<?xml version='1.0' encoding='UTF-8'?>
<hotspot_log version='160 1' process='3870968' time_ms='1684143556925'>
<vm_version>
<name>
OpenJDK 64-Bit Server VM
</name>
<release>
17.0.8-internal+0-adhoc.zhangdingli.riscv-port-jdk17u
</release>
<info>
OpenJDK 64-Bit Server VM (fastdebug 17.0.8-internal+0-adhoc.zhangdingli.riscv-port-jdk17u) for linux-riscv64 JRE (17.0.8-internal+0-adhoc.zhangdingli.riscv-port-jdk17u), built on May 15 2023 09:09:03 by &quot;zhangdingli&quot; with gcc 9.2.0
</info>
</vm_version>
<vm_arguments>
<args>
-Dtest.vm.opts=-Djdk.lang.Process.launchMechanism=vfork -Dtest.tool.vm.opts=-J-Djdk.lang.Process.launchMechanism=vfork -Dtest.compiler.opts= -Dtest.java.opts=-XX:+UnlockExperimentalVMOptions -XX:+UseZbb -XX:+PrintOptoAssembly -XX:LogFile=/home/zhangdingli/riscv-port-jdk17u/TestMinMaxIntrinsics_opto_20230515_prenozbb.log -Dtest.jdk=/home/zhangdingli/riscv-port-jdk17u/build/linux-riscv64-server-fastdebug/jdk -Dcompile.jdk=/home/zhangdingli/riscv-port-jdk17u/build/linux-x86_64-server-release/images/jdk -Dtest.timeout.factor=16.0 -Dtest.root=/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg -Dtest.name=compiler/intrinsics/math/TestMinMaxIntrinsics.java -Dtest.file=/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg/compiler/intrinsics/math/TestMinMaxIntrinsics.java -Dtest.src=/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg/compiler/intrinsics/math -Dtest.src.path=/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg/compiler/intrinsics/math:/home/zhangdingli/riscv-port-jdk17u/test/lib:/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg -Dtest.classes=/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0/compiler/intrinsics/math/TestMinMaxIntrinsics.d -Dtest.class.path=/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0/compiler/intrinsics/math/TestMinMaxIntrinsics.d:/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0/test/lib:/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0 -Dtest.modules=java.base/jdk.internal.misc --add-modules=java.base --add-exports=java.base/jdk.internal.misc=ALL-UNNAMED -Djdk.lang.Process.launchMechanism=vfork -XX:+UnlockExperimentalVMOptions -XX:+UseZbb -XX:+PrintOptoAssembly -XX:LogFile=/home/zhangdingli/riscv-port-jdk17u/TestMinMaxIntrinsics_opto_20230515_prenozbb.log -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-BackgroundCompilation -XX:-UseOnStackReplacement </args>
<command>
com.sun.javatest.regtest.agent.MainWrapper /home/zhangdingli/riscv-port-jdk17u/JTwork/compiler/intrinsics/math/TestMinMaxIntrinsics.d/main.4.jta
</command>
<launcher>
SUN_STANDARD
</launcher>
<properties>
java.vm.specification.name=Java Virtual Machine Specification
java.vm.version=17.0.8-internal+0-adhoc.zhangdingli.riscv-port-jdk17u
java.vm.name=OpenJDK 64-Bit Server VM
jdk.debug=fastdebug
sun.boot.library.path=/home/zhangdingli/riscv-port-jdk17u/build/linux-riscv64-server-fastdebug/jdk/lib
java.library.path=/usr/java/packages/lib:/usr/lib64:/lib64:/lib:/usr/lib
java.home=/home/zhangdingli/riscv-port-jdk17u/build/linux-riscv64-server-fastdebug/jdk
java.class.path=/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0/compiler/intrinsics/math/TestMinMaxIntrinsics.d:/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg/compiler/intrinsics/math:/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0/test/lib:/home/zhangdingli/riscv-port-jdk17u/test/lib:/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0:/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg:/home/zhangdingli/jdk-tools/jtreg-6+1-riscv64fix/lib/javatest.jar:/home/zhangdingli/jdk-tools/jtreg-6+1-riscv64fix/lib/jtreg.jar
jdk.boot.class.path.append=:.
java.vm.info=mixed mode, sharing
java.vm.specification.vendor=Oracle Corporation
java.vm.specification.version=17
java.vm.vendor=Oracle Corporation
test.vm.opts=-Djdk.lang.Process.launchMechanism=vfork
test.tool.vm.opts=-J-Djdk.lang.Process.launchMechanism=vfork
test.compiler.opts=
test.java.opts=-XX:+UnlockExperimentalVMOptions -XX:+UseZbb -XX:+PrintOptoAssembly -XX:LogFile=/home/zhangdingli/riscv-port-jdk17u/TestMinMaxIntrinsics_opto_20230515_prenozbb.log
test.jdk=/home/zhangdingli/riscv-port-jdk17u/build/linux-riscv64-server-fastdebug/jdk
compile.jdk=/home/zhangdingli/riscv-port-jdk17u/build/linux-x86_64-server-release/images/jdk
test.timeout.factor=16.0
test.root=/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg
test.name=compiler/intrinsics/math/TestMinMaxIntrinsics.java
test.file=/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg/compiler/intrinsics/math/TestMinMaxIntrinsics.java
test.src=/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg/compiler/intrinsics/math
test.src.path=/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg/compiler/intrinsics/math:/home/zhangdingli/riscv-port-jdk17u/test/lib:/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg
test.classes=/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0/compiler/intrinsics/math/TestMinMaxIntrinsics.d
test.class.path=/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0/compiler/intrinsics/math/TestMinMaxIntrinsics.d:/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0/test/lib:/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0
test.modules=java.base/jdk.internal.misc
jdk.lang.Process.launchMechanism=vfork
sun.java.command=com.sun.javatest.regtest.agent.MainWrapper /home/zhangdingli/riscv-port-jdk17u/JTwork/compiler/intrinsics/math/TestMinMaxIntrinsics.d/main.4.jta
sun.java.launcher=SUN_STANDARD
</properties>
</vm_arguments>
<tty>
<writer thread='3870970'/>
<blob name='MethodHandlesAdapterBlob' size='152448'>
<sect index='1' size='152448' free='150668'/>
</blob>
<writer thread='3870982'/>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='16'>
----------------------- MetaData before Compile_id = 16 ------------------------
{method}
 - this oop:          0x0000004096000518
 - method holder:     &apos;java/lang/Object&apos;
 - constants:         0x00000040960000d0 constant pool [92] {0x00000040960000d0} for &apos;java/lang/Object&apos; cache=0x000000409613ea08
 - access:            0x81000001  public 
 - name:              &apos;&lt;init&gt;&apos;
 - signature:         &apos;()V&apos;
 - max stack:         1
 - max locals:        1
 - size of params:    1
 - method size:       13
 - intrinsic id:      337 _Object_init
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4ac200
 - code size:         1
 - code start:        0x00000040960004f8
 - code end (excl):   0x00000040960004f9
 - method data:       0x00000040962523b8
 - checked ex length: 0
 - linenumber start:  0x00000040960004f9
 - localvar length:   1
 - localvar start:    0x0000004096000502
 - compiled code: nmethod   2068    1       3       java.lang.Object::&lt;init&gt; (1 bytes)

------------------------ OptoAssembly for Compile_id = 16 -----------------------
#
#  void ( java/lang/Object:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/Object:NotNull *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N13: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N13 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
054 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='66'>
----------------------- MetaData before Compile_id = 66 ------------------------
{method}
 - this oop:          0x0000004096009ee8
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;charAt&apos;
 - signature:         &apos;(I)C&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bb30: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c4ad600
 - code size:         25
 - code start:        0x0000004096009ea8
 - code end (excl):   0x0000004096009ec1
 - method data:       0x000000409630c3c0
 - checked ex length: 0
 - linenumber start:  0x0000004096009ec1
 - localvar length:   2
 - localvar start:    0x0000004096009ece
 - compiled code: nmethod   3099    4       3       java.lang.String::charAt (25 bytes)

------------------------ OptoAssembly for Compile_id = 66 -----------------------
#
#  char ( java/lang/String:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N66: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B5 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
040 +   lb  R29, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
044 +   decode_heap_oop  R7, R7	#@decodeHeapOop
048 +   bne  R29, zr, B5	#@cmpI_reg_imm0_branch  P=0.000000 C=15897.000000

04c     B2: #	out( B7 B3 ) &lt;- in( B1 )  Freq: 1
04c     lwu  R28, [R7, #12]	# range, #@loadRange
050     NullCheck R7

050     B3: #	out( B6 B4 ) &lt;- in( B2 )  Freq: 0.999999
050 +   bgeu  R12, R28, B6	#@cmpU_branch  P=0.000000 C=14591.000000

054     B4: #	out( N66 ) &lt;- in( B3 )  Freq: 0.999998
054 +   addw  R28, R12, zr	#@convI2L_reg_reg
058 +   add R7, R7, R28	# ptr, #@addP_reg_reg
05c +   lbu  R10, [R7, #16]	# byte, #@loadUB
060     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
078 +   ret	// return register, #@Ret

07c     B5: #	out( N66 ) &lt;- in( B1 )  Freq: 5e-07
07c +   spill R11 -&gt; R8	# spill size = 64
080 +   spill R12 -&gt; [sp, #0]	# spill size = 32
084 +   spill R29 -&gt; [sp, #4]	# spill size = 32
088 +   li R11, #-187	# int, #@loadConI
08c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #4
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop off=144/0x90}
090     #@ShouldNotReachHere

09c     B6: #	out( N66 ) &lt;- in( B3 )  Freq: 4.76836e-07
09c +   li R11, #-27	# int, #@loadConI
0a0     spill R7 -&gt; R8	# spill size = 64
0a4 +   spill R12 -&gt; [sp, #4]	# spill size = 32
0a8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:1 (line 47) L[0]=R8 L[1]=sp + #4 STK[0]=sp + #4
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=172/0xac}
0ac     #@ShouldNotReachHere

0b8     B7: #	out( N66 ) &lt;- in( B2 )  Freq: 1.01328e-06
0b8 +   li R11, #-10	# int, #@loadConI
0bc     spill R7 -&gt; R8	# spill size = 64
0c0 +   spill R12 -&gt; [sp, #4]	# spill size = 32
0c4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::charAt @ bci:1 (line 47) L[0]=R8 L[1]=sp + #4 STK[0]=sp + #4
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=200/0xc8}
0c8 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>
<writer thread='3870970'/>
<dependency_failed type='unique_concrete_method_4' ctxk='java/util/concurrent/ConcurrentHashMap$Node' x='java.util.concurrent.ConcurrentHashMap$Node find (ILjava/lang/Object;)Ljava/util/concurrent/ConcurrentHashMap$Node;' x2='java/util/concurrent/ConcurrentHashMap$Node' x3='java.util.concurrent.ConcurrentHashMap$Node find (ILjava/lang/Object;)Ljava/util/concurrent/ConcurrentHashMap$Node;' witness='java/util/concurrent/ConcurrentHashMap$ReservationNode' stamp='3.265'/>
<writer thread='3870982'/>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='78'>
----------------------- MetaData before Compile_id = 78 ------------------------
{method}
 - this oop:          0x000000409638b398
 - method holder:     &apos;jdk/internal/org/objectweb/asm/SymbolTable&apos;
 - constants:         0x0000004096388ec8 constant pool [594] {0x0000004096388ec8} for &apos;jdk/internal/org/objectweb/asm/SymbolTable&apos; cache=0x000000409638e840
 - access:            0x81000002  private 
 - name:              &apos;get&apos;
 - signature:         &apos;(I)Ljdk/internal/org/objectweb/asm/SymbolTable$Entry;&apos;
 - max stack:         4
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bb30: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c4afc80
 - code size:         13
 - code start:        0x000000409638b368
 - code end (excl):   0x000000409638b375
 - method data:       0x00000040963c5de0
 - checked ex length: 0
 - linenumber start:  0x000000409638b375
 - localvar length:   2
 - localvar start:    0x000000409638b37e
 - compiled code: nmethod   3308   20       3       jdk.internal.org.objectweb.asm.SymbolTable::get (13 bytes)

------------------------ OptoAssembly for Compile_id = 78 -----------------------
#
#  jdk/internal/org/objectweb/asm/SymbolTable$Entry * ( jdk/internal/org/objectweb/asm/SymbolTable:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: jdk/internal/org/objectweb/asm/SymbolTable:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N62: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B7 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #44]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/org/objectweb/asm/SymbolTable.entries
040 +   decode_heap_oop  R7, R7	#@decodeHeapOop
044     lwu  R28, [R7, #12]	# range, #@loadRange
048     NullCheck R7

048     B2: #	out( B6 B3 ) &lt;- in( B1 )  Freq: 0.999999
048 +   bleu  R28, zr, B6	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

04c     B3: #	out( B5 B4 ) &lt;- in( B2 )  Freq: 0.999998
04c +   remw  R8, R12, R28	#@modI
050 +   bgeu  R8, R28, B5	#@cmpU_branch  P=0.000001 C=-1.000000

054     B4: #	out( N62 ) &lt;- in( B3 )  Freq: 0.999997
054 +   addw  R28, R8, zr	#@convI2L_reg_reg
058 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
05c +   add R7, R7, R28	# ptr, #@addP_reg_reg
060 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN
064 +   decode_heap_oop  R10, R28	#@decodeHeapOop
068     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
080 +   ret	// return register, #@Ret

084     B5: #	out( N62 ) &lt;- in( B3 )  Freq: 1.01328e-06
084 +   li R11, #-28	# int, #@loadConI
088     spill R7 -&gt; [sp, #0]	# spill size = 64
08c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.org.objectweb.asm.SymbolTable::get @ bci:11 (line 425) L[0]=_ L[1]=_ STK[0]=sp + #0 STK[1]=R8
        # OopMap {[0]=Oop off=144/0x90}
090     #@ShouldNotReachHere

09c     B6: #	out( N62 ) &lt;- in( B2 )  Freq: 9.99999e-07
09c +   li R11, #-122	# int, #@loadConI
0a0     spill R12 -&gt; R8	# spill size = 32
0a4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;div0_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.org.objectweb.asm.SymbolTable::get @ bci:10 (line 425) L[0]=_ L[1]=_ STK[0]=_ STK[1]=R8 STK[2]=#0
        # OopMap {off=168/0xa8}
0a8     #@ShouldNotReachHere

0b4     B7: #	out( N62 ) &lt;- in( B1 )  Freq: 1.01328e-06
0b4 +   li R11, #-10	# int, #@loadConI
0b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.org.objectweb.asm.SymbolTable::get @ bci:9 (line 425) L[0]=_ L[1]=_ STK[0]=_ STK[1]=_ STK[2]=#NULL
        # OopMap {off=188/0xbc}
0bc +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='105'>
----------------------- MetaData before Compile_id = 105 ------------------------
{method}
 - this oop:          0x000000409600fcd8
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000000  
 - name:              &apos;isLatin1&apos;
 - signature:         &apos;()Z&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4ac600
 - code size:         19
 - code start:        0x000000409600fcb0
 - code end (excl):   0x000000409600fcc3
 - method data:       0x00000040962e09d0
 - checked ex length: 0
 - linenumber start:  0x000000409600fcc3
 - localvar length:   1
 - localvar start:    0x000000409600fcca
 - compiled code: nmethod   3678    2       3       java.lang.String::isLatin1 (19 bytes)

------------------------ OptoAssembly for Compile_id = 105 -----------------------
#
#  bool ( java/lang/String:NotNull:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N28: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B3 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     lb  R28, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
040 +   bne  R28, zr, B3	#@cmpI_reg_imm0_branch  P=0.000000 C=24831.000000

044     B2: #	out( N28 ) &lt;- in( B1 )  Freq: 1
044 +   li R10, #1	# int, #@loadConI
048     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
060 +   ret	// return register, #@Ret

064     B3: #	out( N28 ) &lt;- in( B1 )  Freq: 5e-07
064 +   li R11, #-187	# int, #@loadConI
068     spill R28 -&gt; R8	# spill size = 32
06c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=R8
        # OopMap {off=112/0x70}
070 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='129'>
----------------------- MetaData before Compile_id = 129 ------------------------
{method}
 - this oop:          0x00000040962b7238
 - method holder:     &apos;sun/nio/fs/UnixPath&apos;
 - constants:         0x00000040962b5440 constant pool [472] {0x00000040962b5440} for &apos;sun/nio/fs/UnixPath&apos; cache=0x00000040962ba1a0
 - access:            0xf1000002  private 
 - name:              &apos;initOffsets&apos;
 - signature:         &apos;()V&apos;
 - max stack:         4
 - max locals:        6
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4eac80
 - code size:         189
 - code start:        0x00000040962b70f8
 - code end (excl):   0x00000040962b71b5
 - method data:       0x00000040965eb628
 - checked ex length: 0
 - linenumber start:  0x00000040962b71b5
 - localvar length:   6
 - localvar start:    0x00000040962b71dc
 - compiled code: nmethod   4261  110   !   3       sun.nio.fs.UnixPath::initOffsets (189 bytes)

------------------------ OptoAssembly for Compile_id = 129 -----------------------
#
#  void ( sun/nio/fs/UnixPath:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixPath:NotNull *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: Fixed slot 3
#r258 sp+40: Fixed slot 2
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1045: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B3 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lwu  R28, [R11, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
040 +   #@membar_acquire
	fence ir iorw
044 +   spill R11 -&gt; [sp, #0]	# spill size = 64
048 +   beq   R28, zr, B3	#@cmpP_narrowOop_imm0_branch  P=0.045921 C=2047.000000

04c     B2: #	out( N1045 ) &lt;- in( B81 B80 B1 )  Freq: 0.999995
04c     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

068     B3: #	out( B113 B4 ) &lt;- in( B1 )  Freq: 0.0459208
068 +   lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
06c +   decode_heap_oop  R8, R7	#@decodeHeapOop
070     lwu  R30, [R8, #12]	# range, #@loadRange
074     NullCheck R8

074     B4: #	out( B107 B5 ) &lt;- in( B3 )  Freq: 0.0459208
074 +   addiw  R28, R30, #-1	#@addI_reg_imm
078 +   bleu  R30, zr, B107	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

07c     B5: #	out( B106 B6 ) &lt;- in( B4 )  Freq: 0.0459208
07c +   bgeu  R28, R30, B106	#@cmpU_branch  P=0.000001 C=-1.000000

080     B6: #	out( B13 ) &lt;- in( B5 )  Freq: 0.0459207
080 +   addiw  R10, R30, #-3	#@addI_reg_imm
084 +   li R13, #1	# int, #@loadConI
088 +   li R31, #0	# int, #@loadConI
08c +   li R7, #0	# int, #@loadConI
090 +   j  B13	#@branch

094     B7: #	out( B11 ) &lt;- in( B29 )  Freq: 0.0707626
094 +   addiw  R31, R31, #3	#@addI_reg_imm
098 +   j  B11	#@branch

09c     B8: #	out( B11 ) &lt;- in( B28 )  Freq: 0.0781676
09c +   addiw  R31, R31, #2	#@addI_reg_imm
0a0 +   j  B11	#@branch

0a4     B9: #	out( B11 ) &lt;- in( B27 )  Freq: 0.0863475
0a4 +   addiw  R31, R31, #1	#@addI_reg_imm
0a8 +   j  B11	#@branch

0ac     B10: #	out( B11 ) &lt;- in( B14 )  Freq: 0.380803
0ac +   spill R13 -&gt; R31	# spill size = 32

0b0     B11: #	out( B38 B12 ) &lt;- in( B36 B32 B34 B37 B26 B8 B9 B7 B82 B10 ) top-of-loop Freq: 0.785988
0b0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0b0     ld  R28, [R23, #920]	# ptr, #@loadP
0b4 +   lwu zr, [R28]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.UnixPath::initOffsets @ bci:77 (line 190) L[0]=sp + #0 L[1]=R7 L[2]=R31 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=180/0xb4}
0b8 +   bge  R31, R30, B38	#@cmpI_branch  P=0.058421 C=1515.000000

0bc     B12: #	out( B13 ) &lt;- in( B11 )  Freq: 0.74007
0bc +   addiw  R13, R31, #1	#@addI_reg_imm

0c0     B13: #	out( B93 B14 ) &lt;- in( B6 B12 ) Loop( B13-B12 ) Freq: 0.78599
0c0 +   addw  R28, R31, zr	#@convI2L_reg_reg
0c4 +   add R28, R8, R28	# ptr, #@addP_reg_reg
0c8 +   bgeu  R31, R30, B93	#@cmpU_branch  P=0.000001 C=-1.000000

0cc     B14: #	out( B10 B15 ) &lt;- in( B13 )  Freq: 0.785989
0cc +   lb  R28, [R28, #16]	# byte, #@loadB
0d0 +   li R31, #47	# int, #@loadConI
0d4 +   beq  R28, R31, B10	#@cmpI_branch  P=0.484488 C=1515.000000

0d8     B15: #	out( B82 B16 ) &lt;- in( B14 )  Freq: 0.405187
0d8 +   addiw  R7, R7, #1	#@addI_reg_imm
0dc +   bge  R13, R30, B82	#@cmpI_branch  P=0.012796 C=7346.000000

0e0     B16: #	out( B96 B17 ) &lt;- in( B15 )  Freq: 0.400002
0e0 +   bgeu  R13, R30, B96	#@cmpU_branch  P=0.000001 C=-1.000000

0e4     B17: #	out( B18 ) &lt;- in( B16 )  Freq: 0.400001
0e4 +   addiw  R29, R13, #1	#@addI_reg_imm

0e8     B18: #	out( B37 B19 ) &lt;- in( B17 B20 ) Loop( B18-B20 inner pre of N1028) Freq: 0.730775
0e8 +   addw  R28, R13, zr	#@convI2L_reg_reg
0ec +   add R28, R8, R28	# ptr, #@addP_reg_reg
0f0 +   lb  R28, [R28, #16]	# byte, #@loadB
0f4 +   li R31, #47	# int, #@loadConI
0f8 +   beq  R28, R31, B37	#@cmpI_branch  P=0.094732 C=7252.000000

0fc     B19: #	out( B21 B20 ) &lt;- in( B18 )  Freq: 0.661547
0fc +   addiw  R11, R13, #1	#@addI_reg_imm
100 +   bge  R11, R29, B21	#@cmpI_loop  P=0.500000 C=6565.000000

104     B20: #	out( B18 ) &lt;- in( B19 )  Freq: 0.330773
104 +   spill R11 -&gt; R13	# spill size = 32
108 +   j  B18	#@branch

10c     B21: #	out( B98 B22 ) &lt;- in( B19 )  Freq: 0.330773
10c +   bge  R11, R10, B98	#@cmpI_branch  P=0.000001 C=-1.000000

110     B22: #	out( B99 B23 ) &lt;- in( B21 )  Freq: 0.330773
110 +   spill R11 -&gt; R31	# spill size = 32
114 +   addiw  R28, R13, #4	#@addI_reg_imm
118 +   # castII of R31, #@castII
118     bgeu  R31, R30, B99	#@cmpU_branch  P=0.000001 C=-1.000000

11c     B23: #	out( B100 B24 ) &lt;- in( B22 )  Freq: 0.330773
11c +   bgeu  R11, R30, B100	#@cmpU_branch  P=0.000001 C=-1.000000

120     B24: #	out( B101 B25 ) &lt;- in( B23 )  Freq: 0.330772
120 +   bgeu  R28, R30, B101	#@cmpU_branch  P=0.000001 C=-1.000000

124     B25: #	out( B26 ) &lt;- in( B24 B31 ) Loop( B25-B31 ) Freq: 0.339314
124 +   subw  R29, R30, R31	#@subI_reg_reg
128 +   li R11, #0	# int, #@loadConI
12c +   addiw  R28, R29, #-3	#@addI_reg_imm
130     CMove R28, (R10 lt R31), R28, R11	#@cmovI_cmpI
	
138 +   li R12, #4000	# int, #@loadConI
140 +   li R29, #4000	# int, #@loadConI
148     CMove R28, (R28 gtu R29), R28, R12	#@cmovI_cmpU
	
150 +   addw  R29, R28, R31	#@addI_reg_reg
        nop 	# 6 bytes pad for loops and calls

160     B26: #	out( B11 B27 ) &lt;- in( B25 B30 ) Loop( B26-B30 inner main of N109 strip mined) Freq: 1.00687
160 +   addw  R28, R31, zr	#@convI2L_reg_reg
164 +   add R28, R8, R28	# ptr, #@addP_reg_reg
168 +   lb  R11, [R28, #16]	# byte, #@loadB
16c +   li R12, #47	# int, #@loadConI
170 +   beq  R11, R12, B11	#@cmpI_branch  P=0.094732 C=7252.000000

174     B27: #	out( B9 B28 ) &lt;- in( B26 )  Freq: 0.911488
174 +   lb  R12, [R28, #17]	# byte, #@loadB
178 +   li R13, #47	# int, #@loadConI
17c +   beq  R12, R13, B9	#@cmpI_branch  P=0.094732 C=7252.000000

180     B28: #	out( B8 B29 ) &lt;- in( B27 )  Freq: 0.825141
180 +   lb  R11, [R28, #18]	# byte, #@loadB
184 +   li R12, #47	# int, #@loadConI
188 +   beq  R11, R12, B8	#@cmpI_branch  P=0.094732 C=7252.000000

18c     B29: #	out( B7 B30 ) &lt;- in( B28 )  Freq: 0.746973
18c +   lb  R11, [R28, #19]	# byte, #@loadB
190 +   beq  R11, R12, B7	#@cmpI_branch  P=0.094732 C=7252.000000

194     B30: #	out( B26 B31 ) &lt;- in( B29 )  Freq: 0.676211
194 +   addiw  R31, R31, #4	#@addI_reg_imm
198 +   blt  R31, R29, B26	#@cmpI_loop  P=0.987204 C=6565.000000

19c     B31: #	out( B25 B32 ) &lt;- in( B30 )  Freq: 0.00865286
19c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
19c     ld  R11, [R23, #920]	# ptr, #@loadP
1a0 +   lwu zr, [R11]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.UnixPath::initOffsets @ bci:74 (line 188) L[0]=sp + #0 L[1]=R7 L[2]=R31 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=416/0x1a0}
1a4 +   blt  R31, R10, B25	#@cmpI_branch  P=0.987204 C=6565.000000

1a8     B32: #	out( B11 B33 ) &lt;- in( B98 B31 )  Freq: 0.000111058
1a8 +   bge  R31, R30, B11	#@cmpI_branch  P=0.500000 C=-1.000000

1ac     B33: #	out( B111 B34 ) &lt;- in( B32 )  Freq: 5.5529e-05
1ac +   # castII of R31, #@castII
1ac     bgeu  R31, R30, B111	#@cmpU_branch  P=0.000001 C=-1.000000

1b0     B34: #	out( B11 B35 ) &lt;- in( B33 B35 ) Loop( B34-B35 inner post of N1028) Freq: 0.000101448
1b0 +   addw  R28, R31, zr	#@convI2L_reg_reg
1b4 +   add R28, R8, R28	# ptr, #@addP_reg_reg
1b8 +   lb  R28, [R28, #16]	# byte, #@loadB
1bc +   li R29, #47	# int, #@loadConI
1c0 +   beq  R28, R29, B11	#@cmpI_branch  P=0.094732 C=7252.000000

1c4     B35: #	out( B34 B36 ) &lt;- in( B34 )  Freq: 9.18372e-05
1c4 +   addiw  R31, R31, #1	#@addI_reg_imm
1c8 +   blt  R31, R30, B34	#@cmpI_loop  P=0.500000 C=6565.000000

1cc     B36: #	out( B11 ) &lt;- in( B35 )  Freq: 4.59186e-05
1cc +   j  B11	#@branch

1d0     B37: #	out( B11 ) &lt;- in( B18 )  Freq: 0.0692281
1d0 +   spill R13 -&gt; R31	# spill size = 32
1d4 +   j  B11	#@branch

1d8     B38: #	out( B39 B39 ) &lt;- in( B11 )  Freq: 0.0459185
1d8 +   li R29, #262144	# int, #@loadConI
1dc +   addw  R28, R7, zr	#@convI2L_reg_reg
1e0 +   bleu  R7, R29, B39	#@cmpU_branch  P=0.999999 C=-1.000000

1e4     B39: #	out( B91 B40 ) &lt;- in( B38 B38 )  Freq: 0.0459185
1e4 +   bgtu  R7, R29, B91	#@cmpU_branch  P=0.000001 C=-1.000000

1e8     B40: #	out( B91 B41 ) &lt;- in( B39 )  Freq: 0.0459185
1e8 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
1ec +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ec     ld  R29, [R23, #288]	# ptr, #@loadP
1f0 +   addi  R28, R28, #23	#@addL_reg_imm
1f4     spill R29 -&gt; R31	# spill size = 64
1f8 +   andi  R29, R28, #-8	#@andL_reg_imm
1fc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1fc     ld  R11, [R23, #304]	# ptr, #@loadP
200 +   add R29, R31, R29	# ptr, #@addP_reg_reg
204 +   bgeu  R29, R11, B91	#@cmpP_branch  P=0.000100 C=-1.000000

208     B41: #	out( B42 ) &lt;- in( B40 )  Freq: 0.0459139
208 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
208     sd  R29, [R23, #288]	# ptr, #@storeP
20c +   li R29, #1	# long, #@loadConL
210 +   sd  R29, [R31]	# long, #@storeL
214 +   mv  R29, narrowklass: precise klass [I: 0x00000040d001b7c0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
224 +   sw  R29, [R31, #8]	# compressed klass ptr, #@storeNKlass
228 +   srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
22c     spill R31 -&gt; R28	# spill size = 64
230 +   addi  R28, R31, #16	# ptr, #@addP_reg_imm
234 +   addi  R29, R29, #-2	#@addL_reg_imm
238 +   sw  R7, [R31, #12]	# int, #@storeI
23c +   ClearArray R29, R28	#@clearArray_reg_reg

294     B42: #	out( B49 ) &lt;- in( B92 B41 )  Freq: 0.0459185
294     
294     MEMBAR-store-store	#@membar_storestore
298 +   spill R31 -&gt; R28	# spill size = 64
29c +   # checkcastPP of R28, #@checkCastPP
29c     li R12, #0	# int, #@loadConI
2a0     spill R28 -&gt; [sp, #24]	# spill size = 64
2a4 +   li R28, #0	# int, #@loadConI
2a8 +   # castII of R7, #@castII
2a8     j  B49	#@branch

2ac     B43: #	out( B47 ) &lt;- in( B66 )  Freq: 0.0707586
2ac +   addiw  R12, R12, #3	#@addI_reg_imm
2b0 +   j  B47	#@branch

2b4     B44: #	out( B47 ) &lt;- in( B65 )  Freq: 0.0781631
2b4 +   addiw  R12, R12, #2	#@addI_reg_imm
2b8 +   j  B47	#@branch

2bc     B45: #	out( B47 ) &lt;- in( B64 )  Freq: 0.0863426
2bc +   addiw  R12, R12, #1	#@addI_reg_imm
2c0 +   j  B47	#@branch

2c4     B46: #	out( B47 ) &lt;- in( B50 )  Freq: 0.380781
2c4 +   spill R31 -&gt; R12	# spill size = 32
2c8 +   spill R28 -&gt; R14	# spill size = 32

2cc     B47: #	out( B75 B48 ) &lt;- in( B73 B69 B71 B74 B63 B44 B45 B43 B83 B46 ) top-of-loop Freq: 0.785943
2cc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2cc     ld  R29, [R23, #920]	# ptr, #@loadP
2d0 +   lwu zr, [R29]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.UnixPath::initOffsets @ bci:154 (line 206) L[0]=sp + #0 L[1]=R14 L[2]=R12 L[3]=sp + #24 L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [24]=Oop off=720/0x2d0}
2d4 +   bge  R12, R30, B75	#@cmpI_branch  P=0.058421 C=1515.000000

2d8     B48: #	out( B49 ) &lt;- in( B47 )  Freq: 0.740027
2d8 +   spill R14 -&gt; R28	# spill size = 32

2dc     B49: #	out( B94 B50 ) &lt;- in( B42 B48 ) Loop( B49-B48 ) Freq: 0.785946
2dc +   addw  R29, R12, zr	#@convI2L_reg_reg
2e0 +   add R29, R8, R29	# ptr, #@addP_reg_reg
2e4 +   bgeu  R12, R30, B94	#@cmpU_branch  P=0.000001 C=-1.000000

2e8     B50: #	out( B46 B51 ) &lt;- in( B49 )  Freq: 0.785945
2e8 +   lb  R29, [R29, #16]	# byte, #@loadB
2ec +   li R13, #47	# int, #@loadConI
2f0 +   addiw  R31, R12, #1	#@addI_reg_imm
2f4 +   beq  R29, R13, B46	#@cmpI_branch  P=0.484488 C=1515.000000

2f8     B51: #	out( B95 B52 ) &lt;- in( B50 )  Freq: 0.405164
2f8 +   addw  R29, R28, zr	#@convI2L_reg_reg
2fc +   slli  R29, R29, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
300 +   addiw  R14, R28, #1	#@addI_reg_imm
304     spill [sp, #24] -&gt; R11	# spill size = 64
308 +   add R29, R11, R29	# ptr, #@addP_reg_reg
30c +   bgeu  R28, R7, B95	#@cmpU_branch  P=0.000001 C=-1.000000

310     B52: #	out( B83 B53 ) &lt;- in( B51 )  Freq: 0.405163
310 +   sw  R12, [R29, #16]	# int, #@storeI
314 +   bge  R31, R30, B83	#@cmpI_branch  P=0.012796 C=7346.000000

318     B53: #	out( B97 B54 ) &lt;- in( B52 )  Freq: 0.399979
318 +   bgeu  R31, R30, B97	#@cmpU_branch  P=0.000001 C=-1.000000

31c     B54: #	out( B55 ) &lt;- in( B53 )  Freq: 0.399978
31c +   addiw  R28, R12, #2	#@addI_reg_imm

320     B55: #	out( B74 B56 ) &lt;- in( B54 B57 ) Loop( B55-B57 inner pre of N1039) Freq: 0.730733
320 +   addw  R29, R31, zr	#@convI2L_reg_reg
324 +   add R29, R8, R29	# ptr, #@addP_reg_reg
328 +   lb  R11, [R29, #16]	# byte, #@loadB
32c +   li R29, #47	# int, #@loadConI
330 +   beq  R11, R29, B74	#@cmpI_branch  P=0.094732 C=7252.000000

334     B56: #	out( B58 B57 ) &lt;- in( B55 )  Freq: 0.661509
334 +   addiw  R29, R31, #1	#@addI_reg_imm
338 +   bge  R29, R28, B58	#@cmpI_loop  P=0.500000 C=6565.000000

33c     B57: #	out( B55 ) &lt;- in( B56 )  Freq: 0.330754
33c +   spill R29 -&gt; R31	# spill size = 32
340 +   j  B55	#@branch

344     B58: #	out( B102 B59 ) &lt;- in( B56 )  Freq: 0.330754
344 +   bge  R29, R10, B102	#@cmpI_branch  P=0.000001 C=-1.000000

348     B59: #	out( B103 B60 ) &lt;- in( B58 )  Freq: 0.330754
348 +   spill R29 -&gt; R12	# spill size = 32
34c +   addiw  R31, R31, #4	#@addI_reg_imm
350 +   # castII of R12, #@castII
350     bgeu  R12, R30, B103	#@cmpU_branch  P=0.000001 C=-1.000000

354     B60: #	out( B104 B61 ) &lt;- in( B59 )  Freq: 0.330754
354 +   bgeu  R29, R30, B104	#@cmpU_branch  P=0.000001 C=-1.000000

358     B61: #	out( B105 B62 ) &lt;- in( B60 )  Freq: 0.330753
358 +   bgeu  R31, R30, B105	#@cmpU_branch  P=0.000001 C=-1.000000

35c     B62: #	out( B63 ) &lt;- in( B61 B68 ) Loop( B62-B68 ) Freq: 0.339295
35c +   subw  R28, R30, R12	#@subI_reg_reg
360 +   li R31, #0	# int, #@loadConI
364 +   addiw  R29, R28, #-3	#@addI_reg_imm
368     CMove R29, (R10 lt R12), R29, R31	#@cmovI_cmpI
	
370 +   li R11, #4000	# int, #@loadConI
378 +   li R28, #4000	# int, #@loadConI
380     CMove R29, (R29 gtu R28), R29, R11	#@cmovI_cmpU
	
388 +   addw  R28, R29, R12	#@addI_reg_reg
        nop 	# 2 bytes pad for loops and calls

390     B63: #	out( B47 B64 ) &lt;- in( B62 B67 ) Loop( B63-B67 inner main of N286 strip mined) Freq: 1.00681
390 +   addw  R29, R12, zr	#@convI2L_reg_reg
394 +   add R29, R8, R29	# ptr, #@addP_reg_reg
398 +   lb  R11, [R29, #16]	# byte, #@loadB
39c +   li R31, #47	# int, #@loadConI
3a0 +   beq  R11, R31, B47	#@cmpI_branch  P=0.094732 C=7252.000000

3a4     B64: #	out( B45 B65 ) &lt;- in( B63 )  Freq: 0.911436
3a4 +   lb  R31, [R29, #17]	# byte, #@loadB
3a8 +   li R13, #47	# int, #@loadConI
3ac +   beq  R31, R13, B45	#@cmpI_branch  P=0.094732 C=7252.000000

3b0     B65: #	out( B44 B66 ) &lt;- in( B64 )  Freq: 0.825094
3b0 +   lb  R11, [R29, #18]	# byte, #@loadB
3b4 +   li R31, #47	# int, #@loadConI
3b8 +   beq  R11, R31, B44	#@cmpI_branch  P=0.094732 C=7252.000000

3bc     B66: #	out( B43 B67 ) &lt;- in( B65 )  Freq: 0.74693
3bc +   lb  R29, [R29, #19]	# byte, #@loadB
3c0 +   li R11, #47	# int, #@loadConI
3c4 +   beq  R29, R11, B43	#@cmpI_branch  P=0.094732 C=7252.000000

3c8     B67: #	out( B63 B68 ) &lt;- in( B66 )  Freq: 0.676172
3c8 +   addiw  R12, R12, #4	#@addI_reg_imm
3cc +   blt  R12, R28, B63	#@cmpI_loop  P=0.987204 C=6565.000000

3d0     B68: #	out( B62 B69 ) &lt;- in( B67 )  Freq: 0.00865237
3d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3d0     ld  R11, [R23, #920]	# ptr, #@loadP
3d4 +   lwu zr, [R11]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.UnixPath::initOffsets @ bci:151 (line 204) L[0]=sp + #0 L[1]=R14 L[2]=R12 L[3]=sp + #24 L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [24]=Oop off=980/0x3d4}
3d8 +   blt  R12, R10, B62	#@cmpI_branch  P=0.987204 C=6565.000000

3dc     B69: #	out( B47 B70 ) &lt;- in( B102 B68 )  Freq: 0.000111052
3dc +   bge  R12, R30, B47	#@cmpI_branch  P=0.500000 C=-1.000000

3e0     B70: #	out( B112 B71 ) &lt;- in( B69 )  Freq: 5.55259e-05
3e0 +   # castII of R12, #@castII
3e0     bgeu  R12, R30, B112	#@cmpU_branch  P=0.000001 C=-1.000000

3e4     B71: #	out( B47 B72 ) &lt;- in( B70 B72 ) Loop( B71-B72 inner post of N1039) Freq: 0.000101442
3e4 +   addw  R28, R12, zr	#@convI2L_reg_reg
3e8 +   add R28, R8, R28	# ptr, #@addP_reg_reg
3ec +   lb  R29, [R28, #16]	# byte, #@loadB
3f0 +   li R28, #47	# int, #@loadConI
3f4 +   beq  R29, R28, B47	#@cmpI_branch  P=0.094732 C=7252.000000

3f8     B72: #	out( B71 B73 ) &lt;- in( B71 )  Freq: 9.18319e-05
3f8 +   addiw  R12, R12, #1	#@addI_reg_imm
3fc +   blt  R12, R30, B71	#@cmpI_loop  P=0.500000 C=6565.000000

400     B73: #	out( B47 ) &lt;- in( B72 )  Freq: 4.5916e-05
400 +   j  B47	#@branch

404     B74: #	out( B47 ) &lt;- in( B55 )  Freq: 0.0692241
404 +   spill R31 -&gt; R12	# spill size = 32
408 +   j  B47	#@branch

40c     B75: #	out( B108 B76 ) &lt;- in( B47 )  Freq: 0.0459159
40c     add R29, sp, #32	# box lock
410 +   spill [sp, #0] -&gt; R30	# spill size = 64
414 +   fastlock R30,R29	! kills R28,R7, #@cmpFastLock
4a8 +   far_bne RFLAGS, zr, B108	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

4b0     B76: #	out( B109 B77 ) &lt;- in( B108 B75 )  Freq: 0.0459159
4b0 +   #@membar_acquire_lock (elided)
4b0 +   spill [sp, #0] -&gt; R7	# spill size = 64
4b4 +   lwu  R28, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
4b8 +   #@membar_acquire
	fence ir iorw
4bc +   decode_heap_oop  R8, R28	#@decodeHeapOop
4c0 +   bne   R8, zr, B109	#@cmpP_imm0_branch  P=0.000000 C=94.000000

4c4     B77: #	out( B84 B78 ) &lt;- in( B76 )  Freq: 0.0459159
4c4 +   #@membar_release
	fence iorw ow
4c8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
4c8     lb  R7, [R23, #56]	# byte, #@loadB
4cc +   bne  R7, zr, B84	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

4d0     B78: #	out( B80 B79 ) &lt;- in( B110 B86 B84 B77 )  Freq: 0.0459159
4d0 +   spill [sp, #0] -&gt; R7	# spill size = 64
4d4 +   mv  R7, R7	# ptr -&gt; long, #@castP2X
4d4     spill [sp, #24] -&gt; R28	# spill size = 64
4d8 +   mv  R28, R28	# ptr -&gt; long, #@castP2X
4d8 +   xorr  R28, R28, R7	#@xorL_reg_reg
4dc     spill [sp, #24] -&gt; R29	# spill size = 64
4e0 +   encode_heap_oop  R30, R29	#@encodeHeapOop
4e4 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
4e8     spill [sp, #0] -&gt; R29	# spill size = 64
4ec +   sw  R30, [R29, #28]	# compressed ptr, #@storeN ! Field: volatile sun/nio/fs/UnixPath.offsets
4f0 +   beq  R28, zr, B80	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

4f4     B79: #	out( B87 B80 ) &lt;- in( B78 )  Freq: 0.0458699
4f4 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
4f8 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
504 +   add R10, R28, R7	# ptr, #@addP_reg_reg
508 +   lb  R7, [R10]	# byte, #@loadB
50c +   li R29, #4	# int, #@loadConI
510 +   bne  R7, R29, B87	#@cmpI_branch  P=0.001000 C=-1.000000

514     B80: #	out( B2 B81 ) &lt;- in( B89 B90 B87 B79 B78 )  Freq: 0.0459159
514 +   #@membar_volatile
	fence iorw iorw
518 +   #@membar_release_lock (elided)
518     add R29, sp, #32	# box lock
51c +   spill [sp, #0] -&gt; R30	# spill size = 64
520 +   fastunlock R30,R29	! kills R7, R28, #@cmpFastUnlock
598 +   far_beq RFLAGS, zr, B2	#@far_cmpFlag_branch  P=0.999999 C=-1.000000

5a0     B81: #	out( B2 ) &lt;- in( B80 )  Freq: 4.59159e-08
5a0     add R11, sp, #32	# box lock
5a4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5a4     spill R23 -&gt; R12	# spill size = 64
5a8 +   spill [sp, #0] -&gt; R10	# spill size = 64
5ac +   CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
5dc +   j  B2	#@branch

5e0     B82: #	out( B11 ) &lt;- in( B15 )  Freq: 0.00518481
5e0 +   spill R13 -&gt; R31	# spill size = 32
5e4 +   j  B11	#@branch

5e8     B83: #	out( B47 ) &lt;- in( B52 )  Freq: 0.00518451
5e8 +   spill R31 -&gt; R12	# spill size = 32
5ec +   j  B47	#@branch

5f0     B84: #	out( B78 B85 ) &lt;- in( B77 )  Freq: 4.59153e-05
5f0 +   spill [sp, #0] -&gt; R7	# spill size = 64
5f4 +   lwu  R28, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
5f8 +   decode_heap_oop  R10, R28	#@decodeHeapOop
5fc +   beq   R10, zr, B78	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

600     B85: #	out( B110 B86 ) &lt;- in( B84 )  Freq: 2.29576e-05
600 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
600     ld  R7, [R23, #32]	# int, #@loadL
604 +   beq  R7, zr, B110	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

608     B86: #	out( B78 ) &lt;- in( B85 )  Freq: 2.29347e-05
608 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
608     ld  R28, [R23, #48]	# ptr, #@loadP
60c +   add R28, R28, R7	# ptr, #@addP_reg_reg
610 +   addi  R7, R7, #-8	#@addL_reg_imm
614 +   sd  R10, [R28, #-8]	# ptr, #@storeP
618 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
618     sd  R7, [R23, #32]	# long, #@storeL
61c +   j  B78	#@branch

620     B87: #	out( B80 B88 ) &lt;- in( B79 )  Freq: 4.587e-05
620 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
620     ld  R7, [R23, #64]	# int, #@loadL
624 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
624     ld  R28, [R23, #80]	# ptr, #@loadP
628 +   #@membar_volatile
	fence iorw iorw
62c +   lb  R29, [R10]	# byte, #@loadB
630 +   beq  R29, zr, B80	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

634     B88: #	out( B90 B89 ) &lt;- in( B87 )  Freq: 2.2935e-05
634 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
638 +   bne  R7, zr, B90	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

63c     B89: #	out( B80 ) &lt;- in( B88 )  Freq: 1.14675e-05
63c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
63c     spill R23 -&gt; R11	# spill size = 64
640 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
670 +   j  B80	#@branch

674     B90: #	out( B80 ) &lt;- in( B88 )  Freq: 1.14675e-05
674 +   add R28, R28, R7	# ptr, #@addP_reg_reg
678 +   addi  R7, R7, #-8	#@addL_reg_imm
67c +   sd  R10, [R28, #-8]	# ptr, #@storeP
680 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
680     sd  R7, [R23, #64]	# long, #@storeL
684 +   j  B80	#@branch

688     B91: #	out( B114 B92 ) &lt;- in( B39 B40 )  Freq: 4.63914e-06
688 +   spill R10 -&gt; [sp, #16]	# spill size = 32
68c +   spill R30 -&gt; [sp, #12]	# spill size = 32
690 +   spill R7 -&gt; [sp, #8]	# spill size = 32
694 +   mv  R11, precise klass [I: 0x00000040d001b7c0:Constant:exact *	# ptr, #@loadConP
6ac     spill R7 -&gt; R12	# spill size = 32
6b0     CALL,static 0x000000401390d640	#@CallStaticJavaDirect wrapper for: _new_array_Java
        # sun.nio.fs.UnixPath::initOffsets @ bci:81 (line 194) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=1716/0x6b4}

6b4     B92: #	out( B42 ) &lt;- in( B91 )  Freq: 4.63904e-06
        # Block is sole successor of call
6b4 +   spill R10 -&gt; R28	# spill size = 64
6b8 +   spill [sp, #8] -&gt; R7	# spill size = 32
6bc +   spill [sp, #12] -&gt; R30	# spill size = 32
6c0 +   spill [sp, #16] -&gt; R10	# spill size = 32
6c4 +   spill R28 -&gt; R31	# spill size = 64
6c8 +   j  B42	#@branch

6cc     B93: #	out( N1045 ) &lt;- in( B13 )  Freq: 7.96427e-07
6cc +   li R11, #-28	# int, #@loadConI
6d0     spill R7 -&gt; [sp, #8]	# spill size = 32
6d4 +   spill R13 -&gt; [sp, #12]	# spill size = 32
6d8 +   spill R31 -&gt; [sp, #16]	# spill size = 32
6dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::initOffsets @ bci:40 (line 184) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #12 L[3]=_ L[4]=_ L[5]=_ STK[0]=R8 STK[1]=sp + #16
        # OopMap {fp=Oop [0]=Oop off=1760/0x6e0}
6e0     #@ShouldNotReachHere

6ec     B94: #	out( N1045 ) &lt;- in( B49 )  Freq: 7.96382e-07
6ec +   li R11, #-28	# int, #@loadConI
6f0     spill R12 -&gt; [sp, #12]	# spill size = 32
6f4 +   spill R28 -&gt; [sp, #16]	# spill size = 32
6f8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::initOffsets @ bci:102 (line 198) L[0]=sp + #0 L[1]=sp + #16 L[2]=sp + #12 L[3]=sp + #24 L[4]=_ L[5]=_ STK[0]=R8 STK[1]=sp + #12
        # OopMap {fp=Oop [0]=Oop [24]=Oop off=1788/0x6fc}
6fc     #@ShouldNotReachHere

708     B95: #	out( N1045 ) &lt;- in( B51 )  Freq: 4.10544e-07
708 +   spill [sp, #0] -&gt; R8	# spill size = 64
70c +   li R11, #-28	# int, #@loadConI
710     spill R12 -&gt; [sp, #0]	# spill size = 32
714 +   spill R14 -&gt; [sp, #4]	# spill size = 32
718 +   spill R31 -&gt; [sp, #8]	# spill size = 32
71c +   spill R28 -&gt; [sp, #12]	# spill size = 32
720     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::initOffsets @ bci:127 (line 202) L[0]=R8 L[1]=sp + #4 L[2]=sp + #8 L[3]=sp + #24 L[4]=_ L[5]=_ STK[0]=sp + #24 STK[1]=sp + #12 STK[2]=sp + #0
        # OopMap {fp=Oop [24]=Oop off=1828/0x724}
724     #@ShouldNotReachHere

730     B96: #	out( N1045 ) &lt;- in( B16 )  Freq: 4.05313e-07
730 +   spill [sp, #0] -&gt; R8	# spill size = 64
734 +   li R11, #-138	# int, #@loadConI
738     spill R7 -&gt; [sp, #0]	# spill size = 32
73c +   spill R13 -&gt; [sp, #8]	# spill size = 32
740 +   spill R30 -&gt; [sp, #12]	# spill size = 32
744     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::initOffsets @ bci:57 (line 187) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #8 STK[1]=sp + #12
        # OopMap {fp=Oop off=1864/0x748}
748     #@ShouldNotReachHere

754     B97: #	out( N1045 ) &lt;- in( B53 )  Freq: 4.0529e-07
754 +   spill [sp, #0] -&gt; R8	# spill size = 64
758 +   li R11, #-138	# int, #@loadConI
75c     spill R30 -&gt; [sp, #0]	# spill size = 32
760 +   spill R14 -&gt; [sp, #4]	# spill size = 32
764 +   spill R31 -&gt; [sp, #12]	# spill size = 32
768     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::initOffsets @ bci:134 (line 203) L[0]=R8 L[1]=sp + #4 L[2]=sp + #12 L[3]=sp + #24 L[4]=_ L[5]=_ STK[0]=sp + #12 STK[1]=sp + #0
        # OopMap {fp=Oop [24]=Oop off=1900/0x76c}
76c     #@ShouldNotReachHere

778     B98: #	out( B32 ) &lt;- in( B21 )  Freq: 3.35166e-07
778 +   spill R11 -&gt; R31	# spill size = 32
77c +   j  B32	#@branch

780     B99: #	out( N1045 ) &lt;- in( B22 )  Freq: 3.35165e-07
780     #@ShouldNotReachHere

78c     B100: #	out( N1045 ) &lt;- in( B23 )  Freq: 3.35165e-07
78c     #@ShouldNotReachHere

798     B101: #	out( N1045 ) &lt;- in( B24 )  Freq: 3.35165e-07
798     #@ShouldNotReachHere

7a4     B102: #	out( B69 ) &lt;- in( B58 )  Freq: 3.35146e-07
7a4 +   spill R29 -&gt; R12	# spill size = 32
7a8 +   j  B69	#@branch

7ac     B103: #	out( N1045 ) &lt;- in( B59 )  Freq: 3.35146e-07
7ac     #@ShouldNotReachHere

7b8     B104: #	out( N1045 ) &lt;- in( B60 )  Freq: 3.35146e-07
7b8     #@ShouldNotReachHere

7c4     B105: #	out( N1045 ) &lt;- in( B61 )  Freq: 3.35145e-07
7c4     #@ShouldNotReachHere

7d0     B106: #	out( N1045 ) &lt;- in( B5 )  Freq: 4.65305e-08
7d0 +   spill [sp, #0] -&gt; R8	# spill size = 64
7d4 +   li R11, #-66	# int, #@loadConI
7d8     spill R30 -&gt; [sp, #0]	# spill size = 32
7dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;profile_predicate&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::initOffsets @ bci:29 (line 183) L[0]=R8 L[1]=#0 L[2]=#0 L[3]=_ L[4]=_ L[5]=_ STK[0]=#0 STK[1]=sp + #0
        # OopMap {fp=Oop off=2016/0x7e0}
7e0     #@ShouldNotReachHere

7ec     B107: #	out( N1045 ) &lt;- in( B4 )  Freq: 4.59208e-08
7ec +   li R11, #-187	# int, #@loadConI
7f0     spill [sp, #0] -&gt; R8	# spill size = 64
7f4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::initOffsets @ bci:15 (line 179) L[0]=R8 L[1]=#0 L[2]=#0 L[3]=_ L[4]=_ L[5]=_ STK[0]=#1
        # OopMap {fp=Oop off=2040/0x7f8}
7f8     #@ShouldNotReachHere

804     B108: #	out( B76 ) &lt;- in( B75 )  Freq: 4.59159e-08
804     add R12, sp, #32	# box lock
808 +   spill [sp, #0] -&gt; R11	# spill size = 64
80c +   CALL,static 0x000000401390c140	#@CallStaticJavaDirect wrapper for: _complete_monitor_locking_Java
        # sun.nio.fs.UnixPath::initOffsets @ bci:161 (line 207) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=sp + #24 L[4]=sp + #0 L[5]=_ MON-BOX0=sp+32 MON-OBJ[0]=sp + #0
        # OopMap {[0]=Oop [24]=Oop off=2064/0x810}
810 +   j  B76	#@branch

814     B109: #	out( N1045 ) &lt;- in( B76 )  Freq: 2.29579e-08
814 +   li R11, #-187	# int, #@loadConI
818     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::initOffsets @ bci:166 (line 208) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=sp + #24 L[4]=sp + #0 L[5]=_ STK[0]=R8 MON-BOX0=sp+32 MON-OBJ[0]=sp + #0
        # OopMap {fp=Oop [0]=Oop [24]=Oop off=2076/0x81c}
81c     #@ShouldNotReachHere

828     B110: #	out( B78 ) &lt;- in( B85 )  Freq: 2.29573e-08
828 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
828     spill R23 -&gt; R11	# spill size = 64
82c +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
85c +   j  B78	#@branch

860     B111: #	out( N1045 ) &lt;- in( B33 )  Freq: 5.62664e-11
860     #@ShouldNotReachHere

86c     B112: #	out( N1045 ) &lt;- in( B70 )  Freq: 5.62632e-11
86c     #@ShouldNotReachHere

878     B113: #	out( N1045 ) &lt;- in( B3 )  Freq: 4.65306e-08
878 +   li R11, #-10	# int, #@loadConI
87c     spill [sp, #0] -&gt; R8	# spill size = 64
880     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::isEmpty @ bci:4 (line 216) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::initOffsets @ bci:12 (line 179) L[0]=R8 L[1]=#0 L[2]=#0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop off=2180/0x884}
884     #@ShouldNotReachHere

890     B114: #	out( N1045 ) &lt;- in( B91 )  Freq: 4.63914e-11
890      -- 	// exception oop; no code emitted, #@CreateException
890 +   spill R10 -&gt; R11	# spill size = 64
894 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
8a0 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='167'>
----------------------- MetaData before Compile_id = 167 ------------------------
{method}
 - this oop:          0x0000004096187498
 - method holder:     &apos;java/lang/StringLatin1&apos;
 - constants:         0x0000004096185338 constant pool [380] {0x0000004096185338} for &apos;java/lang/StringLatin1&apos; cache=0x0000004096189c30
 - access:            0xc1000009  public static 
 - name:              &apos;hashCode&apos;
 - signature:         &apos;([B)I&apos;
 - max stack:         4
 - max locals:        6
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4af6c0
 - code size:         42
 - code start:        0x0000004096187438
 - code end (excl):   0x0000004096187462
 - method data:       0x0000004096300098
 - checked ex length: 0
 - linenumber start:  0x0000004096187462
 - localvar length:   3
 - localvar start:    0x0000004096187472
 - compiled code: nmethod   4627   19       3       java.lang.StringLatin1::hashCode (42 bytes)

------------------------ OptoAssembly for Compile_id = 167 -----------------------
#
#  int ( byte[int:&gt;=0]:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: byte[int:&gt;=0]:exact *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B22 B17 B20 B21 B15 B18 B19 )  Freq: 1

000     B1: #	out( B22 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     lwu  R12, [R11, #12]	# range, #@loadRange
020     NullCheck R11

020     B2: #	out( B16 B3 ) &lt;- in( B1 )  Freq: 0.999999
020 +   li R14, #0	# int, #@loadConI
024 +   bleu  R12, zr, B16	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.056043 C=18254.000000

028     B3: #	out( B17 B4 ) &lt;- in( B2 )  Freq: 0.943957
028 +   addiw  R7, R12, #-1	#@addI_reg_imm
02c +   bgeu  R7, R12, B17	#@cmpU_branch  P=0.000001 C=-1.000000

030     B4: #	out( B11 B5 ) &lt;- in( B3 )  Freq: 0.943956
030 +   li R29, #-2147483648	# int, #@loadConI
034 +   addiw  R13, R12, #-3	#@addI_reg_imm
038     CMove R13, (R7 lt R13), R13, R29	#@cmovI_cmpI
	
040 +   li R16, #1	# int, #@loadConI
044 +   li R15, #4000	# int, #@loadConI
04c +   lbu  R10, [R11, #16]	# byte, #@loadUB
050 +   ble  R13, R16, B11	#@cmpI_branch  P=0.000001 C=-1.000000

054     B5: #	out( B18 B6 ) &lt;- in( B4 )  Freq: 0.943955
054 +   slliw  R7, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
058 +   subw  R28, R7, R10	#@subI_reg_reg
05c +   li R7, #4	# int, #@loadConI
060 +   bleu  R12, R16, B18	#@cmpU_branch  P=0.000001 C=-1.000000

064     B6: #	out( B19 B7 ) &lt;- in( B5 )  Freq: 0.943954
064 +   bleu  R12, R7, B19	#@cmpU_branch  P=0.000001 C=-1.000000

068     B7: #	out( B8 ) &lt;- in( B6 )  Freq: 0.943953
068 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP

068     B8: #	out( B9 ) &lt;- in( B7 B10 ) Loop( B8-B10 ) Freq: 16.8435
068 +   subw  R29, R13, R16	#@subI_reg_reg
06c     CMove R29, (R13 lt R16), R29, R14	#@cmovI_cmpI
	
074 +   CMove R29, (R29 gtu R15), R29, R15	#@cmovI_cmpU
	
07c +   addw  R17, R29, R16	#@addI_reg_reg

080     B9: #	out( B9 B10 ) &lt;- in( B8 B9 ) Loop( B9-B9 inner main of N54 strip mined) Freq: 300.549
080 +   addw  R7, R16, zr	#@convI2L_reg_reg
084 +   add R7, R11, R7	# ptr, #@addP_reg_reg
088 +   lbu  R29, [R7, #16]	# byte, #@loadUB
08c +   addw  R28, R28, R29	#@addI_reg_reg
090 +   lbu  R31, [R7, #17]	# byte, #@loadUB
094 +   slliw  R30, R28, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
098 +   subw  R29, R30, R28	#@subI_reg_reg
09c +   addw  R30, R29, R31	#@addI_reg_reg
0a0 +   slliw  R29, R30, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0a4 +   lbu  R28, [R7, #18]	# byte, #@loadUB
0a8 +   subw  R30, R29, R30	#@subI_reg_reg
0ac +   lbu  R29, [R7, #19]	# byte, #@loadUB
0b0 +   addw  R7, R30, R28	#@addI_reg_reg
0b4 +   slliw  R30, R7, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0b8 +   subw  R7, R30, R7	#@subI_reg_reg
0bc +   addw  R10, R7, R29	#@addI_reg_reg
0c0 +   slliw  R28, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0c4 +   addiw  R16, R16, #4	#@addI_reg_imm
0c8 +   subw  R28, R28, R10	#@subI_reg_reg
0cc +   blt  R16, R17, B9	#@cmpI_loop  P=0.943958 C=17231.000000

0d0     B10: #	out( B8 B11 ) &lt;- in( B9 )  Freq: 16.8435
0d0 +   ld  R7, [R23, #920]	# ptr, #@loadP
0d4 +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::hashCode @ bci:37 (line 196) L[0]=_ L[1]=R10 L[2]=R11 L[3]=R12 L[4]=R16 L[5]=_
        # OopMap {c_rarg1=Oop off=212/0xd4}
0d8 +   blt  R16, R13, B8	#@cmpI_branch  P=0.943958 C=17231.000000

0dc     B11: #	out( B15 B12 ) &lt;- in( B4 B10 )  Freq: 0.943954
0dc +   bge  R16, R12, B15	#@cmpI_branch  P=0.500000 C=-1.000000

0e0     B12: #	out( B20 B13 ) &lt;- in( B11 )  Freq: 0.471977
0e0 +   # castII of R16, #@castII
0e0     bgeu  R16, R12, B20	#@cmpU_branch  P=0.000001 C=-1.000000

0e4     B13: #	out( B21 B14 ) &lt;- in( B12 )  Freq: 0.471976
0e4 +   spill R16 -&gt; R7	# spill size = 32
0e8 +   # castII of R7, #@castII
0e8     bgeu  R7, R12, B21	#@cmpU_branch  P=0.000001 C=-1.000000

0ec     B14: #	out( B14 B15 ) &lt;- in( B13 B14 ) Loop( B14-B14 inner post of N166) Freq: 0.943952
0ec +   addw  R7, R16, zr	#@convI2L_reg_reg
0f0 +   add R7, R11, R7	# ptr, #@addP_reg_reg
0f4 +   lbu  R28, [R7, #16]	# byte, #@loadUB
0f8 +   slliw  R7, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0fc +   subw  R29, R7, R10	#@subI_reg_reg
100 +   addiw  R16, R16, #1	#@addI_reg_imm
104 +   addw  R10, R29, R28	#@addI_reg_reg
108 +   blt  R16, R12, B14	#@cmpI_loop  P=0.500000 C=17231.000000

10c     B15: #	out( N1 ) &lt;- in( B14 B11 B16 )  Freq: 0.999995
10c     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
124 +   ret	// return register, #@Ret

128     B16: #	out( B15 ) &lt;- in( B2 )  Freq: 0.0560425
128 +   li R10, #0	# int, #@loadConI
12c +   j  B15	#@branch

130     B17: #	out( N1 ) &lt;- in( B3 )  Freq: 9.56491e-07
130 +   spill R11 -&gt; R8	# spill size = 64
134 +   spill R12 -&gt; [sp, #4]	# spill size = 32
138 +   li R11, #-138	# int, #@loadConI
13c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:13 (line 196) L[0]=_ L[1]=#0 L[2]=R8 L[3]=sp + #4 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=sp + #4
        # OopMap {fp=Oop off=320/0x140}
140     #@ShouldNotReachHere

14c     B18: #	out( N1 ) &lt;- in( B5 )  Freq: 9.43955e-07
14c     #@ShouldNotReachHere

158     B19: #	out( N1 ) &lt;- in( B6 )  Freq: 9.43954e-07
158     #@ShouldNotReachHere

164     B20: #	out( N1 ) &lt;- in( B12 )  Freq: 4.78244e-07
164     #@ShouldNotReachHere

170     B21: #	out( N1 ) &lt;- in( B13 )  Freq: 4.78244e-07
170     #@ShouldNotReachHere

17c     B22: #	out( N1 ) &lt;- in( B1 )  Freq: 1.01328e-06
17c +   li R11, #-10	# int, #@loadConI
180     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:5 (line 196) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # OopMap {off=388/0x184}
184     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='181'>
----------------------- MetaData before Compile_id = 181 ------------------------
{method}
 - this oop:          0x00000040962b8d20
 - method holder:     &apos;sun/nio/fs/UnixPath&apos;
 - constants:         0x00000040962b5440 constant pool [472] {0x00000040962b5440} for &apos;sun/nio/fs/UnixPath&apos; cache=0x00000040962ba1a0
 - access:            0xc1000001  public 
 - name:              &apos;compareTo&apos;
 - signature:         &apos;(Ljava/nio/file/Path;)I&apos;
 - max stack:         3
 - max locals:        10
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      19
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bd00: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c4edbc0
 - code size:         92
 - code start:        0x00000040962b8c38
 - code end (excl):   0x00000040962b8c94
 - method data:       0x00000040965ec4c8
 - checked ex length: 0
 - linenumber start:  0x00000040962b8c94
 - localvar length:   10
 - localvar start:    0x00000040962b8ca6
 - compiled code: nmethod   4834  113       3       sun.nio.fs.UnixPath::compareTo (92 bytes)

------------------------ OptoAssembly for Compile_id = 181 -----------------------
#
#  int ( sun/nio/fs/UnixPath:NotNull *, java/nio/file/Path * )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixPath:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/nio/file/Path *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N362: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B49 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
03c     lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
040 +   spill R11 -&gt; R29	# spill size = 64
044 +   decode_heap_oop  R10, R7	#@decodeHeapOop
048     lwu  R30, [R10, #12]	# range, #@loadRange
04c     NullCheck R10

04c     B2: #	out( B50 B3 ) &lt;- in( B1 )  Freq: 0.999999
04c     lwu  R28, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
050     NullCheck R12

050     B3: #	out( B48 B4 ) &lt;- in( B2 )  Freq: 0.999998
050 +   mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d8258020:Constant:exact *	# compressed klass ptr, #@loadConNKlass
060 +   bne  R28, R7, B48	#@cmpN_branch  P=0.000000 C=-1.000000

064     B4: #	out( B51 B5 ) &lt;- in( B3 )  Freq: 0.999998
064 +   # checkcastPP of R12, #@checkCastPP
064     lwu  R28, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
068 +   decode_heap_oop  R14, R28	#@decodeHeapOop
06c     lwu  R15, [R14, #12]	# range, #@loadRange
070     NullCheck R14

070     B5: #	out( B31 B6 ) &lt;- in( B4 )  Freq: 0.999997
070 +   spill R15 -&gt; R8	# spill size = 32
074 +   CMove R8, (R30 lt R15), R8, R30	#@cmovI_cmpI
	
07c +   ble  R8, zr, B31	#@cmpI_reg_imm0_branch  P=0.045860 C=22307.000000

080     B6: #	out( B38 B7 ) &lt;- in( B5 )  Freq: 0.954137
080 +   addiw  R7, R8, #-1	#@addI_reg_imm
084 +   bleu  R30, zr, B38	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

088     B7: #	out( B38 B8 ) &lt;- in( B6 )  Freq: 0.954136
088 +   bgeu  R7, R30, B38	#@cmpU_branch  P=0.000001 C=-1.000000

08c     B8: #	out( B38 B9 ) &lt;- in( B7 )  Freq: 0.954135
08c +   lbu  R12, [R10, #16]	# byte, #@loadUB
090 +   bleu  R15, zr, B38	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

094     B9: #	out( B38 B10 ) &lt;- in( B8 )  Freq: 0.954134
094 +   bgeu  R7, R15, B38	#@cmpU_branch  P=0.000001 C=-1.000000

098     B10: #	out( B47 B11 ) &lt;- in( B9 )  Freq: 0.954133
098 +   lbu  R16, [R14, #16]	# byte, #@loadUB
09c +   li R31, #0	# int, #@loadConI
0a0 +   bne  R12, R16, B47	#@cmpI_branch  P=0.000000 C=21284.000000

0a4     B11: #	out( B24 B12 ) &lt;- in( B10 )  Freq: 0.954133
0a4 +   li R29, #-2147483648	# int, #@loadConI
0a8 +   addiw  R11, R8, #-3	#@addI_reg_imm
0ac     CMove R11, (R7 lt R11), R11, R29	#@cmovI_cmpI
	
0b4 +   li R13, #1	# int, #@loadConI
0b8 +   li R7, #4000	# int, #@loadConI
0c0 +   ble  R11, R13, B24	#@cmpI_branch  P=0.000001 C=-1.000000

0c4     B12: #	out( B39 B13 ) &lt;- in( B11 )  Freq: 0.954132
0c4 +   li R28, #4	# int, #@loadConI
0c8 +   bleu  R15, R13, B39	#@cmpU_branch  P=0.000001 C=-1.000000

0cc     B13: #	out( B40 B14 ) &lt;- in( B12 )  Freq: 0.954131
0cc +   bleu  R30, R13, B40	#@cmpU_branch  P=0.000001 C=-1.000000

0d0     B14: #	out( B41 B15 ) &lt;- in( B13 )  Freq: 0.95413
0d0 +   bleu  R30, R28, B41	#@cmpU_branch  P=0.000001 C=-1.000000

0d4     B15: #	out( B42 B16 ) &lt;- in( B14 )  Freq: 0.954129
0d4 +   bleu  R15, R28, B42	#@cmpU_branch  P=0.000001 C=-1.000000

0d8     B16: #	out( B17 ) &lt;- in( B15 )  Freq: 0.954128
0d8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP

0d8     B17: #	out( B18 ) &lt;- in( B16 B23 ) Loop( B17-B23 ) Freq: 20.7872
0d8 +   subw  R29, R11, R13	#@subI_reg_reg
0dc     CMove R29, (R11 lt R13), R29, R31	#@cmovI_cmpI
	
0e4 +   CMove R29, (R29 gtu R7), R29, R7	#@cmovI_cmpU
	
0ec +   addw  R17, R29, R13	#@addI_reg_reg

0f0     B18: #	out( B32 B19 ) &lt;- in( B17 B22 ) Loop( B18-B22 inner main of N118 strip mined) Freq: 453.257
0f0 +   addw  R28, R13, zr	#@convI2L_reg_reg
0f4 +   add R29, R10, R28	# ptr, #@addP_reg_reg
0f8 +   lbu  R18, [R29, #16]	# byte, #@loadUB
0fc +   lbu  R12, [R29, #19]	# byte, #@loadUB
100 +   lbu  R9, [R29, #18]	# byte, #@loadUB
104 +   lbu  R19, [R29, #17]	# byte, #@loadUB
108 +   add R28, R14, R28	# ptr, #@addP_reg_reg
10c +   lbu  R29, [R28, #16]	# byte, #@loadUB
110 +   lbu  R16, [R28, #19]	# byte, #@loadUB
114 +   lbu  R20, [R28, #18]	# byte, #@loadUB
118 +   lbu  R21, [R28, #17]	# byte, #@loadUB
11c +   bne  R18, R29, B32	#@cmpI_branch  P=0.000000 C=21284.000000

120     B19: #	out( B35 B20 ) &lt;- in( B18 )  Freq: 453.257
120 +   bne  R19, R21, B35	#@cmpI_branch  P=0.000000 C=21284.000000

124     B20: #	out( B33 B21 ) &lt;- in( B19 )  Freq: 453.257
124 +   bne  R9, R20, B33	#@cmpI_branch  P=0.000000 C=21284.000000

128     B21: #	out( B36 B22 ) &lt;- in( B20 )  Freq: 453.256
128 +   bne  R12, R16, B36	#@cmpI_branch  P=0.000000 C=21284.000000

12c     B22: #	out( B18 B23 ) &lt;- in( B21 )  Freq: 453.256
12c +   addiw  R13, R13, #4	#@addI_reg_imm
130 +   blt  R13, R17, B18	#@cmpI_loop  P=0.954140 C=21284.000000

134     B23: #	out( B17 B24 ) &lt;- in( B22 )  Freq: 20.7864
134 +   ld  R12, [R23, #920]	# ptr, #@loadP
138 +   lwu zr, [R12]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.UnixPath::compareTo @ bci:85 (line 728) L[0]=_ L[1]=_ L[2]=R30 L[3]=R15 L[4]=R8 L[5]=R10 L[6]=R14 L[7]=R13 L[8]=_ L[9]=_
        # OopMap {c_rarg0=Oop c_rarg4=Oop off=312/0x138}
13c +   blt  R13, R11, B17	#@cmpI_branch  P=0.954140 C=21284.000000

140     B24: #	out( B31 B25 ) &lt;- in( B11 B23 )  Freq: 0.953264
140 +   bge  R13, R8, B31	#@cmpI_branch  P=0.500000 C=-1.000000

144     B25: #	out( B43 B26 ) &lt;- in( B24 )  Freq: 0.476632
144 +   # castII of R13, #@castII
144     bgeu  R13, R30, B43	#@cmpU_branch  P=0.000001 C=-1.000000

148     B26: #	out( B44 B27 ) &lt;- in( B25 )  Freq: 0.476632
148 +   spill R13 -&gt; R7	# spill size = 32
14c +   # castII of R7, #@castII
14c     bgeu  R7, R30, B44	#@cmpU_branch  P=0.000001 C=-1.000000

150     B27: #	out( B45 B28 ) &lt;- in( B26 )  Freq: 0.476631
150 +   bgeu  R13, R15, B45	#@cmpU_branch  P=0.000001 C=-1.000000

154     B28: #	out( B46 B29 ) &lt;- in( B27 )  Freq: 0.476631
154 +   bgeu  R7, R15, B46	#@cmpU_branch  P=0.000001 C=-1.000000

158     B29: #	out( B37 B30 ) &lt;- in( B28 B30 ) Loop( B29-B30 inner post of N290) Freq: 0.95326
158 +   addw  R7, R13, zr	#@convI2L_reg_reg
15c +   add R28, R10, R7	# ptr, #@addP_reg_reg
160 +   lbu  R12, [R28, #16]	# byte, #@loadUB
164 +   add R7, R14, R7	# ptr, #@addP_reg_reg
168 +   lbu  R16, [R7, #16]	# byte, #@loadUB
16c +   bne  R12, R16, B37	#@cmpI_branch  P=0.000000 C=21284.000000

170     B30: #	out( B29 B31 ) &lt;- in( B29 )  Freq: 0.95326
170 +   addiw  R13, R13, #1	#@addI_reg_imm
174 +   blt  R13, R8, B29	#@cmpI_loop  P=0.500000 C=21284.000000

178     B31: #	out( N362 ) &lt;- in( B24 B5 B30 )  Freq: 0.999122
178 +   subw  R10, R30, R15	#@subI_reg_reg
17c     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
194 +   ret	// return register, #@Ret

198     B32: #	out( B34 ) &lt;- in( B18 )  Freq: 0.00021613
198 +   spill R29 -&gt; R20	# spill size = 32
19c +   spill R18 -&gt; R9	# spill size = 32
1a0 +   j  B34	#@branch

1a4     B33: #	out( B34 ) &lt;- in( B20 )  Freq: 0.00021613
1a4 +   addiw  R13, R13, #2	#@addI_reg_imm

1a8     B34: #	out( B37 ) &lt;- in( B32 B33 )  Freq: 0.00043226
1a8     spill R20 -&gt; R16	# spill size = 32
1ac +   spill R9 -&gt; R12	# spill size = 32
1b0 +   j  B37	#@branch

1b4     B35: #	out( B37 ) &lt;- in( B19 )  Freq: 0.00021613
1b4 +   addiw  R13, R13, #1	#@addI_reg_imm
1b8     spill R21 -&gt; R16	# spill size = 32
1bc +   spill R19 -&gt; R12	# spill size = 32
1c0 +   j  B37	#@branch

1c4     B36: #	out( B37 ) &lt;- in( B21 )  Freq: 0.00021613
1c4 +   addiw  R13, R13, #3	#@addI_reg_imm

1c8     B37: #	out( N362 ) &lt;- in( B29 B47 B34 B35 B36 )  Freq: 0.000865428
1c8 +   li R11, #-187	# int, #@loadConI
1cc     spill R10 -&gt; [sp, #0]	# spill size = 64
1d0 +   spill R14 -&gt; [sp, #8]	# spill size = 64
1d4 +   spill R13 -&gt; [sp, #16]	# spill size = 32
1d8 +   spill R12 -&gt; [sp, #28]	# spill size = 32
1dc +   spill R16 -&gt; [sp, #32]	# spill size = 32
1e0 +   spill R30 -&gt; [sp, #36]	# spill size = 32
1e4 +   spill R15 -&gt; [sp, #40]	# spill size = 32
1e8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:73 (line 724) L[0]=_ L[1]=_ L[2]=sp + #36 L[3]=sp + #40 L[4]=R8 L[5]=sp + #0 L[6]=sp + #8 L[7]=sp + #16 L[8]=sp + #28 L[9]=sp + #32 STK[0]=sp + #28 STK[1]=sp + #32
        # OopMap {[0]=Oop [8]=Oop off=492/0x1ec}
1ec     #@ShouldNotReachHere

1f8     B38: #	out( N362 ) &lt;- in( B9 B6 B7 B8 )  Freq: 3.84188e-06
1f8 +   li R11, #-138	# int, #@loadConI
1fc     spill R10 -&gt; [sp, #0]	# spill size = 64
200 +   spill R14 -&gt; [sp, #8]	# spill size = 64
204 +   spill R30 -&gt; [sp, #16]	# spill size = 32
208 +   spill R15 -&gt; [sp, #20]	# spill size = 32
20c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:44 (line 721) L[0]=_ L[1]=_ L[2]=sp + #16 L[3]=sp + #20 L[4]=R8 L[5]=sp + #0 L[6]=sp + #8 L[7]=#0 L[8]=_ L[9]=_ STK[0]=#0 STK[1]=R8
        # OopMap {[0]=Oop [8]=Oop off=528/0x210}
210     #@ShouldNotReachHere

21c     B39: #	out( N362 ) &lt;- in( B12 )  Freq: 9.54132e-07
21c     #@ShouldNotReachHere

228     B40: #	out( N362 ) &lt;- in( B13 )  Freq: 9.54131e-07
228     #@ShouldNotReachHere

234     B41: #	out( N362 ) &lt;- in( B14 )  Freq: 9.5413e-07
234     #@ShouldNotReachHere

240     B42: #	out( N362 ) &lt;- in( B15 )  Freq: 9.54129e-07
240     #@ShouldNotReachHere

24c     B43: #	out( N362 ) &lt;- in( B25 )  Freq: 4.82961e-07
24c     #@ShouldNotReachHere

258     B44: #	out( N362 ) &lt;- in( B26 )  Freq: 4.82961e-07
258     #@ShouldNotReachHere

264     B45: #	out( N362 ) &lt;- in( B27 )  Freq: 4.8296e-07
264     #@ShouldNotReachHere

270     B46: #	out( N362 ) &lt;- in( B28 )  Freq: 4.8296e-07
270     #@ShouldNotReachHere

27c     B47: #	out( B37 ) &lt;- in( B10 )  Freq: 4.54966e-07
27c +   li R13, #0	# int, #@loadConI
280 +   j  B37	#@branch

284     B48: #	out( N362 ) &lt;- in( B3 )  Freq: 1e-35
284 +   li R11, #-34	# int, #@loadConI
288     spill R29 -&gt; R8	# spill size = 64
28c +   spill R30 -&gt; [sp, #8]	# spill size = 32
290 +   spill R12 -&gt; [sp, #16]	# spill size = 64
294     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:7 (line 714) L[0]=R8 L[1]=sp + #16 L[2]=sp + #8 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ STK[0]=sp + #16
        # OopMap {fp=Oop [16]=Oop off=664/0x298}
298     #@ShouldNotReachHere

2a4     B49: #	out( N362 ) &lt;- in( B1 )  Freq: 1.01328e-06
2a4 +   li R11, #-10	# int, #@loadConI
2a8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:4 (line 713) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ STK[0]=#NULL
        # OopMap {off=684/0x2ac}
2ac     #@ShouldNotReachHere

2b8     B50: #	out( N362 ) &lt;- in( B2 )  Freq: 1.01328e-06
2b8 +   li R11, #-12	# int, #@loadConI
2bc     spill R29 -&gt; R8	# spill size = 64
2c0 +   spill R30 -&gt; [sp, #0]	# spill size = 32
2c4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:7 (line 714) L[0]=R8 L[1]=#NULL L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ STK[0]=#NULL
        # OopMap {fp=Oop off=712/0x2c8}
2c8     #@ShouldNotReachHere

2d4     B51: #	out( N362 ) &lt;- in( B4 )  Freq: 1.01328e-06
2d4 +   li R11, #-10	# int, #@loadConI
2d8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:13 (line 714) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ STK[0]=#NULL
        # OopMap {off=732/0x2dc}
2dc     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='186'>
----------------------- MetaData before Compile_id = 186 ------------------------
{method}
 - this oop:          0x00000040962b7ac8
 - method holder:     &apos;sun/nio/fs/UnixPath&apos;
 - constants:         0x00000040962b5440 constant pool [472] {0x00000040962b5440} for &apos;sun/nio/fs/UnixPath&apos; cache=0x00000040962ba1a0
 - access:            0x81000001  public 
 - name:              &apos;getName&apos;
 - signature:         &apos;(I)Lsun/nio/fs/UnixPath;&apos;
 - max stack:         6
 - max locals:        5
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      22
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bb30: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c4ec940
 - code size:         106
 - code start:        0x00000040962b7a00
 - code end (excl):   0x00000040962b7a6a
 - method data:       0x00000040965ebd28
 - checked ex length: 0
 - linenumber start:  0x00000040962b7a6a
 - localvar length:   6
 - localvar start:    0x00000040962b7a7e
 - compiled code: nmethod   4979  112       3       sun.nio.fs.UnixPath::getName (106 bytes)

------------------------ OptoAssembly for Compile_id = 186 -----------------------
#
#  sun/nio/fs/UnixPath * ( sun/nio/fs/UnixPath:NotNull *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixPath:NotNull *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N429: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B43 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     spill R12 -&gt; R8	# spill size = 32
040 +   spill R11 -&gt; [sp, #0]	# spill size = 64
044     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getName @ bci:1 (line 301) L[0]=sp + #0 L[1]=R8 L[2]=_ L[3]=_ L[4]=_
        # OopMap {[0]=Oop off=72/0x48}

048     B2: #	out( B33 B3 ) &lt;- in( B1 )  Freq: 0.99998
        # Block is sole successor of call
048 +   spill R8 -&gt; R31	# spill size = 32
04c +   blt  R31, zr, B33	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

050     B3: #	out( B35 B4 ) &lt;- in( B2 )  Freq: 0.999979
050 +   spill [sp, #0] -&gt; R7	# spill size = 64
054 +   lwu  R28, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
058 +   #@membar_acquire
	fence ir iorw
05c +   decode_heap_oop  R7, R28	#@decodeHeapOop
060     lwu  R8, [R7, #12]	# range, #@loadRange
064     NullCheck R7

064     B4: #	out( B34 B5 ) &lt;- in( B3 )  Freq: 0.999978
064 +   bge  R31, R8, B34	#@cmpI_branch  P=0.000000 C=5375.000000

068     B5: #	out( B36 B6 ) &lt;- in( B4 )  Freq: 0.999978
068 +   spill [sp, #0] -&gt; R7	# spill size = 64
06c +   lwu  R7, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
070 +   #@membar_acquire
	fence ir iorw
074 +   decode_heap_oop  R8, R7	#@decodeHeapOop
078     lwu  R28, [R8, #12]	# range, #@loadRange
07c     NullCheck R8

07c     B6: #	out( B30 B7 ) &lt;- in( B5 )  Freq: 0.999977
07c +   bgeu  R31, R28, B30	#@cmpU_branch  P=0.000001 C=-1.000000

080     B7: #	out( B37 B8 ) &lt;- in( B6 )  Freq: 0.999976
080 +   addw  R28, R31, zr	#@convI2L_reg_reg
084 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
088     spill [sp, #0] -&gt; R7	# spill size = 64
08c +   lwu  R7, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
090 +   add R29, R8, R28	# ptr, #@addP_reg_reg
094 +   lw  R29, [R29, #16]	# int, #@loadI
098 +   decode_heap_oop  R7, R7	#@decodeHeapOop
09c     spill R29 -&gt; [sp, #8]	# spill size = 32
0a0 +   #@membar_acquire
	fence ir iorw
0a4     lwu  R7, [R7, #12]	# range, #@loadRange
0a8     NullCheck R7

0a8     B8: #	out( B24 B9 ) &lt;- in( B7 )  Freq: 0.999975
0a8 +   addiw  R29, R7, #-1	#@addI_reg_imm
0ac +   beq  R31, R29, B24	#@cmpI_branch  P=0.084651 C=5375.000000

0b0     B9: #	out( B39 B10 ) &lt;- in( B8 )  Freq: 0.915326
0b0 +   spill [sp, #0] -&gt; R7	# spill size = 64
0b4 +   lwu  R7, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0b8 +   #@membar_acquire
	fence ir iorw
0bc +   decode_heap_oop  R7, R7	#@decodeHeapOop
0c0 +   addiw  R8, R31, #1	#@addI_reg_imm
0c4     lwu  R29, [R7, #12]	# range, #@loadRange
0c8     NullCheck R7

0c8     B10: #	out( B32 B11 ) &lt;- in( B9 )  Freq: 0.915325
0c8 +   bgeu  R8, R29, B32	#@cmpU_branch  P=0.000001 C=-1.000000

0cc     B11: #	out( B12 ) &lt;- in( B10 )  Freq: 0.915324
0cc +   add R7, R7, R28	# ptr, #@addP_reg_reg
0d0 +   lw  R7, [R7, #20]	# int, #@loadI
0d4 +   spill [sp, #8] -&gt; R29	# spill size = 32
0d8 +   subw  R28, R7, R29	#@subI_reg_reg
0dc +   addiw  R8, R28, #-1	#@addI_reg_imm

0e0     B12: #	out( B13 B13 ) &lt;- in( B11 B25 )  Freq: 0.999973
0e0     spill [sp, #0] -&gt; R7	# spill size = 64
0e4 +   lwu  R28, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
0e8 +   decode_heap_oop  R10, R28	#@decodeHeapOop
0ec +   li R7, #1048576	# int, #@loadConI
0f0 +   addw  R28, R8, zr	#@convI2L_reg_reg
0f4 +   bleu  R8, R7, B13	#@cmpU_branch  P=0.999999 C=-1.000000

0f8     B13: #	out( B38 B14 ) &lt;- in( B12 B12 )  Freq: 0.999973
0f8     lwu  R30, [R10, #12]	# range, #@loadRange
0fc     NullCheck R10

0fc     B14: #	out( B31 B15 ) &lt;- in( B13 )  Freq: 0.999972
0fc +   spill [sp, #8] -&gt; R31	# spill size = 32
100 +   addw  R29, R8, R31	#@addI_reg_reg
104 +   blt  R31, zr, B31	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

108     B15: #	out( B31 B16 ) &lt;- in( B14 )  Freq: 0.999971
108 +   bltu  R30, R29, B31	#@cmpU_branch  P=0.000001 C=-1.000000

10c     B16: #	out( B28 B17 ) &lt;- in( B15 )  Freq: 0.99997
10c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
10c     bgtu  R8, R7, B28	#@cmpU_branch  P=0.000001 C=-1.000000

110     B17: #	out( B28 B18 ) &lt;- in( B16 )  Freq: 0.999969
110 +   addi  R7, R28, #23	#@addL_reg_imm
114 +   ld  R29, [R23, #288]	# ptr, #@loadP
118 +   andi  R7, R7, #-8	#@andL_reg_imm
11c +   ld  R28, [R23, #304]	# ptr, #@loadP
120 +   add R7, R29, R7	# ptr, #@addP_reg_reg
124 +   bgeu  R7, R28, B28	#@cmpP_branch  P=0.000100 C=-1.000000

128     B18: #	out( B19 ) &lt;- in( B17 )  Freq: 0.999869
128 +   sd  R7, [R23, #288]	# ptr, #@storeP
12c +   li R7, #1	# long, #@loadConL
130 +   mv  R28, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
140 +   sd  R7, [R29]	# long, #@storeL
144 +   sw  R28, [R29, #8]	# compressed klass ptr, #@storeNKlass
148 +   sw  R8, [R29, #12]	# int, #@storeI

14c     B19: #	out( B21 B20 ) &lt;- in( B29 B18 )  Freq: 0.99997
14c     
14c +   # checkcastPP of R29, #@checkCastPP
14c     # castII of R8, #@castII
14c     spill R29 -&gt; [sp, #16]	# spill size = 64
150 +   beq  R8, zr, B21	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

154     B20: #	out( B21 ) &lt;- in( B19 )  Freq: 0.999969
154 +   spill [sp, #8] -&gt; R28	# spill size = 32
158 +   addw  R7, R28, zr	#@convI2L_reg_reg
15c +   add R7, R10, R7	# ptr, #@addP_reg_reg
160 +   addw  R12, R8, zr	#@convI2L_reg_reg
164 +   addi  R11, R29, #16	# ptr, #@addP_reg_imm
168 +   addi  R10, R7, #16	# ptr, #@addP_reg_imm
16c +   CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

170     B21: #	out( B26 B22 ) &lt;- in( B20 B19 )  Freq: 0.99997
170     MEMBAR-store-store	#@membar_storestore
174 +   ld  R10, [R23, #288]	# ptr, #@loadP
178 +   ld  R7, [R23, #304]	# ptr, #@loadP
17c +   addi  R28, R10, #32	# ptr, #@addP_reg_imm
180 +   bgeu  R28, R7, B26	#@cmpP_branch  P=0.000100 C=-1.000000

184     B22: #	out( B23 ) &lt;- in( B21 )  Freq: 0.99987
184 +   sd  R28, [R23, #288]	# ptr, #@storeP
188 +   li R7, #1	# long, #@loadConL
18c +   mv  R28, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d82800c0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
19c +   sd  R7, [R10]	# long, #@storeL
1a0 +   sw  R28, [R10, #8]	# compressed klass ptr, #@storeNKlass
1a4 +   sw  zr, [R10, #12]	# int, #@storeimmI0
1a8 +   sw  zr, [R10, #16]	# int, #@storeimmI0
1ac +   sd  zr, [R10, #24]	# long, #@storeimmL0

1b0     B23: #	out( N429 ) &lt;- in( B27 B22 )  Freq: 0.99997
1b0     spill [sp, #16] -&gt; R7	# spill size = 64
1b4 +   encode_heap_oop  R7, R7	#@encodeHeapOop
1b8 +   sw  R7, [R10, #20]	# compressed ptr, #@storeN
1bc     
1bc     spill [sp, #0] -&gt; R7	# spill size = 64
1c0 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
1c4 +   # checkcastPP of R10, #@checkCastPP
1c4     sw  R28, [R10, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixPath.fs
1c8 +   #@membar_release
	fence iorw ow
1cc +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
1e4 +   ret	// return register, #@Ret

1e8     B24: #	out( B40 B25 ) &lt;- in( B8 )  Freq: 0.0846491
1e8 +   spill [sp, #0] -&gt; R7	# spill size = 64
1ec +   lwu  R28, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
1f0 +   decode_heap_oop  R7, R28	#@decodeHeapOop
1f4     lwu  R7, [R7, #12]	# range, #@loadRange
1f8     NullCheck R7

1f8     B25: #	out( B12 ) &lt;- in( B24 )  Freq: 0.084649
1f8 +   spill [sp, #8] -&gt; R28	# spill size = 32
1fc +   subw  R8, R7, R28	#@subI_reg_reg
200 +   j  B12	#@branch

204     B26: #	out( B41 B27 ) &lt;- in( B21 )  Freq: 0.000100014
204 +   mv  R11, precise klass sun/nio/fs/UnixPath: 0x00000040d82800c0:Constant:exact *	# ptr, #@loadConP
21c     spill [sp, #0] -&gt; R8	# spill size = 64
220     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixPath::getName @ bci:92 (line 318) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #16
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=548/0x224}

224     B27: #	out( B23 ) &lt;- in( B26 )  Freq: 0.000100012
        # Block is sole successor of call
224 +   j  B23	#@branch

228     B28: #	out( B42 B29 ) &lt;- in( B16 B17 )  Freq: 0.000101027
228 +   spill R10 -&gt; [sp, #16]	# spill size = 64
22c +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
244     spill R8 -&gt; R12	# spill size = 32
248     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #0 L[1]=_ L[2]=sp + #8 L[3]=R8 L[4]=_
        # OopMap {[0]=Oop [16]=Oop off=588/0x24c}

24c     B29: #	out( B19 ) &lt;- in( B28 )  Freq: 0.000101025
        # Block is sole successor of call
24c +   spill R10 -&gt; R7	# spill size = 64
250 +   spill [sp, #16] -&gt; R10	# spill size = 64
254 +   spill R7 -&gt; R29	# spill size = 64
258 +   j  B19	#@branch

25c     B30: #	out( N429 ) &lt;- in( B6 )  Freq: 1.01326e-06
25c +   li R11, #-28	# int, #@loadConI
260     spill R31 -&gt; [sp, #12]	# spill size = 32
264     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:38 (line 307) L[0]=sp + #0 L[1]=sp + #12 L[2]=_ L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #12
        # OopMap {fp=Oop [0]=Oop off=616/0x268}
268     #@ShouldNotReachHere

274     B31: #	out( N429 ) &lt;- in( B14 B15 )  Freq: 1.99994e-06
274 +   li R11, #-52	# int, #@loadConI
278     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #0 L[1]=_ L[2]=sp + #8 L[3]=R8 L[4]=_ STK[0]=R8
        # OopMap {[0]=Oop off=636/0x27c}
27c     #@ShouldNotReachHere

288     B32: #	out( N429 ) &lt;- in( B10 )  Freq: 9.2748e-07
288 +   li R11, #-28	# int, #@loadConI
28c     spill R7 -&gt; [sp, #16]	# spill size = 64
290     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:69 (line 312) L[0]=sp + #0 L[1]=_ L[2]=sp + #8 L[3]=_ L[4]=_ STK[0]=sp + #16 STK[1]=R8
        # OopMap {[0]=Oop [16]=Oop off=660/0x294}
294     #@ShouldNotReachHere

2a0     B33: #	out( N429 ) &lt;- in( B2 )  Freq: 4.76828e-07
2a0 +   spill [sp, #0] -&gt; R8	# spill size = 64
2a4 +   li R11, #-187	# int, #@loadConI
2a8     spill R31 -&gt; [sp, #4]	# spill size = 32
2ac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:5 (line 302) L[0]=R8 L[1]=sp + #4 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #4
        # OopMap {fp=Oop off=688/0x2b0}
2b0     #@ShouldNotReachHere

2bc     B34: #	out( N429 ) &lt;- in( B4 )  Freq: 4.76827e-07
2bc +   li R11, #-187	# int, #@loadConI
2c0     spill R31 -&gt; [sp, #12]	# spill size = 32
2c4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:22 (line 304) L[0]=sp + #0 L[1]=sp + #12 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #12 STK[1]=R8
        # OopMap {[0]=Oop off=712/0x2c8}
2c8     #@ShouldNotReachHere

2d4     B35: #	out( N429 ) &lt;- in( B3 )  Freq: 1.01326e-06
2d4 +   li R11, #-10	# int, #@loadConI
2d8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:21 (line 304) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=732/0x2dc}
2dc     #@ShouldNotReachHere

2e8     B36: #	out( N429 ) &lt;- in( B5 )  Freq: 1.01326e-06
2e8 +   li R11, #-10	# int, #@loadConI
2ec     spill R31 -&gt; R8	# spill size = 32
2f0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:38 (line 307) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=R8
        # OopMap {off=756/0x2f4}
2f4     #@ShouldNotReachHere

300     B37: #	out( N429 ) &lt;- in( B7 )  Freq: 1.01325e-06
300 +   li R11, #-10	# int, #@loadConI
304     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:45 (line 309) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=776/0x308}
308     #@ShouldNotReachHere

314     B38: #	out( N429 ) &lt;- in( B13 )  Freq: 1.01325e-06
314 +   li R11, #-12	# int, #@loadConI
318     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #0 L[1]=_ L[2]=sp + #8 L[3]=R8 L[4]=_ STK[0]=R8
        # OopMap {[0]=Oop off=796/0x31c}
31c     #@ShouldNotReachHere

328     B39: #	out( N429 ) &lt;- in( B9 )  Freq: 9.2748e-07
328 +   li R11, #-10	# int, #@loadConI
32c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:69 (line 312) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=R8
        # OopMap {off=816/0x330}
330     #@ShouldNotReachHere

33c     B40: #	out( N429 ) &lt;- in( B24 )  Freq: 8.57731e-08
33c +   li R11, #-10	# int, #@loadConI
340     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:55 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # OopMap {off=836/0x344}
344     #@ShouldNotReachHere

350     B41: #	out( B44 ) &lt;- in( B26 )  Freq: 1.00014e-09
350      -- 	// exception oop; no code emitted, #@CreateException
350 +   spill R10 -&gt; R11	# spill size = 64
354 +   j  B44	#@branch

358     B42: #	out( B44 ) &lt;- in( B28 )  Freq: 1.01027e-09
358      -- 	// exception oop; no code emitted, #@CreateException
358 +   spill R10 -&gt; R11	# spill size = 64
35c +   j  B44	#@branch

360     B43: #	out( B44 ) &lt;- in( B1 )  Freq: 1e-05
360      -- 	// exception oop; no code emitted, #@CreateException
360 +   spill R10 -&gt; R11	# spill size = 64

364     B44: #	out( N429 ) &lt;- in( B43 B42 B41 )  Freq: 1.0002e-05
364     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
370 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='188'>
----------------------- MetaData before Compile_id = 188 ------------------------
{method}
 - this oop:          0x0000004096009d50
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;length&apos;
 - signature:         &apos;()I&apos;
 - max stack:         3
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4ae580
 - code size:         11
 - code start:        0x0000004096009d30
 - code end (excl):   0x0000004096009d3b
 - method data:       0x00000040963b0950
 - checked ex length: 0
 - linenumber start:  0x0000004096009d3b
 - localvar length:   1
 - localvar start:    0x0000004096009d42
 - compiled code: nmethod   5013    7       3       java.lang.String::length (11 bytes)

------------------------ OptoAssembly for Compile_id = 188 -----------------------
#
#  int ( java/lang/String:NotNull:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N32: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B3 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     lwu  R28, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
040 +   decode_heap_oop  R7, R28	#@decodeHeapOop
044     lwu  R7, [R7, #12]	# range, #@loadRange
048     NullCheck R7

048     B2: #	out( N32 ) &lt;- in( B1 )  Freq: 0.999999
048 +   lb  R29, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
04c +   sraw  R10, R7, R29	#@rShiftI_reg_reg
050     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
068 +   ret	// return register, #@Ret

06c     B3: #	out( N32 ) &lt;- in( B1 )  Freq: 1.01328e-06
06c +   li R11, #-10	# int, #@loadConI
070     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # OopMap {off=116/0x74}
074 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='199'>
----------------------- MetaData before Compile_id = 199 ------------------------
{method}
 - this oop:          0x00000040962b6710
 - method holder:     &apos;sun/nio/fs/UnixPath&apos;
 - constants:         0x00000040962b5440 constant pool [472] {0x00000040962b5440} for &apos;sun/nio/fs/UnixPath&apos; cache=0x00000040962ba1a0
 - access:            0x81000000  
 - name:              &apos;&lt;init&gt;&apos;
 - signature:         &apos;(Lsun/nio/fs/UnixFileSystem;[B)V&apos;
 - max stack:         3
 - max locals:        3
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008317290: 0xbbb i2c: 0x0000004013944dc0 c2i: 0x0000004013944e0c c2iUV: 0x0000004013944dd8
 - compiled entry     0x000000400c4ec280
 - code size:         15
 - code start:        0x00000040962b66d0
 - code end (excl):   0x00000040962b66df
 - method data:       0x00000040965ebb70
 - checked ex length: 0
 - linenumber start:  0x00000040962b66df
 - localvar length:   3
 - localvar start:    0x00000040962b66ea
 - compiled code: nmethod   5119  111       3       sun.nio.fs.UnixPath::&lt;init&gt; (15 bytes)

------------------------ OptoAssembly for Compile_id = 199 -----------------------
#
#  void ( sun/nio/fs/UnixPath:NotNull *, sun/nio/fs/LinuxFileSystem *, byte[int:&gt;=0]:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixPath:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: sun/nio/fs/LinuxFileSystem *
#r016 c_rarg3:c_rarg3   : parm 2: byte[int:&gt;=0]:exact *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N296: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B11 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c      -- 	// R23=Thread::current(), empty, #@tlsLoadP
03c     lb  R28, [R23, #56]	# byte, #@loadB
040     spill R13 -&gt; R18	# spill size = 64
044 +   spill R12 -&gt; R9	# spill size = 64
048 +   bne  R28, zr, B11	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

04c     B2: #	out( B3 ) &lt;- in( B1 )  Freq: 0.999
04c +   spill R11 -&gt; R19	# spill size = 64

050     B3: #	out( B6 B4 ) &lt;- in( B25 B13 B11 B2 )  Freq: 1
050 +   mv  R7, R19	# ptr -&gt; long, #@castP2X
054     spill R9 -&gt; R30	# spill size = 64
058 +   mv  R28, R30	# ptr -&gt; long, #@castP2X
05c +   xorr  R28, R28, R7	#@xorL_reg_reg
060 +   encode_heap_oop  R29, R30	#@encodeHeapOop
064 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
068     spill R18 -&gt; R21	# spill size = 64
06c +   encode_heap_oop  R18, R18	#@encodeHeapOop
070 +   li R9, #4	# int, #@loadConI
074 +   mv  R20, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
080 +   sw  R29, [R19, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixPath.fs
084 +   beq  R28, zr, B6	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

088     B4: #	out( B6 B5 ) &lt;- in( B3 )  Freq: 0.999
088 +   beq   R30, zr, B6	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

08c     B5: #	out( B17 B6 ) &lt;- in( B4 )  Freq: 0.998001
08c +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
090 +   add R10, R20, R7	# ptr, #@addP_reg_reg
094 +   lb  R28, [R10]	# byte, #@loadB
098 +   bne  R28, R9, B17	#@cmpI_branch  P=0.001000 C=-1.000000

09c     B6: #	out( B14 B7 ) &lt;- in( B19 B20 B17 B5 B4 B3 )  Freq: 1
09c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
09c     lb  R7, [R23, #56]	# byte, #@loadB
0a0 +   bne  R7, zr, B14	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0a4     B7: #	out( B10 B8 ) &lt;- in( B26 B16 B14 B6 )  Freq: 1
0a4 +   mv  R7, R19	# ptr -&gt; long, #@castP2X
0a8 +   mv  R28, R21	# ptr -&gt; long, #@castP2X
0ac +   xorr  R28, R28, R7	#@xorL_reg_reg
0b0 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0b4 +   sw  R18, [R19, #20]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixPath.path
0b8 +   beq  R28, zr, B10	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0bc     B8: #	out( B10 B9 ) &lt;- in( B7 )  Freq: 0.999
0bc +   beq   R21, zr, B10	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

0c0     B9: #	out( B21 B10 ) &lt;- in( B8 )  Freq: 0.998001
0c0 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0c4 +   add R10, R20, R7	# ptr, #@addP_reg_reg
0c8 +   lb  R28, [R10]	# byte, #@loadB
0cc +   bne  R28, R9, B21	#@cmpI_branch  P=0.001000 C=-1.000000

0d0     B10: #	out( N296 ) &lt;- in( B23 B24 B21 B9 B8 B7 )  Freq: 1
0d0 +   #@membar_release
	fence iorw ow
0d4 +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0ec +   ret	// return register, #@Ret

0f0     B11: #	out( B3 B12 ) &lt;- in( B1 )  Freq: 0.000999987
0f0 +   lwu  R7, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
0f4 +   decode_heap_oop  R10, R7	#@decodeHeapOop
0f8     spill R11 -&gt; R19	# spill size = 64
0fc +   beq   R10, zr, B3	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

100     B12: #	out( B25 B13 ) &lt;- in( B11 )  Freq: 0.000499994
100 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
100     ld  R7, [R23, #32]	# int, #@loadL
104 +   beq  R7, zr, B25	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

108     B13: #	out( B3 ) &lt;- in( B12 )  Freq: 0.000499494
108 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
108     ld  R28, [R23, #48]	# ptr, #@loadP
10c +   add R28, R28, R7	# ptr, #@addP_reg_reg
110 +   addi  R7, R7, #-8	#@addL_reg_imm
114 +   sd  R10, [R28, #-8]	# ptr, #@storeP
118 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
118     sd  R7, [R23, #32]	# long, #@storeL
11c +   j  B3	#@branch

120     B14: #	out( B7 B15 ) &lt;- in( B6 )  Freq: 0.000999987
120 +   lwu  R28, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
124 +   decode_heap_oop  R10, R28	#@decodeHeapOop
128 +   beq   R10, zr, B7	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

12c     B15: #	out( B26 B16 ) &lt;- in( B14 )  Freq: 0.000499994
12c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
12c     ld  R7, [R23, #32]	# int, #@loadL
130 +   beq  R7, zr, B26	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

134     B16: #	out( B7 ) &lt;- in( B15 )  Freq: 0.000499494
134 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
134     ld  R28, [R23, #48]	# ptr, #@loadP
138 +   add R28, R28, R7	# ptr, #@addP_reg_reg
13c +   addi  R7, R7, #-8	#@addL_reg_imm
140 +   sd  R10, [R28, #-8]	# ptr, #@storeP
144 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
144     sd  R7, [R23, #32]	# long, #@storeL
148 +   j  B7	#@branch

14c     B17: #	out( B6 B18 ) &lt;- in( B5 )  Freq: 0.000998001
14c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
14c     ld  R7, [R23, #64]	# int, #@loadL
150 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
150     ld  R28, [R23, #80]	# ptr, #@loadP
154 +   #@membar_volatile
	fence iorw iorw
158 +   lb  R29, [R10]	# byte, #@loadB
15c +   beq  R29, zr, B6	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

160     B18: #	out( B20 B19 ) &lt;- in( B17 )  Freq: 0.000499001
160 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
164 +   bne  R7, zr, B20	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

168     B19: #	out( B6 ) &lt;- in( B18 )  Freq: 0.0002495
168 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
168     spill R23 -&gt; R11	# spill size = 64
16c +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
19c +   j  B6	#@branch

1a0     B20: #	out( B6 ) &lt;- in( B18 )  Freq: 0.0002495
1a0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
1a4 +   addi  R7, R7, #-8	#@addL_reg_imm
1a8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
1ac +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ac     sd  R7, [R23, #64]	# long, #@storeL
1b0 +   j  B6	#@branch

1b4     B21: #	out( B10 B22 ) &lt;- in( B9 )  Freq: 0.000998001
1b4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b4     ld  R7, [R23, #64]	# int, #@loadL
1b8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b8     ld  R28, [R23, #80]	# ptr, #@loadP
1bc +   #@membar_volatile
	fence iorw iorw
1c0 +   lb  R29, [R10]	# byte, #@loadB
1c4 +   beq  R29, zr, B10	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1c8     B22: #	out( B24 B23 ) &lt;- in( B21 )  Freq: 0.000499001
1c8 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1cc +   bne  R7, zr, B24	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1d0     B23: #	out( B10 ) &lt;- in( B22 )  Freq: 0.0002495
1d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1d0     spill R23 -&gt; R11	# spill size = 64
1d4 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
204 +   j  B10	#@branch

208     B24: #	out( B10 ) &lt;- in( B22 )  Freq: 0.0002495
208 +   add R28, R28, R7	# ptr, #@addP_reg_reg
20c +   addi  R7, R7, #-8	#@addL_reg_imm
210 +   sd  R10, [R28, #-8]	# ptr, #@storeP
214 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
214     sd  R7, [R23, #64]	# long, #@storeL
218 +   j  B10	#@branch

21c     B25: #	out( B3 ) &lt;- in( B12 )  Freq: 4.99987e-07
21c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
21c     spill R23 -&gt; R11	# spill size = 64
220 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
250 +   j  B3	#@branch

254     B26: #	out( B7 ) &lt;- in( B15 )  Freq: 4.99987e-07
254 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
254     spill R23 -&gt; R11	# spill size = 64
258 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
288 +   j  B7	#@branch

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='260'>
----------------------- MetaData before Compile_id = 260 ------------------------
{method}
 - this oop:          0x00000040961e8718
 - method holder:     &apos;java/lang/CharacterData&apos;
 - constants:         0x00000040961e73f8 constant pool [80] {0x00000040961e73f8} for &apos;java/lang/CharacterData&apos; cache=0x00000040961e8780
 - access:            0x81000018  static final 
 - name:              &apos;of&apos;
 - signature:         &apos;(I)Ljava/lang/CharacterData;&apos;
 - max stack:         3
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b960: 0xa i2c: 0x00000040139d7540 c2i: 0x00000040139d7584 c2iUV: 0x00000040139d7550
 - compiled entry     0x000000400c4ee880
 - code size:         136
 - code start:        0x00000040961e8670
 - code end (excl):   0x00000040961e86f8
 - method data:       0x00000040965ec718
 - checked ex length: 0
 - linenumber start:  0x00000040961e86f8
 - localvar length:   1
 - localvar start:    0x00000040961e870a
 - compiled code: nmethod   5852  114       3       java.lang.CharacterData::of (136 bytes)

------------------------ OptoAssembly for Compile_id = 260 -----------------------
#
#  java/lang/CharacterDataLatin1 * ( int )
#
#r012 c_rarg1   : parm 0: int
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B3 B2 )  Freq: 1

000     B1: #	out( B3 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     srliw  R28, R11, (#8 &amp; 0x1f)	#@urShiftI_reg_imm
020 +   bne  R28, zr, B3	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

024     B2: #	out( N1 ) &lt;- in( B1 )  Freq: 1
024 +   mv  R10, java/lang/CharacterDataLatin1:exact *	# ptr, #@loadConP
03c     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
054 +   ret	// return register, #@Ret

058     B3: #	out( N1 ) &lt;- in( B1 )  Freq: 5e-07
058 +   spill R11 -&gt; R8	# spill size = 32
05c +   spill R28 -&gt; [sp, #0]	# spill size = 32
060 +   li R11, #-187	# int, #@loadConI
064     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.CharacterData::of @ bci:4 (line 72) L[0]=R8 STK[0]=sp + #0
        # OopMap {off=104/0x68}
068 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='262'>
----------------------- MetaData before Compile_id = 262 ------------------------
{method}
 - this oop:          0x0000004096120198
 - method holder:     &apos;java/lang/Character&apos;
 - constants:         0x000000409611d860 constant pool [576] {0x000000409611d860} for &apos;java/lang/Character&apos; cache=0x00000040961e65e8
 - access:            0x81000009  public static 
 - name:              &apos;codePointAt&apos;
 - signature:         &apos;(Ljava/lang/CharSequence;I)I&apos;
 - max stack:         3
 - max locals:        4
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008320110: 0xba i2c: 0x00000040139438c0 c2i: 0x0000004013943908 c2iUV: 0x00000040139438d4
 - compiled entry     0x000000400c4ef740
 - code size:         51
 - code start:        0x0000004096120128
 - code end (excl):   0x000000409612015b
 - method data:       0x00000040965ecbe0
 - checked ex length: 0
 - linenumber start:  0x000000409612015b
 - localvar length:   4
 - localvar start:    0x0000004096120166
 - compiled code: nmethod   5884  116       3       java.lang.Character::codePointAt (51 bytes)

------------------------ OptoAssembly for Compile_id = 262 -----------------------
#
#  int ( java/lang/CharSequence *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/CharSequence *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B10 B7 B8 B9 B11 B6 )  Freq: 1

000     B1: #	out( B10 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
01c     lwu  R7, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
020     NullCheck R11

020     B2: #	out( B7 B3 ) &lt;- in( B1 )  Freq: 0.999999
020 +   mv  R29, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
030 +   bne  R7, R29, B7	#@cmpN_branch  P=0.000001 C=-1.000000

034     B3: #	out( B8 B4 ) &lt;- in( B2 )  Freq: 0.999998
034 +   # checkcastPP of R11, #@checkCastPP
034     lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
038 +   lb  R28, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
03c +   decode_heap_oop  R8, R7	#@decodeHeapOop
040 +   bne  R28, zr, B8	#@cmpI_reg_imm0_branch  P=0.000000 C=29648.000000

044     B4: #	out( B11 B5 ) &lt;- in( B3 )  Freq: 0.999997
044     lwu  R28, [R8, #12]	# range, #@loadRange
048     NullCheck R8

048     B5: #	out( B9 B6 ) &lt;- in( B4 )  Freq: 0.999996
048 +   bgeu  R12, R28, B9	#@cmpU_branch  P=0.000000 C=23657.000000

04c     B6: #	out( N1 ) &lt;- in( B5 )  Freq: 0.999996
04c +   addw  R7, R12, zr	#@convI2L_reg_reg
050 +   add R7, R8, R7	# ptr, #@addP_reg_reg
054 +   lbu  R10, [R7, #16]	# byte, #@loadUB
058     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
070 +   ret	// return register, #@Ret

074     B7: #	out( N1 ) &lt;- in( B2 )  Freq: 9.99999e-07
074 +   spill R11 -&gt; [sp, #8]	# spill size = 64
078 +   spill R12 -&gt; [sp, #4]	# spill size = 32
07c +   li R11, #-34	# int, #@loadConI
080     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #8 L[1]=sp + #4 L[2]=_ L[3]=_ STK[0]=sp + #8 STK[1]=sp + #4
        # OopMap {[8]=Oop off=132/0x84}
084     #@ShouldNotReachHere

090     B8: #	out( N1 ) &lt;- in( B3 )  Freq: 4.99999e-07
090 +   spill R11 -&gt; [sp, #8]	# spill size = 64
094 +   spill R12 -&gt; [sp, #4]	# spill size = 32
098 +   spill R28 -&gt; [sp, #16]	# spill size = 32
09c +   li R11, #-187	# int, #@loadConI
0a0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #16
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=sp + #8 L[1]=sp + #4
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #8 L[1]=sp + #4 L[2]=_ L[3]=_
        # OopMap {[8]=Oop off=164/0xa4}
0a4     #@ShouldNotReachHere

0b0     B9: #	out( N1 ) &lt;- in( B5 )  Freq: 4.76835e-07
0b0 +   spill R11 -&gt; [sp, #0]	# spill size = 64
0b4 +   spill R12 -&gt; [sp, #12]	# spill size = 32
0b8 +   spill R12 -&gt; [sp, #16]	# spill size = 32
0bc +   li R11, #-27	# int, #@loadConI
0c0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:1 (line 47) L[0]=R8 L[1]=sp + #16 STK[0]=sp + #12
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #0 L[1]=sp + #12 L[2]=_ L[3]=_
        # OopMap {fp=Oop [0]=Oop off=196/0xc4}
0c4     #@ShouldNotReachHere

0d0     B10: #	out( N1 ) &lt;- in( B1 )  Freq: 1.01328e-06
0d0 +   li R11, #-10	# int, #@loadConI
0d4     spill R12 -&gt; R8	# spill size = 32
0d8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL STK[1]=R8
        # OopMap {off=220/0xdc}
0dc     #@ShouldNotReachHere

0e8     B11: #	out( N1 ) &lt;- in( B4 )  Freq: 1.01328e-06
0e8 +   spill R11 -&gt; [sp, #0]	# spill size = 64
0ec +   spill R12 -&gt; [sp, #12]	# spill size = 32
0f0 +   spill R12 -&gt; [sp, #16]	# spill size = 32
0f4 +   li R11, #-10	# int, #@loadConI
0f8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::charAt @ bci:1 (line 47) L[0]=R8 L[1]=sp + #16 STK[0]=sp + #12
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #0 L[1]=sp + #12 L[2]=_ L[3]=_
        # OopMap {fp=Oop [0]=Oop off=252/0xfc}
0fc +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='280'>
----------------------- MetaData before Compile_id = 280 ------------------------
{method}
 - this oop:          0x00000040961e9788
 - method holder:     &apos;java/lang/CharacterDataLatin1&apos;
 - constants:         0x00000040961e89b8 constant pool [130] {0x00000040961e89b8} for &apos;java/lang/CharacterDataLatin1&apos; cache=0x00000040961eb818
 - access:            0x81000000  
 - name:              &apos;isJavaIdentifierPart&apos;
 - signature:         &apos;(I)Z&apos;
 - max stack:         3
 - max locals:        3
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      28
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bb30: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c4f1180
 - code size:         20
 - code start:        0x00000040961e9748
 - code end (excl):   0x00000040961e975c
 - method data:       0x00000040965ed668
 - checked ex length: 0
 - linenumber start:  0x00000040961e975c
 - localvar length:   3
 - localvar start:    0x00000040961e9762
 - compiled code: nmethod   6312  119       3       java.lang.CharacterDataLatin1::isJavaIdentifierPart (20 bytes)

------------------------ OptoAssembly for Compile_id = 280 -----------------------
#
#  bool ( java/lang/CharacterDataLatin1:NotNull *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/CharacterDataLatin1:NotNull *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N48: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B4 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     zext.h  R7, R12	# s2ui, #@convS2UI_reg_reg_b
040 +   addw  R28, R7, zr	#@convI2L_reg_reg
044 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
048 +   mv  R29, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1157 address=0x00000040d833e580&gt; *	# ptr, #@loadConP
060 +   li R30, #256	# int, #@loadConI
064 +   add R28, R29, R28	# ptr, #@addP_reg_reg
068 +   bgeu  R7, R30, B4	#@cmpU_branch  P=0.000001 C=-1.000000

06c     B2: #	out( B5 B3 ) &lt;- in( B1 )  Freq: 0.999999
06c +   lw  R7, [R28, #16]	# int, #@loadI
070 +   li R29, #12288	# int, #@loadConI
074 +   andr  R8, R7, R29	#@andI_reg_reg
078 +   beq  R8, zr, B5	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

07c     B3: #	out( N48 ) &lt;- in( B2 )  Freq: 0.999999
07c +   li R10, #1	# int, #@loadConI
080     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
098 +   ret	// return register, #@Ret

09c     B4: #	out( N48 ) &lt;- in( B1 )  Freq: 1.01328e-06
09c +   li R11, #-28	# int, #@loadConI
0a0     spill R7 -&gt; R8	# spill size = 32
0a4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.CharacterDataLatin1::getProperties @ bci:7 (line 74) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#Ptr0x00000040d833e580 STK[1]=R8
        # java.lang.CharacterDataLatin1::isJavaIdentifierPart @ bci:2 (line 120) L[0]=_ L[1]=_ L[2]=_
        # OopMap {off=168/0xa8}
0a8     #@ShouldNotReachHere

0b4     B5: #	out( N48 ) &lt;- in( B2 )  Freq: 4.76837e-07
0b4 +   li R11, #-187	# int, #@loadConI
0b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.CharacterDataLatin1::isJavaIdentifierPart @ bci:11 (line 121) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8
        # OopMap {off=188/0xbc}
0bc +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='298'>
----------------------- MetaData before Compile_id = 298 ------------------------
{method}
 - this oop:          0x0000004096506500
 - method holder:     &apos;java/util/concurrent/locks/AbstractQueuedSynchronizer&apos;
 - constants:         0x0000004096505498 constant pool [349] {0x0000004096505498} for &apos;java/util/concurrent/locks/AbstractQueuedSynchronizer&apos; cache=0x0000004096508bb8
 - access:            0x81000014  protected final 
 - name:              &apos;compareAndSetState&apos;
 - signature:         &apos;(II)Z&apos;
 - max stack:         7
 - max locals:        3
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008317620: 0xbaa i2c: 0x0000004013945bc0 c2i: 0x0000004013945c0c c2iUV: 0x0000004013945bd8
 - compiled entry     0x000000400c4f8180
 - code size:         13
 - code start:        0x00000040965064c8
 - code end (excl):   0x00000040965064d5
 - method data:       0x00000040965eed10
 - checked ex length: 0
 - linenumber start:  0x00000040965064d5
 - localvar length:   3
 - localvar start:    0x00000040965064da
 - compiled code: nmethod   6569  140       3       java.util.concurrent.locks.AbstractQueuedSynchronizer::compareAndSetState (13 bytes)

------------------------ OptoAssembly for Compile_id = 298 -----------------------
#
#  bool ( java/util/concurrent/locks/ReentrantReadWriteLock$FairSync:NotNull:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/concurrent/locks/ReentrantReadWriteLock$FairSync:NotNull:exact *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N32: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N32 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     #@membar_release
	fence iorw ow
040 +   addi  R7, R11, #16	# ptr, #@addP_reg_imm
044     
044 +   cmpxchg_acq [R7], R12, R13	# (int) if [R7] == R12 then [R7] &lt;-- R13
	mv R10, R10 == R12	# R10 &lt;-- (R10 == R12 ? 1 : 0), #@compareAndSwapIAcq
060     
060 +   #@membar_acquire
	fence ir iorw
064 +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
07c +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='299'>
----------------------- MetaData before Compile_id = 299 ------------------------
{method}
 - this oop:          0x000000409600b6f0
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;hashCode&apos;
 - signature:         &apos;()I&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      3
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4acb40
 - code size:         60
 - code start:        0x000000409600b688
 - code end (excl):   0x000000409600b6c4
 - method data:       0x00000040962ffe18
 - checked ex length: 0
 - linenumber start:  0x000000409600b6c4
 - localvar length:   2
 - localvar start:    0x000000409600b6d6
 - compiled code: nmethod   6640    3       3       java.lang.String::hashCode (60 bytes)

------------------------ OptoAssembly for Compile_id = 299 -----------------------
#
#  int ( java/lang/String:NotNull:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N234: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B20 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lw  R10, [R11, #12]	# int, #@loadI ! Field: java/lang/String.hash
040     spill R11 -&gt; R29	# spill size = 64
044 +   bne  R10, zr, B20	#@cmpI_reg_imm0_branch  P=0.474233 C=5375.000000

048     B2: #	out( B22 B3 ) &lt;- in( B1 )  Freq: 0.525767
048 +   lbu  R28, [R11, #17]	# byte, #@loadUB ! Field: java/lang/String.hashIsZero
04c +   li R7, #0	# int, #@loadConI
050 +   bne  R28, zr, B22	#@cmpI_reg_imm0_branch  P=0.001062 C=2825.000000

054     B3: #	out( B27 B4 ) &lt;- in( B2 )  Freq: 0.525209
054 +   lwu  R30, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
058 +   lb  R8, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
05c +   decode_heap_oop  R13, R30	#@decodeHeapOop
060 +   bne  R8, zr, B27	#@cmpI_reg_imm0_branch  P=0.000000 C=32293.000000

064     B4: #	out( B30 B5 ) &lt;- in( B3 )  Freq: 0.525209
064     lwu  R12, [R13, #12]	# range, #@loadRange
068     NullCheck R13

068     B5: #	out( B21 B6 ) &lt;- in( B4 )  Freq: 0.525208
068 +   li R16, #1	# int, #@loadConI
06c +   bleu  R12, zr, B21	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.056079 C=18260.000000

070     B6: #	out( B23 B7 ) &lt;- in( B5 )  Freq: 0.495755
070 +   addiw  R28, R12, #-1	#@addI_reg_imm
074 +   bgeu  R28, R12, B23	#@cmpU_branch  P=0.000001 C=-1.000000

078     B7: #	out( B24 B8 ) &lt;- in( B6 )  Freq: 0.495755
078 +   addiw  R14, R12, #-3	#@addI_reg_imm
07c +   li R15, #4000	# int, #@loadConI
084 +   lbu  R10, [R13, #16]	# byte, #@loadUB
088 +   ble  R14, R16, B24	#@cmpI_branch  P=0.000001 C=-1.000000

08c     B8: #	out( B25 B9 ) &lt;- in( B7 )  Freq: 0.495754
08c +   slliw  R30, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
090 +   subw  R28, R30, R10	#@subI_reg_reg
094 +   li R30, #4	# int, #@loadConI
098 +   bleu  R12, R16, B25	#@cmpU_branch  P=0.000001 C=-1.000000

09c     B9: #	out( B26 B10 ) &lt;- in( B8 )  Freq: 0.495754
09c +   bleu  R12, R30, B26	#@cmpU_branch  P=0.000001 C=-1.000000

0a0     B10: #	out( B11 ) &lt;- in( B9 )  Freq: 0.495753
0a0 +   li R9, #1	# int, #@loadConI
0a4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP

0a4     B11: #	out( B12 ) &lt;- in( B10 B13 ) Loop( B11-B13 ) Freq: 8.84029
0a4     subw  R31, R12, R9	#@subI_reg_reg
0a8 +   addiw  R30, R31, #-3	#@addI_reg_imm
0ac     CMove R30, (R14 lt R9), R30, R7	#@cmovI_cmpI
	
0b4 +   CMove R30, (R30 gtu R15), R30, R15	#@cmovI_cmpU
	
0bc +   addw  R17, R30, R9	#@addI_reg_reg

0c0     B12: #	out( B12 B13 ) &lt;- in( B11 B12 ) Loop( B12-B12 inner main of N69 strip mined) Freq: 157.64
0c0 +   addw  R30, R9, zr	#@convI2L_reg_reg
0c4 +   add R30, R13, R30	# ptr, #@addP_reg_reg
0c8 +   lbu  R10, [R30, #16]	# byte, #@loadUB
0cc +   addw  R10, R28, R10	#@addI_reg_reg
0d0 +   lbu  R31, [R30, #17]	# byte, #@loadUB
0d4 +   slliw  R11, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0d8 +   subw  R28, R11, R10	#@subI_reg_reg
0dc +   addw  R31, R28, R31	#@addI_reg_reg
0e0 +   slliw  R28, R31, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0e4 +   lbu  R11, [R30, #18]	# byte, #@loadUB
0e8 +   subw  R31, R28, R31	#@subI_reg_reg
0ec +   lbu  R28, [R30, #19]	# byte, #@loadUB
0f0 +   addw  R31, R31, R11	#@addI_reg_reg
0f4 +   slliw  R30, R31, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0f8 +   subw  R31, R30, R31	#@subI_reg_reg
0fc +   addw  R10, R31, R28	#@addI_reg_reg
100 +   slliw  R28, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
104 +   addiw  R9, R9, #4	#@addI_reg_imm
108 +   subw  R28, R28, R10	#@subI_reg_reg
10c +   blt  R9, R17, B12	#@cmpI_loop  P=0.943921 C=17236.000000

110     B13: #	out( B11 B14 ) &lt;- in( B12 )  Freq: 8.84029
110 +   ld  R30, [R23, #920]	# ptr, #@loadP
114 +   lwu zr, [R30]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::hashCode @ bci:37 (line 196) L[0]=_ L[1]=R10 L[2]=R13 L[3]=R12 L[4]=R9 L[5]=_
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=R29 L[1]=_
        # OopMap {x29=Oop c_rarg3=Oop off=276/0x114}
118 +   blt  R9, R14, B11	#@cmpI_branch  P=0.943921 C=17236.000000

11c     B14: #	out( B18 B15 ) &lt;- in( B24 B13 )  Freq: 0.495754
11c +   bge  R9, R12, B18	#@cmpI_branch  P=0.500000 C=-1.000000

120     B15: #	out( B28 B16 ) &lt;- in( B14 )  Freq: 0.247877
120 +   # castII of R9, #@castII
120     bgeu  R9, R12, B28	#@cmpU_branch  P=0.000001 C=-1.000000

124     B16: #	out( B29 B17 ) &lt;- in( B15 )  Freq: 0.247877
124 +   spill R9 -&gt; R28	# spill size = 32
128 +   # castII of R28, #@castII
128     bgeu  R28, R12, B29	#@cmpU_branch  P=0.000001 C=-1.000000

12c     B17: #	out( B17 B18 ) &lt;- in( B16 B17 ) Loop( B17-B17 inner post of N283) Freq: 0.495753
12c +   addw  R7, R9, zr	#@convI2L_reg_reg
130 +   add R7, R13, R7	# ptr, #@addP_reg_reg
134 +   slliw  R30, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
138 +   lbu  R7, [R7, #16]	# byte, #@loadUB
13c +   subw  R28, R30, R10	#@subI_reg_reg
140 +   addiw  R9, R9, #1	#@addI_reg_imm
144 +   addw  R10, R28, R7	#@addI_reg_reg
148 +   blt  R9, R12, B17	#@cmpI_loop  P=0.500000 C=17236.000000

14c     B18: #	out( B21 B19 ) &lt;- in( B17 B14 )  Freq: 0.495753
14c +   beq  R10, zr, B21	#@cmpI_reg_imm0_branch  P=0.000354 C=2822.000000

150     B19: #	out( B20 ) &lt;- in( B18 )  Freq: 0.495578
150 +   sw  R10, [R29, #12]	# int, #@storeI ! Field: java/lang/String.hash

154     B20: #	out( N234 ) &lt;- in( B19 B21 B22 B1 )  Freq: 0.999997
154     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
16c +   ret	// return register, #@Ret

170     B21: #	out( B20 ) &lt;- in( B18 B5 )  Freq: 0.0296288
170 +   sb  R16, [R29, #17]	# byte, #@storeB ! Field: java/lang/String.hashIsZero
174 +   li R10, #0	# int, #@loadConI
178 +   j  B20	#@branch

17c     B22: #	out( B20 ) &lt;- in( B2 )  Freq: 0.000558337
17c +   li R10, #0	# int, #@loadConI
180 +   j  B20	#@branch

184     B23: #	out( N234 ) &lt;- in( B6 )  Freq: 5.02338e-07
184 +   li R11, #-138	# int, #@loadConI
188     spill R29 -&gt; R8	# spill size = 64
18c +   spill R13 -&gt; [sp, #0]	# spill size = 64
190 +   spill R12 -&gt; [sp, #12]	# spill size = 32
194     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:13 (line 196) L[0]=_ L[1]=#0 L[2]=sp + #0 L[3]=sp + #12 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=sp + #12
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=R8 L[1]=_
        # OopMap {fp=Oop [0]=Oop off=408/0x198}
198     #@ShouldNotReachHere

1a4     B24: #	out( B14 ) &lt;- in( B7 )  Freq: 5.02338e-07
1a4 +   li R9, #1	# int, #@loadConI
1a8 +   j  B14	#@branch

1ac     B25: #	out( N234 ) &lt;- in( B8 )  Freq: 4.95754e-07
1ac     #@ShouldNotReachHere

1b8     B26: #	out( N234 ) &lt;- in( B9 )  Freq: 4.95754e-07
1b8     #@ShouldNotReachHere

1c4     B27: #	out( N234 ) &lt;- in( B3 )  Freq: 2.62605e-07
1c4 +   li R11, #-187	# int, #@loadConI
1c8     spill R29 -&gt; [sp, #0]	# spill size = 64
1cc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=R8
        # java.lang.String::hashCode @ bci:17 (line 2337) L[0]=sp + #0 L[1]=_
        # OopMap {[0]=Oop off=464/0x1d0}
1d0     #@ShouldNotReachHere

1dc     B28: #	out( N234 ) &lt;- in( B15 )  Freq: 2.51168e-07
1dc     #@ShouldNotReachHere

1e8     B29: #	out( N234 ) &lt;- in( B16 )  Freq: 2.51168e-07
1e8     #@ShouldNotReachHere

1f4     B30: #	out( N234 ) &lt;- in( B4 )  Freq: 5.32183e-07
1f4 +   li R11, #-10	# int, #@loadConI
1f8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:5 (line 196) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=_ L[1]=_
        # OopMap {off=508/0x1fc}
1fc     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='300'>
----------------------- MetaData before Compile_id = 300 ------------------------
{method}
 - this oop:          0x0000004096186b38
 - method holder:     &apos;java/lang/StringLatin1&apos;
 - constants:         0x0000004096185338 constant pool [380] {0x0000004096185338} for &apos;java/lang/StringLatin1&apos; cache=0x0000004096189c30
 - access:            0xc1000009  public static 
 - name:              &apos;equals&apos;
 - signature:         &apos;([B[B)Z&apos;
 - max stack:         4
 - max locals:        3
 - size of params:    2
 - method size:       13
 - intrinsic id:      109 _equalsL
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400831b380: 0xbb i2c: 0x000000401396c3c0 c2i: 0x000000401396c408 c2iUV: 0x000000401396c3d4
 - compiled entry     0x000000400c4d8280
 - code size:         36
 - code start:        0x0000004096186ad8
 - code end (excl):   0x0000004096186afc
 - method data:       0x000000409654abe0
 - checked ex length: 0
 - linenumber start:  0x0000004096186afc
 - localvar length:   3
 - localvar start:    0x0000004096186b0a
 - compiled code: nmethod   6746   80       3       java.lang.StringLatin1::equals (36 bytes)

------------------------ OptoAssembly for Compile_id = 300 -----------------------
#
#  bool ( byte[int:&gt;=0]:exact *, byte[int:&gt;=0]:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: byte[int:&gt;=0]:exact *
#r014 c_rarg2:c_rarg2   : parm 1: byte[int:&gt;=0]:exact *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B41 B42 B31 B40 B39 B30 B33 B36 B37 B38 B34 B35 )  Freq: 1

000     B1: #	out( B41 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     lwu  R28, [R11, #12]	# range, #@loadRange
020     NullCheck R11

020     B2: #	out( B42 B3 ) &lt;- in( B1 )  Freq: 0.999999
020     lwu  R15, [R12, #12]	# range, #@loadRange
024     NullCheck R12

024     B3: #	out( B30 B4 ) &lt;- in( B2 )  Freq: 0.999998
024 +   li R10, #0	# int, #@loadConI
028 +   bne  R28, R15, B30	#@cmpI_branch  P=0.614652 C=4095.000000

02c     B4: #	out( B29 B5 ) &lt;- in( B3 )  Freq: 0.385347
02c +   li R29, #1	# int, #@loadConI
030 +   bleu  R28, zr, B29	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.053177 C=14668.000000

034     B5: #	out( B31 B6 ) &lt;- in( B4 )  Freq: 0.364856
034 +   addiw  R7, R28, #-1	#@addI_reg_imm
038 +   bgeu  R7, R28, B31	#@cmpU_branch  P=0.000001 C=-1.000000

03c     B6: #	out( B31 B7 ) &lt;- in( B5 )  Freq: 0.364855
03c +   lb  R31, [R11, #16]	# byte, #@loadB
040 +   bleu  R15, zr, B31	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

044     B7: #	out( B31 B8 ) &lt;- in( B6 )  Freq: 0.364855
044 +   bgeu  R7, R15, B31	#@cmpU_branch  P=0.000001 C=-1.000000

048     B8: #	out( B30 B9 ) &lt;- in( B7 )  Freq: 0.364854
048 +   lb  R30, [R12, #16]	# byte, #@loadB
04c +   bne  R31, R30, B30	#@cmpI_branch  P=0.057460 C=13888.000000

050     B9: #	out( B32 B10 ) &lt;- in( B8 )  Freq: 0.34389
050 +   li R31, #-2147483648	# int, #@loadConI
054 +   addiw  R16, R28, #-3	#@addI_reg_imm
058     CMove R16, (R7 lt R16), R16, R31	#@cmovI_cmpI
	
060 +   li R17, #4000	# int, #@loadConI
068 +   ble  R16, R29, B32	#@cmpI_branch  P=0.000001 C=-1.000000

06c     B10: #	out( B33 B11 ) &lt;- in( B9 )  Freq: 0.34389
06c +   li R7, #4	# int, #@loadConI
070 +   bleu  R15, R29, B33	#@cmpU_branch  P=0.000001 C=-1.000000

074     B11: #	out( B34 B12 ) &lt;- in( B10 )  Freq: 0.343889
074 +   bleu  R28, R29, B34	#@cmpU_branch  P=0.000001 C=-1.000000

078     B12: #	out( B35 B13 ) &lt;- in( B11 )  Freq: 0.343889
078 +   bleu  R28, R7, B35	#@cmpU_branch  P=0.000001 C=-1.000000

07c     B13: #	out( B36 B14 ) &lt;- in( B12 )  Freq: 0.343889
07c +   bleu  R15, R7, B36	#@cmpU_branch  P=0.000001 C=-1.000000

080     B14: #	out( B15 ) &lt;- in( B13 )  Freq: 0.343888
080 +   li R9, #1	# int, #@loadConI

084     B15: #	out( B16 ) &lt;- in( B14 B21 ) Loop( B15-B21 ) Freq: 0.408041
084 +   subw  R29, R16, R9	#@subI_reg_reg
088     CMove R29, (R16 lt R9), R29, R10	#@cmovI_cmpI
	
090 +   CMove R29, (R29 gtu R17), R29, R17	#@cmovI_cmpU
	
098 +   addw  R14, R29, R9	#@addI_reg_reg
        nop 	# 2 bytes pad for loops and calls

0a0     B16: #	out( B30 B17 ) &lt;- in( B15 B20 ) Loop( B16-B20 inner main of N91 strip mined) Freq: 1.61443
0a0 +   addw  R7, R9, zr	#@convI2L_reg_reg
0a4 +   add R29, R11, R7	# ptr, #@addP_reg_reg
0a8 +   lb  R30, [R29, #16]	# byte, #@loadB
0ac +   add R7, R12, R7	# ptr, #@addP_reg_reg
0b0 +   lb  R13, [R7, #16]	# byte, #@loadB
0b4 +   bne  R30, R13, B30	#@cmpI_branch  P=0.057460 C=13888.000000

0b8     B17: #	out( B30 B18 ) &lt;- in( B16 )  Freq: 1.52167
0b8 +   lb  R30, [R29, #17]	# byte, #@loadB
0bc +   lb  R31, [R7, #17]	# byte, #@loadB
0c0 +   bne  R30, R31, B30	#@cmpI_branch  P=0.057460 C=13888.000000

0c4     B18: #	out( B30 B19 ) &lt;- in( B17 )  Freq: 1.43423
0c4 +   lb  R30, [R29, #18]	# byte, #@loadB
0c8 +   lb  R31, [R7, #18]	# byte, #@loadB
0cc +   bne  R30, R31, B30	#@cmpI_branch  P=0.057460 C=13888.000000

0d0     B19: #	out( B30 B20 ) &lt;- in( B18 )  Freq: 1.35182
0d0 +   lb  R30, [R29, #19]	# byte, #@loadB
0d4 +   lb  R7, [R7, #19]	# byte, #@loadB
0d8 +   bne  R30, R7, B30	#@cmpI_branch  P=0.057460 C=13888.000000

0dc     B20: #	out( B16 B21 ) &lt;- in( B19 )  Freq: 1.27415
0dc +   addiw  R9, R9, #4	#@addI_reg_imm
0e0 +   blt  R9, R14, B16	#@cmpI_loop  P=0.946823 C=13090.000000

0e4     B21: #	out( B15 B22 ) &lt;- in( B20 )  Freq: 0.0677554
0e4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e4     ld  R7, [R23, #920]	# ptr, #@loadP
0e8 +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::equals @ bci:29 (line 96) L[0]=R11 L[1]=R12 L[2]=R9
        # OopMap {c_rarg1=Oop c_rarg2=Oop off=232/0xe8}
0ec +   blt  R9, R16, B15	#@cmpI_branch  P=0.946823 C=13090.000000

0f0     B22: #	out( B29 B23 ) &lt;- in( B32 B21 )  Freq: 0.00360338
0f0 +   bge  R9, R28, B29	#@cmpI_branch  P=0.500000 C=-1.000000

0f4     B23: #	out( B37 B24 ) &lt;- in( B22 )  Freq: 0.00180169
0f4 +   # castII of R9, #@castII
0f4     bgeu  R9, R28, B37	#@cmpU_branch  P=0.000001 C=-1.000000

0f8     B24: #	out( B38 B25 ) &lt;- in( B23 )  Freq: 0.00180169
0f8 +   spill R9 -&gt; R29	# spill size = 32
0fc +   # castII of R29, #@castII
0fc     bgeu  R29, R28, B38	#@cmpU_branch  P=0.000001 C=-1.000000

100     B25: #	out( B39 B26 ) &lt;- in( B24 )  Freq: 0.00180168
100 +   bgeu  R9, R15, B39	#@cmpU_branch  P=0.000001 C=-1.000000

104     B26: #	out( B40 B27 ) &lt;- in( B25 )  Freq: 0.00180168
104 +   bgeu  R29, R15, B40	#@cmpU_branch  P=0.000001 C=-1.000000

108     B27: #	out( B30 B28 ) &lt;- in( B26 B28 ) Loop( B27-B28 inner post of N209) Freq: 0.00340756
108 +   addw  R7, R9, zr	#@convI2L_reg_reg
10c +   add R29, R11, R7	# ptr, #@addP_reg_reg
110 +   lb  R29, [R29, #16]	# byte, #@loadB
114 +   add R7, R12, R7	# ptr, #@addP_reg_reg
118 +   lb  R30, [R7, #16]	# byte, #@loadB
11c +   bne  R29, R30, B30	#@cmpI_branch  P=0.057460 C=13888.000000

120     B28: #	out( B27 B29 ) &lt;- in( B27 )  Freq: 0.00321177
120 +   addiw  R9, R9, #1	#@addI_reg_imm
124 +   blt  R9, R28, B27	#@cmpI_loop  P=0.500000 C=13090.000000

128     B29: #	out( B30 ) &lt;- in( B22 B4 B28 )  Freq: 0.0238992
128 +   li R10, #1	# int, #@loadConI

12c     B30: #	out( N1 ) &lt;- in( B27 B18 B8 B16 B17 B19 B29 B3 )  Freq: 0.999995
12c     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
144 +   ret	// return register, #@Ret

148     B31: #	out( N1 ) &lt;- in( B6 B7 B5 )  Freq: 1.10426e-06
148 +   spill R11 -&gt; R8	# spill size = 64
14c +   spill R12 -&gt; [sp, #0]	# spill size = 64
150 +   spill R28 -&gt; [sp, #8]	# spill size = 32
154 +   li R11, #-138	# int, #@loadConI
158     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::equals @ bci:12 (line 96) L[0]=R8 L[1]=sp + #0 L[2]=#0 STK[0]=#0 STK[1]=sp + #8
        # OopMap {fp=Oop [0]=Oop off=348/0x15c}
15c     #@ShouldNotReachHere

168     B32: #	out( B22 ) &lt;- in( B9 )  Freq: 3.48457e-07
168 +   li R9, #1	# int, #@loadConI
16c +   j  B22	#@branch

170     B33: #	out( N1 ) &lt;- in( B10 )  Freq: 3.4389e-07
170     #@ShouldNotReachHere

17c     B34: #	out( N1 ) &lt;- in( B11 )  Freq: 3.43889e-07
17c     #@ShouldNotReachHere

188     B35: #	out( N1 ) &lt;- in( B12 )  Freq: 3.43889e-07
188     #@ShouldNotReachHere

194     B36: #	out( N1 ) &lt;- in( B13 )  Freq: 3.43889e-07
194     #@ShouldNotReachHere

1a0     B37: #	out( N1 ) &lt;- in( B23 )  Freq: 1.82561e-09
1a0     #@ShouldNotReachHere

1ac     B38: #	out( N1 ) &lt;- in( B24 )  Freq: 1.82561e-09
1ac     #@ShouldNotReachHere

1b8     B39: #	out( N1 ) &lt;- in( B25 )  Freq: 1.82561e-09
1b8     #@ShouldNotReachHere

1c4     B40: #	out( N1 ) &lt;- in( B26 )  Freq: 1.82561e-09
1c4     #@ShouldNotReachHere

1d0     B41: #	out( N1 ) &lt;- in( B1 )  Freq: 1.01328e-06
1d0 +   li R11, #-10	# int, #@loadConI
1d4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::equals @ bci:1 (line 95) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # OopMap {off=472/0x1d8}
1d8     #@ShouldNotReachHere

1e4     B42: #	out( N1 ) &lt;- in( B2 )  Freq: 1.01328e-06
1e4 +   li R11, #-10	# int, #@loadConI
1e8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::equals @ bci:3 (line 95) L[0]=_ L[1]=_ L[2]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=492/0x1ec}
1ec     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='301'>
----------------------- MetaData before Compile_id = 301 ------------------------
{method}
 - this oop:          0x000000409600e598
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;toString&apos;
 - signature:         &apos;()Ljava/lang/String;&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c509280
 - code size:         2
 - code start:        0x000000409600e580
 - code end (excl):   0x000000409600e582
 - method data:       0x0000004096487c70
 - checked ex length: 0
 - linenumber start:  0x000000409600e582
 - localvar length:   1
 - localvar start:    0x000000409600e58a
 - compiled code: nmethod   6763  183       3       java.lang.String::toString (2 bytes)

------------------------ OptoAssembly for Compile_id = 301 -----------------------
#
#  java/lang/String:exact * ( java/lang/String:NotNull:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N16: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N16 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     spill R11 -&gt; R10	# spill size = 64
040 +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
058 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='302'>
----------------------- MetaData before Compile_id = 302 ------------------------
{method}
 - this oop:          0x000000409600a890
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;equals&apos;
 - signature:         &apos;(Ljava/lang/Object;)Z&apos;
 - max stack:         3
 - max locals:        3
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      1
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bd00: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c4bb740
 - code size:         56
 - code start:        0x000000409600a820
 - code end (excl):   0x000000409600a858
 - method data:       0x00000040963f5748
 - checked ex length: 0
 - linenumber start:  0x000000409600a858
 - localvar length:   3
 - localvar start:    0x000000409600a86a
 - compiled code: nmethod   6803   49       3       java.lang.String::equals (56 bytes)

------------------------ OptoAssembly for Compile_id = 302 -----------------------
#
#  bool ( java/lang/String:NotNull:exact *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N111: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B10 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     beq  R11, R12, B10	#@cmpP_branch  P=0.064830 C=5337.000000

040     B2: #	out( B16 B3 ) &lt;- in( B1 )  Freq: 0.93517
040     lwu  R7, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
044     NullCheck R12

044     B3: #	out( B15 B4 ) &lt;- in( B2 )  Freq: 0.935169
044 +   mv  R29, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
054 +   lb  R30, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
058 +   bne  R7, R29, B15	#@cmpN_branch  P=0.000000 C=-1.000000

05c     B4: #	out( B14 B5 ) &lt;- in( B3 )  Freq: 0.935169
05c +   # checkcastPP of R12, #@checkCastPP
05c     lb  R8, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
060 +   bne  R30, R8, B14	#@cmpI_branch  P=0.000000 C=4991.000000

064     B5: #	out( B12 B6 ) &lt;- in( B4 )  Freq: 0.935168
064 +   lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
068 +   decode_heap_oop  R7, R7	#@decodeHeapOop
06c +   lwu  R29, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
070 +   beq   R7, zr, B12	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

074     B6: #	out( B13 B7 ) &lt;- in( B5 )  Freq: 0.935167
074 +   decode_heap_oop  R28, R29	#@decodeHeapOop
078 +   lwu  R14, [R7, #12]	# range, #@loadRange
07c +   beq   R28, zr, B13	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

080     B7: #	out( B11 B8 ) &lt;- in( B6 )  Freq: 0.935166
080 +   lwu  R30, [R28, #12]	# range, #@loadRange
084 +   bne  R14, R30, B11	#@cmpI_branch  P=0.001000 C=-1.000000

088     B8: #	out( B9 ) &lt;- in( B7 )  Freq: 0.934231
088 +   addi  R13, R28, #16	# ptr, #@addP_reg_imm
08c +   addi  R11, R7, #16	# ptr, #@addP_reg_imm
090 +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL

120     B9: #	out( N111 ) &lt;- in( B10 B8 B11 )  Freq: 0.999997
120     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
138     ret	// return register, #@Ret

13c     B10: #	out( B9 ) &lt;- in( B1 )  Freq: 0.0648304
13c +   li R10, #1	# int, #@loadConI
140 +   j  B9	#@branch

144     B11: #	out( B9 ) &lt;- in( B7 )  Freq: 0.000935166
144 +   li R10, #0	# int, #@loadConI
148 +   j  B9	#@branch

14c     B12: #	out( N111 ) &lt;- in( B5 )  Freq: 9.47586e-07
14c     #@ShouldNotReachHere

158     B13: #	out( N111 ) &lt;- in( B6 )  Freq: 9.47585e-07
158     #@ShouldNotReachHere

164     B14: #	out( N111 ) &lt;- in( B4 )  Freq: 4.67584e-07
164 +   spill R11 -&gt; [sp, #0]	# spill size = 64
168 +   spill R12 -&gt; [sp, #8]	# spill size = 64
16c +   spill R30 -&gt; [sp, #16]	# spill size = 32
170 +   li R11, #-187	# int, #@loadConI
174     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #0 L[1]=_ L[2]=sp + #8 STK[0]=sp + #16 STK[1]=R8
        # OopMap {[0]=Oop [8]=Oop off=376/0x178}
178     #@ShouldNotReachHere

184     B15: #	out( N111 ) &lt;- in( B3 )  Freq: 1e-35
184 +   spill R11 -&gt; R8	# spill size = 64
188 +   spill R12 -&gt; [sp, #8]	# spill size = 64
18c +   li R11, #-34	# int, #@loadConI
190     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=R8 L[1]=sp + #8 L[2]=_ STK[0]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=404/0x194}
194     #@ShouldNotReachHere

1a0     B16: #	out( N111 ) &lt;- in( B2 )  Freq: 9.47588e-07
1a0 +   spill R11 -&gt; R8	# spill size = 64
1a4 +   li R11, #-12	# int, #@loadConI
1a8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=R8 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # OopMap {fp=Oop off=428/0x1ac}
1ac     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='303'>
----------------------- MetaData before Compile_id = 303 ------------------------
{method}
 - this oop:          0x0000004096187e38
 - method holder:     &apos;java/lang/StringLatin1&apos;
 - constants:         0x0000004096185338 constant pool [380] {0x0000004096185338} for &apos;java/lang/StringLatin1&apos; cache=0x0000004096189c30
 - access:            0xc1000009  public static 
 - name:              &apos;replace&apos;
 - signature:         &apos;([BCC)Ljava/lang/String;&apos;
 - max stack:         6
 - max locals:        7
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008317620: 0xbaa i2c: 0x0000004013945bc0 c2i: 0x0000004013945c0c c2iUV: 0x0000004013945bd8
 - compiled entry     0x000000400c4da940
 - code size:         198
 - code start:        0x0000004096187cd0
 - code end (excl):   0x0000004096187d96
 - method data:       0x00000040965bec28
 - checked ex length: 0
 - linenumber start:  0x0000004096187d96
 - localvar length:   10
 - localvar start:    0x0000004096187dbe
 - compiled code: nmethod   7044   88       3       java.lang.StringLatin1::replace (198 bytes)

------------------------ OptoAssembly for Compile_id = 303 -----------------------
#
#  java/lang/String:exact * ( byte[int:&gt;=0]:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: byte[int:&gt;=0]:exact *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B100 B108 B90 B97 B103 B111 B101 B95 B98 B93 B75 B102 B91 B92 B96 B94 B105 B49 B106 B107 B99 B104 )  Freq: 1

000     B1: #	out( B100 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
01c     srliw  R28, R12, (#8 &amp; 0x1f)	#@urShiftI_reg_imm
020     spill R11 -&gt; R7	# spill size = 64
024 +   bne  R28, zr, B100	#@cmpI_reg_imm0_branch  P=0.000000 C=6786.000000

028     B2: #	out( B108 B3 ) &lt;- in( B1 )  Freq: 1
028 +   spill R11 -&gt; R15	# spill size = 64
02c     lwu  R10, [R11, #12]	# range, #@loadRange
030     NullCheck R11

030     B3: #	out( B85 B4 ) &lt;- in( B2 )  Freq: 0.999999
030 +   bleu  R10, zr, B85	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000829 C=4825.000000

034     B4: #	out( B90 B5 ) &lt;- in( B3 )  Freq: 0.999169
034 +   addiw  R9, R10, #-1	#@addI_reg_imm
038 +   bgeu  R9, R10, B90	#@cmpU_branch  P=0.000001 C=-1.000000

03c     B5: #	out( B7 B6 ) &lt;- in( B4 )  Freq: 0.999168
03c +   lb  R28, [R11, #16]	# byte, #@loadB
040 +   sext.b  R11, R12	# b2i, #@convB2I_reg_reg_b
044 +   addiw  R16, R10, #-3	#@addI_reg_imm
048 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
048     bne  R28, R11, B7	#@cmpI_branch  P=0.788633 C=4821.000000

04c     B6: #	out( B18 ) &lt;- in( B5 )  Freq: 0.211191
04c +   li R8, #0	# int, #@loadConI
050 +   li R7, #1	# int, #@loadConI
054 +   j  B18	#@branch

058     B7: #	out( B78 B8 ) &lt;- in( B5 )  Freq: 0.787977
058 +   li R7, #1	# int, #@loadConI
05c +   ble  R16, R7, B78	#@cmpI_branch  P=0.000001 C=-1.000000

060     B8: #	out( B96 B9 ) &lt;- in( B7 )  Freq: 0.787976
060 +   li R29, #1	# int, #@loadConI
064 +   li R7, #4	# int, #@loadConI
068 +   bleu  R10, R29, B96	#@cmpU_branch  P=0.000001 C=-1.000000

06c     B9: #	out( B97 B10 ) &lt;- in( B8 )  Freq: 0.787976
06c +   bleu  R10, R7, B97	#@cmpU_branch  P=0.000001 C=-1.000000

070     B10: #	out( B11 ) &lt;- in( B9 )  Freq: 0.787975
070 +   li R14, #1	# int, #@loadConI
074 +   li R7, #1	# int, #@loadConI

078     B11: #	out( B12 ) &lt;- in( B10 B53 ) Loop( B11-B53 ) Freq: 0.788387
078     spill R14 -&gt; R17	# spill size = 32
        nop 	# 2 bytes pad for loops and calls

080     B12: #	out( B17 B13 ) &lt;- in( B11 B51 ) Loop( B12-B51 inner main of N152 strip mined) Freq: 1.28505
080 +   addw  R28, R17, zr	#@convI2L_reg_reg
084 +   add R28, R15, R28	# ptr, #@addP_reg_reg
088 +   lb  R30, [R28, #16]	# byte, #@loadB
08c +   beq  R30, R11, B17	#@cmpI_branch  P=0.211367 C=4821.000000

090     B13: #	out( B15 B14 ) &lt;- in( B12 )  Freq: 1.01343
090 +   lb  R29, [R28, #17]	# byte, #@loadB
094 +   bne  R29, R11, B15	#@cmpI_branch  P=0.788633 C=4821.000000

098     B14: #	out( B18 ) &lt;- in( B13 )  Freq: 0.214205
098 +   addiw  R8, R17, #1	#@addI_reg_imm
09c +   j  B18	#@branch

0a0     B15: #	out( B50 B16 ) &lt;- in( B13 )  Freq: 0.799224
0a0 +   lb  R29, [R28, #18]	# byte, #@loadB
0a4 +   bne  R29, R11, B50	#@cmpI_branch  P=0.788633 C=4821.000000

0a8     B16: #	out( B17 ) &lt;- in( B15 )  Freq: 0.16893
0a8 +   addiw  R17, R17, #2	#@addI_reg_imm

0ac     B17: #	out( B18 ) &lt;- in( B12 B16 )  Freq: 0.440546
0ac     spill R17 -&gt; R8	# spill size = 32

0b0     B18: #	out( B85 B19 ) &lt;- in( B83 B6 B17 B14 B50 )  Freq: 0.999166
0b0 +   bge  R8, R10, B85	#@cmpI_branch  P=0.003910 C=1023.000000

0b4     B19: #	out( B101 B20 ) &lt;- in( B18 )  Freq: 0.995259
0b4 +   srliw  R28, R13, (#8 &amp; 0x1f)	#@urShiftI_reg_imm
0b8 +   li R30, #1048576	# int, #@loadConI
0bc     spill R13 -&gt; R14	# spill size = 32
0c0 +   bne  R28, zr, B101	#@cmpI_reg_imm0_branch  P=0.000000 C=6786.000000

0c4     B20: #	out( B86 B21 ) &lt;- in( B19 )  Freq: 0.995259
0c4 +   bgtu  R10, R30, B86	#@cmpU_branch  P=0.000001 C=-1.000000

0c8     B21: #	out( B86 B22 ) &lt;- in( B20 )  Freq: 0.995258
0c8 +   addw  R28, R10, zr	#@convI2L_reg_reg
0cc +   addi  R28, R28, #23	#@addL_reg_imm
0d0 +   ld  R30, [R23, #288]	# ptr, #@loadP
0d4 +   andi  R28, R28, #-8	#@andL_reg_imm
0d8 +   ld  R29, [R23, #304]	# ptr, #@loadP
0dc +   add R28, R30, R28	# ptr, #@addP_reg_reg
0e0 +   bgeu  R28, R29, B86	#@cmpP_branch  P=0.000100 C=-1.000000

0e4     B22: #	out( B23 ) &lt;- in( B21 )  Freq: 0.995158
0e4 +   sd  R28, [R23, #288]	# ptr, #@storeP
0e8 +   li R28, #1	# long, #@loadConL
0ec +   sd  R28, [R30]	# long, #@storeL
0f0 +   mv  R28, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
100 +   sw  R28, [R30, #8]	# compressed klass ptr, #@storeNKlass
104 +   sw  R10, [R30, #12]	# int, #@storeI

108     B23: #	out( B36 B24 ) &lt;- in( B87 B22 )  Freq: 0.995259
108     
108 +   MEMBAR-store-store	#@membar_storestore
10c +   # checkcastPP of R30, #@checkCastPP
10c     spill R30 -&gt; [sp, #24]	# spill size = 64
110 +   ble  R8, zr, B36	#@cmpI_reg_imm0_branch  P=0.213314 C=4777.000000

114     B24: #	out( B95 B25 ) &lt;- in( B23 )  Freq: 0.782956
114 +   addiw  R13, R8, #-1	#@addI_reg_imm
118 +   bgeu  R13, R10, B95	#@cmpU_branch  P=0.000001 C=-1.000000

11c     B25: #	out( B95 B26 ) &lt;- in( B24 )  Freq: 0.782955
11c +   li R18, #2000	# int, #@loadConI
120 +   lb  R29, [R15, #16]	# byte, #@loadB
124 +   bleu  R10, zr, B95	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

128     B26: #	out( B32 B27 ) &lt;- in( B25 )  Freq: 0.782955
128 +   sb  R29, [R30, #16]	# byte, #@storeB
12c +   ble  R13, R7, B32	#@cmpI_branch  P=0.000001 C=-1.000000

130     B27: #	out( B98 B28 ) &lt;- in( B26 )  Freq: 0.782954
130 +   li R28, #2	# int, #@loadConI
134 +   bleu  R10, R7, B98	#@cmpU_branch  P=0.000001 C=-1.000000

138     B28: #	out( B99 B29 ) &lt;- in( B27 )  Freq: 0.782953
138 +   bleu  R10, R28, B99	#@cmpU_branch  P=0.000001 C=-1.000000

13c     B29: #	out( B30 ) &lt;- in( B28 B31 ) Loop( B29-B31 ) Freq: 3.67042
13c +   subw  R29, R8, R7	#@subI_reg_reg
140 +   li R30, #0	# int, #@loadConI
144 +   addiw  R28, R29, #-1	#@addI_reg_imm
148     CMove R28, (R13 lt R7), R28, R30	#@cmovI_cmpI
	
150 +   CMove R28, (R28 gtu R18), R28, R18	#@cmovI_cmpU
	
158 +   addw  R29, R28, R7	#@addI_reg_reg
        nop 	# 2 bytes pad for loops and calls

160     B30: #	out( B30 B31 ) &lt;- in( B29 B30 ) Loop( B30-B30 inner main of N231 strip mined) Freq: 17.2067
160 +   addw  R28, R7, zr	#@convI2L_reg_reg
164 +   add R30, R15, R28	# ptr, #@addP_reg_reg
168 +   lb  R31, [R30, #16]	# byte, #@loadB
16c +   spill [sp, #24] -&gt; R17	# spill size = 64
170 +   add R28, R17, R28	# ptr, #@addP_reg_reg
174 +   sb  R31, [R28, #16]	# byte, #@storeB
178 +   lb  R31, [R30, #17]	# byte, #@loadB
17c +   addiw  R7, R7, #2	#@addI_reg_imm
180 +   sb  R31, [R28, #17]	# byte, #@storeB
184 +   blt  R7, R29, B30	#@cmpI_loop  P=0.786686 C=3758.000000

188     B31: #	out( B29 B32 ) &lt;- in( B30 )  Freq: 3.67042
188 +   ld  R17, [R23, #920]	# ptr, #@loadP
18c +   lwu zr, [R17]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::replace @ bci:76 (line 314) L[0]=R15 L[1]=R12 L[2]=R14 L[3]=R10 L[4]=R8 L[5]=sp + #24 L[6]=R7
        # OopMap {c_rarg5=Oop [24]=Oop off=396/0x18c}
190 +   blt  R7, R13, B29	#@cmpI_branch  P=0.786686 C=3758.000000

194     B32: #	out( B36 B33 ) &lt;- in( B26 B31 )  Freq: 0.782953
194 +   bge  R7, R8, B36	#@cmpI_branch  P=0.500000 C=-1.000000

198     B33: #	out( B104 B34 ) &lt;- in( B32 )  Freq: 0.391477
198 +   # castII of R7, #@castII
198     bgeu  R7, R10, B104	#@cmpU_branch  P=0.000001 C=-1.000000

19c     B34: #	out( B105 B35 ) &lt;- in( B33 )  Freq: 0.391476
19c +   spill R7 -&gt; R28	# spill size = 32
1a0 +   # castII of R28, #@castII
1a0     bgeu  R28, R10, B105	#@cmpU_branch  P=0.000001 C=-1.000000

1a4     B35: #	out( B35 B36 ) &lt;- in( B34 B35 ) Loop( B35-B35 inner post of N765) Freq: 0.782951
1a4 +   addw  R28, R7, zr	#@convI2L_reg_reg
1a8 +   add R29, R15, R28	# ptr, #@addP_reg_reg
1ac +   lb  R30, [R29, #16]	# byte, #@loadB
1b0     spill [sp, #24] -&gt; R29	# spill size = 64
1b4 +   add R28, R29, R28	# ptr, #@addP_reg_reg
1b8 +   addiw  R7, R7, #1	#@addI_reg_imm
1bc +   sb  R30, [R28, #16]	# byte, #@storeB
1c0 +   blt  R7, R8, B35	#@cmpI_loop  P=0.500000 C=3758.000000

1c4     B36: #	out( B72 B37 ) &lt;- in( B35 B32 B23 )  Freq: 0.995255
1c4 +   bge  R8, R10, B72	#@cmpI_branch  P=0.066514 C=15320.000000

1c8     B37: #	out( B91 B38 ) &lt;- in( B36 )  Freq: 0.929056
1c8 +   bgeu  R8, R10, B91	#@cmpU_branch  P=0.000001 C=-1.000000

1cc     B38: #	out( B91 B39 ) &lt;- in( B37 )  Freq: 0.929055
1cc +   bgeu  R9, R10, B91	#@cmpU_branch  P=0.000001 C=-1.000000

1d0     B39: #	out( B91 B40 ) &lt;- in( B38 )  Freq: 0.929054
1d0 +   addiw  R7, R8, #1	#@addI_reg_imm
1d4 +   bgeu  R9, R10, B91	#@cmpU_branch  P=0.000001 C=-1.000000

1d8     B40: #	out( B41 ) &lt;- in( B39 )  Freq: 0.929053
1d8 +   sext.b  R31, R14	# b2i, #@convB2I_reg_reg_b

1dc     B41: #	out( B76 B42 ) &lt;- in( B40 B43 ) Loop( B41-B43 inner pre of N776) Freq: 1.85811
1dc +   addw  R28, R8, zr	#@convI2L_reg_reg
1e0 +   add R29, R15, R28	# ptr, #@addP_reg_reg
1e4 +   lb  R30, [R29, #16]	# byte, #@loadB
1e8 +   beq  R30, R11, B76	#@cmpI_branch  P=0.149640 C=14301.000000

1ec     B42: #	out( B44 B43 ) &lt;- in( B41 B76 )  Freq: 1.85811
1ec +   spill [sp, #24] -&gt; R29	# spill size = 64
1f0 +   add R28, R29, R28	# ptr, #@addP_reg_reg
1f4 +   addiw  R29, R8, #1	#@addI_reg_imm
1f8 +   sb  R30, [R28, #16]	# byte, #@storeB
1fc +   bge  R29, R7, B44	#@cmpI_loop  P=0.500000 C=14301.000000

200     B43: #	out( B41 ) &lt;- in( B42 )  Freq: 0.929053
200 +   spill R29 -&gt; R8	# spill size = 32
204 +   j  B41	#@branch

208     B44: #	out( B66 B45 ) &lt;- in( B42 )  Freq: 0.929053
208 +   bge  R29, R16, B66	#@cmpI_branch  P=0.000001 C=-1.000000

20c     B45: #	out( B92 B46 ) &lt;- in( B44 )  Freq: 0.929052
20c +   spill R29 -&gt; R17	# spill size = 32
210 +   # castII of R17, #@castII
210     spill R17 -&gt; R30	# spill size = 32
214 +   addiw  R7, R8, #4	#@addI_reg_imm
218 +   # castII of R30, #@castII
218     bgeu  R30, R10, B92	#@cmpU_branch  P=0.000001 C=-1.000000

21c     B46: #	out( B93 B47 ) &lt;- in( B45 )  Freq: 0.929051
21c +   bgeu  R17, R10, B93	#@cmpU_branch  P=0.000001 C=-1.000000

220     B47: #	out( B94 B48 ) &lt;- in( B46 )  Freq: 0.92905
220 +   bgeu  R29, R10, B94	#@cmpU_branch  P=0.000001 C=-1.000000

224     B48: #	out( B65 B49 ) &lt;- in( B47 )  Freq: 0.929049
224 +   bltu  R7, R10, B65	#@cmpU_branch  P=0.999999 C=-1.000000

228     B49: #	out( N1 ) &lt;- in( B48 )  Freq: 9.41386e-07
228     #@ShouldNotReachHere

234     B50: #	out( B18 B51 ) &lt;- in( B15 )  Freq: 0.630294
234 +   lb  R18, [R28, #19]	# byte, #@loadB
238 +   addiw  R8, R17, #3	#@addI_reg_imm
23c +   beq  R18, R11, B18	#@cmpI_branch  P=0.211367 C=4821.000000

240     B51: #	out( B12 B52 ) &lt;- in( B50 )  Freq: 0.497071
240 +   subw  R29, R10, R14	#@subI_reg_reg
244 +   addiw  R28, R29, #-3	#@addI_reg_imm
248 +   li R29, #0	# int, #@loadConI
24c     CMove R28, (R16 lt R14), R28, R29	#@cmovI_cmpI
	
254 +   li R29, #4000	# int, #@loadConI
25c +   li R30, #4000	# int, #@loadConI
264     CMove R28, (R28 gtu R30), R28, R29	#@cmovI_cmpU
	
26c +   addw  R29, R28, R14	#@addI_reg_reg
270 +   addiw  R17, R17, #4	#@addI_reg_imm
274 +   blt  R17, R29, B12	#@cmpI_loop  P=0.999171 C=4825.000000

278     B52: #	out( B79 B53 ) &lt;- in( B51 )  Freq: 0.000412092
278 +   ld  R14, [R23, #920]	# ptr, #@loadP
27c +   lwu zr, [R14]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::replace @ bci:28 (line 307) L[0]=R15 L[1]=R12 L[2]=R13 L[3]=R10 L[4]=R8 L[5]=_ L[6]=_ STK[0]=R18 STK[1]=R11
        # OopMap {c_rarg5=Oop off=636/0x27c}
280 +   bge  R17, R16, B79	#@cmpI_branch  P=0.000829 C=4825.000000

284     B53: #	out( B11 ) &lt;- in( B52 )  Freq: 0.000411751
284 +   spill R17 -&gt; R14	# spill size = 32
288 +   j  B11	#@branch

28c     B54: #	out( B55 ) &lt;- in( B60 ) top-of-loop Freq: 31.4235
28c +   spill R31 -&gt; R30	# spill size = 32

290     B55: #	out( B64 B56 ) &lt;- in( B59 B54 ) top-of-loop Freq: 209.994
290 +   addiw  R17, R17, #4	#@addI_reg_imm
294 +   sb  R30, [R28, #19]	# byte, #@storeB
298 +   bge  R17, R7, B64	#@cmpI_loop  P=0.066514 C=14301.000000

29c     B56: #	out( B61 B57 ) &lt;- in( B65 B55 ) Loop( B56-B55 inner main of N311 strip mined) Freq: 209.994
29c +   addw  R28, R17, zr	#@convI2L_reg_reg
2a0 +   add R29, R15, R28	# ptr, #@addP_reg_reg
2a4 +   lb  R30, [R29, #16]	# byte, #@loadB
2a8 +   spill [sp, #24] -&gt; R13	# spill size = 64
2ac +   add R28, R13, R28	# ptr, #@addP_reg_reg
2b0 +   beq  R30, R11, B61	#@cmpI_branch  P=0.149640 C=14301.000000

2b4     B57: #	out( B62 B58 ) &lt;- in( B56 B61 )  Freq: 209.994
2b4 +   sb  R30, [R28, #16]	# byte, #@storeB
2b8 +   lb  R13, [R29, #17]	# byte, #@loadB
2bc +   beq  R13, R11, B62	#@cmpI_branch  P=0.149640 C=14301.000000

2c0     B58: #	out( B63 B59 ) &lt;- in( B57 B62 )  Freq: 209.994
2c0 +   sb  R13, [R28, #17]	# byte, #@storeB
2c4 +   lb  R30, [R29, #18]	# byte, #@loadB
2c8 +   beq  R30, R11, B63	#@cmpI_branch  P=0.149640 C=14301.000000

2cc     B59: #	out( B55 B60 ) &lt;- in( B58 B63 )  Freq: 209.994
2cc +   sb  R30, [R28, #18]	# byte, #@storeB
2d0 +   lb  R30, [R29, #19]	# byte, #@loadB
2d4 +   bne  R30, R11, B55	#@cmpI_branch  P=0.850360 C=14301.000000

2d8     B60: #	out( B54 ) &lt;- in( B59 )  Freq: 31.4235
2d8 +   j  B54	#@branch

2dc     B61: #	out( B57 ) &lt;- in( B56 )  Freq: 31.4235
2dc +   spill R31 -&gt; R30	# spill size = 32
2e0 +   j  B57	#@branch

2e4     B62: #	out( B58 ) &lt;- in( B57 )  Freq: 31.4235
2e4 +   spill R31 -&gt; R13	# spill size = 32
2e8 +   j  B58	#@branch

2ec     B63: #	out( B59 ) &lt;- in( B58 )  Freq: 31.4235
2ec +   spill R31 -&gt; R30	# spill size = 32
2f0 +   j  B59	#@branch

2f4     B64: #	out( B67 B65 ) &lt;- in( B55 )  Freq: 13.9676
2f4 +   ld  R13, [R23, #920]	# ptr, #@loadP
2f8 +   lwu zr, [R13]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::replace @ bci:113 (line 321) L[0]=R15 L[1]=R12 L[2]=R14 L[3]=R10 L[4]=R17 L[5]=sp + #24 L[6]=_
        # OopMap {c_rarg5=Oop [24]=Oop off=760/0x2f8}
2fc +   bge  R17, R16, B67	#@cmpI_branch  P=0.066514 C=14301.000000

300     B65: #	out( B56 ) &lt;- in( B48 B64 ) Loop( B65-B64 ) Freq: 13.9676
300 +   subw  R7, R10, R17	#@subI_reg_reg
304 +   addiw  R28, R7, #-3	#@addI_reg_imm
308 +   li R7, #0	# int, #@loadConI
30c     CMove R28, (R16 lt R17), R28, R7	#@cmovI_cmpI
	
314 +   li R7, #4000	# int, #@loadConI
31c +   li R29, #4000	# int, #@loadConI
324     CMove R28, (R28 gtu R29), R28, R7	#@cmovI_cmpU
	
32c +   addw  R7, R28, R17	#@addI_reg_reg
330 +   j  B56	#@branch

334     B66: #	out( B67 ) &lt;- in( B44 )  Freq: 9.4139e-07
334 +   spill R29 -&gt; R17	# spill size = 32

338     B67: #	out( B72 B68 ) &lt;- in( B66 B64 )  Freq: 0.929049
338 +   bge  R17, R10, B72	#@cmpI_branch  P=0.500000 C=-1.000000

33c     B68: #	out( B102 B69 ) &lt;- in( B67 )  Freq: 0.464525
33c +   # castII of R17, #@castII
33c     bgeu  R17, R10, B102	#@cmpU_branch  P=0.000001 C=-1.000000

340     B69: #	out( B103 B70 ) &lt;- in( B68 )  Freq: 0.464524
340 +   spill R17 -&gt; R7	# spill size = 32
344 +   # castII of R7, #@castII
344     bgeu  R7, R10, B103	#@cmpU_branch  P=0.000001 C=-1.000000

348     B70: #	out( B77 B71 ) &lt;- in( B69 B71 ) Loop( B70-B71 inner post of N776) Freq: 0.929047
348 +   addw  R7, R17, zr	#@convI2L_reg_reg
34c +   add R28, R15, R7	# ptr, #@addP_reg_reg
350 +   lb  R29, [R28, #16]	# byte, #@loadB
354 +   spill [sp, #24] -&gt; R28	# spill size = 64
358 +   add R7, R28, R7	# ptr, #@addP_reg_reg
35c +   beq  R29, R11, B77	#@cmpI_branch  P=0.149640 C=14301.000000

360     B71: #	out( B70 B72 ) &lt;- in( B70 B77 )  Freq: 0.929047
360 +   addiw  R17, R17, #1	#@addI_reg_imm
364 +   sb  R29, [R7, #16]	# byte, #@storeB
368 +   blt  R17, R10, B70	#@cmpI_loop  P=0.500000 C=14301.000000

36c     B72: #	out( B88 B73 ) &lt;- in( B71 B67 B36 )  Freq: 0.995247
36c +   ld  R10, [R23, #288]	# ptr, #@loadP
370 +   ld  R7, [R23, #304]	# ptr, #@loadP
374 +   addi  R28, R10, #24	# ptr, #@addP_reg_imm
378 +   bgeu  R28, R7, B88	#@cmpP_branch  P=0.000100 C=-1.000000

37c     B73: #	out( B74 ) &lt;- in( B72 )  Freq: 0.995148
37c +   li R7, #1	# long, #@loadConL
380 +   sd  R28, [R23, #288]	# ptr, #@storeP
384 +   sd  R7, [R10]	# long, #@storeL
388 +   mv  R7, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
398 +   sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
39c +   sw  zr, [R10, #12]	# int, #@storeimmI0
3a0 +   sd  zr, [R10, #16]	# long, #@storeimmL0

3a4     B74: #	out( B75 ) &lt;- in( B89 B73 )  Freq: 0.995247
3a4     spill [sp, #24] -&gt; R7	# spill size = 64
3a8 +   encode_heap_oop  R28, R7	#@encodeHeapOop
3ac     
3ac +   # checkcastPP of R10, #@checkCastPP
3ac     sw  R28, [R10, #20]	# compressed ptr, #@storeN ! Field: java/lang/String.value (constant)
3b0 +   #@membar_release
	fence iorw ow
3b4 +   #@membar_release
	fence iorw ow

3b4     B75: #	out( N1 ) &lt;- in( B74 B85 )  Freq: 0.999984
3b4     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
3cc +   ret	// return register, #@Ret

3d0     B76: #	out( B42 ) &lt;- in( B41 )  Freq: 0.278047
3d0 +   spill R31 -&gt; R30	# spill size = 32
3d4 +   j  B42	#@branch

3d8     B77: #	out( B71 ) &lt;- in( B70 )  Freq: 0.139023
3d8 +   spill R31 -&gt; R29	# spill size = 32
3dc +   j  B71	#@branch

3e0     B78: #	out( B79 ) &lt;- in( B7 )  Freq: 7.98441e-07
3e0 +   li R17, #1	# int, #@loadConI

3e4     B79: #	out( B85 B80 ) &lt;- in( B78 B52 )  Freq: 1.14008e-06
3e4 +   bge  R17, R10, B85	#@cmpI_branch  P=0.500000 C=-1.000000

3e8     B80: #	out( B106 B81 ) &lt;- in( B79 )  Freq: 5.70041e-07
3e8 +   # castII of R17, #@castII
3e8     bgeu  R17, R10, B106	#@cmpU_branch  P=0.000001 C=-1.000000

3ec     B81: #	out( B107 B82 ) &lt;- in( B80 )  Freq: 5.7004e-07
3ec +   spill R17 -&gt; R28	# spill size = 32
3f0 +   # castII of R28, #@castII
3f0     bgeu  R28, R10, B107	#@cmpU_branch  P=0.000001 C=-1.000000

3f4     B82: #	out( B84 B83 ) &lt;- in( B81 B84 ) Loop( B82-B84 inner post of N754) Freq: 9.41152e-07
3f4 +   addw  R28, R17, zr	#@convI2L_reg_reg
3f8 +   add R28, R15, R28	# ptr, #@addP_reg_reg
3fc +   lb  R29, [R28, #16]	# byte, #@loadB
400 +   bne  R29, R11, B84	#@cmpI_branch  P=0.788633 C=4821.000000

404     B83: #	out( B18 ) &lt;- in( B82 )  Freq: 1.98928e-07
404 +   spill R17 -&gt; R8	# spill size = 32
408 +   j  B18	#@branch

40c     B84: #	out( B82 B85 ) &lt;- in( B82 )  Freq: 7.42223e-07
40c +   addiw  R17, R17, #1	#@addI_reg_imm
410 +   blt  R17, R10, B82	#@cmpI_loop  P=0.500000 C=4825.000000

414     B85: #	out( B75 ) &lt;- in( B79 B18 B3 B84 )  Freq: 0.00473676
414 +   mv  R10, NULL	# NULL ptr, #@loadConP0
418 +   j  B75	#@branch

41c     B86: #	out( B109 B87 ) &lt;- in( B20 B21 )  Freq: 0.000100551
41c +   spill R11 -&gt; [sp, #24]	# spill size = 32
420 +   spill R12 -&gt; [sp, #0]	# spill size = 32
424 +   spill R7 -&gt; [sp, #32]	# spill size = 32
428 +   spill R16 -&gt; [sp, #28]	# spill size = 32
42c +   spill R9 -&gt; [sp, #20]	# spill size = 32
430 +   spill R10 -&gt; [sp, #16]	# spill size = 32
434 +   spill R13 -&gt; [sp, #4]	# spill size = 32
438 +   spill R15 -&gt; [sp, #8]	# spill size = 64
43c +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
454     spill R10 -&gt; R12	# spill size = 32
458     CALL,static 0x000000401390d640	#@CallStaticJavaDirect wrapper for: _new_array_Java
        # jdk.internal.misc.Unsafe::allocateUninitializedArray @ bci:51 (line 1375) L[0]=_ L[1]=_ L[2]=_
        # java.lang.StringConcatHelper::newArray @ bci:33 (line 497) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.lang.StringLatin1::replace @ bci:49 (line 313) L[0]=sp + #8 L[1]=sp + #0 L[2]=sp + #4 L[3]=sp + #16 L[4]=R8 L[5]=_ L[6]=_
        # OopMap {[8]=Oop off=1116/0x45c}

45c     B87: #	out( B23 ) &lt;- in( B86 )  Freq: 0.000100549
        # Block is sole successor of call
45c +   spill R10 -&gt; R7	# spill size = 64
460 +   spill R7 -&gt; R28	# spill size = 64
464 +   spill [sp, #0] -&gt; R12	# spill size = 32
468 +   spill [sp, #8] -&gt; R15	# spill size = 64
46c +   spill [sp, #4] -&gt; R14	# spill size = 32
470 +   spill [sp, #16] -&gt; R10	# spill size = 32
474 +   spill [sp, #20] -&gt; R9	# spill size = 32
478 +   spill [sp, #24] -&gt; R11	# spill size = 32
47c +   spill [sp, #28] -&gt; R16	# spill size = 32
480 +   spill [sp, #32] -&gt; R7	# spill size = 32
484 +   spill R28 -&gt; R30	# spill size = 64
488 +   j  B23	#@branch

48c     B88: #	out( B110 B89 ) &lt;- in( B72 )  Freq: 9.95412e-05
48c +   mv  R11, precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# ptr, #@loadConP
4a4     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.lang.StringLatin1::replace @ bci:116 (line 322) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=sp + #24 L[6]=_
        # OopMap {[24]=Oop off=1192/0x4a8}

4a8     B89: #	out( B74 ) &lt;- in( B88 )  Freq: 9.95392e-05
        # Block is sole successor of call
4a8 +   j  B74	#@branch

4ac     B90: #	out( N1 ) &lt;- in( B4 )  Freq: 1.01244e-06
4ac +   li R11, #-138	# int, #@loadConI
4b0     spill R7 -&gt; R8	# spill size = 64
4b4 +   spill R12 -&gt; [sp, #0]	# spill size = 32
4b8 +   spill R13 -&gt; [sp, #4]	# spill size = 32
4bc +   spill R10 -&gt; [sp, #12]	# spill size = 32
4c0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::replace @ bci:19 (line 306) L[0]=R8 L[1]=sp + #0 L[2]=sp + #4 L[3]=sp + #12 L[4]=#0 L[5]=_ L[6]=_ STK[0]=#0 STK[1]=sp + #12
        # OopMap {fp=Oop off=1220/0x4c4}
4c4     #@ShouldNotReachHere

4d0     B91: #	out( N1 ) &lt;- in( B39 B37 B38 )  Freq: 2.82418e-06
4d0 +   li R11, #-138	# int, #@loadConI
4d4     spill R15 -&gt; [sp, #0]	# spill size = 64
4d8 +   spill R12 -&gt; [sp, #8]	# spill size = 32
4dc +   spill R14 -&gt; [sp, #12]	# spill size = 32
4e0 +   spill R10 -&gt; [sp, #32]	# spill size = 32
4e4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::replace @ bci:82 (line 317) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #12 L[3]=sp + #32 L[4]=R8 L[5]=sp + #24 L[6]=_ STK[0]=R8 STK[1]=sp + #32
        # OopMap {[0]=Oop [24]=Oop off=1256/0x4e8}
4e8     #@ShouldNotReachHere

4f4     B92: #	out( N1 ) &lt;- in( B45 )  Freq: 9.41389e-07
4f4     #@ShouldNotReachHere

500     B93: #	out( N1 ) &lt;- in( B46 )  Freq: 9.41388e-07
500     #@ShouldNotReachHere

50c     B94: #	out( N1 ) &lt;- in( B47 )  Freq: 9.41387e-07
50c     #@ShouldNotReachHere

518     B95: #	out( N1 ) &lt;- in( B24 B25 )  Freq: 1.57631e-06
518 +   li R11, #-138	# int, #@loadConI
51c     spill R15 -&gt; [sp, #0]	# spill size = 64
520 +   spill R12 -&gt; [sp, #8]	# spill size = 32
524 +   spill R14 -&gt; [sp, #12]	# spill size = 32
528 +   spill R10 -&gt; [sp, #16]	# spill size = 32
52c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::replace @ bci:61 (line 314) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #12 L[3]=sp + #16 L[4]=R8 L[5]=sp + #24 L[6]=#0 STK[0]=#0 STK[1]=R8
        # OopMap {[0]=Oop [24]=Oop off=1328/0x530}
530     #@ShouldNotReachHere

53c     B96: #	out( N1 ) &lt;- in( B8 )  Freq: 7.87976e-07
53c     #@ShouldNotReachHere

548     B97: #	out( N1 ) &lt;- in( B9 )  Freq: 7.87976e-07
548     #@ShouldNotReachHere

554     B98: #	out( N1 ) &lt;- in( B27 )  Freq: 7.82954e-07
554     #@ShouldNotReachHere

560     B99: #	out( N1 ) &lt;- in( B28 )  Freq: 7.82953e-07
560     #@ShouldNotReachHere

56c     B100: #	out( N1 ) &lt;- in( B1 )  Freq: 5e-07
56c +   li R11, #-187	# int, #@loadConI
570     spill R7 -&gt; R8	# spill size = 64
574 +   spill R12 -&gt; [sp, #0]	# spill size = 32
578 +   spill R13 -&gt; [sp, #4]	# spill size = 32
57c +   spill R28 -&gt; [sp, #8]	# spill size = 32
580     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::canEncode @ bci:4 (line 54) L[0]=_ STK[0]=sp + #8
        # java.lang.StringLatin1::replace @ bci:1 (line 303) L[0]=R8 L[1]=sp + #0 L[2]=sp + #4 L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # OopMap {fp=Oop off=1412/0x584}
584     #@ShouldNotReachHere

590     B101: #	out( N1 ) &lt;- in( B19 )  Freq: 4.9763e-07
590 +   li R11, #-187	# int, #@loadConI
594     spill R15 -&gt; [sp, #0]	# spill size = 64
598 +   spill R12 -&gt; [sp, #8]	# spill size = 32
59c +   spill R13 -&gt; [sp, #12]	# spill size = 32
5a0 +   spill R10 -&gt; [sp, #16]	# spill size = 32
5a4 +   spill R28 -&gt; [sp, #20]	# spill size = 32
5a8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::canEncode @ bci:4 (line 54) L[0]=_ STK[0]=sp + #20
        # java.lang.StringLatin1::replace @ bci:41 (line 312) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #12 L[3]=sp + #16 L[4]=R8 L[5]=_ L[6]=_
        # OopMap {[0]=Oop off=1452/0x5ac}
5ac     #@ShouldNotReachHere

5b8     B102: #	out( N1 ) &lt;- in( B68 )  Freq: 4.70693e-07
5b8     #@ShouldNotReachHere

5c4     B103: #	out( N1 ) &lt;- in( B69 )  Freq: 4.70693e-07
5c4     #@ShouldNotReachHere

5d0     B104: #	out( N1 ) &lt;- in( B33 )  Freq: 3.96675e-07
5d0     #@ShouldNotReachHere

5dc     B105: #	out( N1 ) &lt;- in( B34 )  Freq: 3.96675e-07
5dc     #@ShouldNotReachHere

5e8     B106: #	out( N1 ) &lt;- in( B80 )  Freq: 5.77611e-13
5e8     #@ShouldNotReachHere

5f4     B107: #	out( N1 ) &lt;- in( B81 )  Freq: 5.7761e-13
5f4     #@ShouldNotReachHere

600     B108: #	out( N1 ) &lt;- in( B2 )  Freq: 1.01328e-06
600 +   li R11, #-10	# int, #@loadConI
604     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::replace @ bci:8 (line 304) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=#NULL
        # OopMap {off=1544/0x608}
608     #@ShouldNotReachHere

614     B109: #	out( B111 ) &lt;- in( B86 )  Freq: 1.00551e-09
614      -- 	// exception oop; no code emitted, #@CreateException
614 +   spill R10 -&gt; R11	# spill size = 64
618 +   j  B111	#@branch

61c     B110: #	out( B111 ) &lt;- in( B88 )  Freq: 9.95412e-10
61c      -- 	// exception oop; no code emitted, #@CreateException
61c +   spill R10 -&gt; R11	# spill size = 64

620     B111: #	out( N1 ) &lt;- in( B109 B110 )  Freq: 2.00092e-09
620     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
62c +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='304'>
----------------------- MetaData before Compile_id = 304 ------------------------
{method}
 - this oop:          0x00000040962b74d8
 - method holder:     &apos;sun/nio/fs/UnixPath&apos;
 - constants:         0x00000040962b5440 constant pool [472] {0x00000040962b5440} for &apos;sun/nio/fs/UnixPath&apos; cache=0x00000040962ba1a0
 - access:            0xc1000002  private 
 - name:              &apos;hasDotOrDotDot&apos;
 - signature:         &apos;()Z&apos;
 - max stack:         3
 - max locals:        4
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c508200
 - code size:         69
 - code start:        0x00000040962b7450
 - code end (excl):   0x00000040962b7495
 - method data:       0x0000004096487860
 - checked ex length: 0
 - linenumber start:  0x00000040962b7495
 - localvar length:   4
 - localvar start:    0x00000040962b74a6
 - compiled code: nmethod   7232  180       3       sun.nio.fs.UnixPath::hasDotOrDotDot (69 bytes)

------------------------ OptoAssembly for Compile_id = 304 -----------------------
#
#  bool ( sun/nio/fs/UnixPath:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixPath:NotNull *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N514: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B52 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     spill R11 -&gt; R8	# spill size = 64
040     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getNameCount @ bci:1 (line 295) L[0]=R8
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:1 (line 227) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop off=68/0x44}

044     B2: #	out( B49 B3 ) &lt;- in( B1 )  Freq: 0.99998
        # Block is sole successor of call
044 +   spill R8 -&gt; R21	# spill size = 64
048 +   lwu  R7, [R21, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
04c +   #@membar_acquire
	fence ir iorw
050 +   decode_heap_oop  R7, R7	#@decodeHeapOop
054     lwu  R28, [R7, #12]	# range, #@loadRange
058     NullCheck R7

058     B3: #	out( B31 B4 ) &lt;- in( B2 )  Freq: 0.999979
058 +   bleu  R28, zr, B31	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.092012 C=22247.000000

05c     B4: #	out( B5 ) &lt;- in( B3 )  Freq: 0.907968
05c +   li R29, #0	# int, #@loadConI
060 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
060     li R20, #0	# int, #@loadConI
064     spill R29 -&gt; [sp, #28]	# spill size = 32
        nop 	# 4 bytes pad for loops and calls

070     B5: #	out( B53 B6 ) &lt;- in( B4 B26 ) Loop( B5-B26 inner ) Freq: 9.86571
070 +   spill R20 -&gt; [sp, #0]	# spill size = 32
074 +   spill R28 -&gt; [sp, #8]	# spill size = 32
078 +   spill R21 -&gt; R8	# spill size = 64
07c +   spill R21 -&gt; R11	# spill size = 64
080     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getName @ bci:1 (line 301) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=R8 L[1]=sp + #8 L[2]=sp + #0 L[3]=_
        # OopMap {fp=Oop off=132/0x84}

084     B6: #	out( B44 B7 ) &lt;- in( B5 )  Freq: 9.86551
        # Block is sole successor of call
084 +   spill R8 -&gt; R21	# spill size = 64
088 +   lwu  R28, [R21, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
08c +   #@membar_acquire
	fence ir iorw
090 +   decode_heap_oop  R7, R28	#@decodeHeapOop
094     lwu  R8, [R7, #12]	# range, #@loadRange
098     NullCheck R7

098     B7: #	out( B41 B8 ) &lt;- in( B6 )  Freq: 9.8655
098 +   spill [sp, #0] -&gt; R18	# spill size = 32
09c +   bge  R18, R8, B41	#@cmpI_branch  P=0.000000 C=5376.000000

0a0     B8: #	out( B45 B9 ) &lt;- in( B7 )  Freq: 9.8655
0a0 +   lwu  R7, [R21, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0a4 +   #@membar_acquire
	fence ir iorw
0a8 +   decode_heap_oop  R8, R7	#@decodeHeapOop
0ac     lwu  R28, [R8, #12]	# range, #@loadRange
0b0     NullCheck R8

0b0     B9: #	out( B38 B10 ) &lt;- in( B8 )  Freq: 9.86549
0b0 +   bgeu  R18, R28, B38	#@cmpU_branch  P=0.000001 C=-1.000000

0b4     B10: #	out( B46 B11 ) &lt;- in( B9 )  Freq: 9.86548
0b4 +   addw  R28, R18, zr	#@convI2L_reg_reg
0b8 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0bc +   lwu  R7, [R21, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0c0 +   add R29, R8, R28	# ptr, #@addP_reg_reg
0c4 +   lw  R30, [R29, #16]	# int, #@loadI
0c8 +   decode_heap_oop  R7, R7	#@decodeHeapOop
0cc +   #@membar_acquire
	fence ir iorw
0d0     lwu  R29, [R7, #12]	# range, #@loadRange
0d4     NullCheck R7

0d4     B11: #	out( B29 B12 ) &lt;- in( B10 )  Freq: 9.86547
0d4 +   addiw  R7, R29, #-1	#@addI_reg_imm
0d8 +   addiw  R20, R18, #1	#@addI_reg_imm
0dc +   beq  R18, R7, B29	#@cmpI_branch  P=0.084635 C=5376.000000

0e0     B12: #	out( B48 B13 ) &lt;- in( B11 )  Freq: 9.0305
0e0 +   lwu  R29, [R21, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0e4 +   #@membar_acquire
	fence ir iorw
0e8 +   decode_heap_oop  R8, R29	#@decodeHeapOop
0ec     lwu  R29, [R8, #12]	# range, #@loadRange
0f0     NullCheck R8

0f0     B13: #	out( B40 B14 ) &lt;- in( B12 )  Freq: 9.03049
0f0 +   bgeu  R20, R29, B40	#@cmpU_branch  P=0.000001 C=-1.000000

0f4     B14: #	out( B15 ) &lt;- in( B13 )  Freq: 9.03048
0f4 +   add R7, R8, R28	# ptr, #@addP_reg_reg
0f8 +   lw  R7, [R7, #20]	# int, #@loadI
0fc +   subw  R28, R7, R30	#@subI_reg_reg
100 +   addiw  R9, R28, #-1	#@addI_reg_imm

104     B15: #	out( B16 B16 ) &lt;- in( B14 B30 )  Freq: 9.86545
104 +   lwu  R7, [R21, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
108 +   decode_heap_oop  R8, R7	#@decodeHeapOop
10c +   li R28, #1048576	# int, #@loadConI
110 +   addw  R7, R9, zr	#@convI2L_reg_reg
114 +   bleu  R9, R28, B16	#@cmpU_branch  P=0.999999 C=-1.000000

118     B16: #	out( B47 B17 ) &lt;- in( B15 B15 )  Freq: 9.86545
118     lwu  R29, [R8, #12]	# range, #@loadRange
11c     NullCheck R8

11c     B17: #	out( B39 B18 ) &lt;- in( B16 )  Freq: 9.86544
11c +   addw  R28, R9, R30	#@addI_reg_reg
120 +   blt  R30, zr, B39	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

124     B18: #	out( B39 B19 ) &lt;- in( B17 )  Freq: 9.86543
124 +   bltu  R29, R28, B39	#@cmpU_branch  P=0.000001 C=-1.000000

128     B19: #	out( B36 B20 ) &lt;- in( B18 )  Freq: 9.86542
128 +   li R29, #1048576	# int, #@loadConI
12c +   bgtu  R9, R29, B36	#@cmpU_branch  P=0.000001 C=-1.000000

130     B20: #	out( B36 B21 ) &lt;- in( B19 )  Freq: 9.86541
130 +   addi  R7, R7, #23	#@addL_reg_imm
134 +   ld  R19, [R23, #288]	# ptr, #@loadP
138 +   andi  R7, R7, #-8	#@andL_reg_imm
13c +   ld  R28, [R23, #304]	# ptr, #@loadP
140 +   add R7, R19, R7	# ptr, #@addP_reg_reg
144 +   bgeu  R7, R28, B36	#@cmpP_branch  P=0.000100 C=-1.000000

148     B21: #	out( B22 ) &lt;- in( B20 )  Freq: 9.86442
148 +   sd  R7, [R23, #288]	# ptr, #@storeP
14c +   li R7, #1	# long, #@loadConL
150 +   sd  R7, [R19]	# long, #@storeL
154 +   mv  R7, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
164 +   sw  R7, [R19, #8]	# compressed klass ptr, #@storeNKlass
168 +   sw  R9, [R19, #12]	# int, #@storeI

16c     B22: #	out( B24 B23 ) &lt;- in( B37 B21 )  Freq: 9.86542
16c +   addw  R7, R30, zr	#@convI2L_reg_reg
170     
170 +   add R7, R8, R7	# ptr, #@addP_reg_reg
174 +   # checkcastPP of R19, #@checkCastPP
174     addi  R22, R19, #16	# ptr, #@addP_reg_imm
178 +   # castII of R9, #@castII
178     beq  R9, zr, B24	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

17c     B23: #	out( B24 ) &lt;- in( B22 )  Freq: 9.86541
17c +   addw  R12, R9, zr	#@convI2L_reg_reg
180     spill R22 -&gt; R11	# spill size = 64
184 +   addi  R10, R7, #16	# ptr, #@addP_reg_imm
188 +   CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

18c     B24: #	out( B42 B25 ) &lt;- in( B23 B22 )  Freq: 9.86542
18c     
18c     li R7, #1	# int, #@loadConI
190 +   beq  R9, R7, B42	#@cmpI_branch  P=0.000000 C=20200.000000

194     B25: #	out( B32 B26 ) &lt;- in( B24 )  Freq: 9.86541
194 +   li R28, #2	# int, #@loadConI
198 +   beq  R9, R28, B32	#@cmpI_branch  P=0.000347 C=20200.000000

19c     B26: #	out( B5 B27 ) &lt;- in( B34 B33 B25 )  Freq: 9.86538
19c +   spill [sp, #8] -&gt; R28	# spill size = 32
1a0 +   blt  R20, R28, B5	#@cmpI_loop  P=0.907988 C=20200.000000

1a4     B27: #	out( B28 ) &lt;- in( B26 )  Freq: 0.907737
1a4 +   spill [sp, #28] -&gt; R10	# spill size = 32

1a8     B28: #	out( N514 ) &lt;- in( B35 B27 B31 )  Freq: 0.999782
1a8     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
1c0 +   ret	// return register, #@Ret

1c4     B29: #	out( B50 B30 ) &lt;- in( B11 )  Freq: 0.834968
1c4 +   lwu  R7, [R21, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
1c8 +   decode_heap_oop  R7, R7	#@decodeHeapOop
1cc     lwu  R28, [R7, #12]	# range, #@loadRange
1d0     NullCheck R7

1d0     B30: #	out( B15 ) &lt;- in( B29 )  Freq: 0.834967
1d0 +   subw  R9, R28, R30	#@subI_reg_reg
1d4 +   j  B15	#@branch

1d8     B31: #	out( B28 ) &lt;- in( B3 )  Freq: 0.0920105
1d8 +   li R10, #0	# int, #@loadConI
1dc +   j  B28	#@branch

1e0     B32: #	out( B43 B33 ) &lt;- in( B25 )  Freq: 0.00341877
1e0 +   bleu  R9, R7, B43	#@cmpU_branch  P=0.000001 C=-1.000000

1e4     B33: #	out( B26 B34 ) &lt;- in( B32 )  Freq: 0.00341877
1e4 +   lb  R7, [R22]	# byte, #@loadB
1e8 +   li R29, #46	# int, #@loadConI
1ec +   bne  R7, R29, B26	#@cmpI_branch  P=0.900000 C=-1.000000

1f0     B34: #	out( B26 B35 ) &lt;- in( B33 )  Freq: 0.000341877
1f0 +   lb  R7, [R19, #17]	# byte, #@loadB
1f4 +   bne  R7, R29, B26	#@cmpI_branch  P=0.900000 C=-1.000000

1f8     B35: #	out( B28 ) &lt;- in( B34 )  Freq: 3.41877e-05
1f8 +   li R10, #1	# int, #@loadConI
1fc +   j  B28	#@branch

200     B36: #	out( B51 B37 ) &lt;- in( B19 B20 )  Freq: 0.000996701
200 +   spill R9 -&gt; [sp, #24]	# spill size = 32
204 +   spill R20 -&gt; [sp, #20]	# spill size = 32
208 +   spill R30 -&gt; [sp, #16]	# spill size = 32
20c +   spill R18 -&gt; [sp, #12]	# spill size = 32
210 +   spill R21 -&gt; [sp, #0]	# spill size = 64
214 +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
22c     spill R9 -&gt; R12	# spill size = 32
230     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #0 L[1]=_ L[2]=sp + #16 L[3]=sp + #24 L[4]=_
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #12 L[3]=_
        # OopMap {fp=Oop [0]=Oop off=564/0x234}

234     B37: #	out( B22 ) &lt;- in( B36 )  Freq: 0.000996681
        # Block is sole successor of call
234 +   spill [sp, #0] -&gt; R21	# spill size = 64
238 +   spill [sp, #12] -&gt; R18	# spill size = 32
23c +   spill [sp, #16] -&gt; R30	# spill size = 32
240 +   spill [sp, #20] -&gt; R20	# spill size = 32
244 +   spill [sp, #24] -&gt; R9	# spill size = 32
248 +   spill R10 -&gt; R19	# spill size = 64
24c +   j  B22	#@branch

250     B38: #	out( N514 ) &lt;- in( B9 )  Freq: 9.99649e-06
250 +   li R11, #-28	# int, #@loadConI
254     spill R21 -&gt; [sp, #16]	# spill size = 64
258 +   spill R18 -&gt; [sp, #24]	# spill size = 32
25c +   spill R18 -&gt; [sp, #28]	# spill size = 32
260     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:38 (line 307) L[0]=sp + #16 L[1]=sp + #28 L[2]=_ L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #24
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #16 L[1]=sp + #8 L[2]=sp + #24 L[3]=_
        # OopMap {fp=Oop [16]=Oop off=612/0x264}
264     #@ShouldNotReachHere

270     B39: #	out( N514 ) &lt;- in( B17 B18 )  Freq: 1.97309e-05
270 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 32
278 +   li R11, #-52	# int, #@loadConI
27c     spill R18 -&gt; [sp, #4]	# spill size = 32
280 +   spill R21 -&gt; [sp, #8]	# spill size = 64
284 +   spill R30 -&gt; [sp, #16]	# spill size = 32
288 +   spill R9 -&gt; [sp, #24]	# spill size = 32
28c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #8 L[1]=_ L[2]=sp + #16 L[3]=sp + #24 L[4]=_ STK[0]=sp + #24
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #8 L[1]=sp + #0 L[2]=sp + #4 L[3]=_
        # OopMap {[8]=Oop off=656/0x290}
290     #@ShouldNotReachHere

29c     B40: #	out( N514 ) &lt;- in( B13 )  Freq: 9.15041e-06
29c +   li R11, #-28	# int, #@loadConI
2a0     spill R18 -&gt; [sp, #12]	# spill size = 32
2a4 +   spill R21 -&gt; [sp, #16]	# spill size = 64
2a8 +   spill R20 -&gt; [sp, #24]	# spill size = 32
2ac +   spill R30 -&gt; [sp, #28]	# spill size = 32
2b0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:69 (line 312) L[0]=sp + #16 L[1]=_ L[2]=sp + #28 L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #24
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #16 L[1]=sp + #8 L[2]=sp + #12 L[3]=_
        # OopMap {fp=Oop [16]=Oop off=692/0x2b4}
2b4     #@ShouldNotReachHere

2c0     B41: #	out( N514 ) &lt;- in( B7 )  Freq: 4.70424e-06
2c0 +   li R11, #-187	# int, #@loadConI
2c4     spill R21 -&gt; [sp, #16]	# spill size = 64
2c8 +   spill R18 -&gt; [sp, #24]	# spill size = 32
2cc +   spill R18 -&gt; [sp, #28]	# spill size = 32
2d0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:22 (line 304) L[0]=sp + #16 L[1]=sp + #28 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #24 STK[1]=R8
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #16 L[1]=sp + #8 L[2]=sp + #24 L[3]=_
        # OopMap {[16]=Oop off=724/0x2d4}
2d4     #@ShouldNotReachHere

2e0     B42: #	out( N514 ) &lt;- in( B24 )  Freq: 4.7042e-06
2e0 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 32
2e8 +   li R11, #-187	# int, #@loadConI
2ec     spill R21 -&gt; R8	# spill size = 64
2f0 +   spill R18 -&gt; [sp, #4]	# spill size = 32
2f4 +   spill R19 -&gt; [sp, #8]	# spill size = 64
2f8 +   spill R9 -&gt; [sp, #16]	# spill size = 32
2fc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:24 (line 230) L[0]=R8 L[1]=sp + #0 L[2]=sp + #4 L[3]=sp + #8 STK[0]=sp + #16 STK[1]=#1
        # OopMap {fp=Oop [8]=Oop off=768/0x300}
300     #@ShouldNotReachHere

30c     B43: #	out( N514 ) &lt;- in( B32 )  Freq: 3.41877e-09
30c +   li R11, #-28	# int, #@loadConI
310     spill R21 -&gt; R8	# spill size = 64
314 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 32
31c +   spill R18 -&gt; [sp, #4]	# spill size = 32
320 +   spill R19 -&gt; [sp, #16]	# spill size = 64
324     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:45 (line 232) L[0]=R8 L[1]=sp + #0 L[2]=sp + #4 L[3]=sp + #16 STK[0]=sp + #16 STK[1]=#0
        # OopMap {fp=Oop [16]=Oop off=808/0x328}
328     #@ShouldNotReachHere

334     B44: #	out( N514 ) &lt;- in( B6 )  Freq: 9.99652e-06
334 +   li R11, #-10	# int, #@loadConI
338     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:21 (line 304) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=828/0x33c}
33c     #@ShouldNotReachHere

348     B45: #	out( N514 ) &lt;- in( B8 )  Freq: 9.9965e-06
348 +   li R11, #-10	# int, #@loadConI
34c     spill R18 -&gt; R8	# spill size = 32
350     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:38 (line 307) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=852/0x354}
354     #@ShouldNotReachHere

360     B46: #	out( N514 ) &lt;- in( B10 )  Freq: 9.99648e-06
360 +   li R11, #-10	# int, #@loadConI
364     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:45 (line 309) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=872/0x368}
368     #@ShouldNotReachHere

374     B47: #	out( N514 ) &lt;- in( B16 )  Freq: 9.99645e-06
374 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 32
37c +   li R11, #-12	# int, #@loadConI
380     spill R18 -&gt; [sp, #4]	# spill size = 32
384 +   spill R21 -&gt; [sp, #8]	# spill size = 64
388 +   spill R30 -&gt; [sp, #16]	# spill size = 32
38c +   spill R9 -&gt; [sp, #24]	# spill size = 32
390     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #8 L[1]=_ L[2]=sp + #16 L[3]=sp + #24 L[4]=_ STK[0]=sp + #24
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #8 L[1]=sp + #0 L[2]=sp + #4 L[3]=_
        # OopMap {[8]=Oop off=916/0x394}
394     #@ShouldNotReachHere

3a0     B48: #	out( N514 ) &lt;- in( B12 )  Freq: 9.15042e-06
3a0 +   li R11, #-10	# int, #@loadConI
3a4     spill R20 -&gt; R8	# spill size = 32
3a8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:69 (line 312) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=940/0x3ac}
3ac     #@ShouldNotReachHere

3b8     B49: #	out( N514 ) &lt;- in( B2 )  Freq: 1.01326e-06
3b8 +   li R11, #-10	# int, #@loadConI
3bc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getNameCount @ bci:8 (line 296) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:1 (line 227) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=960/0x3c0}
3c0     #@ShouldNotReachHere

3cc     B50: #	out( N514 ) &lt;- in( B29 )  Freq: 8.46056e-07
3cc +   li R11, #-10	# int, #@loadConI
3d0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:55 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=980/0x3d4}
3d4     #@ShouldNotReachHere

3e0     B51: #	out( B54 ) &lt;- in( B36 )  Freq: 9.96701e-09
3e0      -- 	// exception oop; no code emitted, #@CreateException
3e0 +   j  B54	#@branch

3e4     B52: #	out( B55 ) &lt;- in( B1 )  Freq: 1e-05
3e4      -- 	// exception oop; no code emitted, #@CreateException
3e4 +   spill R10 -&gt; R11	# spill size = 64
3e8 +   j  B55	#@branch

3ec     B53: #	out( B54 ) &lt;- in( B5 )  Freq: 9.86571e-05
3ec      -- 	// exception oop; no code emitted, #@CreateException

3ec     B54: #	out( B55 ) &lt;- in( B53 B51 )  Freq: 9.86671e-05
3ec +   spill R10 -&gt; R11	# spill size = 64

3f0     B55: #	out( N514 ) &lt;- in( B52 B54 )  Freq: 0.000108667
3f0     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
3fc +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='305'>
----------------------- MetaData before Compile_id = 305 ------------------------
{method}
 - this oop:          0x00000040961dd1a0
 - method holder:     &apos;java/util/Arrays&apos;
 - constants:         0x00000040961d2728 constant pool [988]/operands[28] {0x00000040961d2728} for &apos;java/util/Arrays&apos; cache=0x00000040961e4d98
 - access:            0x81000009  public static 
 - name:              &apos;copyOfRange&apos;
 - signature:         &apos;([BII)[B&apos;
 - max stack:         7
 - max locals:        5
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008317620: 0xbaa i2c: 0x0000004013945bc0 c2i: 0x0000004013945c0c c2iUV: 0x0000004013945bd8
 - compiled entry     0x000000400c4b9480
 - code size:         64
 - code start:        0x00000040961dd110
 - code end (excl):   0x00000040961dd150
 - method data:       0x000000409652ad40
 - checked ex length: 0
 - linenumber start:  0x00000040961dd150
 - localvar length:   5
 - localvar start:    0x00000040961dd162
 - compiled code: nmethod   7300   43       3       java.util.Arrays::copyOfRange (64 bytes)

------------------------ OptoAssembly for Compile_id = 305 -----------------------
#
#  byte[int:&gt;=0]:exact * ( byte[int:&gt;=0]:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: byte[int:&gt;=0]:exact *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B20 B21 B19 B14 B22 )  Freq: 1

000     B1: #	out( B20 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
01c     subw  R8, R13, R12	#@subI_reg_reg
020     spill R11 -&gt; [sp, #0]	# spill size = 64
024 +   li R28, #1048576	# int, #@loadConI
028     spill R12 -&gt; [sp, #8]	# spill size = 32
02c +   blt  R8, zr, B20	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

030     B2: #	out( B3 B3 ) &lt;- in( B1 )  Freq: 1
030 +   addw  R7, R8, zr	#@convI2L_reg_reg
034 +   bleu  R8, R28, B3	#@cmpU_branch  P=0.999999 C=-1.000000

038     B3: #	out( B21 B4 ) &lt;- in( B2 B2 )  Freq: 1
038     lwu  R29, [R11, #12]	# range, #@loadRange
03c     NullCheck R11

03c     B4: #	out( B19 B5 ) &lt;- in( B3 )  Freq: 0.999999
03c +   subw  R31, R29, R12	#@subI_reg_reg
040     spill R8 -&gt; R13	# spill size = 32
044 +   CMove R13, (R31 lt R8), R13, R31	#@cmovI_cmpI
	
04c +   addw  R30, R12, R13	#@addI_reg_reg
050 +   blt  R12, zr, B19	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

054     B5: #	out( B19 B6 ) &lt;- in( B4 )  Freq: 0.999997
054 +   bltu  R29, R30, B19	#@cmpU_branch  P=0.000001 C=-1.000000

058     B6: #	out( B19 B7 ) &lt;- in( B5 )  Freq: 0.999996
058 +   bltu  R8, R13, B19	#@cmpU_branch  P=0.000001 C=-1.000000

05c     B7: #	out( B19 B8 ) &lt;- in( B6 )  Freq: 0.999995
05c +   blt  R13, zr, B19	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

060     B8: #	out( B16 B9 ) &lt;- in( B7 )  Freq: 0.999994
060 +   addi  R29, R7, #23	#@addL_reg_imm
064 +   bgtu  R8, R28, B16	#@cmpU_branch  P=0.000001 C=-1.000000

068     B9: #	out( B16 B10 ) &lt;- in( B8 )  Freq: 0.999993
068 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
068     ld  R9, [R23, #288]	# ptr, #@loadP
06c +   andi  R7, R29, #-8	#@andL_reg_imm
070 +   ld  R28, [R23, #304]	# ptr, #@loadP
074 +   add R7, R9, R7	# ptr, #@addP_reg_reg
078 +   bgeu  R7, R28, B16	#@cmpP_branch  P=0.000100 C=-1.000000

07c     B10: #	out( B11 ) &lt;- in( B9 )  Freq: 0.999893
07c +   sd  R7, [R23, #288]	# ptr, #@storeP
080 +   li R7, #1	# long, #@loadConL
084 +   sd  R7, [R9]	# long, #@storeL
088 +   mv  R7, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
098 +   sw  R7, [R9, #8]	# compressed klass ptr, #@storeNKlass
09c +   sw  R8, [R9, #12]	# int, #@storeI

0a0     B11: #	out( B18 B12 ) &lt;- in( B17 B10 )  Freq: 0.999994
0a0 +   srli  R7, R29, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
0a4     spill [sp, #8] -&gt; R29	# spill size = 32
0a8 +   addw  R28, R29, zr	#@convI2L_reg_reg
0ac     
0ac +   addw  R12, R13, zr	#@convI2L_reg_reg
0b0     spill [sp, #0] -&gt; R29	# spill size = 64
0b4 +   add R28, R29, R28	# ptr, #@addP_reg_reg
0b8 +   # checkcastPP of R9, #@checkCastPP
0b8     addi  R11, R9, #16	# ptr, #@addP_reg_imm
0bc +   beq  R13, zr, B18	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0c0     B12: #	out( B15 B13 ) &lt;- in( B11 )  Freq: 0.999993
0c0 +   addi  R10, R28, #16	# ptr, #@addP_reg_imm
0c4 +   blt  R13, R8, B15	#@cmpI_branch  P=0.001000 C=-1.000000

0c8     B13: #	out( B14 ) &lt;- in( B12 B15 )  Freq: 0.999993
0c8 +   CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

0cc     B14: #	out( N1 ) &lt;- in( B13 B18 )  Freq: 0.999994
0cc     MEMBAR-store-store	#@membar_storestore
0d0 +   spill R9 -&gt; R10	# spill size = 64
0d4 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0ec +   ret	// return register, #@Ret

0f0     B15: #	out( B13 ) &lt;- in( B12 )  Freq: 0.000999993
0f0 +   addi  R28, R12, #16	#@addL_reg_imm
0f4 +   srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
0f8 +   andi  R28, R28, #-8	#@andL_reg_imm
0fc +   add R28, R9, R28	# ptr, #@addP_reg_reg
100 +   sub  R29, R7, R29	#@subL_reg_reg
104 +   ClearArray R29, R28	#@clearArray_reg_reg
15c     j  B13	#@branch

160     B16: #	out( B22 B17 ) &lt;- in( B8 B9 )  Freq: 0.000101029
160 +   spill R29 -&gt; [sp, #16]	# spill size = 64
164 +   spill R13 -&gt; [sp, #12]	# spill size = 32
168 +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
180     spill R8 -&gt; R12	# spill size = 32
184     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # java.util.Arrays::copyOfRange @ bci:41 (line 3822) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=R8 L[4]=_
        # OopMap {[0]=Oop off=392/0x188}

188     B17: #	out( B11 ) &lt;- in( B16 )  Freq: 0.000101027
        # Block is sole successor of call
188 +   spill R10 -&gt; R9	# spill size = 64
18c +   spill [sp, #12] -&gt; R13	# spill size = 32
190 +   spill [sp, #16] -&gt; R29	# spill size = 64
194 +   j  B11	#@branch

198     B18: #	out( B14 ) &lt;- in( B11 )  Freq: 1.01327e-06
198 +   spill R11 -&gt; R28	# spill size = 64
19c +   addi  R29, R7, #-2	#@addL_reg_imm
1a0     ClearArray R29, R28	#@clearArray_reg_reg
1f8     
1f8 +   j  B14	#@branch

1fc     B19: #	out( N1 ) &lt;- in( B4 B5 B6 B7 )  Freq: 3.99999e-06
1fc +   li R11, #-52	# int, #@loadConI
200     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # java.util.Arrays::copyOfRange @ bci:41 (line 3822) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=R8 L[4]=_ STK[0]=R8
        # OopMap {[0]=Oop off=516/0x204}
204     #@ShouldNotReachHere

210     B20: #	out( N1 ) &lt;- in( B1 )  Freq: 4.76837e-07
210 +   li R11, #-187	# int, #@loadConI
214     spill R13 -&gt; [sp, #12]	# spill size = 32
218     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.Arrays::copyOfRange @ bci:5 (line 3820) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #12 L[3]=R8 L[4]=_ STK[0]=R8
        # OopMap {[0]=Oop off=540/0x21c}
21c     #@ShouldNotReachHere

228     B21: #	out( N1 ) &lt;- in( B3 )  Freq: 1.01328e-06
228 +   li R11, #-10	# int, #@loadConI
22c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.Arrays::copyOfRange @ bci:51 (line 3823) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=_ STK[2]=_ STK[3]=_ STK[4]=#NULL
        # OopMap {off=560/0x230}
230     #@ShouldNotReachHere

23c     B22: #	out( N1 ) &lt;- in( B16 )  Freq: 1.01029e-09
23c      -- 	// exception oop; no code emitted, #@CreateException
23c +   spill R10 -&gt; R11	# spill size = 64
240 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
24c +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='309'>
----------------------- MetaData before Compile_id = 309 ------------------------
{method}
 - this oop:          0x0000004096187598
 - method holder:     &apos;java/lang/StringLatin1&apos;
 - constants:         0x0000004096185338 constant pool [380] {0x0000004096185338} for &apos;java/lang/StringLatin1&apos; cache=0x0000004096189c30
 - access:            0x81000009  public static 
 - name:              &apos;indexOf&apos;
 - signature:         &apos;([BII)I&apos;
 - max stack:         5
 - max locals:        4
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008317620: 0xbaa i2c: 0x0000004013945bc0 c2i: 0x0000004013945c0c c2iUV: 0x0000004013945bd8
 - compiled entry     0x000000400c4d0600
 - code size:         36
 - code start:        0x0000004096187530
 - code end (excl):   0x0000004096187554
 - method data:       0x000000409652a830
 - checked ex length: 0
 - linenumber start:  0x0000004096187554
 - localvar length:   4
 - localvar start:    0x0000004096187566
 - compiled code: nmethod   7410   62       3       java.lang.StringLatin1::indexOf (36 bytes)

------------------------ OptoAssembly for Compile_id = 309 -----------------------
#
#  int ( byte[int:&gt;=0]:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: byte[int:&gt;=0]:exact *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B9 B11 B10 B7 B8 )  Freq: 1

000     B1: #	out( B9 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
01c     spill R13 -&gt; R31	# spill size = 32
020 +   srliw  R7, R12, (#8 &amp; 0x1f)	#@urShiftI_reg_imm
024     spill R12 -&gt; R13	# spill size = 32
028 +   bne  R7, zr, B9	#@cmpI_reg_imm0_branch  P=0.000000 C=8579.000000

02c     B2: #	out( B11 B3 ) &lt;- in( B1 )  Freq: 1
02c     lwu  R8, [R11, #12]	# range, #@loadRange
030     NullCheck R11

030     B3: #	out( B10 B4 ) &lt;- in( B2 )  Freq: 0.999999
030 +   subw  R12, R8, R31	#@subI_reg_reg
034 +   bgeu  R31, R8, B10	#@cmpU_branch  P=0.000000 C=5374.000000

038     B4: #	out( B8 B5 ) &lt;- in( B3 )  Freq: 0.999998
038 +   blt  R12, zr, B8	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

03c     B5: #	out( B7 B6 ) &lt;- in( B4 )  Freq: 0.999997
03c +   addw  R7, R31, zr	#@convI2L_reg_reg
040 +   add R7, R11, R7	# ptr, #@addP_reg_reg
044 +   addi  R11, R7, #16	# ptr, #@addP_reg_imm
048 +   StringUTF16 IndexOf char[] R11,R12,R13 -&gt; R10
2ec +   blt  R10, zr, B7	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

2f0     B6: #	out( B7 ) &lt;- in( B5 )  Freq: 0.998997
2f0 +   addw  R10, R31, R10	#@addI_reg_reg

2f4     B7: #	out( N1 ) &lt;- in( B6 B5 )  Freq: 0.999997
2f4     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
30c +   ret	// return register, #@Ret

310     B8: #	out( N1 ) &lt;- in( B4 )  Freq: 9.99998e-07
310 +   spill R11 -&gt; [sp, #0]	# spill size = 64
314 +   spill R13 -&gt; [sp, #8]	# spill size = 32
318 +   spill R31 -&gt; [sp, #12]	# spill size = 32
31c +   li R11, #-50	# int, #@loadConI
320     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::indexOf @ bci:32 (line 213) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #0 STK[1]=sp + #8 STK[2]=sp + #12 STK[3]=R8
        # OopMap {[0]=Oop off=804/0x324}
324     #@ShouldNotReachHere

330     B9: #	out( N1 ) &lt;- in( B1 )  Freq: 5e-07
330 +   spill R11 -&gt; R8	# spill size = 64
334 +   spill R12 -&gt; [sp, #0]	# spill size = 32
338 +   spill R31 -&gt; [sp, #4]	# spill size = 32
33c +   spill R7 -&gt; [sp, #8]	# spill size = 32
340 +   li R11, #-187	# int, #@loadConI
344     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::canEncode @ bci:4 (line 54) L[0]=_ STK[0]=sp + #8
        # java.lang.StringLatin1::indexOf @ bci:1 (line 203) L[0]=R8 L[1]=sp + #0 L[2]=sp + #4 L[3]=_
        # OopMap {fp=Oop off=840/0x348}
348     #@ShouldNotReachHere

354     B10: #	out( N1 ) &lt;- in( B3 )  Freq: 4.76836e-07
354 +   spill R11 -&gt; [sp, #0]	# spill size = 64
358 +   spill R13 -&gt; [sp, #8]	# spill size = 32
35c +   spill R31 -&gt; [sp, #16]	# spill size = 32
360 +   li R11, #-27	# int, #@loadConI
364     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::indexOf @ bci:13 (line 207) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #16 L[3]=R8 STK[0]=sp + #16
        # OopMap {[0]=Oop off=872/0x368}
368     #@ShouldNotReachHere

374     B11: #	out( N1 ) &lt;- in( B2 )  Freq: 1.01328e-06
374 +   li R11, #-10	# int, #@loadConI
378     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::indexOf @ bci:10 (line 206) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # OopMap {off=892/0x37c}
37c     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='310'>
----------------------- MetaData before Compile_id = 310 ------------------------
{method}
 - this oop:          0x00000040965e8a98
 - method holder:     &apos;jdk/internal/module/Checks&apos;
 - constants:         0x00000040965e7798 constant pool [250] {0x00000040965e7798} for &apos;jdk/internal/module/Checks&apos; cache=0x00000040965e8ce8
 - access:            0xc100000a  private static 
 - name:              &apos;isJavaIdentifier&apos;
 - signature:         &apos;(Ljava/lang/String;)Z&apos;
 - max stack:         3
 - max locals:        4
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4fbf00
 - code size:         76
 - code start:        0x00000040965e8a08
 - code end (excl):   0x00000040965e8a54
 - method data:       0x0000004096482320
 - checked ex length: 0
 - linenumber start:  0x00000040965e8a54
 - localvar length:   4
 - localvar start:    0x00000040965e8a66
 - compiled code: nmethod   7662  156       3       jdk.internal.module.Checks::isJavaIdentifier (76 bytes)

------------------------ OptoAssembly for Compile_id = 310 -----------------------
#
#  bool ( java/lang/String:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:exact *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B117 B118 B104 B113 B96 B99 B108 B109 B114 B90 B94 B98 B112 B87 B116 B103 B95 B91 B80 B107 B89 B105 B100 B55 B111 B93 B101 B92 )  Freq: 1

000     B1: #	out( B117 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
01c     spill R11 -&gt; R15	# spill size = 64
020     lwu  R28, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
024     NullCheck R11

024     B2: #	out( B118 B3 ) &lt;- in( B1 )  Freq: 0.999999
024 +   lw  R29, [R11, #12]	# int, #@loadI ! Field: java/lang/String.hash
028 +   li R13, #1272582903	# long, #@loadConL
030 +   li R25, #0	# int, #@loadConI
034 +   decode_heap_oop  R18, R28	#@decodeHeapOop
038 +   li R22, #108	# int, #@loadConI
03c     lwu  R16, [R18, #12]	# range, #@loadRange
040     NullCheck R18

040     B3: #	out( B104 B4 ) &lt;- in( B2 )  Freq: 0.999998
040 +   addi  R19, R18, #16	# ptr, #@addP_reg_imm
044 +   bleu  R16, zr, B104	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=4471.000000

048     B4: #	out( B6 B5 ) &lt;- in( B3 )  Freq: 0.999997
048 +   lbu  R17, [R19]	# byte, #@loadUB
04c +   addw  R7, R17, zr	#@convI2L_reg_reg
050 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
054 +   mv  R24, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1227 address=0x00000040d830c9c0&gt; *	# ptr, #@loadConP
06c +   lb  R9, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
070 +   mv  R31, stable:narrowoop: java/lang/Object *[int:108]&lt;ciObjArray length=108 type=&lt;ciObjArrayKlass name=[Ljava/lang/Object; loaded=true ident=1174 address=0x00000040d8325ef0&gt; ident=1190 address=0x00000040d828a7a0&gt; *	# ptr, #@loadConP
088 +   add R20, R24, R7	# ptr, #@addP_reg_reg
08c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
08c     beq  R29, zr, B6	#@cmpI_reg_imm0_branch  P=0.525856 C=5376.000000

090     B5: #	out( B21 ) &lt;- in( B4 )  Freq: 0.474143
090 +   sraiw  R30, R29, (#31 &amp; 0x1f)	#@rShiftI_reg_imm
094 +   j  B21	#@branch

098     B6: #	out( B83 B7 ) &lt;- in( B4 )  Freq: 0.525854
098 +   lbu  R7, [R11, #17]	# byte, #@loadUB ! Field: java/lang/String.hashIsZero
09c +   bne  R7, zr, B83	#@cmpI_reg_imm0_branch  P=0.001062 C=2826.000000

0a0     B7: #	out( B113 B8 ) &lt;- in( B6 )  Freq: 0.525296
0a0 +   addiw  R28, R16, #-1	#@addI_reg_imm
0a4 +   bne  R9, zr, B113	#@cmpI_reg_imm0_branch  P=0.000000 C=41603.000000

0a8     B8: #	out( B96 B9 ) &lt;- in( B7 )  Freq: 0.525296
0a8 +   bgeu  R28, R16, B96	#@cmpU_branch  P=0.000001 C=-1.000000

0ac     B9: #	out( B97 B10 ) &lt;- in( B8 )  Freq: 0.525295
0ac +   li R7, #1	# int, #@loadConI
0b0 +   addiw  R10, R16, #-3	#@addI_reg_imm
0b4 +   li R12, #4000	# int, #@loadConI
0bc +   ble  R10, R7, B97	#@cmpI_branch  P=0.000001 C=-1.000000

0c0     B10: #	out( B98 B11 ) &lt;- in( B9 )  Freq: 0.525295
0c0 +   slliw  R7, R17, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0c4 +   li R11, #1	# int, #@loadConI
0c8 +   subw  R7, R7, R17	#@subI_reg_reg
0cc +   li R29, #4	# int, #@loadConI
0d0 +   bleu  R16, R11, B98	#@cmpU_branch  P=0.000001 C=-1.000000

0d4     B11: #	out( B99 B12 ) &lt;- in( B10 )  Freq: 0.525294
0d4 +   bleu  R16, R29, B99	#@cmpU_branch  P=0.000001 C=-1.000000

0d8     B12: #	out( B13 ) &lt;- in( B11 B14 ) Loop( B12-B14 ) Freq: 9.36706
0d8 +   subw  R29, R16, R11	#@subI_reg_reg
0dc +   addiw  R29, R29, #-3	#@addI_reg_imm
0e0     CMove R29, (R10 lt R11), R29, R25	#@cmovI_cmpI
	
0e8 +   CMove R29, (R29 gtu R12), R29, R12	#@cmovI_cmpU
	
0f0 +   addw  R14, R29, R11	#@addI_reg_reg
        nop 	# 6 bytes pad for loops and calls

100     B13: #	out( B13 B14 ) &lt;- in( B12 B13 ) Loop( B13-B13 inner main of N165 strip mined) Freq: 167.034
100 +   addw  R28, R11, zr	#@convI2L_reg_reg
104 +   add R21, R18, R28	# ptr, #@addP_reg_reg
108 +   lbu  R29, [R21, #16]	# byte, #@loadUB
10c +   addw  R7, R7, R29	#@addI_reg_reg
110 +   lbu  R28, [R21, #17]	# byte, #@loadUB
114 +   slliw  R29, R7, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
118 +   subw  R7, R29, R7	#@subI_reg_reg
11c +   addw  R7, R7, R28	#@addI_reg_reg
120 +   lbu  R30, [R21, #18]	# byte, #@loadUB
124 +   slliw  R29, R7, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
128 +   subw  R7, R29, R7	#@subI_reg_reg
12c +   addw  R7, R7, R30	#@addI_reg_reg
130 +   lbu  R29, [R21, #19]	# byte, #@loadUB
134 +   slliw  R28, R7, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
138 +   subw  R7, R28, R7	#@subI_reg_reg
13c +   addw  R29, R7, R29	#@addI_reg_reg
140 +   slliw  R7, R29, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
144 +   addiw  R11, R11, #4	#@addI_reg_imm
148 +   subw  R7, R7, R29	#@subI_reg_reg
14c +   blt  R11, R14, B13	#@cmpI_loop  P=0.943921 C=17236.000000

150     B14: #	out( B12 B15 ) &lt;- in( B13 )  Freq: 9.36706
150 +   ld  R14, [R23, #920]	# ptr, #@loadP
154 +   lwu zr, [R14]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::hashCode @ bci:37 (line 196) L[0]=_ L[1]=R29 L[2]=R18 L[3]=R16 L[4]=R11 L[5]=_
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=R15 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=#Ptr0x00000040d8321320 L[1]=R15 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=R15 L[1]=_ L[2]=_ L[3]=_
        # OopMap {xmethod=Oop c_rarg5=Oop x18=Oop x19=Derived_oop_x18 esp=Derived_oop_xlocals xlocals=Oop off=340/0x154}
158 +   blt  R11, R10, B12	#@cmpI_branch  P=0.943921 C=17236.000000

15c     B15: #	out( B19 B16 ) &lt;- in( B97 B14 )  Freq: 0.525294
15c +   bge  R11, R16, B19	#@cmpI_branch  P=0.500000 C=-1.000000

160     B16: #	out( B111 B17 ) &lt;- in( B15 )  Freq: 0.262647
160 +   # castII of R11, #@castII
160     bgeu  R11, R16, B111	#@cmpU_branch  P=0.000001 C=-1.000000

164     B17: #	out( B112 B18 ) &lt;- in( B16 )  Freq: 0.262647
164 +   spill R11 -&gt; R28	# spill size = 32
168 +   # castII of R28, #@castII
168     bgeu  R28, R16, B112	#@cmpU_branch  P=0.000001 C=-1.000000

16c     B18: #	out( B18 B19 ) &lt;- in( B17 B18 ) Loop( B18-B18 inner post of N1771) Freq: 0.525293
16c +   addw  R7, R11, zr	#@convI2L_reg_reg
170 +   add R7, R18, R7	# ptr, #@addP_reg_reg
174 +   lbu  R30, [R7, #16]	# byte, #@loadUB
178 +   slliw  R7, R29, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
17c +   subw  R7, R7, R29	#@subI_reg_reg
180 +   addiw  R11, R11, #1	#@addI_reg_imm
184 +   addw  R29, R7, R30	#@addI_reg_reg
188 +   blt  R11, R16, B18	#@cmpI_loop  P=0.500000 C=17236.000000

18c     B19: #	out( B84 B20 ) &lt;- in( B18 B15 )  Freq: 0.525294
18c +   beq  R29, zr, B84	#@cmpI_reg_imm0_branch  P=0.000354 C=2823.000000

190     B20: #	out( B21 ) &lt;- in( B19 )  Freq: 0.525108
190 +   sw  R29, [R15, #12]	# int, #@storeI ! Field: java/lang/String.hash
194 +   sraiw  R30, R29, (#31 &amp; 0x1f)	#@rShiftI_reg_imm

198     B21: #	out( B81 B22 ) &lt;- in( B20 B84 B83 B5 )  Freq: 0.999995
198 +   addw  R7, R29, zr	#@convI2L_reg_reg
19c +   mul  R7, R7, R13	#@mulL
1a0 +   srai  R7, R7, (#37 &amp; 0x3f)	#@rShiftL_reg_imm
1a4 +   subw  R7, l2i(R7), R30	#@subI_reg_reg
1a8 +   mulw  R28, R7, R22	#@mulI
1ac +   subw  R30, R29, R28	#@subI_reg_reg
1b0 +   xori  R7, R30, #108	#@xorI_reg_imm
1b4 +   blt  R7, zr, B81	#@cmpI_reg_imm0_branch  P=0.133348 C=4492.000000

1b8     B22: #	out( B90 B23 ) &lt;- in( B21 B82 )  Freq: 0.999995
1b8 +   addw  R7, R30, zr	#@convI2L_reg_reg
1bc +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
1c0 +   add R7, R31, R7	# ptr, #@addP_reg_reg
1c4 +   bgeu  R30, R22, B90	#@cmpU_branch  P=0.000001 C=-1.000000

1c8     B23: #	out( B35 B24 ) &lt;- in( B22 )  Freq: 0.999994
1c8 +   lw  R11, [R20, #16]	# int, #@loadI
1cc +   lwu  R10, [R7, #16]	# loadN, compressed ptr, #@loadN
1d0 +   li R13, #28672	# int, #@loadConI
1d4 +   andr  R21, R11, R13	#@andI_reg_reg
1d8 +   decode_heap_oop  R13, R10	#@decodeHeapOop
1dc +   sraw  R29, R16, R9	#@rShiftI_reg_reg
1e0 +   li R28, #-1	# int, #@loadConI
1e4 +   li R12, #20480	# int, #@loadConI
1e8 +   beq   R13, zr, B35	#@cmpP_imm0_branch  P=0.318616 C=13182.000000

1ec     B24: #	out( B66 B25 ) &lt;- in( B23 )  Freq: 0.68138
1ec +   lwu  R10, [R13, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
1f0 +   mv  R11, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
200 +   beq  R15, R13, B66	#@cmpP_branch  P=0.000001 C=5338.000000

204     B25: #	out( B116 B26 ) &lt;- in( B24 )  Freq: 0.681379
204 +   bne  R10, R11, B116	#@cmpN_branch  P=0.000000 C=-1.000000

208     B26: #	out( B103 B27 ) &lt;- in( B25 )  Freq: 0.681379
208 +   # checkcastPP of R13, #@checkCastPP
208     lwu  R10, [R13, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
20c +   lb  R14, [R13, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
210 +   decode_heap_oop  R11, R10	#@decodeHeapOop
214 +   bne  R9, R14, B103	#@cmpI_branch  P=0.000000 C=4992.000000

218     B27: #	out( B95 B28 ) &lt;- in( B26 )  Freq: 0.681379
218 +   beq   R18, zr, B95	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

21c     B28: #	out( B91 B29 ) &lt;- in( B27 )  Freq: 0.681378
21c +   beq   R11, zr, B91	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

220     B29: #	out( B31 B30 ) &lt;- in( B28 )  Freq: 0.681377
220 +   lwu  R10, [R11, #12]	# range, #@loadRange
224 +   addiw  R20, R30, #1	#@addI_reg_imm
228 +   bne  R16, R10, B31	#@cmpI_branch  P=0.001000 C=-1.000000

22c     B30: #	out( B79 B31 ) &lt;- in( B29 )  Freq: 0.680696
22c +   addi  R13, R11, #16	# ptr, #@addP_reg_imm
230     spill R16 -&gt; R14	# spill size = 32
234 +   spill R19 -&gt; R11	# spill size = 64
238 +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
2c8 +   bne  R10, zr, B79	#@cmpI_reg_imm0_branch  P=0.000000 C=8982.000000

2cc     B31: #	out( B106 B32 ) &lt;- in( B30 B29 )  Freq: 0.681377
2cc +   beq  R20, R22, B106	#@cmpI_branch  P=0.000000 C=8982.000000

2d0     B32: #	out( B88 B33 ) &lt;- in( B31 )  Freq: 0.681377
2d0 +   bgeu  R20, R22, B88	#@cmpU_branch  P=0.000001 C=-1.000000

2d4     B33: #	out( B56 B34 ) &lt;- in( B32 )  Freq: 0.681376
2d4 +   lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN
2d8 +   decode_heap_oop  R13, R7	#@decodeHeapOop
2dc +   bne   R13, zr, B56	#@cmpP_imm0_branch  P=0.681384 C=8982.000000

2e0     B34: #	out( B35 ) &lt;- in( B33 )  Freq: 0.217097
2e0 +   spill R20 -&gt; R30	# spill size = 32

2e4     B35: #	out( B105 B36 ) &lt;- in( B34 B70 B23 )  Freq: 0.999983
2e4 +   subw  R8, R28, R30	#@subI_reg_reg
2e8 +   bge  R8, zr, B105	#@cmpI_reg_imm0_branch  P=0.000000 C=4356.000000

2ec     B36: #	out( B100 B37 ) &lt;- in( B35 )  Freq: 0.999983
2ec +   bne  R9, zr, B100	#@cmpI_reg_imm0_branch  P=0.000000 C=41603.000000

2f0     B37: #	out( B101 B38 ) &lt;- in( B36 )  Freq: 0.999982
2f0 +   blt  R21, R12, B101	#@cmpI_branch  P=0.000000 C=4351.000000

2f4     B38: #	out( B55 B39 ) &lt;- in( B37 )  Freq: 0.999982
2f4 +   li R28, #1	# int, #@loadConI
2f8 +   ble  R29, R28, B55	#@cmpI_branch  P=0.223149 C=18351.000000

2fc     B39: #	out( B92 B40 ) &lt;- in( B38 )  Freq: 0.776837
2fc +   addw  R7, R29, zr	#@convI2L_reg_reg
300 +   li R30, #1	# int, #@loadConI
304 +   addw  R28, R16, zr	#@convI2L_reg_reg
308 +   addi  R7, R7, #-1	#@addL_reg_imm
30c +   bleu  R16, R30, B92	#@cmpU_branch  P=0.000001 C=-1.000000

310     B40: #	out( B92 B41 ) &lt;- in( B39 )  Freq: 0.776837
310 +   bgeu  R7, R28, B92	#@cmpUL_branch  P=0.000001 C=-1.000000

314     B41: #	out( B110 B42 ) &lt;- in( B40 )  Freq: 0.776836
314 +   lbu  R10, [R18, #17]	# byte, #@loadUB
318 +   addw  R7, R10, zr	#@convI2L_reg_reg
31c +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
320 +   add R7, R24, R7	# ptr, #@addP_reg_reg
324 +   lw  R28, [R7, #16]	# int, #@loadI
328 +   li R12, #12288	# int, #@loadConI
32c +   andr  R28, R28, R12	#@andI_reg_reg
330 +   beq  R28, zr, B110	#@cmpI_reg_imm0_branch  P=0.000000 C=5376.000000

334     B42: #	out( B50 B43 ) &lt;- in( B41 )  Freq: 0.776835
334 +   li R28, #-2147483648	# int, #@loadConI
338 +   addiw  R11, R29, #-1	#@addI_reg_imm
33c     CMove R11, (R29 lt R11), R11, R28	#@cmovI_cmpI
	
344 +   li R31, #2	# int, #@loadConI
348 +   li R7, #2000	# int, #@loadConI
34c +   ble  R11, R31, B50	#@cmpI_branch  P=0.000001 C=-1.000000

350     B43: #	out( B93 B44 ) &lt;- in( B42 )  Freq: 0.776835
350 +   li R28, #3	# int, #@loadConI
354 +   bleu  R16, R31, B93	#@cmpU_branch  P=0.000001 C=-1.000000

358     B44: #	out( B94 B45 ) &lt;- in( B43 )  Freq: 0.776834
358 +   bleu  R16, R28, B94	#@cmpU_branch  P=0.000001 C=-1.000000

35c     B45: #	out( B46 ) &lt;- in( B44 B49 ) Loop( B45-B49 ) Freq: 3.48118
35c +   subw  R30, R11, R31	#@subI_reg_reg
360     CMove R30, (R11 lt R31), R30, R25	#@cmovI_cmpI
	
368 +   CMove R30, (R30 gtu R7), R30, R7	#@cmovI_cmpU
	
370 +   addw  R30, R30, R31	#@addI_reg_reg
        nop 	# 6 bytes pad for loops and calls

380     B46: #	out( B85 B47 ) &lt;- in( B45 B48 ) Loop( B46-B48 inner main of N377 strip mined) Freq: 15.6002
380 +   addw  R28, R31, zr	#@convI2L_reg_reg
384 +   add R28, R18, R28	# ptr, #@addP_reg_reg
388 +   lbu  R17, [R28, #16]	# byte, #@loadUB
38c +   lbu  R10, [R28, #17]	# byte, #@loadUB
390 +   addw  R28, R17, zr	#@convI2L_reg_reg
394 +   addw  R13, R10, zr	#@convI2L_reg_reg
398 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
39c +   slli  R13, R13, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
3a0 +   add R28, R24, R28	# ptr, #@addP_reg_reg
3a4 +   add R13, R24, R13	# ptr, #@addP_reg_reg
3a8 +   lw  R28, [R28, #16]	# int, #@loadI
3ac +   lw  R14, [R13, #16]	# int, #@loadI
3b0 +   andr  R13, R28, R12	#@andI_reg_reg
3b4 +   andr  R28, R14, R12	#@andI_reg_reg
3b8 +   beq  R13, zr, B85	#@cmpI_reg_imm0_branch  P=0.000000 C=5376.000000

3bc     B47: #	out( B86 B48 ) &lt;- in( B46 )  Freq: 15.6002
3bc +   beq  R28, zr, B86	#@cmpI_reg_imm0_branch  P=0.000000 C=5376.000000

3c0     B48: #	out( B46 B49 ) &lt;- in( B47 )  Freq: 15.6002
3c0 +   addiw  R31, R31, #2	#@addI_reg_imm
3c4 +   blt  R31, R30, B46	#@cmpI_loop  P=0.776851 C=14256.000000

3c8     B49: #	out( B45 B50 ) &lt;- in( B48 )  Freq: 3.48117
3c8 +   ld  R28, [R23, #920]	# ptr, #@loadP
3cc +   lwu zr, [R28]	# Safepoint: poll for GC, #@safePoint        # jdk.internal.module.Checks::isJavaIdentifier @ bci:71 (line 185) L[0]=R15 L[1]=_ L[2]=R31 L[3]=_
        # OopMap {c_rarg5=Oop x18=Oop xlocals=Oop off=972/0x3cc}
3d0 +   blt  R31, R11, B45	#@cmpI_branch  P=0.776851 C=14256.000000

3d4     B50: #	out( B55 B51 ) &lt;- in( B42 B49 )  Freq: 0.776819
3d4 +   bge  R31, R29, B55	#@cmpI_branch  P=0.500000 C=-1.000000

3d8     B51: #	out( B108 B52 ) &lt;- in( B50 )  Freq: 0.388409
3d8 +   # castII of R31, #@castII
3d8     bgeu  R31, R16, B108	#@cmpU_branch  P=0.000001 C=-1.000000

3dc     B52: #	out( B109 B53 ) &lt;- in( B51 )  Freq: 0.388409
3dc +   spill R31 -&gt; R28	# spill size = 32
3e0 +   # castII of R28, #@castII
3e0     bgeu  R28, R16, B109	#@cmpU_branch  P=0.000001 C=-1.000000

3e4     B53: #	out( B87 B54 ) &lt;- in( B52 B54 ) Loop( B53-B54 inner post of N1841) Freq: 0.776817
3e4 +   addw  R7, R31, zr	#@convI2L_reg_reg
3e8 +   add R7, R18, R7	# ptr, #@addP_reg_reg
3ec +   lbu  R10, [R7, #16]	# byte, #@loadUB
3f0 +   addw  R7, R10, zr	#@convI2L_reg_reg
3f4 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
3f8 +   add R7, R24, R7	# ptr, #@addP_reg_reg
3fc +   lw  R7, [R7, #16]	# int, #@loadI
400 +   andr  R28, R7, R12	#@andI_reg_reg
404 +   beq  R28, zr, B87	#@cmpI_reg_imm0_branch  P=0.000000 C=5376.000000

408     B54: #	out( B53 B55 ) &lt;- in( B53 )  Freq: 0.776817
408 +   addiw  R31, R31, #1	#@addI_reg_imm
40c +   blt  R31, R29, B53	#@cmpI_loop  P=0.500000 C=14256.000000

410     B55: #	out( N1 ) &lt;- in( B50 B38 B54 )  Freq: 0.999962
410 +   li R10, #1	# int, #@loadConI
414     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
42c +   ret	// return register, #@Ret

430     B56: #	out( B65 B57 ) &lt;- in( B33 )  Freq: 0.464278
430 +   lwu  R7, [R13, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
434 +   mv  R10, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
444 +   beq  R15, R13, B65	#@cmpP_branch  P=0.000001 C=5338.000000

448     B57: #	out( B115 B58 ) &lt;- in( B56 )  Freq: 0.464278
448 +   bne  R7, R10, B115	#@cmpN_branch  P=0.000000 C=-1.000000

44c     B58: #	out( B102 B59 ) &lt;- in( B57 )  Freq: 0.464278
44c +   # checkcastPP of R13, #@checkCastPP
44c     lwu  R10, [R13, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
450 +   lb  R14, [R13, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
454 +   decode_heap_oop  R7, R10	#@decodeHeapOop
458 +   bne  R9, R14, B102	#@cmpI_branch  P=0.000000 C=4992.000000

45c     B59: #	out( B95 B60 ) &lt;- in( B58 )  Freq: 0.464278
45c +   beq   R18, zr, B95	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

460     B60: #	out( B91 B61 ) &lt;- in( B59 )  Freq: 0.464277
460 +   beq   R7, zr, B91	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

464     B61: #	out( B63 B62 ) &lt;- in( B60 )  Freq: 0.464277
464 +   lwu  R10, [R7, #12]	# range, #@loadRange
468 +   addiw  R30, R30, #2	#@addI_reg_imm
46c +   bne  R16, R10, B63	#@cmpI_branch  P=0.001000 C=-1.000000

470     B62: #	out( B78 B63 ) &lt;- in( B61 )  Freq: 0.463813
470 +   spill R16 -&gt; R14	# spill size = 32
474 +   addi  R13, R7, #16	# ptr, #@addP_reg_imm
478     spill R19 -&gt; R11	# spill size = 64
47c +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
50c +   bne  R10, zr, B78	#@cmpI_reg_imm0_branch  P=0.000000 C=8982.000000

510     B63: #	out( B107 B64 ) &lt;- in( B62 B61 )  Freq: 0.464277
510 +   beq  R30, R22, B107	#@cmpI_branch  P=0.000000 C=8982.000000

514     B64: #	out( B69 ) &lt;- in( B63 )  Freq: 0.464276
514 +   ld  R11, [R23, #920]	# ptr, #@loadP
518 +   mv  R7, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
528 +   j  B69	#@branch

52c     B65: #	out( B66 ) &lt;- in( B56 )  Freq: 4.70444e-07
52c +   spill R20 -&gt; R30	# spill size = 32

530     B66: #	out( B80 ) &lt;- in( B24 B65 B71 )  Freq: 2.16693e-06
530 +   li R8, #1	# int, #@loadConI
534 +   j  B80	#@branch
        nop 	# 4 bytes pad for loops and calls

540     B67: #	out( B107 B68 ) &lt;- in( B76 B75 ) top-of-loop Freq: 0.992875
540 +   addiw  R30, R30, #1	#@addI_reg_imm
544 +   beq  R30, R22, B107	#@cmpI_branch  P=0.000000 C=8982.000000

548     B68: #	out( B69 ) &lt;- in( B67 )  Freq: 0.992874
548 +   ld  R11, [R23, #920]	# ptr, #@loadP

54c     B69: #	out( B89 B70 ) &lt;- in( B64 B68 ) Loop( B69-B68 inner partial_peel ) Freq: 1.45715
54c +   lwu zr, [R11]	# Safepoint: poll for GC, #@safePoint        # java.util.ImmutableCollections$SetN::probe @ bci:53 (line 1017) L[0]=#Ptr0x00000040d8321320 L[1]=R15 L[2]=R30 L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=R15 L[1]=_ L[2]=_ L[3]=_
        # OopMap {xmethod=Oop c_rarg5=Oop x18=Oop x19=Derived_oop_x18 xlocals=Oop off=1356/0x54c}
550 +   addw  R10, R30, zr	#@convI2L_reg_reg
554 +   slli  R10, R10, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
558 +   add R10, R31, R10	# ptr, #@addP_reg_reg
55c +   bgeu  R30, R22, B89	#@cmpU_branch  P=0.000001 C=-1.000000

560     B70: #	out( B35 B71 ) &lt;- in( B69 )  Freq: 1.45715
560 +   lwu  R11, [R10, #16]	# loadN, compressed ptr, #@loadN
564 +   decode_heap_oop  R13, R11	#@decodeHeapOop
568 +   beq   R13, zr, B35	#@cmpP_imm0_branch  P=0.318616 C=8982.000000

56c     B71: #	out( B66 B72 ) &lt;- in( B70 )  Freq: 0.992878
56c +   lwu  R10, [R13, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
570 +   beq  R15, R13, B66	#@cmpP_branch  P=0.000001 C=5338.000000

574     B72: #	out( B116 B73 ) &lt;- in( B71 )  Freq: 0.992877
574 +   bne  R10, R7, B116	#@cmpN_branch  P=0.000000 C=-1.000000

578     B73: #	out( B103 B74 ) &lt;- in( B72 )  Freq: 0.992877
578 +   # checkcastPP of R13, #@checkCastPP
578     lwu  R10, [R13, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
57c +   lb  R14, [R13, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
580 +   decode_heap_oop  R11, R10	#@decodeHeapOop
584 +   bne  R9, R14, B103	#@cmpI_branch  P=0.000000 C=4992.000000

588     B74: #	out( B91 B75 ) &lt;- in( B73 )  Freq: 0.992876
588 +   beq   R11, zr, B91	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

58c     B75: #	out( B67 B76 ) &lt;- in( B74 )  Freq: 0.992875
58c +   lwu  R10, [R11, #12]	# range, #@loadRange
590 +   bne  R16, R10, B67	#@cmpI_branch  P=0.001000 C=-1.000000

594     B76: #	out( B67 B77 ) &lt;- in( B75 )  Freq: 0.991882
594 +   addi  R13, R11, #16	# ptr, #@addP_reg_imm
598     spill R16 -&gt; R14	# spill size = 32
59c +   spill R19 -&gt; R11	# spill size = 64
5a0 +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
630 +   beq  R10, zr, B67	#@cmpI_reg_imm0_branch  P=1.000000 C=8982.000000

634     B77: #	out( B78 ) &lt;- in( B76 )  Freq: 4.72966e-07
634 +   spill R30 -&gt; R20	# spill size = 32

638     B78: #	out( B79 ) &lt;- in( B62 B77 )  Freq: 6.94129e-07
638 +   spill R20 -&gt; R30	# spill size = 32

63c     B79: #	out( B80 ) &lt;- in( B30 B78 )  Freq: 1.01871e-06
63c +   spill R10 -&gt; R8	# spill size = 32

640     B80: #	out( N1 ) &lt;- in( B66 B79 )  Freq: 3.18564e-06
640 +   li R11, #-187	# int, #@loadConI
644     spill R15 -&gt; [sp, #8]	# spill size = 64
648 +   spill R30 -&gt; [sp, #16]	# spill size = 32
64c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:34 (line 1012) L[0]=#Ptr0x00000040d8321320 L[1]=sp + #8 L[2]=sp + #16 L[3]=_ STK[0]=R8
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[8]=Oop off=1616/0x650}
650     #@ShouldNotReachHere

65c     B81: #	out( B114 B82 ) &lt;- in( B21 )  Freq: 0.133348
65c +   addiw  R10, R30, #108	#@addI_reg_imm
660 +   beq  R29, R28, B114	#@cmpI_branch  P=0.000000 C=599.000000

664     B82: #	out( B22 ) &lt;- in( B81 )  Freq: 0.133347
664 +   spill R10 -&gt; R30	# spill size = 32
668 +   j  B22	#@branch

66c     B83: #	out( B21 ) &lt;- in( B6 )  Freq: 0.000558232
66c +   li R29, #0	# int, #@loadConI
670 +   li R30, #0	# int, #@loadConI
674 +   j  B21	#@branch

678     B84: #	out( B21 ) &lt;- in( B19 )  Freq: 0.000186075
678 +   li R28, #1	# int, #@loadConI
67c +   sb  R28, [R15, #17]	# byte, #@storeB ! Field: java/lang/String.hashIsZero
680 +   li R29, #0	# int, #@loadConI
684 +   li R30, #0	# int, #@loadConI
688 +   j  B21	#@branch

68c     B85: #	out( B87 ) &lt;- in( B46 )  Freq: 7.43878e-06
68c +   spill R13 -&gt; R28	# spill size = 32
690 +   spill R17 -&gt; R10	# spill size = 32
694 +   j  B87	#@branch

698     B86: #	out( B87 ) &lt;- in( B47 )  Freq: 7.43877e-06
698 +   addiw  R31, R31, #1	#@addI_reg_imm

69c     B87: #	out( N1 ) &lt;- in( B53 B110 B85 B86 )  Freq: 1.56184e-05
69c +   li R11, #-187	# int, #@loadConI
6a0     spill R15 -&gt; R8	# spill size = 64
6a4 +   spill R31 -&gt; [sp, #0]	# spill size = 32
6a8 +   spill R10 -&gt; [sp, #4]	# spill size = 32
6ac +   spill R28 -&gt; [sp, #8]	# spill size = 32
6b0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.CharacterDataLatin1::isJavaIdentifierPart @ bci:11 (line 121) L[0]=_ L[1]=_ L[2]=_ STK[0]=sp + #8
        # java.lang.Character::isJavaIdentifierPart @ bci:5 (line 10140) L[0]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:56 (line 182) L[0]=R8 L[1]=_ L[2]=sp + #0 L[3]=sp + #4
        # OopMap {fp=Oop off=1716/0x6b4}
6b4     #@ShouldNotReachHere

6c0     B88: #	out( B89 ) &lt;- in( B32 )  Freq: 6.90425e-07
6c0 +   spill R20 -&gt; R30	# spill size = 32

6c4     B89: #	out( N1 ) &lt;- in( B88 B69 )  Freq: 2.16692e-06
6c4 +   li R11, #-28	# int, #@loadConI
6c8     spill R15 -&gt; [sp, #0]	# spill size = 64
6cc +   spill R30 -&gt; [sp, #12]	# spill size = 32
6d0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:18 (line 1009) L[0]=#Ptr0x00000040d8321320 L[1]=sp + #0 L[2]=sp + #12 L[3]=_ STK[0]=#Ptr0x00000040d828a7a0 STK[1]=sp + #12
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=1748/0x6d4}
6d4     #@ShouldNotReachHere

6e0     B90: #	out( N1 ) &lt;- in( B22 )  Freq: 1.01327e-06
6e0 +   li R11, #-28	# int, #@loadConI
6e4     spill R15 -&gt; [sp, #0]	# spill size = 64
6e8 +   spill R30 -&gt; [sp, #12]	# spill size = 32
6ec     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:18 (line 1009) L[0]=#Ptr0x00000040d8321320 L[1]=sp + #0 L[2]=sp + #12 L[3]=_ STK[0]=#Ptr0x00000040d828a7a0 STK[1]=sp + #12
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=1776/0x6f0}
6f0     #@ShouldNotReachHere

6fc     B91: #	out( N1 ) &lt;- in( B28 B74 B60 )  Freq: 2.16693e-06
6fc     #@ShouldNotReachHere

708     B92: #	out( N1 ) &lt;- in( B40 B39 )  Freq: 1.56399e-06
708 +   li R11, #-138	# int, #@loadConI
70c     spill R15 -&gt; R8	# spill size = 64
710 +   spill R29 -&gt; [sp, #0]	# spill size = 32
714     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:46 (line 180) L[0]=R8 L[1]=_ L[2]=#1 L[3]=_ STK[0]=#1 STK[1]=sp + #0
        # OopMap {fp=Oop off=1816/0x718}
718     #@ShouldNotReachHere

724     B93: #	out( N1 ) &lt;- in( B43 )  Freq: 7.76835e-07
724     #@ShouldNotReachHere

730     B94: #	out( N1 ) &lt;- in( B44 )  Freq: 7.76834e-07
730     #@ShouldNotReachHere

73c     B95: #	out( N1 ) &lt;- in( B27 B59 )  Freq: 1.16087e-06
73c     #@ShouldNotReachHere

748     B96: #	out( N1 ) &lt;- in( B8 )  Freq: 5.32271e-07
748 +   li R11, #-138	# int, #@loadConI
74c     spill R15 -&gt; [sp, #0]	# spill size = 64
750 +   spill R15 -&gt; [sp, #8]	# spill size = 64
754 +   spill R18 -&gt; [sp, #16]	# spill size = 64
758 +   spill R16 -&gt; [sp, #28]	# spill size = 32
75c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:13 (line 196) L[0]=_ L[1]=#0 L[2]=sp + #16 L[3]=sp + #28 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=sp + #28
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=sp + #0 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=#Ptr0x00000040d8321320 L[1]=sp + #8 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=1888/0x760}
760     #@ShouldNotReachHere

76c     B97: #	out( B15 ) &lt;- in( B9 )  Freq: 5.32271e-07
76c +   li R11, #1	# int, #@loadConI
770     spill R17 -&gt; R29	# spill size = 32
774 +   j  B15	#@branch

778     B98: #	out( N1 ) &lt;- in( B10 )  Freq: 5.25295e-07
778     #@ShouldNotReachHere

784     B99: #	out( N1 ) &lt;- in( B11 )  Freq: 5.25294e-07
784     #@ShouldNotReachHere

790     B100: #	out( N1 ) &lt;- in( B36 )  Freq: 4.99991e-07
790 +   li R11, #-187	# int, #@loadConI
794     spill R15 -&gt; [sp, #0]	# spill size = 64
798 +   spill R15 -&gt; [sp, #8]	# spill size = 64
79c +   spill R9 -&gt; [sp, #16]	# spill size = 32
7a0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #16
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=sp + #0 L[1]=#0
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #8 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop [8]=Oop off=1956/0x7a4}
7a4     #@ShouldNotReachHere

7b0     B101: #	out( N1 ) &lt;- in( B37 )  Freq: 4.99991e-07
7b0 +   li R11, #-187	# int, #@loadConI
7b4     spill R15 -&gt; R8	# spill size = 64
7b8 +   spill R17 -&gt; [sp, #0]	# spill size = 32
7bc +   spill R21 -&gt; [sp, #4]	# spill size = 32
7c0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.CharacterDataLatin1::isJavaIdentifierStart @ bci:14 (line 116) L[0]=_ L[1]=_ L[2]=_ STK[0]=sp + #4 STK[1]=#20480
        # java.lang.Character::isJavaIdentifierStart @ bci:5 (line 10070) L[0]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:28 (line 176) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_
        # OopMap {fp=Oop off=1988/0x7c4}
7c4     #@ShouldNotReachHere

7d0     B102: #	out( B103 ) &lt;- in( B58 )  Freq: 2.32139e-07
7d0 +   spill R20 -&gt; R30	# spill size = 32

7d4     B103: #	out( N1 ) &lt;- in( B26 B102 B73 )  Freq: 1.06927e-06
7d4 +   li R11, #-187	# int, #@loadConI
7d8     spill R15 -&gt; [sp, #0]	# spill size = 64
7dc +   spill R15 -&gt; [sp, #8]	# spill size = 64
7e0 +   spill R30 -&gt; [sp, #16]	# spill size = 32
7e4 +   spill R13 -&gt; [sp, #24]	# spill size = 64
7e8 +   spill R9 -&gt; [sp, #20]	# spill size = 32
7ec +   spill R14 -&gt; [sp, #32]	# spill size = 32
7f0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #0 L[1]=_ L[2]=sp + #24 STK[0]=sp + #20 STK[1]=sp + #32
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=#Ptr0x00000040d8321320 L[1]=sp + #8 L[2]=sp + #16 L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop [8]=Oop [24]=Oop off=2036/0x7f4}
7f4     #@ShouldNotReachHere

800     B104: #	out( N1 ) &lt;- in( B3 )  Freq: 4.76836e-07
800 +   li R11, #-187	# int, #@loadConI
804     spill R15 -&gt; R8	# spill size = 64
808 +   spill R16 -&gt; [sp, #0]	# spill size = 32
80c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isEmpty @ bci:5 (line 1487) L[0]=_ STK[0]=sp + #0
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop off=2064/0x810}
810     #@ShouldNotReachHere

81c     B105: #	out( N1 ) &lt;- in( B35 )  Freq: 4.76829e-07
81c +   li R11, #-187	# int, #@loadConI
820     spill R15 -&gt; [sp, #0]	# spill size = 64
824     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::contains @ bci:17 (line 938) L[0]=_ L[1]=_ STK[0]=R8
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=2088/0x828}
828     #@ShouldNotReachHere

834     B106: #	out( B107 ) &lt;- in( B31 )  Freq: 3.24906e-07
834 +   spill R20 -&gt; R30	# spill size = 32

838     B107: #	out( N1 ) &lt;- in( B106 B63 B67 )  Freq: 1.01973e-06
838 +   li R11, #-187	# int, #@loadConI
83c     spill R15 -&gt; [sp, #0]	# spill size = 64
840 +   spill R30 -&gt; [sp, #12]	# spill size = 32
844     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:48 (line 1014) L[0]=#Ptr0x00000040d8321320 L[1]=sp + #0 L[2]=sp + #12 L[3]=_ STK[0]=sp + #12 STK[1]=#108
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=2120/0x848}
848     #@ShouldNotReachHere

854     B108: #	out( N1 ) &lt;- in( B51 )  Freq: 3.93567e-07
854     #@ShouldNotReachHere

860     B109: #	out( N1 ) &lt;- in( B52 )  Freq: 3.93567e-07
860     #@ShouldNotReachHere

86c     B110: #	out( B87 ) &lt;- in( B41 )  Freq: 3.70424e-07
86c +   li R31, #1	# int, #@loadConI
870 +   j  B87	#@branch

874     B111: #	out( N1 ) &lt;- in( B16 )  Freq: 2.66135e-07
874     #@ShouldNotReachHere

880     B112: #	out( N1 ) &lt;- in( B17 )  Freq: 2.66135e-07
880     #@ShouldNotReachHere

88c     B113: #	out( N1 ) &lt;- in( B7 )  Freq: 2.62648e-07
88c +   li R11, #-187	# int, #@loadConI
890     spill R15 -&gt; [sp, #0]	# spill size = 64
894 +   spill R15 -&gt; [sp, #8]	# spill size = 64
898 +   spill R9 -&gt; [sp, #16]	# spill size = 32
89c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #16
        # java.lang.String::hashCode @ bci:17 (line 2337) L[0]=sp + #0 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=#Ptr0x00000040d8321320 L[1]=sp + #8 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop [8]=Oop off=2208/0x8a0}
8a0     #@ShouldNotReachHere

8ac     B114: #	out( N1 ) &lt;- in( B81 )  Freq: 6.35851e-08
8ac +   li R11, #-187	# int, #@loadConI
8b0     spill R15 -&gt; [sp, #0]	# spill size = 64
8b4 +   spill R30 -&gt; [sp, #12]	# spill size = 32
8b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.Math::floorMod @ bci:11 (line 1344) L[0]=_ L[1]=#108 L[2]=sp + #12 STK[0]=sp + #12
        # java.util.ImmutableCollections$SetN::probe @ bci:9 (line 1007) L[0]=#Ptr0x00000040d8321320 L[1]=sp + #0 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=2236/0x8bc}
8bc     #@ShouldNotReachHere

8c8     B115: #	out( B116 ) &lt;- in( B57 )  Freq: 1e-35
8c8 +   spill R20 -&gt; R30	# spill size = 32

8cc     B116: #	out( N1 ) &lt;- in( B25 B115 B72 )  Freq: 1e-35
8cc +   li R11, #-34	# int, #@loadConI
8d0     spill R15 -&gt; [sp, #0]	# spill size = 64
8d4 +   spill R15 -&gt; [sp, #8]	# spill size = 64
8d8 +   spill R30 -&gt; [sp, #16]	# spill size = 32
8dc +   spill R13 -&gt; [sp, #32]	# spill size = 64
8e0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #0 L[1]=sp + #32 L[2]=_ STK[0]=sp + #32
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=#Ptr0x00000040d8321320 L[1]=sp + #8 L[2]=sp + #16 L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop [8]=Oop [32]=Oop off=2276/0x8e4}
8e4     #@ShouldNotReachHere

8f0     B117: #	out( N1 ) &lt;- in( B1 )  Freq: 1.01328e-06
8f0 +   li R11, #-10	# int, #@loadConI
8f4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # OopMap {off=2296/0x8f8}
8f8     #@ShouldNotReachHere

904     B118: #	out( N1 ) &lt;- in( B2 )  Freq: 1.01328e-06
904 +   li R11, #-10	# int, #@loadConI
908     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::isEmpty @ bci:4 (line 1487) L[0]=_ STK[0]=#NULL
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=2316/0x90c}
90c     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='311'>
----------------------- MetaData before Compile_id = 311 ------------------------
{method}
 - this oop:          0x00000040961897f0
 - method holder:     &apos;java/lang/StringLatin1&apos;
 - constants:         0x0000004096185338 constant pool [380] {0x0000004096185338} for &apos;java/lang/StringLatin1&apos; cache=0x0000004096189c30
 - access:            0x81000009  public static 
 - name:              &apos;newString&apos;
 - signature:         &apos;([BII)Ljava/lang/String;&apos;
 - max stack:         7
 - max locals:        3
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008317620: 0xbaa i2c: 0x0000004013945bc0 c2i: 0x0000004013945c0c c2iUV: 0x0000004013945bd8
 - compiled entry     0x000000400c4bef80
 - code size:         24
 - code start:        0x00000040961897a8
 - code end (excl):   0x00000040961897c0
 - method data:       0x000000409652be88
 - checked ex length: 0
 - linenumber start:  0x00000040961897c0
 - localvar length:   3
 - localvar start:    0x00000040961897ca
 - compiled code: nmethod   7768   58       3       java.lang.StringLatin1::newString (24 bytes)

------------------------ OptoAssembly for Compile_id = 311 -----------------------
#
#  java/lang/String:exact * ( byte[int:&gt;=0]:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: byte[int:&gt;=0]:exact *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B32 B33 B34 B31 B20 B37 )  Freq: 1

000     B1: #	out( B32 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
01c     spill R12 -&gt; [sp, #8]	# spill size = 32
020 +   spill R11 -&gt; [sp, #0]	# spill size = 64
024 +   spill R13 -&gt; [sp, #12]	# spill size = 32
028 +   beq  R13, zr, B32	#@cmpI_reg_imm0_branch  P=0.000000 C=5374.000000

02c     B2: #	out( B26 B3 ) &lt;- in( B1 )  Freq: 1
02c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
02c     ld  R9, [R23, #288]	# ptr, #@loadP
030 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
030     ld  R7, [R23, #304]	# ptr, #@loadP
034 +   addi  R28, R9, #24	# ptr, #@addP_reg_imm
038 +   bgeu  R28, R7, B26	#@cmpP_branch  P=0.000100 C=-1.000000

03c     B3: #	out( B4 ) &lt;- in( B2 )  Freq: 0.9999
03c +   li R7, #1	# long, #@loadConL
040 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
040     sd  R28, [R23, #288]	# ptr, #@storeP
044 +   sd  R7, [R9]	# long, #@storeL
048 +   mv  R7, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
058 +   sw  R7, [R9, #8]	# compressed klass ptr, #@storeNKlass
05c +   sw  zr, [R9, #12]	# int, #@storeimmI0
060 +   sd  zr, [R9, #16]	# long, #@storeimmL0

064     B4: #	out( B33 B5 ) &lt;- in( B27 B3 )  Freq: 1
064     
064     spill [sp, #12] -&gt; R28	# spill size = 32
068 +   li R7, #1048576	# int, #@loadConI
06c +   # checkcastPP of R9, #@checkCastPP
06c     blt  R28, zr, B33	#@cmpI_reg_imm0_branch  P=0.000000 C=5376.000000

070     B5: #	out( B6 B6 ) &lt;- in( B4 )  Freq: 0.999999
070 +   addw  R28, R28, zr	#@convI2L_reg_reg
074     spill [sp, #12] -&gt; R29	# spill size = 32
078 +   bleu  R29, R7, B6	#@cmpU_branch  P=0.999999 C=-1.000000

07c     B6: #	out( B34 B7 ) &lt;- in( B5 B5 )  Freq: 0.999999
07c +   spill [sp, #0] -&gt; R29	# spill size = 64
080     lwu  R30, [R29, #12]	# range, #@loadRange
084     NullCheck R29

084     B7: #	out( B31 B8 ) &lt;- in( B6 )  Freq: 0.999998
084 +   spill [sp, #8] -&gt; R31	# spill size = 32
088 +   subw  R29, R30, R31	#@subI_reg_reg
08c     spill [sp, #12] -&gt; R8	# spill size = 32
090 +   CMove R8, (R29 lt R8), R8, R29	#@cmovI_cmpI
	
098 +   spill [sp, #8] -&gt; R31	# spill size = 32
09c +   addw  R31, R31, R8	#@addI_reg_reg
0a0     spill [sp, #8] -&gt; R29	# spill size = 32
0a4 +   blt  R29, zr, B31	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0a8     B8: #	out( B31 B9 ) &lt;- in( B7 )  Freq: 0.999997
0a8 +   bltu  R30, R31, B31	#@cmpU_branch  P=0.000001 C=-1.000000

0ac     B9: #	out( B31 B10 ) &lt;- in( B8 )  Freq: 0.999996
0ac +   spill [sp, #12] -&gt; R30	# spill size = 32
0b0 +   bltu  R30, R8, B31	#@cmpU_branch  P=0.000001 C=-1.000000

0b4     B10: #	out( B31 B11 ) &lt;- in( B9 )  Freq: 0.999995
0b4 +   blt  R8, zr, B31	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0b8     B11: #	out( B28 B12 ) &lt;- in( B10 )  Freq: 0.999994
0b8 +   addi  R29, R28, #23	#@addL_reg_imm
0bc +   bgtu  R30, R7, B28	#@cmpU_branch  P=0.000001 C=-1.000000

0c0     B12: #	out( B28 B13 ) &lt;- in( B11 )  Freq: 0.999993
0c0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c0     ld  R18, [R23, #288]	# ptr, #@loadP
0c4 +   andi  R7, R29, #-8	#@andL_reg_imm
0c8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c8     ld  R28, [R23, #304]	# ptr, #@loadP
0cc +   add R7, R18, R7	# ptr, #@addP_reg_reg
0d0 +   bgeu  R7, R28, B28	#@cmpP_branch  P=0.000100 C=-1.000000

0d4     B13: #	out( B14 ) &lt;- in( B12 )  Freq: 0.999893
0d4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0d4     sd  R7, [R23, #288]	# ptr, #@storeP
0d8 +   li R7, #1	# long, #@loadConL
0dc +   sd  R7, [R18]	# long, #@storeL
0e0 +   mv  R7, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0f0 +   sw  R7, [R18, #8]	# compressed klass ptr, #@storeNKlass
0f4 +   sw  R30, [R18, #12]	# int, #@storeI

0f8     B14: #	out( B30 B15 ) &lt;- in( B29 B13 )  Freq: 0.999994
0f8     
0f8 +   srli  R7, R29, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
0fc +   # checkcastPP of R18, #@checkCastPP
0fc     addi  R11, R18, #16	# ptr, #@addP_reg_imm
100 +   encode_heap_oop  R20, R18	#@encodeHeapOop
104 +   beq  R8, zr, B30	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

108     B15: #	out( B21 B16 ) &lt;- in( B14 )  Freq: 0.999993
108 +   spill [sp, #8] -&gt; R28	# spill size = 32
10c +   addw  R28, R28, zr	#@convI2L_reg_reg
110     spill [sp, #0] -&gt; R29	# spill size = 64
114 +   add R28, R29, R28	# ptr, #@addP_reg_reg
118 +   addi  R10, R28, #16	# ptr, #@addP_reg_imm
11c +   addw  R12, R8, zr	#@convI2L_reg_reg
120     spill [sp, #12] -&gt; R29	# spill size = 32
124 +   blt  R8, R29, B21	#@cmpI_branch  P=0.001000 C=-1.000000

128     B16: #	out( B17 ) &lt;- in( B15 B21 )  Freq: 0.999993
128 +   CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

12c     B17: #	out( B18 B18 ) &lt;- in( B16 B30 )  Freq: 0.999994
12c     MEMBAR-store-store	#@membar_storestore
130 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
130     lb  R28, [R23, #56]	# byte, #@loadB
134 +   bne  R28, zr, B18	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

138     B18: #	out( B20 B19 ) &lt;- in( B17 B17 )  Freq: 0.999994
138 +   mv  R7, R9	# ptr -&gt; long, #@castP2X
13c +   mv  R28, R18	# ptr -&gt; long, #@castP2X
140 +   xorr  R28, R28, R7	#@xorL_reg_reg
144 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
148 +   sw  R20, [R9, #20]	# compressed ptr, #@storeN ! Field: java/lang/String.value (constant)
14c +   beq  R28, zr, B20	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

150     B19: #	out( B22 B20 ) &lt;- in( B18 )  Freq: 0.998994
150 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
154 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
160 +   add R10, R28, R7	# ptr, #@addP_reg_reg
164 +   lb  R7, [R10]	# byte, #@loadB
168 +   li R29, #4	# int, #@loadConI
16c +   bne  R7, R29, B22	#@cmpI_branch  P=0.001000 C=-1.000000

170     B20: #	out( N1 ) &lt;- in( B24 B25 B22 B19 B18 )  Freq: 0.999994
170 +   sb zr, [R9, #16]	# byte, #@storeimmB0 ! Field: java/lang/String.coder (constant)
174 +   #@membar_release
	fence iorw ow
178 +   #@membar_release
	fence iorw ow
178 +   spill R9 -&gt; R10	# spill size = 64
17c +   # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
194 +   ret	// return register, #@Ret

198     B21: #	out( B16 ) &lt;- in( B15 )  Freq: 0.000999993
198 +   addi  R28, R12, #16	#@addL_reg_imm
19c +   srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
1a0 +   andi  R28, R28, #-8	#@andL_reg_imm
1a4 +   add R28, R18, R28	# ptr, #@addP_reg_reg
1a8 +   sub  R29, R7, R29	#@subL_reg_reg
1ac +   ClearArray R29, R28	#@clearArray_reg_reg
204     j  B16	#@branch

208     B22: #	out( B20 B23 ) &lt;- in( B19 )  Freq: 0.000998994
208 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
208     ld  R7, [R23, #64]	# int, #@loadL
20c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
20c     ld  R28, [R23, #80]	# ptr, #@loadP
210 +   #@membar_volatile
	fence iorw iorw
214 +   lb  R29, [R10]	# byte, #@loadB
218 +   beq  R29, zr, B20	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

21c     B23: #	out( B25 B24 ) &lt;- in( B22 )  Freq: 0.000499497
21c +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
220 +   bne  R7, zr, B25	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

224     B24: #	out( B20 ) &lt;- in( B23 )  Freq: 0.000249749
224 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
224     spill R23 -&gt; R11	# spill size = 64
228 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
258 +   j  B20	#@branch

25c     B25: #	out( B20 ) &lt;- in( B23 )  Freq: 0.000249749
25c +   add R28, R28, R7	# ptr, #@addP_reg_reg
260 +   addi  R7, R7, #-8	#@addL_reg_imm
264 +   sd  R10, [R28, #-8]	# ptr, #@storeP
268 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
268     sd  R7, [R23, #64]	# long, #@storeL
26c +   j  B20	#@branch

270     B26: #	out( B36 B27 ) &lt;- in( B2 )  Freq: 0.000100017
270 +   mv  R11, precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# ptr, #@loadConP
288     spill R13 -&gt; R8	# spill size = 32
28c     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.lang.StringLatin1::newString @ bci:7 (line 769) L[0]=sp + #0 L[1]=sp + #8 L[2]=R8
        # OopMap {[0]=Oop off=656/0x290}

290     B27: #	out( B4 ) &lt;- in( B26 )  Freq: 0.000100015
        # Block is sole successor of call
290 +   spill R10 -&gt; R9	# spill size = 64
294 +   j  B4	#@branch

298     B28: #	out( B35 B29 ) &lt;- in( B11 B12 )  Freq: 0.000101029
298 +   spill R29 -&gt; [sp, #32]	# spill size = 64
29c +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
2b4     spill R30 -&gt; R12	# spill size = 32
2b8 +   spill R9 -&gt; [sp, #24]	# spill size = 64
2bc +   spill R9 -&gt; [sp, #40]	# spill size = 64
2c0     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # java.util.Arrays::copyOfRange @ bci:41 (line 3822) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=sp + #12 L[4]=_
        # java.lang.StringLatin1::newString @ bci:16 (line 769) L[0]=_ L[1]=_ L[2]=_ STK[0]=sp + #24 STK[1]=sp + #40
        # OopMap {[0]=Oop [24]=Oop [40]=Oop off=708/0x2c4}

2c4     B29: #	out( B14 ) &lt;- in( B28 )  Freq: 0.000101027
        # Block is sole successor of call
2c4 +   spill R10 -&gt; R18	# spill size = 64
2c8 +   spill [sp, #32] -&gt; R29	# spill size = 64
2cc +   spill [sp, #24] -&gt; R9	# spill size = 64
2d0 +   j  B14	#@branch

2d4     B30: #	out( B17 ) &lt;- in( B14 )  Freq: 1.01327e-06
2d4 +   spill R11 -&gt; R28	# spill size = 64
2d8 +   addi  R29, R7, #-2	#@addL_reg_imm
2dc     ClearArray R29, R28	#@clearArray_reg_reg
334     
334 +   j  B17	#@branch

338     B31: #	out( N1 ) &lt;- in( B7 B8 B9 B10 )  Freq: 3.99999e-06
338 +   spill [sp, #0] -&gt; R8	# spill size = 64
33c +   li R11, #-52	# int, #@loadConI
340     spill R29 -&gt; [sp, #0]	# spill size = 32
344 +   spill [sp, #12] -&gt; [sp, #4]	# spill size = 32
34c +   spill R9 -&gt; [sp, #24]	# spill size = 64
350     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # java.util.Arrays::copyOfRange @ bci:41 (line 3822) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=sp + #4 L[4]=_ STK[0]=sp + #4
        # java.lang.StringLatin1::newString @ bci:16 (line 769) L[0]=_ L[1]=_ L[2]=_ STK[0]=sp + #24 STK[1]=sp + #24
        # OopMap {fp=Oop [24]=Oop off=852/0x354}
354     #@ShouldNotReachHere

360     B32: #	out( N1 ) &lt;- in( B1 )  Freq: 4.76837e-07
360 +   spill [sp, #0] -&gt; R8	# spill size = 64
364 +   li R11, #-187	# int, #@loadConI
368     spill R12 -&gt; [sp, #0]	# spill size = 32
36c +   spill R13 -&gt; [sp, #8]	# spill size = 32
370     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::newString @ bci:1 (line 766) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 STK[0]=sp + #12
        # OopMap {fp=Oop off=884/0x374}
374     #@ShouldNotReachHere

380     B33: #	out( N1 ) &lt;- in( B4 )  Freq: 4.76837e-07
380 +   spill [sp, #12] -&gt; R7	# spill size = 32
384 +   spill [sp, #8] -&gt; R28	# spill size = 32
388 +   addw  R8, R28, R7	#@addI_reg_reg
38c +   li R11, #-187	# int, #@loadConI
390     spill R9 -&gt; [sp, #32]	# spill size = 64
394     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.Arrays::copyOfRange @ bci:5 (line 3820) L[0]=sp + #0 L[1]=sp + #8 L[2]=R8 L[3]=sp + #12 L[4]=_ STK[0]=sp + #12
        # java.lang.StringLatin1::newString @ bci:16 (line 769) L[0]=_ L[1]=_ L[2]=_ STK[0]=sp + #32 STK[1]=sp + #32
        # OopMap {[0]=Oop [32]=Oop off=920/0x398}
398     #@ShouldNotReachHere

3a4     B34: #	out( N1 ) &lt;- in( B6 )  Freq: 1.01328e-06
3a4 +   li R11, #-10	# int, #@loadConI
3a8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.Arrays::copyOfRange @ bci:51 (line 3823) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=_ STK[2]=_ STK[3]=_ STK[4]=#NULL
        # java.lang.StringLatin1::newString @ bci:16 (line 769) L[0]=_ L[1]=_ L[2]=_ STK[0]=_ STK[1]=_
        # OopMap {off=940/0x3ac}
3ac     #@ShouldNotReachHere

3b8     B35: #	out( B37 ) &lt;- in( B28 )  Freq: 1.01029e-09
3b8      -- 	// exception oop; no code emitted, #@CreateException
3b8 +   spill R10 -&gt; R11	# spill size = 64
3bc +   j  B37	#@branch

3c0     B36: #	out( B37 ) &lt;- in( B26 )  Freq: 1.00017e-09
3c0      -- 	// exception oop; no code emitted, #@CreateException
3c0 +   spill R10 -&gt; R11	# spill size = 64

3c4     B37: #	out( N1 ) &lt;- in( B36 B35 )  Freq: 2.01046e-09
3c4     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
3d0 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='312'>
----------------------- MetaData before Compile_id = 312 ------------------------
{method}
 - this oop:          0x00000040965e5990
 - method holder:     &apos;java/util/stream/ReferencePipeline$3$1&apos;
 - constants:         0x00000040965e55b8 constant pool [60] {0x00000040965e55b8} for &apos;java/util/stream/ReferencePipeline$3$1&apos; cache=0x00000040965e5a60
 - access:            0x81000001  public 
 - name:              &apos;accept&apos;
 - signature:         &apos;(Ljava/lang/Object;)V&apos;
 - max stack:         4
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      7
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bd00: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c4fad40
 - code size:         23
 - code start:        0x00000040965e5950
 - code end (excl):   0x00000040965e5967
 - method data:       0x0000004096481f18
 - checked ex length: 0
 - linenumber start:  0x00000040965e5967
 - localvar length:   2
 - localvar start:    0x00000040965e5974
 - compiled code: nmethod   8909  154       3       java.util.stream.ReferencePipeline$3$1::accept (23 bytes)

------------------------ OptoAssembly for Compile_id = 312 -----------------------
#
#  void ( java/util/stream/ReferencePipeline$3$1:NotNull *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/stream/ReferencePipeline$3$1:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 112 --
#r263 sp+108: in_preserve
#r262 sp+104: return address
#r261 sp+100: in_preserve
#r260 sp+96: saved fp register
#r259 sp+92: pad2, stack alignment
#r258 sp+88: pad2, stack alignment
#r257 sp+84: Fixed slot 1
#r256 sp+80: Fixed slot 0
#r283 sp+76: spill
#r282 sp+72: spill
#r281 sp+68: spill
#r280 sp+64: spill
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
0000    N5509: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0000    # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

0020    B1: #	out( B439 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0020    # stack bang size=112
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #112
	
003c    lwu  R7, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$3$1.this$1
0040 +  decode_heap_oop  R7, R7	#@decodeHeapOop
0044    lwu  R28, [R7, #52]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$3.val$mapper
0048    NullCheck R7

0048    B2: #	out( B506 B3 ) &lt;- in( B1 )  Freq: 0.999999
0048 +  lwu  R7, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/Sink$ChainedReference.downstream
004c +  decode_heap_oop  R11, R28	#@decodeHeapOop
0050 +  decode_heap_oop  R8, R7	#@decodeHeapOop
0054    CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.function.Function::apply
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:12 (line 197) L[0]=_ L[1]=_ STK[0]=R8
        # OopMap {fp=Oop off=112/0x70}

0070    B3: #	out( B440 B4 ) &lt;- in( B2 )  Freq: 0.999979
        # Block is sole successor of call
0070 +  spill R10 -&gt; [sp, #0]	# spill size = 64
0074    lwu  R7, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0078    NullCheck R8

0078    B4: #	out( B49 B5 ) &lt;- in( B3 )  Freq: 0.999978
0078 +  mv  R29, narrowklass: precise klass java/util/stream/ReferencePipeline$3$1: 0x00000040d8350400:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0088 +  beq  R7, R29, B49	#@cmpN_branch  P=0.666732 C=-1.000000

008c    B5: #	out( B342 B6 ) &lt;- in( B4 )  Freq: 0.333261
008c +  mv  R29, narrowklass: precise klass java/util/stream/ReferencePipeline$7$1: 0x00000040d8351160:Constant:exact *	# compressed klass ptr, #@loadConNKlass
009c +  far_bne  R7, R29, B342	#@far_cmpN_branch  P=0.000001 C=-1.000000

00a4    B6: #	out( B443 B7 ) &lt;- in( B5 )  Freq: 0.333261
00a4 +  # checkcastPP of R8, #@checkCastPP
00a4    lwu  R7, [R8, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$7$1.this$1
00a8 +  spill R8 -&gt; R29	# spill size = 64
00ac +  decode_heap_oop  R7, R7	#@decodeHeapOop
00b0    lwu  R28, [R7, #52]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$7.val$mapper
00b4    NullCheck R7

00b4    B7: #	out( B444 B8 ) &lt;- in( B6 )  Freq: 0.33326
00b4 +  decode_heap_oop  R8, R28	#@decodeHeapOop
00b8    lwu  R7, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
00bc    NullCheck R8

00bc    B8: #	out( B343 B9 ) &lt;- in( B7 )  Freq: 0.33326
00bc +  mv  R30, narrowklass: precise klass jdk/internal/module/ModulePath$$Lambda$10+0x000000080001e230: 0x00000040d81f3610:Constant:exact *	# compressed klass ptr, #@loadConNKlass
00cc +  far_bne  R7, R30, B343	#@far_cmpN_branch  P=0.000001 C=-1.000000

00d4    B9: #	out( B445 B10 ) &lt;- in( B8 )  Freq: 0.33326
00d4 +  spill R10 -&gt; R28	# spill size = 64
00d8    lwu  R7, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
00dc    NullCheck R10

00dc    B10: #	out( B428 B11 ) &lt;- in( B9 )  Freq: 0.333259
00dc +  mv  R30, narrowklass: precise klass java/util/Optional: 0x00000040d81f67e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
00ec +  far_bne  R7, R30, B428	#@far_cmpN_branch  P=0.000000 C=-1.000000

00f4    B11: #	out( B254 B12 ) &lt;- in( B10 )  Freq: 0.333259
00f4 +  # checkcastPP of R28, #@checkCastPP
00f4    lwu  R7, [R28, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/Optional.value
00f8 +  decode_heap_oop  R8, R7	#@decodeHeapOop
00fc    spill R7 -&gt; [sp, #8]	# spill size = 32
0100 +  far_beq   R8, zr, B254	#@far_cmpP_imm0_branch  P=0.004467 C=1791.000000

0108    B12: #	out( B304 B13 ) &lt;- in( B11 )  Freq: 0.331771
0108 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0108    ld  R30, [R23, #288]	# ptr, #@loadP
010c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
010c    ld  R7, [R23, #304]	# ptr, #@loadP
0110 +  addi  R28, R30, #24	# ptr, #@addP_reg_imm
0114 +  far_bgeu  R28, R7, B304	#@far_cmpP_branch  P=0.000100 C=-1.000000

011c    B13: #	out( B14 ) &lt;- in( B12 )  Freq: 0.331737
011c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
011c    sd  R28, [R23, #288]	# ptr, #@storeP
0120 +  li R7, #1	# long, #@loadConL
0124 +  mv  R28, narrowklass: precise klass java/util/stream/Streams$StreamBuilderImpl: 0x00000040d8403cd0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0134 +  sd  R7, [R30]	# long, #@storeL
0138 +  sw  R28, [R30, #8]	# compressed klass ptr, #@storeNKlass
013c +  sw  zr, [R30, #20]	# int, #@storeimmI0

0140    B14: #	out( B306 B15 ) &lt;- in( B305 B13 )  Freq: 0.331771
0140 +  li R28, #-2	# int, #@loadConI
0144 +  sw  R28, [R30, #12]	# int, #@storeI
0148    spill [sp, #8] -&gt; R7	# spill size = 32
014c +  sw  R7, [R30, #16]	# compressed ptr, #@storeN
0150    
0150 +  MEMBAR-store-store	#@membar_storestore
0154 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0154    ld  R10, [R23, #288]	# ptr, #@loadP
0158 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0158    ld  R7, [R23, #304]	# ptr, #@loadP
015c +  addi  R28, R10, #56	# ptr, #@addP_reg_imm
0160 +  # checkcastPP of R30, #@checkCastPP
0160    far_bgeu  R28, R7, B306	#@far_cmpP_branch  P=0.000100 C=-1.000000

0168    B15: #	out( B16 ) &lt;- in( B14 )  Freq: 0.331737
0168 +  li R7, #1	# long, #@loadConL
016c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
016c    sd  R28, [R23, #288]	# ptr, #@storeP
0170 +  sd  R7, [R10]	# long, #@storeL
0174 +  mv  R7, narrowklass: precise klass java/util/stream/ReferencePipeline$Head: 0x00000040d81f36e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0184 +  addi  R28, R10, #24	# ptr, #@addP_reg_imm
0188 +  sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
018c    ClearArray #2, R28	#@clearArray_imm_reg
0194 +  sw  zr, [R10, #44]	# int, #@storeimmI0
0198 +  sd  zr, [R10, #48]	# long, #@storeimmL0

019c    B16: #	out( B17 ) &lt;- in( B307 B15 )  Freq: 0.331771
019c +  li R28, #80	# int, #@loadConI
01a0 +  sw  R28, [R10, #12]	# int, #@storeI
01a4 +  li R7, #408021893120	# long, #@loadConL
01ac +  encode_heap_oop  R28, R30	#@encodeHeapOop
01b0 +  sd  R7, [R10, #16]	# long, #@storeL
01b4 +  sw  R28, [R10, #40]	# compressed ptr, #@storeN
01b8    
01b8 +  MEMBAR-store-store	#@membar_storestore
01bc +  # checkcastPP of R10, #@checkCastPP
01bc    encode_heap_oop  R7, R10	#@encodeHeapOop
01c0 +  sw  R7, [R10, #28]	# compressed ptr, #@storeN ! Field: java/util/stream/AbstractPipeline.sourceStage
01c4    spill R10 -&gt; R18	# spill size = 64
01c8 +  #@membar_release
	fence iorw ow
01cc +  # checkcastPP of R18, #@checkCastPP

01cc    B17: #	out( B430 B18 ) &lt;- in( B256 B16 )  Freq: 0.333259
01cc    lwu  R28, [R18, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
01d0 +  mv  R7, narrowklass: precise klass java/util/stream/ReferencePipeline$Head: 0x00000040d81f36e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
01e0 +  far_bne  R28, R7, B430	#@far_cmpN_branch  P=0.000000 C=-1.000000

01e8    B18: #	out( B353 B19 ) &lt;- in( B17 )  Freq: 0.333259
01e8 +  # checkcastPP of R18, #@checkCastPP
01e8    lwu  R28, [R18, #28]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceStage
01ec    spill R18 -&gt; R12	# spill size = 64
01f0 +  lbu  R8, [R29, #16]	# byte, #@loadUB ! Field: java/util/stream/ReferencePipeline$7$1.cancellationRequestedCalled
01f4 +  # checkcastPP of R12, #@checkCastPP
01f4    lwu  R7, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
01f8 +  decode_heap_oop  R28, R28	#@decodeHeapOop
01fc +  mv  R31, narrowklass: precise klass java/util/stream/ReferencePipeline$Head: 0x00000040d81f36e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
020c +  far_bne  R8, zr, B353	#@far_cmpI_reg_imm0_branch  P=0.000000 C=1791.000000

0214    B19: #	out( B446 B20 ) &lt;- in( B18 )  Freq: 0.333259
0214    sb zr, [R28, #26]	# byte, #@storeimmB0 ! Field: java/util/stream/AbstractPipeline.parallel
0218    NullCheck R28

0218    B20: #	out( B432 B21 ) &lt;- in( B19 )  Freq: 0.333259
0218 +  far_bne  R7, R31, B432	#@far_cmpN_branch  P=0.000000 C=-1.000000

0220    B21: #	out( B447 B22 ) &lt;- in( B20 )  Freq: 0.333259
0220 +  # checkcastPP of R12, #@checkCastPP
0220    lwu  R7, [R12, #28]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceStage
0224 +  decode_heap_oop  R31, R7	#@decodeHeapOop
0228    lbu  R13, [R31, #26]	# byte, #@loadUB ! Field: java/util/stream/AbstractPipeline.parallel
022c    NullCheck R31

022c    B22: #	out( B354 B23 ) &lt;- in( B21 )  Freq: 0.333258
022c +  lwu  R28, [R31, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceSpliterator
0230 +  lwu  R7, [R29, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/Sink$ChainedReference.downstream
0234 +  lbu  R10, [R12, #24]	# byte, #@loadUB ! Field: java/util/stream/AbstractPipeline.linkedOrConsumed
0238 +  decode_heap_oop  R19, R28	#@decodeHeapOop
023c +  decode_heap_oop  R30, R7	#@decodeHeapOop
0240 +  far_bne  R13, zr, B354	#@far_cmpI_reg_imm0_branch  P=0.000000 C=1791.000000

0248    B23: #	out( B363 B24 ) &lt;- in( B22 )  Freq: 0.333258
0248 +  far_bne  R12, R31, B363	#@far_cmpP_branch  P=0.000000 C=1791.000000

0250    B24: #	out( B364 B25 ) &lt;- in( B23 )  Freq: 0.333258
0250 +  far_bne  R10, zr, B364	#@far_cmpI_reg_imm0_branch  P=0.000000 C=1791.000000

0258    B25: #	out( B460 B26 ) &lt;- in( B24 )  Freq: 0.333258
0258 +  li R7, #1	# int, #@loadConI
025c +  sb  R7, [R12, #24]	# byte, #@storeB ! Field: java/util/stream/AbstractPipeline.linkedOrConsumed
0260    lwu  R9, [R19, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0264    NullCheck R19

0264    B26: #	out( B263 B27 ) &lt;- in( B25 )  Freq: 0.333258
0264 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0264    lb  R28, [R23, #56]	# byte, #@loadB
0268 +  far_bne  R28, zr, B263	#@far_cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0270    B27: #	out( B251 B28 ) &lt;- in( B355 B265 B263 B26 )  Freq: 0.333258
0270 +  mv  R7, narrowklass: precise klass java/util/stream/Streams$StreamBuilderImpl: 0x00000040d8403cd0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0280 +  sw  rheapbase, [R31, #40]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/util/stream/AbstractPipeline.sourceSpliterator
0284 +  far_bne  R9, R7, B251	#@far_cmpN_branch  P=0.004560 C=-1.000000

028c    B28: #	out( B461 B29 ) &lt;- in( B27 )  Freq: 0.331738
028c +  # checkcastPP of R19, #@checkCastPP
028c    lwu  R31, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0290    NullCheck R30

0290    B29: #	out( B358 B30 ) &lt;- in( B28 )  Freq: 0.331738
0290 +  lw  R8, [R19, #12]	# int, #@loadI ! Field: java/util/stream/Streams$AbstractStreamBuilderImpl.count
0294 +  li R10, #-2	# int, #@loadConI
0298 +  lwu  R29, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/Streams$StreamBuilderImpl.first
029c +  mv  R28, narrowklass: precise klass java/util/stream/ReduceOps$3ReducingSink: 0x00000040d827ab90:Constant:exact *	# compressed klass ptr, #@loadConNKlass
02ac +  far_bne  R8, R10, B358	#@far_cmpI_branch  P=0.000000 C=1748.000000

02b4    B30: #	out( B344 B31 ) &lt;- in( B29 )  Freq: 0.331738
02b4 +  decode_heap_oop  R7, R29	#@decodeHeapOop
02b8 +  far_bne  R31, R28, B344	#@far_cmpN_branch  P=0.000001 C=-1.000000

02c0    B31: #	out( B449 B32 ) &lt;- in( B30 )  Freq: 0.331737
02c0 +  # checkcastPP of R30, #@checkCastPP
02c0    lwu  R31, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReduceOps$3ReducingSink.val$accumulator
02c4 +  lwu  R28, [R30, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReduceOps$Box.state
02c8 +  decode_heap_oop  R31, R31	#@decodeHeapOop
02cc +  decode_heap_oop  R8, R28	#@decodeHeapOop
02d0    lwu  R30, [R31, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
02d4    NullCheck R31

02d4    B32: #	out( B345 B33 ) &lt;- in( B31 )  Freq: 0.331737
02d4 +  mv  R28, narrowklass: precise klass java/util/stream/Collectors$$Lambda$12+0x0000000800008ea8: 0x00000040d827c910:Constant:exact *	# compressed klass ptr, #@loadConNKlass
02e4 +  far_bne  R30, R28, B345	#@far_cmpN_branch  P=0.000001 C=-1.000000

02ec    B33: #	out( B450 B34 ) &lt;- in( B32 )  Freq: 0.331737
02ec    lwu  R30, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
02f0    NullCheck R8

02f0    B34: #	out( B434 B35 ) &lt;- in( B33 )  Freq: 0.331736
02f0 +  mv  R28, narrowklass: precise klass java/util/HashSet: 0x00000040d828fd70:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0300 +  far_bne  R30, R28, B434	#@far_cmpN_branch  P=0.000000 C=-1.000000

0308    B35: #	out( B341 B36 ) &lt;- in( B34 )  Freq: 0.331736
0308 +  # checkcastPP of R8, #@checkCastPP
0308    lwu  R30, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashSet.map
030c +  decode_heap_oop  R21, R30	#@decodeHeapOop
0310 +  far_beq   R21, zr, B341	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0318    B36: #	out( B462 B37 ) &lt;- in( B35 )  Freq: 0.331736
0318    lwu  R30, [R7, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
031c    NullCheck R7

031c    B37: #	out( B245 B38 ) &lt;- in( B36 )  Freq: 0.331736
031c +  mv  R28, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
032c +  far_bne  R30, R28, B245	#@far_cmpN_branch  P=0.019314 C=-1.000000

0334    B38: #	out( B40 B39 ) &lt;- in( B37 )  Freq: 0.325329
0334 +  spill R7 -&gt; R14	# spill size = 64
0338 +  # checkcastPP of R14, #@checkCastPP
0338    lw  R10, [R14, #12]	# int, #@loadI ! Field: java/lang/String.hash
033c +  beq  R10, zr, B40	#@cmpI_reg_imm0_branch  P=0.525856 C=5376.000000

0340    B39: #	out( B110 ) &lt;- in( B38 )  Freq: 0.154253
0340 +  li R28, #0	# int, #@loadConI
0344 +  j  B110	#@branch

0348    B40: #	out( B295 B41 ) &lt;- in( B38 )  Freq: 0.171076
0348 +  lbu  R28, [R14, #17]	# byte, #@loadUB ! Field: java/lang/String.hashIsZero
034c +  far_bne  R28, zr, B295	#@far_cmpI_reg_imm0_branch  P=0.001062 C=2826.000000

0354    B41: #	out( B398 B42 ) &lt;- in( B40 )  Freq: 0.170894
0354 +  lwu  R31, [R14, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0358 +  lb  R8, [R14, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
035c +  decode_heap_oop  R15, R31	#@decodeHeapOop
0360 +  far_bne  R8, zr, B398	#@far_cmpI_reg_imm0_branch  P=0.000000 C=42934.000000

0368    B42: #	out( B459 B43 ) &lt;- in( B41 )  Freq: 0.170894
0368    lwu  R13, [R15, #12]	# range, #@loadRange
036c    NullCheck R15

036c    B43: #	out( B232 B44 ) &lt;- in( B42 )  Freq: 0.170894
036c +  far_bleu  R13, zr, B232	#@far_cmpUEqNeLeGt_imm0_branch  P=0.056079 C=18260.000000

0374    B44: #	out( B359 B45 ) &lt;- in( B43 )  Freq: 0.16131
0374 +  addiw  R28, R13, #-1	#@addI_reg_imm
0378 +  far_bgeu R28, R13, B359	#@far_cmpU_branch  P=0.000001 C=-1.000000

0380    B45: #	out( B360 B46 ) &lt;- in( B44 )  Freq: 0.16131
0380 +  li R11, #1	# int, #@loadConI
0384 +  addiw  R28, R13, #-3	#@addI_reg_imm
0388 +  lbu  R10, [R15, #16]	# byte, #@loadUB
038c +  far_ble  R28, R11, B360	#@far_cmpI_branch  P=0.000001 C=-1.000000

0394    B46: #	out( B361 B47 ) &lt;- in( B45 )  Freq: 0.16131
0394 +  slliw  R11, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0398 +  li R31, #1	# int, #@loadConI
039c +  subw  R16, R11, R10	#@subI_reg_reg
03a0 +  far_bleu R13, R31, B361	#@far_cmpU_branch  P=0.000001 C=-1.000000

03a8    B47: #	out( B362 B48 ) &lt;- in( B46 )  Freq: 0.16131
03a8 +  li R10, #4	# int, #@loadConI
03ac +  far_bleu R13, R10, B362	#@far_cmpU_branch  P=0.000001 C=-1.000000

03b4    B48: #	out( B100 ) &lt;- in( B47 )  Freq: 0.16131
03b4 +  li R12, #1	# int, #@loadConI
03b8 +  li R31, #0	# int, #@loadConI
03bc +  j  B100	#@branch

03c0    B49: #	out( B441 B50 ) &lt;- in( B4 )  Freq: 0.666717
03c0 +  # checkcastPP of R8, #@checkCastPP
03c0    lwu  R7, [R8, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$3$1.this$1
03c4 +  decode_heap_oop  R7, R7	#@decodeHeapOop
03c8    lwu  R28, [R7, #52]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$3.val$mapper
03cc    NullCheck R7

03cc    B50: #	out( B503 B51 ) &lt;- in( B49 )  Freq: 0.666716
03cc +  lwu  R7, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/Sink$ChainedReference.downstream
03d0 +  decode_heap_oop  R11, R28	#@decodeHeapOop
03d4 +  decode_heap_oop  R8, R7	#@decodeHeapOop
03d8    spill R10 -&gt; R12	# spill size = 64
03dc    CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.function.Function::apply
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:12 (line 197) L[0]=_ L[1]=_ STK[0]=R8
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=1016/0x3f8}

03f8    B51: #	out( B442 B52 ) &lt;- in( B50 )  Freq: 0.666703
        # Block is sole successor of call
03f8 +  spill R10 -&gt; [sp, #0]	# spill size = 64
03fc +  spill R8 -&gt; R30	# spill size = 64
0400    lwu  R7, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0404    NullCheck R8

0404    B52: #	out( B97 B53 ) &lt;- in( B51 )  Freq: 0.666702
0404 +  mv  R29, narrowklass: precise klass java/util/stream/ReferencePipeline$3$1: 0x00000040d8350400:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0414 +  beq  R7, R29, B97	#@cmpN_branch  P=0.666732 C=-1.000000

0418    B53: #	out( B348 B54 ) &lt;- in( B52 )  Freq: 0.222191
0418 +  mv  R28, narrowklass: precise klass java/util/stream/ReferencePipeline$7$1: 0x00000040d8351160:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0428 +  far_bne  R7, R28, B348	#@far_cmpN_branch  P=0.000001 C=-1.000000

0430    B54: #	out( B451 B55 ) &lt;- in( B53 )  Freq: 0.22219
0430 +  # checkcastPP of R30, #@checkCastPP
0430    lwu  R28, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$7$1.this$1
0434 +  decode_heap_oop  R7, R28	#@decodeHeapOop
0438    lwu  R7, [R7, #52]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$7.val$mapper
043c    NullCheck R7

043c    B55: #	out( B452 B56 ) &lt;- in( B54 )  Freq: 0.22219
043c +  decode_heap_oop  R8, R7	#@decodeHeapOop
0440    lwu  R28, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0444    NullCheck R8

0444    B56: #	out( B349 B57 ) &lt;- in( B55 )  Freq: 0.22219
0444 +  mv  R7, narrowklass: precise klass jdk/internal/module/ModulePath$$Lambda$10+0x000000080001e230: 0x00000040d81f3610:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0454 +  far_bne  R28, R7, B349	#@far_cmpN_branch  P=0.000001 C=-1.000000

045c    B57: #	out( B453 B58 ) &lt;- in( B56 )  Freq: 0.22219
045c +  spill R10 -&gt; R29	# spill size = 64
0460    lwu  R28, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0464    NullCheck R10

0464    B58: #	out( B427 B59 ) &lt;- in( B57 )  Freq: 0.22219
0464 +  mv  R7, narrowklass: precise klass java/util/Optional: 0x00000040d81f67e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0474 +  far_bne  R28, R7, B427	#@far_cmpN_branch  P=0.000000 C=-1.000000

047c    B59: #	out( B260 B60 ) &lt;- in( B58 )  Freq: 0.22219
047c +  # checkcastPP of R29, #@checkCastPP
047c    lwu  R28, [R29, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/Optional.value
0480 +  decode_heap_oop  R8, R28	#@decodeHeapOop
0484    spill R28 -&gt; [sp, #8]	# spill size = 32
0488 +  far_beq   R8, zr, B260	#@far_cmpP_imm0_branch  P=0.004467 C=1791.000000

0490    B60: #	out( B315 B61 ) &lt;- in( B59 )  Freq: 0.221197
0490 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0490    ld  R29, [R23, #288]	# ptr, #@loadP
0494 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0494    ld  R7, [R23, #304]	# ptr, #@loadP
0498 +  addi  R28, R29, #24	# ptr, #@addP_reg_imm
049c +  far_bgeu  R28, R7, B315	#@far_cmpP_branch  P=0.000100 C=-1.000000

04a4    B61: #	out( B62 ) &lt;- in( B60 )  Freq: 0.221175
04a4 +  li R7, #1	# long, #@loadConL
04a8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
04a8    sd  R28, [R23, #288]	# ptr, #@storeP
04ac +  sd  R7, [R29]	# long, #@storeL
04b0 +  mv  R7, narrowklass: precise klass java/util/stream/Streams$StreamBuilderImpl: 0x00000040d8403cd0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
04c0 +  sw  R7, [R29, #8]	# compressed klass ptr, #@storeNKlass
04c4 +  sw  zr, [R29, #20]	# int, #@storeimmI0

04c8    B62: #	out( B317 B63 ) &lt;- in( B316 B61 )  Freq: 0.221197
04c8 +  li R28, #-2	# int, #@loadConI
04cc +  sw  R28, [R29, #12]	# int, #@storeI
04d0    spill [sp, #8] -&gt; R7	# spill size = 32
04d4 +  sw  R7, [R29, #16]	# compressed ptr, #@storeN
04d8    
04d8 +  MEMBAR-store-store	#@membar_storestore
04dc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
04dc    ld  R10, [R23, #288]	# ptr, #@loadP
04e0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
04e0    ld  R7, [R23, #304]	# ptr, #@loadP
04e4 +  addi  R28, R10, #56	# ptr, #@addP_reg_imm
04e8 +  # checkcastPP of R29, #@checkCastPP
04e8    far_bgeu  R28, R7, B317	#@far_cmpP_branch  P=0.000100 C=-1.000000

04f0    B63: #	out( B64 ) &lt;- in( B62 )  Freq: 0.221175
04f0 +  li R7, #1	# long, #@loadConL
04f4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
04f4    sd  R28, [R23, #288]	# ptr, #@storeP
04f8 +  sd  R7, [R10]	# long, #@storeL
04fc +  mv  R7, narrowklass: precise klass java/util/stream/ReferencePipeline$Head: 0x00000040d81f36e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
050c +  addi  R28, R10, #24	# ptr, #@addP_reg_imm
0510 +  sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
0514    ClearArray #2, R28	#@clearArray_imm_reg
051c +  sw  zr, [R10, #44]	# int, #@storeimmI0
0520 +  sd  zr, [R10, #48]	# long, #@storeimmL0

0524    B64: #	out( B65 ) &lt;- in( B318 B63 )  Freq: 0.221197
0524 +  li R28, #80	# int, #@loadConI
0528 +  li R7, #408021893120	# long, #@loadConL
0530 +  sw  R28, [R10, #12]	# int, #@storeI
0534 +  sd  R7, [R10, #16]	# long, #@storeL
0538 +  encode_heap_oop  R7, R29	#@encodeHeapOop
053c +  sw  R7, [R10, #40]	# compressed ptr, #@storeN
0540    
0540 +  MEMBAR-store-store	#@membar_storestore
0544 +  # checkcastPP of R10, #@checkCastPP
0544    encode_heap_oop  R28, R10	#@encodeHeapOop
0548 +  sw  R28, [R10, #28]	# compressed ptr, #@storeN ! Field: java/util/stream/AbstractPipeline.sourceStage
054c    spill R10 -&gt; R19	# spill size = 64
0550 +  #@membar_release
	fence iorw ow
0554 +  # checkcastPP of R19, #@checkCastPP

0554    B65: #	out( B429 B66 ) &lt;- in( B262 B64 )  Freq: 0.22219
0554    lwu  R7, [R19, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0558 +  mv  R29, narrowklass: precise klass java/util/stream/ReferencePipeline$Head: 0x00000040d81f36e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0568 +  far_bne  R7, R29, B429	#@far_cmpN_branch  P=0.000000 C=-1.000000

0570    B66: #	out( B378 B67 ) &lt;- in( B65 )  Freq: 0.22219
0570 +  # checkcastPP of R19, #@checkCastPP
0570    lwu  R7, [R19, #28]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceStage
0574    spill R19 -&gt; R10	# spill size = 64
0578 +  lbu  R8, [R30, #16]	# byte, #@loadUB ! Field: java/util/stream/ReferencePipeline$7$1.cancellationRequestedCalled
057c +  # checkcastPP of R10, #@checkCastPP
057c    lwu  R29, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0580 +  decode_heap_oop  R7, R7	#@decodeHeapOop
0584 +  mv  R28, narrowklass: precise klass java/util/stream/ReferencePipeline$Head: 0x00000040d81f36e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0594 +  far_bne  R8, zr, B378	#@far_cmpI_reg_imm0_branch  P=0.000000 C=1791.000000

059c    B67: #	out( B454 B68 ) &lt;- in( B66 )  Freq: 0.222189
059c    sb zr, [R7, #26]	# byte, #@storeimmB0 ! Field: java/util/stream/AbstractPipeline.parallel
05a0    NullCheck R7

05a0    B68: #	out( B431 B69 ) &lt;- in( B67 )  Freq: 0.222189
05a0 +  far_bne  R29, R28, B431	#@far_cmpN_branch  P=0.000000 C=-1.000000

05a8    B69: #	out( B455 B70 ) &lt;- in( B68 )  Freq: 0.222189
05a8 +  # checkcastPP of R10, #@checkCastPP
05a8    lwu  R28, [R10, #28]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceStage
05ac +  decode_heap_oop  R31, R28	#@decodeHeapOop
05b0    lbu  R12, [R31, #26]	# byte, #@loadUB ! Field: java/util/stream/AbstractPipeline.parallel
05b4    NullCheck R31

05b4    B70: #	out( B379 B71 ) &lt;- in( B69 )  Freq: 0.222189
05b4 +  lwu  R7, [R31, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceSpliterator
05b8 +  lwu  R29, [R30, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/Sink$ChainedReference.downstream
05bc +  lbu  R28, [R10, #24]	# byte, #@loadUB ! Field: java/util/stream/AbstractPipeline.linkedOrConsumed
05c0 +  decode_heap_oop  R9, R7	#@decodeHeapOop
05c4 +  decode_heap_oop  R29, R29	#@decodeHeapOop
05c8 +  far_bne  R12, zr, B379	#@far_cmpI_reg_imm0_branch  P=0.000000 C=1791.000000

05d0    B71: #	out( B388 B72 ) &lt;- in( B70 )  Freq: 0.222189
05d0 +  far_bne  R10, R31, B388	#@far_cmpP_branch  P=0.000000 C=1791.000000

05d8    B72: #	out( B389 B73 ) &lt;- in( B71 )  Freq: 0.222189
05d8 +  far_bne  R28, zr, B389	#@far_cmpI_reg_imm0_branch  P=0.000000 C=1791.000000

05e0    B73: #	out( B466 B74 ) &lt;- in( B72 )  Freq: 0.222189
05e0 +  li R7, #1	# int, #@loadConI
05e4 +  sb  R7, [R10, #24]	# byte, #@storeB ! Field: java/util/stream/AbstractPipeline.linkedOrConsumed
05e8    lwu  R18, [R9, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
05ec    NullCheck R9

05ec    B74: #	out( B279 B75 ) &lt;- in( B73 )  Freq: 0.222189
05ec +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
05ec    lb  R7, [R23, #56]	# byte, #@loadB
05f0 +  far_bne  R7, zr, B279	#@far_cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

05f8    B75: #	out( B257 B76 ) &lt;- in( B380 B281 B279 B74 )  Freq: 0.222189
05f8 +  mv  R28, narrowklass: precise klass java/util/stream/Streams$StreamBuilderImpl: 0x00000040d8403cd0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0608 +  sw  rheapbase, [R31, #40]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/util/stream/AbstractPipeline.sourceSpliterator
060c +  far_bne  R18, R28, B257	#@far_cmpN_branch  P=0.004560 C=-1.000000

0614    B76: #	out( B467 B77 ) &lt;- in( B75 )  Freq: 0.221175
0614 +  # checkcastPP of R9, #@checkCastPP
0614    lwu  R28, [R29, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0618    NullCheck R29

0618    B77: #	out( B383 B78 ) &lt;- in( B76 )  Freq: 0.221175
0618 +  lw  R8, [R9, #12]	# int, #@loadI ! Field: java/util/stream/Streams$AbstractStreamBuilderImpl.count
061c +  li R31, #-2	# int, #@loadConI
0620 +  lwu  R30, [R9, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/Streams$StreamBuilderImpl.first
0624 +  mv  R10, narrowklass: precise klass java/util/stream/ReduceOps$3ReducingSink: 0x00000040d827ab90:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0634 +  far_bne  R8, R31, B383	#@far_cmpI_branch  P=0.000000 C=1748.000000

063c    B78: #	out( B350 B79 ) &lt;- in( B77 )  Freq: 0.221175
063c +  decode_heap_oop  R7, R30	#@decodeHeapOop
0640 +  far_bne  R28, R10, B350	#@far_cmpN_branch  P=0.000001 C=-1.000000

0648    B79: #	out( B457 B80 ) &lt;- in( B78 )  Freq: 0.221175
0648 +  # checkcastPP of R29, #@checkCastPP
0648    lwu  R28, [R29, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReduceOps$3ReducingSink.val$accumulator
064c +  lwu  R31, [R29, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReduceOps$Box.state
0650 +  decode_heap_oop  R29, R28	#@decodeHeapOop
0654 +  decode_heap_oop  R8, R31	#@decodeHeapOop
0658    lwu  R28, [R29, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
065c    NullCheck R29

065c    B80: #	out( B351 B81 ) &lt;- in( B79 )  Freq: 0.221175
065c +  mv  R31, narrowklass: precise klass java/util/stream/Collectors$$Lambda$12+0x0000000800008ea8: 0x00000040d827c910:Constant:exact *	# compressed klass ptr, #@loadConNKlass
066c +  far_bne  R28, R31, B351	#@far_cmpN_branch  P=0.000001 C=-1.000000

0674    B81: #	out( B458 B82 ) &lt;- in( B80 )  Freq: 0.221174
0674    lwu  R28, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0678    NullCheck R8

0678    B82: #	out( B433 B83 ) &lt;- in( B81 )  Freq: 0.221174
0678 +  mv  R31, narrowklass: precise klass java/util/HashSet: 0x00000040d828fd70:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0688 +  far_bne  R28, R31, B433	#@far_cmpN_branch  P=0.000000 C=-1.000000

0690    B83: #	out( B347 B84 ) &lt;- in( B82 )  Freq: 0.221174
0690 +  # checkcastPP of R8, #@checkCastPP
0690    lwu  R28, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashSet.map
0694 +  decode_heap_oop  R20, R28	#@decodeHeapOop
0698 +  far_beq   R20, zr, B347	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

06a0    B84: #	out( B468 B85 ) &lt;- in( B83 )  Freq: 0.221174
06a0    lwu  R31, [R7, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
06a4    NullCheck R7

06a4    B85: #	out( B249 B86 ) &lt;- in( B84 )  Freq: 0.221174
06a4 +  mv  R28, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
06b4 +  bne  R31, R28, B249	#@cmpN_branch  P=0.019314 C=-1.000000

06b8    B86: #	out( B88 B87 ) &lt;- in( B85 )  Freq: 0.216902
06b8 +  spill R7 -&gt; R29	# spill size = 64
06bc +  # checkcastPP of R29, #@checkCastPP
06bc    lw  R10, [R29, #12]	# int, #@loadI ! Field: java/lang/String.hash
06c0 +  beq  R10, zr, B88	#@cmpI_reg_imm0_branch  P=0.525856 C=5376.000000

06c4    B87: #	out( B160 ) &lt;- in( B86 )  Freq: 0.102843
06c4 +  li R18, #0	# int, #@loadConI
06c8 +  j  B160	#@branch

06cc    B88: #	out( B296 B89 ) &lt;- in( B86 )  Freq: 0.114059
06cc +  lbu  R10, [R29, #17]	# byte, #@loadUB ! Field: java/lang/String.hashIsZero
06d0 +  far_bne  R10, zr, B296	#@far_cmpI_reg_imm0_branch  P=0.001062 C=2826.000000

06d8    B89: #	out( B410 B90 ) &lt;- in( B88 )  Freq: 0.113938
06d8 +  lwu  R28, [R29, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
06dc +  lb  R8, [R29, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
06e0 +  decode_heap_oop  R14, R28	#@decodeHeapOop
06e4 +  far_bne  R8, zr, B410	#@far_cmpI_reg_imm0_branch  P=0.000000 C=42934.000000

06ec    B90: #	out( B465 B91 ) &lt;- in( B89 )  Freq: 0.113938
06ec    lwu  R8, [R14, #12]	# range, #@loadRange
06f0    NullCheck R14

06f0    B91: #	out( B247 B92 ) &lt;- in( B90 )  Freq: 0.113938
06f0 +  bleu  R8, zr, B247	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.056079 C=18260.000000

06f4    B92: #	out( B384 B93 ) &lt;- in( B91 )  Freq: 0.107548
06f4 +  addiw  R10, R8, #-1	#@addI_reg_imm
06f8 +  far_bgeu R10, R8, B384	#@far_cmpU_branch  P=0.000001 C=-1.000000

0700    B93: #	out( B385 B94 ) &lt;- in( B92 )  Freq: 0.107548
0700 +  li R11, #1	# int, #@loadConI
0704 +  addiw  R13, R8, #-3	#@addI_reg_imm
0708 +  lbu  R10, [R14, #16]	# byte, #@loadUB
070c +  far_ble  R13, R11, B385	#@far_cmpI_branch  P=0.000001 C=-1.000000

0714    B94: #	out( B386 B95 ) &lt;- in( B93 )  Freq: 0.107548
0714 +  slliw  R28, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0718 +  subw  R28, R28, R10	#@subI_reg_reg
071c +  li R10, #1	# int, #@loadConI
0720 +  far_bleu R8, R10, B386	#@far_cmpU_branch  P=0.000001 C=-1.000000

0728    B95: #	out( B387 B96 ) &lt;- in( B94 )  Freq: 0.107548
0728 +  li R11, #4	# int, #@loadConI
072c +  far_bleu R8, R11, B387	#@far_cmpU_branch  P=0.000001 C=-1.000000

0734    B96: #	out( B150 ) &lt;- in( B95 )  Freq: 0.107548
0734 +  li R11, #1	# int, #@loadConI
0738 +  li R15, #0	# int, #@loadConI
073c +  j  B150	#@branch

0740    B97: #	out( B504 B98 ) &lt;- in( B52 )  Freq: 0.444512
0740 +  spill R8 -&gt; R11	# spill size = 64
0744 +  # checkcastPP of R11, #@checkCastPP
0744    spill R10 -&gt; R12	# spill size = 64
0748    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.stream.ReferencePipeline$3$1::accept
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {off=1868/0x74c}

074c    B98: #	out( N5509 ) &lt;- in( B97 B197 B147 )  Freq: 0.999938
074c    # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0764 +  ret	// return register, #@Ret

0768    B99: #	out( B100 ) &lt;- in( B102 ) top-of-loop Freq: 2.71517
0768 +  spill R9 -&gt; R31	# spill size = 32
076c +  spill R17 -&gt; R29	# spill size = 32
0774 +  spill R20 -&gt; R7	# spill size = 64
0778 +  spill R22 -&gt; R30	# spill size = 32

0780    B100: #	out( B101 ) &lt;- in( B48 B99 ) Loop( B100-B99 ) Freq: 2.87648
0780 +  subw  R10, R13, R12	#@subI_reg_reg
0784 +  addiw  R11, R10, #-3	#@addI_reg_imm
0788    CMove R11, (R28 lt R12), R11, R31	#@cmovI_cmpI
	
0790 +  li R9, #4000	# int, #@loadConI
0798 +  li R10, #4000	# int, #@loadConI
07a0    CMove R11, (R11 gtu R10), R11, R9	#@cmovI_cmpU
	
07a8 +  addw  R11, R11, R12	#@addI_reg_reg
07ac    spill R31 -&gt; R9	# spill size = 32
07b0 +  spill R29 -&gt; R17	# spill size = 32
07b8 +  spill R7 -&gt; R20	# spill size = 64
07bc +  spill R30 -&gt; R22	# spill size = 32
        nop 	# 6 bytes pad for loops and calls

07d0    B101: #	out( B101 B102 ) &lt;- in( B100 B101 ) Loop( B101-B101 inner main of N1057 strip mined) Freq: 51.2935
07d0 +  addw  R7, R12, zr	#@convI2L_reg_reg
07d4 +  add R24, R15, R7	# ptr, #@addP_reg_reg
07d8 +  lbu  R7, [R24, #16]	# byte, #@loadUB
07dc +  addw  R7, R16, R7	#@addI_reg_reg
07e0 +  lbu  R29, [R24, #17]	# byte, #@loadUB
07e4 +  slliw  R31, R7, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
07e8 +  subw  R7, R31, R7	#@subI_reg_reg
07ec +  addw  R7, R7, R29	#@addI_reg_reg
07f0 +  lbu  R10, [R24, #18]	# byte, #@loadUB
07f4 +  slliw  R30, R7, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
07f8 +  subw  R29, R30, R7	#@subI_reg_reg
07fc +  addw  R7, R29, R10	#@addI_reg_reg
0800 +  lbu  R30, [R24, #19]	# byte, #@loadUB
0804 +  slliw  R31, R7, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0808 +  subw  R7, R31, R7	#@subI_reg_reg
080c +  addw  R10, R7, R30	#@addI_reg_reg
0810 +  slliw  R29, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0814 +  addiw  R12, R12, #4	#@addI_reg_imm
0818 +  subw  R16, R29, R10	#@subI_reg_reg
081c +  blt  R12, R11, B101	#@cmpI_loop  P=0.943921 C=17236.000000

0820    B102: #	out( B99 B103 ) &lt;- in( B101 )  Freq: 2.87648
0820 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0820    ld  R7, [R23, #920]	# ptr, #@loadP
0824 +  lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::hashCode @ bci:37 (line 196) L[0]=_ L[1]=R10 L[2]=R15 L[3]=R13 L[4]=R12 L[5]=_
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=R14 L[1]=_
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=R20 L[2]=#Ptr0x00000040d8292660 STK[0]=R21
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=R19 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R18 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {c_rarg4=Oop c_rarg5=Oop c_rarg7=NarrowOop x18=Oop x19=Oop esp=Oop xdispatch=Oop off=2084/0x824}
0828 +  blt  R12, R28, B99	#@cmpI_branch  P=0.943921 C=17236.000000

082c    B103: #	out( B104 ) &lt;- in( B102 )  Freq: 0.16131
082c +  spill R9 -&gt; R28	# spill size = 32
0830 +  spill R17 -&gt; R29	# spill size = 32
0838 +  spill R20 -&gt; R7	# spill size = 64
083c +  spill R22 -&gt; R30	# spill size = 32

0844    B104: #	out( B108 B105 ) &lt;- in( B360 B103 )  Freq: 0.16131
0844 +  bge  R12, R13, B108	#@cmpI_branch  P=0.500000 C=-1.000000

0848    B105: #	out( B400 B106 ) &lt;- in( B104 )  Freq: 0.080655
0848 +  # castII of R12, #@castII
0848    far_bgeu R12, R13, B400	#@far_cmpU_branch  P=0.000001 C=-1.000000

0850    B106: #	out( B401 B107 ) &lt;- in( B105 )  Freq: 0.0806549
0850 +  spill R12 -&gt; R31	# spill size = 32
0854 +  # castII of R31, #@castII
0854    far_bgeu R31, R13, B401	#@far_cmpU_branch  P=0.000001 C=-1.000000

085c    B107: #	out( B107 B108 ) &lt;- in( B106 B107 ) Loop( B107-B107 inner post of N3399) Freq: 0.16131
085c +  addw  R31, R12, zr	#@convI2L_reg_reg
0860 +  add R31, R15, R31	# ptr, #@addP_reg_reg
0864 +  lbu  R11, [R31, #16]	# byte, #@loadUB
0868 +  slliw  R31, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
086c +  subw  R10, R31, R10	#@subI_reg_reg
0870 +  addiw  R12, R12, #1	#@addI_reg_imm
0874 +  addw  R10, R10, R11	#@addI_reg_reg
0878 +  blt  R12, R13, B107	#@cmpI_loop  P=0.500000 C=17236.000000

087c    B108: #	out( B233 B109 ) &lt;- in( B107 B104 )  Freq: 0.16131
087c +  beq  R10, zr, B233	#@cmpI_reg_imm0_branch  P=0.000354 C=2823.000000

0880    B109: #	out( B110 ) &lt;- in( B108 )  Freq: 0.161253
0880 +  sw  R10, [R14, #12]	# int, #@storeI ! Field: java/lang/String.hash

0884    B110: #	out( B229 B111 ) &lt;- in( B109 B233 B295 B39 B246 )  Freq: 0.331735
0884 +  lwu  R11, [R21, #36]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap.table
0888 +  srliw  R31, R10, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
088c +  decode_heap_oop  R22, R11	#@decodeHeapOop
0890 +  xorr  R20, R31, R10	#@xorI_reg_reg
0894 +  beq   R22, zr, B229	#@cmpP_imm0_branch  P=0.031876 C=2196.000000

0898    B111: #	out( B366 B112 ) &lt;- in( B110 )  Freq: 0.32116
0898 +  lwu  R31, [R22, #12]	# range, #@loadRange
089c +  far_bleu  R31, zr, B366	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000000 C=2126.000000

08a4    B112: #	out( B346 B113 ) &lt;- in( B231 B111 )  Freq: 0.331734
08a4 +  addiw  R11, R31, #-1	#@addI_reg_imm
08a8 +  andr  R10, R11, R20	#@andI_reg_reg
08ac +  addw  R11, R10, zr	#@convI2L_reg_reg
08b0 +  slli  R11, R11, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
08b4 +  add R11, R22, R11	# ptr, #@addP_reg_reg
08b8 +  addi  R24, R11, #16	# ptr, #@addP_reg_imm
08bc +  far_ble  R31, zr, B346	#@far_cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

08c4    B113: #	out( B199 B114 ) &lt;- in( B112 )  Freq: 0.331734
08c4 +  lwu  R31, [R24]	# loadN, compressed ptr, #@loadN
08c8 +  decode_heap_oop  R9, R31	#@decodeHeapOop
08cc +  beq   R9, zr, B199	#@cmpP_imm0_branch  P=0.112477 C=2196.000000

08d0    B114: #	out( B130 B115 ) &lt;- in( B113 )  Freq: 0.294422
08d0 +  lw  R10, [R9, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
08d4 +  beq  R10, R20, B130	#@cmpI_branch  P=0.523345 C=1949.000000

08d8    B115: #	out( B371 B116 ) &lt;- in( B114 )  Freq: 0.140337
08d8 +  lwu  R10, [R9, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
08dc +  lwu  R31, [R9, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
08e0 +  mv  R11, narrowklass: precise klass java/util/HashMap$TreeNode: 0x00000040d81cb1b0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
08f0 +  decode_heap_oop  R24, R10	#@decodeHeapOop
08f4 +  far_beq  R31, R11, B371	#@far_cmpN_branch  P=0.000001 C=-1.000000

08fc    B116: #	out( B221 B117 ) &lt;- in( B115 )  Freq: 0.140337
08fc +  beq   R24, zr, B221	#@cmpP_imm0_branch  P=0.083176 C=1058.000000

0900    B117: #	out( B118 ) &lt;- in( B116 )  Freq: 0.128665
0900 +  li R9, #0	# int, #@loadConI

0904    B118: #	out( B217 B119 ) &lt;- in( B117 B218 ) Loop( B118-B218 inner ) Freq: 0.146531
0904 +  lw  R31, [R24, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
0908 +  bne  R31, R20, B217	#@cmpI_branch  P=0.132990 C=970.000000

090c    B119: #	out( B408 B120 ) &lt;- in( B118 )  Freq: 0.127044
090c +  lwu  R10, [R24, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
0910 +  decode_heap_oop  R12, R10	#@decodeHeapOop
0914 +  far_beq  R10, R29, B408	#@far_cmpN_branch  P=0.000000 C=841.000000

091c    B120: #	out( B373 B121 ) &lt;- in( B119 )  Freq: 0.127044
091c +  mv  R31, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
092c +  far_bne  R30, R31, B373	#@far_cmpN_branch  P=0.000001 C=-1.000000

0934    B121: #	out( B129 B122 ) &lt;- in( B120 )  Freq: 0.127044
0934 +  spill R7 -&gt; R15	# spill size = 64
0938 +  # checkcastPP of R15, #@checkCastPP
0938    beq  R15, R12, B129	#@cmpP_branch  P=0.064818 C=5338.000000

093c    B122: #	out( B464 B123 ) &lt;- in( B121 )  Freq: 0.118809
093c    lwu  R7, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0940    NullCheck R12

0940    B123: #	out( B438 B124 ) &lt;- in( B122 )  Freq: 0.118809
0940 +  mv  R29, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0950 +  lwu  R31, [R15, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0954 +  lb  R30, [R15, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0958 +  far_bne  R7, R29, B438	#@far_cmpN_branch  P=0.000000 C=-1.000000

0960    B124: #	out( B409 B125 ) &lt;- in( B123 )  Freq: 0.118809
0960 +  # checkcastPP of R12, #@checkCastPP
0960    lb  R8, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0964 +  lwu  R7, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0968 +  decode_heap_oop  R29, R31	#@decodeHeapOop
096c +  far_bne  R30, R8, B409	#@far_cmpI_branch  P=0.000000 C=4992.000000

0974    B125: #	out( B374 B126 ) &lt;- in( B124 )  Freq: 0.118809
0974 +  far_beq   R29, zr, B374	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

097c    B126: #	out( B375 B127 ) &lt;- in( B125 )  Freq: 0.118809
097c +  decode_heap_oop  R7, R7	#@decodeHeapOop
0980 +  lwu  R14, [R29, #12]	# range, #@loadRange
0984 +  far_beq   R7, zr, B375	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

098c    B127: #	out( B377 B128 ) &lt;- in( B126 )  Freq: 0.118808
098c +  lwu  R31, [R7, #12]	# range, #@loadRange
0990 +  far_bne  R14, R31, B377	#@far_cmpI_branch  P=0.000001 C=-1.000000

0998    B128: #	out( B376 B129 ) &lt;- in( B127 )  Freq: 0.118808
0998 +  addi  R13, R7, #16	# ptr, #@addP_reg_imm
099c +  addi  R11, R29, #16	# ptr, #@addP_reg_imm
09a0    String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
0a30 +  far_beq  R10, zr, B376	#@far_cmpI_reg_imm0_branch  P=0.000000 C=841.000000

0a38    B129: #	out( B140 ) &lt;- in( B121 B128 )  Freq: 0.127043
0a38 +  spill R24 -&gt; R9	# spill size = 64
0a3c +  j  B140	#@branch

0a40    B130: #	out( B406 B131 ) &lt;- in( B114 )  Freq: 0.154084
0a40 +  lwu  R31, [R9, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
0a44 +  decode_heap_oop  R10, R31	#@decodeHeapOop
0a48 +  far_beq  R31, R29, B406	#@far_cmpN_branch  P=0.000000 C=1020.000000

0a50    B131: #	out( B365 B132 ) &lt;- in( B130 )  Freq: 0.154084
0a50 +  mv  R31, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0a60 +  far_bne  R30, R31, B365	#@far_cmpN_branch  P=0.000001 C=-1.000000

0a68    B132: #	out( B140 B133 ) &lt;- in( B131 )  Freq: 0.154084
0a68 +  spill R7 -&gt; R12	# spill size = 64
0a6c +  # checkcastPP of R12, #@checkCastPP
0a6c    beq  R12, R10, B140	#@cmpP_branch  P=0.064818 C=5338.000000

0a70    B133: #	out( B463 B134 ) &lt;- in( B132 )  Freq: 0.144096
0a70    lwu  R29, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0a74    NullCheck R10

0a74    B134: #	out( B437 B135 ) &lt;- in( B133 )  Freq: 0.144096
0a74 +  lwu  R7, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0a78 +  lb  R30, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0a7c +  far_bne  R29, R31, B437	#@far_cmpN_branch  P=0.000000 C=-1.000000

0a84    B135: #	out( B407 B136 ) &lt;- in( B134 )  Freq: 0.144096
0a84 +  # checkcastPP of R10, #@checkCastPP
0a84    lb  R8, [R10, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0a88 +  lwu  R29, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0a8c +  decode_heap_oop  R7, R7	#@decodeHeapOop
0a90 +  far_bne  R30, R8, B407	#@far_cmpI_branch  P=0.000000 C=4992.000000

0a98    B136: #	out( B367 B137 ) &lt;- in( B135 )  Freq: 0.144096
0a98 +  far_beq   R7, zr, B367	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0aa0    B137: #	out( B368 B138 ) &lt;- in( B136 )  Freq: 0.144096
0aa0 +  decode_heap_oop  R29, R29	#@decodeHeapOop
0aa4 +  lwu  R14, [R7, #12]	# range, #@loadRange
0aa8 +  far_beq   R29, zr, B368	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0ab0    B138: #	out( B370 B139 ) &lt;- in( B137 )  Freq: 0.144096
0ab0 +  lwu  R30, [R29, #12]	# range, #@loadRange
0ab4 +  far_bne  R14, R30, B370	#@far_cmpI_branch  P=0.000001 C=-1.000000

0abc    B139: #	out( B369 B140 ) &lt;- in( B138 )  Freq: 0.144096
0abc +  addi  R13, R29, #16	# ptr, #@addP_reg_imm
0ac0 +  addi  R11, R7, #16	# ptr, #@addP_reg_imm
0ac4    String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
0b54 +  far_beq  R10, zr, B369	#@far_cmpI_reg_imm0_branch  P=0.000000 C=1020.000000

0b5c    B140: #	out( B272 B141 ) &lt;- in( B132 B139 B129 )  Freq: 0.281126
0b5c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0b5c    lb  R7, [R23, #56]	# byte, #@loadB
0b60 +  bne  R7, zr, B272	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0b64    B141: #	out( B143 B142 ) &lt;- in( B372 B274 B272 B140 )  Freq: 0.281126
0b64 +  mv  R28, java/lang/Object:exact *	# ptr, #@loadConP
0b7c +  mv  R7, R9	# ptr -&gt; long, #@castP2X
0b80 +  mv  R28, R28	# ptr -&gt; long, #@castP2X
0b80 +  xorr  R28, R28, R7	#@xorL_reg_reg
0b84 +  mv  R29, narrowoop: java/lang/Object:exact *	# compressed ptr, #@loadConN
0b94 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0b98 +  sw  R29, [R9, #20]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.value
0b9c +  beq  R28, zr, B143	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0ba0    B142: #	out( B275 B143 ) &lt;- in( B141 )  Freq: 0.280845
0ba0 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0ba4 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
0bb0 +  add R10, R28, R7	# ptr, #@addP_reg_reg
0bb4 +  lb  R28, [R10]	# byte, #@loadB
0bb8 +  li R29, #4	# int, #@loadConI
0bbc +  bne  R28, R29, B275	#@cmpI_branch  P=0.001000 C=-1.000000

0bc0    B143: #	out( B144 ) &lt;- in( B277 B278 B275 B142 B141 B207 B205 )  Freq: 0.331732
0bc0 +  li R28, #-1	# int, #@loadConI
0bc4 +  sw  R28, [R19, #12]	# int, #@storeI ! Field: java/util/stream/Streams$AbstractStreamBuilderImpl.count

0bc8    B144: #	out( B266 B145 ) &lt;- in( B143 B252 )  Freq: 0.333252
0bc8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0bc8    lb  R28, [R23, #56]	# byte, #@loadB
0bcc +  bne  R28, zr, B266	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0bd0    B145: #	out( B269 B146 ) &lt;- in( B356 B268 B266 B144 )  Freq: 0.333252
0bd0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0bd0    lb  R7, [R23, #56]	# byte, #@loadB
0bd4 +  lwu  R9, [R18, #28]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceStage
0bd8 +  bne  R7, zr, B269	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0bdc    B146: #	out( B448 B147 ) &lt;- in( B357 B271 B269 B145 )  Freq: 0.333252
0bdc +  li R28, #1	# int, #@loadConI
0be0 +  decode_heap_oop  R7, R9	#@decodeHeapOop
0be4 +  sb  R28, [R18, #24]	# byte, #@storeB ! Field: java/util/stream/AbstractPipeline.linkedOrConsumed
0be8 +  sw  rheapbase, [R18, #44]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/util/stream/AbstractPipeline.sourceSupplier
0bec +  sw  rheapbase, [R18, #40]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/util/stream/AbstractPipeline.sourceSpliterator
0bf0    lwu  R28, [R7, #48]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceCloseAction
0bf4    NullCheck R7

0bf4    B147: #	out( B98 B148 ) &lt;- in( B146 )  Freq: 0.333251
0bf4 +  decode_heap_oop  R8, R28	#@decodeHeapOop
0bf8 +  beq   R8, zr, B98	#@cmpP_imm0_branch  P=1.000000 C=1791.000000

0bfc    B148: #	out( N5509 ) &lt;- in( B147 )  Freq: 1.58907e-07
0bfc +  li R11, #-187	# int, #@loadConI
0c00    spill R18 -&gt; [sp, #0]	# spill size = 64
0c04    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.AbstractPipeline::close @ bci:22 (line 320) L[0]=sp + #0 L[1]=_ STK[0]=R8
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:94 (line 283) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=3080/0xc08}
0c08    #@ShouldNotReachHere

0c14    B149: #	out( B150 ) &lt;- in( B152 ) top-of-loop Freq: 1.81025
0c14 +  spill R16 -&gt; R7	# spill size = 64
0c18 +  spill R17 -&gt; R29	# spill size = 64

0c1c    B150: #	out( B151 ) &lt;- in( B96 B149 ) Loop( B150-B149 ) Freq: 1.9178
0c1c +  subw  R12, R8, R11	#@subI_reg_reg
0c20 +  addiw  R10, R12, #-3	#@addI_reg_imm
0c24    CMove R10, (R13 lt R11), R10, R15	#@cmovI_cmpI
	
0c2c +  li R17, #4000	# int, #@loadConI
0c34 +  li R12, #4000	# int, #@loadConI
0c3c    CMove R10, (R10 gtu R12), R10, R17	#@cmovI_cmpU
	
0c44 +  addw  R12, R10, R11	#@addI_reg_reg
0c48    spill R7 -&gt; R16	# spill size = 64
0c4c +  spill R29 -&gt; R17	# spill size = 64

0c50    B151: #	out( B151 B152 ) &lt;- in( B150 B151 ) Loop( B151-B151 inner main of N670 strip mined) Freq: 34.1983
0c50 +  addw  R7, R11, zr	#@convI2L_reg_reg
0c54 +  add R18, R14, R7	# ptr, #@addP_reg_reg
0c58 +  lbu  R29, [R18, #16]	# byte, #@loadUB
0c5c +  addw  R7, R28, R29	#@addI_reg_reg
0c60 +  lbu  R10, [R18, #17]	# byte, #@loadUB
0c64 +  slliw  R28, R7, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0c68 +  subw  R7, R28, R7	#@subI_reg_reg
0c6c +  addw  R7, R7, R10	#@addI_reg_reg
0c70 +  lbu  R29, [R18, #18]	# byte, #@loadUB
0c74 +  slliw  R28, R7, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0c78 +  subw  R7, R28, R7	#@subI_reg_reg
0c7c +  addw  R28, R7, R29	#@addI_reg_reg
0c80 +  lbu  R18, [R18, #19]	# byte, #@loadUB
0c84 +  slliw  R7, R28, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0c88 +  subw  R28, R7, R28	#@subI_reg_reg
0c8c +  addw  R10, R28, R18	#@addI_reg_reg
0c90 +  slliw  R7, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0c94 +  addiw  R11, R11, #4	#@addI_reg_imm
0c98 +  subw  R28, R7, R10	#@subI_reg_reg
0c9c +  blt  R11, R12, B151	#@cmpI_loop  P=0.943921 C=17236.000000

0ca0    B152: #	out( B149 B153 ) &lt;- in( B151 )  Freq: 1.9178
0ca0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0ca0    ld  R7, [R23, #920]	# ptr, #@loadP
0ca4 +  lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::hashCode @ bci:37 (line 196) L[0]=_ L[1]=R10 L[2]=R14 L[3]=R8 L[4]=R11 L[5]=_
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=R17 L[1]=_
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=R16 L[2]=#Ptr0x00000040d8292660 STK[0]=R20
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=R9 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R19 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {x30=NarrowOop c_rarg4=Oop c_rarg6=Oop c_rarg7=Oop x9=Oop x19=Oop esp=Oop off=3236/0xca4}
0ca8 +  blt  R11, R13, B149	#@cmpI_branch  P=0.943921 C=17236.000000

0cac    B153: #	out( B154 ) &lt;- in( B152 )  Freq: 0.107548
0cac +  spill R15 -&gt; R18	# spill size = 32
0cb0 +  spill R16 -&gt; R7	# spill size = 64
0cb4 +  spill R17 -&gt; R29	# spill size = 64

0cb8    B154: #	out( B158 B155 ) &lt;- in( B385 B153 )  Freq: 0.107548
0cb8 +  bge  R11, R8, B158	#@cmpI_branch  P=0.500000 C=-1.000000

0cbc    B155: #	out( B411 B156 ) &lt;- in( B154 )  Freq: 0.0537741
0cbc +  # castII of R11, #@castII
0cbc    far_bgeu R11, R8, B411	#@far_cmpU_branch  P=0.000001 C=-1.000000

0cc4    B156: #	out( B412 B157 ) &lt;- in( B155 )  Freq: 0.053774
0cc4 +  spill R11 -&gt; R12	# spill size = 32
0cc8 +  # castII of R12, #@castII
0cc8    far_bgeu R12, R8, B412	#@far_cmpU_branch  P=0.000001 C=-1.000000

0cd0    B157: #	out( B157 B158 ) &lt;- in( B156 B157 ) Loop( B157-B157 inner post of N3410) Freq: 0.107548
0cd0 +  addw  R28, R11, zr	#@convI2L_reg_reg
0cd4 +  add R28, R14, R28	# ptr, #@addP_reg_reg
0cd8 +  slliw  R13, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0cdc +  lbu  R28, [R28, #16]	# byte, #@loadUB
0ce0 +  subw  R10, R13, R10	#@subI_reg_reg
0ce4 +  addiw  R11, R11, #1	#@addI_reg_imm
0ce8 +  addw  R10, R10, R28	#@addI_reg_reg
0cec +  blt  R11, R8, B157	#@cmpI_loop  P=0.500000 C=17236.000000

0cf0    B158: #	out( B248 B159 ) &lt;- in( B157 B154 )  Freq: 0.107548
0cf0 +  beq  R10, zr, B248	#@cmpI_reg_imm0_branch  P=0.000354 C=2823.000000

0cf4    B159: #	out( B160 ) &lt;- in( B158 )  Freq: 0.10751
0cf4 +  sw  R10, [R29, #12]	# int, #@storeI ! Field: java/lang/String.hash

0cf8    B160: #	out( B242 B161 ) &lt;- in( B159 B248 B296 B87 B250 )  Freq: 0.221173
0cf8 +  lwu  R28, [R20, #36]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap.table
0cfc +  srliw  R11, R10, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
0d00 +  decode_heap_oop  R22, R28	#@decodeHeapOop
0d04 +  xorr  R21, R11, R10	#@xorI_reg_reg
0d08 +  beq   R22, zr, B242	#@cmpP_imm0_branch  P=0.031876 C=2196.000000

0d0c    B161: #	out( B391 B162 ) &lt;- in( B160 )  Freq: 0.214123
0d0c +  lwu  R28, [R22, #12]	# range, #@loadRange
0d10 +  far_bleu  R28, zr, B391	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000000 C=2126.000000

0d18    B162: #	out( B352 B163 ) &lt;- in( B244 B161 )  Freq: 0.221173
0d18 +  addiw  R29, R28, #-1	#@addI_reg_imm
0d1c +  andr  R29, R29, R21	#@andI_reg_reg
0d20 +  addw  R10, R29, zr	#@convI2L_reg_reg
0d24 +  slli  R10, R10, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0d28 +  add R10, R22, R10	# ptr, #@addP_reg_reg
0d2c +  addi  R25, R10, #16	# ptr, #@addP_reg_imm
0d30 +  far_ble  R28, zr, B352	#@far_cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0d38    B163: #	out( B208 B164 ) &lt;- in( B162 )  Freq: 0.221173
0d38 +  lwu  R10, [R25]	# loadN, compressed ptr, #@loadN
0d3c +  decode_heap_oop  R24, R10	#@decodeHeapOop
0d40 +  beq   R24, zr, B208	#@cmpP_imm0_branch  P=0.112477 C=2196.000000

0d44    B164: #	out( B180 B165 ) &lt;- in( B163 )  Freq: 0.196296
0d44 +  lw  R28, [R24, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
0d48 +  beq  R28, R21, B180	#@cmpI_branch  P=0.523345 C=1949.000000

0d4c    B165: #	out( B396 B166 ) &lt;- in( B164 )  Freq: 0.0935653
0d4c +  lwu  R28, [R24, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
0d50 +  lwu  R10, [R24, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0d54 +  decode_heap_oop  R12, R28	#@decodeHeapOop
0d58 +  mv  R28, narrowklass: precise klass java/util/HashMap$TreeNode: 0x00000040d81cb1b0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0d68 +  far_beq  R10, R28, B396	#@far_cmpN_branch  P=0.000001 C=-1.000000

0d70    B166: #	out( B235 B167 ) &lt;- in( B165 )  Freq: 0.0935652
0d70 +  beq   R12, zr, B235	#@cmpP_imm0_branch  P=0.083176 C=1058.000000

0d74    B167: #	out( B168 ) &lt;- in( B166 )  Freq: 0.0857829
0d74 +  li R28, #0	# int, #@loadConI

0d78    B168: #	out( B219 B169 ) &lt;- in( B167 B220 ) Loop( B168-B220 inner ) Freq: 0.0976946
0d78 +  lw  R10, [R12, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
0d7c +  bne  R10, R21, B219	#@cmpI_branch  P=0.132990 C=970.000000

0d80    B169: #	out( B415 B170 ) &lt;- in( B168 )  Freq: 0.0847022
0d80 +  lwu  R29, [R12, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
0d84 +  decode_heap_oop  R10, R29	#@decodeHeapOop
0d88 +  far_beq  R29, R30, B415	#@far_cmpN_branch  P=0.000000 C=841.000000

0d90    B170: #	out( B399 B171 ) &lt;- in( B169 )  Freq: 0.0847022
0d90 +  mv  R30, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0da0 +  far_bne  R31, R30, B399	#@far_cmpN_branch  P=0.000001 C=-1.000000

0da8    B171: #	out( B179 B172 ) &lt;- in( B170 )  Freq: 0.0847021
0da8 +  spill R7 -&gt; R15	# spill size = 64
0dac +  # checkcastPP of R15, #@checkCastPP
0dac    beq  R15, R10, B179	#@cmpP_branch  P=0.064818 C=5338.000000

0db0    B172: #	out( B470 B173 ) &lt;- in( B171 )  Freq: 0.0792119
0db0    lwu  R30, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0db4    NullCheck R10

0db4    B173: #	out( B436 B174 ) &lt;- in( B172 )  Freq: 0.0792118
0db4 +  mv  R7, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0dc4 +  lwu  R31, [R15, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0dc8 +  lb  R29, [R15, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0dcc +  far_bne  R30, R7, B436	#@far_cmpN_branch  P=0.000000 C=-1.000000

0dd4    B174: #	out( B416 B175 ) &lt;- in( B173 )  Freq: 0.0792118
0dd4 +  # checkcastPP of R10, #@checkCastPP
0dd4    lb  R8, [R10, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0dd8 +  lwu  R7, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0ddc +  decode_heap_oop  R30, R31	#@decodeHeapOop
0de0 +  far_bne  R29, R8, B416	#@far_cmpI_branch  P=0.000000 C=4992.000000

0de8    B175: #	out( B402 B176 ) &lt;- in( B174 )  Freq: 0.0792117
0de8 +  far_beq   R30, zr, B402	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0df0    B176: #	out( B403 B177 ) &lt;- in( B175 )  Freq: 0.0792117
0df0 +  decode_heap_oop  R7, R7	#@decodeHeapOop
0df4 +  lwu  R14, [R30, #12]	# range, #@loadRange
0df8 +  far_beq   R7, zr, B403	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0e00    B177: #	out( B405 B178 ) &lt;- in( B176 )  Freq: 0.0792116
0e00 +  lwu  R29, [R7, #12]	# range, #@loadRange
0e04 +  far_bne  R14, R29, B405	#@far_cmpI_branch  P=0.000001 C=-1.000000

0e0c    B178: #	out( B404 B179 ) &lt;- in( B177 )  Freq: 0.0792115
0e0c +  addi  R13, R7, #16	# ptr, #@addP_reg_imm
0e10 +  addi  R11, R30, #16	# ptr, #@addP_reg_imm
0e14    String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
0ea4 +  far_beq  R10, zr, B404	#@far_cmpI_reg_imm0_branch  P=0.000000 C=841.000000

0eac    B179: #	out( B190 ) &lt;- in( B171 B178 )  Freq: 0.0847017
0eac +  spill R12 -&gt; R24	# spill size = 64
0eb0 +  j  B190	#@branch

0eb4    B180: #	out( B413 B181 ) &lt;- in( B164 )  Freq: 0.102731
0eb4 +  lwu  R29, [R24, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
0eb8 +  decode_heap_oop  R10, R29	#@decodeHeapOop
0ebc +  far_beq  R29, R30, B413	#@far_cmpN_branch  P=0.000000 C=1020.000000

0ec4    B181: #	out( B390 B182 ) &lt;- in( B180 )  Freq: 0.10273
0ec4 +  mv  R29, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0ed4 +  far_bne  R31, R29, B390	#@far_cmpN_branch  P=0.000001 C=-1.000000

0edc    B182: #	out( B190 B183 ) &lt;- in( B181 )  Freq: 0.10273
0edc +  spill R7 -&gt; R31	# spill size = 64
0ee0 +  # checkcastPP of R31, #@checkCastPP
0ee0    beq  R31, R10, B190	#@cmpP_branch  P=0.064818 C=5338.000000

0ee4    B183: #	out( B469 B184 ) &lt;- in( B182 )  Freq: 0.0960716
0ee4    lwu  R7, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0ee8    NullCheck R10

0ee8    B184: #	out( B435 B185 ) &lt;- in( B183 )  Freq: 0.0960715
0ee8 +  mv  R28, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0ef8 +  lwu  R29, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0efc +  lb  R30, [R31, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0f00 +  far_bne  R7, R28, B435	#@far_cmpN_branch  P=0.000000 C=-1.000000

0f08    B185: #	out( B414 B186 ) &lt;- in( B184 )  Freq: 0.0960715
0f08 +  # checkcastPP of R10, #@checkCastPP
0f08    lb  R8, [R10, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0f0c +  lwu  R28, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0f10 +  decode_heap_oop  R7, R29	#@decodeHeapOop
0f14 +  far_bne  R30, R8, B414	#@far_cmpI_branch  P=0.000000 C=4992.000000

0f1c    B186: #	out( B392 B187 ) &lt;- in( B185 )  Freq: 0.0960714
0f1c +  far_beq   R7, zr, B392	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0f24    B187: #	out( B393 B188 ) &lt;- in( B186 )  Freq: 0.0960713
0f24 +  decode_heap_oop  R28, R28	#@decodeHeapOop
0f28 +  lwu  R14, [R7, #12]	# range, #@loadRange
0f2c +  far_beq   R28, zr, B393	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0f34    B188: #	out( B395 B189 ) &lt;- in( B187 )  Freq: 0.0960712
0f34 +  lwu  R30, [R28, #12]	# range, #@loadRange
0f38 +  far_bne  R14, R30, B395	#@far_cmpI_branch  P=0.000001 C=-1.000000

0f40    B189: #	out( B394 B190 ) &lt;- in( B188 )  Freq: 0.0960711
0f40 +  addi  R13, R28, #16	# ptr, #@addP_reg_imm
0f44 +  addi  R11, R7, #16	# ptr, #@addP_reg_imm
0f48    String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
0fd8 +  far_beq  R10, zr, B394	#@far_cmpI_reg_imm0_branch  P=0.000000 C=1020.000000

0fe0    B190: #	out( B288 B191 ) &lt;- in( B182 B189 B179 )  Freq: 0.187432
0fe0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0fe0    lb  R28, [R23, #56]	# byte, #@loadB
0fe4 +  bne  R28, zr, B288	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0fe8    B191: #	out( B193 B192 ) &lt;- in( B397 B290 B288 B190 )  Freq: 0.187432
0fe8 +  mv  R28, java/lang/Object:exact *	# ptr, #@loadConP
1000 +  mv  R7, R24	# ptr -&gt; long, #@castP2X
1004 +  mv  R28, R28	# ptr -&gt; long, #@castP2X
1004 +  xorr  R28, R28, R7	#@xorL_reg_reg
1008 +  mv  R29, narrowoop: java/lang/Object:exact *	# compressed ptr, #@loadConN
1018 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
101c +  sw  R29, [R24, #20]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.value
1020 +  beq  R28, zr, B193	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1024    B192: #	out( B291 B193 ) &lt;- in( B191 )  Freq: 0.187244
1024 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1028 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1034 +  add R10, R28, R7	# ptr, #@addP_reg_reg
1038 +  lb  R7, [R10]	# byte, #@loadB
103c +  li R29, #4	# int, #@loadConI
1040 +  bne  R7, R29, B291	#@cmpI_branch  P=0.001000 C=-1.000000

1044    B193: #	out( B194 ) &lt;- in( B293 B294 B291 B192 B191 B216 B214 )  Freq: 0.221171
1044 +  li R28, #-1	# int, #@loadConI
1048 +  sw  R28, [R9, #12]	# int, #@storeI ! Field: java/util/stream/Streams$AbstractStreamBuilderImpl.count

104c    B194: #	out( B282 B195 ) &lt;- in( B193 B258 )  Freq: 0.222185
104c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
104c    lb  R7, [R23, #56]	# byte, #@loadB
1050 +  bne  R7, zr, B282	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1054    B195: #	out( B285 B196 ) &lt;- in( B381 B284 B282 B194 )  Freq: 0.222185
1054 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1054    lb  R28, [R23, #56]	# byte, #@loadB
1058 +  lwu  R18, [R19, #28]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceStage
105c +  bne  R28, zr, B285	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1060    B196: #	out( B456 B197 ) &lt;- in( B382 B287 B285 B195 )  Freq: 0.222185
1060 +  li R28, #1	# int, #@loadConI
1064 +  decode_heap_oop  R7, R18	#@decodeHeapOop
1068 +  sb  R28, [R19, #24]	# byte, #@storeB ! Field: java/util/stream/AbstractPipeline.linkedOrConsumed
106c +  sw  rheapbase, [R19, #44]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/util/stream/AbstractPipeline.sourceSupplier
1070 +  sw  rheapbase, [R19, #40]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/util/stream/AbstractPipeline.sourceSpliterator
1074    lwu  R7, [R7, #48]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceCloseAction
1078    NullCheck R7

1078    B197: #	out( B98 B198 ) &lt;- in( B196 )  Freq: 0.222184
1078 +  decode_heap_oop  R8, R7	#@decodeHeapOop
107c +  beq   R8, zr, B98	#@cmpP_imm0_branch  P=1.000000 C=1791.000000

1080    B198: #	out( N5509 ) &lt;- in( B197 )  Freq: 1.05946e-07
1080 +  li R11, #-187	# int, #@loadConI
1084    spill R19 -&gt; [sp, #0]	# spill size = 64
1088    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.AbstractPipeline::close @ bci:22 (line 320) L[0]=sp + #0 L[1]=_ STK[0]=R8
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:94 (line 283) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=4236/0x108c}
108c    #@ShouldNotReachHere

1098    B199: #	out( B333 B200 ) &lt;- in( B113 )  Freq: 0.0373125
1098 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1098    ld  R9, [R23, #288]	# ptr, #@loadP
109c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
109c    ld  R28, [R23, #304]	# ptr, #@loadP
10a0 +  addi  R30, R9, #32	# ptr, #@addP_reg_imm
10a4 +  bgeu  R30, R28, B333	#@cmpP_branch  P=0.000100 C=-1.000000

10a8    B200: #	out( B201 ) &lt;- in( B199 )  Freq: 0.0373088
10a8 +  li R7, #1	# long, #@loadConL
10ac +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
10ac    sd  R30, [R23, #288]	# ptr, #@storeP
10b0 +  sd  R7, [R9]	# long, #@storeL
10b4 +  mv  R7, narrowklass: precise klass java/util/HashMap$Node: 0x00000040d81c98a0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
10c4 +  sw  R7, [R9, #8]	# compressed klass ptr, #@storeNKlass
10c8 +  sw  zr, [R9, #12]	# int, #@storeimmI0
10cc +  sw  zr, [R9, #16]	# int, #@storeimmI0
10d0 +  sd  zr, [R9, #24]	# long, #@storeimmL0

10d4    B201: #	out( B417 B202 ) &lt;- in( B334 B200 )  Freq: 0.0373125
10d4 +  mv  R28, narrowoop: java/lang/Object:exact *	# compressed ptr, #@loadConN
10e4 +  sw  R28, [R9, #20]	# compressed ptr, #@storeN
10e8    
10e8 +  # checkcastPP of R9, #@checkCastPP
10e8    sw  R29, [R9, #16]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.key
10ec +  sw  R20, [R9, #12]	# int, #@storeI ! Field: java/util/HashMap$Node.hash
10f0 +  #@membar_release
	fence iorw ow
10f4 +  lwu  R28, [R22, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
10f8 +  mv  R7, narrowklass: precise klass [Ljava/util/HashMap$Node;: 0x00000040d81c9970:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1108 +  far_bne  R28, R7, B417	#@far_cmpN_branch  P=0.000001 C=-1.000000

1110    B202: #	out( B297 B203 ) &lt;- in( B201 )  Freq: 0.0373125
1110 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1110    lb  R28, [R23, #56]	# byte, #@loadB
1114 +  bne  R28, zr, B297	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1118    B203: #	out( B205 B204 ) &lt;- in( B419 B299 B297 B202 )  Freq: 0.0373125
1118 +  mv  R28, R24	# ptr -&gt; long, #@castP2X
111c +  mv  R7, R9	# ptr -&gt; long, #@castP2X
1120 +  xorr  R7, R7, R28	#@xorL_reg_reg
1124 +  encode_heap_oop  R29, R9	#@encodeHeapOop
1128 +  srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
112c +  sw  R29, [R24]	# compressed ptr, #@storeN
1130 +  beq  R7, zr, B205	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1134    B204: #	out( B300 B205 ) &lt;- in( B203 )  Freq: 0.0372752
1134 +  srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1138 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1144 +  add R10, R28, R7	# ptr, #@addP_reg_reg
1148 +  lb  R28, [R10]	# byte, #@loadB
114c +  li R7, #4	# int, #@loadConI
1150 +  bne  R28, R7, B300	#@cmpI_branch  P=0.001000 C=-1.000000

1154    B205: #	out( B143 B206 ) &lt;- in( B227 B302 B303 B300 B204 B203 )  Freq: 0.050606
1154 +  lw  R29, [R21, #24]	# int, #@loadI ! Field: java/util/HashMap.modCount
1158 +  lw  R7, [R21, #20]	# int, #@loadI ! Field: java/util/HashMap.size
115c +  addiw  R30, R29, #1	#@addI_reg_imm
1160 +  addiw  R7, R7, #1	#@addI_reg_imm
1164 +  lw  R28, [R21, #28]	# int, #@loadI ! Field: java/util/HashMap.threshold
1168 +  sw  R30, [R21, #24]	# int, #@storeI ! Field: java/util/HashMap.modCount
116c +  sw  R7, [R21, #20]	# int, #@storeI ! Field: java/util/HashMap.size
1170 +  ble  R7, R28, B143	#@cmpI_branch  P=0.952239 C=335.000000

1174    B206: #	out( B492 B207 ) &lt;- in( B205 )  Freq: 0.002417
1174 +  spill R19 -&gt; [sp, #8]	# spill size = 64
1178 +  spill R18 -&gt; [sp, #0]	# spill size = 64
117c +  spill R21 -&gt; R8	# spill size = 64
1180 +  spill R21 -&gt; R11	# spill size = 64
1184    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:288 (line 661) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=4488/0x1188}

1188    B207: #	out( B143 ) &lt;- in( B206 )  Freq: 0.00241696
        # Block is sole successor of call
1188 +  spill [sp, #0] -&gt; R18	# spill size = 64
118c +  spill [sp, #8] -&gt; R19	# spill size = 64
1190 +  j  B143	#@branch

1194    B208: #	out( B335 B209 ) &lt;- in( B163 )  Freq: 0.0248769
1194 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1194    ld  R18, [R23, #288]	# ptr, #@loadP
1198 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1198    ld  R28, [R23, #304]	# ptr, #@loadP
119c +  addi  R31, R18, #32	# ptr, #@addP_reg_imm
11a0 +  bgeu  R31, R28, B335	#@cmpP_branch  P=0.000100 C=-1.000000

11a4    B209: #	out( B210 ) &lt;- in( B208 )  Freq: 0.0248744
11a4 +  li R7, #1	# long, #@loadConL
11a8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
11a8    sd  R31, [R23, #288]	# ptr, #@storeP
11ac +  sd  R7, [R18]	# long, #@storeL
11b0 +  mv  R7, narrowklass: precise klass java/util/HashMap$Node: 0x00000040d81c98a0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
11c0 +  sw  R7, [R18, #8]	# compressed klass ptr, #@storeNKlass
11c4 +  sw  zr, [R18, #12]	# int, #@storeimmI0
11c8 +  sw  zr, [R18, #16]	# int, #@storeimmI0
11cc +  sd  zr, [R18, #24]	# long, #@storeimmL0

11d0    B210: #	out( B418 B211 ) &lt;- in( B336 B209 )  Freq: 0.0248769
11d0 +  mv  R28, narrowoop: java/lang/Object:exact *	# compressed ptr, #@loadConN
11e0 +  sw  R28, [R18, #20]	# compressed ptr, #@storeN
11e4    
11e4 +  # checkcastPP of R18, #@checkCastPP
11e4    sw  R30, [R18, #16]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.key
11e8 +  sw  R21, [R18, #12]	# int, #@storeI ! Field: java/util/HashMap$Node.hash
11ec +  #@membar_release
	fence iorw ow
11f0 +  lwu  R7, [R22, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
11f4 +  mv  R30, narrowklass: precise klass [Ljava/util/HashMap$Node;: 0x00000040d81c9970:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1204 +  far_bne  R7, R30, B418	#@far_cmpN_branch  P=0.000001 C=-1.000000

120c    B211: #	out( B308 B212 ) &lt;- in( B210 )  Freq: 0.0248769
120c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
120c    lb  R7, [R23, #56]	# byte, #@loadB
1210 +  bne  R7, zr, B308	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1214    B212: #	out( B214 B213 ) &lt;- in( B420 B310 B308 B211 )  Freq: 0.0248769
1214 +  mv  R28, R25	# ptr -&gt; long, #@castP2X
1218 +  mv  R7, R18	# ptr -&gt; long, #@castP2X
121c +  xorr  R7, R7, R28	#@xorL_reg_reg
1220 +  encode_heap_oop  R30, R18	#@encodeHeapOop
1224 +  srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
1228 +  sw  R30, [R25]	# compressed ptr, #@storeN
122c +  beq  R7, zr, B214	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1230    B213: #	out( B311 B214 ) &lt;- in( B212 )  Freq: 0.024852
1230 +  srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1234 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1240 +  add R10, R28, R7	# ptr, #@addP_reg_reg
1244 +  lb  R7, [R10]	# byte, #@loadB
1248 +  li R28, #4	# int, #@loadConI
124c +  bne  R7, R28, B311	#@cmpI_branch  P=0.001000 C=-1.000000

1250    B214: #	out( B193 B215 ) &lt;- in( B240 B313 B314 B311 B213 B212 )  Freq: 0.0337399
1250 +  lw  R7, [R20, #24]	# int, #@loadI ! Field: java/util/HashMap.modCount
1254 +  lw  R28, [R20, #20]	# int, #@loadI ! Field: java/util/HashMap.size
1258 +  addiw  R7, R7, #1	#@addI_reg_imm
125c +  addiw  R29, R28, #1	#@addI_reg_imm
1260 +  lw  R30, [R20, #28]	# int, #@loadI ! Field: java/util/HashMap.threshold
1264 +  sw  R7, [R20, #24]	# int, #@storeI ! Field: java/util/HashMap.modCount
1268 +  sw  R29, [R20, #20]	# int, #@storeI ! Field: java/util/HashMap.size
126c +  ble  R29, R30, B193	#@cmpI_branch  P=0.952239 C=335.000000

1270    B215: #	out( B491 B216 ) &lt;- in( B214 )  Freq: 0.00161146
1270 +  spill R20 -&gt; [sp, #8]	# spill size = 64
1274 +  spill R9 -&gt; [sp, #0]	# spill size = 64
1278 +  spill R19 -&gt; R8	# spill size = 64
127c +  spill R20 -&gt; R11	# spill size = 64
1280    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:288 (line 661) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=4740/0x1284}

1284    B216: #	out( B193 ) &lt;- in( B215 )  Freq: 0.00161143
        # Block is sole successor of call
1284 +  spill R8 -&gt; R19	# spill size = 64
1288 +  spill [sp, #0] -&gt; R9	# spill size = 64
128c +  j  B193	#@branch

1290    B217: #	out( B222 B218 ) &lt;- in( B118 )  Freq: 0.0194871
1290 +  addiw  R9, R9, #1	#@addI_reg_imm
1294 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1294    ld  R31, [R23, #920]	# ptr, #@loadP
1298 +  lwu zr, [R31]	# Safepoint: poll for GC, #@safePoint        # java.util.HashMap::putVal @ bci:219 (line 638) L[0]=R21 L[1]=R20 L[2]=R7 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=R22 L[7]=R24 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=R9
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=R19 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R18 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {t2=Oop x29=NarrowOop x18=Oop x19=Oop xdispatch=Oop xbcp=Oop xlocals=Oop off=4760/0x1298}
129c +  lwu  R31, [R24, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
12a0 +  decode_heap_oop  R31, R31	#@decodeHeapOop
12a4 +  beq   R31, zr, B222	#@cmpP_imm0_branch  P=0.083176 C=129.000000

12a8    B218: #	out( B118 ) &lt;- in( B217 )  Freq: 0.0178662
12a8 +  spill R31 -&gt; R24	# spill size = 64
12ac +  j  B118	#@branch

12b0    B219: #	out( B234 B220 ) &lt;- in( B168 )  Freq: 0.0129924
12b0 +  addiw  R28, R28, #1	#@addI_reg_imm
12b4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
12b4    ld  R15, [R23, #920]	# ptr, #@loadP
12b8 +  lwu zr, [R15]	# Safepoint: poll for GC, #@safePoint        # java.util.HashMap::putVal @ bci:219 (line 638) L[0]=R20 L[1]=R21 L[2]=R7 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=R22 L[7]=R12 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=R28
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=R9 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R19 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {t2=Oop x30=NarrowOop c_rarg2=Oop x9=Oop x19=Oop esp=Oop xbcp=Oop off=4792/0x12b8}
12bc +  lwu  R10, [R12, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
12c0 +  decode_heap_oop  R29, R10	#@decodeHeapOop
12c4 +  beq   R29, zr, B234	#@cmpP_imm0_branch  P=0.083176 C=129.000000

12c8    B220: #	out( B168 ) &lt;- in( B219 )  Freq: 0.0119117
12c8 +  spill R29 -&gt; R12	# spill size = 64
12cc +  j  B168	#@branch

12d0    B221: #	out( B222 ) &lt;- in( B116 )  Freq: 0.0116727
12d0 +  spill R9 -&gt; R28	# spill size = 64
12d4 +  li R9, #0	# int, #@loadConI
12d8    spill R28 -&gt; R24	# spill size = 64

12dc    B222: #	out( B337 B223 ) &lt;- in( B217 B221 )  Freq: 0.0132935
12dc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
12dc    ld  R25, [R23, #288]	# ptr, #@loadP
12e0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
12e0    ld  R28, [R23, #304]	# ptr, #@loadP
12e4 +  addi  R30, R25, #32	# ptr, #@addP_reg_imm
12e8 +  bgeu  R30, R28, B337	#@cmpP_branch  P=0.000100 C=-1.000000

12ec    B223: #	out( B224 ) &lt;- in( B222 )  Freq: 0.0132922
12ec +  li R7, #1	# long, #@loadConL
12f0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
12f0    sd  R30, [R23, #288]	# ptr, #@storeP
12f4 +  sd  R7, [R25]	# long, #@storeL
12f8 +  mv  R7, narrowklass: precise klass java/util/HashMap$Node: 0x00000040d81c98a0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1308 +  sw  R7, [R25, #8]	# compressed klass ptr, #@storeNKlass
130c +  sw  zr, [R25, #12]	# int, #@storeimmI0
1310 +  sw  zr, [R25, #16]	# int, #@storeimmI0
1314 +  sd  zr, [R25, #24]	# long, #@storeimmL0

1318    B224: #	out( B319 B225 ) &lt;- in( B338 B223 )  Freq: 0.0132935
1318 +  mv  R28, narrowoop: java/lang/Object:exact *	# compressed ptr, #@loadConN
1328 +  sw  R28, [R25, #20]	# compressed ptr, #@storeN
132c    
132c +  # checkcastPP of R25, #@checkCastPP
132c    sw  R29, [R25, #16]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.key
1330 +  sw  R20, [R25, #12]	# int, #@storeI ! Field: java/util/HashMap$Node.hash
1334 +  #@membar_release
	fence iorw ow
1338 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1338    lb  R28, [R23, #56]	# byte, #@loadB
133c +  bne  R28, zr, B319	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1340    B225: #	out( B227 B226 ) &lt;- in( B421 B321 B319 B224 )  Freq: 0.0132935
1340 +  mv  R28, R24	# ptr -&gt; long, #@castP2X
1344 +  mv  R7, R25	# ptr -&gt; long, #@castP2X
1348 +  xorr  R7, R7, R28	#@xorL_reg_reg
134c +  encode_heap_oop  R29, R25	#@encodeHeapOop
1350 +  srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
1354 +  sw  R29, [R24, #24]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.next
1358 +  beq  R7, zr, B227	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

135c    B226: #	out( B322 B227 ) &lt;- in( B225 )  Freq: 0.0132802
135c +  srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1360 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
136c +  add R10, R28, R7	# ptr, #@addP_reg_reg
1370 +  lb  R28, [R10]	# byte, #@loadB
1374 +  li R7, #4	# int, #@loadConI
1378 +  bne  R28, R7, B322	#@cmpI_branch  P=0.001000 C=-1.000000

137c    B227: #	out( B205 B228 ) &lt;- in( B324 B325 B322 B226 B225 )  Freq: 0.0132935
137c +  li R28, #7	# int, #@loadConI
1380 +  blt  R9, R28, B205	#@cmpI_branch  P=1.000000 C=88.000000

1384    B228: #	out( N5509 ) &lt;- in( B227 )  Freq: 6.33884e-09
1384 +  li R11, #-187	# int, #@loadConI
1388    spill R18 -&gt; R8	# spill size = 64
138c +  spill R19 -&gt; [sp, #0]	# spill size = 64
1390 +  spill R21 -&gt; [sp, #8]	# spill size = 64
1394 +  spill R20 -&gt; [sp, #16]	# spill size = 32
1398 +  spill R22 -&gt; [sp, #24]	# spill size = 64
139c +  spill R9 -&gt; [sp, #20]	# spill size = 32
13a0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:162 (line 641) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=_ STK[0]=sp + #20 STK[1]=#7
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop off=5028/0x13a4}
13a4    #@ShouldNotReachHere

13b0    B229: #	out( B498 B230 ) &lt;- in( B110 )  Freq: 0.0105744
13b0 +  spill R20 -&gt; [sp, #40]	# spill size = 32
13b4 +  spill R30 -&gt; [sp, #20]	# spill size = 32
13b8 +  spill R21 -&gt; [sp, #32]	# spill size = 64
13bc +  spill R7 -&gt; [sp, #24]	# spill size = 64
13c0 +  spill R29 -&gt; [sp, #16]	# spill size = 32
13c4 +  spill R19 -&gt; [sp, #8]	# spill size = 64
13c8 +  spill R18 -&gt; [sp, #0]	# spill size = 64
13cc +  spill R28 -&gt; R8	# spill size = 32
13d0 +  spill R21 -&gt; R11	# spill size = 64
13d4    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:20 (line 627) L[0]=sp + #32 L[1]=sp + #40 L[2]=sp + #24 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=NarrowOop [24]=Oop [32]=Oop off=5080/0x13d8}

13d8    B230: #	out( B471 B231 ) &lt;- in( B229 )  Freq: 0.0105742
        # Block is sole successor of call
13d8 +  spill R10 -&gt; R22	# spill size = 64
13dc    lwu  R31, [R10, #12]	# range, #@loadRange
13e0    NullCheck R10

13e0    B231: #	out( B112 ) &lt;- in( B230 )  Freq: 0.0105742
13e0 +  spill R8 -&gt; R28	# spill size = 32
13e4 +  spill [sp, #0] -&gt; R18	# spill size = 64
13e8 +  spill [sp, #8] -&gt; R19	# spill size = 64
13ec +  spill [sp, #16] -&gt; R29	# spill size = 32
13f0 +  spill [sp, #24] -&gt; R7	# spill size = 64
13f4 +  spill [sp, #32] -&gt; R21	# spill size = 64
13f8 +  spill [sp, #20] -&gt; R30	# spill size = 32
13fc +  spill [sp, #40] -&gt; R20	# spill size = 32
1400 +  j  B112	#@branch

1404    B232: #	out( B233 ) &lt;- in( B43 )  Freq: 0.00958354
1404 +  li R28, #0	# int, #@loadConI

1408    B233: #	out( B110 ) &lt;- in( B108 B232 )  Freq: 0.00964068
1408 +  li R31, #1	# int, #@loadConI
140c +  sb  R31, [R14, #17]	# byte, #@storeB ! Field: java/lang/String.hashIsZero
1410 +  li R10, #0	# int, #@loadConI
1414 +  j  B110	#@branch

1418    B234: #	out( B235 ) &lt;- in( B219 )  Freq: 0.00108065
1418 +  spill R28 -&gt; R18	# spill size = 32
141c +  spill R12 -&gt; R24	# spill size = 64

1420    B235: #	out( B339 B236 ) &lt;- in( B234 B166 )  Freq: 0.00886301
1420 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1420    ld  R25, [R23, #288]	# ptr, #@loadP
1424 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1424    ld  R28, [R23, #304]	# ptr, #@loadP
1428 +  addi  R29, R25, #32	# ptr, #@addP_reg_imm
142c +  bgeu  R29, R28, B339	#@cmpP_branch  P=0.000100 C=-1.000000

1430    B236: #	out( B237 ) &lt;- in( B235 )  Freq: 0.00886213
1430 +  li R7, #1	# long, #@loadConL
1434 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1434    sd  R29, [R23, #288]	# ptr, #@storeP
1438 +  sd  R7, [R25]	# long, #@storeL
143c +  mv  R7, narrowklass: precise klass java/util/HashMap$Node: 0x00000040d81c98a0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
144c +  sw  R7, [R25, #8]	# compressed klass ptr, #@storeNKlass
1450 +  sw  zr, [R25, #12]	# int, #@storeimmI0
1454 +  sw  zr, [R25, #16]	# int, #@storeimmI0
1458 +  sd  zr, [R25, #24]	# long, #@storeimmL0

145c    B237: #	out( B326 B238 ) &lt;- in( B340 B236 )  Freq: 0.00886301
145c +  mv  R28, narrowoop: java/lang/Object:exact *	# compressed ptr, #@loadConN
146c +  sw  R28, [R25, #20]	# compressed ptr, #@storeN
1470    
1470 +  # checkcastPP of R25, #@checkCastPP
1470    sw  R30, [R25, #16]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.key
1474 +  sw  R21, [R25, #12]	# int, #@storeI ! Field: java/util/HashMap$Node.hash
1478 +  #@membar_release
	fence iorw ow
147c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
147c    lb  R7, [R23, #56]	# byte, #@loadB
1480 +  bne  R7, zr, B326	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1484    B238: #	out( B240 B239 ) &lt;- in( B422 B328 B326 B237 )  Freq: 0.00886301
1484 +  mv  R28, R24	# ptr -&gt; long, #@castP2X
1488 +  mv  R7, R25	# ptr -&gt; long, #@castP2X
148c +  xorr  R7, R7, R28	#@xorL_reg_reg
1490 +  encode_heap_oop  R30, R25	#@encodeHeapOop
1494 +  srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
1498 +  sw  R30, [R24, #24]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.next
149c +  beq  R7, zr, B240	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

14a0    B239: #	out( B329 B240 ) &lt;- in( B238 )  Freq: 0.00885415
14a0 +  srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
14a4 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
14b0 +  add R10, R28, R7	# ptr, #@addP_reg_reg
14b4 +  lb  R7, [R10]	# byte, #@loadB
14b8 +  li R28, #4	# int, #@loadConI
14bc +  bne  R7, R28, B329	#@cmpI_branch  P=0.001000 C=-1.000000

14c0    B240: #	out( B214 B241 ) &lt;- in( B331 B332 B329 B239 B238 )  Freq: 0.00886301
14c0 +  li R28, #7	# int, #@loadConI
14c4 +  blt  R18, R28, B214	#@cmpI_branch  P=1.000000 C=88.000000

14c8    B241: #	out( N5509 ) &lt;- in( B240 )  Freq: 4.22621e-09
14c8 +  li R11, #-187	# int, #@loadConI
14cc    spill R18 -&gt; R8	# spill size = 32
14d0 +  spill R19 -&gt; [sp, #0]	# spill size = 64
14d4 +  spill R9 -&gt; [sp, #8]	# spill size = 64
14d8 +  spill R20 -&gt; [sp, #16]	# spill size = 64
14dc +  spill R21 -&gt; [sp, #24]	# spill size = 32
14e0 +  spill R22 -&gt; [sp, #32]	# spill size = 64
14e4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:162 (line 641) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=_ STK[0]=R8 STK[1]=#7
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [32]=Oop off=5352/0x14e8}
14e8    #@ShouldNotReachHere

14f4    B242: #	out( B493 B243 ) &lt;- in( B160 )  Freq: 0.00705015
14f4 +  spill R21 -&gt; [sp, #36]	# spill size = 32
14f8 +  spill R31 -&gt; [sp, #32]	# spill size = 32
14fc +  spill R20 -&gt; [sp, #24]	# spill size = 64
1500 +  spill R7 -&gt; [sp, #16]	# spill size = 64
1504 +  spill R30 -&gt; [sp, #4]	# spill size = 32
1508 +  spill R9 -&gt; [sp, #8]	# spill size = 64
150c +  spill R19 -&gt; R8	# spill size = 64
1510 +  spill R18 -&gt; [sp, #0]	# spill size = 32
1514 +  spill R20 -&gt; R11	# spill size = 64
1518    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:20 (line 627) L[0]=sp + #24 L[1]=sp + #36 L[2]=sp + #16 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop off=5404/0x151c}

151c    B243: #	out( B472 B244 ) &lt;- in( B242 )  Freq: 0.00705001
        # Block is sole successor of call
151c +  spill R10 -&gt; R22	# spill size = 64
1520    lwu  R28, [R10, #12]	# range, #@loadRange
1524    NullCheck R10

1524    B244: #	out( B162 ) &lt;- in( B243 )  Freq: 0.00705
1524 +  spill [sp, #0] -&gt; R18	# spill size = 32
1528 +  spill R8 -&gt; R19	# spill size = 64
152c +  spill [sp, #8] -&gt; R9	# spill size = 64
1530 +  spill [sp, #4] -&gt; R30	# spill size = 32
1534 +  spill [sp, #16] -&gt; R7	# spill size = 64
1538 +  spill [sp, #24] -&gt; R20	# spill size = 64
153c +  spill [sp, #32] -&gt; R31	# spill size = 32
1540 +  spill [sp, #36] -&gt; R21	# spill size = 32
1544 +  j  B162	#@branch

1548    B245: #	out( B500 B246 ) &lt;- in( B37 )  Freq: 0.00640726
1548 +  spill R30 -&gt; [sp, #12]	# spill size = 32
154c +  spill R21 -&gt; [sp, #24]	# spill size = 64
1550 +  spill R7 -&gt; [sp, #16]	# spill size = 64
1554 +  spill R29 -&gt; [sp, #8]	# spill size = 32
1558 +  spill R19 -&gt; R8	# spill size = 64
155c +  spill R18 -&gt; [sp, #0]	# spill size = 64
1560 +  spill R7 -&gt; R11	# spill size = 64
1564    CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #16 L[2]=#Ptr0x00000040d8292660 STK[0]=sp + #24
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=R8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=NarrowOop [16]=Oop [24]=Oop off=5504/0x1580}

1580    B246: #	out( B110 ) &lt;- in( B245 )  Freq: 0.00640713
        # Block is sole successor of call
1580 +  li R28, #0	# int, #@loadConI
1584    spill [sp, #0] -&gt; R18	# spill size = 64
1588 +  spill R8 -&gt; R19	# spill size = 64
158c +  spill [sp, #8] -&gt; R29	# spill size = 32
1590 +  spill [sp, #16] -&gt; R7	# spill size = 64
1594 +  spill [sp, #24] -&gt; R21	# spill size = 64
1598 +  spill [sp, #12] -&gt; R30	# spill size = 32
159c +  j  B110	#@branch

15a0    B247: #	out( B248 ) &lt;- in( B91 )  Freq: 0.00638951
15a0 +  li R18, #0	# int, #@loadConI

15a4    B248: #	out( B160 ) &lt;- in( B158 B247 )  Freq: 0.00642761
15a4 +  li R28, #1	# int, #@loadConI
15a8 +  sb  R28, [R29, #17]	# byte, #@storeB ! Field: java/lang/String.hashIsZero
15ac +  li R10, #0	# int, #@loadConI
15b0 +  j  B160	#@branch

15b4    B249: #	out( B495 B250 ) &lt;- in( B85 )  Freq: 0.00427183
15b4 +  spill R31 -&gt; [sp, #12]	# spill size = 32
15b8 +  spill R20 -&gt; [sp, #24]	# spill size = 64
15bc +  spill R7 -&gt; [sp, #16]	# spill size = 64
15c0 +  spill R30 -&gt; [sp, #8]	# spill size = 32
15c4 +  spill R9 -&gt; [sp, #0]	# spill size = 64
15c8 +  spill R19 -&gt; R8	# spill size = 64
15cc +  spill R7 -&gt; R11	# spill size = 64
15d0    CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #16 L[2]=#Ptr0x00000040d8292660 STK[0]=sp + #24
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=NarrowOop [16]=Oop [24]=Oop off=5612/0x15ec}

15ec    B250: #	out( B160 ) &lt;- in( B249 )  Freq: 0.00427174
        # Block is sole successor of call
15ec +  li R18, #0	# int, #@loadConI
15f0    spill R8 -&gt; R19	# spill size = 64
15f4 +  spill [sp, #0] -&gt; R9	# spill size = 64
15f8 +  spill [sp, #8] -&gt; R30	# spill size = 32
15fc +  spill [sp, #16] -&gt; R7	# spill size = 64
1600 +  spill [sp, #24] -&gt; R20	# spill size = 64
1604 +  spill [sp, #12] -&gt; R31	# spill size = 32
1608 +  j  B160	#@branch

160c    B251: #	out( B423 B252 ) &lt;- in( B27 )  Freq: 0.00151973
160c +  mv  R7, narrowklass: precise klass java/util/Spliterators$EmptySpliterator$OfRef: 0x00000040d81e90f0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
161c +  far_bne  R9, R7, B423	#@far_cmpN_branch  P=0.000001 C=-1.000000

1624    B252: #	out( B144 B253 ) &lt;- in( B251 )  Freq: 0.00151973
1624 +  bne   R30, zr, B144	#@cmpP_imm0_branch  P=1.000000 C=12850.000000

1628    B253: #	out( N5509 ) &lt;- in( B252 )  Freq: 7.24664e-10
1628 +  li R11, #-187	# int, #@loadConI
162c    spill R18 -&gt; R8	# spill size = 64
1630 +  spill R30 -&gt; [sp, #8]	# spill size = 64
1634    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.Objects::requireNonNull @ bci:1 (line 208) L[0]=sp + #8 STK[0]=sp + #8
        # java.util.Spliterators$EmptySpliterator::forEachRemaining @ bci:1 (line 894) L[0]=_ L[1]=_
        # java.util.Spliterators$EmptySpliterator$OfRef::forEachRemaining @ bci:2 (line 905) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop off=5688/0x1638}
1638    #@ShouldNotReachHere

1644    B254: #	out( B489 B255 ) &lt;- in( B11 )  Freq: 0.00148859
1644 +  spill R29 -&gt; R8	# spill size = 64
1648    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.util.stream.Stream::empty
        # java.util.Optional::stream @ bci:7 (line 335) L[0]=_
        # jdk.internal.module.ModulePath$$Lambda$10/0x000000080001e230::apply @ bci:4 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=5708/0x164c}

164c    B255: #	out( B424 B256 ) &lt;- in( B254 )  Freq: 0.00148856
        # Block is sole successor of call
164c +  far_beq   R10, zr, B424	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

1654    B256: #	out( B17 ) &lt;- in( B255 )  Freq: 0.00148856
1654 +  spill R8 -&gt; R29	# spill size = 64
1658 +  spill R10 -&gt; R18	# spill size = 64
165c +  j  B17	#@branch

1660    B257: #	out( B425 B258 ) &lt;- in( B75 )  Freq: 0.00101323
1660 +  mv  R28, narrowklass: precise klass java/util/Spliterators$EmptySpliterator$OfRef: 0x00000040d81e90f0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1670 +  far_bne  R18, R28, B425	#@far_cmpN_branch  P=0.000001 C=-1.000000

1678    B258: #	out( B194 B259 ) &lt;- in( B257 )  Freq: 0.00101323
1678 +  bne   R29, zr, B194	#@cmpP_imm0_branch  P=1.000000 C=12850.000000

167c    B259: #	out( N5509 ) &lt;- in( B258 )  Freq: 4.83146e-10
167c +  li R11, #-187	# int, #@loadConI
1680    spill R19 -&gt; R8	# spill size = 64
1684 +  spill R29 -&gt; [sp, #8]	# spill size = 64
1688    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.Objects::requireNonNull @ bci:1 (line 208) L[0]=sp + #8 STK[0]=sp + #8
        # java.util.Spliterators$EmptySpliterator::forEachRemaining @ bci:1 (line 894) L[0]=_ L[1]=_
        # java.util.Spliterators$EmptySpliterator$OfRef::forEachRemaining @ bci:2 (line 905) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop off=5772/0x168c}
168c    #@ShouldNotReachHere

1698    B260: #	out( B487 B261 ) &lt;- in( B59 )  Freq: 0.00099247
1698 +  spill R30 -&gt; R8	# spill size = 64
169c    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.util.stream.Stream::empty
        # java.util.Optional::stream @ bci:7 (line 335) L[0]=_
        # jdk.internal.module.ModulePath$$Lambda$10/0x000000080001e230::apply @ bci:4 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=5792/0x16a0}

16a0    B261: #	out( B426 B262 ) &lt;- in( B260 )  Freq: 0.00099245
        # Block is sole successor of call
16a0 +  far_beq   R10, zr, B426	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

16a8    B262: #	out( B65 ) &lt;- in( B261 )  Freq: 0.000992449
16a8 +  spill R8 -&gt; R30	# spill size = 64
16ac +  spill R10 -&gt; R19	# spill size = 64
16b0 +  j  B65	#@branch

16b4    B263: #	out( B27 B264 ) &lt;- in( B26 )  Freq: 0.000333253
16b4 +  lwu  R7, [R31, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceSpliterator
16b8 +  decode_heap_oop  R10, R7	#@decodeHeapOop
16bc +  far_beq   R10, zr, B27	#@far_cmpP_imm0_branch  P=0.500000 C=-1.000000

16c4    B264: #	out( B355 B265 ) &lt;- in( B263 )  Freq: 0.000166627
16c4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16c4    ld  R7, [R23, #32]	# int, #@loadL
16c8 +  beq  R7, zr, B355	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

16cc    B265: #	out( B27 ) &lt;- in( B264 )  Freq: 0.00016646
16cc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16cc    ld  R28, [R23, #48]	# ptr, #@loadP
16d0 +  add R28, R28, R7	# ptr, #@addP_reg_reg
16d4 +  addi  R7, R7, #-8	#@addL_reg_imm
16d8 +  sd  R10, [R28, #-8]	# ptr, #@storeP
16dc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16dc    sd  R7, [R23, #32]	# long, #@storeL
16e0 +  j  B27	#@branch

16e4    B266: #	out( B145 B267 ) &lt;- in( B144 )  Freq: 0.000333248
16e4 +  lwu  R7, [R18, #44]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceSupplier
16e8 +  decode_heap_oop  R10, R7	#@decodeHeapOop
16ec +  beq   R10, zr, B145	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

16f0    B267: #	out( B356 B268 ) &lt;- in( B266 )  Freq: 0.000166624
16f0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16f0    ld  R7, [R23, #32]	# int, #@loadL
16f4 +  beq  R7, zr, B356	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

16f8    B268: #	out( B145 ) &lt;- in( B267 )  Freq: 0.000166457
16f8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16f8    ld  R28, [R23, #48]	# ptr, #@loadP
16fc +  add R28, R28, R7	# ptr, #@addP_reg_reg
1700 +  addi  R7, R7, #-8	#@addL_reg_imm
1704 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1708 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1708    sd  R7, [R23, #32]	# long, #@storeL
170c +  j  B145	#@branch

1710    B269: #	out( B146 B270 ) &lt;- in( B145 )  Freq: 0.000333248
1710 +  lwu  R28, [R18, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceSpliterator
1714 +  decode_heap_oop  R10, R28	#@decodeHeapOop
1718 +  beq   R10, zr, B146	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

171c    B270: #	out( B357 B271 ) &lt;- in( B269 )  Freq: 0.000166624
171c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
171c    ld  R7, [R23, #32]	# int, #@loadL
1720 +  beq  R7, zr, B357	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1724    B271: #	out( B146 ) &lt;- in( B270 )  Freq: 0.000166457
1724 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1724    ld  R28, [R23, #48]	# ptr, #@loadP
1728 +  add R28, R28, R7	# ptr, #@addP_reg_reg
172c +  addi  R7, R7, #-8	#@addL_reg_imm
1730 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1734 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1734    sd  R7, [R23, #32]	# long, #@storeL
1738 +  j  B146	#@branch

173c    B272: #	out( B141 B273 ) &lt;- in( B140 )  Freq: 0.000281123
173c +  lwu  R28, [R9, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.value
1740 +  decode_heap_oop  R10, R28	#@decodeHeapOop
1744 +  beq   R10, zr, B141	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1748    B273: #	out( B372 B274 ) &lt;- in( B272 )  Freq: 0.000140561
1748 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1748    ld  R7, [R23, #32]	# int, #@loadL
174c +  beq  R7, zr, B372	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1750    B274: #	out( B141 ) &lt;- in( B273 )  Freq: 0.000140421
1750 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1750    ld  R28, [R23, #48]	# ptr, #@loadP
1754 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1758 +  addi  R7, R7, #-8	#@addL_reg_imm
175c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1760 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1760    sd  R7, [R23, #32]	# long, #@storeL
1764 +  j  B141	#@branch

1768    B275: #	out( B143 B276 ) &lt;- in( B142 )  Freq: 0.000280845
1768 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1768    ld  R7, [R23, #64]	# int, #@loadL
176c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
176c    ld  R28, [R23, #80]	# ptr, #@loadP
1770 +  #@membar_volatile
	fence iorw iorw
1774 +  lb  R29, [R10]	# byte, #@loadB
1778 +  beq  R29, zr, B143	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

177c    B276: #	out( B278 B277 ) &lt;- in( B275 )  Freq: 0.000140423
177c +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1780 +  bne  R7, zr, B278	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1784    B277: #	out( B143 ) &lt;- in( B276 )  Freq: 7.02113e-05
1784 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1784    spill R23 -&gt; R11	# spill size = 64
1788 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
17b8 +  j  B143	#@branch

17bc    B278: #	out( B143 ) &lt;- in( B276 )  Freq: 7.02113e-05
17bc +  add R28, R28, R7	# ptr, #@addP_reg_reg
17c0 +  addi  R7, R7, #-8	#@addL_reg_imm
17c4 +  sd  R10, [R28, #-8]	# ptr, #@storeP
17c8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
17c8    sd  R7, [R23, #64]	# long, #@storeL
17cc +  j  B143	#@branch

17d0    B279: #	out( B75 B280 ) &lt;- in( B74 )  Freq: 0.000222186
17d0 +  lwu  R28, [R31, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceSpliterator
17d4 +  decode_heap_oop  R10, R28	#@decodeHeapOop
17d8 +  far_beq   R10, zr, B75	#@far_cmpP_imm0_branch  P=0.500000 C=-1.000000

17e0    B280: #	out( B380 B281 ) &lt;- in( B279 )  Freq: 0.000111093
17e0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
17e0    ld  R7, [R23, #32]	# int, #@loadL
17e4 +  beq  R7, zr, B380	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

17e8    B281: #	out( B75 ) &lt;- in( B280 )  Freq: 0.000110982
17e8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
17e8    ld  R28, [R23, #48]	# ptr, #@loadP
17ec +  add R28, R28, R7	# ptr, #@addP_reg_reg
17f0 +  addi  R7, R7, #-8	#@addL_reg_imm
17f4 +  sd  R10, [R28, #-8]	# ptr, #@storeP
17f8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
17f8    sd  R7, [R23, #32]	# long, #@storeL
17fc +  j  B75	#@branch

1800    B282: #	out( B195 B283 ) &lt;- in( B194 )  Freq: 0.000222182
1800 +  lwu  R28, [R19, #44]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceSupplier
1804 +  decode_heap_oop  R10, R28	#@decodeHeapOop
1808 +  beq   R10, zr, B195	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

180c    B283: #	out( B381 B284 ) &lt;- in( B282 )  Freq: 0.000111091
180c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
180c    ld  R7, [R23, #32]	# int, #@loadL
1810 +  beq  R7, zr, B381	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1814    B284: #	out( B195 ) &lt;- in( B283 )  Freq: 0.00011098
1814 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1814    ld  R28, [R23, #48]	# ptr, #@loadP
1818 +  add R28, R28, R7	# ptr, #@addP_reg_reg
181c +  addi  R7, R7, #-8	#@addL_reg_imm
1820 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1824 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1824    sd  R7, [R23, #32]	# long, #@storeL
1828 +  j  B195	#@branch

182c    B285: #	out( B196 B286 ) &lt;- in( B195 )  Freq: 0.000222182
182c +  lwu  R7, [R19, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceSpliterator
1830 +  decode_heap_oop  R10, R7	#@decodeHeapOop
1834 +  beq   R10, zr, B196	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1838    B286: #	out( B382 B287 ) &lt;- in( B285 )  Freq: 0.000111091
1838 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1838    ld  R7, [R23, #32]	# int, #@loadL
183c +  beq  R7, zr, B382	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1840    B287: #	out( B196 ) &lt;- in( B286 )  Freq: 0.00011098
1840 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1840    ld  R28, [R23, #48]	# ptr, #@loadP
1844 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1848 +  addi  R7, R7, #-8	#@addL_reg_imm
184c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1850 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1850    sd  R7, [R23, #32]	# long, #@storeL
1854 +  j  B196	#@branch

1858    B288: #	out( B191 B289 ) &lt;- in( B190 )  Freq: 0.000187429
1858 +  lwu  R7, [R24, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.value
185c +  decode_heap_oop  R10, R7	#@decodeHeapOop
1860 +  beq   R10, zr, B191	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1864    B289: #	out( B397 B290 ) &lt;- in( B288 )  Freq: 9.37146e-05
1864 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1864    ld  R7, [R23, #32]	# int, #@loadL
1868 +  beq  R7, zr, B397	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

186c    B290: #	out( B191 ) &lt;- in( B289 )  Freq: 9.36209e-05
186c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
186c    ld  R28, [R23, #48]	# ptr, #@loadP
1870 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1874 +  addi  R7, R7, #-8	#@addL_reg_imm
1878 +  sd  R10, [R28, #-8]	# ptr, #@storeP
187c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
187c    sd  R7, [R23, #32]	# long, #@storeL
1880 +  j  B191	#@branch

1884    B291: #	out( B193 B292 ) &lt;- in( B192 )  Freq: 0.000187244
1884 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1884    ld  R7, [R23, #64]	# int, #@loadL
1888 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1888    ld  R28, [R23, #80]	# ptr, #@loadP
188c +  #@membar_volatile
	fence iorw iorw
1890 +  lb  R30, [R10]	# byte, #@loadB
1894 +  beq  R30, zr, B193	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1898    B292: #	out( B294 B293 ) &lt;- in( B291 )  Freq: 9.36221e-05
1898 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
189c +  bne  R7, zr, B294	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

18a0    B293: #	out( B193 ) &lt;- in( B292 )  Freq: 4.6811e-05
18a0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
18a0    spill R23 -&gt; R11	# spill size = 64
18a4 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
18d4 +  j  B193	#@branch

18d8    B294: #	out( B193 ) &lt;- in( B292 )  Freq: 4.6811e-05
18d8 +  add R28, R28, R7	# ptr, #@addP_reg_reg
18dc +  addi  R7, R7, #-8	#@addL_reg_imm
18e0 +  sd  R10, [R28, #-8]	# ptr, #@storeP
18e4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
18e4    sd  R7, [R23, #64]	# long, #@storeL
18e8 +  j  B193	#@branch

18ec    B295: #	out( B110 ) &lt;- in( B40 )  Freq: 0.000181609
18ec +  li R10, #0	# int, #@loadConI
18f0 +  li R28, #0	# int, #@loadConI
18f4 +  j  B110	#@branch

18f8    B296: #	out( B160 ) &lt;- in( B88 )  Freq: 0.000121082
18f8 +  li R10, #0	# int, #@loadConI
18fc +  li R18, #0	# int, #@loadConI
1900 +  j  B160	#@branch

1904    B297: #	out( B203 B298 ) &lt;- in( B202 )  Freq: 3.7312e-05
1904 +  lwu  R7, [R24]	# loadN, compressed ptr, #@loadN
1908 +  decode_heap_oop  R10, R7	#@decodeHeapOop
190c +  beq   R10, zr, B203	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1910    B298: #	out( B419 B299 ) &lt;- in( B297 )  Freq: 1.8656e-05
1910 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1910    ld  R7, [R23, #32]	# int, #@loadL
1914 +  far_beq  R7, zr, B419	#@far_cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

191c    B299: #	out( B203 ) &lt;- in( B298 )  Freq: 1.86374e-05
191c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
191c    ld  R28, [R23, #48]	# ptr, #@loadP
1920 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1924 +  addi  R7, R7, #-8	#@addL_reg_imm
1928 +  sd  R10, [R28, #-8]	# ptr, #@storeP
192c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
192c    sd  R7, [R23, #32]	# long, #@storeL
1930 +  j  B203	#@branch

1934    B300: #	out( B205 B301 ) &lt;- in( B204 )  Freq: 3.72752e-05
1934 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1934    ld  R7, [R23, #64]	# int, #@loadL
1938 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1938    ld  R28, [R23, #80]	# ptr, #@loadP
193c +  #@membar_volatile
	fence iorw iorw
1940 +  lb  R29, [R10]	# byte, #@loadB
1944 +  beq  R29, zr, B205	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1948    B301: #	out( B303 B302 ) &lt;- in( B300 )  Freq: 1.86376e-05
1948 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
194c +  bne  R7, zr, B303	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1950    B302: #	out( B205 ) &lt;- in( B301 )  Freq: 9.3188e-06
1950 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1950    spill R23 -&gt; R11	# spill size = 64
1954 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1984 +  j  B205	#@branch

1988    B303: #	out( B205 ) &lt;- in( B301 )  Freq: 9.3188e-06
1988 +  add R28, R28, R7	# ptr, #@addP_reg_reg
198c +  addi  R7, R7, #-8	#@addL_reg_imm
1990 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1994 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1994    sd  R7, [R23, #64]	# long, #@storeL
1998 +  j  B205	#@branch

199c    B304: #	out( B485 B305 ) &lt;- in( B12 )  Freq: 3.31826e-05
199c +  spill R29 -&gt; [sp, #0]	# spill size = 64
19a0 +  mv  R11, precise klass java/util/stream/Streams$StreamBuilderImpl: 0x00000040d8403cd0:Constant:exact *	# ptr, #@loadConP
19b8    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.stream.Stream::of @ bci:0 (line 1398) L[0]=R8
        # java.util.Optional::stream @ bci:15 (line 337) L[0]=_
        # jdk.internal.module.ModulePath$$Lambda$10/0x000000080001e230::apply @ bci:4 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=NarrowOop off=6588/0x19bc}

19bc    B305: #	out( B14 ) &lt;- in( B304 )  Freq: 3.31819e-05
        # Block is sole successor of call
19bc +  spill [sp, #0] -&gt; R29	# spill size = 64
19c0 +  spill R10 -&gt; R30	# spill size = 64
19c4 +  j  B14	#@branch

19c8    B306: #	out( B486 B307 ) &lt;- in( B14 )  Freq: 3.31826e-05
19c8 +  spill R30 -&gt; [sp, #0]	# spill size = 64
19cc +  spill R29 -&gt; R8	# spill size = 64
19d0 +  mv  R11, precise klass java/util/stream/ReferencePipeline$Head: 0x00000040d81f36e0:Constant:exact *	# ptr, #@loadConP
19e8    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.stream.StreamSupport::stream @ bci:5 (line 69) L[0]=sp + #0 L[1]=#0
        # java.util.stream.Stream::of @ bci:9 (line 1398) L[0]=_
        # java.util.Optional::stream @ bci:15 (line 337) L[0]=_
        # jdk.internal.module.ModulePath$$Lambda$10/0x000000080001e230::apply @ bci:4 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=6636/0x19ec}

19ec    B307: #	out( B16 ) &lt;- in( B306 )  Freq: 3.31819e-05
        # Block is sole successor of call
19ec +  spill R8 -&gt; R29	# spill size = 64
19f0 +  spill [sp, #0] -&gt; R30	# spill size = 64
19f4 +  j  B16	#@branch

19f8    B308: #	out( B212 B309 ) &lt;- in( B211 )  Freq: 2.48766e-05
19f8 +  lwu  R28, [R25]	# loadN, compressed ptr, #@loadN
19fc +  decode_heap_oop  R10, R28	#@decodeHeapOop
1a00 +  beq   R10, zr, B212	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1a04    B309: #	out( B420 B310 ) &lt;- in( B308 )  Freq: 1.24383e-05
1a04 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a04    ld  R7, [R23, #32]	# int, #@loadL
1a08 +  beq  R7, zr, B420	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1a0c    B310: #	out( B212 ) &lt;- in( B309 )  Freq: 1.24258e-05
1a0c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a0c    ld  R28, [R23, #48]	# ptr, #@loadP
1a10 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1a14 +  addi  R7, R7, #-8	#@addL_reg_imm
1a18 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1a1c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a1c    sd  R7, [R23, #32]	# long, #@storeL
1a20 +  j  B212	#@branch

1a24    B311: #	out( B214 B312 ) &lt;- in( B213 )  Freq: 2.4852e-05
1a24 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a24    ld  R7, [R23, #64]	# int, #@loadL
1a28 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a28    ld  R28, [R23, #80]	# ptr, #@loadP
1a2c +  #@membar_volatile
	fence iorw iorw
1a30 +  lb  R30, [R10]	# byte, #@loadB
1a34 +  beq  R30, zr, B214	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1a38    B312: #	out( B314 B313 ) &lt;- in( B311 )  Freq: 1.2426e-05
1a38 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1a3c +  bne  R7, zr, B314	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1a40    B313: #	out( B214 ) &lt;- in( B312 )  Freq: 6.213e-06
1a40 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a40    spill R23 -&gt; R11	# spill size = 64
1a44 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1a74 +  j  B214	#@branch

1a78    B314: #	out( B214 ) &lt;- in( B312 )  Freq: 6.213e-06
1a78 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1a7c +  addi  R7, R7, #-8	#@addL_reg_imm
1a80 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1a84 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a84    sd  R7, [R23, #64]	# long, #@storeL
1a88 +  j  B214	#@branch

1a8c    B315: #	out( B483 B316 ) &lt;- in( B60 )  Freq: 2.21234e-05
1a8c +  spill R30 -&gt; [sp, #0]	# spill size = 64
1a90 +  mv  R11, precise klass java/util/stream/Streams$StreamBuilderImpl: 0x00000040d8403cd0:Constant:exact *	# ptr, #@loadConP
1aa8    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.stream.Stream::of @ bci:0 (line 1398) L[0]=R8
        # java.util.Optional::stream @ bci:15 (line 337) L[0]=_
        # jdk.internal.module.ModulePath$$Lambda$10/0x000000080001e230::apply @ bci:4 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=NarrowOop off=6828/0x1aac}

1aac    B316: #	out( B62 ) &lt;- in( B315 )  Freq: 2.21229e-05
        # Block is sole successor of call
1aac +  spill [sp, #0] -&gt; R30	# spill size = 64
1ab0 +  spill R10 -&gt; R29	# spill size = 64
1ab4 +  j  B62	#@branch

1ab8    B317: #	out( B484 B318 ) &lt;- in( B62 )  Freq: 2.21234e-05
1ab8 +  spill R29 -&gt; [sp, #0]	# spill size = 64
1abc +  spill R30 -&gt; R8	# spill size = 64
1ac0 +  mv  R11, precise klass java/util/stream/ReferencePipeline$Head: 0x00000040d81f36e0:Constant:exact *	# ptr, #@loadConP
1ad8    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.stream.StreamSupport::stream @ bci:5 (line 69) L[0]=sp + #0 L[1]=#0
        # java.util.stream.Stream::of @ bci:9 (line 1398) L[0]=_
        # java.util.Optional::stream @ bci:15 (line 337) L[0]=_
        # jdk.internal.module.ModulePath$$Lambda$10/0x000000080001e230::apply @ bci:4 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=6876/0x1adc}

1adc    B318: #	out( B64 ) &lt;- in( B317 )  Freq: 2.21229e-05
        # Block is sole successor of call
1adc +  spill R8 -&gt; R30	# spill size = 64
1ae0 +  spill [sp, #0] -&gt; R29	# spill size = 64
1ae4 +  j  B64	#@branch

1ae8    B319: #	out( B225 B320 ) &lt;- in( B224 )  Freq: 1.32933e-05
1ae8 +  lwu  R7, [R24, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
1aec +  decode_heap_oop  R10, R7	#@decodeHeapOop
1af0 +  beq   R10, zr, B225	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1af4    B320: #	out( B421 B321 ) &lt;- in( B319 )  Freq: 6.64667e-06
1af4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1af4    ld  R7, [R23, #32]	# int, #@loadL
1af8 +  beq  R7, zr, B421	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1afc    B321: #	out( B225 ) &lt;- in( B320 )  Freq: 6.64003e-06
1afc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1afc    ld  R28, [R23, #48]	# ptr, #@loadP
1b00 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1b04 +  addi  R7, R7, #-8	#@addL_reg_imm
1b08 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1b0c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b0c    sd  R7, [R23, #32]	# long, #@storeL
1b10 +  j  B225	#@branch

1b14    B322: #	out( B227 B323 ) &lt;- in( B226 )  Freq: 1.32802e-05
1b14 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b14    ld  R7, [R23, #64]	# int, #@loadL
1b18 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b18    ld  R28, [R23, #80]	# ptr, #@loadP
1b1c +  #@membar_volatile
	fence iorw iorw
1b20 +  lb  R29, [R10]	# byte, #@loadB
1b24 +  beq  R29, zr, B227	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1b28    B323: #	out( B325 B324 ) &lt;- in( B322 )  Freq: 6.64011e-06
1b28 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1b2c +  bne  R7, zr, B325	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1b30    B324: #	out( B227 ) &lt;- in( B323 )  Freq: 3.32006e-06
1b30 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b30    spill R23 -&gt; R11	# spill size = 64
1b34 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1b64 +  j  B227	#@branch

1b68    B325: #	out( B227 ) &lt;- in( B323 )  Freq: 3.32006e-06
1b68 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1b6c +  addi  R7, R7, #-8	#@addL_reg_imm
1b70 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1b74 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b74    sd  R7, [R23, #64]	# long, #@storeL
1b78 +  j  B227	#@branch

1b7c    B326: #	out( B238 B327 ) &lt;- in( B237 )  Freq: 8.8629e-06
1b7c +  lwu  R28, [R24, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
1b80 +  decode_heap_oop  R10, R28	#@decodeHeapOop
1b84 +  beq   R10, zr, B238	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1b88    B327: #	out( B422 B328 ) &lt;- in( B326 )  Freq: 4.43145e-06
1b88 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b88    ld  R7, [R23, #32]	# int, #@loadL
1b8c +  beq  R7, zr, B422	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1b90    B328: #	out( B238 ) &lt;- in( B327 )  Freq: 4.42702e-06
1b90 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b90    ld  R28, [R23, #48]	# ptr, #@loadP
1b94 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1b98 +  addi  R7, R7, #-8	#@addL_reg_imm
1b9c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1ba0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ba0    sd  R7, [R23, #32]	# long, #@storeL
1ba4 +  j  B238	#@branch

1ba8    B329: #	out( B240 B330 ) &lt;- in( B239 )  Freq: 8.85415e-06
1ba8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ba8    ld  R7, [R23, #64]	# int, #@loadL
1bac +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1bac    ld  R28, [R23, #80]	# ptr, #@loadP
1bb0 +  #@membar_volatile
	fence iorw iorw
1bb4 +  lb  R30, [R10]	# byte, #@loadB
1bb8 +  beq  R30, zr, B240	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1bbc    B330: #	out( B332 B331 ) &lt;- in( B329 )  Freq: 4.42708e-06
1bbc +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1bc0 +  bne  R7, zr, B332	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1bc4    B331: #	out( B240 ) &lt;- in( B330 )  Freq: 2.21354e-06
1bc4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1bc4    spill R23 -&gt; R11	# spill size = 64
1bc8 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1bf8 +  j  B240	#@branch

1bfc    B332: #	out( B240 ) &lt;- in( B330 )  Freq: 2.21354e-06
1bfc +  add R28, R28, R7	# ptr, #@addP_reg_reg
1c00 +  addi  R7, R7, #-8	#@addL_reg_imm
1c04 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1c08 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1c08    sd  R7, [R23, #64]	# long, #@storeL
1c0c +  j  B240	#@branch

1c10    B333: #	out( B482 B334 ) &lt;- in( B199 )  Freq: 3.73187e-06
1c10 +  spill R24 -&gt; [sp, #48]	# spill size = 64
1c14 +  spill R10 -&gt; [sp, #40]	# spill size = 32
1c18 +  spill R20 -&gt; [sp, #20]	# spill size = 32
1c1c +  spill R22 -&gt; [sp, #32]	# spill size = 64
1c20 +  spill R21 -&gt; [sp, #24]	# spill size = 64
1c24 +  spill R29 -&gt; [sp, #16]	# spill size = 32
1c28 +  spill R19 -&gt; [sp, #8]	# spill size = 64
1c2c +  spill R18 -&gt; [sp, #0]	# spill size = 64
1c30 +  mv  R11, precise klass java/util/HashMap$Node: 0x00000040d81c98a0:Constant:exact *	# ptr, #@loadConP
1c48    spill R7 -&gt; R8	# spill size = 64
1c4c    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #20 L[2]=R8 L[3]=#Ptr0x00000040d8292660 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:56 (line 629) L[0]=sp + #24 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #32 STK[1]=sp + #40
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=NarrowOop [24]=Oop [32]=Oop [48]=Derived_oop_[32] off=7248/0x1c50}

1c50    B334: #	out( B201 ) &lt;- in( B333 )  Freq: 3.7318e-06
        # Block is sole successor of call
1c50 +  spill R10 -&gt; R7	# spill size = 64
1c54 +  spill [sp, #0] -&gt; R18	# spill size = 64
1c58 +  spill [sp, #8] -&gt; R19	# spill size = 64
1c5c +  spill [sp, #16] -&gt; R29	# spill size = 32
1c60 +  spill [sp, #24] -&gt; R21	# spill size = 64
1c64 +  spill [sp, #32] -&gt; R22	# spill size = 64
1c68 +  spill [sp, #20] -&gt; R20	# spill size = 32
1c6c +  spill [sp, #40] -&gt; R10	# spill size = 32
1c70 +  spill [sp, #48] -&gt; R24	# spill size = 64
1c74 +  spill R7 -&gt; R9	# spill size = 64
1c78 +  j  B201	#@branch

1c7c    B335: #	out( B481 B336 ) &lt;- in( B208 )  Freq: 2.4881e-06
1c7c +  spill R25 -&gt; [sp, #48]	# spill size = 64
1c80 +  spill R29 -&gt; [sp, #40]	# spill size = 32
1c84 +  spill R21 -&gt; [sp, #12]	# spill size = 32
1c88 +  spill R22 -&gt; [sp, #32]	# spill size = 64
1c8c +  spill R20 -&gt; [sp, #24]	# spill size = 64
1c90 +  spill R7 -&gt; [sp, #16]	# spill size = 64
1c94 +  spill R30 -&gt; [sp, #8]	# spill size = 32
1c98 +  spill R9 -&gt; [sp, #0]	# spill size = 64
1c9c +  spill R19 -&gt; R8	# spill size = 64
1ca0 +  mv  R11, precise klass java/util/HashMap$Node: 0x00000040d81c98a0:Constant:exact *	# ptr, #@loadConP
1cb8    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #12 L[2]=sp + #16 L[3]=#Ptr0x00000040d8292660 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:56 (line 629) L[0]=sp + #24 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #32 STK[1]=sp + #40
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=NarrowOop [16]=Oop [24]=Oop [32]=Oop [48]=Derived_oop_[32] off=7356/0x1cbc}

1cbc    B336: #	out( B210 ) &lt;- in( B335 )  Freq: 2.48805e-06
        # Block is sole successor of call
1cbc +  spill R8 -&gt; R19	# spill size = 64
1cc0 +  spill [sp, #0] -&gt; R9	# spill size = 64
1cc4 +  spill [sp, #8] -&gt; R30	# spill size = 32
1cc8 +  spill [sp, #24] -&gt; R20	# spill size = 64
1ccc +  spill [sp, #32] -&gt; R22	# spill size = 64
1cd0 +  spill [sp, #12] -&gt; R21	# spill size = 32
1cd4 +  spill [sp, #40] -&gt; R29	# spill size = 32
1cd8 +  spill [sp, #48] -&gt; R25	# spill size = 64
1cdc +  spill R10 -&gt; R18	# spill size = 64
1ce0 +  j  B210	#@branch

1ce4    B337: #	out( B480 B338 ) &lt;- in( B222 )  Freq: 1.32957e-06
1ce4 +  spill R9 -&gt; [sp, #48]	# spill size = 32
1ce8 +  spill R24 -&gt; [sp, #40]	# spill size = 64
1cec +  spill R20 -&gt; [sp, #20]	# spill size = 32
1cf0 +  spill R22 -&gt; [sp, #32]	# spill size = 64
1cf4 +  spill R21 -&gt; [sp, #24]	# spill size = 64
1cf8 +  spill R29 -&gt; [sp, #16]	# spill size = 32
1cfc +  spill R19 -&gt; [sp, #8]	# spill size = 64
1d00 +  spill R18 -&gt; [sp, #0]	# spill size = 64
1d04 +  mv  R11, precise klass java/util/HashMap$Node: 0x00000040d81c98a0:Constant:exact *	# ptr, #@loadConP
1d1c    spill R7 -&gt; R8	# spill size = 64
1d20    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #20 L[2]=R8 L[3]=#Ptr0x00000040d8292660 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:152 (line 640) L[0]=sp + #24 L[1]=sp + #20 L[2]=_ L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=sp + #48 STK[0]=sp + #40
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=NarrowOop [24]=Oop [32]=Oop [40]=Oop off=7460/0x1d24}

1d24    B338: #	out( B224 ) &lt;- in( B337 )  Freq: 1.32955e-06
        # Block is sole successor of call
1d24 +  spill [sp, #0] -&gt; R18	# spill size = 64
1d28 +  spill [sp, #8] -&gt; R19	# spill size = 64
1d2c +  spill [sp, #16] -&gt; R29	# spill size = 32
1d30 +  spill [sp, #24] -&gt; R21	# spill size = 64
1d34 +  spill [sp, #32] -&gt; R22	# spill size = 64
1d38 +  spill [sp, #20] -&gt; R20	# spill size = 32
1d3c +  spill [sp, #40] -&gt; R24	# spill size = 64
1d40 +  spill [sp, #48] -&gt; R9	# spill size = 32
1d44 +  spill R10 -&gt; R25	# spill size = 64
1d48 +  j  B224	#@branch

1d4c    B339: #	out( B479 B340 ) &lt;- in( B235 )  Freq: 8.86448e-07
1d4c +  spill R24 -&gt; [sp, #48]	# spill size = 64
1d50 +  spill R21 -&gt; [sp, #40]	# spill size = 32
1d54 +  spill R22 -&gt; [sp, #32]	# spill size = 64
1d58 +  spill R20 -&gt; [sp, #24]	# spill size = 64
1d5c +  spill R7 -&gt; [sp, #16]	# spill size = 64
1d60 +  spill R30 -&gt; [sp, #4]	# spill size = 32
1d64 +  spill R9 -&gt; [sp, #8]	# spill size = 64
1d68 +  spill R19 -&gt; R8	# spill size = 64
1d6c +  spill R18 -&gt; [sp, #0]	# spill size = 32
1d70 +  mv  R11, precise klass java/util/HashMap$Node: 0x00000040d81c98a0:Constant:exact *	# ptr, #@loadConP
1d88    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #40 L[2]=sp + #16 L[3]=#Ptr0x00000040d8292660 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:152 (line 640) L[0]=sp + #24 L[1]=sp + #40 L[2]=_ L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=sp + #0 STK[0]=sp + #48
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [48]=Oop off=7564/0x1d8c}

1d8c    B340: #	out( B237 ) &lt;- in( B339 )  Freq: 8.86431e-07
        # Block is sole successor of call
1d8c +  spill [sp, #0] -&gt; R18	# spill size = 32
1d90 +  spill R8 -&gt; R19	# spill size = 64
1d94 +  spill [sp, #8] -&gt; R9	# spill size = 64
1d98 +  spill [sp, #4] -&gt; R30	# spill size = 32
1d9c +  spill [sp, #24] -&gt; R20	# spill size = 64
1da0 +  spill [sp, #32] -&gt; R22	# spill size = 64
1da4 +  spill [sp, #40] -&gt; R21	# spill size = 32
1da8 +  spill [sp, #48] -&gt; R24	# spill size = 64
1dac +  spill R10 -&gt; R25	# spill size = 64
1db0 +  j  B237	#@branch

1db4    B341: #	out( N5509 ) &lt;- in( B35 )  Freq: 3.36141e-07
1db4 +  li R11, #-10	# int, #@loadConI
1db8    spill R18 -&gt; R8	# spill size = 64
1dbc +  spill R7 -&gt; [sp, #0]	# spill size = 64
1dc0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=sp + #0 STK[2]=#Ptr0x00000040d8292660
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=7620/0x1dc4}
1dc4    #@ShouldNotReachHere

1dd0    B342: #	out( N5509 ) &lt;- in( B5 )  Freq: 3.33261e-07
1dd0 +  li R11, #-58	# int, #@loadConI
1dd4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;bimorphic&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop off=7640/0x1dd8}
1dd8    #@ShouldNotReachHere

1de4    B343: #	out( N5509 ) &lt;- in( B8 )  Freq: 3.3326e-07
1de4 +  li R11, #-34	# int, #@loadConI
1de8    spill R29 -&gt; [sp, #8]	# spill size = 64
1dec    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #0
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=7664/0x1df0}
1df0    #@ShouldNotReachHere

1dfc    B344: #	out( N5509 ) &lt;- in( B30 )  Freq: 3.31738e-07
1dfc +  li R11, #-34	# int, #@loadConI
1e00    spill R18 -&gt; R8	# spill size = 64
1e04 +  spill R19 -&gt; [sp, #0]	# spill size = 64
1e08 +  spill R7 -&gt; [sp, #8]	# spill size = 64
1e0c +  spill R30 -&gt; [sp, #16]	# spill size = 64
1e10    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_ STK[0]=sp + #16 STK[1]=sp + #8
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=7700/0x1e14}
1e14    #@ShouldNotReachHere

1e20    B345: #	out( N5509 ) &lt;- in( B32 )  Freq: 3.31737e-07
1e20 +  li R11, #-34	# int, #@loadConI
1e24    spill R18 -&gt; [sp, #0]	# spill size = 64
1e28 +  spill R19 -&gt; [sp, #8]	# spill size = 64
1e2c +  spill R7 -&gt; [sp, #16]	# spill size = 64
1e30 +  spill R31 -&gt; [sp, #24]	# spill size = 64
1e34    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_ STK[0]=sp + #24 STK[1]=R8 STK[2]=sp + #16
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=7736/0x1e38}
1e38    #@ShouldNotReachHere

1e44    B346: #	out( N5509 ) &lt;- in( B112 )  Freq: 3.31734e-07
1e44 +  li R11, #-28	# int, #@loadConI
1e48    spill R18 -&gt; R8	# spill size = 64
1e4c +  spill R19 -&gt; [sp, #0]	# spill size = 64
1e50 +  spill R21 -&gt; [sp, #8]	# spill size = 64
1e54 +  spill R7 -&gt; [sp, #16]	# spill size = 64
1e58 +  spill R20 -&gt; [sp, #24]	# spill size = 32
1e5c +  spill R22 -&gt; [sp, #40]	# spill size = 64
1e60 +  spill R10 -&gt; [sp, #48]	# spill size = 32
1e64    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.HashMap::putVal @ bci:40 (line 628) L[0]=sp + #8 L[1]=sp + #24 L[2]=sp + #16 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=_ L[8]=_ L[9]=sp + #48 L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #40 STK[1]=sp + #48
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [40]=Oop off=7784/0x1e68}
1e68    #@ShouldNotReachHere

1e74    B347: #	out( N5509 ) &lt;- in( B83 )  Freq: 2.24111e-07
1e74 +  li R11, #-10	# int, #@loadConI
1e78    spill R19 -&gt; R8	# spill size = 64
1e7c +  spill R7 -&gt; [sp, #0]	# spill size = 64
1e80    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=sp + #0 STK[2]=#Ptr0x00000040d8292660
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=7812/0x1e84}
1e84    #@ShouldNotReachHere

1e90    B348: #	out( N5509 ) &lt;- in( B53 )  Freq: 2.22191e-07
1e90 +  li R11, #-58	# int, #@loadConI
1e94    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;bimorphic&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #0
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=7832/0x1e98}
1e98    #@ShouldNotReachHere

1ea4    B349: #	out( N5509 ) &lt;- in( B56 )  Freq: 2.2219e-07
1ea4 +  li R11, #-34	# int, #@loadConI
1ea8    spill R30 -&gt; [sp, #8]	# spill size = 64
1eac    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #0
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=7856/0x1eb0}
1eb0    #@ShouldNotReachHere

1ebc    B350: #	out( N5509 ) &lt;- in( B78 )  Freq: 2.21175e-07
1ebc +  li R11, #-34	# int, #@loadConI
1ec0    spill R19 -&gt; R8	# spill size = 64
1ec4 +  spill R9 -&gt; [sp, #0]	# spill size = 64
1ec8 +  spill R29 -&gt; [sp, #8]	# spill size = 64
1ecc +  spill R7 -&gt; [sp, #16]	# spill size = 64
1ed0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_ STK[0]=sp + #8 STK[1]=sp + #16
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=7892/0x1ed4}
1ed4    #@ShouldNotReachHere

1ee0    B351: #	out( N5509 ) &lt;- in( B80 )  Freq: 2.21175e-07
1ee0 +  li R11, #-34	# int, #@loadConI
1ee4    spill R19 -&gt; [sp, #0]	# spill size = 64
1ee8 +  spill R9 -&gt; [sp, #8]	# spill size = 64
1eec +  spill R29 -&gt; [sp, #16]	# spill size = 64
1ef0 +  spill R7 -&gt; [sp, #24]	# spill size = 64
1ef4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_ STK[0]=sp + #16 STK[1]=R8 STK[2]=sp + #24
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=7928/0x1ef8}
1ef8    #@ShouldNotReachHere

1f04    B352: #	out( N5509 ) &lt;- in( B162 )  Freq: 2.21173e-07
1f04 +  li R11, #-28	# int, #@loadConI
1f08    spill R19 -&gt; R8	# spill size = 64
1f0c +  spill R9 -&gt; [sp, #0]	# spill size = 64
1f10 +  spill R20 -&gt; [sp, #8]	# spill size = 64
1f14 +  spill R21 -&gt; [sp, #16]	# spill size = 32
1f18 +  spill R7 -&gt; [sp, #24]	# spill size = 64
1f1c +  spill R22 -&gt; [sp, #40]	# spill size = 64
1f20 +  spill R29 -&gt; [sp, #48]	# spill size = 32
1f24    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.HashMap::putVal @ bci:40 (line 628) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #24 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=_ L[8]=_ L[9]=sp + #48 L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #40 STK[1]=sp + #48
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [40]=Oop off=7976/0x1f28}
1f28    #@ShouldNotReachHere

1f34    B353: #	out( N5509 ) &lt;- in( B18 )  Freq: 1.6663e-07
1f34 +  li R11, #-187	# int, #@loadConI
1f38    spill R18 -&gt; [sp, #0]	# spill size = 64
1f3c +  spill R29 -&gt; [sp, #8]	# spill size = 64
1f40    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:25 (line 275) L[0]=sp + #8 L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ STK[0]=R8
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop off=8004/0x1f44}
1f44    #@ShouldNotReachHere

1f50    B354: #	out( N5509 ) &lt;- in( B22 )  Freq: 1.66629e-07
1f50 +  li R11, #-187	# int, #@loadConI
1f54    spill R18 -&gt; R8	# spill size = 64
1f58 +  spill R12 -&gt; [sp, #0]	# spill size = 64
1f5c +  spill R30 -&gt; [sp, #8]	# spill size = 64
1f60 +  spill R13 -&gt; [sp, #16]	# spill size = 32
1f64    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:4 (line 761) L[0]=sp + #0 L[1]=sp + #8 STK[0]=sp + #16
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=8040/0x1f68}
1f68    #@ShouldNotReachHere

1f74    B355: #	out( B27 ) &lt;- in( B264 )  Freq: 1.66625e-07
1f74 +  spill R19 -&gt; R20	# spill size = 64
1f78 +  spill R31 -&gt; R19	# spill size = 64
1f7c    
1f7c    
1f7c +  spill R30 -&gt; R21	# spill size = 64
1f80    
1f80    
1f80 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1f80    spill R23 -&gt; R11	# spill size = 64
1f84 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
1fb4 +  spill R19 -&gt; R31	# spill size = 64
1fb8 +  spill R20 -&gt; R19	# spill size = 64
1fbc +  spill R21 -&gt; R30	# spill size = 64
1fc0 +  j  B27	#@branch

1fc4    B356: #	out( B145 ) &lt;- in( B267 )  Freq: 1.66622e-07
1fc4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1fc4    spill R23 -&gt; R11	# spill size = 64
1fc8 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
1ff8 +  j  B145	#@branch

1ffc    B357: #	out( B146 ) &lt;- in( B270 )  Freq: 1.66622e-07
1ffc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ffc    spill R23 -&gt; R11	# spill size = 64
2000 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2030 +  j  B146	#@branch

2034    B358: #	out( N5509 ) &lt;- in( B29 )  Freq: 1.65869e-07
2034 +  li R11, #-187	# int, #@loadConI
2038    spill R18 -&gt; [sp, #0]	# spill size = 64
203c +  spill R19 -&gt; [sp, #8]	# spill size = 64
2040 +  spill R30 -&gt; [sp, #16]	# spill size = 64
2044    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:11 (line 410) L[0]=sp + #8 L[1]=sp + #16 STK[0]=R8 STK[1]=#-2
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=8264/0x2048}
2048    #@ShouldNotReachHere

2054    B359: #	out( N5509 ) &lt;- in( B44 )  Freq: 1.63452e-07
2054 +  li R11, #-138	# int, #@loadConI
2058    spill R18 -&gt; R8	# spill size = 64
205c +  spill R19 -&gt; [sp, #0]	# spill size = 64
2060 +  spill R7 -&gt; [sp, #8]	# spill size = 64
2064 +  spill R21 -&gt; [sp, #16]	# spill size = 64
2068 +  spill R14 -&gt; [sp, #24]	# spill size = 64
206c +  spill R15 -&gt; [sp, #32]	# spill size = 64
2070 +  spill R13 -&gt; [sp, #44]	# spill size = 32
2074    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:13 (line 196) L[0]=_ L[1]=#0 L[2]=sp + #32 L[3]=sp + #44 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=sp + #44
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=sp + #24 L[1]=_
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #8 L[2]=#Ptr0x00000040d8292660 STK[0]=sp + #16
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop off=8312/0x2078}
2078    #@ShouldNotReachHere

2084    B360: #	out( B104 ) &lt;- in( B45 )  Freq: 1.63452e-07
2084 +  li R12, #1	# int, #@loadConI
2088 +  li R28, #0	# int, #@loadConI
208c +  j  B104	#@branch

2090    B361: #	out( N5509 ) &lt;- in( B46 )  Freq: 1.6131e-07
2090    #@ShouldNotReachHere

209c    B362: #	out( N5509 ) &lt;- in( B47 )  Freq: 1.6131e-07
209c    #@ShouldNotReachHere

20a8    B363: #	out( N5509 ) &lt;- in( B23 )  Freq: 1.5891e-07
20a8 +  li R11, #-187	# int, #@loadConI
20ac    spill R18 -&gt; R8	# spill size = 64
20b0 +  spill R30 -&gt; [sp, #0]	# spill size = 64
20b4 +  spill R12 -&gt; [sp, #16]	# spill size = 64
20b8 +  spill R31 -&gt; [sp, #24]	# spill size = 64
20bc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.AbstractPipeline::sourceStageSpliterator @ bci:5 (line 275) L[0]=sp + #16 L[1]=_ STK[0]=sp + #16 STK[1]=sp + #24
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:8 (line 762) L[0]=_ L[1]=sp + #0
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=8384/0x20c0}
20c0    #@ShouldNotReachHere

20cc    B364: #	out( N5509 ) &lt;- in( B24 )  Freq: 1.5891e-07
20cc +  li R11, #-187	# int, #@loadConI
20d0    spill R18 -&gt; R8	# spill size = 64
20d4 +  spill R30 -&gt; [sp, #0]	# spill size = 64
20d8 +  spill R12 -&gt; [sp, #8]	# spill size = 64
20dc +  spill R10 -&gt; [sp, #16]	# spill size = 32
20e0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.AbstractPipeline::sourceStageSpliterator @ bci:20 (line 278) L[0]=sp + #8 L[1]=_ STK[0]=sp + #16
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:8 (line 762) L[0]=_ L[1]=sp + #0
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=8420/0x20e4}
20e4    #@ShouldNotReachHere

20f0    B365: #	out( N5509 ) &lt;- in( B131 )  Freq: 1.54084e-07
20f0 +  li R11, #-34	# int, #@loadConI
20f4    spill R18 -&gt; R8	# spill size = 64
20f8 +  spill R19 -&gt; [sp, #0]	# spill size = 64
20fc +  spill R21 -&gt; [sp, #8]	# spill size = 64
2100 +  spill R7 -&gt; [sp, #24]	# spill size = 64
2104 +  spill R20 -&gt; [sp, #32]	# spill size = 32
2108 +  spill R22 -&gt; [sp, #40]	# spill size = 64
210c +  spill R9 -&gt; [sp, #48]	# spill size = 64
2110 +  spill R10 -&gt; [sp, #56]	# spill size = 64
2114    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=sp + #8 L[1]=sp + #32 L[2]=sp + #24 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=sp + #48 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #24 STK[1]=sp + #56
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop off=8472/0x2118}
2118    #@ShouldNotReachHere

2124    B366: #	out( N5509 ) &lt;- in( B111 )  Freq: 1.53141e-07
2124 +  li R11, #-187	# int, #@loadConI
2128    spill R18 -&gt; R8	# spill size = 64
212c +  spill R19 -&gt; [sp, #0]	# spill size = 64
2130 +  spill R21 -&gt; [sp, #8]	# spill size = 64
2134 +  spill R7 -&gt; [sp, #16]	# spill size = 64
2138 +  spill R20 -&gt; [sp, #24]	# spill size = 32
213c +  spill R22 -&gt; [sp, #32]	# spill size = 64
2140 +  spill R31 -&gt; [sp, #40]	# spill size = 32
2144    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:16 (line 626) L[0]=sp + #8 L[1]=sp + #24 L[2]=sp + #16 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=sp + #40 L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #40
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [32]=Oop off=8520/0x2148}
2148    #@ShouldNotReachHere

2154    B367: #	out( N5509 ) &lt;- in( B136 )  Freq: 1.4601e-07
2154    #@ShouldNotReachHere

2160    B368: #	out( N5509 ) &lt;- in( B137 )  Freq: 1.4601e-07
2160    #@ShouldNotReachHere

216c    B369: #	out( B370 ) &lt;- in( B139 )  Freq: 6.87102e-08
216c +  spill R10 -&gt; R28	# spill size = 32

2170    B370: #	out( N5509 ) &lt;- in( B369 B138 )  Freq: 2.12806e-07
2170 +  li R11, #-187	# int, #@loadConI
2174    spill R18 -&gt; R8	# spill size = 64
2178 +  spill R19 -&gt; [sp, #0]	# spill size = 64
217c +  spill R21 -&gt; [sp, #8]	# spill size = 64
2180 +  spill R28 -&gt; [sp, #16]	# spill size = 32
2184 +  spill R20 -&gt; [sp, #20]	# spill size = 32
2188 +  spill R12 -&gt; [sp, #24]	# spill size = 64
218c +  spill R22 -&gt; [sp, #32]	# spill size = 64
2190 +  spill R9 -&gt; [sp, #40]	# spill size = 64
2194    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:94 (line 633) L[0]=sp + #8 L[1]=sp + #20 L[2]=sp + #24 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #16
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop off=8600/0x2198}
2198    #@ShouldNotReachHere

21a4    B371: #	out( N5509 ) &lt;- in( B115 )  Freq: 1.42201e-07
21a4 +  li R11, #-187	# int, #@loadConI
21a8    spill R18 -&gt; R8	# spill size = 64
21ac +  spill R19 -&gt; [sp, #0]	# spill size = 64
21b0 +  spill R21 -&gt; [sp, #8]	# spill size = 64
21b4 +  spill R7 -&gt; [sp, #16]	# spill size = 64
21b8 +  spill R20 -&gt; [sp, #24]	# spill size = 32
21bc +  spill R22 -&gt; [sp, #32]	# spill size = 64
21c0 +  spill R9 -&gt; [sp, #40]	# spill size = 64
21c4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:109 (line 635) L[0]=sp + #8 L[1]=sp + #24 L[2]=sp + #16 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#1
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop off=8648/0x21c8}
21c8    #@ShouldNotReachHere

21d4    B372: #	out( B141 ) &lt;- in( B273 )  Freq: 1.40559e-07
21d4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
21d4    spill R23 -&gt; R11	# spill size = 64
21d8 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2208 +  j  B141	#@branch

220c    B373: #	out( N5509 ) &lt;- in( B120 )  Freq: 1.27044e-07
220c +  li R11, #-34	# int, #@loadConI
2210    spill R18 -&gt; R8	# spill size = 64
2214 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2218 +  spill R21 -&gt; [sp, #8]	# spill size = 64
221c +  spill R7 -&gt; [sp, #24]	# spill size = 64
2220 +  spill R20 -&gt; [sp, #32]	# spill size = 32
2224 +  spill R22 -&gt; [sp, #40]	# spill size = 64
2228 +  spill R24 -&gt; [sp, #48]	# spill size = 64
222c +  spill R9 -&gt; [sp, #36]	# spill size = 32
2230 +  spill R12 -&gt; [sp, #56]	# spill size = 64
2234    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #8 L[1]=sp + #32 L[2]=sp + #24 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #48 L[11]=_ L[12]=sp + #36 STK[0]=sp + #24 STK[1]=sp + #56
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop off=8760/0x2238}
2238    #@ShouldNotReachHere

2244    B374: #	out( N5509 ) &lt;- in( B125 )  Freq: 1.20386e-07
2244    #@ShouldNotReachHere

2250    B375: #	out( N5509 ) &lt;- in( B126 )  Freq: 1.20386e-07
2250    #@ShouldNotReachHere

225c    B376: #	out( B377 ) &lt;- in( B128 )  Freq: 5.66522e-08
225c +  spill R10 -&gt; R28	# spill size = 32

2260    B377: #	out( N5509 ) &lt;- in( B376 B127 )  Freq: 1.75461e-07
2260 +  li R11, #-187	# int, #@loadConI
2264    spill R18 -&gt; R8	# spill size = 64
2268 +  spill R19 -&gt; [sp, #0]	# spill size = 64
226c +  spill R21 -&gt; [sp, #8]	# spill size = 64
2270 +  spill R28 -&gt; [sp, #16]	# spill size = 32
2274 +  spill R20 -&gt; [sp, #20]	# spill size = 32
2278 +  spill R15 -&gt; [sp, #24]	# spill size = 64
227c +  spill R22 -&gt; [sp, #32]	# spill size = 64
2280 +  spill R24 -&gt; [sp, #40]	# spill size = 64
2284 +  spill R9 -&gt; [sp, #48]	# spill size = 32
2288    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:206 (line 646) L[0]=sp + #8 L[1]=sp + #20 L[2]=sp + #24 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=_ L[12]=sp + #48 STK[0]=sp + #16
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop off=8844/0x228c}
228c    #@ShouldNotReachHere

2298    B378: #	out( N5509 ) &lt;- in( B66 )  Freq: 1.11095e-07
2298 +  li R11, #-187	# int, #@loadConI
229c    spill R30 -&gt; [sp, #0]	# spill size = 64
22a0 +  spill R19 -&gt; [sp, #8]	# spill size = 64
22a4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:25 (line 275) L[0]=sp + #0 L[1]=_ L[2]=sp + #8 L[3]=_ L[4]=_ STK[0]=R8
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop off=8872/0x22a8}
22a8    #@ShouldNotReachHere

22b4    B379: #	out( N5509 ) &lt;- in( B70 )  Freq: 1.11095e-07
22b4 +  li R11, #-187	# int, #@loadConI
22b8    spill R19 -&gt; R8	# spill size = 64
22bc +  spill R10 -&gt; [sp, #0]	# spill size = 64
22c0 +  spill R29 -&gt; [sp, #8]	# spill size = 64
22c4 +  spill R12 -&gt; [sp, #16]	# spill size = 32
22c8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:4 (line 761) L[0]=sp + #0 L[1]=sp + #8 STK[0]=sp + #16
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=8908/0x22cc}
22cc    #@ShouldNotReachHere

22d8    B380: #	out( B75 ) &lt;- in( B280 )  Freq: 1.11091e-07
22d8 +  spill R31 -&gt; R20	# spill size = 64
22dc    
22dc    
22dc +  spill R29 -&gt; R22	# spill size = 64
22e0    
22e0    
22e0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
22e0    spill R23 -&gt; R11	# spill size = 64
22e4 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2314 +  spill R9 -&gt; R21	# spill size = 64
2318 +  spill R20 -&gt; R31	# spill size = 64
231c +  spill R21 -&gt; R9	# spill size = 64
2320 +  spill R22 -&gt; R29	# spill size = 64
2324 +  j  B75	#@branch

2328    B381: #	out( B195 ) &lt;- in( B283 )  Freq: 1.11089e-07
2328 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2328    spill R23 -&gt; R11	# spill size = 64
232c +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
235c +  j  B195	#@branch

2360    B382: #	out( B196 ) &lt;- in( B286 )  Freq: 1.11089e-07
2360 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2360    spill R23 -&gt; R11	# spill size = 64
2364 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2394 +  j  B196	#@branch

2398    B383: #	out( N5509 ) &lt;- in( B77 )  Freq: 1.10588e-07
2398 +  li R11, #-187	# int, #@loadConI
239c    spill R19 -&gt; [sp, #0]	# spill size = 64
23a0 +  spill R9 -&gt; [sp, #8]	# spill size = 64
23a4 +  spill R29 -&gt; [sp, #16]	# spill size = 64
23a8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:11 (line 410) L[0]=sp + #8 L[1]=sp + #16 STK[0]=R8 STK[1]=#-2
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=9132/0x23ac}
23ac    #@ShouldNotReachHere

23b8    B384: #	out( N5509 ) &lt;- in( B92 )  Freq: 1.08977e-07
23b8 +  li R11, #-138	# int, #@loadConI
23bc    spill R14 -&gt; [sp, #0]	# spill size = 64
23c0 +  spill R19 -&gt; [sp, #8]	# spill size = 64
23c4 +  spill R9 -&gt; [sp, #16]	# spill size = 64
23c8 +  spill R7 -&gt; [sp, #24]	# spill size = 64
23cc +  spill R20 -&gt; [sp, #32]	# spill size = 64
23d0 +  spill R29 -&gt; [sp, #40]	# spill size = 64
23d4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:13 (line 196) L[0]=_ L[1]=#0 L[2]=sp + #0 L[3]=R8 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=R8
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=sp + #40 L[1]=_
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #24 L[2]=#Ptr0x00000040d8292660 STK[0]=sp + #32
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #16 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=9176/0x23d8}
23d8    #@ShouldNotReachHere

23e4    B385: #	out( B154 ) &lt;- in( B93 )  Freq: 1.08976e-07
23e4 +  li R18, #0	# int, #@loadConI
23e8 +  j  B154	#@branch

23ec    B386: #	out( N5509 ) &lt;- in( B94 )  Freq: 1.07548e-07
23ec    #@ShouldNotReachHere

23f8    B387: #	out( N5509 ) &lt;- in( B95 )  Freq: 1.07548e-07
23f8    #@ShouldNotReachHere

2404    B388: #	out( N5509 ) &lt;- in( B71 )  Freq: 1.05948e-07
2404 +  li R11, #-187	# int, #@loadConI
2408    spill R19 -&gt; R8	# spill size = 64
240c +  spill R29 -&gt; [sp, #0]	# spill size = 64
2410 +  spill R10 -&gt; [sp, #16]	# spill size = 64
2414 +  spill R31 -&gt; [sp, #24]	# spill size = 64
2418    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.AbstractPipeline::sourceStageSpliterator @ bci:5 (line 275) L[0]=sp + #16 L[1]=_ STK[0]=sp + #16 STK[1]=sp + #24
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:8 (line 762) L[0]=_ L[1]=sp + #0
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=9244/0x241c}
241c    #@ShouldNotReachHere

2428    B389: #	out( N5509 ) &lt;- in( B72 )  Freq: 1.05948e-07
2428 +  li R11, #-187	# int, #@loadConI
242c    spill R19 -&gt; R8	# spill size = 64
2430 +  spill R29 -&gt; [sp, #0]	# spill size = 64
2434 +  spill R10 -&gt; [sp, #8]	# spill size = 64
2438 +  spill R28 -&gt; [sp, #16]	# spill size = 32
243c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.AbstractPipeline::sourceStageSpliterator @ bci:20 (line 278) L[0]=sp + #8 L[1]=_ STK[0]=sp + #16
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:8 (line 762) L[0]=_ L[1]=sp + #0
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=9280/0x2440}
2440    #@ShouldNotReachHere

244c    B390: #	out( N5509 ) &lt;- in( B181 )  Freq: 1.0273e-07
244c +  li R11, #-34	# int, #@loadConI
2450    spill R19 -&gt; R8	# spill size = 64
2454 +  spill R9 -&gt; [sp, #0]	# spill size = 64
2458 +  spill R20 -&gt; [sp, #8]	# spill size = 64
245c +  spill R21 -&gt; [sp, #16]	# spill size = 32
2460 +  spill R22 -&gt; [sp, #32]	# spill size = 64
2464 +  spill R24 -&gt; [sp, #40]	# spill size = 64
2468 +  spill R7 -&gt; [sp, #48]	# spill size = 64
246c +  spill R10 -&gt; [sp, #56]	# spill size = 64
2470    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #48 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #48 STK[1]=sp + #56
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=9332/0x2474}
2474    #@ShouldNotReachHere

2480    B391: #	out( N5509 ) &lt;- in( B161 )  Freq: 1.02102e-07
2480 +  li R11, #-187	# int, #@loadConI
2484    spill R19 -&gt; R8	# spill size = 64
2488 +  spill R9 -&gt; [sp, #0]	# spill size = 64
248c +  spill R20 -&gt; [sp, #8]	# spill size = 64
2490 +  spill R21 -&gt; [sp, #16]	# spill size = 32
2494 +  spill R7 -&gt; [sp, #24]	# spill size = 64
2498 +  spill R22 -&gt; [sp, #32]	# spill size = 64
249c +  spill R28 -&gt; [sp, #40]	# spill size = 32
24a0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:16 (line 626) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #24 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=sp + #40 L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #40
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop off=9380/0x24a4}
24a4    #@ShouldNotReachHere

24b0    B392: #	out( N5509 ) &lt;- in( B186 )  Freq: 9.73471e-08
24b0    #@ShouldNotReachHere

24bc    B393: #	out( N5509 ) &lt;- in( B187 )  Freq: 9.7347e-08
24bc    #@ShouldNotReachHere

24c8    B394: #	out( B395 ) &lt;- in( B189 )  Freq: 4.58103e-08
24c8 +  spill R10 -&gt; R18	# spill size = 32

24cc    B395: #	out( N5509 ) &lt;- in( B394 B188 )  Freq: 1.41881e-07
24cc +  li R11, #-187	# int, #@loadConI
24d0    spill R18 -&gt; R8	# spill size = 32
24d4 +  spill R19 -&gt; [sp, #0]	# spill size = 64
24d8 +  spill R9 -&gt; [sp, #8]	# spill size = 64
24dc +  spill R20 -&gt; [sp, #16]	# spill size = 64
24e0 +  spill R21 -&gt; [sp, #24]	# spill size = 32
24e4 +  spill R31 -&gt; [sp, #32]	# spill size = 64
24e8 +  spill R22 -&gt; [sp, #40]	# spill size = 64
24ec +  spill R24 -&gt; [sp, #48]	# spill size = 64
24f0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:94 (line 633) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #32 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=sp + #48 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=R8
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop off=9460/0x24f4}
24f4    #@ShouldNotReachHere

2500    B396: #	out( N5509 ) &lt;- in( B165 )  Freq: 9.48078e-08
2500 +  li R11, #-187	# int, #@loadConI
2504    spill R19 -&gt; R8	# spill size = 64
2508 +  spill R9 -&gt; [sp, #0]	# spill size = 64
250c +  spill R20 -&gt; [sp, #8]	# spill size = 64
2510 +  spill R21 -&gt; [sp, #16]	# spill size = 32
2514 +  spill R7 -&gt; [sp, #24]	# spill size = 64
2518 +  spill R22 -&gt; [sp, #32]	# spill size = 64
251c +  spill R24 -&gt; [sp, #40]	# spill size = 64
2520    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:109 (line 635) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #24 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#1
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop off=9508/0x2524}
2524    #@ShouldNotReachHere

2530    B397: #	out( B191 ) &lt;- in( B289 )  Freq: 9.37134e-08
2530 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2530    spill R23 -&gt; R11	# spill size = 64
2534 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2564 +  j  B191	#@branch

2568    B398: #	out( N5509 ) &lt;- in( B41 )  Freq: 8.54471e-08
2568 +  li R11, #-187	# int, #@loadConI
256c    spill R18 -&gt; [sp, #0]	# spill size = 64
2570 +  spill R19 -&gt; [sp, #8]	# spill size = 64
2574 +  spill R7 -&gt; [sp, #16]	# spill size = 64
2578 +  spill R21 -&gt; [sp, #24]	# spill size = 64
257c +  spill R14 -&gt; [sp, #32]	# spill size = 64
2580    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=R8
        # java.lang.String::hashCode @ bci:17 (line 2337) L[0]=sp + #32 L[1]=_
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #16 L[2]=#Ptr0x00000040d8292660 STK[0]=sp + #24
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop off=9604/0x2584}
2584    #@ShouldNotReachHere

2590    B399: #	out( N5509 ) &lt;- in( B170 )  Freq: 8.47022e-08
2590 +  li R11, #-34	# int, #@loadConI
2594    spill R19 -&gt; R8	# spill size = 64
2598 +  spill R9 -&gt; [sp, #0]	# spill size = 64
259c +  spill R20 -&gt; [sp, #8]	# spill size = 64
25a0 +  spill R21 -&gt; [sp, #16]	# spill size = 32
25a4 +  spill R22 -&gt; [sp, #32]	# spill size = 64
25a8 +  spill R12 -&gt; [sp, #40]	# spill size = 64
25ac +  spill R28 -&gt; [sp, #20]	# spill size = 32
25b0 +  spill R7 -&gt; [sp, #48]	# spill size = 64
25b4 +  spill R10 -&gt; [sp, #56]	# spill size = 64
25b8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #48 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=_ L[12]=sp + #20 STK[0]=sp + #48 STK[1]=sp + #56
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=9660/0x25bc}
25bc    #@ShouldNotReachHere

25c8    B400: #	out( N5509 ) &lt;- in( B105 )  Freq: 8.1726e-08
25c8    #@ShouldNotReachHere

25d4    B401: #	out( N5509 ) &lt;- in( B106 )  Freq: 8.17259e-08
25d4    #@ShouldNotReachHere

25e0    B402: #	out( N5509 ) &lt;- in( B175 )  Freq: 8.02636e-08
25e0    #@ShouldNotReachHere

25ec    B403: #	out( N5509 ) &lt;- in( B176 )  Freq: 8.02635e-08
25ec    #@ShouldNotReachHere

25f8    B404: #	out( B405 ) &lt;- in( B178 )  Freq: 3.7771e-08
25f8 +  spill R10 -&gt; R18	# spill size = 32

25fc    B405: #	out( N5509 ) &lt;- in( B404 B177 )  Freq: 1.16983e-07
25fc +  li R11, #-187	# int, #@loadConI
2600    spill R18 -&gt; R8	# spill size = 32
2604 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2608 +  spill R9 -&gt; [sp, #8]	# spill size = 64
260c +  spill R20 -&gt; [sp, #16]	# spill size = 64
2610 +  spill R21 -&gt; [sp, #24]	# spill size = 32
2614 +  spill R15 -&gt; [sp, #32]	# spill size = 64
2618 +  spill R22 -&gt; [sp, #40]	# spill size = 64
261c +  spill R12 -&gt; [sp, #48]	# spill size = 64
2620 +  spill R28 -&gt; [sp, #28]	# spill size = 32
2624    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:206 (line 646) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #32 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #48 L[11]=_ L[12]=sp + #28 STK[0]=R8
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop off=9768/0x2628}
2628    #@ShouldNotReachHere

2634    B406: #	out( N5509 ) &lt;- in( B130 )  Freq: 7.3473e-08
2634 +  li R11, #-187	# int, #@loadConI
2638    spill R18 -&gt; R8	# spill size = 64
263c +  spill R19 -&gt; [sp, #0]	# spill size = 64
2640 +  spill R21 -&gt; [sp, #8]	# spill size = 64
2644 +  spill R7 -&gt; [sp, #24]	# spill size = 64
2648 +  spill R20 -&gt; [sp, #32]	# spill size = 32
264c +  spill R22 -&gt; [sp, #40]	# spill size = 64
2650 +  spill R9 -&gt; [sp, #48]	# spill size = 64
2654 +  spill R10 -&gt; [sp, #64]	# spill size = 64
2658    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:81 (line 632) L[0]=sp + #8 L[1]=sp + #32 L[2]=sp + #24 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=sp + #48 L[8]=_ L[9]=_ L[10]=_ L[11]=sp + #64 L[12]=_ STK[0]=sp + #64 STK[1]=sp + #24
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [40]=Oop [48]=Oop [64]=Oop off=9820/0x265c}
265c    #@ShouldNotReachHere

2668    B407: #	out( N5509 ) &lt;- in( B135 )  Freq: 7.20481e-08
2668 +  li R11, #-187	# int, #@loadConI
266c    spill R18 -&gt; [sp, #0]	# spill size = 64
2670 +  spill R19 -&gt; [sp, #8]	# spill size = 64
2674 +  spill R21 -&gt; [sp, #16]	# spill size = 64
2678 +  spill R20 -&gt; [sp, #24]	# spill size = 32
267c +  spill R22 -&gt; [sp, #40]	# spill size = 64
2680 +  spill R9 -&gt; [sp, #48]	# spill size = 64
2684 +  spill R12 -&gt; [sp, #56]	# spill size = 64
2688 +  spill R10 -&gt; [sp, #64]	# spill size = 64
268c +  spill R30 -&gt; [sp, #28]	# spill size = 32
2690    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #56 L[1]=_ L[2]=sp + #64 STK[0]=sp + #28 STK[1]=R8
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #56 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=sp + #48 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop off=9876/0x2694}
2694    #@ShouldNotReachHere

26a0    B408: #	out( N5509 ) &lt;- in( B119 )  Freq: 6.05792e-08
26a0 +  li R11, #-187	# int, #@loadConI
26a4    spill R18 -&gt; R8	# spill size = 64
26a8 +  spill R19 -&gt; [sp, #0]	# spill size = 64
26ac +  spill R21 -&gt; [sp, #8]	# spill size = 64
26b0 +  spill R7 -&gt; [sp, #24]	# spill size = 64
26b4 +  spill R20 -&gt; [sp, #32]	# spill size = 32
26b8 +  spill R22 -&gt; [sp, #40]	# spill size = 64
26bc +  spill R24 -&gt; [sp, #48]	# spill size = 64
26c0 +  spill R9 -&gt; [sp, #36]	# spill size = 32
26c4 +  spill R12 -&gt; [sp, #64]	# spill size = 64
26c8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:193 (line 645) L[0]=sp + #8 L[1]=sp + #32 L[2]=sp + #24 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #48 L[11]=sp + #64 L[12]=sp + #36 STK[0]=sp + #64 STK[1]=sp + #24
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [40]=Oop [48]=Oop [64]=Oop off=9932/0x26cc}
26cc    #@ShouldNotReachHere

26d8    B409: #	out( N5509 ) &lt;- in( B124 )  Freq: 5.94043e-08
26d8 +  li R11, #-187	# int, #@loadConI
26dc    spill R18 -&gt; [sp, #0]	# spill size = 64
26e0 +  spill R19 -&gt; [sp, #8]	# spill size = 64
26e4 +  spill R21 -&gt; [sp, #16]	# spill size = 64
26e8 +  spill R20 -&gt; [sp, #24]	# spill size = 32
26ec +  spill R22 -&gt; [sp, #40]	# spill size = 64
26f0 +  spill R24 -&gt; [sp, #48]	# spill size = 64
26f4 +  spill R9 -&gt; [sp, #28]	# spill size = 32
26f8 +  spill R15 -&gt; [sp, #56]	# spill size = 64
26fc +  spill R12 -&gt; [sp, #64]	# spill size = 64
2700 +  spill R30 -&gt; [sp, #72]	# spill size = 32
2704    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #56 L[1]=_ L[2]=sp + #64 STK[0]=sp + #72 STK[1]=R8
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #56 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #48 L[11]=_ L[12]=sp + #28
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop off=9992/0x2708}
2708    #@ShouldNotReachHere

2714    B410: #	out( N5509 ) &lt;- in( B89 )  Freq: 5.69691e-08
2714 +  li R11, #-187	# int, #@loadConI
2718    spill R19 -&gt; [sp, #0]	# spill size = 64
271c +  spill R9 -&gt; [sp, #8]	# spill size = 64
2720 +  spill R7 -&gt; [sp, #16]	# spill size = 64
2724 +  spill R20 -&gt; [sp, #24]	# spill size = 64
2728 +  spill R29 -&gt; [sp, #32]	# spill size = 64
272c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=R8
        # java.lang.String::hashCode @ bci:17 (line 2337) L[0]=sp + #32 L[1]=_
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #16 L[2]=#Ptr0x00000040d8292660 STK[0]=sp + #24
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop off=10032/0x2730}
2730    #@ShouldNotReachHere

273c    B411: #	out( N5509 ) &lt;- in( B155 )  Freq: 5.44881e-08
273c    #@ShouldNotReachHere

2748    B412: #	out( N5509 ) &lt;- in( B156 )  Freq: 5.44881e-08
2748    #@ShouldNotReachHere

2754    B413: #	out( N5509 ) &lt;- in( B180 )  Freq: 4.89857e-08
2754 +  li R11, #-187	# int, #@loadConI
2758    spill R19 -&gt; R8	# spill size = 64
275c +  spill R9 -&gt; [sp, #0]	# spill size = 64
2760 +  spill R20 -&gt; [sp, #8]	# spill size = 64
2764 +  spill R21 -&gt; [sp, #16]	# spill size = 32
2768 +  spill R22 -&gt; [sp, #32]	# spill size = 64
276c +  spill R24 -&gt; [sp, #40]	# spill size = 64
2770 +  spill R10 -&gt; [sp, #56]	# spill size = 64
2774 +  spill R7 -&gt; [sp, #64]	# spill size = 64
2778    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:81 (line 632) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #64 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=sp + #56 L[12]=_ STK[0]=sp + #56 STK[1]=sp + #64
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=10108/0x277c}
277c    #@ShouldNotReachHere

2788    B414: #	out( N5509 ) &lt;- in( B185 )  Freq: 4.80357e-08
2788 +  li R11, #-187	# int, #@loadConI
278c    spill R19 -&gt; [sp, #0]	# spill size = 64
2790 +  spill R9 -&gt; [sp, #8]	# spill size = 64
2794 +  spill R20 -&gt; [sp, #16]	# spill size = 64
2798 +  spill R21 -&gt; [sp, #24]	# spill size = 32
279c +  spill R22 -&gt; [sp, #40]	# spill size = 64
27a0 +  spill R24 -&gt; [sp, #48]	# spill size = 64
27a4 +  spill R31 -&gt; [sp, #56]	# spill size = 64
27a8 +  spill R10 -&gt; [sp, #64]	# spill size = 64
27ac +  spill R30 -&gt; [sp, #28]	# spill size = 32
27b0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #56 L[1]=_ L[2]=sp + #64 STK[0]=sp + #28 STK[1]=R8
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #56 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=sp + #48 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop off=10164/0x27b4}
27b4    #@ShouldNotReachHere

27c0    B415: #	out( N5509 ) &lt;- in( B169 )  Freq: 4.03892e-08
27c0 +  li R11, #-187	# int, #@loadConI
27c4    spill R19 -&gt; R8	# spill size = 64
27c8 +  spill R9 -&gt; [sp, #0]	# spill size = 64
27cc +  spill R20 -&gt; [sp, #8]	# spill size = 64
27d0 +  spill R21 -&gt; [sp, #16]	# spill size = 32
27d4 +  spill R22 -&gt; [sp, #32]	# spill size = 64
27d8 +  spill R12 -&gt; [sp, #40]	# spill size = 64
27dc +  spill R28 -&gt; [sp, #20]	# spill size = 32
27e0 +  spill R10 -&gt; [sp, #56]	# spill size = 64
27e4 +  spill R7 -&gt; [sp, #64]	# spill size = 64
27e8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:193 (line 645) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #64 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=sp + #56 L[12]=sp + #20 STK[0]=sp + #56 STK[1]=sp + #64
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=10220/0x27ec}
27ec    #@ShouldNotReachHere

27f8    B416: #	out( N5509 ) &lt;- in( B174 )  Freq: 3.96059e-08
27f8 +  li R11, #-187	# int, #@loadConI
27fc    spill R19 -&gt; [sp, #0]	# spill size = 64
2800 +  spill R9 -&gt; [sp, #8]	# spill size = 64
2804 +  spill R20 -&gt; [sp, #16]	# spill size = 64
2808 +  spill R21 -&gt; [sp, #24]	# spill size = 32
280c +  spill R22 -&gt; [sp, #40]	# spill size = 64
2810 +  spill R12 -&gt; [sp, #48]	# spill size = 64
2814 +  spill R28 -&gt; [sp, #28]	# spill size = 32
2818 +  spill R15 -&gt; [sp, #56]	# spill size = 64
281c +  spill R10 -&gt; [sp, #64]	# spill size = 64
2820 +  spill R29 -&gt; [sp, #72]	# spill size = 32
2824    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #56 L[1]=_ L[2]=sp + #64 STK[0]=sp + #72 STK[1]=R8
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #56 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #48 L[11]=_ L[12]=sp + #28
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop off=10280/0x2828}
2828    #@ShouldNotReachHere

2834    B417: #	out( N5509 ) &lt;- in( B201 )  Freq: 3.73125e-08
2834 +  li R11, #-42	# int, #@loadConI
2838    spill R18 -&gt; R8	# spill size = 64
283c +  spill R19 -&gt; [sp, #0]	# spill size = 64
2840 +  spill R21 -&gt; [sp, #8]	# spill size = 64
2844 +  spill R22 -&gt; [sp, #16]	# spill size = 64
2848 +  spill R10 -&gt; [sp, #24]	# spill size = 32
284c +  spill R9 -&gt; [sp, #32]	# spill size = 64
2850    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;array_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:59 (line 629) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #16 STK[1]=sp + #24 STK[2]=sp + #32
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [32]=Oop off=10324/0x2854}
2854    #@ShouldNotReachHere

2860    B418: #	out( N5509 ) &lt;- in( B210 )  Freq: 2.48769e-08
2860 +  li R11, #-42	# int, #@loadConI
2864    spill R19 -&gt; R8	# spill size = 64
2868 +  spill R9 -&gt; [sp, #0]	# spill size = 64
286c +  spill R20 -&gt; [sp, #8]	# spill size = 64
2870 +  spill R22 -&gt; [sp, #16]	# spill size = 64
2874 +  spill R29 -&gt; [sp, #24]	# spill size = 32
2878 +  spill R18 -&gt; [sp, #32]	# spill size = 64
287c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;array_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:59 (line 629) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #16 STK[1]=sp + #24 STK[2]=sp + #32
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [32]=Oop off=10368/0x2880}
2880    #@ShouldNotReachHere

288c    B419: #	out( B203 ) &lt;- in( B298 )  Freq: 1.86558e-08
288c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
288c    spill R23 -&gt; R11	# spill size = 64
2890 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
28c0 +  j  B203	#@branch

28c4    B420: #	out( B212 ) &lt;- in( B309 )  Freq: 1.24381e-08
28c4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
28c4    spill R23 -&gt; R11	# spill size = 64
28c8 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
28f8 +  j  B212	#@branch

28fc    B421: #	out( B225 ) &lt;- in( B320 )  Freq: 6.64659e-09
28fc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
28fc    spill R23 -&gt; R11	# spill size = 64
2900 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2930 +  j  B225	#@branch

2934    B422: #	out( B238 ) &lt;- in( B327 )  Freq: 4.43139e-09
2934 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2934    spill R23 -&gt; R11	# spill size = 64
2938 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2968 +  j  B238	#@branch

296c    B423: #	out( N5509 ) &lt;- in( B251 )  Freq: 1.51973e-09
296c +  li R11, #-58	# int, #@loadConI
2970    spill R18 -&gt; R8	# spill size = 64
2974 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2978 +  spill R30 -&gt; [sp, #8]	# spill size = 64
297c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;bimorphic&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_ STK[0]=sp + #0 STK[1]=sp + #8
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=10624/0x2980}
2980    #@ShouldNotReachHere

298c    B424: #	out( N5509 ) &lt;- in( B255 )  Freq: 1.50833e-09
298c +  li R11, #-12	# int, #@loadConI
2990    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:13 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=10644/0x2994}
2994    #@ShouldNotReachHere

29a0    B425: #	out( N5509 ) &lt;- in( B257 )  Freq: 1.01323e-09
29a0 +  li R11, #-58	# int, #@loadConI
29a4    spill R19 -&gt; R8	# spill size = 64
29a8 +  spill R9 -&gt; [sp, #0]	# spill size = 64
29ac +  spill R29 -&gt; [sp, #8]	# spill size = 64
29b0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;bimorphic&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_ STK[0]=sp + #0 STK[1]=sp + #8
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=10676/0x29b4}
29b4    #@ShouldNotReachHere

29c0    B426: #	out( N5509 ) &lt;- in( B261 )  Freq: 1.00563e-09
29c0 +  li R11, #-12	# int, #@loadConI
29c4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:13 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=10696/0x29c8}
29c8    #@ShouldNotReachHere

29d4    B427: #	out( N5509 ) &lt;- in( B58 )  Freq: 1e-35
29d4 +  li R11, #-34	# int, #@loadConI
29d8    spill R30 -&gt; R8	# spill size = 64
29dc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$10/0x000000080001e230::apply @ bci:1 L[0]=_ L[1]=_ STK[0]=sp + #0
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=10720/0x29e0}
29e0    #@ShouldNotReachHere

29ec    B428: #	out( N5509 ) &lt;- in( B10 )  Freq: 1e-35
29ec +  li R11, #-34	# int, #@loadConI
29f0    spill R29 -&gt; R8	# spill size = 64
29f4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$10/0x000000080001e230::apply @ bci:1 L[0]=_ L[1]=_ STK[0]=sp + #0
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=10744/0x29f8}
29f8    #@ShouldNotReachHere

2a04    B429: #	out( N5509 ) &lt;- in( B65 )  Freq: 1e-35
2a04 +  li R11, #-34	# int, #@loadConI
2a08    spill R30 -&gt; R8	# spill size = 64
2a0c +  spill R19 -&gt; [sp, #0]	# spill size = 64
2a10    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:13 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #0
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=10772/0x2a14}
2a14    #@ShouldNotReachHere

2a20    B430: #	out( N5509 ) &lt;- in( B17 )  Freq: 1e-35
2a20 +  li R11, #-34	# int, #@loadConI
2a24    spill R18 -&gt; R8	# spill size = 64
2a28 +  spill R29 -&gt; [sp, #0]	# spill size = 64
2a2c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:13 (line 273) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=10800/0x2a30}
2a30    #@ShouldNotReachHere

2a3c    B431: #	out( N5509 ) &lt;- in( B68 )  Freq: 1e-35
2a3c +  li R11, #-34	# int, #@loadConI
2a40    spill R30 -&gt; R8	# spill size = 64
2a44 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2a48 +  spill R10 -&gt; [sp, #8]	# spill size = 64
2a4c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:34 (line 276) L[0]=R8 L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ STK[0]=sp + #8
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=10832/0x2a50}
2a50    #@ShouldNotReachHere

2a5c    B432: #	out( N5509 ) &lt;- in( B20 )  Freq: 1e-35
2a5c +  li R11, #-34	# int, #@loadConI
2a60    spill R18 -&gt; R8	# spill size = 64
2a64 +  spill R29 -&gt; [sp, #0]	# spill size = 64
2a68 +  spill R12 -&gt; [sp, #8]	# spill size = 64
2a6c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:34 (line 276) L[0]=sp + #0 L[1]=_ L[2]=R8 L[3]=_ L[4]=_ STK[0]=sp + #8
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=10864/0x2a70}
2a70    #@ShouldNotReachHere

2a7c    B433: #	out( N5509 ) &lt;- in( B82 )  Freq: 1e-35
2a7c +  li R11, #-34	# int, #@loadConI
2a80    spill R19 -&gt; [sp, #0]	# spill size = 64
2a84 +  spill R9 -&gt; [sp, #8]	# spill size = 64
2a88 +  spill R7 -&gt; [sp, #16]	# spill size = 64
2a8c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:1 L[0]=_ L[1]=_ L[2]=sp + #16 STK[0]=R8
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=10896/0x2a90}
2a90    #@ShouldNotReachHere

2a9c    B434: #	out( N5509 ) &lt;- in( B34 )  Freq: 1e-35
2a9c +  li R11, #-34	# int, #@loadConI
2aa0    spill R18 -&gt; [sp, #0]	# spill size = 64
2aa4 +  spill R19 -&gt; [sp, #8]	# spill size = 64
2aa8 +  spill R7 -&gt; [sp, #16]	# spill size = 64
2aac    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:1 L[0]=_ L[1]=_ L[2]=sp + #16 STK[0]=R8
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=10928/0x2ab0}
2ab0    #@ShouldNotReachHere

2abc    B435: #	out( N5509 ) &lt;- in( B184 )  Freq: 1e-35
2abc +  li R11, #-34	# int, #@loadConI
2ac0    spill R19 -&gt; R8	# spill size = 64
2ac4 +  spill R9 -&gt; [sp, #0]	# spill size = 64
2ac8 +  spill R20 -&gt; [sp, #8]	# spill size = 64
2acc +  spill R21 -&gt; [sp, #16]	# spill size = 32
2ad0 +  spill R22 -&gt; [sp, #32]	# spill size = 64
2ad4 +  spill R24 -&gt; [sp, #40]	# spill size = 64
2ad8 +  spill R31 -&gt; [sp, #48]	# spill size = 64
2adc +  spill R10 -&gt; [sp, #64]	# spill size = 64
2ae0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=sp + #64 L[2]=_ STK[0]=sp + #64
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #48 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [48]=Oop [64]=Oop off=10980/0x2ae4}
2ae4    #@ShouldNotReachHere

2af0    B436: #	out( N5509 ) &lt;- in( B173 )  Freq: 1e-35
2af0 +  li R11, #-34	# int, #@loadConI
2af4    spill R19 -&gt; R8	# spill size = 64
2af8 +  spill R9 -&gt; [sp, #0]	# spill size = 64
2afc +  spill R20 -&gt; [sp, #8]	# spill size = 64
2b00 +  spill R21 -&gt; [sp, #16]	# spill size = 32
2b04 +  spill R22 -&gt; [sp, #32]	# spill size = 64
2b08 +  spill R12 -&gt; [sp, #40]	# spill size = 64
2b0c +  spill R28 -&gt; [sp, #20]	# spill size = 32
2b10 +  spill R15 -&gt; [sp, #48]	# spill size = 64
2b14 +  spill R10 -&gt; [sp, #64]	# spill size = 64
2b18    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=sp + #64 L[2]=_ STK[0]=sp + #64
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #48 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=_ L[12]=sp + #20
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [48]=Oop [64]=Oop off=11036/0x2b1c}
2b1c    #@ShouldNotReachHere

2b28    B437: #	out( N5509 ) &lt;- in( B134 )  Freq: 1e-35
2b28 +  li R11, #-34	# int, #@loadConI
2b2c    spill R18 -&gt; R8	# spill size = 64
2b30 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2b34 +  spill R21 -&gt; [sp, #8]	# spill size = 64
2b38 +  spill R20 -&gt; [sp, #16]	# spill size = 32
2b3c +  spill R22 -&gt; [sp, #32]	# spill size = 64
2b40 +  spill R9 -&gt; [sp, #40]	# spill size = 64
2b44 +  spill R12 -&gt; [sp, #48]	# spill size = 64
2b48 +  spill R10 -&gt; [sp, #64]	# spill size = 64
2b4c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=sp + #64 L[2]=_ STK[0]=sp + #64
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #48 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [48]=Oop [64]=Oop off=11088/0x2b50}
2b50    #@ShouldNotReachHere

2b5c    B438: #	out( N5509 ) &lt;- in( B123 )  Freq: 1e-35
2b5c +  li R11, #-34	# int, #@loadConI
2b60    spill R18 -&gt; R8	# spill size = 64
2b64 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2b68 +  spill R21 -&gt; [sp, #8]	# spill size = 64
2b6c +  spill R20 -&gt; [sp, #16]	# spill size = 32
2b70 +  spill R22 -&gt; [sp, #32]	# spill size = 64
2b74 +  spill R24 -&gt; [sp, #40]	# spill size = 64
2b78 +  spill R9 -&gt; [sp, #20]	# spill size = 32
2b7c +  spill R15 -&gt; [sp, #48]	# spill size = 64
2b80 +  spill R12 -&gt; [sp, #64]	# spill size = 64
2b84    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=sp + #64 L[2]=_ STK[0]=sp + #64
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #48 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=_ L[12]=sp + #20
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [48]=Oop [64]=Oop off=11144/0x2b88}
2b88    #@ShouldNotReachHere

2b94    B439: #	out( N5509 ) &lt;- in( B1 )  Freq: 1.01328e-06
2b94 +  li R11, #-10	# int, #@loadConI
2b98    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:8 (line 197) L[0]=_ L[1]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=11164/0x2b9c}
2b9c    #@ShouldNotReachHere

2ba8    B440: #	out( N5509 ) &lt;- in( B3 )  Freq: 1.01326e-06
2ba8 +  li R11, #-10	# int, #@loadConI
2bac    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=sp + #0
        # OopMap {[0]=Oop off=11184/0x2bb0}
2bb0    #@ShouldNotReachHere

2bbc    B441: #	out( N5509 ) &lt;- in( B49 )  Freq: 6.7557e-07
2bbc +  li R11, #-10	# int, #@loadConI
2bc0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:8 (line 197) L[0]=_ L[1]=_ STK[0]=_ STK[1]=#NULL
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {off=11204/0x2bc4}
2bc4    #@ShouldNotReachHere

2bd0    B442: #	out( N5509 ) &lt;- in( B51 )  Freq: 6.75556e-07
2bd0 +  li R11, #-10	# int, #@loadConI
2bd4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=sp + #0
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop off=11224/0x2bd8}
2bd8    #@ShouldNotReachHere

2be4    B443: #	out( N5509 ) &lt;- in( B6 )  Freq: 3.37686e-07
2be4 +  li R11, #-10	# int, #@loadConI
2be8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:4 (line 273) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=11244/0x2bec}
2bec    #@ShouldNotReachHere

2bf8    B444: #	out( N5509 ) &lt;- in( B7 )  Freq: 3.37686e-07
2bf8 +  li R11, #-10	# int, #@loadConI
2bfc    spill R29 -&gt; R8	# spill size = 64
2c00    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=sp + #0
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=11268/0x2c04}
2c04    #@ShouldNotReachHere

2c10    B445: #	out( N5509 ) &lt;- in( B9 )  Freq: 3.37685e-07
2c10 +  li R11, #-12	# int, #@loadConI
2c14    spill R29 -&gt; R8	# spill size = 64
2c18    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.module.ModulePath$$Lambda$10/0x000000080001e230::apply @ bci:1 L[0]=_ L[1]=_ STK[0]=#NULL
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=11292/0x2c1c}
2c1c    #@ShouldNotReachHere

2c28    B446: #	out( N5509 ) &lt;- in( B19 )  Freq: 3.37684e-07
2c28 +  li R11, #-10	# int, #@loadConI
2c2c    spill R18 -&gt; R8	# spill size = 64
2c30 +  spill R29 -&gt; [sp, #0]	# spill size = 64
2c34    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.AbstractPipeline::sequential @ bci:5 (line 304) L[0]=_ STK[0]=#NULL STK[1]=#0
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:29 (line 276) L[0]=sp + #0 L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=11320/0x2c38}
2c38    #@ShouldNotReachHere

2c44    B447: #	out( N5509 ) &lt;- in( B21 )  Freq: 3.37684e-07
2c44 +  li R11, #-10	# int, #@loadConI
2c48    spill R18 -&gt; R8	# spill size = 64
2c4c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.AbstractPipeline::isParallel @ bci:4 (line 373) L[0]=_ STK[0]=#NULL
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:1 (line 761) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=11344/0x2c50}
2c50    #@ShouldNotReachHere

2c5c    B448: #	out( N5509 ) &lt;- in( B146 )  Freq: 3.37677e-07
2c5c +  li R11, #-10	# int, #@loadConI
2c60    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.AbstractPipeline::close @ bci:19 (line 320) L[0]=_ L[1]=_ STK[0]=#NULL
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:94 (line 283) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {off=11364/0x2c64}
2c64    #@ShouldNotReachHere

2c70    B449: #	out( N5509 ) &lt;- in( B31 )  Freq: 3.36142e-07
2c70 +  li R11, #-10	# int, #@loadConI
2c74    spill R18 -&gt; [sp, #0]	# spill size = 64
2c78 +  spill R7 -&gt; [sp, #8]	# spill size = 64
2c7c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8 STK[2]=sp + #8
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=11392/0x2c80}
2c80    #@ShouldNotReachHere

2c8c    B450: #	out( N5509 ) &lt;- in( B33 )  Freq: 3.36142e-07
2c8c +  li R11, #-12	# int, #@loadConI
2c90    spill R18 -&gt; R8	# spill size = 64
2c94 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2c98 +  spill R7 -&gt; [sp, #8]	# spill size = 64
2c9c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:1 L[0]=_ L[1]=_ L[2]=sp + #8 STK[0]=#NULL
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=11424/0x2ca0}
2ca0    #@ShouldNotReachHere

2cac    B451: #	out( N5509 ) &lt;- in( B54 )  Freq: 2.25141e-07
2cac +  li R11, #-10	# int, #@loadConI
2cb0    spill R30 -&gt; R8	# spill size = 64
2cb4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:4 (line 273) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=11448/0x2cb8}
2cb8    #@ShouldNotReachHere

2cc4    B452: #	out( N5509 ) &lt;- in( B55 )  Freq: 2.25141e-07
2cc4 +  li R11, #-10	# int, #@loadConI
2cc8    spill R30 -&gt; R8	# spill size = 64
2ccc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=sp + #0
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=11472/0x2cd0}
2cd0    #@ShouldNotReachHere

2cdc    B453: #	out( N5509 ) &lt;- in( B57 )  Freq: 2.2514e-07
2cdc +  li R11, #-12	# int, #@loadConI
2ce0    spill R30 -&gt; R8	# spill size = 64
2ce4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.module.ModulePath$$Lambda$10/0x000000080001e230::apply @ bci:1 L[0]=_ L[1]=_ STK[0]=#NULL
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=11496/0x2ce8}
2ce8    #@ShouldNotReachHere

2cf4    B454: #	out( N5509 ) &lt;- in( B67 )  Freq: 2.2514e-07
2cf4 +  li R11, #-10	# int, #@loadConI
2cf8    spill R30 -&gt; R8	# spill size = 64
2cfc +  spill R19 -&gt; [sp, #0]	# spill size = 64
2d00    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.AbstractPipeline::sequential @ bci:5 (line 304) L[0]=_ STK[0]=#NULL STK[1]=#0
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:29 (line 276) L[0]=R8 L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=11524/0x2d04}
2d04    #@ShouldNotReachHere

2d10    B455: #	out( N5509 ) &lt;- in( B69 )  Freq: 2.2514e-07
2d10 +  li R11, #-10	# int, #@loadConI
2d14    spill R19 -&gt; R8	# spill size = 64
2d18    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.AbstractPipeline::isParallel @ bci:4 (line 373) L[0]=_ STK[0]=#NULL
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:1 (line 761) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=11548/0x2d1c}
2d1c    #@ShouldNotReachHere

2d28    B456: #	out( N5509 ) &lt;- in( B196 )  Freq: 2.25135e-07
2d28 +  li R11, #-10	# int, #@loadConI
2d2c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.AbstractPipeline::close @ bci:19 (line 320) L[0]=_ L[1]=_ STK[0]=#NULL
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:94 (line 283) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {off=11568/0x2d30}
2d30    #@ShouldNotReachHere

2d3c    B457: #	out( N5509 ) &lt;- in( B79 )  Freq: 2.24112e-07
2d3c +  li R11, #-10	# int, #@loadConI
2d40    spill R19 -&gt; [sp, #0]	# spill size = 64
2d44 +  spill R7 -&gt; [sp, #8]	# spill size = 64
2d48    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8 STK[2]=sp + #8
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=11596/0x2d4c}
2d4c    #@ShouldNotReachHere

2d58    B458: #	out( N5509 ) &lt;- in( B81 )  Freq: 2.24111e-07
2d58 +  li R11, #-12	# int, #@loadConI
2d5c    spill R19 -&gt; R8	# spill size = 64
2d60 +  spill R9 -&gt; [sp, #0]	# spill size = 64
2d64 +  spill R7 -&gt; [sp, #8]	# spill size = 64
2d68    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:1 L[0]=_ L[1]=_ L[2]=sp + #8 STK[0]=#NULL
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=11628/0x2d6c}
2d6c    #@ShouldNotReachHere

2d78    B459: #	out( N5509 ) &lt;- in( B42 )  Freq: 1.73163e-07
2d78 +  li R11, #-10	# int, #@loadConI
2d7c    spill R18 -&gt; R8	# spill size = 64
2d80    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:5 (line 196) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=_ L[1]=_
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=_ L[2]=_ STK[0]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=11652/0x2d84}
2d84    #@ShouldNotReachHere

2d90    B460: #	out( N5509 ) &lt;- in( B25 )  Freq: 1.5891e-07
2d90 +  li R11, #-187	# int, #@loadConI
2d94    spill R18 -&gt; R8	# spill size = 64
2d98 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2d9c +  spill R30 -&gt; [sp, #8]	# spill size = 64
2da0 +  spill R12 -&gt; [sp, #16]	# spill size = 64
2da4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.AbstractPipeline::sourceStageSpliterator @ bci:45 (line 282) L[0]=sp + #16 L[1]=_ STK[0]=sp + #0
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:8 (line 762) L[0]=_ L[1]=sp + #8
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=11688/0x2da8}
2da8    #@ShouldNotReachHere

2db4    B461: #	out( N5509 ) &lt;- in( B28 )  Freq: 1.58185e-07
2db4 +  li R11, #-187	# int, #@loadConI
2db8    spill R18 -&gt; R8	# spill size = 64
2dbc +  spill R19 -&gt; [sp, #0]	# spill size = 64
2dc0 +  spill R30 -&gt; [sp, #16]	# spill size = 64
2dc4 +  spill R30 -&gt; [sp, #24]	# spill size = 64
2dc8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.Objects::requireNonNull @ bci:1 (line 208) L[0]=sp + #24 STK[0]=sp + #16
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:1 (line 408) L[0]=sp + #0 L[1]=sp + #16
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=11724/0x2dcc}
2dcc    #@ShouldNotReachHere

2dd8    B462: #	out( N5509 ) &lt;- in( B36 )  Freq: 1.58184e-07
2dd8 +  li R11, #-187	# int, #@loadConI
2ddc    spill R18 -&gt; R8	# spill size = 64
2de0 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2de4 +  spill R21 -&gt; [sp, #16]	# spill size = 64
2de8 +  spill R7 -&gt; [sp, #24]	# spill size = 64
2dec +  spill R7 -&gt; [sp, #32]	# spill size = 64
2df0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::hash @ bci:1 (line 338) L[0]=sp + #32 L[1]=_ STK[0]=sp + #24
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #24 L[2]=#Ptr0x00000040d8292660 STK[0]=sp + #16
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop off=11764/0x2df4}
2df4    #@ShouldNotReachHere

2e00    B463: #	out( N5509 ) &lt;- in( B133 )  Freq: 1.4601e-07
2e00 +  li R11, #-12	# int, #@loadConI
2e04    spill R18 -&gt; R8	# spill size = 64
2e08 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2e0c +  spill R21 -&gt; [sp, #8]	# spill size = 64
2e10 +  spill R20 -&gt; [sp, #16]	# spill size = 32
2e14 +  spill R22 -&gt; [sp, #32]	# spill size = 64
2e18 +  spill R9 -&gt; [sp, #40]	# spill size = 64
2e1c +  spill R12 -&gt; [sp, #48]	# spill size = 64
2e20    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #48 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [48]=Oop off=11812/0x2e24}
2e24    #@ShouldNotReachHere

2e30    B464: #	out( N5509 ) &lt;- in( B122 )  Freq: 1.20386e-07
2e30 +  li R11, #-12	# int, #@loadConI
2e34    spill R18 -&gt; R8	# spill size = 64
2e38 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2e3c +  spill R21 -&gt; [sp, #8]	# spill size = 64
2e40 +  spill R20 -&gt; [sp, #16]	# spill size = 32
2e44 +  spill R22 -&gt; [sp, #32]	# spill size = 64
2e48 +  spill R24 -&gt; [sp, #40]	# spill size = 64
2e4c +  spill R9 -&gt; [sp, #20]	# spill size = 32
2e50 +  spill R15 -&gt; [sp, #48]	# spill size = 64
2e54    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #48 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=_ L[12]=sp + #20
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [48]=Oop off=11864/0x2e58}
2e58    #@ShouldNotReachHere

2e64    B465: #	out( N5509 ) &lt;- in( B90 )  Freq: 1.15451e-07
2e64 +  li R11, #-10	# int, #@loadConI
2e68    spill R19 -&gt; R8	# spill size = 64
2e6c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:5 (line 196) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=_ L[1]=_
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=_ L[2]=_ STK[0]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=11888/0x2e70}
2e70    #@ShouldNotReachHere

2e7c    B466: #	out( N5509 ) &lt;- in( B73 )  Freq: 1.05948e-07
2e7c +  li R11, #-187	# int, #@loadConI
2e80    spill R19 -&gt; R8	# spill size = 64
2e84 +  spill R29 -&gt; [sp, #0]	# spill size = 64
2e88 +  spill R10 -&gt; [sp, #8]	# spill size = 64
2e8c +  spill R9 -&gt; [sp, #16]	# spill size = 64
2e90    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.AbstractPipeline::sourceStageSpliterator @ bci:45 (line 282) L[0]=sp + #8 L[1]=_ STK[0]=sp + #16
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:8 (line 762) L[0]=_ L[1]=sp + #0
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=11924/0x2e94}
2e94    #@ShouldNotReachHere

2ea0    B467: #	out( N5509 ) &lt;- in( B76 )  Freq: 1.05465e-07
2ea0 +  li R11, #-187	# int, #@loadConI
2ea4    spill R19 -&gt; R8	# spill size = 64
2ea8 +  spill R9 -&gt; [sp, #0]	# spill size = 64
2eac +  spill R29 -&gt; [sp, #16]	# spill size = 64
2eb0 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2eb4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.Objects::requireNonNull @ bci:1 (line 208) L[0]=sp + #24 STK[0]=sp + #16
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:1 (line 408) L[0]=sp + #0 L[1]=sp + #16
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=11960/0x2eb8}
2eb8    #@ShouldNotReachHere

2ec4    B468: #	out( N5509 ) &lt;- in( B84 )  Freq: 1.05464e-07
2ec4 +  li R11, #-187	# int, #@loadConI
2ec8    spill R19 -&gt; R8	# spill size = 64
2ecc +  spill R9 -&gt; [sp, #0]	# spill size = 64
2ed0 +  spill R20 -&gt; [sp, #16]	# spill size = 64
2ed4 +  spill R7 -&gt; [sp, #24]	# spill size = 64
2ed8 +  spill R7 -&gt; [sp, #32]	# spill size = 64
2edc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::hash @ bci:1 (line 338) L[0]=sp + #32 L[1]=_ STK[0]=sp + #24
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #24 L[2]=#Ptr0x00000040d8292660 STK[0]=sp + #16
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop off=12000/0x2ee0}
2ee0    #@ShouldNotReachHere

2eec    B469: #	out( N5509 ) &lt;- in( B183 )  Freq: 9.73473e-08
2eec +  li R11, #-12	# int, #@loadConI
2ef0    spill R19 -&gt; R8	# spill size = 64
2ef4 +  spill R9 -&gt; [sp, #0]	# spill size = 64
2ef8 +  spill R20 -&gt; [sp, #8]	# spill size = 64
2efc +  spill R21 -&gt; [sp, #16]	# spill size = 32
2f00 +  spill R22 -&gt; [sp, #32]	# spill size = 64
2f04 +  spill R24 -&gt; [sp, #40]	# spill size = 64
2f08 +  spill R31 -&gt; [sp, #48]	# spill size = 64
2f0c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #48 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [48]=Oop off=12048/0x2f10}
2f10    #@ShouldNotReachHere

2f1c    B470: #	out( N5509 ) &lt;- in( B172 )  Freq: 8.02637e-08
2f1c +  li R11, #-12	# int, #@loadConI
2f20    spill R19 -&gt; R8	# spill size = 64
2f24 +  spill R9 -&gt; [sp, #0]	# spill size = 64
2f28 +  spill R20 -&gt; [sp, #8]	# spill size = 64
2f2c +  spill R21 -&gt; [sp, #16]	# spill size = 32
2f30 +  spill R22 -&gt; [sp, #32]	# spill size = 64
2f34 +  spill R12 -&gt; [sp, #40]	# spill size = 64
2f38 +  spill R28 -&gt; [sp, #20]	# spill size = 32
2f3c +  spill R15 -&gt; [sp, #48]	# spill size = 64
2f40    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #48 L[3]=#Ptr0x00000040d8292660 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=_ L[12]=sp + #20
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [48]=Oop off=12100/0x2f44}
2f44    #@ShouldNotReachHere

2f50    B471: #	out( N5509 ) &lt;- in( B230 )  Freq: 1.07146e-08
2f50 +  li R11, #-10	# int, #@loadConI
2f54    spill [sp, #0] -&gt; R8	# spill size = 64
2f58    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:26 (line 627) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#NULL
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=12124/0x2f5c}
2f5c    #@ShouldNotReachHere

2f68    B472: #	out( N5509 ) &lt;- in( B243 )  Freq: 7.14363e-09
2f68 +  li R11, #-10	# int, #@loadConI
2f6c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:26 (line 627) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#NULL
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=12144/0x2f70}
2f70    #@ShouldNotReachHere

2f7c    B473: #	out( B497 ) &lt;- in( B475 )  Freq: 1.29368e-17
2f7c     -- 	// exception oop; no code emitted, #@CreateException
2f7c +  spill R10 -&gt; [sp, #0]	# spill size = 64
2f80 +  j  B497	#@branch

2f84    B474: #	out( B502 ) &lt;- in( B477 )  Freq: 1.94038e-17
2f84     -- 	// exception oop; no code emitted, #@CreateException
2f84 +  spill R10 -&gt; R8	# spill size = 64
2f88 +  j  B502	#@branch

2f8c    B475: #	out( B473 B476 ) &lt;- in( B496 )  Freq: 1.29368e-12
2f8c     -- 	// exception oop; no code emitted, #@CreateException
2f8c +  spill [sp, #0] -&gt; R11	# spill size = 64
2f90 +  spill R10 -&gt; R12	# spill size = 64
2f94    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.Throwable::addSuppressed
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:121 (line 273) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop off=12184/0x2f98}

2f98    B476: #	out( B497 ) &lt;- in( B475 )  Freq: 1.29366e-12
        # Block is sole successor of call
2f98 +  j  B497	#@branch

2f9c    B477: #	out( B474 B478 ) &lt;- in( B501 )  Freq: 1.94038e-12
2f9c     -- 	// exception oop; no code emitted, #@CreateException
2f9c +  spill R8 -&gt; R11	# spill size = 64
2fa0 +  spill R10 -&gt; R12	# spill size = 64
2fa4    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.Throwable::addSuppressed
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:121 (line 273) L[0]=_ L[1]=_ L[2]=_ L[3]=R8 L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=12200/0x2fa8}

2fa8    B478: #	out( B502 ) &lt;- in( B477 )  Freq: 1.94034e-12
        # Block is sole successor of call
2fa8 +  j  B502	#@branch

2fac    B479: #	out( B494 ) &lt;- in( B339 )  Freq: 8.86448e-12
2fac     -- 	// exception oop; no code emitted, #@CreateException
2fac +  j  B494	#@branch

2fb0    B480: #	out( B499 ) &lt;- in( B337 )  Freq: 1.32957e-11
2fb0     -- 	// exception oop; no code emitted, #@CreateException
2fb0 +  j  B499	#@branch

2fb4    B481: #	out( B494 ) &lt;- in( B335 )  Freq: 2.4881e-11
2fb4     -- 	// exception oop; no code emitted, #@CreateException
2fb4 +  j  B494	#@branch

2fb8    B482: #	out( B499 ) &lt;- in( B333 )  Freq: 3.73187e-11
2fb8     -- 	// exception oop; no code emitted, #@CreateException
2fb8 +  j  B499	#@branch

2fbc    B483: #	out( B488 ) &lt;- in( B315 )  Freq: 2.21234e-10
2fbc     -- 	// exception oop; no code emitted, #@CreateException
2fbc +  j  B488	#@branch

2fc0    B484: #	out( B488 ) &lt;- in( B317 )  Freq: 2.21234e-10
2fc0     -- 	// exception oop; no code emitted, #@CreateException
2fc0 +  j  B488	#@branch

2fc4    B485: #	out( B490 ) &lt;- in( B304 )  Freq: 3.31826e-10
2fc4     -- 	// exception oop; no code emitted, #@CreateException
2fc4 +  j  B490	#@branch

2fc8    B486: #	out( B490 ) &lt;- in( B306 )  Freq: 3.31826e-10
2fc8     -- 	// exception oop; no code emitted, #@CreateException
2fc8 +  j  B490	#@branch

2fcc    B487: #	out( B488 ) &lt;- in( B260 )  Freq: 9.9247e-09
2fcc     -- 	// exception oop; no code emitted, #@CreateException

2fcc    B488: #	out( B497 ) &lt;- in( B487 B483 B484 )  Freq: 1.03672e-08
2fcc +  spill R10 -&gt; [sp, #0]	# spill size = 64
2fd0 +  j  B497	#@branch

2fd4    B489: #	out( B490 ) &lt;- in( B254 )  Freq: 1.48859e-08
2fd4     -- 	// exception oop; no code emitted, #@CreateException

2fd4    B490: #	out( B502 ) &lt;- in( B489 B485 B486 )  Freq: 1.55496e-08
2fd4 +  spill R10 -&gt; R8	# spill size = 64
2fd8 +  j  B502	#@branch

2fdc    B491: #	out( B494 ) &lt;- in( B215 )  Freq: 1.61146e-08
2fdc     -- 	// exception oop; no code emitted, #@CreateException
2fdc +  j  B494	#@branch

2fe0    B492: #	out( B499 ) &lt;- in( B206 )  Freq: 2.417e-08
2fe0     -- 	// exception oop; no code emitted, #@CreateException
2fe0 +  j  B499	#@branch

2fe4    B493: #	out( B494 ) &lt;- in( B242 )  Freq: 7.05015e-08
2fe4     -- 	// exception oop; no code emitted, #@CreateException

2fe4    B494: #	out( B496 ) &lt;- in( B493 B481 B479 B491 )  Freq: 8.66498e-08
2fe4 +  spill R10 -&gt; [sp, #0]	# spill size = 64
2fe8 +  j  B496	#@branch

2fec    B495: #	out( B496 ) &lt;- in( B249 )  Freq: 4.27183e-08
2fec     -- 	// exception oop; no code emitted, #@CreateException
2fec +  spill R10 -&gt; [sp, #0]	# spill size = 64

2ff0    B496: #	out( B475 B497 ) &lt;- in( B495 B494 )  Freq: 1.29368e-07
2ff0 +  spill R8 -&gt; R11	# spill size = 64
2ff4 +  # checkcastPP of R11, #@checkCastPP
2ff4    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.stream.AbstractPipeline::close
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:108 (line 273) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop off=12280/0x2ff8}

2ff8    B497: #	out( B505 ) &lt;- in( B488 B473 B476 B496 )  Freq: 1.39734e-07
2ff8 +  spill [sp, #0] -&gt; R10	# spill size = 64
2ffc +  j  B505	#@branch

3000    B498: #	out( B499 ) &lt;- in( B229 )  Freq: 1.05744e-07
3000     -- 	// exception oop; no code emitted, #@CreateException

3000    B499: #	out( B501 ) &lt;- in( B498 B482 B480 B492 )  Freq: 1.29965e-07
3000 +  spill R10 -&gt; R8	# spill size = 64
3004 +  j  B501	#@branch

3008    B500: #	out( B501 ) &lt;- in( B245 )  Freq: 6.40726e-08
3008     -- 	// exception oop; no code emitted, #@CreateException
3008 +  spill R10 -&gt; R8	# spill size = 64

300c    B501: #	out( B477 B502 ) &lt;- in( B500 B499 )  Freq: 1.94038e-07
300c +  spill [sp, #0] -&gt; R11	# spill size = 64
3010 +  # checkcastPP of R11, #@checkCastPP
3010    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.stream.AbstractPipeline::close
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:108 (line 273) L[0]=_ L[1]=_ L[2]=_ L[3]=R8 L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=12308/0x3014}

3014    B502: #	out( B507 ) &lt;- in( B490 B474 B478 B501 )  Freq: 2.09585e-07
3014 +  spill R8 -&gt; R11	# spill size = 64
3018 +  j  B507	#@branch

301c    B503: #	out( B505 ) &lt;- in( B50 )  Freq: 6.66716e-06
301c     -- 	// exception oop; no code emitted, #@CreateException
301c +  j  B505	#@branch

3020    B504: #	out( B505 ) &lt;- in( B97 )  Freq: 4.44512e-06
3020     -- 	// exception oop; no code emitted, #@CreateException

3020    B505: #	out( B507 ) &lt;- in( B503 B497 B504 )  Freq: 1.1252e-05
3020 +  spill R10 -&gt; R11	# spill size = 64
3024 +  j  B507	#@branch

3028    B506: #	out( B507 ) &lt;- in( B2 )  Freq: 9.99999e-06
3028     -- 	// exception oop; no code emitted, #@CreateException
3028 +  spill R10 -&gt; R11	# spill size = 64

302c    B507: #	out( N5509 ) &lt;- in( B506 B502 B505 )  Freq: 2.14616e-05
302c    # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
3038 +  j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='313'>
----------------------- MetaData before Compile_id = 313 ------------------------
{method}
 - this oop:          0x00000040960100c8
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000008  static 
 - name:              &apos;checkBoundsBeginEnd&apos;
 - signature:         &apos;(III)V&apos;
 - max stack:         5
 - max locals:        3
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008318820: 0xaaa i2c: 0x0000004013943c40 c2i: 0x0000004013943c8c c2iUV: 0x0000004013943c58
 - compiled entry     0x000000400c4dd340
 - code size:         63
 - code start:        0x0000004096010058
 - code end (excl):   0x0000004096010097
 - method data:       0x000000409658c430
 - checked ex length: 0
 - linenumber start:  0x0000004096010097
 - localvar length:   3
 - localvar start:    0x00000040960100a2
 - compiled code: nmethod   9149   90       3       java.lang.String::checkBoundsBeginEnd (63 bytes)

------------------------ OptoAssembly for Compile_id = 313 -----------------------
#
#  void ( int, int, int )
#
#r012 c_rarg1   : parm 0: int
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B5 B6 B7 B4 )  Freq: 1

000     B1: #	out( B5 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     blt  R11, zr, B5	#@cmpI_reg_imm0_branch  P=0.000000 C=5374.000000

020     B2: #	out( B6 B3 ) &lt;- in( B1 )  Freq: 1
020 +   bgt  R11, R12, B6	#@cmpI_branch  P=0.000000 C=5374.000000

024     B3: #	out( B7 B4 ) &lt;- in( B2 )  Freq: 0.999999
024 +   bgt  R12, R13, B7	#@cmpI_branch  P=0.000000 C=5374.000000

028     B4: #	out( N1 ) &lt;- in( B3 )  Freq: 0.999999
028     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
040 +   ret	// return register, #@Ret

044     B5: #	out( N1 ) &lt;- in( B1 )  Freq: 5e-07
044 +   spill R11 -&gt; [sp, #8]	# spill size = 32
048 +   spill R12 -&gt; [sp, #0]	# spill size = 32
04c +   spill R13 -&gt; [sp, #4]	# spill size = 32
050 +   li R11, #-187	# int, #@loadConI
054     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:1 (line 4598) L[0]=sp + #8 L[1]=sp + #0 L[2]=sp + #4 STK[0]=sp + #8
        # OopMap {off=88/0x58}
058     #@ShouldNotReachHere

064     B6: #	out( N1 ) &lt;- in( B2 )  Freq: 4.76837e-07
064 +   spill R11 -&gt; [sp, #8]	# spill size = 32
068 +   spill R13 -&gt; [sp, #4]	# spill size = 32
06c +   spill R12 -&gt; [sp, #12]	# spill size = 32
070 +   li R11, #-187	# int, #@loadConI
074     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:6 (line 4598) L[0]=sp + #8 L[1]=sp + #12 L[2]=sp + #4 STK[0]=sp + #8 STK[1]=sp + #12
        # OopMap {off=120/0x78}
078     #@ShouldNotReachHere

084     B7: #	out( N1 ) &lt;- in( B3 )  Freq: 4.76837e-07
084 +   spill R11 -&gt; R8	# spill size = 32
088 +   spill R12 -&gt; [sp, #8]	# spill size = 32
08c +   spill R13 -&gt; [sp, #12]	# spill size = 32
090 +   li R11, #-187	# int, #@loadConI
094     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:11 (line 4598) L[0]=R8 L[1]=sp + #8 L[2]=sp + #12 STK[0]=sp + #8 STK[1]=sp + #12
        # OopMap {off=152/0x98}
098 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='314'>
----------------------- MetaData before Compile_id = 314 ------------------------
{method}
 - this oop:          0x000000409600c2c8
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;substring&apos;
 - signature:         &apos;(II)Ljava/lang/String;&apos;
 - max stack:         4
 - max locals:        5
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008317620: 0xbaa i2c: 0x0000004013945bc0 c2i: 0x0000004013945c0c c2iUV: 0x0000004013945bd8
 - compiled entry     0x000000400c4cf880
 - code size:         58
 - code start:        0x000000409600c240
 - code end (excl):   0x000000409600c27a
 - method data:       0x000000409658c198
 - checked ex length: 0
 - linenumber start:  0x000000409600c27a
 - localvar length:   5
 - localvar start:    0x000000409600c28a
 - compiled code: nmethod   9174   61       3       java.lang.String::substring (58 bytes)

------------------------ OptoAssembly for Compile_id = 314 -----------------------
#
#  java/lang/String:exact * ( java/lang/String:NotNull:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N143: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B18 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lwu  R28, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
040 +   spill R11 -&gt; R29	# spill size = 64
044 +   decode_heap_oop  R11, R28	#@decodeHeapOop
048     lwu  R7, [R11, #12]	# range, #@loadRange
04c     NullCheck R11

04c     B2: #	out( B13 B3 ) &lt;- in( B1 )  Freq: 0.999999
04c +   lb  R28, [R29, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
050 +   sraw  R8, R7, R28	#@rShiftI_reg_reg
054 +   blt  R12, zr, B13	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

058     B3: #	out( B15 B4 ) &lt;- in( B2 )  Freq: 0.999999
058 +   bgt  R12, R13, B15	#@cmpI_branch  P=0.000000 C=5375.000000

05c     B4: #	out( B16 B5 ) &lt;- in( B3 )  Freq: 0.999998
05c +   bgt  R13, R8, B16	#@cmpI_branch  P=0.000000 C=5375.000000

060     B5: #	out( B8 B6 ) &lt;- in( B4 )  Freq: 0.999998
060 +   bne  R12, zr, B8	#@cmpI_reg_imm0_branch  P=0.627721 C=5375.000000

064     B6: #	out( B12 B7 ) &lt;- in( B5 )  Freq: 0.372278
064 +   beq  R13, R8, B12	#@cmpI_branch  P=0.011494 C=2001.000000

068     B7: #	out( B9 ) &lt;- in( B6 )  Freq: 0.367999
068 +   li R12, #0	# int, #@loadConI
06c +   j  B9	#@branch

070     B8: #	out( B9 ) &lt;- in( B5 )  Freq: 0.627719
070 +   subw  R13, R13, R12	#@subI_reg_reg

074     B9: #	out( B14 B10 ) &lt;- in( B7 B8 )  Freq: 0.995718
074 +   bne  R28, zr, B14	#@cmpI_reg_imm0_branch  P=0.000000 C=42978.000000

078     B10: #	out( B17 B11 ) &lt;- in( B9 )  Freq: 0.995718
078     CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringLatin1::newString
        # java.lang.String::substring @ bci:41 (line 2707) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # OopMap {off=124/0x7c}

07c     B11: #	out( N143 ) &lt;- in( B12 B10 )  Freq: 0.999977
07c     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
094 +   ret	// return register, #@Ret

098     B12: #	out( B11 ) &lt;- in( B6 )  Freq: 0.00427907
098 +   spill R29 -&gt; R10	# spill size = 64
09c +   j  B11	#@branch

0a0     B13: #	out( N143 ) &lt;- in( B2 )  Freq: 4.99999e-07
0a0 +   li R11, #-187	# int, #@loadConI
0a4     spill R29 -&gt; [sp, #0]	# spill size = 64
0a8 +   spill R12 -&gt; [sp, #16]	# spill size = 32
0ac +   spill R13 -&gt; [sp, #20]	# spill size = 32
0b0 +   spill R12 -&gt; [sp, #24]	# spill size = 32
0b4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:1 (line 4598) L[0]=sp + #24 L[1]=sp + #20 L[2]=R8 STK[0]=sp + #16
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #0 L[1]=sp + #16 L[2]=sp + #20 L[3]=R8 L[4]=_
        # OopMap {[0]=Oop off=184/0xb8}
0b8     #@ShouldNotReachHere

0c4     B14: #	out( N143 ) &lt;- in( B9 )  Freq: 4.97859e-07
0c4 +   li R11, #-187	# int, #@loadConI
0c8     spill R29 -&gt; R8	# spill size = 64
0cc +   spill R12 -&gt; [sp, #0]	# spill size = 32
0d0 +   spill R13 -&gt; [sp, #4]	# spill size = 32
0d4 +   spill R28 -&gt; [sp, #8]	# spill size = 32
0d8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #8
        # java.lang.String::substring @ bci:28 (line 2707) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=sp + #4
        # OopMap {fp=Oop off=220/0xdc}
0dc     #@ShouldNotReachHere

0e8     B15: #	out( N143 ) &lt;- in( B3 )  Freq: 4.76836e-07
0e8 +   li R11, #-187	# int, #@loadConI
0ec     spill R29 -&gt; [sp, #0]	# spill size = 64
0f0 +   spill R12 -&gt; [sp, #16]	# spill size = 32
0f4 +   spill R13 -&gt; [sp, #20]	# spill size = 32
0f8 +   spill R12 -&gt; [sp, #24]	# spill size = 32
0fc +   spill R13 -&gt; [sp, #28]	# spill size = 32
100     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:6 (line 4598) L[0]=sp + #24 L[1]=sp + #28 L[2]=R8 STK[0]=sp + #16 STK[1]=sp + #20
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #0 L[1]=sp + #16 L[2]=sp + #20 L[3]=R8 L[4]=_
        # OopMap {[0]=Oop off=260/0x104}
104     #@ShouldNotReachHere

110     B16: #	out( N143 ) &lt;- in( B4 )  Freq: 4.76836e-07
110 +   li R11, #-187	# int, #@loadConI
114     spill R29 -&gt; [sp, #0]	# spill size = 64
118 +   spill R12 -&gt; [sp, #16]	# spill size = 32
11c +   spill R13 -&gt; [sp, #20]	# spill size = 32
120 +   spill R13 -&gt; [sp, #24]	# spill size = 32
124     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:11 (line 4598) L[0]=sp + #16 L[1]=sp + #24 L[2]=R8 STK[0]=sp + #20 STK[1]=R8
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #0 L[1]=sp + #16 L[2]=sp + #20 L[3]=R8 L[4]=_
        # OopMap {[0]=Oop off=296/0x128}
128     #@ShouldNotReachHere

134     B17: #	out( N143 ) &lt;- in( B10 )  Freq: 9.95718e-06
134      -- 	// exception oop; no code emitted, #@CreateException
134 +   spill R10 -&gt; R11	# spill size = 64
138 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
144 +   j rethrow_stub	#@RethrowException

14c     B18: #	out( N143 ) &lt;- in( B1 )  Freq: 1.01328e-06
14c +   li R11, #-10	# int, #@loadConI
150     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::substring @ bci:1 (line 2701) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # OopMap {off=340/0x154}
154     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='315'>
----------------------- MetaData before Compile_id = 315 ------------------------
{method}
 - this oop:          0x00000040962b8388
 - method holder:     &apos;sun/nio/fs/UnixPath&apos;
 - constants:         0x00000040962b5440 constant pool [472] {0x00000040962b5440} for &apos;sun/nio/fs/UnixPath&apos; cache=0x00000040962ba1a0
 - access:            0xc1000001  public 
 - name:              &apos;relativize&apos;
 - signature:         &apos;(Ljava/nio/file/Path;)Lsun/nio/fs/UnixPath;&apos;
 - max stack:         6
 - max locals:        15
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      8
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bd00: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c556540
 - code size:         408
 - code start:        0x00000040962b80e8
 - code end (excl):   0x00000040962b8280
 - method data:       0x0000004096496be8
 - checked ex length: 0
 - linenumber start:  0x00000040962b8280
 - localvar length:   17
 - localvar start:    0x00000040962b82ba
 - compiled code: nmethod   9732  275       3       sun.nio.fs.UnixPath::relativize (408 bytes)

------------------------ OptoAssembly for Compile_id = 315 -----------------------
#
#  sun/nio/fs/UnixPath * ( sun/nio/fs/UnixPath:NotNull *, java/nio/file/Path * )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixPath:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/nio/file/Path *
# -- Old sp -- Framesize: 128 --
#r263 sp+124: in_preserve
#r262 sp+120: return address
#r261 sp+116: in_preserve
#r260 sp+112: saved fp register
#r259 sp+108: pad2, stack alignment
#r258 sp+104: pad2, stack alignment
#r257 sp+100: Fixed slot 1
#r256 sp+96: Fixed slot 0
#r287 sp+92: spill
#r286 sp+88: spill
#r285 sp+84: spill
#r284 sp+80: spill
#r283 sp+76: spill
#r282 sp+72: spill
#r281 sp+68: spill
#r280 sp+64: spill
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
0000    N2499: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0000    # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

0020    B1: #	out( B238 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0020    # stack bang size=128
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #128
	
003c    spill R11 -&gt; R7	# spill size = 64
0040    lwu  R29, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0044    NullCheck R12

0044    B2: #	out( B215 B3 ) &lt;- in( B1 )  Freq: 1
0044 +  mv  R28, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d060f5a0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0054 +  bne  R29, R28, B215	#@cmpN_branch  P=0.000000 C=-1.000000

0058    B3: #	out( B226 B4 ) &lt;- in( B2 )  Freq: 1
0058 +  lwu  R28, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
005c +  # checkcastPP of R12, #@checkCastPP
005c    lwu  R7, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
0060 +  decode_heap_oop  R17, R28	#@decodeHeapOop
0064    spill R11 -&gt; R14	# spill size = 64
0068 +  decode_heap_oop  R9, R7	#@decodeHeapOop
006c    lwu  R30, [R9, #12]	# range, #@loadRange
0070    NullCheck R9

0070    B4: #	out( B227 B5 ) &lt;- in( B3 )  Freq: 0.999999
0070    lwu  R16, [R17, #12]	# range, #@loadRange
0074    NullCheck R17

0074    B5: #	out( B31 B6 ) &lt;- in( B4 )  Freq: 0.999997
0074 +  spill R16 -&gt; R8	# spill size = 32
0078 +  CMove R8, (R30 lt R16), R8, R30	#@cmovI_cmpI
	
0080 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0080    ble  R8, zr, B31	#@cmpI_reg_imm0_branch  P=0.045878 C=22320.000000

0084    B6: #	out( B190 B7 ) &lt;- in( B5 )  Freq: 0.954119
0084 +  addiw  R7, R8, #-1	#@addI_reg_imm
0088 +  bleu  R30, zr, B190	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

008c    B7: #	out( B190 B8 ) &lt;- in( B6 )  Freq: 0.954119
008c +  bgeu  R7, R30, B190	#@cmpU_branch  P=0.000001 C=-1.000000

0090    B8: #	out( B190 B9 ) &lt;- in( B7 )  Freq: 0.954118
0090 +  lbu  R10, [R9, #16]	# byte, #@loadUB
0094 +  bleu  R16, zr, B190	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

0098    B9: #	out( B190 B10 ) &lt;- in( B8 )  Freq: 0.954117
0098 +  bgeu  R7, R16, B190	#@cmpU_branch  P=0.000001 C=-1.000000

009c    B10: #	out( B214 B11 ) &lt;- in( B9 )  Freq: 0.954116
009c +  lbu  R13, [R17, #16]	# byte, #@loadUB
00a0 +  bne  R10, R13, B214	#@cmpI_branch  P=0.000000 C=21296.000000

00a4    B11: #	out( B191 B12 ) &lt;- in( B10 )  Freq: 0.954115
00a4 +  li R29, #-2147483648	# int, #@loadConI
00a8 +  addiw  R15, R8, #-3	#@addI_reg_imm
00ac    CMove R15, (R7 lt R15), R15, R29	#@cmovI_cmpI
	
00b4 +  li R7, #1	# int, #@loadConI
00b8 +  ble  R15, R7, B191	#@cmpI_branch  P=0.000001 C=-1.000000

00bc    B12: #	out( B192 B13 ) &lt;- in( B11 )  Freq: 0.954114
00bc +  li R28, #1	# int, #@loadConI
00c0 +  bleu  R16, R28, B192	#@cmpU_branch  P=0.000001 C=-1.000000

00c4    B13: #	out( B193 B14 ) &lt;- in( B12 )  Freq: 0.954113
00c4 +  bleu  R30, R7, B193	#@cmpU_branch  P=0.000001 C=-1.000000

00c8    B14: #	out( B194 B15 ) &lt;- in( B13 )  Freq: 0.954112
00c8 +  li R28, #4	# int, #@loadConI
00cc +  bleu  R30, R28, B194	#@cmpU_branch  P=0.000001 C=-1.000000

00d0    B15: #	out( B195 B16 ) &lt;- in( B14 )  Freq: 0.954111
00d0 +  li R7, #4	# int, #@loadConI
00d4 +  bleu  R16, R7, B195	#@cmpU_branch  P=0.000001 C=-1.000000

00d8    B16: #	out( B17 ) &lt;- in( B15 )  Freq: 0.95411
00d8 +  li R31, #1	# int, #@loadConI

00dc    B17: #	out( B18 ) &lt;- in( B16 B23 ) Loop( B17-B23 ) Freq: 20.7787
00dc +  li R29, #0	# int, #@loadConI
00e0 +  subw  R7, R15, R31	#@subI_reg_reg
00e4    CMove R7, (R15 lt R31), R7, R29	#@cmovI_cmpI
	
00ec +  li R10, #4000	# int, #@loadConI
00f4 +  li R28, #4000	# int, #@loadConI
00fc    CMove R7, (R7 gtu R28), R7, R10	#@cmovI_cmpU
	
0104 +  addw  R7, R7, R31	#@addI_reg_reg
        nop 	# 4 bytes pad for loops and calls

0110    B18: #	out( B157 B19 ) &lt;- in( B17 B22 ) Loop( B18-B22 inner main of N315 strip mined) Freq: 452.892
0110 +  addw  R11, R31, zr	#@convI2L_reg_reg
0114 +  add R13, R9, R11	# ptr, #@addP_reg_reg
0118 +  add R11, R17, R11	# ptr, #@addP_reg_reg
011c +  lbu  R29, [R13, #16]	# byte, #@loadUB
0120 +  lbu  R10, [R13, #19]	# byte, #@loadUB
0124 +  lbu  R28, [R13, #18]	# byte, #@loadUB
0128 +  lbu  R19, [R13, #17]	# byte, #@loadUB
012c +  lbu  R18, [R11, #16]	# byte, #@loadUB
0130 +  lbu  R13, [R11, #19]	# byte, #@loadUB
0134 +  lbu  R21, [R11, #18]	# byte, #@loadUB
0138 +  lbu  R11, [R11, #17]	# byte, #@loadUB
013c +  bne  R29, R18, B157	#@cmpI_branch  P=0.000000 C=21296.000000

0140    B19: #	out( B160 B20 ) &lt;- in( B18 )  Freq: 452.892
0140 +  bne  R19, R11, B160	#@cmpI_branch  P=0.000000 C=21296.000000

0144    B20: #	out( B158 B21 ) &lt;- in( B19 )  Freq: 452.892
0144 +  bne  R28, R21, B158	#@cmpI_branch  P=0.000000 C=21296.000000

0148    B21: #	out( B161 B22 ) &lt;- in( B20 )  Freq: 452.892
0148 +  bne  R10, R13, B161	#@cmpI_branch  P=0.000000 C=21296.000000

014c    B22: #	out( B18 B23 ) &lt;- in( B21 )  Freq: 452.891
014c +  addiw  R31, R31, #4	#@addI_reg_imm
0150 +  blt  R31, R7, B18	#@cmpI_loop  P=0.954122 C=21296.000000

0154    B23: #	out( B17 B24 ) &lt;- in( B22 )  Freq: 20.7778
0154 +  ld  R11, [R23, #920]	# ptr, #@loadP
0158 +  lwu zr, [R11]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.UnixPath::compareTo @ bci:85 (line 728) L[0]=_ L[1]=_ L[2]=R30 L[3]=R16 L[4]=R8 L[5]=R9 L[6]=R17 L[7]=R31 L[8]=_ L[9]=_
        # sun.nio.fs.UnixPath::equals @ bci:14 (line 735) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.UnixPath::relativize @ bci:7 (line 393) L[0]=R14 L[1]=R12 L[2]=R12 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {c_rarg2=Oop c_rarg4=Oop c_rarg7=Oop x9=Oop off=344/0x158}
015c +  blt  R31, R15, B17	#@cmpI_branch  P=0.954122 C=21296.000000

0160    B24: #	out( B31 B25 ) &lt;- in( B191 B23 )  Freq: 0.953247
0160 +  bge  R31, R8, B31	#@cmpI_branch  P=0.500000 C=-1.000000

0164    B25: #	out( B203 B26 ) &lt;- in( B24 )  Freq: 0.476624
0164 +  # castII of R31, #@castII
0164    bgeu  R31, R30, B203	#@cmpU_branch  P=0.000001 C=-1.000000

0168    B26: #	out( B204 B27 ) &lt;- in( B25 )  Freq: 0.476623
0168 +  spill R31 -&gt; R28	# spill size = 32
016c +  # castII of R28, #@castII
016c    bgeu  R28, R30, B204	#@cmpU_branch  P=0.000001 C=-1.000000

0170    B27: #	out( B205 B28 ) &lt;- in( B26 )  Freq: 0.476623
0170 +  bgeu  R31, R16, B205	#@cmpU_branch  P=0.000001 C=-1.000000

0174    B28: #	out( B206 B29 ) &lt;- in( B27 )  Freq: 0.476622
0174 +  bgeu  R28, R16, B206	#@cmpU_branch  P=0.000001 C=-1.000000

0178    B29: #	out( B162 B30 ) &lt;- in( B28 B30 ) Loop( B29-B30 inner post of N2754) Freq: 0.953243
0178 +  addw  R7, R31, zr	#@convI2L_reg_reg
017c +  add R28, R9, R7	# ptr, #@addP_reg_reg
0180 +  lbu  R10, [R28, #16]	# byte, #@loadUB
0184 +  add R7, R17, R7	# ptr, #@addP_reg_reg
0188 +  lbu  R13, [R7, #16]	# byte, #@loadUB
018c +  bne  R10, R13, B162	#@cmpI_branch  P=0.000000 C=21296.000000

0190    B30: #	out( B29 B31 ) &lt;- in( B29 )  Freq: 0.953243
0190 +  addiw  R31, R31, #1	#@addI_reg_imm
0194 +  blt  R31, R8, B29	#@cmpI_loop  P=0.500000 C=21296.000000

0198    B31: #	out( B186 B32 ) &lt;- in( B24 B5 B30 )  Freq: 0.999123
0198 +  beq  R30, R16, B186	#@cmpI_branch  P=0.000001 C=20718.000000

019c    B32: #	out( B196 B33 ) &lt;- in( B31 )  Freq: 0.999122
019c +  bleu  R16, zr, B196	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=4608.000000

01a0    B33: #	out( B197 B34 ) &lt;- in( B32 )  Freq: 0.999122
01a0 +  lb  R8, [R17, #16]	# byte, #@loadB
01a4 +  li R7, #47	# int, #@loadConI
01a8 +  bne  R8, R7, B197	#@cmpI_branch  P=0.000000 C=4608.000000

01ac    B34: #	out( B198 B35 ) &lt;- in( B33 )  Freq: 0.999121
01ac +  bleu  R30, zr, B198	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=4608.000000

01b0    B35: #	out( B199 B36 ) &lt;- in( B34 )  Freq: 0.999121
01b0 +  lb  R8, [R9, #16]	# byte, #@loadB
01b4 +  bne  R8, R7, B199	#@cmpI_branch  P=0.000000 C=4608.000000

01b8    B36: #	out( B248 B37 ) &lt;- in( B35 )  Freq: 0.99912
01b8 +  spill R12 -&gt; [sp, #0]	# spill size = 64
01bc +  spill R14 -&gt; R8	# spill size = 64
01c0 +  spill R14 -&gt; R11	# spill size = 64
01c4    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::hasDotOrDotDot
        # sun.nio.fs.UnixPath::relativize @ bci:51 (line 405) L[0]=R8 L[1]=sp + #0 L[2]=sp + #0 L[3]=R8 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [0]=Oop off=456/0x1c8}

01c8    B37: #	out( B200 B38 ) &lt;- in( B36 )  Freq: 0.9991
        # Block is sole successor of call
01c8 +  bne  R10, zr, B200	#@cmpI_reg_imm0_branch  P=0.000000 C=2047.000000

01cc    B38: #	out( B247 B39 ) &lt;- in( B37 )  Freq: 0.9991
01cc +  spill [sp, #0] -&gt; R11	# spill size = 64
01d0    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::hasDotOrDotDot
        # sun.nio.fs.UnixPath::relativize @ bci:58 (line 405) L[0]=R8 L[1]=sp + #0 L[2]=sp + #0 L[3]=R8 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [0]=Oop off=468/0x1d4}

01d4    B39: #	out( B207 B40 ) &lt;- in( B38 )  Freq: 0.99908
        # Block is sole successor of call
01d4 +  bne  R10, zr, B207	#@cmpI_reg_imm0_branch  P=0.000000 C=2047.000000

01d8    B40: #	out( B246 B41 ) &lt;- in( B39 )  Freq: 0.999079
01d8 +  spill R8 -&gt; R11	# spill size = 64
01dc    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getNameCount @ bci:1 (line 295) L[0]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:75 (line 410) L[0]=R8 L[1]=sp + #0 L[2]=sp + #0 L[3]=R8 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [0]=Oop off=480/0x1e0}

01e0    B41: #	out( B228 B42 ) &lt;- in( B40 )  Freq: 0.999059
        # Block is sole successor of call
01e0 +  spill R8 -&gt; R29	# spill size = 64
01e4 +  lwu  R28, [R29, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
01e8 +  #@membar_acquire
	fence ir iorw
01ec +  decode_heap_oop  R7, R28	#@decodeHeapOop
01f0    lwu  R8, [R7, #12]	# range, #@loadRange
01f4    NullCheck R7

01f4    B42: #	out( B245 B43 ) &lt;- in( B41 )  Freq: 0.999058
01f4 +  spill R29 -&gt; [sp, #24]	# spill size = 64
01f8 +  spill [sp, #0] -&gt; R11	# spill size = 64
01fc    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getNameCount @ bci:1 (line 295) L[0]=sp + #0
        # sun.nio.fs.UnixPath::relativize @ bci:81 (line 411) L[0]=sp + #24 L[1]=sp + #0 L[2]=sp + #0 L[3]=sp + #24 L[4]=R8 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[0]=Oop [24]=Oop off=512/0x200}

0200    B43: #	out( B229 B44 ) &lt;- in( B42 )  Freq: 0.999038
        # Block is sole successor of call
0200 +  spill [sp, #0] -&gt; R22	# spill size = 64
0204 +  lwu  R7, [R22, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0208 +  #@membar_acquire
	fence ir iorw
020c +  decode_heap_oop  R7, R7	#@decodeHeapOop
0210    lwu  R28, [R7, #12]	# range, #@loadRange
0214    NullCheck R7

0214    B44: #	out( B144 B45 ) &lt;- in( B43 )  Freq: 0.999037
0214 +  spill R28 -&gt; R29	# spill size = 32
0218 +  CMove R29, (R8 lt R28), R29, R8	#@cmovI_cmpI
	
0220 +  spill R8 -&gt; R7	# spill size = 32
0224 +  ble  R29, zr, B144	#@cmpI_reg_imm0_branch  P=0.111111 C=18423.000000

0228    B45: #	out( B49 ) &lt;- in( B44 )  Freq: 0.888033
0228 +  li R19, #0	# int, #@loadConI
022c +  j  B49	#@branch

0230    B46: #	out( B172 B47 ) &lt;- in( B106 B87 B111 ) top-of-loop Freq: 7.92709
0230 +  bne  R21, R20, B172	#@cmpI_branch  P=0.000001 C=20718.000000

0234    B47: #	out( B112 B48 ) &lt;- in( B46 )  Freq: 7.92708
0234 +  spill [sp, #40] -&gt; R29	# spill size = 32
0238 +  bge  R19, R29, B112	#@cmpI_loop  P=0.111111 C=16376.000000

023c    B48: #	out( B49 ) &lt;- in( B47 )  Freq: 7.04629
023c +  spill [sp, #32] -&gt; R7	# spill size = 32
0240 +  spill [sp, #36] -&gt; R28	# spill size = 32

0244    B49: #	out( B249 B50 ) &lt;- in( B45 B48 ) Loop( B49-B48 ) Freq: 7.93449
0244 +  spill R19 -&gt; [sp, #0]	# spill size = 32
0248 +  spill R29 -&gt; [sp, #40]	# spill size = 32
024c +  spill R28 -&gt; [sp, #36]	# spill size = 32
0250 +  spill R7 -&gt; [sp, #32]	# spill size = 32
0254 +  spill R22 -&gt; [sp, #8]	# spill size = 64
0258 +  spill [sp, #24] -&gt; R11	# spill size = 64
025c    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getName @ bci:1 (line 301) L[0]=sp + #24 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=sp + #24 L[1]=sp + #8 L[2]=sp + #8 L[3]=sp + #24 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=sp + #0 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[8]=Oop [24]=Oop off=608/0x260}

0260    B50: #	out( B216 B51 ) &lt;- in( B49 )  Freq: 7.93433
        # Block is sole successor of call
0260 +  spill [sp, #24] -&gt; R9	# spill size = 64
0264 +  lwu  R28, [R9, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0268 +  #@membar_acquire
	fence ir iorw
026c +  decode_heap_oop  R7, R28	#@decodeHeapOop
0270    lwu  R8, [R7, #12]	# range, #@loadRange
0274    NullCheck R7

0274    B51: #	out( B183 B52 ) &lt;- in( B50 )  Freq: 7.93432
0274 +  spill [sp, #0] -&gt; R30	# spill size = 32
0278 +  bge  R30, R8, B183	#@cmpI_branch  P=0.000000 C=5376.000000

027c    B52: #	out( B217 B53 ) &lt;- in( B51 )  Freq: 7.93431
027c +  lwu  R7, [R9, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0280 +  #@membar_acquire
	fence ir iorw
0284 +  decode_heap_oop  R8, R7	#@decodeHeapOop
0288    lwu  R28, [R8, #12]	# range, #@loadRange
028c    NullCheck R8

028c    B53: #	out( B167 B54 ) &lt;- in( B52 )  Freq: 7.93431
028c +  bgeu  R30, R28, B167	#@cmpU_branch  P=0.000001 C=-1.000000

0290    B54: #	out( B218 B55 ) &lt;- in( B53 )  Freq: 7.9343
0290 +  addw  R28, R30, zr	#@convI2L_reg_reg
0294 +  slli  R11, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0298 +  lwu  R7, [R9, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
029c +  add R28, R8, R11	# ptr, #@addP_reg_reg
02a0 +  lw  R29, [R28, #16]	# int, #@loadI
02a4 +  decode_heap_oop  R7, R7	#@decodeHeapOop
02a8 +  #@membar_acquire
	fence ir iorw
02ac    lwu  R7, [R7, #12]	# range, #@loadRange
02b0    NullCheck R7

02b0    B55: #	out( B140 B56 ) &lt;- in( B54 )  Freq: 7.93429
02b0 +  addiw  R28, R7, #-1	#@addI_reg_imm
02b4 +  addiw  R10, R30, #1	#@addI_reg_imm
02b8 +  beq  R30, R28, B140	#@cmpI_branch  P=0.084635 C=5376.000000

02bc    B56: #	out( B224 B57 ) &lt;- in( B55 )  Freq: 7.26277
02bc +  lwu  R7, [R9, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
02c0 +  #@membar_acquire
	fence ir iorw
02c4 +  decode_heap_oop  R8, R7	#@decodeHeapOop
02c8    lwu  R28, [R8, #12]	# range, #@loadRange
02cc    NullCheck R8

02cc    B57: #	out( B179 B58 ) &lt;- in( B56 )  Freq: 7.26276
02cc +  bgeu  R10, R28, B179	#@cmpU_branch  P=0.000001 C=-1.000000

02d0    B58: #	out( B59 ) &lt;- in( B57 )  Freq: 7.26275
02d0 +  add R7, R8, R11	# ptr, #@addP_reg_reg
02d4 +  lw  R28, [R7, #20]	# int, #@loadI
02d8 +  subw  R7, R28, R29	#@subI_reg_reg
02dc +  addiw  R7, R7, #-1	#@addI_reg_imm

02e0    B59: #	out( B60 B60 ) &lt;- in( B58 B141 )  Freq: 7.93428
02e0 +  lwu  R31, [R9, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
02e4 +  li R13, #1048576	# int, #@loadConI
02e8 +  decode_heap_oop  R12, R31	#@decodeHeapOop
02ec +  addw  R28, R7, zr	#@convI2L_reg_reg
02f0 +  bleu  R7, R13, B60	#@cmpU_branch  P=0.999999 C=-1.000000

02f4    B60: #	out( B219 B61 ) &lt;- in( B59 B59 )  Freq: 7.93428
02f4    lwu  R31, [R12, #12]	# range, #@loadRange
02f8    NullCheck R12

02f8    B61: #	out( B170 B62 ) &lt;- in( B60 )  Freq: 7.93427
02f8 +  addw  R13, R7, R29	#@addI_reg_reg
02fc +  blt  R29, zr, B170	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0300    B62: #	out( B170 B63 ) &lt;- in( B61 )  Freq: 7.93426
0300 +  bltu  R31, R13, B170	#@cmpU_branch  P=0.000001 C=-1.000000

0304    B63: #	out( B153 B64 ) &lt;- in( B62 )  Freq: 7.93425
0304 +  li R31, #1048576	# int, #@loadConI
0308 +  bgtu  R7, R31, B153	#@cmpU_branch  P=0.000001 C=-1.000000

030c    B64: #	out( B153 B65 ) &lt;- in( B63 )  Freq: 7.93424
030c +  addi  R28, R28, #23	#@addL_reg_imm
0310 +  ld  R13, [R23, #288]	# ptr, #@loadP
0314 +  andi  R28, R28, #-8	#@andL_reg_imm
0318 +  ld  R31, [R23, #304]	# ptr, #@loadP
031c +  add R28, R13, R28	# ptr, #@addP_reg_reg
0320 +  bgeu  R28, R31, B153	#@cmpP_branch  P=0.000100 C=-1.000000

0324    B65: #	out( B66 ) &lt;- in( B64 )  Freq: 7.93345
0324 +  sd  R28, [R23, #288]	# ptr, #@storeP
0328 +  li R28, #1	# long, #@loadConL
032c +  mv  R31, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
033c +  sd  R28, [R13]	# long, #@storeL
0340 +  sw  R31, [R13, #8]	# compressed klass ptr, #@storeNKlass
0344 +  sw  R7, [R13, #12]	# int, #@storeI

0348    B66: #	out( B168 B67 ) &lt;- in( B154 B65 )  Freq: 7.93425
0348    
0348 +  # checkcastPP of R13, #@checkCastPP
0348    addi  R28, R13, #16	# ptr, #@addP_reg_imm
034c +  # castII of R7, #@castII
034c    beq  R7, zr, B168	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0350    B67: #	out( B68 ) &lt;- in( B66 )  Freq: 7.93424
0350 +  spill R28 -&gt; [sp, #48]	# spill size = 64
0354 +  addw  R28, R29, zr	#@convI2L_reg_reg
0358 +  add R28, R12, R28	# ptr, #@addP_reg_reg
035c    spill R10 -&gt; [sp, #4]	# spill size = 32
0360 +  addi  R10, R28, #16	# ptr, #@addP_reg_imm
0364    spill R11 -&gt; [sp, #16]	# spill size = 64
0368 +  spill R13 -&gt; [sp, #64]	# spill size = 64
036c +  spill R30 -&gt; [sp, #0]	# spill size = 32
0370 +  spill R7 -&gt; [sp, #44]	# spill size = 32
0374 +  addw  R12, R7, zr	#@convI2L_reg_reg
0378    spill [sp, #48] -&gt; R11	# spill size = 64
037c +  CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

0380    B68: #	out( B251 B69 ) &lt;- in( B67 B168 )  Freq: 7.93425
0380    
0380    lwu  R28, [R9, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
0384 +  decode_heap_oop  R7, R28	#@decodeHeapOop
0388    spill R9 -&gt; [sp, #24]	# spill size = 64
038c +  spill R7 -&gt; [sp, #72]	# spill size = 64
0390 +  spill [sp, #8] -&gt; R11	# spill size = 64
0394    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getName @ bci:1 (line 301) L[0]=sp + #8 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=sp + #24 L[1]=sp + #8 L[2]=sp + #8 L[3]=sp + #24 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=sp + #0 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#ScObj0
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=sp + #72, [path :2]=sp + #64, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # OopMap {[8]=Oop [24]=Oop [48]=Derived_oop_[64] [64]=Oop [72]=Oop off=920/0x398}

0398    B69: #	out( B220 B70 ) &lt;- in( B68 )  Freq: 7.93409
        # Block is sole successor of call
0398 +  spill [sp, #8] -&gt; R22	# spill size = 64
039c +  lwu  R7, [R22, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
03a0 +  #@membar_acquire
	fence ir iorw
03a4 +  decode_heap_oop  R7, R7	#@decodeHeapOop
03a8    lwu  R8, [R7, #12]	# range, #@loadRange
03ac    NullCheck R7

03ac    B70: #	out( B184 B71 ) &lt;- in( B69 )  Freq: 7.93408
03ac +  spill [sp, #0] -&gt; R9	# spill size = 32
03b0 +  bge  R9, R8, B184	#@cmpI_branch  P=0.000000 C=5376.000000

03b4    B71: #	out( B221 B72 ) &lt;- in( B70 )  Freq: 7.93408
03b4 +  lwu  R28, [R22, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
03b8 +  #@membar_acquire
	fence ir iorw
03bc +  decode_heap_oop  R8, R28	#@decodeHeapOop
03c0    lwu  R7, [R8, #12]	# range, #@loadRange
03c4    NullCheck R8

03c4    B72: #	out( B169 B73 ) &lt;- in( B71 )  Freq: 7.93407
03c4 +  bgeu  R9, R7, B169	#@cmpU_branch  P=0.000001 C=-1.000000

03c8    B73: #	out( B222 B74 ) &lt;- in( B72 )  Freq: 7.93406
03c8 +  lwu  R28, [R22, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
03cc +  decode_heap_oop  R7, R28	#@decodeHeapOop
03d0    spill [sp, #16] -&gt; R30	# spill size = 64
03d4 +  add R28, R8, R30	# ptr, #@addP_reg_reg
03d8 +  lw  R29, [R28, #16]	# int, #@loadI
03dc +  #@membar_acquire
	fence ir iorw
03e0    lwu  R7, [R7, #12]	# range, #@loadRange
03e4    NullCheck R7

03e4    B74: #	out( B142 B75 ) &lt;- in( B73 )  Freq: 7.93406
03e4 +  addiw  R28, R7, #-1	#@addI_reg_imm
03e8 +  beq  R9, R28, B142	#@cmpI_branch  P=0.084635 C=5376.000000

03ec    B75: #	out( B225 B76 ) &lt;- in( B74 )  Freq: 7.26255
03ec +  lwu  R7, [R22, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
03f0 +  #@membar_acquire
	fence ir iorw
03f4 +  decode_heap_oop  R8, R7	#@decodeHeapOop
03f8    lwu  R28, [R8, #12]	# range, #@loadRange
03fc    NullCheck R8

03fc    B76: #	out( B180 B77 ) &lt;- in( B75 )  Freq: 7.26255
03fc +  spill [sp, #4] -&gt; R19	# spill size = 32
0400 +  bgeu  R19, R28, B180	#@cmpU_branch  P=0.000001 C=-1.000000

0404    B77: #	out( B78 ) &lt;- in( B76 )  Freq: 7.26254
0404 +  add R7, R8, R30	# ptr, #@addP_reg_reg
0408 +  lw  R7, [R7, #20]	# int, #@loadI
040c +  subw  R28, R7, R29	#@subI_reg_reg
0410 +  addiw  R20, R28, #-1	#@addI_reg_imm

0414    B78: #	out( B79 B79 ) &lt;- in( B77 B143 )  Freq: 7.93404
0414 +  lwu  R28, [R22, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
0418 +  li R30, #1048576	# int, #@loadConI
041c +  decode_heap_oop  R8, R28	#@decodeHeapOop
0420 +  addw  R7, R20, zr	#@convI2L_reg_reg
0424 +  bleu  R20, R30, B79	#@cmpU_branch  P=0.999999 C=-1.000000

0428    B79: #	out( B223 B80 ) &lt;- in( B78 B78 )  Freq: 7.93404
0428    lwu  R28, [R8, #12]	# range, #@loadRange
042c    NullCheck R8

042c    B80: #	out( B171 B81 ) &lt;- in( B79 )  Freq: 7.93403
042c +  addw  R31, R20, R29	#@addI_reg_reg
0430 +  blt  R29, zr, B171	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0434    B81: #	out( B171 B82 ) &lt;- in( B80 )  Freq: 7.93402
0434 +  bltu  R28, R31, B171	#@cmpU_branch  P=0.000001 C=-1.000000

0438    B82: #	out( B155 B83 ) &lt;- in( B81 )  Freq: 7.93402
0438 +  li R28, #1048576	# int, #@loadConI
043c +  bgtu  R20, R28, B155	#@cmpU_branch  P=0.000001 C=-1.000000

0440    B83: #	out( B155 B84 ) &lt;- in( B82 )  Freq: 7.93401
0440 +  addi  R7, R7, #23	#@addL_reg_imm
0444 +  ld  R24, [R23, #288]	# ptr, #@loadP
0448 +  andi  R7, R7, #-8	#@andL_reg_imm
044c +  ld  R28, [R23, #304]	# ptr, #@loadP
0450 +  add R7, R24, R7	# ptr, #@addP_reg_reg
0454 +  bgeu  R7, R28, B155	#@cmpP_branch  P=0.000100 C=-1.000000

0458    B84: #	out( B85 ) &lt;- in( B83 )  Freq: 7.93322
0458 +  sd  R7, [R23, #288]	# ptr, #@storeP
045c +  li R7, #1	# long, #@loadConL
0460 +  mv  R28, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0470 +  sd  R7, [R24]	# long, #@storeL
0474 +  sw  R28, [R24, #8]	# compressed klass ptr, #@storeNKlass
0478 +  sw  R20, [R24, #12]	# int, #@storeI

047c    B85: #	out( B87 B86 ) &lt;- in( B156 B84 )  Freq: 7.93402
047c    
047c +  # castII of R20, #@castII
047c    # checkcastPP of R24, #@checkCastPP
047c    spill [sp, #44] -&gt; R21	# spill size = 32
0480 +  spill R20 -&gt; R18	# spill size = 32
0484 +  addi  R25, R24, #16	# ptr, #@addP_reg_imm
0488 +  CMove R18, (R21 lt R20), R18, R21	#@cmovI_cmpI
	
0490    beq  R20, zr, B87	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0494    B86: #	out( B87 ) &lt;- in( B85 )  Freq: 7.93401
0494 +  addw  R7, R29, zr	#@convI2L_reg_reg
0498 +  add R7, R8, R7	# ptr, #@addP_reg_reg
049c +  addw  R12, R20, zr	#@convI2L_reg_reg
04a0    spill R25 -&gt; R11	# spill size = 64
04a4 +  addi  R10, R7, #16	# ptr, #@addP_reg_imm
04a8 +  CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

04ac    B87: #	out( B46 B88 ) &lt;- in( B86 B85 )  Freq: 7.93402
04ac    
04ac    ble  R18, zr, B46	#@cmpI_reg_imm0_branch  P=0.045878 C=22320.000000

04b0    B88: #	out( B173 B89 ) &lt;- in( B87 )  Freq: 7.57002
04b0 +  addiw  R30, R18, #-1	#@addI_reg_imm
04b4 +  beq  R21, zr, B173	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

04b8    B89: #	out( B173 B90 ) &lt;- in( B88 )  Freq: 7.57001
04b8 +  bgeu  R30, R21, B173	#@cmpU_branch  P=0.000001 C=-1.000000

04bc    B90: #	out( B173 B91 ) &lt;- in( B89 )  Freq: 7.57
04bc +  spill [sp, #48] -&gt; R7	# spill size = 64
04c0 +  lbu  R29, [R7]	# byte, #@loadUB
04c4 +  beq  R20, zr, B173	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

04c8    B91: #	out( B173 B92 ) &lt;- in( B90 )  Freq: 7.57
04c8 +  bgeu  R30, R20, B173	#@cmpU_branch  P=0.000001 C=-1.000000

04cc    B92: #	out( B185 B93 ) &lt;- in( B91 )  Freq: 7.56999
04cc +  lbu  R31, [R25]	# byte, #@loadUB
04d0 +  bne  R29, R31, B185	#@cmpI_branch  P=0.000000 C=21296.000000

04d4    B93: #	out( B174 B94 ) &lt;- in( B92 )  Freq: 7.56998
04d4 +  li R29, #-2147483648	# int, #@loadConI
04d8 +  addiw  R7, R18, #-3	#@addI_reg_imm
04dc    CMove R7, (R30 lt R7), R7, R29	#@cmovI_cmpI
	
04e4 +  li R28, #1	# int, #@loadConI
04e8 +  ble  R7, R28, B174	#@cmpI_branch  P=0.000001 C=-1.000000

04ec    B94: #	out( B175 B95 ) &lt;- in( B93 )  Freq: 7.56998
04ec +  li R29, #1	# int, #@loadConI
04f0 +  bleu  R20, R29, B175	#@cmpU_branch  P=0.000001 C=-1.000000

04f4    B95: #	out( B176 B96 ) &lt;- in( B94 )  Freq: 7.56997
04f4 +  bleu  R21, R28, B176	#@cmpU_branch  P=0.000001 C=-1.000000

04f8    B96: #	out( B177 B97 ) &lt;- in( B95 )  Freq: 7.56996
04f8 +  li R29, #4	# int, #@loadConI
04fc +  bleu  R21, R29, B177	#@cmpU_branch  P=0.000001 C=-1.000000

0500    B97: #	out( B178 B98 ) &lt;- in( B96 )  Freq: 7.56995
0500 +  li R28, #4	# int, #@loadConI
0504 +  bleu  R20, R28, B178	#@cmpU_branch  P=0.000001 C=-1.000000

0508    B98: #	out( B99 ) &lt;- in( B97 )  Freq: 7.56995
0508 +  li R30, #1	# int, #@loadConI

050c    B99: #	out( B100 ) &lt;- in( B98 B105 ) Loop( B99-B105 ) Freq: 164.859
050c +  li R31, #0	# int, #@loadConI
0510 +  subw  R28, R7, R30	#@subI_reg_reg
0514    CMove R28, (R7 lt R30), R28, R31	#@cmovI_cmpI
	
051c +  li R10, #4000	# int, #@loadConI
0524 +  li R29, #4000	# int, #@loadConI
052c    CMove R28, (R28 gtu R29), R28, R10	#@cmovI_cmpU
	
0534 +  addw  R28, R28, R30	#@addI_reg_reg
        nop 	# 4 bytes pad for loops and calls

0540    B100: #	out( B145 B101 ) &lt;- in( B99 B104 ) Loop( B100-B104 inner main of N417 strip mined) Freq: 3593.26
0540 +  addw  R31, R30, zr	#@convI2L_reg_reg
0544    spill [sp, #64] -&gt; R29	# spill size = 64
0548 +  add R10, R29, R31	# ptr, #@addP_reg_reg
054c +  lbu  R11, [R10, #16]	# byte, #@loadUB
0550 +  lbu  R29, [R10, #19]	# byte, #@loadUB
0554 +  lbu  R14, [R10, #18]	# byte, #@loadUB
0558 +  lbu  R16, [R10, #17]	# byte, #@loadUB
055c +  add R10, R24, R31	# ptr, #@addP_reg_reg
0560 +  lbu  R12, [R10, #16]	# byte, #@loadUB
0564 +  lbu  R31, [R10, #19]	# byte, #@loadUB
0568 +  lbu  R13, [R10, #18]	# byte, #@loadUB
056c +  lbu  R10, [R10, #17]	# byte, #@loadUB
0570 +  bne  R11, R12, B145	#@cmpI_branch  P=0.000000 C=21296.000000

0574    B101: #	out( B148 B102 ) &lt;- in( B100 )  Freq: 3593.26
0574 +  bne  R16, R10, B148	#@cmpI_branch  P=0.000000 C=21296.000000

0578    B102: #	out( B146 B103 ) &lt;- in( B101 )  Freq: 3593.26
0578 +  bne  R14, R13, B146	#@cmpI_branch  P=0.000000 C=21296.000000

057c    B103: #	out( B149 B104 ) &lt;- in( B102 )  Freq: 3593.26
057c +  bne  R29, R31, B149	#@cmpI_branch  P=0.000000 C=21296.000000

0580    B104: #	out( B100 B105 ) &lt;- in( B103 )  Freq: 3593.26
0580 +  addiw  R30, R30, #4	#@addI_reg_imm
0584 +  blt  R30, R28, B100	#@cmpI_loop  P=0.954122 C=21296.000000

0588    B105: #	out( B99 B106 ) &lt;- in( B104 )  Freq: 164.852
0588 +  ld  R28, [R23, #920]	# ptr, #@loadP
058c +  lwu zr, [R28]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.UnixPath::compareTo @ bci:85 (line 728) L[0]=_ L[1]=_ L[2]=R21 L[3]=R20 L[4]=R18 L[5]=sp + #64 L[6]=R24 L[7]=R30 L[8]=_ L[9]=_
        # sun.nio.fs.UnixPath::equals @ bci:14 (line 735) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.UnixPath::relativize @ bci:117 (line 417) L[0]=sp + #24 L[1]=R22 L[2]=R22 L[3]=sp + #24 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=R9 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {xbcp=Oop xlocals=Oop [24]=Oop [64]=Oop off=1420/0x58c}
0590 +  blt  R30, R7, B99	#@cmpI_branch  P=0.954122 C=21296.000000

0594    B106: #	out( B46 B107 ) &lt;- in( B174 B105 )  Freq: 7.5631
0594 +  bge  R30, R18, B46	#@cmpI_branch  P=0.500000 C=-1.000000

0598    B107: #	out( B181 B108 ) &lt;- in( B106 )  Freq: 3.78155
0598 +  # castII of R30, #@castII
0598    bgeu  R30, R21, B181	#@cmpU_branch  P=0.000001 C=-1.000000

059c    B108: #	out( B182 B109 ) &lt;- in( B107 )  Freq: 3.78155
059c +  bgeu  R30, R20, B182	#@cmpU_branch  P=0.000001 C=-1.000000

05a0    B109: #	out( B152 B110 ) &lt;- in( B108 B110 ) Loop( B109-B110 inner post of N2770) Freq: 7.56308
05a0 +  addw  R28, R30, zr	#@convI2L_reg_reg
05a4    spill [sp, #64] -&gt; R7	# spill size = 64
05a8 +  add R29, R7, R28	# ptr, #@addP_reg_reg
05ac +  lbu  R29, [R29, #16]	# byte, #@loadUB
05b0 +  add R28, R24, R28	# ptr, #@addP_reg_reg
05b4 +  lbu  R31, [R28, #16]	# byte, #@loadUB
05b8 +  bne  R29, R31, B152	#@cmpI_branch  P=0.000000 C=21296.000000

05bc    B110: #	out( B109 B111 ) &lt;- in( B109 )  Freq: 7.56308
05bc +  addiw  R30, R30, #1	#@addI_reg_imm
05c0 +  blt  R30, R18, B109	#@cmpI_loop  P=0.500000 C=21296.000000

05c4    B111: #	out( B46 ) &lt;- in( B110 )  Freq: 3.78154
05c4 +  j  B46	#@branch

05c8    B112: #	out( B113 ) &lt;- in( B47 )  Freq: 0.880786
05c8 +  spill [sp, #32] -&gt; R7	# spill size = 32
05cc +  spill [sp, #36] -&gt; R28	# spill size = 32

05d0    B113: #	out( B208 B114 ) &lt;- in( B144 B112 )  Freq: 0.991791
05d0 +  beq  R19, R28, B208	#@cmpI_branch  P=0.000000 C=2047.000000

05d4    B114: #	out( B243 B115 ) &lt;- in( B113 )  Freq: 0.99179
05d4 +  spill R19 -&gt; [sp, #48]	# spill size = 32
05d8 +  spill R28 -&gt; [sp, #44]	# spill size = 32
05dc +  spill R7 -&gt; [sp, #40]	# spill size = 32
05e0 +  spill R22 -&gt; [sp, #32]	# spill size = 64
05e4 +  spill R22 -&gt; R11	# spill size = 64
05e8    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::subpath @ bci:1 (line 323) L[0]=sp + #32 L[1]=sp + #48 L[2]=sp + #44 L[3]=_ L[4]=_ L[5]=_
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=sp + #24 L[1]=sp + #32 L[2]=_ L[3]=sp + #24 L[4]=sp + #40 L[5]=_ L[6]=_ L[7]=sp + #48 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[24]=Oop [32]=Oop off=1516/0x5ec}

05ec    B115: #	out( B209 B116 ) &lt;- in( B114 )  Freq: 0.99177
        # Block is sole successor of call
05ec +  spill [sp, #48] -&gt; R28	# spill size = 32
05f0 +  blt  R28, zr, B209	#@cmpI_reg_imm0_branch  P=0.000000 C=2302.000000

05f4    B116: #	out( B230 B117 ) &lt;- in( B115 )  Freq: 0.99177
05f4 +  spill [sp, #32] -&gt; R7	# spill size = 64
05f8 +  lwu  R28, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
05fc +  #@membar_acquire
	fence ir iorw
0600 +  decode_heap_oop  R7, R28	#@decodeHeapOop
0604    lwu  R8, [R7, #12]	# range, #@loadRange
0608    NullCheck R7

0608    B117: #	out( B210 B118 ) &lt;- in( B116 )  Freq: 0.991769
0608 +  spill [sp, #48] -&gt; R7	# spill size = 32
060c +  bge  R7, R8, B210	#@cmpI_branch  P=0.000000 C=2302.000000

0610    B118: #	out( B231 B119 ) &lt;- in( B117 )  Freq: 0.991768
0610 +  spill [sp, #32] -&gt; R7	# spill size = 64
0614 +  lwu  R7, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0618 +  #@membar_acquire
	fence ir iorw
061c +  decode_heap_oop  R7, R7	#@decodeHeapOop
0620    lwu  R8, [R7, #12]	# range, #@loadRange
0624    NullCheck R7

0624    B119: #	out( B211 B120 ) &lt;- in( B118 )  Freq: 0.991767
0624 +  spill [sp, #44] -&gt; R31	# spill size = 32
0628 +  bgt  R31, R8, B211	#@cmpI_branch  P=0.000000 C=2302.000000

062c    B120: #	out( B212 B121 ) &lt;- in( B119 )  Freq: 0.991767
062c +  spill [sp, #48] -&gt; R28	# spill size = 32
0630 +  bge  R28, R31, B212	#@cmpI_branch  P=0.000000 C=2302.000000

0634    B121: #	out( B232 B122 ) &lt;- in( B120 )  Freq: 0.991766
0634 +  spill [sp, #32] -&gt; R7	# spill size = 64
0638 +  lwu  R28, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
063c +  #@membar_acquire
	fence ir iorw
0640 +  decode_heap_oop  R8, R28	#@decodeHeapOop
0644    lwu  R7, [R8, #12]	# range, #@loadRange
0648    NullCheck R8

0648    B122: #	out( B187 B123 ) &lt;- in( B121 )  Freq: 0.991765
0648 +  spill [sp, #48] -&gt; R28	# spill size = 32
064c +  bgeu  R28, R7, B187	#@cmpU_branch  P=0.000001 C=-1.000000

0650    B123: #	out( B233 B124 ) &lt;- in( B122 )  Freq: 0.991764
0650 +  spill [sp, #32] -&gt; R7	# spill size = 64
0654 +  lwu  R28, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0658    spill [sp, #48] -&gt; R29	# spill size = 32
065c +  addw  R7, R29, zr	#@convI2L_reg_reg
0660 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0664 +  add R7, R8, R7	# ptr, #@addP_reg_reg
0668 +  lw  R7, [R7, #16]	# int, #@loadI
066c +  #@membar_acquire
	fence ir iorw
0670 +  decode_heap_oop  R28, R28	#@decodeHeapOop
0674    spill [sp, #32] -&gt; R29	# spill size = 64
0678 +  lwu  R29, [R29, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
067c    lwu  R8, [R28, #12]	# range, #@loadRange
0680    NullCheck R28

0680    B124: #	out( B201 B125 ) &lt;- in( B123 )  Freq: 0.991763
0680 +  decode_heap_oop  R11, R29	#@decodeHeapOop
0684 +  bne  R31, R8, B201	#@cmpI_branch  P=0.000000 C=2302.000000

0688    B125: #	out( B234 B126 ) &lt;- in( B124 )  Freq: 0.991763
0688    lwu  R10, [R11, #12]	# range, #@loadRange
068c    NullCheck R11

068c    B126: #	out( B188 B127 ) &lt;- in( B125 )  Freq: 0.991762
068c +  subw  R29, R10, R7	#@subI_reg_reg
0690 +  li R28, #1048576	# int, #@loadConI
0694 +  addw  R13, R7, zr	#@convI2L_reg_reg
0698 +  addw  R12, R29, zr	#@convI2L_reg_reg
069c +  bgtu  R29, R28, B188	#@cmpU_branch  P=0.000001 C=-1.000000

06a0    B127: #	out( B128 ) &lt;- in( B126 )  Freq: 0.991761
06a0 +  addw  R28, R10, zr	#@convI2L_reg_reg
06a4 +  sub  R28, R28, R13	#@subL_reg_reg

06a8    B128: #	out( B189 B129 ) &lt;- in( B127 B188 )  Freq: 0.991762
06a8 +  blt  R7, zr, B189	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

06ac    B129: #	out( B165 B130 ) &lt;- in( B128 )  Freq: 0.991761
06ac +  li R31, #1048576	# int, #@loadConI
06b0 +  bgtu  R29, R31, B165	#@cmpU_branch  P=0.000001 C=-1.000000

06b4    B130: #	out( B165 B131 ) &lt;- in( B129 )  Freq: 0.99176
06b4 +  addi  R28, R28, #23	#@addL_reg_imm
06b8 +  ld  R8, [R23, #288]	# ptr, #@loadP
06bc +  andi  R28, R28, #-8	#@andL_reg_imm
06c0 +  ld  R30, [R23, #304]	# ptr, #@loadP
06c4 +  add R28, R8, R28	# ptr, #@addP_reg_reg
06c8 +  bgeu  R28, R30, B165	#@cmpP_branch  P=0.000100 C=-1.000000

06cc    B131: #	out( B132 ) &lt;- in( B130 )  Freq: 0.991661
06cc +  sd  R28, [R23, #288]	# ptr, #@storeP
06d0 +  li R28, #1	# long, #@loadConL
06d4 +  mv  R30, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
06e4 +  sd  R28, [R8]	# long, #@storeL
06e8 +  sw  R30, [R8, #8]	# compressed klass ptr, #@storeNKlass
06ec +  sw  R29, [R8, #12]	# int, #@storeI

06f0    B132: #	out( B134 B133 ) &lt;- in( B166 B131 )  Freq: 0.991761
06f0    
06f0 +  # checkcastPP of R8, #@checkCastPP
06f0    beq  R10, R7, B134	#@cmpI_branch  P=0.000001 C=-1.000000

06f4    B133: #	out( B134 ) &lt;- in( B132 )  Freq: 0.99176
06f4 +  add R7, R11, R13	# ptr, #@addP_reg_reg
06f8 +  addi  R10, R7, #16	# ptr, #@addP_reg_imm
06fc +  addi  R11, R8, #16	# ptr, #@addP_reg_imm
0700 +  CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

0704    B134: #	out( B163 B135 ) &lt;- in( B133 B132 )  Freq: 0.991761
0704    MEMBAR-store-store	#@membar_storestore
0708 +  ld  R10, [R23, #288]	# ptr, #@loadP
070c +  ld  R7, [R23, #304]	# ptr, #@loadP
0710 +  addi  R28, R10, #32	# ptr, #@addP_reg_imm
0714 +  bgeu  R28, R7, B163	#@cmpP_branch  P=0.000100 C=-1.000000

0718    B135: #	out( B136 ) &lt;- in( B134 )  Freq: 0.991662
0718 +  sd  R28, [R23, #288]	# ptr, #@storeP
071c +  li R7, #1	# long, #@loadConL
0720 +  mv  R28, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d060f5a0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0730 +  sd  R7, [R10]	# long, #@storeL
0734 +  sw  R28, [R10, #8]	# compressed klass ptr, #@storeNKlass
0738 +  sw  zr, [R10, #12]	# int, #@storeimmI0
073c +  sw  zr, [R10, #16]	# int, #@storeimmI0
0740 +  sd  zr, [R10, #24]	# long, #@storeimmL0

0744    B136: #	out( B235 B137 ) &lt;- in( B164 B135 )  Freq: 0.991761
0744 +  encode_heap_oop  R7, R8	#@encodeHeapOop
0748 +  sw  R7, [R10, #20]	# compressed ptr, #@storeN
074c    
074c    spill [sp, #32] -&gt; R7	# spill size = 64
0750 +  lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
0754 +  # checkcastPP of R10, #@checkCastPP
0754    sw  R28, [R10, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixPath.fs
0758 +  #@membar_release
	fence iorw ow
075c +  lwu  R7, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
0760 +  decode_heap_oop  R7, R7	#@decodeHeapOop
0764    lwu  R8, [R7, #12]	# range, #@loadRange
0768    NullCheck R7

0768    B137: #	out( B213 B138 ) &lt;- in( B136 )  Freq: 0.99176
0768 +  bleu  R8, zr, B213	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=9503.000000

076c    B138: #	out( B202 B139 ) &lt;- in( B137 )  Freq: 0.991759
076c +  spill [sp, #40] -&gt; R7	# spill size = 32
0770 +  spill [sp, #48] -&gt; R28	# spill size = 32
0774 +  bne  R28, R7, B202	#@cmpI_branch  P=0.000000 C=2047.000000

0778    B139: #	out( N2499 ) &lt;- in( B138 )  Freq: 0.991759
0778    # pop frame 128
	add  sp, sp, #128
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0790 +  ret	// return register, #@Ret

0794    B140: #	out( B236 B141 ) &lt;- in( B55 )  Freq: 0.671522
0794 +  lwu  R28, [R9, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
0798 +  decode_heap_oop  R7, R28	#@decodeHeapOop
079c    lwu  R7, [R7, #12]	# range, #@loadRange
07a0    NullCheck R7

07a0    B141: #	out( B59 ) &lt;- in( B140 )  Freq: 0.671521
07a0 +  subw  R7, R7, R29	#@subI_reg_reg
07a4 +  j  B59	#@branch

07a8    B142: #	out( B237 B143 ) &lt;- in( B74 )  Freq: 0.671502
07a8 +  lwu  R28, [R22, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
07ac +  decode_heap_oop  R7, R28	#@decodeHeapOop
07b0    lwu  R7, [R7, #12]	# range, #@loadRange
07b4    NullCheck R7

07b4    B143: #	out( B78 ) &lt;- in( B142 )  Freq: 0.671502
07b4 +  subw  R20, R7, R29	#@subI_reg_reg
07b8    spill [sp, #4] -&gt; R19	# spill size = 32
07bc +  j  B78	#@branch

07c0    B144: #	out( B113 ) &lt;- in( B44 )  Freq: 0.111004
07c0 +  li R19, #0	# int, #@loadConI
07c4 +  j  B113	#@branch

07c8    B145: #	out( B147 ) &lt;- in( B100 )  Freq: 0.0017134
07c8 +  spill R12 -&gt; R13	# spill size = 32
07cc +  spill R11 -&gt; R14	# spill size = 32
07d0 +  j  B147	#@branch

07d4    B146: #	out( B147 ) &lt;- in( B102 )  Freq: 0.0017134
07d4 +  # castII of R30, #@castII
07d4    addiw  R30, R30, #2	#@addI_reg_imm

07d8    B147: #	out( B151 ) &lt;- in( B145 B146 )  Freq: 0.0034268
07d8    spill R13 -&gt; R31	# spill size = 32
07dc +  spill R14 -&gt; R29	# spill size = 32
07e0 +  j  B151	#@branch

07e4    B148: #	out( B150 ) &lt;- in( B101 )  Freq: 0.0017134
07e4 +  spill R10 -&gt; R31	# spill size = 32
07e8 +  spill R16 -&gt; R29	# spill size = 32
07ec +  j  B150	#@branch

07f0    B149: #	out( B150 ) &lt;- in( B103 )  Freq: 0.0017134
07f0 +  # castII of R30, #@castII
07f0    addiw  R30, R30, #2	#@addI_reg_imm

07f4    B150: #	out( B151 ) &lt;- in( B148 B149 )  Freq: 0.0034268
07f4 +  addiw  R30, R30, #1	#@addI_reg_imm

07f8    B151: #	out( B152 ) &lt;- in( B185 B147 B150 )  Freq: 0.00685721
07f8    spill [sp, #64] -&gt; R7	# spill size = 64

07fc    B152: #	out( N2499 ) &lt;- in( B109 B151 )  Freq: 0.00686082
07fc +  spill [sp, #24] -&gt; R8	# spill size = 64
0800 +  spill [sp, #32] -&gt; R28	# spill size = 32
0804 +  spill R28 -&gt; [sp, #24]	# spill size = 32
0808 +  spill [sp, #36] -&gt; R10	# spill size = 32
080c +  spill [sp, #40] -&gt; R28	# spill size = 32
0810 +  li R11, #-187	# int, #@loadConI
0814    spill R22 -&gt; [sp, #8]	# spill size = 64
0818 +  spill R10 -&gt; [sp, #28]	# spill size = 32
081c +  spill R28 -&gt; [sp, #32]	# spill size = 32
0820 +  spill R9 -&gt; [sp, #36]	# spill size = 32
0824 +  spill R21 -&gt; [sp, #40]	# spill size = 32
0828 +  spill R20 -&gt; [sp, #44]	# spill size = 32
082c +  spill R18 -&gt; [sp, #48]	# spill size = 32
0830 +  spill R7 -&gt; [sp, #56]	# spill size = 64
0834 +  spill R24 -&gt; [sp, #64]	# spill size = 64
0838 +  spill R30 -&gt; [sp, #52]	# spill size = 32
083c +  spill R29 -&gt; [sp, #80]	# spill size = 32
0840 +  spill R31 -&gt; [sp, #84]	# spill size = 32
0844    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:73 (line 724) L[0]=_ L[1]=_ L[2]=sp + #40 L[3]=sp + #44 L[4]=sp + #48 L[5]=sp + #56 L[6]=sp + #64 L[7]=sp + #52 L[8]=sp + #80 L[9]=sp + #84 STK[0]=sp + #80 STK[1]=sp + #84
        # sun.nio.fs.UnixPath::equals @ bci:14 (line 735) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.UnixPath::relativize @ bci:117 (line 417) L[0]=R8 L[1]=sp + #8 L[2]=sp + #8 L[3]=R8 L[4]=sp + #24 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #36 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [8]=Oop [56]=Oop [64]=Oop off=2120/0x848}
0848    #@ShouldNotReachHere

0854    B153: #	out( B242 B154 ) &lt;- in( B63 B64 )  Freq: 0.000801596
0854 +  spill R11 -&gt; [sp, #16]	# spill size = 64
0858 +  spill R12 -&gt; [sp, #48]	# spill size = 64
085c +  spill R7 -&gt; [sp, #28]	# spill size = 32
0860 +  spill R10 -&gt; [sp, #24]	# spill size = 32
0864 +  spill R29 -&gt; [sp, #4]	# spill size = 32
0868 +  spill R9 -&gt; R8	# spill size = 64
086c +  mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
0884    spill R7 -&gt; R12	# spill size = 32
0888    CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=R8 L[1]=_ L[2]=sp + #4 L[3]=sp + #28 L[4]=_
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=R8 L[1]=sp + #8 L[2]=sp + #8 L[3]=R8 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=sp + #0 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [8]=Oop [48]=Oop off=2188/0x88c}

088c    B154: #	out( B66 ) &lt;- in( B153 )  Freq: 0.00080158
        # Block is sole successor of call
088c +  spill R10 -&gt; R28	# spill size = 64
0890 +  spill R8 -&gt; R9	# spill size = 64
0894 +  spill [sp, #0] -&gt; R30	# spill size = 32
0898 +  spill [sp, #16] -&gt; R11	# spill size = 64
089c +  spill [sp, #4] -&gt; R29	# spill size = 32
08a0 +  spill [sp, #24] -&gt; R10	# spill size = 32
08a4 +  spill [sp, #28] -&gt; R7	# spill size = 32
08a8 +  spill [sp, #48] -&gt; R12	# spill size = 64
08ac +  spill R28 -&gt; R13	# spill size = 64
08b0 +  j  B66	#@branch

08b4    B155: #	out( B241 B156 ) &lt;- in( B82 B83 )  Freq: 0.000801572
08b4 +  spill [sp, #0] -&gt; [sp, #8]	# spill size = 32
08bc +  spill R20 -&gt; [sp, #20]	# spill size = 32
08c0 +  spill R29 -&gt; [sp, #16]	# spill size = 32
08c4 +  spill R19 -&gt; [sp, #12]	# spill size = 32
08c8 +  spill R22 -&gt; [sp, #0]	# spill size = 64
08cc +  mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
08e4    spill R20 -&gt; R12	# spill size = 32
08e8    CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #0 L[1]=_ L[2]=sp + #16 L[3]=sp + #20 L[4]=_
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=sp + #24 L[1]=sp + #0 L[2]=sp + #0 L[3]=sp + #24 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=sp + #8 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#ScObj0
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=sp + #72, [path :2]=sp + #64, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # OopMap {fp=Oop [0]=Oop [24]=Oop [48]=Derived_oop_[64] [64]=Oop [72]=Oop off=2284/0x8ec}

08ec    B156: #	out( B85 ) &lt;- in( B155 )  Freq: 0.000801556
        # Block is sole successor of call
08ec +  spill [sp, #0] -&gt; R22	# spill size = 64
08f0 +  spill [sp, #8] -&gt; R9	# spill size = 32
08f4 +  spill [sp, #12] -&gt; R19	# spill size = 32
08f8 +  spill [sp, #16] -&gt; R29	# spill size = 32
08fc +  spill [sp, #20] -&gt; R20	# spill size = 32
0900 +  spill R10 -&gt; R24	# spill size = 64
0904 +  j  B85	#@branch

0908    B157: #	out( B159 ) &lt;- in( B18 )  Freq: 0.000215956
0908 +  spill R18 -&gt; R21	# spill size = 32
090c +  spill R29 -&gt; R28	# spill size = 32
0910 +  j  B159	#@branch

0914    B158: #	out( B159 ) &lt;- in( B20 )  Freq: 0.000215956
0914 +  addiw  R31, R31, #2	#@addI_reg_imm

0918    B159: #	out( B162 ) &lt;- in( B157 B158 )  Freq: 0.000431912
0918    spill R21 -&gt; R13	# spill size = 32
091c +  spill R28 -&gt; R10	# spill size = 32
0920 +  j  B162	#@branch

0924    B160: #	out( B162 ) &lt;- in( B19 )  Freq: 0.000215956
0924 +  addiw  R31, R31, #1	#@addI_reg_imm
0928    spill R11 -&gt; R13	# spill size = 32
092c +  spill R19 -&gt; R10	# spill size = 32
0930 +  j  B162	#@branch

0934    B161: #	out( B162 ) &lt;- in( B21 )  Freq: 0.000215956
0934 +  addiw  R31, R31, #3	#@addI_reg_imm

0938    B162: #	out( N2499 ) &lt;- in( B29 B214 B159 B160 B161 )  Freq: 0.000864732
0938 +  li R11, #-187	# int, #@loadConI
093c    spill R14 -&gt; [sp, #0]	# spill size = 64
0940 +  spill R12 -&gt; [sp, #16]	# spill size = 64
0944 +  spill R9 -&gt; [sp, #24]	# spill size = 64
0948 +  spill R17 -&gt; [sp, #32]	# spill size = 64
094c +  spill R31 -&gt; [sp, #40]	# spill size = 32
0950 +  spill R10 -&gt; [sp, #52]	# spill size = 32
0954 +  spill R13 -&gt; [sp, #56]	# spill size = 32
0958 +  spill R30 -&gt; [sp, #60]	# spill size = 32
095c +  spill R16 -&gt; [sp, #64]	# spill size = 32
0960    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:73 (line 724) L[0]=_ L[1]=_ L[2]=sp + #60 L[3]=sp + #64 L[4]=R8 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=sp + #52 L[9]=sp + #56 STK[0]=sp + #52 STK[1]=sp + #56
        # sun.nio.fs.UnixPath::equals @ bci:14 (line 735) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.UnixPath::relativize @ bci:7 (line 393) L[0]=sp + #0 L[1]=sp + #16 L[2]=sp + #16 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop off=2404/0x964}
0964    #@ShouldNotReachHere

0970    B163: #	out( B239 B164 ) &lt;- in( B134 )  Freq: 9.91925e-05
0970 +  mv  R11, precise klass sun/nio/fs/UnixPath: 0x00000040d060f5a0:Constant:exact *	# ptr, #@loadConP
0988    spill [sp, #32] -&gt; [sp, #0]	# spill size = 64
0990    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixPath::subpath @ bci:122 (line 347) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=sp + #24 L[1]=sp + #0 L[2]=_ L[3]=sp + #24 L[4]=sp + #40 L[5]=_ L[6]=_ L[7]=sp + #48 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [0]=Oop [24]=Oop [32]=Oop off=2452/0x994}

0994    B164: #	out( B136 ) &lt;- in( B163 )  Freq: 9.91906e-05
        # Block is sole successor of call
0994 +  j  B136	#@branch

0998    B165: #	out( B240 B166 ) &lt;- in( B129 B130 )  Freq: 0.000100197
0998 +  spill R11 -&gt; [sp, #56]	# spill size = 64
099c +  spill R12 -&gt; [sp, #16]	# spill size = 64
09a0 +  spill R13 -&gt; [sp, #64]	# spill size = 64
09a4 +  spill R10 -&gt; [sp, #12]	# spill size = 32
09a8 +  spill R29 -&gt; [sp, #8]	# spill size = 32
09ac +  spill R7 -&gt; [sp, #4]	# spill size = 32
09b0 +  spill [sp, #48] -&gt; [sp, #0]	# spill size = 32
09b8 +  spill [sp, #32] -&gt; R8	# spill size = 64
09bc +  mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
09d4    spill R29 -&gt; R12	# spill size = 32
09d8    CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::subpath @ bci:105 (line 345) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #4 L[4]=sp + #8 L[5]=_
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=sp + #24 L[1]=R8 L[2]=_ L[3]=sp + #24 L[4]=sp + #40 L[5]=_ L[6]=_ L[7]=sp + #0 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [24]=Oop [32]=Oop [56]=Oop off=2524/0x9dc}

09dc    B166: #	out( B132 ) &lt;- in( B165 )  Freq: 0.000100195
        # Block is sole successor of call
09dc +  spill R10 -&gt; R8	# spill size = 64
09e0 +  spill [sp, #4] -&gt; R7	# spill size = 32
09e4 +  spill [sp, #16] -&gt; R12	# spill size = 64
09e8 +  spill [sp, #56] -&gt; R11	# spill size = 64
09ec +  spill [sp, #12] -&gt; R10	# spill size = 32
09f0 +  spill [sp, #64] -&gt; R13	# spill size = 64
09f4 +  j  B132	#@branch

09f8    B167: #	out( N2499 ) &lt;- in( B53 )  Freq: 8.03967e-06
09f8 +  li R11, #-28	# int, #@loadConI
09fc    spill R30 -&gt; [sp, #56]	# spill size = 32
0a00 +  spill R30 -&gt; [sp, #60]	# spill size = 32
0a04    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:38 (line 307) L[0]=sp + #24 L[1]=sp + #60 L[2]=_ L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #56
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=sp + #24 L[1]=sp + #8 L[2]=sp + #8 L[3]=sp + #24 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=sp + #56 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop off=2568/0xa08}
0a08    #@ShouldNotReachHere

0a14    B168: #	out( B68 ) &lt;- in( B66 )  Freq: 8.03961e-06
0a14 +  spill R30 -&gt; [sp, #0]	# spill size = 32
0a18 +  spill R11 -&gt; [sp, #16]	# spill size = 64
0a1c +  spill R10 -&gt; [sp, #4]	# spill size = 32
0a20 +  spill R7 -&gt; [sp, #44]	# spill size = 32
0a24 +  spill R13 -&gt; [sp, #64]	# spill size = 64
0a28 +  spill R28 -&gt; [sp, #48]	# spill size = 64
0a2c +  j  B68	#@branch

0a30    B169: #	out( N2499 ) &lt;- in( B72 )  Freq: 8.03943e-06
0a30 +  li R11, #-28	# int, #@loadConI
0a34    spill R9 -&gt; [sp, #56]	# spill size = 32
0a38 +  spill R9 -&gt; [sp, #60]	# spill size = 32
0a3c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:38 (line 307) L[0]=sp + #8 L[1]=sp + #60 L[2]=_ L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #56
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=sp + #24 L[1]=sp + #8 L[2]=sp + #8 L[3]=sp + #24 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=sp + #56 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#ScObj0
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=sp + #72, [path :2]=sp + #64, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # OopMap {fp=Oop [8]=Oop [24]=Oop [64]=Oop [72]=Oop off=2624/0xa40}
0a40    #@ShouldNotReachHere

0a4c    B170: #	out( N2499 ) &lt;- in( B61 B62 )  Freq: 1.58685e-05
0a4c +  spill [sp, #24] -&gt; [sp, #16]	# spill size = 64
0a54 +  spill [sp, #32] -&gt; R31	# spill size = 32
0a58 +  spill R31 -&gt; [sp, #24]	# spill size = 32
0a5c +  spill [sp, #36] -&gt; R28	# spill size = 32
0a60 +  spill [sp, #40] -&gt; R31	# spill size = 32
0a64 +  li R11, #-52	# int, #@loadConI
0a68    spill R28 -&gt; [sp, #28]	# spill size = 32
0a6c +  spill R31 -&gt; [sp, #32]	# spill size = 32
0a70 +  spill R30 -&gt; [sp, #36]	# spill size = 32
0a74 +  spill R9 -&gt; [sp, #40]	# spill size = 64
0a78 +  spill R7 -&gt; [sp, #52]	# spill size = 32
0a7c +  spill R29 -&gt; [sp, #56]	# spill size = 32
0a80    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #16 L[1]=_ L[2]=sp + #56 L[3]=sp + #52 L[4]=_ STK[0]=sp + #52
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=sp + #16 L[1]=sp + #8 L[2]=sp + #8 L[3]=sp + #40 L[4]=sp + #24 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #36 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[8]=Oop [16]=Oop [40]=Oop off=2692/0xa84}
0a84    #@ShouldNotReachHere

0a90    B171: #	out( N2499 ) &lt;- in( B80 B81 )  Freq: 1.58681e-05
0a90 +  spill [sp, #24] -&gt; R8	# spill size = 64
0a94 +  spill [sp, #32] -&gt; R28	# spill size = 32
0a98 +  spill [sp, #36] -&gt; R7	# spill size = 32
0a9c +  spill R28 -&gt; [sp, #24]	# spill size = 32
0aa0 +  spill R7 -&gt; [sp, #28]	# spill size = 32
0aa4 +  spill [sp, #40] -&gt; R28	# spill size = 32
0aa8 +  spill [sp, #64] -&gt; R7	# spill size = 64
0aac +  li R11, #-52	# int, #@loadConI
0ab0    spill R28 -&gt; [sp, #32]	# spill size = 32
0ab4 +  spill R9 -&gt; [sp, #36]	# spill size = 32
0ab8 +  spill R20 -&gt; [sp, #52]	# spill size = 32
0abc +  spill R7 -&gt; [sp, #56]	# spill size = 64
0ac0 +  spill R29 -&gt; [sp, #64]	# spill size = 32
0ac4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #8 L[1]=_ L[2]=sp + #64 L[3]=sp + #52 L[4]=_ STK[0]=sp + #52
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=R8 L[1]=sp + #8 L[2]=sp + #8 L[3]=R8 L[4]=sp + #24 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #36 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#ScObj0
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=sp + #72, [path :2]=sp + #56, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # OopMap {fp=Oop [8]=Oop [56]=Oop [72]=Oop off=2760/0xac8}
0ac8    #@ShouldNotReachHere

0ad4    B172: #	out( N2499 ) &lt;- in( B46 )  Freq: 7.92709e-06
0ad4 +  spill [sp, #24] -&gt; R8	# spill size = 64
0ad8 +  spill [sp, #32] -&gt; R7	# spill size = 32
0adc +  spill [sp, #36] -&gt; R28	# spill size = 32
0ae0 +  li R11, #-187	# int, #@loadConI
0ae4    spill R22 -&gt; [sp, #8]	# spill size = 64
0ae8 +  spill R7 -&gt; [sp, #24]	# spill size = 32
0aec +  spill R28 -&gt; [sp, #28]	# spill size = 32
0af0 +  spill R9 -&gt; [sp, #36]	# spill size = 32
0af4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::relativize @ bci:120 (line 417) L[0]=R8 L[1]=sp + #8 L[2]=sp + #8 L[3]=R8 L[4]=sp + #24 L[5]=sp + #28 L[6]=sp + #40 L[7]=sp + #36 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#0
        # OopMap {fp=Oop [8]=Oop off=2808/0xaf8}
0af8    #@ShouldNotReachHere

0b04    B173: #	out( N2499 ) &lt;- in( B90 B88 B89 B91 )  Freq: 3.06821e-05
0b04 +  spill [sp, #24] -&gt; R8	# spill size = 64
0b08 +  spill [sp, #32] -&gt; R28	# spill size = 32
0b0c +  spill R28 -&gt; [sp, #24]	# spill size = 32
0b10 +  spill [sp, #36] -&gt; R7	# spill size = 32
0b14 +  spill [sp, #40] -&gt; R28	# spill size = 32
0b18 +  spill R7 -&gt; [sp, #28]	# spill size = 32
0b1c +  spill [sp, #44] -&gt; [sp, #40]	# spill size = 32
0b24 +  spill [sp, #64] -&gt; R7	# spill size = 64
0b28 +  li R11, #-138	# int, #@loadConI
0b2c    spill R22 -&gt; [sp, #8]	# spill size = 64
0b30 +  spill R28 -&gt; [sp, #32]	# spill size = 32
0b34 +  spill R9 -&gt; [sp, #36]	# spill size = 32
0b38 +  spill R20 -&gt; [sp, #44]	# spill size = 32
0b3c +  spill R7 -&gt; [sp, #56]	# spill size = 64
0b40 +  spill R24 -&gt; [sp, #64]	# spill size = 64
0b44 +  spill R18 -&gt; [sp, #52]	# spill size = 32
0b48    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:44 (line 721) L[0]=_ L[1]=_ L[2]=sp + #40 L[3]=sp + #44 L[4]=sp + #52 L[5]=sp + #56 L[6]=sp + #64 L[7]=#0 L[8]=_ L[9]=_ STK[0]=#0 STK[1]=sp + #52
        # sun.nio.fs.UnixPath::equals @ bci:14 (line 735) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.UnixPath::relativize @ bci:117 (line 417) L[0]=R8 L[1]=sp + #8 L[2]=sp + #8 L[3]=R8 L[4]=sp + #24 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #36 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [8]=Oop [56]=Oop [64]=Oop off=2892/0xb4c}
0b4c    #@ShouldNotReachHere

0b58    B174: #	out( B106 ) &lt;- in( B93 )  Freq: 7.67051e-06
0b58 +  li R30, #1	# int, #@loadConI
0b5c +  j  B106	#@branch

0b60    B175: #	out( N2499 ) &lt;- in( B94 )  Freq: 7.56998e-06
0b60    #@ShouldNotReachHere

0b6c    B176: #	out( N2499 ) &lt;- in( B95 )  Freq: 7.56997e-06
0b6c    #@ShouldNotReachHere

0b78    B177: #	out( N2499 ) &lt;- in( B96 )  Freq: 7.56996e-06
0b78    #@ShouldNotReachHere

0b84    B178: #	out( N2499 ) &lt;- in( B97 )  Freq: 7.56995e-06
0b84    #@ShouldNotReachHere

0b90    B179: #	out( N2499 ) &lt;- in( B57 )  Freq: 7.3592e-06
0b90 +  li R11, #-28	# int, #@loadConI
0b94    spill R30 -&gt; [sp, #44]	# spill size = 32
0b98 +  spill R29 -&gt; [sp, #56]	# spill size = 32
0b9c +  spill R10 -&gt; [sp, #60]	# spill size = 32
0ba0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:69 (line 312) L[0]=sp + #24 L[1]=_ L[2]=sp + #56 L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #60
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=sp + #24 L[1]=sp + #8 L[2]=sp + #8 L[3]=sp + #24 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=sp + #44 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop off=2980/0xba4}
0ba4    #@ShouldNotReachHere

0bb0    B180: #	out( N2499 ) &lt;- in( B76 )  Freq: 7.35899e-06
0bb0 +  spill [sp, #64] -&gt; R7	# spill size = 64
0bb4 +  li R11, #-28	# int, #@loadConI
0bb8    spill R9 -&gt; [sp, #44]	# spill size = 32
0bbc +  spill R7 -&gt; [sp, #56]	# spill size = 64
0bc0 +  spill R29 -&gt; [sp, #64]	# spill size = 32
0bc4 +  spill R19 -&gt; [sp, #68]	# spill size = 32
0bc8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:69 (line 312) L[0]=sp + #8 L[1]=_ L[2]=sp + #64 L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #68
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=sp + #24 L[1]=sp + #8 L[2]=sp + #8 L[3]=sp + #24 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=sp + #44 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#ScObj0
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=sp + #72, [path :2]=sp + #56, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # OopMap {fp=Oop [8]=Oop [24]=Oop [56]=Oop [72]=Oop off=3020/0xbcc}
0bcc    #@ShouldNotReachHere

0bd8    B181: #	out( N2499 ) &lt;- in( B107 )  Freq: 3.83177e-06
0bd8    #@ShouldNotReachHere

0be4    B182: #	out( N2499 ) &lt;- in( B108 )  Freq: 3.83176e-06
0be4    #@ShouldNotReachHere

0bf0    B183: #	out( N2499 ) &lt;- in( B51 )  Freq: 3.78338e-06
0bf0 +  li R11, #-187	# int, #@loadConI
0bf4    spill R30 -&gt; [sp, #56]	# spill size = 32
0bf8 +  spill R30 -&gt; [sp, #60]	# spill size = 32
0bfc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:22 (line 304) L[0]=sp + #24 L[1]=sp + #60 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #56 STK[1]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=sp + #24 L[1]=sp + #8 L[2]=sp + #8 L[3]=sp + #24 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=sp + #56 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[8]=Oop [24]=Oop off=3072/0xc00}
0c00    #@ShouldNotReachHere

0c0c    B184: #	out( N2499 ) &lt;- in( B70 )  Freq: 3.78327e-06
0c0c +  li R11, #-187	# int, #@loadConI
0c10    spill R9 -&gt; [sp, #56]	# spill size = 32
0c14 +  spill R9 -&gt; [sp, #60]	# spill size = 32
0c18    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:22 (line 304) L[0]=sp + #8 L[1]=sp + #60 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #56 STK[1]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=sp + #24 L[1]=sp + #8 L[2]=sp + #8 L[3]=sp + #24 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=sp + #56 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#ScObj0
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=sp + #72, [path :2]=sp + #64, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # OopMap {[8]=Oop [24]=Oop [64]=Oop [72]=Oop off=3100/0xc1c}
0c1c    #@ShouldNotReachHere

0c28    B185: #	out( B151 ) &lt;- in( B92 )  Freq: 3.60965e-06
0c28 +  li R30, #0	# int, #@loadConI
0c2c +  j  B151	#@branch

0c30    B186: #	out( N2499 ) &lt;- in( B31 )  Freq: 1.01239e-06
0c30 +  li R11, #-187	# int, #@loadConI
0c34    spill R14 -&gt; R8	# spill size = 64
0c38 +  spill R12 -&gt; [sp, #8]	# spill size = 64
0c3c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::relativize @ bci:10 (line 393) L[0]=R8 L[1]=sp + #8 L[2]=sp + #8 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#1
        # OopMap {fp=Oop [8]=Oop off=3136/0xc40}
0c40    #@ShouldNotReachHere

0c4c    B187: #	out( N2499 ) &lt;- in( B122 )  Freq: 1.00493e-06
0c4c +  spill [sp, #24] -&gt; R7	# spill size = 64
0c50 +  spill R7 -&gt; [sp, #16]	# spill size = 64
0c54 +  spill [sp, #40] -&gt; R7	# spill size = 32
0c58 +  li R11, #-28	# int, #@loadConI
0c5c    spill R7 -&gt; [sp, #24]	# spill size = 32
0c60 +  spill R31 -&gt; [sp, #28]	# spill size = 32
0c64 +  spill R28 -&gt; [sp, #44]	# spill size = 32
0c68    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:68 (line 336) L[0]=sp + #32 L[1]=_ L[2]=sp + #28 L[3]=_ L[4]=_ L[5]=_ STK[0]=R8 STK[1]=sp + #48
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=sp + #16 L[1]=sp + #32 L[2]=_ L[3]=sp + #16 L[4]=sp + #24 L[5]=_ L[6]=_ L[7]=sp + #44 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [16]=Oop [32]=Oop off=3180/0xc6c}
0c6c    #@ShouldNotReachHere

0c78    B188: #	out( B128 ) &lt;- in( B126 )  Freq: 1.00493e-06
0c78 +  spill R12 -&gt; R28	# spill size = 64
0c7c +  j  B128	#@branch

0c80    B189: #	out( N2499 ) &lt;- in( B128 )  Freq: 9.91762e-07
0c80 +  spill [sp, #40] -&gt; R28	# spill size = 32
0c84 +  spill [sp, #32] -&gt; [sp, #0]	# spill size = 64
0c8c +  li R11, #-52	# int, #@loadConI
0c90    spill [sp, #24] -&gt; R8	# spill size = 64
0c94 +  spill R28 -&gt; [sp, #16]	# spill size = 32
0c98 +  spill R7 -&gt; [sp, #32]	# spill size = 32
0c9c +  spill R29 -&gt; [sp, #40]	# spill size = 32
0ca0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:105 (line 345) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=sp + #32 L[4]=sp + #40 L[5]=_ STK[0]=sp + #40
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=R8 L[4]=sp + #16 L[5]=_ L[6]=_ L[7]=sp + #48 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [0]=Oop off=3236/0xca4}
0ca4    #@ShouldNotReachHere

0cb0    B190: #	out( N2499 ) &lt;- in( B8 B6 B7 B9 )  Freq: 3.84181e-06
0cb0 +  li R11, #-138	# int, #@loadConI
0cb4    spill R14 -&gt; [sp, #0]	# spill size = 64
0cb8 +  spill R12 -&gt; [sp, #16]	# spill size = 64
0cbc +  spill R9 -&gt; [sp, #24]	# spill size = 64
0cc0 +  spill R17 -&gt; [sp, #32]	# spill size = 64
0cc4 +  spill R30 -&gt; [sp, #40]	# spill size = 32
0cc8 +  spill R16 -&gt; [sp, #44]	# spill size = 32
0ccc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:44 (line 721) L[0]=_ L[1]=_ L[2]=sp + #40 L[3]=sp + #44 L[4]=R8 L[5]=sp + #24 L[6]=sp + #32 L[7]=#0 L[8]=_ L[9]=_ STK[0]=#0 STK[1]=R8
        # sun.nio.fs.UnixPath::equals @ bci:14 (line 735) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.UnixPath::relativize @ bci:7 (line 393) L[0]=sp + #0 L[1]=sp + #16 L[2]=sp + #16 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop off=3280/0xcd0}
0cd0    #@ShouldNotReachHere

0cdc    B191: #	out( B24 ) &lt;- in( B11 )  Freq: 9.66785e-07
0cdc +  li R31, #1	# int, #@loadConI
0ce0 +  j  B24	#@branch

0ce4    B192: #	out( N2499 ) &lt;- in( B12 )  Freq: 9.54114e-07
0ce4    #@ShouldNotReachHere

0cf0    B193: #	out( N2499 ) &lt;- in( B13 )  Freq: 9.54113e-07
0cf0    #@ShouldNotReachHere

0cfc    B194: #	out( N2499 ) &lt;- in( B14 )  Freq: 9.54112e-07
0cfc    #@ShouldNotReachHere

0d08    B195: #	out( N2499 ) &lt;- in( B15 )  Freq: 9.54111e-07
0d08    #@ShouldNotReachHere

0d14    B196: #	out( N2499 ) &lt;- in( B32 )  Freq: 4.99561e-07
0d14 +  li R11, #-187	# int, #@loadConI
0d18    spill R12 -&gt; [sp, #8]	# spill size = 64
0d1c +  spill R14 -&gt; [sp, #16]	# spill size = 64
0d20 +  spill R16 -&gt; [sp, #24]	# spill size = 32
0d24    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::isAbsolute @ bci:5 (line 352) L[0]=sp + #16 STK[0]=sp + #24
        # sun.nio.fs.UnixPath::relativize @ bci:19 (line 397) L[0]=sp + #16 L[1]=sp + #8 L[2]=sp + #8 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[8]=Oop [16]=Oop off=3368/0xd28}
0d28    #@ShouldNotReachHere

0d34    B197: #	out( N2499 ) &lt;- in( B33 )  Freq: 4.99561e-07
0d34 +  li R11, #-187	# int, #@loadConI
0d38    spill R14 -&gt; [sp, #0]	# spill size = 64
0d3c +  spill R12 -&gt; [sp, #16]	# spill size = 64
0d40    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::isAbsolute @ bci:16 (line 352) L[0]=_ STK[0]=R8 STK[1]=#47
        # sun.nio.fs.UnixPath::relativize @ bci:19 (line 397) L[0]=sp + #0 L[1]=sp + #16 L[2]=sp + #16 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[0]=Oop [16]=Oop off=3396/0xd44}
0d44    #@ShouldNotReachHere

0d50    B198: #	out( N2499 ) &lt;- in( B34 )  Freq: 4.99561e-07
0d50 +  li R11, #-187	# int, #@loadConI
0d54    spill R14 -&gt; R8	# spill size = 64
0d58 +  spill R12 -&gt; [sp, #8]	# spill size = 64
0d5c +  spill R12 -&gt; [sp, #16]	# spill size = 64
0d60 +  spill R30 -&gt; [sp, #24]	# spill size = 32
0d64    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::isAbsolute @ bci:5 (line 352) L[0]=sp + #8 STK[0]=sp + #24
        # sun.nio.fs.UnixPath::relativize @ bci:23 (line 397) L[0]=R8 L[1]=sp + #8 L[2]=sp + #16 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#1
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=3432/0xd68}
0d68    #@ShouldNotReachHere

0d74    B199: #	out( N2499 ) &lt;- in( B35 )  Freq: 4.9956e-07
0d74 +  li R11, #-187	# int, #@loadConI
0d78    spill R14 -&gt; [sp, #0]	# spill size = 64
0d7c +  spill R12 -&gt; [sp, #16]	# spill size = 64
0d80    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::isAbsolute @ bci:16 (line 352) L[0]=_ STK[0]=R8 STK[1]=#47
        # sun.nio.fs.UnixPath::relativize @ bci:23 (line 397) L[0]=sp + #0 L[1]=sp + #16 L[2]=sp + #16 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#1
        # OopMap {[0]=Oop [16]=Oop off=3460/0xd84}
0d84    #@ShouldNotReachHere

0d90    B200: #	out( N2499 ) &lt;- in( B37 )  Freq: 4.9955e-07
0d90 +  li R11, #-187	# int, #@loadConI
0d94    spill R10 -&gt; [sp, #24]	# spill size = 32
0d98    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::relativize @ bci:54 (line 405) L[0]=R8 L[1]=sp + #0 L[2]=sp + #0 L[3]=R8 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=sp + #24
        # OopMap {fp=Oop [0]=Oop off=3484/0xd9c}
0d9c    #@ShouldNotReachHere

0da8    B201: #	out( N2499 ) &lt;- in( B124 )  Freq: 4.95882e-07
0da8 +  spill [sp, #24] -&gt; R28	# spill size = 64
0dac +  spill [sp, #40] -&gt; R29	# spill size = 32
0db0 +  spill [sp, #48] -&gt; [sp, #44]	# spill size = 32
0db8 +  li R11, #-187	# int, #@loadConI
0dbc    spill R28 -&gt; [sp, #16]	# spill size = 64
0dc0 +  spill R29 -&gt; [sp, #24]	# spill size = 32
0dc4 +  spill R31 -&gt; [sp, #40]	# spill size = 32
0dc8 +  spill R7 -&gt; [sp, #48]	# spill size = 32
0dcc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:76 (line 338) L[0]=sp + #32 L[1]=_ L[2]=sp + #40 L[3]=sp + #48 L[4]=_ L[5]=_ STK[0]=sp + #40 STK[1]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=sp + #16 L[1]=sp + #32 L[2]=_ L[3]=sp + #16 L[4]=sp + #24 L[5]=_ L[6]=_ L[7]=sp + #44 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[16]=Oop [32]=Oop off=3536/0xdd0}
0dd0    #@ShouldNotReachHere

0ddc    B202: #	out( N2499 ) &lt;- in( B138 )  Freq: 4.9588e-07
0ddc +  spill [sp, #24] -&gt; R8	# spill size = 64
0de0 +  spill [sp, #32] -&gt; [sp, #0]	# spill size = 64
0de8 +  li R11, #-187	# int, #@loadConI
0dec    spill R7 -&gt; [sp, #20]	# spill size = 32
0df0 +  spill [sp, #48] -&gt; [sp, #24]	# spill size = 32
0df8 +  spill R10 -&gt; [sp, #32]	# spill size = 64
0dfc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::relativize @ bci:172 (line 434) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=R8 L[4]=sp + #20 L[5]=_ L[6]=_ L[7]=sp + #24 L[8]=sp + #32 L[9]=#0 L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=sp + #24 STK[1]=sp + #40
        # OopMap {fp=Oop [0]=Oop [32]=Oop off=3584/0xe00}
0e00    #@ShouldNotReachHere

0e0c    B203: #	out( N2499 ) &lt;- in( B25 )  Freq: 4.82953e-07
0e0c    #@ShouldNotReachHere

0e18    B204: #	out( N2499 ) &lt;- in( B26 )  Freq: 4.82952e-07
0e18    #@ShouldNotReachHere

0e24    B205: #	out( N2499 ) &lt;- in( B27 )  Freq: 4.82952e-07
0e24    #@ShouldNotReachHere

0e30    B206: #	out( N2499 ) &lt;- in( B28 )  Freq: 4.82951e-07
0e30    #@ShouldNotReachHere

0e3c    B207: #	out( N2499 ) &lt;- in( B39 )  Freq: 4.76398e-07
0e3c +  li R11, #-187	# int, #@loadConI
0e40    spill R10 -&gt; [sp, #24]	# spill size = 32
0e44    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::relativize @ bci:61 (line 405) L[0]=R8 L[1]=sp + #0 L[2]=sp + #0 L[3]=R8 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=sp + #24
        # OopMap {fp=Oop [0]=Oop off=3656/0xe48}
0e48    #@ShouldNotReachHere

0e54    B208: #	out( N2499 ) &lt;- in( B113 )  Freq: 4.72923e-07
0e54 +  spill [sp, #24] -&gt; R8	# spill size = 64
0e58 +  li R11, #-187	# int, #@loadConI
0e5c    spill R22 -&gt; [sp, #8]	# spill size = 64
0e60 +  spill R7 -&gt; [sp, #24]	# spill size = 32
0e64 +  spill R28 -&gt; [sp, #32]	# spill size = 32
0e68 +  spill R19 -&gt; [sp, #40]	# spill size = 32
0e6c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::relativize @ bci:136 (line 425) L[0]=R8 L[1]=sp + #8 L[2]=sp + #8 L[3]=R8 L[4]=sp + #24 L[5]=sp + #32 L[6]=_ L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=sp + #40 STK[1]=sp + #32
        # OopMap {fp=Oop [8]=Oop off=3696/0xe70}
0e70    #@ShouldNotReachHere

0e7c    B209: #	out( N2499 ) &lt;- in( B115 )  Freq: 4.72913e-07
0e7c +  spill [sp, #40] -&gt; R28	# spill size = 32
0e80 +  spill [sp, #32] -&gt; [sp, #0]	# spill size = 64
0e88 +  li R11, #-187	# int, #@loadConI
0e8c    spill [sp, #24] -&gt; R8	# spill size = 64
0e90 +  spill R28 -&gt; [sp, #16]	# spill size = 32
0e94 +  spill [sp, #48] -&gt; [sp, #32]	# spill size = 32
0e9c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:5 (line 325) L[0]=sp + #0 L[1]=sp + #32 L[2]=sp + #44 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #32
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=R8 L[4]=sp + #16 L[5]=_ L[6]=_ L[7]=sp + #32 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [0]=Oop off=3744/0xea0}
0ea0    #@ShouldNotReachHere

0eac    B210: #	out( N2499 ) &lt;- in( B117 )  Freq: 4.72912e-07
0eac +  spill [sp, #24] -&gt; R7	# spill size = 64
0eb0 +  spill R7 -&gt; [sp, #16]	# spill size = 64
0eb4 +  spill [sp, #40] -&gt; R7	# spill size = 32
0eb8 +  spill [sp, #44] -&gt; R28	# spill size = 32
0ebc +  li R11, #-187	# int, #@loadConI
0ec0    spill R7 -&gt; [sp, #24]	# spill size = 32
0ec4 +  spill R28 -&gt; [sp, #28]	# spill size = 32
0ec8 +  spill [sp, #48] -&gt; [sp, #40]	# spill size = 32
0ed0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:22 (line 327) L[0]=sp + #32 L[1]=sp + #40 L[2]=sp + #28 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #40 STK[1]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=sp + #16 L[1]=sp + #32 L[2]=_ L[3]=sp + #16 L[4]=sp + #24 L[5]=_ L[6]=_ L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[16]=Oop [32]=Oop off=3796/0xed4}
0ed4    #@ShouldNotReachHere

0ee0    B211: #	out( N2499 ) &lt;- in( B119 )  Freq: 4.72912e-07
0ee0 +  spill [sp, #24] -&gt; R7	# spill size = 64
0ee4 +  spill R7 -&gt; [sp, #16]	# spill size = 64
0ee8 +  spill [sp, #40] -&gt; R7	# spill size = 32
0eec +  li R11, #-187	# int, #@loadConI
0ef0    spill R7 -&gt; [sp, #24]	# spill size = 32
0ef4 +  spill R31 -&gt; [sp, #40]	# spill size = 32
0ef8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:39 (line 329) L[0]=sp + #32 L[1]=sp + #48 L[2]=sp + #40 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #40 STK[1]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=sp + #16 L[1]=sp + #32 L[2]=_ L[3]=sp + #16 L[4]=sp + #24 L[5]=_ L[6]=_ L[7]=sp + #48 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[16]=Oop [32]=Oop off=3836/0xefc}
0efc    #@ShouldNotReachHere

0f08    B212: #	out( N2499 ) &lt;- in( B120 )  Freq: 4.72911e-07
0f08 +  spill [sp, #40] -&gt; R28	# spill size = 32
0f0c +  spill [sp, #32] -&gt; [sp, #0]	# spill size = 64
0f14 +  li R11, #-187	# int, #@loadConI
0f18    spill [sp, #24] -&gt; R8	# spill size = 64
0f1c +  spill R28 -&gt; [sp, #16]	# spill size = 32
0f20 +  spill R31 -&gt; [sp, #32]	# spill size = 32
0f24 +  spill [sp, #48] -&gt; [sp, #36]	# spill size = 32
0f2c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:52 (line 331) L[0]=sp + #0 L[1]=sp + #36 L[2]=sp + #32 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #36 STK[1]=sp + #32
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=R8 L[4]=sp + #16 L[5]=_ L[6]=_ L[7]=sp + #36 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [0]=Oop off=3888/0xf30}
0f30    #@ShouldNotReachHere

0f3c    B213: #	out( N2499 ) &lt;- in( B137 )  Freq: 4.72908e-07
0f3c +  spill [sp, #24] -&gt; R7	# spill size = 64
0f40 +  spill [sp, #32] -&gt; [sp, #8]	# spill size = 64
0f48 +  li R11, #-187	# int, #@loadConI
0f4c    spill R7 -&gt; [sp, #16]	# spill size = 64
0f50 +  spill R10 -&gt; [sp, #32]	# spill size = 64
0f54    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::isEmpty @ bci:5 (line 216) L[0]=_ STK[0]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:163 (line 430) L[0]=sp + #16 L[1]=sp + #8 L[2]=_ L[3]=sp + #16 L[4]=sp + #40 L[5]=_ L[6]=_ L[7]=sp + #48 L[8]=sp + #32 L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[8]=Oop [16]=Oop [32]=Oop off=3928/0xf58}
0f58    #@ShouldNotReachHere

0f64    B214: #	out( B162 ) &lt;- in( B10 )  Freq: 4.54958e-07
0f64 +  li R31, #0	# int, #@loadConI
0f68 +  j  B162	#@branch

0f6c    B215: #	out( N2499 ) &lt;- in( B2 )  Freq: 1e-35
0f6c +  li R11, #-34	# int, #@loadConI
0f70    spill R7 -&gt; R8	# spill size = 64
0f74 +  spill R12 -&gt; [sp, #8]	# spill size = 64
0f78 +  spill R12 -&gt; [sp, #16]	# spill size = 64
0f7c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::toUnixPath @ bci:13 (line 166) L[0]=sp + #16 STK[0]=sp + #8
        # sun.nio.fs.UnixPath::relativize @ bci:1 (line 392) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=3968/0xf80}
0f80    #@ShouldNotReachHere

0f8c    B216: #	out( N2499 ) &lt;- in( B50 )  Freq: 8.03969e-06
0f8c +  li R11, #-10	# int, #@loadConI
0f90    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:21 (line 304) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=3988/0xf94}
0f94    #@ShouldNotReachHere

0fa0    B217: #	out( N2499 ) &lt;- in( B52 )  Freq: 8.03967e-06
0fa0 +  li R11, #-10	# int, #@loadConI
0fa4    spill R30 -&gt; R8	# spill size = 32
0fa8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:38 (line 307) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4012/0xfac}
0fac    #@ShouldNotReachHere

0fb8    B218: #	out( N2499 ) &lt;- in( B54 )  Freq: 8.03966e-06
0fb8 +  li R11, #-10	# int, #@loadConI
0fbc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:45 (line 309) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4032/0xfc0}
0fc0    #@ShouldNotReachHere

0fcc    B219: #	out( N2499 ) &lt;- in( B60 )  Freq: 8.03963e-06
0fcc +  spill [sp, #24] -&gt; [sp, #16]	# spill size = 64
0fd4 +  spill [sp, #32] -&gt; R28	# spill size = 32
0fd8 +  spill R28 -&gt; [sp, #24]	# spill size = 32
0fdc +  spill [sp, #36] -&gt; R31	# spill size = 32
0fe0 +  spill [sp, #40] -&gt; R28	# spill size = 32
0fe4 +  li R11, #-12	# int, #@loadConI
0fe8    spill R31 -&gt; [sp, #28]	# spill size = 32
0fec +  spill R28 -&gt; [sp, #32]	# spill size = 32
0ff0 +  spill R30 -&gt; [sp, #36]	# spill size = 32
0ff4 +  spill R9 -&gt; [sp, #40]	# spill size = 64
0ff8 +  spill R7 -&gt; [sp, #52]	# spill size = 32
0ffc +  spill R29 -&gt; [sp, #56]	# spill size = 32
1000    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #16 L[1]=_ L[2]=sp + #56 L[3]=sp + #52 L[4]=_ STK[0]=sp + #52
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=sp + #16 L[1]=sp + #8 L[2]=sp + #8 L[3]=sp + #40 L[4]=sp + #24 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #36 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[8]=Oop [16]=Oop [40]=Oop off=4100/0x1004}
1004    #@ShouldNotReachHere

1010    B220: #	out( N2499 ) &lt;- in( B69 )  Freq: 8.03945e-06
1010 +  li R11, #-10	# int, #@loadConI
1014    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:21 (line 304) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=_
        # OopMap {off=4120/0x1018}
1018    #@ShouldNotReachHere

1024    B221: #	out( N2499 ) &lt;- in( B71 )  Freq: 8.03944e-06
1024 +  li R11, #-10	# int, #@loadConI
1028    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:38 (line 307) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=sp + #0
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=_
        # OopMap {off=4140/0x102c}
102c    #@ShouldNotReachHere

1038    B222: #	out( N2499 ) &lt;- in( B73 )  Freq: 8.03942e-06
1038 +  li R11, #-10	# int, #@loadConI
103c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:45 (line 309) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=_
        # OopMap {off=4160/0x1040}
1040    #@ShouldNotReachHere

104c    B223: #	out( N2499 ) &lt;- in( B79 )  Freq: 8.0394e-06
104c +  spill [sp, #24] -&gt; R8	# spill size = 64
1050 +  spill [sp, #32] -&gt; R7	# spill size = 32
1054 +  spill R7 -&gt; [sp, #24]	# spill size = 32
1058 +  spill [sp, #40] -&gt; R7	# spill size = 32
105c +  spill R7 -&gt; [sp, #32]	# spill size = 32
1060 +  spill [sp, #36] -&gt; R28	# spill size = 32
1064 +  spill [sp, #64] -&gt; R7	# spill size = 64
1068 +  li R11, #-12	# int, #@loadConI
106c    spill R28 -&gt; [sp, #28]	# spill size = 32
1070 +  spill R9 -&gt; [sp, #36]	# spill size = 32
1074 +  spill R20 -&gt; [sp, #52]	# spill size = 32
1078 +  spill R7 -&gt; [sp, #56]	# spill size = 64
107c +  spill R29 -&gt; [sp, #64]	# spill size = 32
1080    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #8 L[1]=_ L[2]=sp + #64 L[3]=sp + #52 L[4]=_ STK[0]=sp + #52
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=R8 L[1]=sp + #8 L[2]=sp + #8 L[3]=R8 L[4]=sp + #24 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #36 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#ScObj0
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=sp + #72, [path :2]=sp + #56, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # OopMap {fp=Oop [8]=Oop [56]=Oop [72]=Oop off=4228/0x1084}
1084    #@ShouldNotReachHere

1090    B224: #	out( N2499 ) &lt;- in( B56 )  Freq: 7.35921e-06
1090 +  li R11, #-10	# int, #@loadConI
1094    spill R10 -&gt; R8	# spill size = 32
1098    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:69 (line 312) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4252/0x109c}
109c    #@ShouldNotReachHere

10a8    B225: #	out( N2499 ) &lt;- in( B75 )  Freq: 7.35899e-06
10a8 +  li R11, #-10	# int, #@loadConI
10ac    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:69 (line 312) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=sp + #4
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=_
        # OopMap {off=4272/0x10b0}
10b0    #@ShouldNotReachHere

10bc    B226: #	out( N2499 ) &lt;- in( B3 )  Freq: 1.01328e-06
10bc +  li R11, #-10	# int, #@loadConI
10c0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:4 (line 713) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::equals @ bci:14 (line 735) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.UnixPath::relativize @ bci:7 (line 393) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4292/0x10c4}
10c4    #@ShouldNotReachHere

10d0    B227: #	out( N2499 ) &lt;- in( B4 )  Freq: 1.01328e-06
10d0 +  li R11, #-10	# int, #@loadConI
10d4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:13 (line 714) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::equals @ bci:14 (line 735) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.UnixPath::relativize @ bci:7 (line 393) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4312/0x10d8}
10d8    #@ShouldNotReachHere

10e4    B228: #	out( N2499 ) &lt;- in( B41 )  Freq: 1.01233e-06
10e4 +  li R11, #-10	# int, #@loadConI
10e8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getNameCount @ bci:8 (line 296) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:75 (line 410) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4332/0x10ec}
10ec    #@ShouldNotReachHere

10f8    B229: #	out( N2499 ) &lt;- in( B43 )  Freq: 1.0123e-06
10f8 +  li R11, #-10	# int, #@loadConI
10fc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getNameCount @ bci:8 (line 296) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:81 (line 411) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4352/0x1100}
1100    #@ShouldNotReachHere

110c    B230: #	out( N2499 ) &lt;- in( B116 )  Freq: 1.00494e-06
110c +  li R11, #-10	# int, #@loadConI
1110    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:21 (line 327) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4372/0x1114}
1114    #@ShouldNotReachHere

1120    B231: #	out( N2499 ) &lt;- in( B118 )  Freq: 1.00494e-06
1120 +  li R11, #-10	# int, #@loadConI
1124    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:38 (line 329) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4392/0x1128}
1128    #@ShouldNotReachHere

1134    B232: #	out( N2499 ) &lt;- in( B121 )  Freq: 1.00494e-06
1134 +  li R11, #-10	# int, #@loadConI
1138    spill [sp, #48] -&gt; R8	# spill size = 32
113c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:68 (line 336) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4416/0x1140}
1140    #@ShouldNotReachHere

114c    B233: #	out( N2499 ) &lt;- in( B123 )  Freq: 1.00493e-06
114c +  li R11, #-10	# int, #@loadConI
1150    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:75 (line 338) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4436/0x1154}
1154    #@ShouldNotReachHere

1160    B234: #	out( N2499 ) &lt;- in( B125 )  Freq: 1.00493e-06
1160 +  li R11, #-10	# int, #@loadConI
1164    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:83 (line 339) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4456/0x1168}
1168    #@ShouldNotReachHere

1174    B235: #	out( N2499 ) &lt;- in( B136 )  Freq: 1.00493e-06
1174 +  li R11, #-10	# int, #@loadConI
1178    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::isEmpty @ bci:4 (line 216) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:163 (line 430) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4476/0x117c}
117c    #@ShouldNotReachHere

1188    B236: #	out( N2499 ) &lt;- in( B140 )  Freq: 6.80439e-07
1188 +  li R11, #-10	# int, #@loadConI
118c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:55 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4496/0x1190}
1190    #@ShouldNotReachHere

119c    B237: #	out( N2499 ) &lt;- in( B142 )  Freq: 6.80419e-07
119c +  li R11, #-10	# int, #@loadConI
11a0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:55 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=_
        # OopMap {off=4516/0x11a4}
11a4    #@ShouldNotReachHere

11b0    B238: #	out( N2499 ) &lt;- in( B1 )  Freq: 4.76837e-07
11b0 +  li R11, #-187	# int, #@loadConI
11b4    spill R7 -&gt; R8	# spill size = 64
11b8 +  spill R12 -&gt; [sp, #8]	# spill size = 64
11bc +  spill R12 -&gt; [sp, #16]	# spill size = 64
11c0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::toUnixPath @ bci:1 (line 164) L[0]=sp + #16 STK[0]=sp + #8
        # sun.nio.fs.UnixPath::relativize @ bci:1 (line 392) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=4548/0x11c4}
11c4    #@ShouldNotReachHere

11d0    B239: #	out( B244 ) &lt;- in( B163 )  Freq: 9.91925e-10
11d0     -- 	// exception oop; no code emitted, #@CreateException
11d0 +  j  B244	#@branch

11d4    B240: #	out( B244 ) &lt;- in( B165 )  Freq: 1.00197e-09
11d4     -- 	// exception oop; no code emitted, #@CreateException
11d4 +  j  B244	#@branch

11d8    B241: #	out( B252 ) &lt;- in( B155 )  Freq: 8.01572e-09
11d8     -- 	// exception oop; no code emitted, #@CreateException
11d8 +  j  B252	#@branch

11dc    B242: #	out( B250 ) &lt;- in( B153 )  Freq: 8.01596e-09
11dc     -- 	// exception oop; no code emitted, #@CreateException
11dc +  j  B250	#@branch

11e0    B243: #	out( B244 ) &lt;- in( B114 )  Freq: 9.9179e-06
11e0     -- 	// exception oop; no code emitted, #@CreateException

11e0    B244: #	out( B253 ) &lt;- in( B243 B240 B239 )  Freq: 9.9199e-06
11e0 +  spill R10 -&gt; R11	# spill size = 64
11e4 +  j  B253	#@branch

11e8    B245: #	out( B253 ) &lt;- in( B42 )  Freq: 9.99058e-06
11e8     -- 	// exception oop; no code emitted, #@CreateException
11e8 +  spill R10 -&gt; R11	# spill size = 64
11ec +  j  B253	#@branch

11f0    B246: #	out( B253 ) &lt;- in( B40 )  Freq: 9.99079e-06
11f0     -- 	// exception oop; no code emitted, #@CreateException
11f0 +  spill R10 -&gt; R11	# spill size = 64
11f4 +  j  B253	#@branch

11f8    B247: #	out( B253 ) &lt;- in( B38 )  Freq: 9.991e-06
11f8     -- 	// exception oop; no code emitted, #@CreateException
11f8 +  spill R10 -&gt; R11	# spill size = 64
11fc +  j  B253	#@branch

1200    B248: #	out( B253 ) &lt;- in( B36 )  Freq: 9.9912e-06
1200     -- 	// exception oop; no code emitted, #@CreateException
1200 +  spill R10 -&gt; R11	# spill size = 64
1204 +  j  B253	#@branch

1208    B249: #	out( B250 ) &lt;- in( B49 )  Freq: 7.93449e-05
1208     -- 	// exception oop; no code emitted, #@CreateException

1208    B250: #	out( B253 ) &lt;- in( B249 B242 )  Freq: 7.93529e-05
1208 +  spill R10 -&gt; R11	# spill size = 64
120c +  j  B253	#@branch

1210    B251: #	out( B252 ) &lt;- in( B68 )  Freq: 7.93425e-05
1210     -- 	// exception oop; no code emitted, #@CreateException

1210    B252: #	out( B253 ) &lt;- in( B251 B241 )  Freq: 7.93505e-05
1210 +  spill R10 -&gt; R11	# spill size = 64

1214    B253: #	out( N2499 ) &lt;- in( B248 B247 B246 B245 B250 B252 B244 )  Freq: 0.000208587
1214    # pop frame 128
	add  sp, sp, #128
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
1220 +  j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='316'>
----------------------- MetaData before Compile_id = 316 ------------------------
{method}
 - this oop:          0x00000040962eecc0
 - method holder:     &apos;java/lang/ThreadLocal$ThreadLocalMap&apos;
 - constants:         0x00000040962ee148 constant pool [142] {0x00000040962ee148} for &apos;java/lang/ThreadLocal$ThreadLocalMap&apos; cache=0x00000040962ef9e0
 - access:            0x81000002  private 
 - name:              &apos;getEntry&apos;
 - signature:         &apos;(Ljava/lang/ThreadLocal;)Ljava/lang/ThreadLocal$ThreadLocalMap$Entry;&apos;
 - max stack:         5
 - max locals:        4
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bd00: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c5076c0
 - code size:         42
 - code start:        0x00000040962eec58
 - code end (excl):   0x00000040962eec82
 - method data:       0x0000004096481668
 - checked ex length: 0
 - linenumber start:  0x00000040962eec82
 - localvar length:   4
 - localvar start:    0x00000040962eec8c
 - compiled code: nmethod   9880  179       3       java.lang.ThreadLocal$ThreadLocalMap::getEntry (42 bytes)

------------------------ OptoAssembly for Compile_id = 316 -----------------------
#
#  java/lang/ThreadLocal$ThreadLocalMap$Entry * ( java/lang/ThreadLocal$ThreadLocalMap:NotNull *, java/lang/ThreadLocal * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/ThreadLocal$ThreadLocalMap:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/ThreadLocal *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N105: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B9 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap.table
040 +   spill R11 -&gt; R31	# spill size = 64
044 +   decode_heap_oop  R7, R7	#@decodeHeapOop
048     lw  R28, [R12, #12]	# int, #@loadI ! Field: java/lang/ThreadLocal.threadLocalHashCode (constant)
04c     NullCheck R12

04c     B2: #	out( B10 B3 ) &lt;- in( B1 )  Freq: 0.999999
04c     lwu  R30, [R7, #12]	# range, #@loadRange
050     NullCheck R7

050     B3: #	out( B7 B4 ) &lt;- in( B2 )  Freq: 0.999998
050 +   addiw  R29, R30, #-1	#@addI_reg_imm
054 +   andr  R8, R28, R29	#@andI_reg_reg
058 +   addw  R28, R8, zr	#@convI2L_reg_reg
05c +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
060 +   add R28, R7, R28	# ptr, #@addP_reg_reg
064 +   bleu  R30, zr, B7	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

068     B4: #	out( B11 B5 ) &lt;- in( B3 )  Freq: 0.999997
068 +   lwu  R28, [R28, #16]	# loadN, compressed ptr, #@loadN
06c +   decode_heap_oop  R10, R28	#@decodeHeapOop
070     lwu  R7, [R10, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
074     NullCheck R10

074     B5: #	out( B8 B6 ) &lt;- in( B4 )  Freq: 0.999996
074 +   decode_heap_oop  R7, R7	#@decodeHeapOop
078     
078 +   bne  R7, R12, B8	#@cmpP_branch  P=0.000001 C=-1.000000

07c     B6: #	out( N105 ) &lt;- in( B5 )  Freq: 0.999995
07c     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
094 +   ret	// return register, #@Ret

098     B7: #	out( N105 ) &lt;- in( B3 )  Freq: 9.99998e-07
098 +   li R11, #-28	# int, #@loadConI
09c     spill R31 -&gt; [sp, #0]	# spill size = 64
0a0 +   spill R12 -&gt; [sp, #8]	# spill size = 64
0a4 +   spill R7 -&gt; [sp, #16]	# spill size = 64
0a8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:18 (line 435) L[0]=sp + #0 L[1]=sp + #8 L[2]=R8 L[3]=_ STK[0]=sp + #16 STK[1]=R8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=172/0xac}
0ac     #@ShouldNotReachHere

0b8     B8: #	out( N105 ) &lt;- in( B5 )  Freq: 9.99996e-07
0b8 +   li R11, #-187	# int, #@loadConI
0bc     spill R31 -&gt; [sp, #0]	# spill size = 64
0c0 +   spill R12 -&gt; [sp, #8]	# spill size = 64
0c4 +   spill R10 -&gt; [sp, #16]	# spill size = 64
0c8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:29 (line 436) L[0]=sp + #0 L[1]=sp + #8 L[2]=R8 L[3]=sp + #16 STK[0]=#0
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=204/0xcc}
0cc     #@ShouldNotReachHere

0d8     B9: #	out( N105 ) &lt;- in( B1 )  Freq: 1.01328e-06
0d8 +   li R11, #-10	# int, #@loadConI
0dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:1 (line 434) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # OopMap {off=224/0xe0}
0e0     #@ShouldNotReachHere

0ec     B10: #	out( N105 ) &lt;- in( B2 )  Freq: 1.01328e-06
0ec +   li R11, #-10	# int, #@loadConI
0f0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:8 (line 434) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=244/0xf4}
0f4     #@ShouldNotReachHere

100     B11: #	out( N105 ) &lt;- in( B4 )  Freq: 4.76836e-07
100 +   li R11, #-187	# int, #@loadConI
104     spill R31 -&gt; [sp, #0]	# spill size = 64
108 +   spill R12 -&gt; [sp, #8]	# spill size = 64
10c +   spill R10 -&gt; [sp, #24]	# spill size = 64
110     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:21 (line 436) L[0]=sp + #0 L[1]=sp + #8 L[2]=R8 L[3]=sp + #24 STK[0]=sp + #24
        # OopMap {[0]=Oop [8]=Oop [24]=Oop off=276/0x114}
114 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='317'>
----------------------- MetaData before Compile_id = 317 ------------------------
{method}
 - this oop:          0x0000004096210c78
 - method holder:     &apos;java/lang/ThreadLocal&apos;
 - constants:         0x0000004096210350 constant pool [141] {0x0000004096210350} for &apos;java/lang/ThreadLocal&apos; cache=0x0000004096211498
 - access:            0x81000001  public 
 - name:              &apos;get&apos;
 - signature:         &apos;()Ljava/lang/Object;&apos;
 - max stack:         3
 - max locals:        5
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      10
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4f9ac0
 - code size:         38
 - code start:        0x0000004096210c00
 - code end (excl):   0x0000004096210c26
 - method data:       0x0000004096481408
 - checked ex length: 0
 - linenumber start:  0x0000004096210c26
 - localvar length:   5
 - localvar start:    0x0000004096210c38
 - compiled code: nmethod   9913  147       3       java.lang.ThreadLocal::get (38 bytes)

------------------------ OptoAssembly for Compile_id = 317 -----------------------
#
#  java/lang/Object * ( java/lang/ThreadLocal:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/ThreadLocal:NotNull *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N117: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B10 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c      -- 	// R23=Thread::current(), empty, #@tlsLoadP
03c     ld  R7, [R23, #712]	# ptr, #@loadP
040 +   ld  R7, [R7]	# ptr, #@loadP
044 +   lwu  R28, [R7, #68]	# loadN, compressed ptr, #@loadN ! Field: java/lang/Thread.threadLocals
048 +   spill R11 -&gt; R10	# spill size = 64
04c +   decode_heap_oop  R7, R28	#@decodeHeapOop
050     lwu  R28, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap.table
054     NullCheck R7

054     B2: #	out( B9 B3 ) &lt;- in( B1 )  Freq: 1
054 +   decode_heap_oop  R30, R28	#@decodeHeapOop
058     lwu  R29, [R30, #12]	# range, #@loadRange
05c     NullCheck R30

05c     B3: #	out( B7 B4 ) &lt;- in( B2 )  Freq: 0.999999
05c +   lw  R28, [R11, #12]	# int, #@loadI ! Field: java/lang/ThreadLocal.threadLocalHashCode (constant)
060 +   addiw  R31, R29, #-1	#@addI_reg_imm
064 +   andr  R31, R28, R31	#@andI_reg_reg
068 +   addw  R28, R31, zr	#@convI2L_reg_reg
06c +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
070 +   add R28, R30, R28	# ptr, #@addP_reg_reg
074 +   bleu  R29, zr, B7	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

078     B4: #	out( B11 B5 ) &lt;- in( B3 )  Freq: 0.999997
078 +   lwu  R28, [R28, #16]	# loadN, compressed ptr, #@loadN
07c +   decode_heap_oop  R8, R28	#@decodeHeapOop
080     lwu  R29, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
084     NullCheck R8

084     B5: #	out( B8 B6 ) &lt;- in( B4 )  Freq: 0.999997
084 +   decode_heap_oop  R28, R29	#@decodeHeapOop
088     
088 +   bne  R28, R11, B8	#@cmpP_branch  P=0.000001 C=-1.000000

08c     B6: #	out( N117 ) &lt;- in( B5 )  Freq: 0.999996
08c +   lwu  R7, [R8, #28]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap$Entry.value
090 +   decode_heap_oop  R10, R7	#@decodeHeapOop
094     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0ac +   ret	// return register, #@Ret

0b0     B7: #	out( N117 ) &lt;- in( B3 )  Freq: 9.99999e-07
0b0 +   li R11, #-28	# int, #@loadConI
0b4     spill R7 -&gt; [sp, #0]	# spill size = 64
0b8 +   spill R10 -&gt; [sp, #8]	# spill size = 64
0bc +   spill R30 -&gt; [sp, #24]	# spill size = 64
0c0 +   spill R31 -&gt; [sp, #20]	# spill size = 32
0c4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:18 (line 435) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #20 L[3]=_ STK[0]=sp + #24 STK[1]=sp + #20
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # OopMap {[0]=Oop [8]=Oop [24]=Oop off=200/0xc8}
0c8     #@ShouldNotReachHere

0d4     B8: #	out( N117 ) &lt;- in( B5 )  Freq: 9.99997e-07
0d4 +   li R11, #-187	# int, #@loadConI
0d8     spill R7 -&gt; [sp, #8]	# spill size = 64
0dc +   spill R10 -&gt; [sp, #16]	# spill size = 64
0e0 +   spill R31 -&gt; [sp, #24]	# spill size = 32
0e4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:29 (line 436) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #24 L[3]=R8 STK[0]=#0
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=232/0xe8}
0e8     #@ShouldNotReachHere

0f4     B9: #	out( N117 ) &lt;- in( B2 )  Freq: 1.01328e-06
0f4 +   li R11, #-10	# int, #@loadConI
0f8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:8 (line 434) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # OopMap {off=252/0xfc}
0fc     #@ShouldNotReachHere

108     B10: #	out( N117 ) &lt;- in( B1 )  Freq: 4.76837e-07
108 +   li R11, #-187	# int, #@loadConI
10c     spill R10 -&gt; R8	# spill size = 64
110 +   spill R7 -&gt; [sp, #8]	# spill size = 64
114     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal::get @ bci:11 (line 164) L[0]=R8 L[1]=_ L[2]=sp + #8 L[3]=_ L[4]=_ STK[0]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=280/0x118}
118     #@ShouldNotReachHere

124     B11: #	out( N117 ) &lt;- in( B4 )  Freq: 4.76836e-07
124 +   li R11, #-187	# int, #@loadConI
128     spill R7 -&gt; [sp, #8]	# spill size = 64
12c +   spill R10 -&gt; [sp, #16]	# spill size = 64
130 +   spill R31 -&gt; [sp, #24]	# spill size = 32
134     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:21 (line 436) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #24 L[3]=R8 STK[0]=R8
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=312/0x138}
138 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='318'>
----------------------- MetaData before Compile_id = 318 ------------------------
{method}
 - this oop:          0x0000004096550570
 - method holder:     &apos;java/nio/file/FileTreeIterator&apos;
 - constants:         0x000000409654fe20 constant pool [128] {0x000000409654fe20} for &apos;java/nio/file/FileTreeIterator&apos; cache=0x0000004096550a20
 - access:            0xc1000002  private 
 - name:              &apos;fetchNextIfNeeded&apos;
 - signature:         &apos;()V&apos;
 - max stack:         4
 - max locals:        3
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c501b00
 - code size:         65
 - code start:        0x00000040965504f8
 - code end (excl):   0x0000004096550539
 - method data:       0x0000004096484b08
 - checked ex length: 0
 - linenumber start:  0x0000004096550539
 - localvar length:   3
 - localvar start:    0x000000409655054a
 - compiled code: nmethod  11398  169       3       java.nio.file.FileTreeIterator::fetchNextIfNeeded (65 bytes)

------------------------ OptoAssembly for Compile_id = 318 -----------------------
#
#  void ( java/nio/file/FileTreeIterator:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/nio/file/FileTreeIterator:NotNull *
# -- Old sp -- Framesize: 176 --
#r263 sp+172: in_preserve
#r262 sp+168: return address
#r261 sp+164: in_preserve
#r260 sp+160: saved fp register
#r259 sp+156: Fixed slot 3
#r258 sp+152: Fixed slot 2
#r257 sp+148: Fixed slot 1
#r256 sp+144: Fixed slot 0
#r299 sp+140: spill
#r298 sp+136: spill
#r297 sp+132: spill
#r296 sp+128: spill
#r295 sp+124: spill
#r294 sp+120: spill
#r293 sp+116: spill
#r292 sp+112: spill
#r291 sp+108: spill
#r290 sp+104: spill
#r289 sp+100: spill
#r288 sp+96: spill
#r287 sp+92: spill
#r286 sp+88: spill
#r285 sp+84: spill
#r284 sp+80: spill
#r283 sp+76: spill
#r282 sp+72: spill
#r281 sp+68: spill
#r280 sp+64: spill
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
0000    N6588: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0000    # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

0020    B1: #	out( B162 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0020    # stack bang size=176
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #176
	
003c    lwu  R28, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.next
0040    spill R11 -&gt; R9	# spill size = 64
0044 +  bne   R28, zr, B162	#@cmpP_narrowOop_imm0_branch  P=0.500279 C=5375.000000

0048    B2: #	out( B410 B3 ) &lt;- in( B1 )  Freq: 0.499721
0048 +  lwu  R7, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.walker
004c +  decode_heap_oop  R18, R7	#@decodeHeapOop
0050    lwu  R28, [R18, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker.stack
0054    NullCheck R18

0054    B3: #	out( B411 B4 ) &lt;- in( B2 )  Freq: 0.49972
0054 +  decode_heap_oop  R7, R28	#@decodeHeapOop
0058    lwu  R28, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/ArrayDeque.elements
005c    NullCheck R7

005c    B4: #	out( B412 B5 ) &lt;- in( B3 )  Freq: 0.49972
005c +  lw  R30, [R7, #12]	# int, #@loadI ! Field: java/util/ArrayDeque.head
0060 +  addw  R7, R30, zr	#@convI2L_reg_reg
0064 +  decode_heap_oop  R8, R28	#@decodeHeapOop
0068 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
006c    lwu  R29, [R8, #12]	# range, #@loadRange
0070    NullCheck R8

0070    B5: #	out( B325 B6 ) &lt;- in( B4 )  Freq: 0.499719
0070 +  add R7, R8, R7	# ptr, #@addP_reg_reg
0074 +  far_bgeu R30, R29, B325	#@far_cmpU_branch  P=0.000001 C=-1.000000

007c    B6: #	out( B162 B7 ) &lt;- in( B5 )  Freq: 0.499719
007c +  lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN
0080 +  decode_heap_oop  R24, R7	#@decodeHeapOop
0084 +  beq   R24, zr, B162	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

0088    B7: #	out( B399 B8 ) &lt;- in( B6 )  Freq: 0.499219
0088 +  lwu  R28, [R24, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
008c +  mv  R7, narrowklass: precise klass java/nio/file/FileTreeWalker$DirectoryNode: 0x00000040d83de8c0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
009c +  far_bne  R28, R7, B399	#@far_cmpN_branch  P=0.000000 C=-1.000000

00a4    B8: #	out( B356 B9 ) &lt;- in( B7 )  Freq: 0.499219
00a4 +  # checkcastPP of R24, #@checkCastPP
00a4    lwu  R28, [R24, #28]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.iterator
00a8 +  lbu  R8, [R24, #12]	# byte, #@loadUB ! Field: java/nio/file/FileTreeWalker$DirectoryNode.skipped
00ac +  decode_heap_oop  R19, R28	#@decodeHeapOop
00b0 +  far_bne  R8, zr, B356	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2774.000000

00b8    B9: #	out( B413 B10 ) &lt;- in( B8 )  Freq: 0.499219
00b8    lwu  R7, [R19, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
00bc    NullCheck R19

00bc    B10: #	out( B326 B11 ) &lt;- in( B9 )  Freq: 0.499218
00bc +  mv  R29, narrowklass: precise klass sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator: 0x00000040d8247b80:Constant:exact *	# compressed klass ptr, #@loadConNKlass
00cc +  far_bne  R7, R29, B326	#@far_cmpN_branch  P=0.000001 C=-1.000000

00d4    B11: #	out( B327 B12 ) &lt;- in( B10 )  Freq: 0.499218
00d4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
00d4    ld  R7, [R23, #712]	# ptr, #@loadP
00d8 +  ld  R20, [R7]	# ptr, #@loadP
00dc +  add R29, sp, #144	# box lock
00e0 +  # checkcastPP of R19, #@checkCastPP
00e0    fastlock R19,R29	! kills R7,R28, #@cmpFastLock
0174 +  far_bne RFLAGS, zr, B327	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

017c    B12: #	out( B357 B13 ) &lt;- in( B327 B11 )  Freq: 0.499218
017c +  #@membar_acquire_lock (elided)
017c +  lwu  R28, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
0180 +  lwu  R7, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
0184 +  decode_heap_oop  R8, R28	#@decodeHeapOop
0188 +  lbu  R29, [R19, #12]	# byte, #@loadUB ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.atEof
018c +  decode_heap_oop  R7, R7	#@decodeHeapOop
0190 +  far_bne   R8, zr, B357	#@far_cmpP_imm0_branch  P=0.000000 C=2778.000000

0198    B13: #	out( B358 B14 ) &lt;- in( B12 )  Freq: 0.499218
0198 +  far_bne  R29, zr, B358	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2778.000000

01a0    B14: #	out( B414 B15 ) &lt;- in( B13 )  Freq: 0.499217
01a0    lwu  R28, [R7, #32]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream.streamLock
01a4    NullCheck R7

01a4    B15: #	out( B415 B16 ) &lt;- in( B14 )  Freq: 0.499217
01a4 +  decode_heap_oop  R7, R28	#@decodeHeapOop
01a8    lwu  R7, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock.readerLock
01ac    NullCheck R7

01ac    B16: #	out( B416 B17 ) &lt;- in( B15 )  Freq: 0.499216
01ac +  decode_heap_oop  R8, R7	#@decodeHeapOop
01b0    # checkcastPP of R8, #@checkCastPP
01b0    lwu  R28, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
01b4    NullCheck R8

01b4    B17: #	out( B328 B18 ) &lt;- in( B16 )  Freq: 0.499216
01b4 +  mv  R7, narrowklass: precise klass java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock: 0x00000040d836c7e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
01c4 +  far_bne  R28, R7, B328	#@far_cmpN_branch  P=0.000001 C=-1.000000

01cc    B18: #	out( B417 B19 ) &lt;- in( B17 )  Freq: 0.499215
01cc +  # checkcastPP of R8, #@checkCastPP
01cc    lwu  R28, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock.sync
01d0 +  decode_heap_oop  R21, R28	#@decodeHeapOop
01d4    lw  R30, [R21, #16]	# int, #@loadI ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.state
01d8    NullCheck R21

01d8    B19: #	out( B371 B20 ) &lt;- in( B18 )  Freq: 0.499215
01d8 +  #@membar_acquire
	fence ir iorw
01dc +  zext.h  R8, R30	# s2ui, #@convS2UI_reg_reg_b
01e0 +  far_bne  R8, zr, B371	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2964.000000

01e8    B20: #	out( B329 B21 ) &lt;- in( B19 )  Freq: 0.499215
01e8 +  lwu  R7, [R21, #20]	# loadN, compressed ptr, #@loadN ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.head
01ec +  #@membar_acquire
	fence ir iorw
01f0 +  decode_heap_oop  R8, R7	#@decodeHeapOop
01f4 +  srliw  R31, R30, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
01f8 +  far_bne   R8, zr, B329	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0200    B21: #	out( B372 B22 ) &lt;- in( B20 )  Freq: 0.499214
0200 +  li R28, #65535	# int, #@loadConI
0208 +  far_bge  R31, R28, B372	#@far_cmpI_branch  P=0.000000 C=2964.000000

0210    B22: #	out( B373 B23 ) &lt;- in( B21 )  Freq: 0.499214
0210 +  #@membar_release
	fence iorw ow
0214 +  li R29, #65536	# int, #@loadConI
0218 +  addw  R29, R30, R29	#@addI_reg_reg
021c +  addi  R7, R21, #16	# ptr, #@addP_reg_imm
0220    
0220 +  cmpxchg_acq [R7], R30, R29	# (int) if [R7] == R30 then [R7] &lt;-- R29
	mv R8, R8 == R30	# R8 &lt;-- (R8 == R30 ? 1 : 0), #@compareAndSwapIAcq
023c    
023c +  #@membar_acquire
	fence ir iorw
0240 +  far_beq  R8, zr, B373	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2964.000000

0248    B23: #	out( B359 B24 ) &lt;- in( B22 )  Freq: 0.499214
0248 +  far_bne  R31, zr, B359	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2964.000000

0250    B24: #	out( B228 B25 ) &lt;- in( B23 )  Freq: 0.499213
0250 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0250    lb  R7, [R23, #56]	# byte, #@loadB
0254 +  far_bne  R7, zr, B228	#@far_cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

025c    B25: #	out( B27 B26 ) &lt;- in( B360 B230 B228 B24 )  Freq: 0.499213
025c +  mv  R7, R21	# ptr -&gt; long, #@castP2X
0260 +  mv  R28, R20	# ptr -&gt; long, #@castP2X
0264 +  xorr  R29, R28, R7	#@xorL_reg_reg
0268 +  encode_heap_oop  R28, R20	#@encodeHeapOop
026c +  srli  R29, R29, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0270 +  sw  R28, [R21, #40]	# compressed ptr, #@storeN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
0274 +  beq  R29, zr, B27	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0278    B26: #	out( B237 B27 ) &lt;- in( B25 )  Freq: 0.498714
0278 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
027c +  mv  R29, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
0288 +  add R10, R29, R7	# ptr, #@addP_reg_reg
028c +  lb  R29, [R10]	# byte, #@loadB
0290 +  li R7, #4	# int, #@loadConI
0294 +  far_bne  R29, R7, B237	#@far_cmpI_branch  P=0.001000 C=-1.000000

029c    B27: #	out( B28 ) &lt;- in( B239 B240 B237 B26 B25 )  Freq: 0.499213
029c +  li R29, #1	# int, #@loadConI
02a0 +  sw  R29, [R21, #28]	# int, #@storeI ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReaderHoldCount

02a4    B28: #	out( B404 B29 ) &lt;- in( B27 B180 ) Loop( B28-B180 inner ) Freq: 0.525792
02a4 +  lwu  R7, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
02a8 +  decode_heap_oop  R7, R7	#@decodeHeapOop
02ac    lbu  R8, [R7, #12]	# byte, #@loadUB ! Field: volatile sun/nio/fs/UnixDirectoryStream.isClosed
02b0    NullCheck R7

02b0    B29: #	out( B350 B30 ) &lt;- in( B28 )  Freq: 0.525792
02b0 +  #@membar_acquire
	fence ir iorw
02b4 +  lwu  R29, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
02b8 +  decode_heap_oop  R7, R29	#@decodeHeapOop
02bc +  far_bne  R8, zr, B350	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2964.000000

02c4    B30: #	out( B405 B31 ) &lt;- in( B29 )  Freq: 0.525792
02c4    ld  R11, [R7, #16]	# int, #@loadL ! Field: sun/nio/fs/UnixDirectoryStream.dp
02c8    NullCheck R7

02c8    B31: #	out( B403 B32 ) &lt;- in( B30 )  Freq: 0.525791
02c8 +  spill R28 -&gt; [sp, #40]	# spill size = 32
02cc +  spill R20 -&gt; [sp, #32]	# spill size = 64
02d0 +  spill R19 -&gt; [sp, #0]	# spill size = 64
02d4 +  spill R24 -&gt; [sp, #24]	# spill size = 64
02d8 +  spill R18 -&gt; [sp, #16]	# spill size = 64
02dc +  spill R9 -&gt; [sp, #8]	# spill size = 64
02e0    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect sun.nio.fs.UnixNativeDispatcher::readdir
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:52 (line 165) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=NarrowOop off=740/0x2e4}

02e4    B32: #	out( B406 B33 ) &lt;- in( B31 )  Freq: 0.525781
        # Block is sole successor of call
02e4 +  spill [sp, #0] -&gt; R28	# spill size = 64
02e8 +  lwu  R7, [R28, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
02ec +  spill R10 -&gt; [sp, #48]	# spill size = 64
02f0 +  decode_heap_oop  R7, R7	#@decodeHeapOop
02f4    lwu  R29, [R7, #32]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream.streamLock
02f8    NullCheck R7

02f8    B33: #	out( B407 B34 ) &lt;- in( B32 )  Freq: 0.52578
02f8 +  decode_heap_oop  R7, R29	#@decodeHeapOop
02fc    lwu  R7, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock.readerLock
0300    NullCheck R7

0300    B34: #	out( B408 B35 ) &lt;- in( B33 )  Freq: 0.525779
0300 +  decode_heap_oop  R8, R7	#@decodeHeapOop
0304    # checkcastPP of R8, #@checkCastPP
0304    lwu  R29, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0308    NullCheck R8

0308    B35: #	out( B321 B36 ) &lt;- in( B34 )  Freq: 0.525779
0308 +  mv  R7, narrowklass: precise klass java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock: 0x00000040d836c7e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0318 +  far_bne  R29, R7, B321	#@far_cmpN_branch  P=0.000001 C=-1.000000

0320    B36: #	out( B409 B37 ) &lt;- in( B35 )  Freq: 0.525778
0320 +  # checkcastPP of R8, #@checkCastPP
0320    lwu  R7, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock.sync
0324 +  decode_heap_oop  R12, R7	#@decodeHeapOop
0328    lwu  R29, [R12, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
032c    NullCheck R12

032c    B37: #	out( B351 B38 ) &lt;- in( B36 )  Freq: 0.525778
032c +  decode_heap_oop  R8, R29	#@decodeHeapOop
0330 +  lw  R31, [R12, #28]	# int, #@loadI ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReaderHoldCount
0334    spill [sp, #32] -&gt; R30	# spill size = 64
0338 +  far_bne  R8, R30, B351	#@far_cmpP_branch  P=0.000000 C=2964.000000

0340    B38: #	out( B352 B39 ) &lt;- in( B37 )  Freq: 0.525778
0340 +  li R29, #1	# int, #@loadConI
0344 +  far_bne  R31, R29, B352	#@far_cmpI_branch  P=0.000000 C=2964.000000

034c    B39: #	out( B225 B40 ) &lt;- in( B38 )  Freq: 0.525777
034c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
034c    lb  R7, [R23, #56]	# byte, #@loadB
0350 +  far_bne  R7, zr, B225	#@far_cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0358    B40: #	out( B355 B41 ) &lt;- in( B354 B227 B225 B39 )  Freq: 0.525777
0358 +  lw  R29, [R12, #16]	# int, #@loadI ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.state
035c +  sw  rheapbase, [R12, #40]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
0360 +  #@membar_acquire
	fence ir iorw
0364 +  #@membar_release
	fence iorw ow
0364 +  li R31, #-65536	# int, #@loadConI
0368 +  addw  R10, R29, R31	#@addI_reg_reg
036c +  addi  R7, R12, #16	# ptr, #@addP_reg_imm
0370    
0370 +  cmpxchg_acq [R7], R29, R10	# (int) if [R7] == R29 then [R7] &lt;-- R10
	mv R8, R8 == R29	# R8 &lt;-- (R8 == R29 ? 1 : 0), #@compareAndSwapIAcq
038c    
038c +  #@membar_acquire
	fence ir iorw
0390 +  far_beq  R8, zr, B355	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2964.000000

0398    B41: #	out( B353 B42 ) &lt;- in( B40 )  Freq: 0.525777
0398 +  li R31, #65536	# int, #@loadConI
039c +  far_bne  R29, R31, B353	#@far_cmpI_branch  P=0.000000 C=2964.000000

03a4    B42: #	out( B322 B43 ) &lt;- in( B41 )  Freq: 0.525777
03a4 +  lwu  R7, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.head
03a8 +  #@membar_acquire
	fence ir iorw
03ac +  decode_heap_oop  R8, R7	#@decodeHeapOop
03b0 +  far_bne   R8, zr, B322	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

03b8    B43: #	out( B508 B44 ) &lt;- in( B42 )  Freq: 0.525776
03b8 +  spill R30 -&gt; [sp, #32]	# spill size = 64
03bc +  spill R28 -&gt; [sp, #0]	# spill size = 64
03c0 +  mv  R11, NULL	# NULL ptr, #@loadConP0
03c4    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.util.concurrent.locks.AbstractQueuedSynchronizer::signalNext
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:12 (line 1095) L[0]=_ L[1]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #0 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=NarrowOop [48]=Oop off=968/0x3c8}

03c8    B44: #	out( B194 B45 ) &lt;- in( B43 )  Freq: 0.525766
        # Block is sole successor of call
03c8 +  spill [sp, #48] -&gt; R20	# spill size = 64
03cc +  beq   R20, zr, B194	#@cmpP_imm0_branch  P=0.025965 C=2927.000000

03d0    B45: #	out( B324 B46 ) &lt;- in( B44 )  Freq: 0.512114
03d0 +  lwu  R9, [R20, #12]	# range, #@loadRange
03d4 +  li R7, #1	# int, #@loadConI
03d8 +  addi  R30, R20, #16	# ptr, #@addP_reg_imm
03dc    spill [sp, #0] -&gt; R19	# spill size = 64
03e0 +  lwu  R28, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
03e4 +  far_bleu R9, R7, B324	#@far_cmpU_branch  P=0.000001 C=-1.000000

03ec    B46: #	out( B163 B47 ) &lt;- in( B45 )  Freq: 0.512114
03ec +  lb  R29, [R30]	# byte, #@loadB
03f0 +  decode_heap_oop  R10, R28	#@decodeHeapOop
03f4 +  li R28, #46	# int, #@loadConI
03f8 +  beq  R29, R28, B163	#@cmpI_branch  P=0.051880 C=2872.000000

03fc    B47: #	out( B418 B48 ) &lt;- in( B46 )  Freq: 0.485545
03fc    lwu  R7, [R10, #24]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream.dir
0400    NullCheck R10

0400    B48: #	out( B419 B49 ) &lt;- in( B47 )  Freq: 0.485545
0400 +  decode_heap_oop  R22, R7	#@decodeHeapOop
0404    lwu  R28, [R22, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
0408    NullCheck R22

0408    B49: #	out( B364 B50 ) &lt;- in( B48 )  Freq: 0.485544
0408 +  lwu  R7, [R22, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
040c +  decode_heap_oop  R28, R28	#@decodeHeapOop
0410 +  decode_heap_oop  R8, R7	#@decodeHeapOop
0414 +  far_bleu  R9, zr, B364	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000000 C=2692.000000

041c    B50: #	out( B375 B51 ) &lt;- in( B49 )  Freq: 0.485544
041c +  li R31, #47	# int, #@loadConI
0420 +  far_beq  R29, R31, B375	#@far_cmpI_branch  P=0.000000 C=2692.000000

0428    B51: #	out( B420 B52 ) &lt;- in( B50 )  Freq: 0.485544
0428    lwu  R18, [R28, #12]	# range, #@loadRange
042c    NullCheck R28

042c    B52: #	out( B365 B53 ) &lt;- in( B51 )  Freq: 0.485543
042c +  addw  R29, R9, R18	#@addI_reg_reg
0430 +  addiw  R21, R29, #1	#@addI_reg_imm
0434 +  li R7, #1048576	# int, #@loadConI
0438 +  far_bleu  R18, zr, B365	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000000 C=2692.000000

0440    B53: #	out( B376 B54 ) &lt;- in( B52 )  Freq: 0.485543
0440 +  li R29, #1	# int, #@loadConI
0444 +  far_beq  R18, R29, B376	#@far_cmpI_branch  P=0.000000 C=2692.000000

044c    B54: #	out( B331 B55 ) &lt;- in( B53 )  Freq: 0.485543
044c +  addw  R31, R9, zr	#@convI2L_reg_reg
0450 +  addw  R26, R18, zr	#@convI2L_reg_reg
0454 +  far_bgtu R21, R7, B331	#@far_cmpU_branch  P=0.000001 C=-1.000000

045c    B55: #	out( B56 ) &lt;- in( B54 )  Freq: 0.485542
045c +  add  R29, R26, R31	#@addL_reg_reg
0460 +  addi  R29, R29, #1	#@addL_reg_imm

0464    B56: #	out( B336 B57 ) &lt;- in( B55 B331 )  Freq: 0.485543
0464 +  addi  R8, R29, #23	#@addL_reg_imm
0468 +  far_bltu R21, R18, B336	#@far_cmpU_branch  P=0.000001 C=-1.000000

0470    B57: #	out( B270 B58 ) &lt;- in( B56 )  Freq: 0.485542
0470 +  andi  R29, R8, #-8	#@andL_reg_imm
0474    spill R29 -&gt; [sp, #104]	# spill size = 64
0478 +  far_bgtu R21, R7, B270	#@far_cmpU_branch  P=0.000001 C=-1.000000

0480    B58: #	out( B270 B59 ) &lt;- in( B57 )  Freq: 0.485542
0480 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0480    ld  R24, [R23, #288]	# ptr, #@loadP
0484 +  add R7, R24, R29	# ptr, #@addP_reg_reg
0488 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0488    ld  R29, [R23, #304]	# ptr, #@loadP
048c +  far_bgeu  R7, R29, B270	#@far_cmpP_branch  P=0.000100 C=-1.000000

0494    B59: #	out( B60 ) &lt;- in( B58 )  Freq: 0.485493
0494 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0494    sd  R7, [R23, #288]	# ptr, #@storeP
0498 +  li R7, #1	# long, #@loadConL
049c +  sd  R7, [R24]	# long, #@storeL
04a0 +  mv  R7, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
04b0 +  sw  R7, [R24, #8]	# compressed klass ptr, #@storeNKlass
04b4 +  sw  R21, [R24, #12]	# int, #@storeI

04b8    B60: #	out( B337 B61 ) &lt;- in( B271 B59 )  Freq: 0.485542
04b8    
04b8 +  srli  R7, R8, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
04bc +  # checkcastPP of R24, #@checkCastPP
04bc    addi  R11, R24, #16	# ptr, #@addP_reg_imm
04c0 +  far_bleu  R18, zr, B337	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

04c8    B61: #	out( B246 B62 ) &lt;- in( B60 )  Freq: 0.485542
04c8 +  addi  R10, R28, #16	# ptr, #@addP_reg_imm
04cc +  far_blt  R18, R21, B246	#@far_cmpI_branch  P=0.001000 C=-1.000000

04d4    B62: #	out( B63 ) &lt;- in( B61 )  Freq: 0.485056
04d4 +  spill R21 -&gt; R25	# spill size = 32
04d8 +  spill [sp, #104] -&gt; R7	# spill size = 64
04dc +  spill R24 -&gt; R8	# spill size = 64
04e0 +  spill R18 -&gt; R21	# spill size = 32
04e4 +  addi  R7, R7, #-16	#@addL_reg_imm
04e8    spill R31 -&gt; R24	# spill size = 64
04ec +  spill R30 -&gt; R18	# spill size = 64
04f0    
04f0    
04f0    
04f0    
04f0 +  srli  R12, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
04f4    CALL, runtime leaf nofp 0x000000401396d840	#@CallLeafNoFPDirect jlong_disjoint_arraycopy
        No JVM State Info
        # 
04f8 +  spill R18 -&gt; R30	# spill size = 64
04fc +  spill R21 -&gt; R18	# spill size = 32
0500 +  spill R24 -&gt; R31	# spill size = 64
0504 +  spill R25 -&gt; R21	# spill size = 32
0508 +  spill R8 -&gt; R24	# spill size = 64

050c    B63: #	out( B332 B64 ) &lt;- in( B246 B62 B337 )  Freq: 0.485542
050c +  MEMBAR-store-store	#@membar_storestore
0510 +  add R7, R24, R26	# ptr, #@addP_reg_reg
0514 +  addiw  R8, R18, #1	#@addI_reg_imm
0518 +  far_bgeu R18, R21, B332	#@far_cmpU_branch  P=0.000001 C=-1.000000

0520    B64: #	out( B338 B65 ) &lt;- in( B63 )  Freq: 0.485542
0520 +  li R28, #47	# int, #@loadConI
0524 +  sb  R28, [R7, #16]	# byte, #@storeB
0528 +  far_blt  R8, zr, B338	#@far_cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0530    B65: #	out( B67 B66 ) &lt;- in( B64 )  Freq: 0.485541
0530 +  bleu  R9, zr, B67	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

0534    B66: #	out( B67 ) &lt;- in( B65 )  Freq: 0.485541
0534 +  spill R31 -&gt; R12	# spill size = 64
0538 +  addi  R11, R7, #17	# ptr, #@addP_reg_imm
053c    spill R30 -&gt; R10	# spill size = 64
0540 +  CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

0544    B67: #	out( B272 B68 ) &lt;- in( B66 B65 )  Freq: 0.485541
0544    
0544 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0544    ld  R18, [R23, #288]	# ptr, #@loadP
0548 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0548    ld  R7, [R23, #304]	# ptr, #@loadP
054c +  addi  R28, R18, #32	# ptr, #@addP_reg_imm
0550 +  far_bgeu  R28, R7, B272	#@far_cmpP_branch  P=0.000100 C=-1.000000

0558    B68: #	out( B69 ) &lt;- in( B67 )  Freq: 0.485493
0558 +  li R7, #1	# long, #@loadConL
055c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
055c    sd  R28, [R23, #288]	# ptr, #@storeP
0560 +  sd  R7, [R18]	# long, #@storeL
0564 +  mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d8247c50:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0574 +  sw  R7, [R18, #8]	# compressed klass ptr, #@storeNKlass
0578 +  sw  zr, [R18, #12]	# int, #@storeimmI0
057c +  sw  zr, [R18, #16]	# int, #@storeimmI0
0580 +  sd  zr, [R18, #24]	# long, #@storeimmL0

0584    B69: #	out( B421 B70 ) &lt;- in( B273 B68 )  Freq: 0.485541
0584 +  encode_heap_oop  R28, R24	#@encodeHeapOop
0588 +  sw  R28, [R18, #20]	# compressed ptr, #@storeN
058c    
058c +  lwu  R7, [R22, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
0590 +  # checkcastPP of R18, #@checkCastPP
0590    sw  R7, [R18, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixPath.fs
0594 +  #@membar_release
	fence iorw ow
0598 +  lwu  R28, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
059c +  decode_heap_oop  R7, R28	#@decodeHeapOop
05a0    lwu  R7, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream.filter
05a4    NullCheck R7

05a4    B70: #	out( B435 B71 ) &lt;- in( B69 )  Freq: 0.485541
05a4 +  decode_heap_oop  R8, R7	#@decodeHeapOop
05a8    lwu  R28, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
05ac    NullCheck R8

05ac    B71: #	out( B339 B72 ) &lt;- in( B70 )  Freq: 0.48554
05ac +  mv  R7, narrowklass: precise klass java/nio/file/Files$AcceptAllFilter: 0x00000040d836c8b0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
05bc +  far_bne  R28, R7, B339	#@far_cmpN_branch  P=0.000001 C=-1.000000

05c4    B72: #	out( B73 ) &lt;- in( B71 )  Freq: 0.48554
05c4 +  # checkcastPP of R18, #@checkCastPP

05c4    B73: #	out( B231 B74 ) &lt;- in( B194 B72 )  Freq: 0.499192
05c4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
05c4    lb  R28, [R23, #56]	# byte, #@loadB
05c8 +  bne  R28, zr, B231	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

05cc    B74: #	out( B77 B75 ) &lt;- in( B361 B233 B231 B73 )  Freq: 0.499192
05cc +  mv  R7, R19	# ptr -&gt; long, #@castP2X
05d0 +  mv  R28, R18	# ptr -&gt; long, #@castP2X
05d4 +  xorr  R28, R28, R7	#@xorL_reg_reg
05d8 +  encode_heap_oop  R9, R18	#@encodeHeapOop
05dc +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
05e0 +  sw  R9, [R19, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
05e4 +  beq  R28, zr, B77	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

05e8    B75: #	out( B77 B76 ) &lt;- in( B74 )  Freq: 0.498692
05e8 +  beq   R18, zr, B77	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

05ec    B76: #	out( B241 B77 ) &lt;- in( B75 )  Freq: 0.498194
05ec +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
05f0 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
05fc +  add R10, R28, R7	# ptr, #@addP_reg_reg
0600 +  lb  R7, [R10]	# byte, #@loadB
0604 +  li R28, #4	# int, #@loadConI
0608 +  bne  R7, R28, B241	#@cmpI_branch  P=0.001000 C=-1.000000

060c    B77: #	out( B330 B78 ) &lt;- in( B245 B76 B75 B74 )  Freq: 0.499192
060c +  #@membar_release_lock (elided)
060c    add R29, sp, #144	# box lock
0610 +  fastunlock R19,R29	! kills R7, R28, #@cmpFastUnlock
0688 +  far_bne RFLAGS, zr, B330	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

0690    B78: #	out( B185 B79 ) &lt;- in( B330 B77 )  Freq: 0.499192
0690 +  beq   R9, zr, B185	#@cmpP_narrowOop_imm0_branch  P=0.028479 C=2774.000000

0694    B79: #	out( B340 B80 ) &lt;- in( B78 )  Freq: 0.484975
0694    add R29, sp, #144	# box lock
0698 +  fastlock R19,R29	! kills R7,R28, #@cmpFastLock
072c +  far_bne RFLAGS, zr, B340	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

0734    B80: #	out( B436 B81 ) &lt;- in( B340 B79 )  Freq: 0.484975
0734 +  #@membar_acquire_lock (elided)
0734 +  lwu  R7, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
0738 +  decode_heap_oop  R8, R7	#@decodeHeapOop
073c    lwu  R18, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0740    NullCheck R8

0740    B81: #	out( B247 B82 ) &lt;- in( B80 )  Freq: 0.484975
0740 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0740    lb  R28, [R23, #56]	# byte, #@loadB
0744 +  bne  R28, zr, B247	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0748    B82: #	out( B341 B83 ) &lt;- in( B366 B249 B247 B81 )  Freq: 0.484975
0748 +  sw  rheapbase, [R19, #16]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
074c +  #@membar_release_lock (elided)
074c    add R29, sp, #144	# box lock
0750 +  fastunlock R19,R29	! kills R28, R7, #@cmpFastUnlock
07c8 +  far_bne RFLAGS, zr, B341	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

07d0    B83: #	out( B400 B84 ) &lt;- in( B341 B82 )  Freq: 0.484975
07d0 +  mv  R14, precise klass sun/nio/fs/UnixPath: 0x00000040d8247c50:Constant:exact *	# ptr, #@loadConP
07e8 +  mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d8247c50:Constant:exact *	# compressed klass ptr, #@loadConNKlass
07f8 +  ld  R28, [R14, #40]	# class, #@loadKlass
07fc +  mv  R10, precise klass sun/nio/fs/BasicFileAttributesHolder: 0x00000040d01cabd0:Constant:exact *	# ptr, #@loadConP
0814 +  far_bne  R18, R7, B400	#@far_cmpN_branch  P=0.000000 C=-1.000000

081c    B84: #	out( B333 B85 ) &lt;- in( B83 )  Freq: 0.484975
081c +  spill R8 -&gt; R7	# spill size = 64
0820 +  # checkcastPP of R7, #@checkCastPP
0820    far_beq  R28, R10, B333	#@far_cmpP_branch  P=0.000001 C=-1.000000

0828    B85: #	out( B334 B86 ) &lt;- in( B84 )  Freq: 0.484974
0828 +  partialSubtypeCheck R15, R14, R10 == 0	#@partialSubtypeCheckVsZero
0884 +  lwu  R30, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
0888 +  spill [sp, #16] -&gt; R29	# spill size = 64
088c +  lwu  R28, [R29, #20]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker.linkOptions
0890 +  decode_heap_oop  R30, R30	#@decodeHeapOop
0894 +  far_beq RFLAGS, zr, B334	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

089c    B86: #	out( B422 B87 ) &lt;- in( B85 )  Freq: 0.484974
089c    lwu  R30, [R30, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileSystem.provider
08a0    NullCheck R30

08a0    B87: #	out( B335 B88 ) &lt;- in( B86 )  Freq: 0.484974
08a0 +  decode_heap_oop  R15, R28	#@decodeHeapOop
08a4 +  far_beq   R30, zr, B335	#@far_cmpP_narrowOop_imm0_branch  P=0.000001 C=-1.000000

08ac    B88: #	out( B423 B89 ) &lt;- in( B87 )  Freq: 0.484973
08ac    lwu  R28, [R15, #12]	# range, #@loadRange
08b0    NullCheck R15

08b0    B89: #	out( B97 B90 ) &lt;- in( B88 )  Freq: 0.484973
08b0 +  bleu  R28, zr, B97	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.500093 C=5383.000000

08b4    B90: #	out( B363 B91 ) &lt;- in( B89 )  Freq: 0.242441
08b4 +  addiw  R31, R28, #-1	#@addI_reg_imm
08b8 +  li R14, #1000	# int, #@loadConI
08bc +  far_bgeu R31, R28, B363	#@far_cmpU_branch  P=0.000001 C=-1.000000

08c4    B91: #	out( B92 ) &lt;- in( B90 )  Freq: 0.242441
08c4 +  mv  R13, narrowoop: java/nio/file/LinkOption:exact *	# compressed ptr, #@loadConN
08d4 +  li R12, #0	# int, #@loadConI
08d8 +  li R9, #0	# int, #@loadConI

08dc    B92: #	out( B93 ) &lt;- in( B91 B95 ) Loop( B92-B95 ) Freq: 0.484791
08dc +  subw  R30, R28, R12	#@subI_reg_reg
08e0    CMove R30, (R28 lt R12), R30, R9	#@cmovI_cmpI
	
08e8 +  CMove R30, (R30 gtu R14), R30, R14	#@cmovI_cmpU
	
08f0 +  addw  R31, R30, R12	#@addI_reg_reg

08f4    B93: #	out( B349 B94 ) &lt;- in( B92 B94 ) Loop( B93-B94 inner  strip mined) Freq: 0.969402
08f4 +  addw  R30, R12, zr	#@convI2L_reg_reg
08f8 +  slli  R30, R30, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
08fc +  add R30, R15, R30	# ptr, #@addP_reg_reg
0900 +  lwu  R30, [R30, #16]	# loadN, compressed ptr, #@loadN
0904 +  far_bne  R30, R13, B349	#@far_cmpN_branch  P=0.000000 C=2691.000000

090c    B94: #	out( B93 B95 ) &lt;- in( B93 )  Freq: 0.969402
090c +  addiw  R12, R12, #1	#@addI_reg_imm
0910 +  blt  R12, R31, B93	#@cmpI_loop  P=0.499907 C=2691.000000

0914    B95: #	out( B92 B96 ) &lt;- in( B94 )  Freq: 0.484791
0914 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0914    ld  R16, [R23, #920]	# ptr, #@loadP
0918 +  lwu zr, [R16]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.Util::followLinks @ bci:61 (line 121) L[0]=_ L[1]=#0 L[2]=R15 L[3]=R28 L[4]=R12 L[5]=_
        # sun.nio.fs.UnixFileSystemProvider::getFileAttributeView @ bci:7 (line 120) L[0]=_ L[1]=_ L[2]=#Ptr0x00000040d838e700 L[3]=_ L[4]=R7 L[5]=_
        # sun.nio.fs.LinuxFileSystemProvider::getFileAttributeView @ bci:48 (line 68) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:51 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=R29 L[1]=R7 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=R29 L[1]=R7 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=R29 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {t2=Oop x29=Oop c_rarg3=NarrowOop c_rarg5=Oop [8]=Oop [24]=Oop [32]=Oop off=2328/0x918}
091c +  blt  R12, R28, B92	#@cmpI_branch  P=0.499907 C=2691.000000

0920    B96: #	out( B98 ) &lt;- in( B95 )  Freq: 0.24244
0920 +  j  B98	#@branch

0924    B97: #	out( B98 ) &lt;- in( B89 )  Freq: 0.242531
0924 +  li R9, #1	# int, #@loadConI

0928    B98: #	out( B377 B99 ) &lt;- in( B96 B97 )  Freq: 0.484972
0928 +  mv  R28, java/lang/Class:exact *	# ptr, #@loadConP
0940 +  lw  R8, [R28, #156]	# int, #@loadI ! Field: java/lang/System.allowSecurityManager (constant)
0944 +  li R31, #1	# int, #@loadConI
0948 +  far_beq  R8, R31, B377	#@far_cmpI_branch  P=0.000000 C=5568.000000

0950    B99: #	out( B378 B100 ) &lt;- in( B98 )  Freq: 0.484972
0950 +  lwu  R30, [R28, #124]	# loadN, compressed ptr, #@loadN ! Field: volatile java/lang/System.security
0954 +  #@membar_acquire
	fence ir iorw
0958 +  decode_heap_oop  R8, R30	#@decodeHeapOop
095c +  far_bne   R8, zr, B378	#@far_cmpP_imm0_branch  P=0.000000 C=5385.000000

0964    B100: #	out( B274 B101 ) &lt;- in( B99 )  Freq: 0.484971
0964 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0964    ld  R10, [R23, #288]	# ptr, #@loadP
0968 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0968    ld  R28, [R23, #304]	# ptr, #@loadP
096c +  addi  R30, R10, #128	# ptr, #@addP_reg_imm
0970 +  bgeu  R30, R28, B274	#@cmpP_branch  P=0.000100 C=-1.000000

0974    B101: #	out( B102 ) &lt;- in( B100 )  Freq: 0.484923
0974 +  li R28, #1	# long, #@loadConL
0978 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0978    sd  R30, [R23, #288]	# ptr, #@storeP
097c +  sd  R28, [R10]	# long, #@storeL
0980 +  mv  R28, narrowklass: precise klass sun/nio/fs/UnixFileAttributes: 0x00000040d819d360:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0990 +  sw  R28, [R10, #8]	# compressed klass ptr, #@storeNKlass
0994 +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
0998 +  sw  zr, [R10, #12]	# int, #@storeimmI0
099c +  ClearArray #14, R28	#@clearArray_imm_reg

09d4    B102: #	out( B268 B103 ) &lt;- in( B275 B101 )  Freq: 0.484971
09d4    
09d4    MEMBAR-store-store	#@membar_storestore
09d8 +  spill R10 -&gt; R30	# spill size = 64
09dc +  encode_heap_oop  R11, R7	#@encodeHeapOop
09e0 +  # checkcastPP of R30, #@checkCastPP
09e0    bne  R9, zr, B268	#@cmpI_reg_imm0_branch  P=0.000371 C=2692.000000

09e4    B103: #	out( B427 B104 ) &lt;- in( B102 )  Freq: 0.484791
09e4 +  lwu  R31, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
09e8 +  mv  R28, java/lang/Class:exact *	# ptr, #@loadConP
0a00 +  lwu  R12, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
0a04    spill [sp, #32] -&gt; R17	# spill size = 64
0a08 +  lwu  R10, [R17, #68]	# loadN, compressed ptr, #@loadN ! Field: java/lang/Thread.threadLocals
0a0c +  lwu  R28, [R28, #116]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/NativeBuffers.threadLocal
0a10 +  decode_heap_oop  R31, R31	#@decodeHeapOop
0a14    lbu  R31, [R31, #12]	# byte, #@loadUB ! Field: sun/nio/fs/UnixFileSystem.needToResolveAgainstDefaultDirectory
0a18    NullCheck R31

0a18    B104: #	out( B380 B105 ) &lt;- in( B103 )  Freq: 0.484791
0a18 +  decode_heap_oop  R12, R12	#@decodeHeapOop
0a1c +  far_bne  R31, zr, B380	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2801.000000

0a24    B105: #	out( B428 B106 ) &lt;- in( B104 )  Freq: 0.48479
0a24    lwu  R14, [R12, #12]	# range, #@loadRange
0a28    NullCheck R12

0a28    B106: #	out( B381 B107 ) &lt;- in( B105 )  Freq: 0.48479
0a28 +  decode_heap_oop  R15, R10	#@decodeHeapOop
0a2c +  decode_heap_oop  R16, R28	#@decodeHeapOop
0a30 +  far_bleu  R14, zr, B381	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000000 C=10104.000000

0a38    B107: #	out( B429 B108 ) &lt;- in( B106 )  Freq: 0.48479
0a38    lw  R31, [R16, #12]	# int, #@loadI ! Field: java/lang/ThreadLocal.threadLocalHashCode (constant)
0a3c    NullCheck R16

0a3c    B108: #	out( B437 B109 ) &lt;- in( B107 )  Freq: 0.484789
0a3c +  addiw  R19, R14, #1	#@addI_reg_imm
0a40    lwu  R13, [R15, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap.table
0a44    NullCheck R15

0a44    B109: #	out( B430 B110 ) &lt;- in( B108 )  Freq: 0.484789
0a44 +  decode_heap_oop  R20, R13	#@decodeHeapOop
0a48    lwu  R18, [R20, #12]	# range, #@loadRange
0a4c    NullCheck R20

0a4c    B110: #	out( B343 B111 ) &lt;- in( B109 )  Freq: 0.484789
0a4c +  addiw  R10, R18, #-1	#@addI_reg_imm
0a50 +  andr  R13, R31, R10	#@andI_reg_reg
0a54 +  addw  R31, R13, zr	#@convI2L_reg_reg
0a58 +  slli  R31, R31, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0a5c +  add R31, R20, R31	# ptr, #@addP_reg_reg
0a60 +  far_bleu  R18, zr, B343	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

0a68    B111: #	out( B438 B112 ) &lt;- in( B110 )  Freq: 0.484788
0a68 +  lwu  R31, [R31, #16]	# loadN, compressed ptr, #@loadN
0a6c +  decode_heap_oop  R20, R31	#@decodeHeapOop
0a70    lwu  R10, [R20, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
0a74    NullCheck R20

0a74    B112: #	out( B344 B113 ) &lt;- in( B111 )  Freq: 0.484788
0a74    
0a74 +  lwu  R31, [R20, #28]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap$Entry.value
0a78 +  decode_heap_oop  R18, R31	#@decodeHeapOop
0a7c +  far_bne  R10, R28, B344	#@far_cmpN_branch  P=0.000001 C=-1.000000

0a84    B113: #	out( B431 B114 ) &lt;- in( B112 )  Freq: 0.484787
0a84    lwu  R31, [R18, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0a88    NullCheck R18

0a88    B114: #	out( B401 B115 ) &lt;- in( B113 )  Freq: 0.484787
0a88 +  mv  R28, narrowklass: precise klass [Lsun/nio/fs/NativeBuffer;: 0x00000040d0585d40:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0a98 +  far_bne  R31, R28, B401	#@far_cmpN_branch  P=0.000000 C=-1.000000

0aa0    B115: #	out( B345 B116 ) &lt;- in( B114 )  Freq: 0.484787
0aa0 +  # checkcastPP of R18, #@checkCastPP
0aa0    lwu  R31, [R18, #12]	# range, #@loadRange
0aa4 +  far_bleu  R31, zr, B345	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

0aac    B116: #	out( B439 B117 ) &lt;- in( B115 )  Freq: 0.484786
0aac +  lwu  R31, [R18, #16]	# loadN, compressed ptr, #@loadN
0ab0 +  decode_heap_oop  R21, R31	#@decodeHeapOop
0ab4    lw  R8, [R21, #12]	# int, #@loadI ! Field: sun/nio/fs/NativeBuffer.size
0ab8    NullCheck R21

0ab8    B117: #	out( B367 B118 ) &lt;- in( B116 )  Freq: 0.484786
0ab8 +  far_blt  R8, R19, B367	#@far_cmpI_branch  P=0.000000 C=2801.000000

0ac0    B118: #	out( B250 B119 ) &lt;- in( B117 )  Freq: 0.484786
0ac0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0ac0    lb  R28, [R23, #56]	# byte, #@loadB
0ac4 +  lwu  R19, [R21, #28]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/NativeBuffer.owner
0ac8 +  bne  R28, zr, B250	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0acc    B119: #	out( B224 B120 ) &lt;- in( B368 B252 B250 B118 )  Freq: 0.484786
0acc +  decode_heap_oop  R28, R19	#@decodeHeapOop
0ad0 +  sw  rheapbase, [R18, #16]	# compressed ptr (rheapbase==0), #@storeImmN0
0ad4 +  ld  R24, [R21, #16]	# int, #@loadL ! Field: sun/nio/fs/NativeBuffer.address
0ad8 +  beq  R28, R7, B224	#@cmpP_branch  P=0.027133 C=2801.000000

0adc    B120: #	out( B260 B121 ) &lt;- in( B119 )  Freq: 0.471632
0adc +  spill R7 -&gt; R18	# spill size = 64
0ae0 +  li R7, #1	# int, #@loadConI
0ae4    
0ae4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0ae4    sb  R7, [R23, #968]	# byte, #@storeB
0ae8    
0ae8    
0ae8 +  addi  R10, R12, #16	# ptr, #@addP_reg_imm
0aec    spill R9 -&gt; R19	# spill size = 32
0af0 +  addw  R25, R14, zr	#@convI2L_reg_reg
0af4    spill R11 -&gt; R22	# spill size = 32
0afc +  spill R31 -&gt; [sp, #0]	# spill size = 32
0b00 +  spill R30 -&gt; R20	# spill size = 64
0b04 +  spill R17 -&gt; R8	# spill size = 64
0b08 +  spill R29 -&gt; R9	# spill size = 64
0b0c +  spill R25 -&gt; R12	# spill size = 64
0b10 +  mv  R11, R24	# long -&gt; ptr, #@castX2P
0b14    CALL, runtime leaf nofp 0x000000401396e3c0	#@CallLeafNoFPDirect unsafe_arraycopy
        No JVM State Info
        # 
0b18 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0b18    sb zr, [R23, #968]	# byte, #@storeimmB0
0b1c    
0b1c +  ld  R24, [R21, #16]	# int, #@loadL ! Field: sun/nio/fs/NativeBuffer.address
0b20 +  mv  R7, R24	# long -&gt; ptr, #@castX2P
0b24 +  add R7, R7, R25	# ptr, #@addP_reg_reg
0b28 +  sb zr, [R7]	# byte, #@storeimmB0
0b2c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0b2c    lb  R7, [R23, #56]	# byte, #@loadB
0b30 +  bne  R7, zr, B260	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0b34    B121: #	out( B123 B122 ) &lt;- in( B374 B262 B260 B120 )  Freq: 0.471632
0b34 +  mv  R28, R21	# ptr -&gt; long, #@castP2X
0b38    spill R18 -&gt; R7	# spill size = 64
0b3c +  mv  R29, R7	# ptr -&gt; long, #@castP2X
0b40 +  xorr  R29, R29, R28	#@xorL_reg_reg
0b44 +  srli  R29, R29, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0b48 +  sw  R22, [R21, #28]	# compressed ptr, #@storeN ! Field: sun/nio/fs/NativeBuffer.owner
0b4c +  beq  R29, zr, B123	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0b50    B122: #	out( B263 B123 ) &lt;- in( B121 )  Freq: 0.47116
0b50 +  srli  R28, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0b54 +  mv  R29, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
0b60 +  add R10, R29, R28	# ptr, #@addP_reg_reg
0b64 +  lb  R29, [R10]	# byte, #@loadB
0b68 +  li R30, #4	# int, #@loadConI
0b6c +  bne  R29, R30, B263	#@cmpI_branch  P=0.001000 C=-1.000000

0b70    B123: #	out( B124 ) &lt;- in( B267 B122 B121 )  Freq: 0.471632
0b70 +  spill R9 -&gt; R29	# spill size = 64
0b74 +  spill R19 -&gt; R9	# spill size = 32
0b78 +  spill R20 -&gt; R30	# spill size = 64
0b7c +  spill R22 -&gt; [sp, #4]	# spill size = 32

0b80    B124: #	out( B462 B125 ) &lt;- in( B224 B123 )  Freq: 0.484786
0b80 +  spill R21 -&gt; [sp, #56]	# spill size = 64
0b84 +  spill R30 -&gt; [sp, #32]	# spill size = 64
0b88 +  spill R9 -&gt; [sp, #48]	# spill size = 32
0b8c +  spill R7 -&gt; [sp, #40]	# spill size = 64
0b90 +  spill R29 -&gt; [sp, #16]	# spill size = 64
0b94 +  spill R24 -&gt; R11	# spill size = 64
0b98 +  spill R30 -&gt; R12	# spill size = 64
0b9c    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect sun.nio.fs.UnixNativeDispatcher::lstat0
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:10 (line 308) L[0]=_ L[1]=_ L[2]=sp + #56 L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=NarrowOop [4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop off=2976/0xba0}

0ba0    B125: #	out( B432 B126 ) &lt;- in( B124 )  Freq: 0.484776
        # Block is sole successor of call
0ba0 +  mv  R7, java/lang/Class:exact *	# ptr, #@loadConP
0bb8 +  lwu  R31, [R7, #116]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/NativeBuffers.threadLocal
0bbc +  lwu  R7, [R8, #68]	# loadN, compressed ptr, #@loadN ! Field: java/lang/Thread.threadLocals
0bc0 +  decode_heap_oop  R28, R31	#@decodeHeapOop
0bc4 +  decode_heap_oop  R30, R7	#@decodeHeapOop
0bc8    lw  R10, [R28, #12]	# int, #@loadI ! Field: java/lang/ThreadLocal.threadLocalHashCode (constant)
0bcc    NullCheck R28

0bcc    B126: #	out( B440 B127 ) &lt;- in( B125 )  Freq: 0.484776
0bcc    lwu  R7, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap.table
0bd0    NullCheck R30

0bd0    B127: #	out( B433 B128 ) &lt;- in( B126 )  Freq: 0.484775
0bd0 +  decode_heap_oop  R12, R7	#@decodeHeapOop
0bd4    lwu  R7, [R12, #12]	# range, #@loadRange
0bd8    NullCheck R12

0bd8    B128: #	out( B346 B129 ) &lt;- in( B127 )  Freq: 0.484775
0bd8 +  addiw  R11, R7, #-1	#@addI_reg_imm
0bdc +  andr  R29, R10, R11	#@andI_reg_reg
0be0 +  addw  R10, R29, zr	#@convI2L_reg_reg
0be4 +  slli  R10, R10, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0be8 +  add R10, R12, R10	# ptr, #@addP_reg_reg
0bec +  far_bleu  R7, zr, B346	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

0bf4    B129: #	out( B441 B130 ) &lt;- in( B128 )  Freq: 0.484774
0bf4 +  lwu  R7, [R10, #16]	# loadN, compressed ptr, #@loadN
0bf8 +  decode_heap_oop  R7, R7	#@decodeHeapOop
0bfc    lwu  R11, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
0c00    NullCheck R7

0c00    B130: #	out( B347 B131 ) &lt;- in( B129 )  Freq: 0.484774
0c00    
0c00 +  lwu  R10, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap$Entry.value
0c04 +  decode_heap_oop  R10, R10	#@decodeHeapOop
0c08 +  far_bne  R11, R31, B347	#@far_cmpN_branch  P=0.000001 C=-1.000000

0c10    B131: #	out( B434 B132 ) &lt;- in( B130 )  Freq: 0.484774
0c10    lwu  R28, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0c14    NullCheck R10

0c14    B132: #	out( B402 B133 ) &lt;- in( B131 )  Freq: 0.484773
0c14 +  mv  R7, narrowklass: precise klass [Lsun/nio/fs/NativeBuffer;: 0x00000040d0585d40:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0c24 +  far_bne  R28, R7, B402	#@far_cmpN_branch  P=0.000000 C=-1.000000

0c2c    B133: #	out( B348 B134 ) &lt;- in( B132 )  Freq: 0.484773
0c2c +  # checkcastPP of R10, #@checkCastPP
0c2c    lwu  R28, [R10, #12]	# range, #@loadRange
0c30 +  addi  R9, R10, #16	# ptr, #@addP_reg_imm
0c34 +  far_bleu  R28, zr, B348	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

0c3c    B134: #	out( B369 B135 ) &lt;- in( B133 )  Freq: 0.484773
0c3c +  lwu  R7, [R9]	# loadN, compressed ptr, #@loadN
0c40 +  decode_heap_oop  R8, R7	#@decodeHeapOop
0c44 +  far_bne   R8, zr, B369	#@far_cmpP_imm0_branch  P=0.000000 C=2801.000000

0c4c    B135: #	out( B253 B136 ) &lt;- in( B134 )  Freq: 0.484773
0c4c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c4c    lb  R28, [R23, #56]	# byte, #@loadB
0c50 +  bne  R28, zr, B253	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0c54    B136: #	out( B138 B137 ) &lt;- in( B370 B255 B253 B135 )  Freq: 0.484773
0c54 +  mv  R7, R9	# ptr -&gt; long, #@castP2X
0c58    spill [sp, #56] -&gt; R28	# spill size = 64
0c5c +  mv  R28, R28	# ptr -&gt; long, #@castP2X
0c5c +  xorr  R28, R28, R7	#@xorL_reg_reg
0c60 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0c64    spill [sp, #0] -&gt; R29	# spill size = 32
0c68 +  sw  R29, [R9]	# compressed ptr, #@storeN
0c6c +  beq  R28, zr, B138	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0c70    B137: #	out( B256 B138 ) &lt;- in( B136 )  Freq: 0.484288
0c70 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0c74 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
0c80 +  add R10, R28, R7	# ptr, #@addP_reg_reg
0c84 +  lb  R7, [R10]	# byte, #@loadB
0c88 +  li R29, #4	# int, #@loadConI
0c8c +  bne  R7, R29, B256	#@cmpI_branch  P=0.001000 C=-1.000000

0c90    B138: #	out( B276 B139 ) &lt;- in( B258 B259 B256 B137 B136 B269 )  Freq: 0.484953
0c90 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c90    ld  R10, [R23, #288]	# ptr, #@loadP
0c94 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c94    ld  R7, [R23, #304]	# ptr, #@loadP
0c98 +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
0c9c +  bgeu  R28, R7, B276	#@cmpP_branch  P=0.000100 C=-1.000000

0ca0    B139: #	out( B140 ) &lt;- in( B138 )  Freq: 0.484904
0ca0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0ca0    sd  R28, [R23, #288]	# ptr, #@storeP
0ca4 +  li R7, #1	# long, #@loadConL
0ca8 +  mv  R28, narrowklass: precise klass sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes: 0x00000040d01c5930:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0cb8 +  sd  R7, [R10]	# long, #@storeL
0cbc +  sw  R28, [R10, #8]	# compressed klass ptr, #@storeNKlass
0cc0 +  sw  zr, [R10, #12]	# int, #@storeimmI0

0cc4    B140: #	out( B424 B141 ) &lt;- in( B277 B139 )  Freq: 0.484953
0cc4    spill [sp, #32] -&gt; R7	# spill size = 64
0cc8 +  encode_heap_oop  R7, R7	#@encodeHeapOop
0ccc    
0ccc +  # checkcastPP of R10, #@checkCastPP
0ccc    sw  R7, [R10, #12]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes.attrs
0cd0 +  #@membar_release
	fence iorw ow
0cd4 +  spill [sp, #16] -&gt; R31	# spill size = 64
0cd8 +  lwu  R28, [R31, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker.stack
0cdc +  spill R10 -&gt; R12	# spill size = 64
0ce0 +  # checkcastPP of R12, #@checkCastPP
0ce0    decode_heap_oop  R7, R28	#@decodeHeapOop
0ce4    lwu  R28, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/ArrayDeque.elements
0ce8    NullCheck R7

0ce8    B141: #	out( B425 B142 ) &lt;- in( B140 )  Freq: 0.484952
0ce8 +  lw  R30, [R7, #12]	# int, #@loadI ! Field: java/util/ArrayDeque.head
0cec +  lw  R7, [R7, #16]	# int, #@loadI ! Field: java/util/ArrayDeque.tail
0cf0 +  decode_heap_oop  R28, R28	#@decodeHeapOop
0cf4    lwu  R29, [R28, #12]	# range, #@loadRange
0cf8    NullCheck R28

0cf8    B142: #	out( B379 B143 ) &lt;- in( B141 )  Freq: 0.484952
0cf8 +  subw  R7, R7, R30	#@subI_reg_reg
0cfc +  sraiw R28, R28, 31	#@cmpLTMask_reg_reg
0d00 +  andr  R29, R28, R29	#@andI_reg_reg
0d04 +  addw  R8, R29, R7	#@addI_reg_reg
0d08 +  lw  R28, [R31, #12]	# int, #@loadI ! Field: java/nio/file/FileTreeWalker.maxDepth
0d0c +  lwu  R30, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0d10 +  mv  R7, narrowklass: precise klass sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes: 0x00000040d01c5930:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0d20 +  far_bge  R8, R28, B379	#@far_cmpI_branch  P=0.000000 C=2686.000000

0d28    B143: #	out( B342 B144 ) &lt;- in( B142 )  Freq: 0.484951
0d28 +  far_bne  R30, R7, B342	#@far_cmpN_branch  P=0.000001 C=-1.000000

0d30    B144: #	out( B426 B145 ) &lt;- in( B143 )  Freq: 0.484951
0d30 +  spill R12 -&gt; R30	# spill size = 64
0d34 +  # checkcastPP of R30, #@checkCastPP
0d34    lwu  R28, [R30, #12]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes.attrs
0d38 +  decode_heap_oop  R7, R28	#@decodeHeapOop
0d3c    lw  R7, [R7, #12]	# int, #@loadI ! Field: sun/nio/fs/UnixFileAttributes.st_mode
0d40    NullCheck R7

0d40    B145: #	out( B195 B146 ) &lt;- in( B144 )  Freq: 0.48495
0d40 +  li R29, #61440	# int, #@loadConI
0d44 +  andr  R7, R7, R29	#@andI_reg_reg
0d48 +  li R29, #16384	# int, #@loadConI
0d4c +  beq  R7, R29, B195	#@cmpI_branch  P=0.027923 C=2686.000000

0d50    B146: #	out( B278 B147 ) &lt;- in( B145 )  Freq: 0.471409
0d50 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0d50    ld  R10, [R23, #288]	# ptr, #@loadP
0d54 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0d54    ld  R7, [R23, #304]	# ptr, #@loadP
0d58 +  addi  R28, R10, #32	# ptr, #@addP_reg_imm
0d5c +  bgeu  R28, R7, B278	#@cmpP_branch  P=0.000100 C=-1.000000

0d60    B147: #	out( B148 ) &lt;- in( B146 )  Freq: 0.471362
0d60 +  li R7, #1	# long, #@loadConL
0d64 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0d64    sd  R28, [R23, #288]	# ptr, #@storeP
0d68 +  sd  R7, [R10]	# long, #@storeL
0d6c +  mv  R7, narrowklass: precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d8218cb0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0d7c +  sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
0d80 +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
0d84 +  sw  zr, [R10, #12]	# int, #@storeimmI0
0d88 +  ClearArray #2, R28	#@clearArray_imm_reg

0d90    B148: #	out( B531 B149 ) &lt;- in( B279 B147 )  Freq: 0.471409
0d90    
0d90    MEMBAR-store-store	#@membar_storestore
0d94 +  spill R10 -&gt; R8	# spill size = 64
0d98 +  # checkcastPP of R8, #@checkCastPP
0d98    mv  R12, java/nio/file/FileTreeWalker$EventType:exact *	# ptr, #@loadConP
0db0    spill R8 -&gt; R11	# spill size = 64
0db4 +  spill [sp, #40] -&gt; R13	# spill size = 64
0db8 +  spill R30 -&gt; R14	# spill size = 64
0dbc +  mv  R15, NULL	# NULL ptr, #@loadConP0
0dc0    spill R31 -&gt; [sp, #0]	# spill size = 64
0dc4    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeWalker$Event::&lt;init&gt;
        # java.nio.file.FileTreeWalker$Event::&lt;init&gt; @ bci:5 (line 141) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.nio.file.FileTreeWalker::visit @ bci:76 (line 289) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=R8
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #0 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop off=3528/0xdc8}

0dc8    B149: #	out( B150 ) &lt;- in( B148 )  Freq: 0.4714
        # Block is sole successor of call
0dc8 +  spill R8 -&gt; [sp, #0]	# spill size = 64

0dcc    B150: #	out( B151 ) &lt;- in( B223 B149 B193 )  Freq: 0.499155
0dcc +  mv  R8, narrowoop: java/nio/file/FileTreeWalker$EventType:exact *	# compressed ptr, #@loadConN

0ddc    B151: #	out( B533 B152 ) &lt;- in( B150 B184 ) Loop( B151-B184 inner ) Freq: 0.513841
0ddc    spill [sp, #0] -&gt; R11	# spill size = 64
0de0    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeWalker$Event::ioeException
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:20 (line 85) L[0]=sp + #8 L[1]=sp + #0 L[2]=_
        # OopMap {fp=NarrowOop [0]=Oop [8]=Oop off=3556/0xde4}

0de4    B152: #	out( B323 B153 ) &lt;- in( B151 )  Freq: 0.513831
        # Block is sole successor of call
0de4 +  spill [sp, #0] -&gt; R9	# spill size = 64
0de8 +  lwu  R7, [R9, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.type
0dec +  bne   R10, zr, B323	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

0df0    B153: #	out( B181 B154 ) &lt;- in( B152 )  Freq: 0.51383
0df0 +  beq  R7, R8, B181	#@cmpN_branch  P=0.028602 C=2762.000000

0df4    B154: #	out( B234 B155 ) &lt;- in( B153 )  Freq: 0.499133
0df4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0df4    lb  R28, [R23, #56]	# byte, #@loadB
0df8 +  bne  R28, zr, B234	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0dfc    B155: #	out( B156 ) &lt;- in( B154 )  Freq: 0.498634
0dfc +  spill [sp, #8] -&gt; R18	# spill size = 64

0e00    B156: #	out( B162 B157 ) &lt;- in( B362 B236 B234 B155 )  Freq: 0.499133
0e00 +  mv  R7, R18	# ptr -&gt; long, #@castP2X
0e04 +  mv  R28, R9	# ptr -&gt; long, #@castP2X
0e08 +  xorr  R28, R28, R7	#@xorL_reg_reg
0e0c +  encode_heap_oop  R29, R9	#@encodeHeapOop
0e10 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0e14 +  sw  R29, [R18, #16]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeIterator.next
0e18 +  beq  R28, zr, B162	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0e1c    B157: #	out( B162 B158 ) &lt;- in( B156 )  Freq: 0.498634
0e1c +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0e20 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
0e2c +  add R10, R28, R7	# ptr, #@addP_reg_reg
0e30 +  lb  R28, [R10]	# byte, #@loadB
0e34 +  li R29, #4	# int, #@loadConI
0e38 +  beq  R28, R29, B162	#@cmpI_branch  P=0.999000 C=-1.000000

0e3c    B158: #	out( B162 B159 ) &lt;- in( B157 )  Freq: 0.000498634
0e3c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e3c    ld  R7, [R23, #64]	# int, #@loadL
0e40 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e40    ld  R28, [R23, #80]	# ptr, #@loadP
0e44 +  #@membar_volatile
	fence iorw iorw
0e48 +  lb  R29, [R10]	# byte, #@loadB
0e4c +  beq  R29, zr, B162	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

0e50    B159: #	out( B161 B160 ) &lt;- in( B158 )  Freq: 0.000249317
0e50 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
0e54 +  bne  R7, zr, B161	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

0e58    B160: #	out( B162 ) &lt;- in( B159 )  Freq: 0.000124659
0e58 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e58    spill R23 -&gt; R11	# spill size = 64
0e5c +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
0e8c +  j  B162	#@branch

0e90    B161: #	out( B162 ) &lt;- in( B159 )  Freq: 0.000124659
0e90 +  add R28, R28, R7	# ptr, #@addP_reg_reg
0e94 +  addi  R7, R7, #-8	#@addL_reg_imm
0e98 +  sd  R10, [R28, #-8]	# ptr, #@storeP
0e9c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e9c    sd  R7, [R23, #64]	# long, #@storeL

0ea0    B162: #	out( N6588 ) &lt;- in( B160 B161 B158 B157 B156 B183 B6 B1 )  Freq: 0.999928
0ea0    # pop frame 176
	add  sp, sp, #176
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0f00 +  ret	// return register, #@Ret

0f04    B163: #	out( B167 B164 ) &lt;- in( B46 )  Freq: 0.0265686
0f04 +  li R28, #1	# int, #@loadConI
0f08 +  beq  R9, R28, B167	#@cmpI_branch  P=0.500000 C=150.000000

0f0c    B164: #	out( B397 B165 ) &lt;- in( B163 )  Freq: 0.0132843
0f0c +  li R7, #2	# int, #@loadConI
0f10 +  lb  R8, [R20, #17]	# byte, #@loadB
0f14 +  far_bne  R9, R7, B397	#@far_cmpI_branch  P=0.000000 C=75.000000

0f1c    B165: #	out( B167 B166 ) &lt;- in( B164 )  Freq: 0.0132843
0f1c +  li R7, #46	# int, #@loadConI
0f20 +  beq  R8, R7, B167	#@cmpI_branch  P=1.000000 C=75.000000

0f24    B166: #	out( N6588 ) &lt;- in( B165 )  Freq: 6.64214e-09
0f24 +  spill [sp, #8] -&gt; R7	# spill size = 64
0f28 +  li R11, #-187	# int, #@loadConI
0f2c    spill R7 -&gt; [sp, #0]	# spill size = 64
0f30 +  spill R19 -&gt; [sp, #32]	# spill size = 64
0f34 +  spill R19 -&gt; [sp, #40]	# spill size = 64
0f38 +  spill R20 -&gt; [sp, #64]	# spill size = 64
0f3c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::isSelfOrParent @ bci:25 (line 146) L[0]=_ L[1]=_ STK[0]=R8 STK[1]=#46
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:123 (line 181) L[0]=sp + #32 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [64]=Oop off=3904/0xf40}
0f40    #@ShouldNotReachHere

0f4c    B167: #	out( B444 B168 ) &lt;- in( B165 B163 )  Freq: 0.0265686
0f4c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0f4c    spill R19 -&gt; R7	# spill size = 64
0f50 +  ld  R11, [R23, #920]	# ptr, #@loadP
0f54    spill R7 -&gt; R28	# spill size = 64
0f58 +  lwu zr, [R11]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:182 (line 192) L[0]=R28 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=R28 STK[0]=R28 MON-BOX0=sp+144 MON-OBJ[0]=R28
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=R28 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {x28=Oop c_rarg0=Oop x19=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=NarrowOop off=3928/0xf58}
0f5c    lwu  R28, [R10, #32]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream.streamLock
0f60    NullCheck R10

0f60    B168: #	out( B445 B169 ) &lt;- in( B167 )  Freq: 0.0265685
0f60 +  decode_heap_oop  R7, R28	#@decodeHeapOop
0f64    lwu  R7, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock.readerLock
0f68    NullCheck R7

0f68    B169: #	out( B446 B170 ) &lt;- in( B168 )  Freq: 0.0265685
0f68 +  decode_heap_oop  R8, R7	#@decodeHeapOop
0f6c    # checkcastPP of R8, #@checkCastPP
0f6c    lwu  R28, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0f70    NullCheck R8

0f70    B170: #	out( B382 B171 ) &lt;- in( B169 )  Freq: 0.0265685
0f70 +  mv  R7, narrowklass: precise klass java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock: 0x00000040d836c7e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0f80 +  far_bne  R28, R7, B382	#@far_cmpN_branch  P=0.000001 C=-1.000000

0f88    B171: #	out( B447 B172 ) &lt;- in( B170 )  Freq: 0.0265685
0f88 +  # checkcastPP of R8, #@checkCastPP
0f88    lwu  R28, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock.sync
0f8c +  decode_heap_oop  R30, R28	#@decodeHeapOop
0f90    lw  R10, [R30, #16]	# int, #@loadI ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.state
0f94    NullCheck R30

0f94    B172: #	out( B390 B173 ) &lt;- in( B171 )  Freq: 0.0265684
0f94 +  #@membar_acquire
	fence ir iorw
0f98 +  zext.h  R8, R10	# s2ui, #@convS2UI_reg_reg_b
0f9c +  far_bne  R8, zr, B390	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2964.000000

0fa4    B173: #	out( B383 B174 ) &lt;- in( B172 )  Freq: 0.0265684
0fa4 +  lwu  R7, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.head
0fa8 +  #@membar_acquire
	fence ir iorw
0fac +  decode_heap_oop  R8, R7	#@decodeHeapOop
0fb0 +  srliw  R31, R10, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
0fb4 +  far_bne   R8, zr, B383	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0fbc    B174: #	out( B391 B175 ) &lt;- in( B173 )  Freq: 0.0265684
0fbc +  li R28, #65535	# int, #@loadConI
0fc4 +  far_bge  R31, R28, B391	#@far_cmpI_branch  P=0.000000 C=2964.000000

0fcc    B175: #	out( B392 B176 ) &lt;- in( B174 )  Freq: 0.0265684
0fcc +  #@membar_release
	fence iorw ow
0fd0 +  li R28, #65536	# int, #@loadConI
0fd4 +  addw  R29, R10, R28	#@addI_reg_reg
0fd8 +  addi  R7, R30, #16	# ptr, #@addP_reg_imm
0fdc    
0fdc +  cmpxchg_acq [R7], R10, R29	# (int) if [R7] == R10 then [R7] &lt;-- R29
	mv R8, R8 == R10	# R8 &lt;-- (R8 == R10 ? 1 : 0), #@compareAndSwapIAcq
0ff8    
0ff8 +  #@membar_acquire
	fence ir iorw
0ffc +  far_beq  R8, zr, B392	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2964.000000

1004    B176: #	out( B388 B177 ) &lt;- in( B175 )  Freq: 0.0265684
1004 +  far_bne  R31, zr, B388	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2964.000000

100c    B177: #	out( B280 B178 ) &lt;- in( B176 )  Freq: 0.0265684
100c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
100c    lb  R7, [R23, #56]	# byte, #@loadB
1010 +  bne  R7, zr, B280	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1014    B178: #	out( B180 B179 ) &lt;- in( B389 B282 B280 B177 )  Freq: 0.0265684
1014 +  mv  R7, R30	# ptr -&gt; long, #@castP2X
1018    spill [sp, #32] -&gt; R20	# spill size = 64
101c +  mv  R28, R20	# ptr -&gt; long, #@castP2X
1020 +  xorr  R28, R28, R7	#@xorL_reg_reg
1024 +  srli  R29, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
1028    spill [sp, #40] -&gt; R28	# spill size = 32
102c +  sw  R28, [R30, #40]	# compressed ptr, #@storeN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
1030 +  beq  R29, zr, B180	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1034    B179: #	out( B283 B180 ) &lt;- in( B178 )  Freq: 0.0265418
1034 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1038 +  mv  R29, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1044 +  add R10, R29, R7	# ptr, #@addP_reg_reg
1048 +  lb  R7, [R10]	# byte, #@loadB
104c +  li R31, #4	# int, #@loadConI
1050 +  bne  R7, R31, B283	#@cmpI_branch  P=0.001000 C=-1.000000

1054    B180: #	out( B28 ) &lt;- in( B285 B286 B283 B179 B178 )  Freq: 0.0265684
1054 +  li R7, #1	# int, #@loadConI
1058 +  sw  R7, [R30, #28]	# int, #@storeI ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReaderHoldCount
105c    spill [sp, #8] -&gt; R9	# spill size = 64
1060 +  spill [sp, #16] -&gt; R18	# spill size = 64
1064 +  spill [sp, #24] -&gt; R24	# spill size = 64
1068 +  j  B28	#@branch

106c    B181: #	out( B384 B182 ) &lt;- in( B153 )  Freq: 0.0146968
106c +  spill [sp, #8] -&gt; R28	# spill size = 64
1070 +  lwu  R7, [R28, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.walker
1074 +  decode_heap_oop  R11, R7	#@decodeHeapOop
1078 +  far_beq   R11, zr, B384	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

1080    B182: #	out( B530 B183 ) &lt;- in( B181 )  Freq: 0.0146968
1080    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeWalker::next
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:57 (line 94) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=NarrowOop [8]=Oop off=4228/0x1084}

1084    B183: #	out( B162 B184 ) &lt;- in( B182 )  Freq: 0.0146965
        # Block is sole successor of call
1084 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1084    ld  R7, [R23, #920]	# ptr, #@loadP
1088 +  lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:61 (line 95) L[0]=sp + #8 L[1]=R10 L[2]=_
        # OopMap {c_rarg0=Oop fp=NarrowOop [8]=Oop off=4232/0x1088}
108c +  beq   R10, zr, B162	#@cmpP_imm0_branch  P=0.001085 C=79.000000

1090    B184: #	out( B151 ) &lt;- in( B183 )  Freq: 0.0146806
1090 +  spill R10 -&gt; [sp, #0]	# spill size = 64
1094 +  j  B151	#@branch

1098    B185: #	out( B448 B186 ) &lt;- in( B78 )  Freq: 0.0142163
1098 +  spill [sp, #24] -&gt; R29	# spill size = 64
109c +  lwu  R7, [R29, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.stream
10a0 +  decode_heap_oop  R30, R7	#@decodeHeapOop
10a4    lwu  R28, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
10a8    NullCheck R30

10a8    B186: #	out( B386 B187 ) &lt;- in( B185 )  Freq: 0.0142163
10a8 +  mv  R7, narrowklass: precise klass sun/nio/fs/UnixSecureDirectoryStream: 0x00000040d8247d20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
10b8 +  far_bne  R28, R7, B386	#@far_cmpN_branch  P=0.000001 C=-1.000000

10c0    B187: #	out( B442 B188 ) &lt;- in( B186 )  Freq: 0.0142163
10c0 +  # checkcastPP of R30, #@checkCastPP
10c0    spill R29 -&gt; [sp, #0]	# spill size = 64
10c4 +  spill R30 -&gt; R11	# spill size = 64
10c8    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixSecureDirectoryStream::close
        # java.nio.file.FileTreeWalker::next @ bci:76 (line 361) L[0]=sp + #16 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=4300/0x10cc}

10cc    B188: #	out( B385 B189 ) &lt;- in( B187 )  Freq: 0.014216
        # Block is sole successor of call
10cc +  spill [sp, #16] -&gt; R7	# spill size = 64
10d0 +  lwu  R28, [R7, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker.stack
10d4 +  decode_heap_oop  R11, R28	#@decodeHeapOop
10d8 +  far_beq   R11, zr, B385	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

10e0    B189: #	out( B529 B190 ) &lt;- in( B188 )  Freq: 0.014216
10e0    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.ArrayDeque::removeFirst
        # java.util.ArrayDeque::pop @ bci:1 (line 593) L[0]=_
        # java.nio.file.FileTreeWalker::next @ bci:109 (line 369) L[0]=_ L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop off=4324/0x10e4}

10e4    B190: #	out( B315 B191 ) &lt;- in( B189 )  Freq: 0.0142157
        # Block is sole successor of call
10e4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
10e4    ld  R10, [R23, #288]	# ptr, #@loadP
10e8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
10e8    ld  R7, [R23, #304]	# ptr, #@loadP
10ec +  addi  R28, R10, #32	# ptr, #@addP_reg_imm
10f0 +  bgeu  R28, R7, B315	#@cmpP_branch  P=0.000100 C=-1.000000

10f4    B191: #	out( B192 ) &lt;- in( B190 )  Freq: 0.0142143
10f4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
10f4    sd  R28, [R23, #288]	# ptr, #@storeP
10f8 +  li R7, #1	# long, #@loadConL
10fc +  mv  R28, narrowklass: precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d8218cb0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
110c +  sd  R7, [R10]	# long, #@storeL
1110 +  sw  R28, [R10, #8]	# compressed klass ptr, #@storeNKlass
1114 +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
1118 +  sw  zr, [R10, #12]	# int, #@storeimmI0
111c +  ClearArray #2, R28	#@clearArray_imm_reg

1124    B192: #	out( B528 B193 ) &lt;- in( B316 B191 )  Freq: 0.0142157
1124    
1124    MEMBAR-store-store	#@membar_storestore
1128 +  spill [sp, #0] -&gt; R7	# spill size = 64
112c +  lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.dir
1130 +  spill R10 -&gt; R8	# spill size = 64
1134 +  decode_heap_oop  R13, R28	#@decodeHeapOop
1138 +  # checkcastPP of R8, #@checkCastPP
1138    mv  R12, java/nio/file/FileTreeWalker$EventType:exact *	# ptr, #@loadConP
1150    spill R8 -&gt; R11	# spill size = 64
1154 +  mv  R14, NULL	# NULL ptr, #@loadConP0
1158    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeWalker$Event::&lt;init&gt;
        # java.nio.file.FileTreeWalker::next @ bci:126 (line 370) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=R8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop off=4444/0x115c}

115c    B193: #	out( B150 ) &lt;- in( B192 )  Freq: 0.0142155
        # Block is sole successor of call
115c +  spill R8 -&gt; [sp, #0]	# spill size = 64
1160 +  j  B150	#@branch

1164    B194: #	out( B73 ) &lt;- in( B44 )  Freq: 0.0136516
1164 +  li R28, #1	# int, #@loadConI
1168    spill [sp, #0] -&gt; R19	# spill size = 64
116c +  sb  R28, [R19, #12]	# byte, #@storeB ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.atEof
1170 +  mv  R18, NULL	# NULL ptr, #@loadConP0
1174 +  j  B73	#@branch

1178    B195: #	out( B398 B196 ) &lt;- in( B145 )  Freq: 0.0135411
1178 +  lbu  R8, [R31, #16]	# byte, #@loadUB ! Field: java/nio/file/FileTreeWalker.followLinks
117c +  far_bne  R8, zr, B398	#@far_cmpI_reg_imm0_branch  P=0.000000 C=75.000000

1184    B196: #	out( B443 B197 ) &lt;- in( B195 )  Freq: 0.0135411
1184 +  spill R30 -&gt; [sp, #32]	# spill size = 64
1188 +  spill [sp, #40] -&gt; R11	# spill size = 64
118c    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.nio.file.Files::newDirectoryStream
        # java.nio.file.FileTreeWalker::visit @ bci:131 (line 301) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=4496/0x1190}

1190    B197: #	out( B317 B198 ) &lt;- in( B196 )  Freq: 0.0135408
        # Block is sole successor of call
1190 +  spill R10 -&gt; R8	# spill size = 64
1194 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1194    ld  R10, [R23, #288]	# ptr, #@loadP
1198    spill [sp, #16] -&gt; R30	# spill size = 64
119c +  lwu  R28, [R30, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker.stack
11a0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
11a0    ld  R29, [R23, #304]	# ptr, #@loadP
11a4 +  addi  R7, R10, #32	# ptr, #@addP_reg_imm
11a8 +  decode_heap_oop  R31, R28	#@decodeHeapOop
11ac +  bgeu  R7, R29, B317	#@cmpP_branch  P=0.000100 C=-1.000000

11b0    B198: #	out( B199 ) &lt;- in( B197 )  Freq: 0.0135394
11b0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
11b0    sd  R7, [R23, #288]	# ptr, #@storeP
11b4 +  li R7, #1	# long, #@loadConL
11b8 +  sd  R7, [R10]	# long, #@storeL
11bc +  mv  R7, narrowklass: precise klass java/nio/file/FileTreeWalker$DirectoryNode: 0x00000040d83de8c0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
11cc +  sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
11d0 +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
11d4 +  sw  zr, [R10, #12]	# int, #@storeimmI0
11d8    ClearArray #2, R28	#@clearArray_imm_reg
11e0    spill R31 -&gt; [sp, #48]	# spill size = 64

11e4    B199: #	out( B527 B200 ) &lt;- in( B318 B198 )  Freq: 0.0135408
11e4    
11e4 +  spill R10 -&gt; R7	# spill size = 64
11e8 +  # checkcastPP of R7, #@checkCastPP
11e8    spill R7 -&gt; [sp, #56]	# spill size = 64
11ec +  spill [sp, #32] -&gt; R11	# spill size = 64
11f0    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes::fileKey
        # java.nio.file.FileTreeWalker::visit @ bci:177 (line 311) L[0]=_ L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=R8 L[7]=_ STK[0]=sp + #48 STK[1]=sp + #56 STK[2]=sp + #56 STK[3]=sp + #40
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=4596/0x11f4}

11f4    B200: #	out( B287 B201 ) &lt;- in( B199 )  Freq: 0.0135405
        # Block is sole successor of call
11f4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
11f4    lb  R7, [R23, #56]	# byte, #@loadB
11f8    spill R10 -&gt; R9	# spill size = 64
11fc +  bne  R7, zr, B287	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1200    B201: #	out( B202 ) &lt;- in( B200 )  Freq: 0.013527
1200 +  spill [sp, #56] -&gt; R20	# spill size = 64

1204    B202: #	out( B204 B203 ) &lt;- in( B393 B289 B287 B201 )  Freq: 0.0135405
1204 +  mv  R7, R20	# ptr -&gt; long, #@castP2X
1208    spill [sp, #40] -&gt; R18	# spill size = 64
120c +  mv  R28, R18	# ptr -&gt; long, #@castP2X
1210 +  xorr  R28, R28, R7	#@xorL_reg_reg
1214 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
1218    spill R8 -&gt; R21	# spill size = 64
121c +  encode_heap_oop  R19, R21	#@encodeHeapOop
1220    spill R9 -&gt; R22	# spill size = 64
1224 +  encode_heap_oop  R9, R9	#@encodeHeapOop
1228    spill [sp, #4] -&gt; R30	# spill size = 32
122c +  sw  R30, [R20, #16]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.dir
1230 +  beq  R28, zr, B204	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1234    B203: #	out( B299 B204 ) &lt;- in( B202 )  Freq: 0.013527
1234 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1238 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1244 +  add R10, R28, R7	# ptr, #@addP_reg_reg
1248 +  lb  R28, [R10]	# byte, #@loadB
124c +  li R7, #4	# int, #@loadConI
1250 +  bne  R28, R7, B299	#@cmpI_branch  P=0.001000 C=-1.000000

1254    B204: #	out( B290 B205 ) &lt;- in( B301 B302 B299 B203 B202 )  Freq: 0.0135405
1254 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1254    lb  R7, [R23, #56]	# byte, #@loadB
1258 +  bne  R7, zr, B290	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

125c    B205: #	out( B208 B206 ) &lt;- in( B394 B292 B290 B204 )  Freq: 0.0135405
125c +  mv  R7, R20	# ptr -&gt; long, #@castP2X
1260 +  mv  R28, R22	# ptr -&gt; long, #@castP2X
1264 +  xorr  R28, R28, R7	#@xorL_reg_reg
1268 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
126c +  sw  R9, [R20, #20]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.key
1270 +  beq  R28, zr, B208	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1274    B206: #	out( B208 B207 ) &lt;- in( B205 )  Freq: 0.013527
1274 +  beq   R22, zr, B208	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

1278    B207: #	out( B303 B208 ) &lt;- in( B206 )  Freq: 0.0135134
1278 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
127c +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1288 +  add R10, R28, R7	# ptr, #@addP_reg_reg
128c +  lb  R28, [R10]	# byte, #@loadB
1290 +  li R29, #4	# int, #@loadConI
1294 +  bne  R28, R29, B303	#@cmpI_branch  P=0.001000 C=-1.000000

1298    B208: #	out( B293 B209 ) &lt;- in( B305 B306 B303 B207 B206 B205 )  Freq: 0.0135405
1298 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1298    lb  R7, [R23, #56]	# byte, #@loadB
129c +  bne  R7, zr, B293	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

12a0    B209: #	out( B212 B210 ) &lt;- in( B395 B295 B293 B208 )  Freq: 0.0135405
12a0 +  mv  R7, R20	# ptr -&gt; long, #@castP2X
12a4 +  mv  R28, R21	# ptr -&gt; long, #@castP2X
12a8 +  xorr  R28, R28, R7	#@xorL_reg_reg
12ac +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
12b0 +  sw  R19, [R20, #24]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.stream
12b4 +  beq  R28, zr, B212	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

12b8    B210: #	out( B212 B211 ) &lt;- in( B209 )  Freq: 0.013527
12b8 +  beq   R21, zr, B212	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

12bc    B211: #	out( B307 B212 ) &lt;- in( B210 )  Freq: 0.0135134
12bc +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
12c0 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
12cc +  add R10, R28, R7	# ptr, #@addP_reg_reg
12d0 +  lb  R28, [R10]	# byte, #@loadB
12d4 +  li R7, #4	# int, #@loadConI
12d8 +  bne  R28, R7, B307	#@cmpI_branch  P=0.001000 C=-1.000000

12dc    B212: #	out( B526 B213 ) &lt;- in( B309 B310 B307 B211 B210 B209 )  Freq: 0.0135405
12dc +  spill R20 -&gt; R8	# spill size = 64
12e0 +  spill R21 -&gt; R11	# spill size = 64
12e4    CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.nio.file.DirectoryStream::iterator
        # java.nio.file.FileTreeWalker$DirectoryNode::&lt;init&gt; @ bci:21 (line 78) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=R8
        # java.nio.file.FileTreeWalker::visit @ bci:184 (line 311) L[0]=_ L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #48 STK[1]=R8
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop off=4864/0x1300}

1300    B213: #	out( B296 B214 ) &lt;- in( B212 )  Freq: 0.0135402
        # Block is sole successor of call
1300 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1300    lb  R28, [R23, #56]	# byte, #@loadB
1304    spill R10 -&gt; R9	# spill size = 64
1308 +  bne  R28, zr, B296	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

130c    B214: #	out( B215 ) &lt;- in( B213 )  Freq: 0.0135267
130c +  spill R8 -&gt; R18	# spill size = 64

1310    B215: #	out( B218 B216 ) &lt;- in( B396 B298 B296 B214 )  Freq: 0.0135402
1310 +  mv  R7, R18	# ptr -&gt; long, #@castP2X
1314    spill R9 -&gt; R30	# spill size = 64
1318 +  mv  R28, R30	# ptr -&gt; long, #@castP2X
131c +  xorr  R28, R28, R7	#@xorL_reg_reg
1320 +  encode_heap_oop  R29, R30	#@encodeHeapOop
1324 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
1328 +  sw  R29, [R18, #28]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.iterator
132c +  beq  R28, zr, B218	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1330    B216: #	out( B218 B217 ) &lt;- in( B215 )  Freq: 0.0135267
1330 +  beq   R30, zr, B218	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

1334    B217: #	out( B311 B218 ) &lt;- in( B216 )  Freq: 0.0135132
1334 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1338 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1344 +  add R10, R28, R7	# ptr, #@addP_reg_reg
1348 +  lb  R28, [R10]	# byte, #@loadB
134c +  li R29, #4	# int, #@loadConI
1350 +  bne  R28, R29, B311	#@cmpI_branch  P=0.001000 C=-1.000000

1354    B218: #	out( B387 B219 ) &lt;- in( B313 B314 B311 B217 B216 B215 )  Freq: 0.0135402
1354 +  #@membar_release
	fence iorw ow
1358 +  spill [sp, #48] -&gt; R7	# spill size = 64
135c +  far_beq   R7, zr, B387	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

1364    B219: #	out( B525 B220 ) &lt;- in( B218 )  Freq: 0.0135402
1364 +  spill [sp, #48] -&gt; R11	# spill size = 64
1368 +  spill R18 -&gt; R12	# spill size = 64
136c    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.ArrayDeque::addFirst
        # java.util.ArrayDeque::push @ bci:2 (line 579) L[0]=_ L[1]=_
        # java.nio.file.FileTreeWalker::visit @ bci:187 (line 311) L[0]=_ L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=4976/0x1370}

1370    B220: #	out( B319 B221 ) &lt;- in( B219 )  Freq: 0.01354
        # Block is sole successor of call
1370 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1370    ld  R10, [R23, #288]	# ptr, #@loadP
1374 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1374    ld  R7, [R23, #304]	# ptr, #@loadP
1378 +  addi  R28, R10, #32	# ptr, #@addP_reg_imm
137c +  bgeu  R28, R7, B319	#@cmpP_branch  P=0.000100 C=-1.000000

1380    B221: #	out( B222 ) &lt;- in( B220 )  Freq: 0.0135386
1380 +  li R7, #1	# long, #@loadConL
1384 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1384    sd  R28, [R23, #288]	# ptr, #@storeP
1388 +  sd  R7, [R10]	# long, #@storeL
138c +  mv  R7, narrowklass: precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d8218cb0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
139c +  sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
13a0 +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
13a4 +  sw  zr, [R10, #12]	# int, #@storeimmI0
13a8 +  ClearArray #2, R28	#@clearArray_imm_reg

13b0    B222: #	out( B524 B223 ) &lt;- in( B320 B221 )  Freq: 0.01354
13b0    
13b0    MEMBAR-store-store	#@membar_storestore
13b4 +  spill R10 -&gt; R8	# spill size = 64
13b8 +  # checkcastPP of R8, #@checkCastPP
13b8    mv  R12, java/nio/file/FileTreeWalker$EventType:exact *	# ptr, #@loadConP
13d0    spill R8 -&gt; R11	# spill size = 64
13d4 +  spill [sp, #40] -&gt; R13	# spill size = 64
13d8 +  spill [sp, #32] -&gt; R14	# spill size = 64
13dc +  mv  R15, NULL	# NULL ptr, #@loadConP0
13e0    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeWalker$Event::&lt;init&gt;
        # java.nio.file.FileTreeWalker$Event::&lt;init&gt; @ bci:5 (line 141) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.nio.file.FileTreeWalker::visit @ bci:200 (line 312) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=R8
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop off=5092/0x13e4}

13e4    B223: #	out( B150 ) &lt;- in( B222 )  Freq: 0.0135397
        # Block is sole successor of call
13e4 +  spill R8 -&gt; [sp, #0]	# spill size = 64
13e8 +  j  B150	#@branch

13ec    B224: #	out( B124 ) &lt;- in( B119 )  Freq: 0.0131538
13ec +  spill R17 -&gt; R8	# spill size = 64
13f0 +  spill R11 -&gt; [sp, #4]	# spill size = 32
13f4 +  spill R31 -&gt; [sp, #0]	# spill size = 32
13f8 +  j  B124	#@branch

13fc    B225: #	out( B40 B226 ) &lt;- in( B39 )  Freq: 0.000525771
13fc +  lwu  R29, [R12, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
1400 +  decode_heap_oop  R10, R29	#@decodeHeapOop
1404 +  far_beq   R10, zr, B40	#@far_cmpP_imm0_branch  P=0.500000 C=-1.000000

140c    B226: #	out( B354 B227 ) &lt;- in( B225 )  Freq: 0.000262885
140c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
140c    ld  R7, [R23, #32]	# int, #@loadL
1410 +  beq  R7, zr, B354	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1414    B227: #	out( B40 ) &lt;- in( B226 )  Freq: 0.000262622
1414 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1414    ld  R29, [R23, #48]	# ptr, #@loadP
1418 +  add R29, R29, R7	# ptr, #@addP_reg_reg
141c +  addi  R7, R7, #-8	#@addL_reg_imm
1420 +  sd  R10, [R29, #-8]	# ptr, #@storeP
1424 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1424    sd  R7, [R23, #32]	# long, #@storeL
1428 +  j  B40	#@branch

142c    B228: #	out( B25 B229 ) &lt;- in( B24 )  Freq: 0.000499207
142c +  lwu  R28, [R21, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
1430 +  decode_heap_oop  R10, R28	#@decodeHeapOop
1434 +  far_beq   R10, zr, B25	#@far_cmpP_imm0_branch  P=0.500000 C=-1.000000

143c    B229: #	out( B360 B230 ) &lt;- in( B228 )  Freq: 0.000249604
143c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
143c    ld  R7, [R23, #32]	# int, #@loadL
1440 +  beq  R7, zr, B360	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1444    B230: #	out( B25 ) &lt;- in( B229 )  Freq: 0.000249354
1444 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1444    ld  R28, [R23, #48]	# ptr, #@loadP
1448 +  add R28, R28, R7	# ptr, #@addP_reg_reg
144c +  addi  R7, R7, #-8	#@addL_reg_imm
1450 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1454 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1454    sd  R7, [R23, #32]	# long, #@storeL
1458 +  j  B25	#@branch

145c    B231: #	out( B74 B232 ) &lt;- in( B73 )  Freq: 0.000499185
145c +  lwu  R7, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
1460 +  decode_heap_oop  R10, R7	#@decodeHeapOop
1464 +  beq   R10, zr, B74	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1468    B232: #	out( B361 B233 ) &lt;- in( B231 )  Freq: 0.000249593
1468 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1468    ld  R7, [R23, #32]	# int, #@loadL
146c +  beq  R7, zr, B361	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1470    B233: #	out( B74 ) &lt;- in( B232 )  Freq: 0.000249343
1470 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1470    ld  R28, [R23, #48]	# ptr, #@loadP
1474 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1478 +  addi  R7, R7, #-8	#@addL_reg_imm
147c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1480 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1480    sd  R7, [R23, #32]	# long, #@storeL
1484 +  j  B74	#@branch

1488    B234: #	out( B156 B235 ) &lt;- in( B154 )  Freq: 0.000499127
1488 +  spill [sp, #8] -&gt; R18	# spill size = 64
148c +  lwu  R7, [R18, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.next
1490 +  decode_heap_oop  R10, R7	#@decodeHeapOop
1494 +  beq   R10, zr, B156	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1498    B235: #	out( B362 B236 ) &lt;- in( B234 )  Freq: 0.000249563
1498 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1498    ld  R7, [R23, #32]	# int, #@loadL
149c +  beq  R7, zr, B362	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

14a0    B236: #	out( B156 ) &lt;- in( B235 )  Freq: 0.000249314
14a0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
14a0    ld  R28, [R23, #48]	# ptr, #@loadP
14a4 +  add R28, R28, R7	# ptr, #@addP_reg_reg
14a8 +  addi  R7, R7, #-8	#@addL_reg_imm
14ac +  sd  R10, [R28, #-8]	# ptr, #@storeP
14b0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
14b0    sd  R7, [R23, #32]	# long, #@storeL
14b4 +  j  B156	#@branch

14b8    B237: #	out( B27 B238 ) &lt;- in( B26 )  Freq: 0.000498714
14b8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
14b8    ld  R7, [R23, #64]	# int, #@loadL
14bc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
14bc    ld  R29, [R23, #80]	# ptr, #@loadP
14c0 +  #@membar_volatile
	fence iorw iorw
14c4 +  lb  R30, [R10]	# byte, #@loadB
14c8 +  far_beq  R30, zr, B27	#@far_cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

14d0    B238: #	out( B240 B239 ) &lt;- in( B237 )  Freq: 0.000249357
14d0 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
14d4 +  bne  R7, zr, B240	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

14d8    B239: #	out( B27 ) &lt;- in( B238 )  Freq: 0.000124679
14d8 +  spill R28 -&gt; R26	# spill size = 32
14e0    
14e0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
14e0    spill R23 -&gt; R11	# spill size = 64
14e4 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1514 +  spill R21 -&gt; R22	# spill size = 64
1518 +  spill R20 -&gt; R21	# spill size = 64
151c +  spill R19 -&gt; R20	# spill size = 64
1520 +  spill R20 -&gt; R19	# spill size = 64
1524 +  spill R21 -&gt; R20	# spill size = 64
1528 +  spill R22 -&gt; R21	# spill size = 64
152c +  spill R26 -&gt; R28	# spill size = 32
1534 +  j  B27	#@branch

1538    B240: #	out( B27 ) &lt;- in( B238 )  Freq: 0.000124679
1538 +  add R29, R29, R7	# ptr, #@addP_reg_reg
153c +  addi  R7, R7, #-8	#@addL_reg_imm
1540 +  sd  R10, [R29, #-8]	# ptr, #@storeP
1544 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1544    sd  R7, [R23, #64]	# long, #@storeL
1548 +  j  B27	#@branch

154c    B241: #	out( B245 B242 ) &lt;- in( B76 )  Freq: 0.000498194
154c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
154c    ld  R7, [R23, #64]	# int, #@loadL
1550 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1550    ld  R28, [R23, #80]	# ptr, #@loadP
1554 +  #@membar_volatile
	fence iorw iorw
1558 +  lb  R30, [R10]	# byte, #@loadB
155c +  beq  R30, zr, B245	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1560    B242: #	out( B244 B243 ) &lt;- in( B241 )  Freq: 0.000249097
1560 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1564 +  beq  R7, zr, B244	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1568    B243: #	out( B245 ) &lt;- in( B242 )  Freq: 0.000124548
1568 +  add R28, R28, R7	# ptr, #@addP_reg_reg
156c +  addi  R7, R7, #-8	#@addL_reg_imm
1570 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1574 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1574    sd  R7, [R23, #64]	# long, #@storeL
1578 +  j  B245	#@branch

157c    B244: #	out( B245 ) &lt;- in( B242 )  Freq: 0.000124548
157c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
157c    spill R23 -&gt; R11	# spill size = 64
1580 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 

15b0    B245: #	out( B77 ) &lt;- in( B244 B243 B241 )  Freq: 0.000498194
15b0    lwu  R9, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
15b4 +  j  B77	#@branch

15b8    B246: #	out( B63 ) &lt;- in( B61 )  Freq: 0.000485542
15b8 +  addi  R28, R26, #16	#@addL_reg_imm
15bc +  srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
15c0 +  andi  R28, R28, #-8	#@andL_reg_imm
15c4 +  add R28, R24, R28	# ptr, #@addP_reg_reg
15c8 +  sub  R29, R7, R29	#@subL_reg_reg
15cc    ClearArray R29, R28	#@clearArray_reg_reg
1624 +  spill R31 -&gt; [sp, #40]	# spill size = 64
1628    
1628    
1628 +  spill R22 -&gt; R25	# spill size = 64
162c +  spill R30 -&gt; R22	# spill size = 64
1630    
1630    
1630 +  spill R26 -&gt; R12	# spill size = 64
1634 +  CALL, runtime leaf nofp 0x000000401396cf00	#@CallLeafNoFPDirect arrayof_jbyte_disjoint_arraycopy
        No JVM State Info
        # 
1638 +  spill R21 -&gt; [sp, #0]	# spill size = 32
163c +  spill R9 -&gt; R21	# spill size = 32
1640 +  spill R22 -&gt; R30	# spill size = 64
1644 +  spill R18 -&gt; R8	# spill size = 32
1648 +  spill R21 -&gt; R9	# spill size = 32
164c +  spill R25 -&gt; R22	# spill size = 64
1650 +  spill R8 -&gt; R18	# spill size = 32
1654 +  spill [sp, #0] -&gt; R21	# spill size = 32
1658 +  spill [sp, #40] -&gt; R31	# spill size = 64
165c +  j  B63	#@branch

1660    B247: #	out( B82 B248 ) &lt;- in( B81 )  Freq: 0.000484969
1660 +  lwu  R7, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
1664 +  decode_heap_oop  R10, R7	#@decodeHeapOop
1668 +  beq   R10, zr, B82	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

166c    B248: #	out( B366 B249 ) &lt;- in( B247 )  Freq: 0.000242484
166c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
166c    ld  R7, [R23, #32]	# int, #@loadL
1670 +  beq  R7, zr, B366	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1674    B249: #	out( B82 ) &lt;- in( B248 )  Freq: 0.000242242
1674 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1674    ld  R28, [R23, #48]	# ptr, #@loadP
1678 +  add R28, R28, R7	# ptr, #@addP_reg_reg
167c +  addi  R7, R7, #-8	#@addL_reg_imm
1680 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1684 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1684    sd  R7, [R23, #32]	# long, #@storeL
1688 +  j  B82	#@branch

168c    B250: #	out( B119 B251 ) &lt;- in( B118 )  Freq: 0.00048478
168c +  lwu  R10, [R18, #16]	# loadN, compressed ptr, #@loadN
1690 +  decode_heap_oop  R10, R10	#@decodeHeapOop
1694 +  beq   R10, zr, B119	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1698    B251: #	out( B368 B252 ) &lt;- in( B250 )  Freq: 0.00024239
1698 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1698    ld  R28, [R23, #32]	# int, #@loadL
169c +  beq  R28, zr, B368	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

16a0    B252: #	out( B119 ) &lt;- in( B251 )  Freq: 0.000242147
16a0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16a0    ld  R13, [R23, #48]	# ptr, #@loadP
16a4 +  add R13, R13, R28	# ptr, #@addP_reg_reg
16a8 +  addi  R28, R28, #-8	#@addL_reg_imm
16ac +  sd  R10, [R13, #-8]	# ptr, #@storeP
16b0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16b0    sd  R28, [R23, #32]	# long, #@storeL
16b4 +  j  B119	#@branch

16b8    B253: #	out( B136 B254 ) &lt;- in( B135 )  Freq: 0.000484766
16b8 +  lwu  R7, [R9]	# loadN, compressed ptr, #@loadN
16bc +  decode_heap_oop  R10, R7	#@decodeHeapOop
16c0 +  beq   R10, zr, B136	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

16c4    B254: #	out( B370 B255 ) &lt;- in( B253 )  Freq: 0.000242383
16c4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16c4    ld  R7, [R23, #32]	# int, #@loadL
16c8 +  beq  R7, zr, B370	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

16cc    B255: #	out( B136 ) &lt;- in( B254 )  Freq: 0.000242141
16cc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16cc    ld  R28, [R23, #48]	# ptr, #@loadP
16d0 +  add R28, R28, R7	# ptr, #@addP_reg_reg
16d4 +  addi  R7, R7, #-8	#@addL_reg_imm
16d8 +  sd  R10, [R28, #-8]	# ptr, #@storeP
16dc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16dc    sd  R7, [R23, #32]	# long, #@storeL
16e0 +  j  B136	#@branch

16e4    B256: #	out( B138 B257 ) &lt;- in( B137 )  Freq: 0.000484288
16e4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16e4    ld  R7, [R23, #64]	# int, #@loadL
16e8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16e8    ld  R28, [R23, #80]	# ptr, #@loadP
16ec +  #@membar_volatile
	fence iorw iorw
16f0 +  lb  R30, [R10]	# byte, #@loadB
16f4 +  beq  R30, zr, B138	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

16f8    B257: #	out( B259 B258 ) &lt;- in( B256 )  Freq: 0.000242144
16f8 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
16fc +  bne  R7, zr, B259	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1700    B258: #	out( B138 ) &lt;- in( B257 )  Freq: 0.000121072
1700 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1700    spill R23 -&gt; R11	# spill size = 64
1704 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1734 +  j  B138	#@branch

1738    B259: #	out( B138 ) &lt;- in( B257 )  Freq: 0.000121072
1738 +  add R28, R28, R7	# ptr, #@addP_reg_reg
173c +  addi  R7, R7, #-8	#@addL_reg_imm
1740 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1744 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1744    sd  R7, [R23, #64]	# long, #@storeL
1748 +  j  B138	#@branch

174c    B260: #	out( B121 B261 ) &lt;- in( B120 )  Freq: 0.000471626
174c +  lwu  R28, [R21, #28]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/NativeBuffer.owner
1750 +  decode_heap_oop  R10, R28	#@decodeHeapOop
1754 +  beq   R10, zr, B121	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1758    B261: #	out( B374 B262 ) &lt;- in( B260 )  Freq: 0.000235813
1758 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1758    ld  R7, [R23, #32]	# int, #@loadL
175c +  beq  R7, zr, B374	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1760    B262: #	out( B121 ) &lt;- in( B261 )  Freq: 0.000235577
1760 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1760    ld  R28, [R23, #48]	# ptr, #@loadP
1764 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1768 +  addi  R7, R7, #-8	#@addL_reg_imm
176c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1770 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1770    sd  R7, [R23, #32]	# long, #@storeL
1774 +  j  B121	#@branch

1778    B263: #	out( B267 B264 ) &lt;- in( B122 )  Freq: 0.00047116
1778 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1778    ld  R28, [R23, #64]	# int, #@loadL
177c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
177c    ld  R29, [R23, #80]	# ptr, #@loadP
1780 +  #@membar_volatile
	fence iorw iorw
1784 +  lb  R30, [R10]	# byte, #@loadB
1788 +  beq  R30, zr, B267	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

178c    B264: #	out( B266 B265 ) &lt;- in( B263 )  Freq: 0.00023558
178c +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1790 +  beq  R28, zr, B266	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1794    B265: #	out( B267 ) &lt;- in( B264 )  Freq: 0.00011779
1794 +  add R29, R29, R28	# ptr, #@addP_reg_reg
1798 +  addi  R28, R28, #-8	#@addL_reg_imm
179c +  sd  R10, [R29, #-8]	# ptr, #@storeP
17a0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
17a0    sd  R28, [R23, #64]	# long, #@storeL
17a4 +  j  B267	#@branch

17a8    B266: #	out( B267 ) &lt;- in( B264 )  Freq: 0.00011779
17a8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
17a8    spill R23 -&gt; R11	# spill size = 64
17ac +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
17dc +  spill R18 -&gt; R7	# spill size = 64

17e0    B267: #	out( B123 ) &lt;- in( B266 B265 B263 )  Freq: 0.00047116
17e0 +  ld  R24, [R21, #16]	# int, #@loadL ! Field: sun/nio/fs/NativeBuffer.address
17e4 +  j  B123	#@branch

17e8    B268: #	out( B461 B269 ) &lt;- in( B102 )  Freq: 0.000180146
17e8 +  spill R11 -&gt; [sp, #4]	# spill size = 32
17ec +  spill R30 -&gt; [sp, #32]	# spill size = 64
17f0 +  spill R9 -&gt; [sp, #48]	# spill size = 32
17f4 +  spill R7 -&gt; [sp, #40]	# spill size = 64
17f8 +  spill R29 -&gt; [sp, #16]	# spill size = 64
17fc +  spill R7 -&gt; R11	# spill size = 64
1800 +  spill R30 -&gt; R12	# spill size = 64
1804    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect sun.nio.fs.UnixNativeDispatcher::stat
        # sun.nio.fs.UnixFileAttributes::get @ bci:14 (line 70) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=6152/0x1808}

1808    B269: #	out( B138 ) &lt;- in( B268 )  Freq: 0.000180142
        # Block is sole successor of call
1808 +  j  B138	#@branch

180c    B270: #	out( B505 B271 ) &lt;- in( B57 B58 )  Freq: 4.90542e-05
180c +  spill R26 -&gt; [sp, #96]	# spill size = 64
1810 +  spill R31 -&gt; [sp, #88]	# spill size = 64
1814 +  spill R21 -&gt; [sp, #80]	# spill size = 32
1818 +  spill R18 -&gt; [sp, #52]	# spill size = 32
181c +  spill R28 -&gt; [sp, #72]	# spill size = 64
1820 +  spill R22 -&gt; [sp, #64]	# spill size = 64
1824 +  spill R30 -&gt; [sp, #56]	# spill size = 64
1828 +  spill R9 -&gt; [sp, #48]	# spill size = 32
182c +  spill R20 -&gt; [sp, #40]	# spill size = 64
1830 +  mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
1848    spill R21 -&gt; R12	# spill size = 32
184c    CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::resolve @ bci:69 (line 369) L[0]=sp + #72 L[1]=sp + #40 L[2]=sp + #52 L[3]=sp + #48 L[4]=_
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #64 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Derived_oop_[40] [64]=Oop [72]=Oop off=6224/0x1850}

1850    B271: #	out( B60 ) &lt;- in( B270 )  Freq: 4.90532e-05
        # Block is sole successor of call
1850 +  spill [sp, #0] -&gt; R19	# spill size = 64
1854 +  spill [sp, #40] -&gt; R20	# spill size = 64
1858 +  spill [sp, #48] -&gt; R9	# spill size = 32
185c +  spill [sp, #56] -&gt; R30	# spill size = 64
1860 +  spill [sp, #64] -&gt; R22	# spill size = 64
1864 +  spill [sp, #72] -&gt; R28	# spill size = 64
1868 +  spill [sp, #52] -&gt; R18	# spill size = 32
186c +  spill [sp, #80] -&gt; R21	# spill size = 32
1870 +  spill [sp, #88] -&gt; R31	# spill size = 64
1874 +  spill [sp, #96] -&gt; R26	# spill size = 64
1878 +  spill R10 -&gt; R24	# spill size = 64
187c +  j  B60	#@branch

1880    B272: #	out( B506 B273 ) &lt;- in( B67 )  Freq: 4.85622e-05
1880 +  spill R24 -&gt; [sp, #40]	# spill size = 64
1884 +  spill R22 -&gt; R8	# spill size = 64
1888 +  spill R19 -&gt; [sp, #0]	# spill size = 64
188c +  mv  R11, precise klass sun/nio/fs/UnixPath: 0x00000040d8247c50:Constant:exact *	# ptr, #@loadConP
18a4    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixPath::resolve @ bci:35 (line 383) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #40
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=6312/0x18a8}

18a8    B273: #	out( B69 ) &lt;- in( B272 )  Freq: 4.85612e-05
        # Block is sole successor of call
18a8 +  spill [sp, #0] -&gt; R19	# spill size = 64
18ac +  spill R8 -&gt; R22	# spill size = 64
18b0 +  spill [sp, #40] -&gt; R24	# spill size = 64
18b4 +  spill R10 -&gt; R18	# spill size = 64
18b8 +  j  B69	#@branch

18bc    B274: #	out( B460 B275 ) &lt;- in( B100 )  Freq: 4.85052e-05
18bc +  spill R9 -&gt; [sp, #48]	# spill size = 32
18c0 +  spill R7 -&gt; [sp, #40]	# spill size = 64
18c4 +  spill R29 -&gt; [sp, #16]	# spill size = 64
18c8 +  mv  R11, precise klass sun/nio/fs/UnixFileAttributes: 0x00000040d819d360:Constant:exact *	# ptr, #@loadConP
18e0    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixFileAttributes::get @ bci:0 (line 68) L[0]=sp + #40 L[1]=sp + #48 L[2]=_
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=6372/0x18e4}

18e4    B275: #	out( B102 ) &lt;- in( B274 )  Freq: 4.85042e-05
        # Block is sole successor of call
18e4 +  spill [sp, #16] -&gt; R29	# spill size = 64
18e8 +  spill [sp, #40] -&gt; R7	# spill size = 64
18ec +  spill [sp, #48] -&gt; R9	# spill size = 32
18f0 +  j  B102	#@branch

18f4    B276: #	out( B449 B277 ) &lt;- in( B138 )  Freq: 4.85033e-05
18f4 +  mv  R11, precise klass sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes: 0x00000040d01c5930:Constant:exact *	# ptr, #@loadConP
190c    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes::wrap @ bci:0 (line 274) L[0]=sp + #32
        # sun.nio.fs.UnixFileAttributes::asBasicFileAttributes @ bci:1 (line 251) L[0]=_
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:20 (line 53) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=6416/0x1910}

1910    B277: #	out( B140 ) &lt;- in( B276 )  Freq: 4.85023e-05
        # Block is sole successor of call
1910 +  j  B140	#@branch

1914    B278: #	out( B523 B279 ) &lt;- in( B146 )  Freq: 4.71488e-05
1914 +  spill R30 -&gt; [sp, #0]	# spill size = 64
1918 +  mv  R11, precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d8218cb0:Constant:exact *	# ptr, #@loadConP
1930    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.nio.file.FileTreeWalker::visit @ bci:66 (line 289) L[0]=_ L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop off=6452/0x1934}

1934    B279: #	out( B148 ) &lt;- in( B278 )  Freq: 4.71478e-05
        # Block is sole successor of call
1934 +  spill [sp, #16] -&gt; R31	# spill size = 64
1938 +  spill [sp, #0] -&gt; R30	# spill size = 64
193c +  j  B148	#@branch

1940    B280: #	out( B178 B281 ) &lt;- in( B177 )  Freq: 2.6568e-05
1940 +  lwu  R28, [R30, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
1944 +  decode_heap_oop  R10, R28	#@decodeHeapOop
1948 +  beq   R10, zr, B178	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

194c    B281: #	out( B389 B282 ) &lt;- in( B280 )  Freq: 1.3284e-05
194c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
194c    ld  R7, [R23, #32]	# int, #@loadL
1950 +  far_beq  R7, zr, B389	#@far_cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1958    B282: #	out( B178 ) &lt;- in( B281 )  Freq: 1.32707e-05
1958 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1958    ld  R28, [R23, #48]	# ptr, #@loadP
195c +  add R28, R28, R7	# ptr, #@addP_reg_reg
1960 +  addi  R7, R7, #-8	#@addL_reg_imm
1964 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1968 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1968    sd  R7, [R23, #32]	# long, #@storeL
196c +  j  B178	#@branch

1970    B283: #	out( B180 B284 ) &lt;- in( B179 )  Freq: 2.65418e-05
1970 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1970    ld  R7, [R23, #64]	# int, #@loadL
1974 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1974    ld  R29, [R23, #80]	# ptr, #@loadP
1978 +  #@membar_volatile
	fence iorw iorw
197c +  lb  R11, [R10]	# byte, #@loadB
1980 +  beq  R11, zr, B180	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1984    B284: #	out( B286 B285 ) &lt;- in( B283 )  Freq: 1.32709e-05
1984 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1988 +  bne  R7, zr, B286	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

198c    B285: #	out( B180 ) &lt;- in( B284 )  Freq: 6.63545e-06
198c +  spill R30 -&gt; R22	# spill size = 64
1990    
1990    
1990 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1990    spill R23 -&gt; R11	# spill size = 64
1994 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
19c4 +  spill [sp, #40] -&gt; R28	# spill size = 32
19c8 +  spill R22 -&gt; R30	# spill size = 64
19cc +  j  B180	#@branch

19d0    B286: #	out( B180 ) &lt;- in( B284 )  Freq: 6.63545e-06
19d0 +  add R29, R29, R7	# ptr, #@addP_reg_reg
19d4 +  addi  R7, R7, #-8	#@addL_reg_imm
19d8 +  sd  R10, [R29, #-8]	# ptr, #@storeP
19dc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
19dc    sd  R7, [R23, #64]	# long, #@storeL
19e0 +  j  B180	#@branch

19e4    B287: #	out( B202 B288 ) &lt;- in( B200 )  Freq: 1.35403e-05
19e4 +  spill [sp, #56] -&gt; R20	# spill size = 64
19e8 +  lwu  R28, [R20, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.dir
19ec +  decode_heap_oop  R10, R28	#@decodeHeapOop
19f0 +  beq   R10, zr, B202	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

19f4    B288: #	out( B393 B289 ) &lt;- in( B287 )  Freq: 6.77017e-06
19f4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
19f4    ld  R7, [R23, #32]	# int, #@loadL
19f8 +  far_beq  R7, zr, B393	#@far_cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1a00    B289: #	out( B202 ) &lt;- in( B288 )  Freq: 6.7634e-06
1a00 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a00    ld  R28, [R23, #48]	# ptr, #@loadP
1a04 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1a08 +  addi  R7, R7, #-8	#@addL_reg_imm
1a0c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1a10 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a10    sd  R7, [R23, #32]	# long, #@storeL
1a14 +  j  B202	#@branch

1a18    B290: #	out( B205 B291 ) &lt;- in( B204 )  Freq: 1.35403e-05
1a18 +  lwu  R28, [R20, #20]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.key
1a1c +  decode_heap_oop  R10, R28	#@decodeHeapOop
1a20 +  beq   R10, zr, B205	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1a24    B291: #	out( B394 B292 ) &lt;- in( B290 )  Freq: 6.77017e-06
1a24 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a24    ld  R7, [R23, #32]	# int, #@loadL
1a28 +  far_beq  R7, zr, B394	#@far_cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1a30    B292: #	out( B205 ) &lt;- in( B291 )  Freq: 6.7634e-06
1a30 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a30    ld  R28, [R23, #48]	# ptr, #@loadP
1a34 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1a38 +  addi  R7, R7, #-8	#@addL_reg_imm
1a3c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1a40 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a40    sd  R7, [R23, #32]	# long, #@storeL
1a44 +  j  B205	#@branch

1a48    B293: #	out( B209 B294 ) &lt;- in( B208 )  Freq: 1.35403e-05
1a48 +  lwu  R28, [R20, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.stream
1a4c +  decode_heap_oop  R10, R28	#@decodeHeapOop
1a50 +  beq   R10, zr, B209	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1a54    B294: #	out( B395 B295 ) &lt;- in( B293 )  Freq: 6.77017e-06
1a54 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a54    ld  R7, [R23, #32]	# int, #@loadL
1a58 +  far_beq  R7, zr, B395	#@far_cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1a60    B295: #	out( B209 ) &lt;- in( B294 )  Freq: 6.7634e-06
1a60 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a60    ld  R28, [R23, #48]	# ptr, #@loadP
1a64 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1a68 +  addi  R7, R7, #-8	#@addL_reg_imm
1a6c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1a70 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a70    sd  R7, [R23, #32]	# long, #@storeL
1a74 +  j  B209	#@branch

1a78    B296: #	out( B215 B297 ) &lt;- in( B213 )  Freq: 1.35401e-05
1a78 +  spill R8 -&gt; R18	# spill size = 64
1a7c +  lwu  R7, [R18, #28]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.iterator
1a80 +  decode_heap_oop  R10, R7	#@decodeHeapOop
1a84 +  beq   R10, zr, B215	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1a88    B297: #	out( B396 B298 ) &lt;- in( B296 )  Freq: 6.77003e-06
1a88 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a88    ld  R7, [R23, #32]	# int, #@loadL
1a8c +  far_beq  R7, zr, B396	#@far_cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1a94    B298: #	out( B215 ) &lt;- in( B297 )  Freq: 6.76326e-06
1a94 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a94    ld  R28, [R23, #48]	# ptr, #@loadP
1a98 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1a9c +  addi  R7, R7, #-8	#@addL_reg_imm
1aa0 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1aa4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1aa4    sd  R7, [R23, #32]	# long, #@storeL
1aa8 +  j  B215	#@branch

1aac    B299: #	out( B204 B300 ) &lt;- in( B203 )  Freq: 1.3527e-05
1aac +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1aac    ld  R7, [R23, #64]	# int, #@loadL
1ab0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ab0    ld  R28, [R23, #80]	# ptr, #@loadP
1ab4 +  #@membar_volatile
	fence iorw iorw
1ab8 +  lb  R29, [R10]	# byte, #@loadB
1abc +  beq  R29, zr, B204	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1ac0    B300: #	out( B302 B301 ) &lt;- in( B299 )  Freq: 6.76349e-06
1ac0 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1ac4 +  bne  R7, zr, B302	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1ac8    B301: #	out( B204 ) &lt;- in( B300 )  Freq: 3.38174e-06
1ac8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ac8    spill R23 -&gt; R11	# spill size = 64
1acc +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1afc +  j  B204	#@branch

1b00    B302: #	out( B204 ) &lt;- in( B300 )  Freq: 3.38174e-06
1b00 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1b04 +  addi  R7, R7, #-8	#@addL_reg_imm
1b08 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1b0c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b0c    sd  R7, [R23, #64]	# long, #@storeL
1b10 +  j  B204	#@branch

1b14    B303: #	out( B208 B304 ) &lt;- in( B207 )  Freq: 1.35134e-05
1b14 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b14    ld  R7, [R23, #64]	# int, #@loadL
1b18 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b18    ld  R28, [R23, #80]	# ptr, #@loadP
1b1c +  #@membar_volatile
	fence iorw iorw
1b20 +  lb  R29, [R10]	# byte, #@loadB
1b24 +  beq  R29, zr, B208	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1b28    B304: #	out( B306 B305 ) &lt;- in( B303 )  Freq: 6.75672e-06
1b28 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1b2c +  bne  R7, zr, B306	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1b30    B305: #	out( B208 ) &lt;- in( B304 )  Freq: 3.37836e-06
1b30 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b30    spill R23 -&gt; R11	# spill size = 64
1b34 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1b64 +  j  B208	#@branch

1b68    B306: #	out( B208 ) &lt;- in( B304 )  Freq: 3.37836e-06
1b68 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1b6c +  addi  R7, R7, #-8	#@addL_reg_imm
1b70 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1b74 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b74    sd  R7, [R23, #64]	# long, #@storeL
1b78 +  j  B208	#@branch

1b7c    B307: #	out( B212 B308 ) &lt;- in( B211 )  Freq: 1.35134e-05
1b7c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b7c    ld  R7, [R23, #64]	# int, #@loadL
1b80 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b80    ld  R28, [R23, #80]	# ptr, #@loadP
1b84 +  #@membar_volatile
	fence iorw iorw
1b88 +  lb  R29, [R10]	# byte, #@loadB
1b8c +  beq  R29, zr, B212	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1b90    B308: #	out( B310 B309 ) &lt;- in( B307 )  Freq: 6.75672e-06
1b90 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1b94 +  bne  R7, zr, B310	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1b98    B309: #	out( B212 ) &lt;- in( B308 )  Freq: 3.37836e-06
1b98 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b98    spill R23 -&gt; R11	# spill size = 64
1b9c +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1bcc +  j  B212	#@branch

1bd0    B310: #	out( B212 ) &lt;- in( B308 )  Freq: 3.37836e-06
1bd0 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1bd4 +  addi  R7, R7, #-8	#@addL_reg_imm
1bd8 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1bdc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1bdc    sd  R7, [R23, #64]	# long, #@storeL
1be0 +  j  B212	#@branch

1be4    B311: #	out( B218 B312 ) &lt;- in( B217 )  Freq: 1.35132e-05
1be4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1be4    ld  R7, [R23, #64]	# int, #@loadL
1be8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1be8    ld  R28, [R23, #80]	# ptr, #@loadP
1bec +  #@membar_volatile
	fence iorw iorw
1bf0 +  lb  R29, [R10]	# byte, #@loadB
1bf4 +  beq  R29, zr, B218	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1bf8    B312: #	out( B314 B313 ) &lt;- in( B311 )  Freq: 6.75659e-06
1bf8 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1bfc +  bne  R7, zr, B314	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1c00    B313: #	out( B218 ) &lt;- in( B312 )  Freq: 3.37829e-06
1c00 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1c00    spill R23 -&gt; R11	# spill size = 64
1c04 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1c34 +  j  B218	#@branch

1c38    B314: #	out( B218 ) &lt;- in( B312 )  Freq: 3.37829e-06
1c38 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1c3c +  addi  R7, R7, #-8	#@addL_reg_imm
1c40 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1c44 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1c44    sd  R7, [R23, #64]	# long, #@storeL
1c48 +  j  B218	#@branch

1c4c    B315: #	out( B521 B316 ) &lt;- in( B190 )  Freq: 1.42181e-06
1c4c +  mv  R11, precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d8218cb0:Constant:exact *	# ptr, #@loadConP
1c64    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.nio.file.FileTreeWalker::next @ bci:113 (line 370) L[0]=_ L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop off=7272/0x1c68}

1c68    B316: #	out( B192 ) &lt;- in( B315 )  Freq: 1.42178e-06
        # Block is sole successor of call
1c68 +  j  B192	#@branch

1c6c    B317: #	out( B520 B318 ) &lt;- in( B197 )  Freq: 1.3543e-06
1c6c +  spill R31 -&gt; [sp, #48]	# spill size = 64
1c70 +  mv  R11, precise klass java/nio/file/FileTreeWalker$DirectoryNode: 0x00000040d83de8c0:Constant:exact *	# ptr, #@loadConP
1c88    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.nio.file.FileTreeWalker::visit @ bci:170 (line 311) L[0]=_ L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=R8 L[7]=_ STK[0]=sp + #48
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop off=7308/0x1c8c}

1c8c    B318: #	out( B199 ) &lt;- in( B317 )  Freq: 1.35428e-06
        # Block is sole successor of call
1c8c +  j  B199	#@branch

1c90    B319: #	out( B519 B320 ) &lt;- in( B220 )  Freq: 1.35422e-06
1c90 +  mv  R11, precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d8218cb0:Constant:exact *	# ptr, #@loadConP
1ca8    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.nio.file.FileTreeWalker::visit @ bci:190 (line 312) L[0]=_ L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=7340/0x1cac}

1cac    B320: #	out( B222 ) &lt;- in( B319 )  Freq: 1.35419e-06
        # Block is sole successor of call
1cac +  j  B222	#@branch

1cb0    B321: #	out( N6588 ) &lt;- in( B35 )  Freq: 5.25779e-07
1cb0 +  spill [sp, #8] -&gt; R7	# spill size = 64
1cb4 +  li R11, #-34	# int, #@loadConI
1cb8    spill R7 -&gt; [sp, #0]	# spill size = 64
1cbc +  spill R28 -&gt; [sp, #32]	# spill size = 64
1cc0 +  spill R28 -&gt; [sp, #40]	# spill size = 64
1cc4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #32 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop off=7368/0x1cc8}
1cc8    #@ShouldNotReachHere

1cd4    B322: #	out( N6588 ) &lt;- in( B42 )  Freq: 5.25777e-07
1cd4 +  spill [sp, #8] -&gt; R7	# spill size = 64
1cd8 +  li R11, #-20	# int, #@loadConI
1cdc    spill R7 -&gt; [sp, #0]	# spill size = 64
1ce0 +  spill R28 -&gt; [sp, #32]	# spill size = 64
1ce4 +  spill R28 -&gt; [sp, #40]	# spill size = 64
1ce8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_assert&apos; action=&apos;make_not_entrant&apos;)
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:12 (line 1095) L[0]=_ L[1]=_ STK[0]=R8
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #32 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop off=7404/0x1cec}
1cec    #@ShouldNotReachHere

1cf8    B323: #	out( N6588 ) &lt;- in( B152 )  Freq: 5.13831e-07
1cf8 +  spill [sp, #8] -&gt; R8	# spill size = 64
1cfc +  li R11, #-20	# int, #@loadConI
1d00    spill R10 -&gt; [sp, #8]	# spill size = 64
1d04    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_assert&apos; action=&apos;make_not_entrant&apos;)
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:23 (line 85) L[0]=R8 L[1]=sp + #0 L[2]=_ STK[0]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=7432/0x1d08}
1d08    #@ShouldNotReachHere

1d14    B324: #	out( N6588 ) &lt;- in( B45 )  Freq: 5.12114e-07
1d14 +  li R11, #-28	# int, #@loadConI
1d18    spill [sp, #8] -&gt; R8	# spill size = 64
1d1c +  spill R20 -&gt; [sp, #64]	# spill size = 64
1d20 +  spill R20 -&gt; [sp, #72]	# spill size = 64
1d24    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::isSelfOrParent @ bci:2 (line 145) L[0]=_ L[1]=sp + #72 STK[0]=sp + #64 STK[1]=#0
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:123 (line 181) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [64]=Oop [72]=Oop off=7464/0x1d28}
1d28    #@ShouldNotReachHere

1d34    B325: #	out( N6588 ) &lt;- in( B5 )  Freq: 5.06355e-07
1d34 +  li R11, #-28	# int, #@loadConI
1d38    spill R9 -&gt; [sp, #0]	# spill size = 64
1d3c +  spill R18 -&gt; [sp, #8]	# spill size = 64
1d40 +  spill R30 -&gt; [sp, #16]	# spill size = 32
1d44    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ArrayDeque::elementAt @ bci:2 (line 259) L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #16
        # java.util.ArrayDeque::peekFirst @ bci:8 (line 418) L[0]=_
        # java.util.ArrayDeque::peek @ bci:1 (line 564) L[0]=_
        # java.nio.file.FileTreeWalker::next @ bci:4 (line 335) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=7496/0x1d48}
1d48    #@ShouldNotReachHere

1d54    B326: #	out( N6588 ) &lt;- in( B10 )  Freq: 4.99218e-07
1d54 +  li R11, #-34	# int, #@loadConI
1d58    spill R9 -&gt; R8	# spill size = 64
1d5c +  spill R18 -&gt; [sp, #0]	# spill size = 64
1d60 +  spill R24 -&gt; [sp, #8]	# spill size = 64
1d64 +  spill R19 -&gt; [sp, #24]	# spill size = 64
1d68    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #24 L[6]=_ STK[0]=sp + #24
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop off=7532/0x1d6c}
1d6c    #@ShouldNotReachHere

1d78    B327: #	out( B12 ) &lt;- in( B11 )  Freq: 4.99218e-07
1d78 +  spill R20 -&gt; [sp, #24]	# spill size = 64
1d7c    
1d7c    
1d7c +  spill R11 -&gt; R8	# spill size = 64
1d80 +  spill R19 -&gt; [sp, #16]	# spill size = 64
1d84 +  spill R19 -&gt; R11	# spill size = 64
1d88    
1d88    
1d88 +  spill R18 -&gt; [sp, #0]	# spill size = 64
1d8c    
1d8c    
1d8c +  spill R24 -&gt; [sp, #8]	# spill size = 64
1d90    
1d90    
1d90    add R12, sp, #144	# box lock
1d94 +  CALL,static 0x000000401390c140	#@CallStaticJavaDirect wrapper for: _complete_monitor_locking_Java
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:-1 (line 197) L[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=7576/0x1d98}
1d98 +  spill R8 -&gt; R9	# spill size = 64
1d9c +  spill [sp, #0] -&gt; R18	# spill size = 64
1da0 +  spill [sp, #8] -&gt; R24	# spill size = 64
1da4 +  spill [sp, #16] -&gt; R19	# spill size = 64
1da8 +  spill [sp, #24] -&gt; R20	# spill size = 64
1dac +  j  B12	#@branch

1db0    B328: #	out( N6588 ) &lt;- in( B17 )  Freq: 4.99216e-07
1db0 +  li R11, #-34	# int, #@loadConI
1db4    spill R9 -&gt; [sp, #0]	# spill size = 64
1db8 +  spill R18 -&gt; [sp, #8]	# spill size = 64
1dbc +  spill R24 -&gt; [sp, #16]	# spill size = 64
1dc0 +  spill R19 -&gt; [sp, #32]	# spill size = 64
1dc4 +  spill R19 -&gt; [sp, #40]	# spill size = 64
1dc8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #32 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop off=7628/0x1dcc}
1dcc    #@ShouldNotReachHere

1dd8    B329: #	out( N6588 ) &lt;- in( B20 )  Freq: 4.99215e-07
1dd8 +  li R11, #-20	# int, #@loadConI
1ddc    spill R9 -&gt; [sp, #0]	# spill size = 64
1de0 +  spill R18 -&gt; [sp, #8]	# spill size = 64
1de4 +  spill R24 -&gt; [sp, #16]	# spill size = 64
1de8 +  spill R19 -&gt; [sp, #32]	# spill size = 64
1dec +  spill R19 -&gt; [sp, #40]	# spill size = 64
1df0 +  spill R21 -&gt; [sp, #72]	# spill size = 64
1df4 +  spill R20 -&gt; [sp, #80]	# spill size = 64
1df8 +  spill R30 -&gt; [sp, #88]	# spill size = 32
1dfc +  spill R31 -&gt; [sp, #92]	# spill size = 32
1e00 +  spill R21 -&gt; [sp, #96]	# spill size = 64
1e04    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_assert&apos; action=&apos;make_not_entrant&apos;)
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::hasQueuedPredecessors @ bci:6 (line 1234) L[0]=sp + #72 L[1]=#NULL L[2]=_ L[3]=_ STK[0]=R8
        # java.util.concurrent.locks.ReentrantReadWriteLock$FairSync::readerShouldBlock @ bci:1 (line 706) L[0]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:33 (line 475) L[0]=sp + #96 L[1]=_ L[2]=sp + #80 L[3]=sp + #88 L[4]=sp + #92 L[5]=_
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #72 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #32 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop [72]=Oop [80]=Oop [96]=Oop off=7688/0x1e08}
1e08    #@ShouldNotReachHere

1e14    B330: #	out( B78 ) &lt;- in( B77 )  Freq: 4.99192e-07
1e14    add R11, sp, #144	# box lock
1e18 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1e18    spill R23 -&gt; R12	# spill size = 64
1e1c +  spill R19 -&gt; R10	# spill size = 64
1e20 +  CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
1e50 +  j  B78	#@branch

1e54    B331: #	out( B56 ) &lt;- in( B54 )  Freq: 4.9199e-07
1e54 +  addw  R29, R21, zr	#@convI2L_reg_reg
1e58 +  j  B56	#@branch

1e5c    B332: #	out( N6588 ) &lt;- in( B63 )  Freq: 4.9199e-07
1e5c +  spill [sp, #8] -&gt; R8	# spill size = 64
1e60 +  li R11, #-28	# int, #@loadConI
1e64    spill R19 -&gt; [sp, #8]	# spill size = 64
1e68 +  spill R19 -&gt; [sp, #32]	# spill size = 64
1e6c +  spill R22 -&gt; [sp, #56]	# spill size = 64
1e70 +  spill R20 -&gt; [sp, #64]	# spill size = 64
1e74 +  spill R9 -&gt; [sp, #76]	# spill size = 32
1e78 +  spill R24 -&gt; [sp, #88]	# spill size = 64
1e7c +  spill R18 -&gt; [sp, #96]	# spill size = 32
1e80    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:88 (line 371) L[0]=_ L[1]=sp + #64 L[2]=sp + #96 L[3]=sp + #76 L[4]=sp + #88 STK[0]=sp + #88 STK[1]=sp + #96 STK[2]=#47
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [56]=Oop [64]=Oop [88]=Oop off=7812/0x1e84}
1e84    #@ShouldNotReachHere

1e90    B333: #	out( B334 ) &lt;- in( B84 )  Freq: 4.91415e-07
1e90 +  spill [sp, #16] -&gt; R29	# spill size = 64

1e94    B334: #	out( N6588 ) &lt;- in( B333 B85 )  Freq: 9.82829e-07
1e94 +  spill [sp, #8] -&gt; R8	# spill size = 64
1e98 +  li R11, #-187	# int, #@loadConI
1e9c    spill R29 -&gt; [sp, #8]	# spill size = 64
1ea0 +  spill R29 -&gt; [sp, #32]	# spill size = 64
1ea4 +  spill R7 -&gt; [sp, #40]	# spill size = 64
1ea8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::getAttributes @ bci:8 (line 206) L[0]=sp + #8 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_ STK[0]=#1
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop off=7852/0x1eac}
1eac    #@ShouldNotReachHere

1eb8    B335: #	out( N6588 ) &lt;- in( B87 )  Freq: 4.91413e-07
1eb8 +  li R11, #-10	# int, #@loadConI
1ebc    spill [sp, #8] -&gt; R8	# spill size = 64
1ec0 +  spill R15 -&gt; [sp, #0]	# spill size = 64
1ec4 +  spill R7 -&gt; [sp, #48]	# spill size = 64
1ec8 +  spill R7 -&gt; [sp, #56]	# spill size = 64
1ecc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL STK[1]=sp + #48 STK[2]=#Ptr0x00000040d01c9f20 STK[3]=sp + #0
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #48 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop off=7888/0x1ed0}
1ed0    #@ShouldNotReachHere

1edc    B336: #	out( N6588 ) &lt;- in( B56 )  Freq: 4.85543e-07
1edc +  li R11, #-52	# int, #@loadConI
1ee0    spill [sp, #8] -&gt; R8	# spill size = 64
1ee4 +  spill R22 -&gt; [sp, #56]	# spill size = 64
1ee8 +  spill R28 -&gt; [sp, #64]	# spill size = 64
1eec +  spill R20 -&gt; [sp, #72]	# spill size = 64
1ef0 +  spill R18 -&gt; [sp, #80]	# spill size = 32
1ef4 +  spill R9 -&gt; [sp, #84]	# spill size = 32
1ef8 +  spill R21 -&gt; [sp, #88]	# spill size = 32
1efc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:69 (line 369) L[0]=sp + #64 L[1]=sp + #72 L[2]=sp + #80 L[3]=sp + #84 L[4]=_ STK[0]=sp + #88
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [56]=Oop [64]=Oop [72]=Oop off=7936/0x1f00}
1f00    #@ShouldNotReachHere

1f0c    B337: #	out( B63 ) &lt;- in( B60 )  Freq: 4.85542e-07
1f0c +  spill R11 -&gt; R28	# spill size = 64
1f10 +  addi  R29, R7, #-2	#@addL_reg_imm
1f14    ClearArray R29, R28	#@clearArray_reg_reg
1f6c    
1f6c +  j  B63	#@branch

1f70    B338: #	out( N6588 ) &lt;- in( B64 )  Freq: 4.85542e-07
1f70 +  spill [sp, #8] -&gt; R7	# spill size = 64
1f74 +  li R11, #-52	# int, #@loadConI
1f78    spill R7 -&gt; [sp, #0]	# spill size = 64
1f7c +  spill R19 -&gt; [sp, #32]	# spill size = 64
1f80 +  spill R19 -&gt; [sp, #40]	# spill size = 64
1f84 +  spill R22 -&gt; [sp, #64]	# spill size = 64
1f88 +  spill R20 -&gt; [sp, #80]	# spill size = 64
1f8c +  spill R24 -&gt; [sp, #88]	# spill size = 64
1f90 +  spill R9 -&gt; [sp, #96]	# spill size = 32
1f94    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:97 (line 372) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #88 STK[0]=sp + #80 STK[1]=#0 STK[2]=sp + #88 STK[3]=R8 STK[4]=sp + #96
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #64 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #32 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [64]=Oop [80]=Oop [88]=Oop off=8088/0x1f98}
1f98    #@ShouldNotReachHere

1fa4    B339: #	out( N6588 ) &lt;- in( B71 )  Freq: 4.8554e-07
1fa4 +  spill [sp, #8] -&gt; R7	# spill size = 64
1fa8 +  li R11, #-34	# int, #@loadConI
1fac    spill R7 -&gt; [sp, #0]	# spill size = 64
1fb0 +  spill R19 -&gt; [sp, #32]	# spill size = 64
1fb4 +  spill R19 -&gt; [sp, #40]	# spill size = 64
1fb8 +  spill R18 -&gt; [sp, #72]	# spill size = 64
1fbc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:159 (line 186) L[0]=sp + #32 L[1]=_ L[2]=sp + #72 L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #72
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [72]=Oop off=8128/0x1fc0}
1fc0    #@ShouldNotReachHere

1fcc    B340: #	out( B80 ) &lt;- in( B79 )  Freq: 4.84975e-07
1fcc +  spill R19 -&gt; R8	# spill size = 64
1fd0 +  spill R19 -&gt; R11	# spill size = 64
1fd4    
1fd4    
1fd4    add R12, sp, #144	# box lock
1fd8 +  CALL,static 0x000000401390c140	#@CallStaticJavaDirect wrapper for: _complete_monitor_locking_Java
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::next @ bci:-1 (line 205) L[0]=R8 L[1]=_ MON-BOX0=sp+144 MON-OBJ[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::next @ bci:1 (line 132) L[0]=_
        # java.nio.file.FileTreeWalker::next @ bci:47 (line 350) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop off=8156/0x1fdc}
1fdc +  spill R8 -&gt; R19	# spill size = 64
1fe0 +  j  B80	#@branch

1fe4    B341: #	out( B83 ) &lt;- in( B82 )  Freq: 4.84975e-07
1fe4    add R11, sp, #144	# box lock
1fe8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1fe8    spill R23 -&gt; R12	# spill size = 64
1fec +  spill R19 -&gt; R10	# spill size = 64
1ff0 +  CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
2020 +  j  B83	#@branch

2024    B342: #	out( N6588 ) &lt;- in( B143 )  Freq: 4.84951e-07
2024 +  spill [sp, #8] -&gt; R8	# spill size = 64
2028 +  li R11, #-34	# int, #@loadConI
202c    spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
2034 +  spill R12 -&gt; [sp, #32]	# spill size = 64
2038    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:58 (line 288) L[0]=sp + #8 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop off=8252/0x203c}
203c    #@ShouldNotReachHere

2048    B343: #	out( N6588 ) &lt;- in( B110 )  Freq: 4.84789e-07
2048 +  spill [sp, #8] -&gt; R8	# spill size = 64
204c +  li R11, #-28	# int, #@loadConI
2050    spill R29 -&gt; [sp, #8]	# spill size = 64
2054 +  spill R29 -&gt; [sp, #32]	# spill size = 64
2058 +  spill R7 -&gt; [sp, #40]	# spill size = 64
205c +  spill R30 -&gt; [sp, #56]	# spill size = 64
2060 +  spill R7 -&gt; [sp, #64]	# spill size = 64
2064 +  spill R12 -&gt; [sp, #72]	# spill size = 64
2068 +  spill R19 -&gt; [sp, #84]	# spill size = 32
206c +  spill R15 -&gt; [sp, #96]	# spill size = 64
2070 +  spill R16 -&gt; [sp, #104]	# spill size = 64
2074 +  spill R20 -&gt; [sp, #120]	# spill size = 64
2078 +  spill R13 -&gt; [sp, #116]	# spill size = 32
207c +  spill R9 -&gt; [sp, #128]	# spill size = 32
2080    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:18 (line 435) L[0]=sp + #96 L[1]=sp + #104 L[2]=sp + #116 L[3]=_ STK[0]=sp + #120 STK[1]=sp + #116
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #104 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #40 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #128, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [96]=Oop [104]=Oop [120]=Oop off=8324/0x2084}
2084    #@ShouldNotReachHere

2090    B344: #	out( N6588 ) &lt;- in( B112 )  Freq: 4.84788e-07
2090 +  spill [sp, #8] -&gt; R8	# spill size = 64
2094 +  li R11, #-187	# int, #@loadConI
2098    spill R29 -&gt; [sp, #8]	# spill size = 64
209c +  spill R29 -&gt; [sp, #32]	# spill size = 64
20a0 +  spill R7 -&gt; [sp, #40]	# spill size = 64
20a4 +  spill R30 -&gt; [sp, #56]	# spill size = 64
20a8 +  spill R7 -&gt; [sp, #64]	# spill size = 64
20ac +  spill R12 -&gt; [sp, #72]	# spill size = 64
20b0 +  spill R19 -&gt; [sp, #84]	# spill size = 32
20b4 +  spill R15 -&gt; [sp, #96]	# spill size = 64
20b8 +  spill R16 -&gt; [sp, #104]	# spill size = 64
20bc +  spill R13 -&gt; [sp, #112]	# spill size = 32
20c0 +  spill R20 -&gt; [sp, #120]	# spill size = 64
20c4 +  spill R9 -&gt; [sp, #116]	# spill size = 32
20c8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:29 (line 436) L[0]=sp + #96 L[1]=sp + #104 L[2]=sp + #112 L[3]=sp + #120 STK[0]=#0
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #104 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #40 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #116, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [96]=Oop [104]=Oop [120]=Oop off=8396/0x20cc}
20cc    #@ShouldNotReachHere

20d8    B345: #	out( N6588 ) &lt;- in( B115 )  Freq: 4.84787e-07
20d8 +  spill [sp, #8] -&gt; R8	# spill size = 64
20dc +  li R11, #-28	# int, #@loadConI
20e0    spill R29 -&gt; [sp, #8]	# spill size = 64
20e4 +  spill R29 -&gt; [sp, #32]	# spill size = 64
20e8 +  spill R7 -&gt; [sp, #40]	# spill size = 64
20ec +  spill R30 -&gt; [sp, #56]	# spill size = 64
20f0 +  spill R7 -&gt; [sp, #64]	# spill size = 64
20f4 +  spill R12 -&gt; [sp, #72]	# spill size = 64
20f8 +  spill R19 -&gt; [sp, #84]	# spill size = 32
20fc +  spill R18 -&gt; [sp, #96]	# spill size = 64
2100 +  spill R9 -&gt; [sp, #104]	# spill size = 32
2104    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:23 (line 75) L[0]=sp + #84 L[1]=sp + #96 L[2]=#0 L[3]=_ STK[0]=sp + #96 STK[1]=#0
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #40 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #104, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [96]=Oop off=8456/0x2108}
2108    #@ShouldNotReachHere

2114    B346: #	out( N6588 ) &lt;- in( B128 )  Freq: 4.84775e-07
2114 +  spill [sp, #8] -&gt; R8	# spill size = 64
2118 +  li R11, #-28	# int, #@loadConI
211c    spill R30 -&gt; [sp, #8]	# spill size = 64
2120 +  spill R28 -&gt; [sp, #64]	# spill size = 64
2124 +  spill R12 -&gt; [sp, #72]	# spill size = 64
2128 +  spill R29 -&gt; [sp, #80]	# spill size = 32
212c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:18 (line 435) L[0]=sp + #8 L[1]=sp + #64 L[2]=sp + #80 L[3]=_ STK[0]=sp + #72 STK[1]=sp + #80
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #64 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop off=8496/0x2130}
2130    #@ShouldNotReachHere

213c    B347: #	out( N6588 ) &lt;- in( B130 )  Freq: 4.84774e-07
213c +  spill [sp, #8] -&gt; R8	# spill size = 64
2140 +  li R11, #-187	# int, #@loadConI
2144    spill R30 -&gt; [sp, #8]	# spill size = 64
2148 +  spill R28 -&gt; [sp, #64]	# spill size = 64
214c +  spill R29 -&gt; [sp, #52]	# spill size = 32
2150 +  spill R7 -&gt; [sp, #72]	# spill size = 64
2154    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:29 (line 436) L[0]=sp + #8 L[1]=sp + #64 L[2]=sp + #52 L[3]=sp + #72 STK[0]=#0
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #64 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop off=8536/0x2158}
2158    #@ShouldNotReachHere

2164    B348: #	out( N6588 ) &lt;- in( B133 )  Freq: 4.84773e-07
2164 +  spill [sp, #8] -&gt; R8	# spill size = 64
2168 +  li R11, #-28	# int, #@loadConI
216c    spill R10 -&gt; [sp, #8]	# spill size = 64
2170    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:40 (line 115) L[0]=sp + #56 L[1]=sp + #8 L[2]=#0 L[3]=_ STK[0]=sp + #8 STK[1]=#0
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop off=8564/0x2174}
2174    #@ShouldNotReachHere

2180    B349: #	out( N6588 ) &lt;- in( B93 )  Freq: 4.84701e-07
2180 +  decode_heap_oop  R8, R30	#@decodeHeapOop
2184    spill [sp, #8] -&gt; R30	# spill size = 64
2188 +  li R11, #-187	# int, #@loadConI
218c    spill R30 -&gt; [sp, #0]	# spill size = 64
2190 +  spill R15 -&gt; [sp, #8]	# spill size = 64
2194 +  spill R12 -&gt; [sp, #16]	# spill size = 32
2198 +  spill R29 -&gt; [sp, #40]	# spill size = 64
219c +  spill R29 -&gt; [sp, #56]	# spill size = 64
21a0 +  spill R7 -&gt; [sp, #64]	# spill size = 64
21a4 +  spill R7 -&gt; [sp, #72]	# spill size = 64
21a8 +  spill R28 -&gt; [sp, #20]	# spill size = 32
21ac    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.Util::followLinks @ bci:27 (line 122) L[0]=_ L[1]=_ L[2]=sp + #8 L[3]=sp + #20 L[4]=sp + #16 L[5]=R8 STK[0]=R8 STK[1]=#Ptr0x00000040d8198650
        # sun.nio.fs.UnixFileSystemProvider::getFileAttributeView @ bci:7 (line 120) L[0]=_ L[1]=_ L[2]=#Ptr0x00000040d838e700 L[3]=_ L[4]=sp + #64 L[5]=_
        # sun.nio.fs.LinuxFileSystemProvider::getFileAttributeView @ bci:48 (line 68) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:51 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #40 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #56 L[1]=sp + #64 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #40 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop off=8624/0x21b0}
21b0    #@ShouldNotReachHere

21bc    B350: #	out( N6588 ) &lt;- in( B29 )  Freq: 2.62896e-07
21bc +  li R11, #-187	# int, #@loadConI
21c0    spill R9 -&gt; [sp, #0]	# spill size = 64
21c4 +  spill R18 -&gt; [sp, #8]	# spill size = 64
21c8 +  spill R24 -&gt; [sp, #16]	# spill size = 64
21cc +  spill R19 -&gt; [sp, #32]	# spill size = 64
21d0 +  spill R19 -&gt; [sp, #40]	# spill size = 64
21d4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream::isOpen @ bci:4 (line 83) L[0]=_ STK[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:39 (line 164) L[0]=sp + #32 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop off=8664/0x21d8}
21d8    #@ShouldNotReachHere

21e4    B351: #	out( N6588 ) &lt;- in( B37 )  Freq: 2.62889e-07
21e4 +  spill [sp, #8] -&gt; R7	# spill size = 64
21e8 +  li R11, #-187	# int, #@loadConI
21ec    spill R7 -&gt; [sp, #0]	# spill size = 64
21f0 +  spill R28 -&gt; [sp, #32]	# spill size = 64
21f4 +  spill R28 -&gt; [sp, #40]	# spill size = 64
21f8 +  spill R12 -&gt; [sp, #80]	# spill size = 64
21fc +  spill R30 -&gt; [sp, #96]	# spill size = 64
2200    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryReleaseShared @ bci:9 (line 417) L[0]=sp + #80 L[1]=_ L[2]=sp + #96 L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #96
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:2 (line 1094) L[0]=sp + #80 L[1]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #32 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop [80]=Oop [96]=Oop off=8708/0x2204}
2204    #@ShouldNotReachHere

2210    B352: #	out( N6588 ) &lt;- in( B38 )  Freq: 2.62889e-07
2210 +  li R11, #-187	# int, #@loadConI
2214    spill [sp, #8] -&gt; R8	# spill size = 64
2218 +  spill R12 -&gt; [sp, #72]	# spill size = 64
221c +  spill R31 -&gt; [sp, #80]	# spill size = 32
2220    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryReleaseShared @ bci:17 (line 419) L[0]=sp + #72 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #80 STK[1]=#1
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:2 (line 1094) L[0]=sp + #72 L[1]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #0 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [72]=Oop off=8740/0x2224}
2224    #@ShouldNotReachHere

2230    B353: #	out( N6588 ) &lt;- in( B41 )  Freq: 2.62889e-07
2230 +  spill [sp, #8] -&gt; R8	# spill size = 64
2234 +  li R11, #-187	# int, #@loadConI
2238    spill R28 -&gt; [sp, #8]	# spill size = 64
223c +  spill R28 -&gt; [sp, #32]	# spill size = 64
2240 +  spill R12 -&gt; [sp, #64]	# spill size = 64
2244 +  spill R10 -&gt; [sp, #72]	# spill size = 32
2248    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryReleaseShared @ bci:134 (line 443) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #72
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:2 (line 1094) L[0]=sp + #64 L[1]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #8 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [48]=Oop [64]=Oop off=8780/0x224c}
224c    #@ShouldNotReachHere

2258    B354: #	out( B40 ) &lt;- in( B226 )  Freq: 2.62882e-07
2258 +  spill R12 -&gt; R19	# spill size = 64
225c    
225c    
225c +  spill R28 -&gt; R9	# spill size = 64
2260    
2260    
2260 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2260    spill R23 -&gt; R11	# spill size = 64
2264 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2294 +  spill R9 -&gt; R28	# spill size = 64
2298 +  spill [sp, #32] -&gt; R30	# spill size = 64
229c +  spill R19 -&gt; R12	# spill size = 64
22a0 +  j  B40	#@branch

22a4    B355: #	out( N6588 ) &lt;- in( B40 )  Freq: 2.5071e-07
22a4 +  spill [sp, #8] -&gt; R7	# spill size = 64
22a8 +  li R11, #-187	# int, #@loadConI
22ac    spill R7 -&gt; [sp, #0]	# spill size = 64
22b0 +  spill R28 -&gt; [sp, #32]	# spill size = 64
22b4 +  spill R28 -&gt; [sp, #40]	# spill size = 64
22b8 +  spill R12 -&gt; [sp, #80]	# spill size = 64
22bc +  spill R10 -&gt; [sp, #88]	# spill size = 32
22c0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryReleaseShared @ bci:129 (line 439) L[0]=sp + #80 L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #88 STK[0]=R8
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:2 (line 1094) L[0]=sp + #80 L[1]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #32 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop [80]=Oop off=8900/0x22c4}
22c4    #@ShouldNotReachHere

22d0    B356: #	out( N6588 ) &lt;- in( B8 )  Freq: 2.4961e-07
22d0 +  li R11, #-187	# int, #@loadConI
22d4    spill R9 -&gt; [sp, #0]	# spill size = 64
22d8 +  spill R18 -&gt; [sp, #8]	# spill size = 64
22dc +  spill R24 -&gt; [sp, #16]	# spill size = 64
22e0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:26 (line 346) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=_ L[6]=_ STK[0]=R8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=8932/0x22e4}
22e4    #@ShouldNotReachHere

22f0    B357: #	out( N6588 ) &lt;- in( B12 )  Freq: 2.49609e-07
22f0 +  li R11, #-187	# int, #@loadConI
22f4    spill R9 -&gt; [sp, #0]	# spill size = 64
22f8 +  spill R18 -&gt; [sp, #8]	# spill size = 64
22fc +  spill R24 -&gt; [sp, #16]	# spill size = 64
2300 +  spill R19 -&gt; [sp, #32]	# spill size = 64
2304 +  spill R19 -&gt; [sp, #40]	# spill size = 64
2308    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:4 (line 197) L[0]=sp + #40 STK[0]=R8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop off=8972/0x230c}
230c    #@ShouldNotReachHere

2318    B358: #	out( N6588 ) &lt;- in( B13 )  Freq: 2.49609e-07
2318 +  li R11, #-187	# int, #@loadConI
231c    spill R9 -&gt; R8	# spill size = 64
2320 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2324 +  spill R24 -&gt; [sp, #8]	# spill size = 64
2328 +  spill R19 -&gt; [sp, #24]	# spill size = 64
232c +  spill R29 -&gt; [sp, #32]	# spill size = 32
2330 +  spill R19 -&gt; [sp, #40]	# spill size = 64
2334    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:11 (line 197) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #24
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #24 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [40]=Oop off=9016/0x2338}
2338    #@ShouldNotReachHere

2344    B359: #	out( N6588 ) &lt;- in( B23 )  Freq: 2.49607e-07
2344 +  li R11, #-187	# int, #@loadConI
2348    spill R9 -&gt; R8	# spill size = 64
234c +  spill R18 -&gt; [sp, #0]	# spill size = 64
2350 +  spill R24 -&gt; [sp, #8]	# spill size = 64
2354 +  spill R19 -&gt; [sp, #24]	# spill size = 64
2358 +  spill R19 -&gt; [sp, #32]	# spill size = 64
235c +  spill R21 -&gt; [sp, #64]	# spill size = 64
2360 +  spill R20 -&gt; [sp, #72]	# spill size = 64
2364 +  spill R31 -&gt; [sp, #80]	# spill size = 32
2368    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:60 (line 478) L[0]=sp + #64 L[1]=_ L[2]=sp + #72 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #80
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #64 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #24 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #24 MON-BOX0=sp+144 MON-OBJ[0]=sp + #24
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #24 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop [64]=Oop [72]=Oop off=9068/0x236c}
236c    #@ShouldNotReachHere

2378    B360: #	out( B25 ) &lt;- in( B229 )  Freq: 2.496e-07
2378 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2378    spill R23 -&gt; R11	# spill size = 64
237c +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
23ac +  j  B25	#@branch

23b0    B361: #	out( B74 ) &lt;- in( B232 )  Freq: 2.49589e-07
23b0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
23b0    spill R23 -&gt; R11	# spill size = 64
23b4 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
23e4 +  j  B74	#@branch

23e8    B362: #	out( B156 ) &lt;- in( B235 )  Freq: 2.4956e-07
23e8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
23e8    spill R23 -&gt; R11	# spill size = 64
23ec +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
241c +  j  B156	#@branch

2420    B363: #	out( N6588 ) &lt;- in( B90 )  Freq: 2.45661e-07
2420 +  li R11, #-138	# int, #@loadConI
2424    spill [sp, #8] -&gt; R8	# spill size = 64
2428 +  spill R15 -&gt; [sp, #0]	# spill size = 64
242c +  spill R7 -&gt; [sp, #48]	# spill size = 64
2430 +  spill R7 -&gt; [sp, #56]	# spill size = 64
2434 +  spill R28 -&gt; [sp, #68]	# spill size = 32
2438    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.Util::followLinks @ bci:13 (line 121) L[0]=_ L[1]=#1 L[2]=sp + #0 L[3]=sp + #68 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=sp + #68
        # sun.nio.fs.UnixFileSystemProvider::getFileAttributeView @ bci:7 (line 120) L[0]=_ L[1]=_ L[2]=#Ptr0x00000040d838e700 L[3]=_ L[4]=sp + #48 L[5]=_
        # sun.nio.fs.LinuxFileSystemProvider::getFileAttributeView @ bci:48 (line 68) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:51 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #48 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop off=9276/0x243c}
243c    #@ShouldNotReachHere

2448    B364: #	out( N6588 ) &lt;- in( B49 )  Freq: 2.42772e-07
2448 +  spill [sp, #8] -&gt; R7	# spill size = 64
244c +  li R11, #-187	# int, #@loadConI
2450    spill R7 -&gt; [sp, #0]	# spill size = 64
2454 +  spill R19 -&gt; [sp, #32]	# spill size = 64
2458 +  spill R19 -&gt; [sp, #40]	# spill size = 64
245c +  spill R22 -&gt; [sp, #64]	# spill size = 64
2460 +  spill R9 -&gt; [sp, #80]	# spill size = 32
2464 +  spill R20 -&gt; [sp, #88]	# spill size = 64
2468    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:10 (line 380) L[0]=sp + #64 L[1]=#ScObj0 L[2]=sp + #88 L[3]=_ STK[0]=sp + #80
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=R8, [path :2]=sp + #88, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #32 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [64]=Oop [88]=Oop off=9324/0x246c}
246c    #@ShouldNotReachHere

2478    B365: #	out( N6588 ) &lt;- in( B52 )  Freq: 2.42772e-07
2478 +  li R11, #-187	# int, #@loadConI
247c    spill [sp, #8] -&gt; R8	# spill size = 64
2480 +  spill R22 -&gt; [sp, #56]	# spill size = 64
2484 +  spill R28 -&gt; [sp, #64]	# spill size = 64
2488 +  spill R20 -&gt; [sp, #72]	# spill size = 64
248c +  spill R9 -&gt; [sp, #84]	# spill size = 32
2490 +  spill R18 -&gt; [sp, #88]	# spill size = 32
2494    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 361) L[0]=sp + #64 L[1]=sp + #72 L[2]=sp + #88 L[3]=sp + #84 L[4]=_ STK[0]=sp + #88
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [56]=Oop [64]=Oop [72]=Oop off=9368/0x2498}
2498    #@ShouldNotReachHere

24a4    B366: #	out( B82 ) &lt;- in( B248 )  Freq: 2.42481e-07
24a4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
24a4    spill R23 -&gt; R11	# spill size = 64
24a8 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
24d8 +  j  B82	#@branch

24dc    B367: #	out( N6588 ) &lt;- in( B117 )  Freq: 2.42393e-07
24dc +  spill [sp, #8] -&gt; R28	# spill size = 64
24e0 +  li R11, #-187	# int, #@loadConI
24e4    spill R28 -&gt; [sp, #0]	# spill size = 64
24e8 +  spill R29 -&gt; [sp, #16]	# spill size = 64
24ec +  spill R29 -&gt; [sp, #40]	# spill size = 64
24f0 +  spill R7 -&gt; [sp, #48]	# spill size = 64
24f4 +  spill R30 -&gt; [sp, #64]	# spill size = 64
24f8 +  spill R7 -&gt; [sp, #72]	# spill size = 64
24fc +  spill R12 -&gt; [sp, #80]	# spill size = 64
2500 +  spill R19 -&gt; [sp, #92]	# spill size = 32
2504 +  spill R18 -&gt; [sp, #96]	# spill size = 64
2508 +  spill R21 -&gt; [sp, #104]	# spill size = 64
250c +  spill R19 -&gt; [sp, #112]	# spill size = 32
2510 +  spill R9 -&gt; [sp, #116]	# spill size = 32
2514    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:34 (line 76) L[0]=sp + #112 L[1]=sp + #96 L[2]=#0 L[3]=sp + #104 STK[0]=R8 STK[1]=sp + #92
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #48 L[1]=sp + #80 L[2]=sp + #92 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #64 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #64
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #116, [file :1]=sp + #48 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #40 L[1]=sp + #48 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [64]=Oop [72]=Oop [80]=Oop [96]=Oop [104]=Oop off=9496/0x2518}
2518    #@ShouldNotReachHere

2524    B368: #	out( B119 ) &lt;- in( B251 )  Freq: 2.42387e-07
2524 +  spill R18 -&gt; R8	# spill size = 64
2528 +  spill R17 -&gt; R18	# spill size = 64
252c    
252c    
252c +  spill R14 -&gt; R26	# spill size = 32
2530    
2530 +  spill R12 -&gt; R24	# spill size = 64
2534    
2534    
2534 +  spill R31 -&gt; [sp, #0]	# spill size = 32
2538    
2538 +  spill R30 -&gt; R22	# spill size = 64
253c    
253c    
253c +  spill R21 -&gt; [sp, #16]	# spill size = 64
2540 +  spill R9 -&gt; R21	# spill size = 32
2544 +  spill R29 -&gt; R9	# spill size = 64
2548    
2548    
2548 +  spill R7 -&gt; R20	# spill size = 64
254c    
254c    
254c +  spill R11 -&gt; R25	# spill size = 32
2554 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2554    spill R23 -&gt; R11	# spill size = 64
2558 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2588 +  spill R9 -&gt; R29	# spill size = 64
258c +  spill R18 -&gt; R17	# spill size = 64
2590 +  spill R21 -&gt; R9	# spill size = 32
2594 +  spill R20 -&gt; R7	# spill size = 64
2598 +  spill R22 -&gt; R30	# spill size = 64
259c +  spill R25 -&gt; R11	# spill size = 32
25a4 +  spill R24 -&gt; R12	# spill size = 64
25a8 +  spill R26 -&gt; R14	# spill size = 32
25ac +  spill R8 -&gt; R18	# spill size = 64
25b0 +  spill [sp, #0] -&gt; R31	# spill size = 32
25b4 +  spill [sp, #16] -&gt; R21	# spill size = 64
25b8 +  j  B119	#@branch

25bc    B369: #	out( N6588 ) &lt;- in( B134 )  Freq: 2.42386e-07
25bc +  spill [sp, #8] -&gt; R7	# spill size = 64
25c0 +  li R11, #-187	# int, #@loadConI
25c4    spill R7 -&gt; [sp, #0]	# spill size = 64
25c8 +  spill R10 -&gt; [sp, #8]	# spill size = 64
25cc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:41 (line 115) L[0]=sp + #56 L[1]=sp + #8 L[2]=#0 L[3]=_ STK[0]=R8
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop off=9680/0x25d0}
25d0    #@ShouldNotReachHere

25dc    B370: #	out( B136 ) &lt;- in( B254 )  Freq: 2.4238e-07
25dc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
25dc    spill R23 -&gt; R11	# spill size = 64
25e0 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2610 +  j  B136	#@branch

2614    B371: #	out( N6588 ) &lt;- in( B19 )  Freq: 2.38044e-07
2614 +  li R11, #-187	# int, #@loadConI
2618    spill R9 -&gt; [sp, #0]	# spill size = 64
261c +  spill R18 -&gt; [sp, #8]	# spill size = 64
2620 +  spill R24 -&gt; [sp, #16]	# spill size = 64
2624 +  spill R19 -&gt; [sp, #32]	# spill size = 64
2628 +  spill R19 -&gt; [sp, #40]	# spill size = 64
262c +  spill R21 -&gt; [sp, #72]	# spill size = 64
2630 +  spill R20 -&gt; [sp, #80]	# spill size = 64
2634 +  spill R30 -&gt; [sp, #88]	# spill size = 32
2638    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:13 (line 471) L[0]=sp + #72 L[1]=_ L[2]=sp + #80 L[3]=sp + #88 L[4]=_ L[5]=_ STK[0]=R8
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #72 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #32 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop [72]=Oop [80]=Oop off=9788/0x263c}
263c    #@ShouldNotReachHere

2648    B372: #	out( N6588 ) &lt;- in( B21 )  Freq: 2.38044e-07
2648 +  li R11, #-187	# int, #@loadConI
264c    spill R9 -&gt; R8	# spill size = 64
2650 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2654 +  spill R24 -&gt; [sp, #8]	# spill size = 64
2658 +  spill R19 -&gt; [sp, #24]	# spill size = 64
265c +  spill R19 -&gt; [sp, #32]	# spill size = 64
2660 +  spill R21 -&gt; [sp, #64]	# spill size = 64
2664 +  spill R20 -&gt; [sp, #72]	# spill size = 64
2668 +  spill R30 -&gt; [sp, #80]	# spill size = 32
266c +  spill R31 -&gt; [sp, #88]	# spill size = 32
2670    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:43 (line 475) L[0]=sp + #64 L[1]=_ L[2]=sp + #72 L[3]=sp + #80 L[4]=sp + #88 L[5]=_ STK[0]=sp + #88 STK[1]=#65535
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #64 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #24 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #24 MON-BOX0=sp+144 MON-OBJ[0]=sp + #24
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #24 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop [64]=Oop [72]=Oop off=9844/0x2674}
2674    #@ShouldNotReachHere

2680    B373: #	out( N6588 ) &lt;- in( B22 )  Freq: 2.38044e-07
2680 +  li R11, #-187	# int, #@loadConI
2684    spill R9 -&gt; [sp, #0]	# spill size = 64
2688 +  spill R18 -&gt; [sp, #8]	# spill size = 64
268c +  spill R24 -&gt; [sp, #16]	# spill size = 64
2690 +  spill R19 -&gt; [sp, #32]	# spill size = 64
2694 +  spill R19 -&gt; [sp, #40]	# spill size = 64
2698 +  spill R21 -&gt; [sp, #72]	# spill size = 64
269c +  spill R20 -&gt; [sp, #80]	# spill size = 64
26a0 +  spill R31 -&gt; [sp, #88]	# spill size = 32
26a4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:55 (line 477) L[0]=sp + #72 L[1]=_ L[2]=sp + #80 L[3]=_ L[4]=sp + #88 L[5]=_ STK[0]=R8
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #72 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #32 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop [72]=Oop [80]=Oop off=9896/0x26a8}
26a8    #@ShouldNotReachHere

26b4    B374: #	out( B121 ) &lt;- in( B261 )  Freq: 2.3581e-07
26b4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
26b4    spill R23 -&gt; R11	# spill size = 64
26b8 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
26e8 +  j  B121	#@branch

26ec    B375: #	out( N6588 ) &lt;- in( B50 )  Freq: 2.31525e-07
26ec +  spill [sp, #8] -&gt; R7	# spill size = 64
26f0 +  li R11, #-187	# int, #@loadConI
26f4    spill R7 -&gt; [sp, #0]	# spill size = 64
26f8 +  spill R19 -&gt; [sp, #32]	# spill size = 64
26fc +  spill R19 -&gt; [sp, #40]	# spill size = 64
2700 +  spill R22 -&gt; [sp, #64]	# spill size = 64
2704 +  spill R29 -&gt; [sp, #80]	# spill size = 32
2708 +  spill R20 -&gt; [sp, #88]	# spill size = 64
270c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:18 (line 380) L[0]=sp + #64 L[1]=#ScObj0 L[2]=sp + #88 L[3]=_ STK[0]=sp + #80 STK[1]=#47
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=R8, [path :2]=sp + #88, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #32 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [64]=Oop [88]=Oop off=10000/0x2710}
2710    #@ShouldNotReachHere

271c    B376: #	out( N6588 ) &lt;- in( B53 )  Freq: 2.31525e-07
271c +  li R11, #-187	# int, #@loadConI
2720    spill [sp, #8] -&gt; R8	# spill size = 64
2724 +  spill R22 -&gt; [sp, #56]	# spill size = 64
2728 +  spill R28 -&gt; [sp, #64]	# spill size = 64
272c +  spill R20 -&gt; [sp, #72]	# spill size = 64
2730 +  spill R9 -&gt; [sp, #84]	# spill size = 32
2734 +  spill R18 -&gt; [sp, #88]	# spill size = 32
2738    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:28 (line 364) L[0]=sp + #64 L[1]=sp + #72 L[2]=sp + #88 L[3]=sp + #84 L[4]=_ STK[0]=sp + #88 STK[1]=#1
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [56]=Oop [64]=Oop [72]=Oop off=10044/0x273c}
273c    #@ShouldNotReachHere

2748    B377: #	out( N6588 ) &lt;- in( B98 )  Freq: 2.31253e-07
2748 +  spill [sp, #8] -&gt; R28	# spill size = 64
274c +  li R11, #-187	# int, #@loadConI
2750    spill R28 -&gt; [sp, #0]	# spill size = 64
2754 +  spill R29 -&gt; [sp, #16]	# spill size = 64
2758 +  spill R29 -&gt; [sp, #40]	# spill size = 64
275c +  spill R7 -&gt; [sp, #48]	# spill size = 64
2760 +  spill R7 -&gt; [sp, #56]	# spill size = 64
2764 +  spill R9 -&gt; [sp, #64]	# spill size = 32
2768    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.System::allowSecurityManager @ bci:4 (line 193) STK[0]=R8 STK[1]=#1
        # java.lang.System::getSecurityManager @ bci:0 (line 483)
        # sun.nio.fs.UnixPath::checkRead @ bci:0 (line 778) L[0]=sp + #48 L[1]=_
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:4 (line 49) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #48 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #40 L[1]=sp + #48 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop off=10092/0x276c}
276c    #@ShouldNotReachHere

2778    B378: #	out( N6588 ) &lt;- in( B99 )  Freq: 2.31252e-07
2778 +  spill [sp, #8] -&gt; R28	# spill size = 64
277c +  li R11, #-187	# int, #@loadConI
2780    spill R28 -&gt; [sp, #0]	# spill size = 64
2784 +  spill R29 -&gt; [sp, #16]	# spill size = 64
2788 +  spill R29 -&gt; [sp, #40]	# spill size = 64
278c +  spill R7 -&gt; [sp, #48]	# spill size = 64
2790 +  spill R7 -&gt; [sp, #56]	# spill size = 64
2794 +  spill R9 -&gt; [sp, #64]	# spill size = 32
2798    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::checkRead @ bci:5 (line 779) L[0]=sp + #48 L[1]=R8 STK[0]=R8
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:4 (line 49) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #48 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #40 L[1]=sp + #48 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop off=10140/0x279c}
279c    #@ShouldNotReachHere

27a8    B379: #	out( N6588 ) &lt;- in( B142 )  Freq: 2.31243e-07
27a8 +  spill [sp, #8] -&gt; R7	# spill size = 64
27ac +  li R11, #-187	# int, #@loadConI
27b0    spill R7 -&gt; [sp, #0]	# spill size = 64
27b4 +  spill R12 -&gt; [sp, #32]	# spill size = 64
27b8 +  spill R28 -&gt; [sp, #48]	# spill size = 32
27bc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:53 (line 288) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ STK[0]=R8 STK[1]=sp + #48
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=10176/0x27c0}
27c0    #@ShouldNotReachHere

27cc    B380: #	out( N6588 ) &lt;- in( B104 )  Freq: 2.31166e-07
27cc +  spill [sp, #8] -&gt; R8	# spill size = 64
27d0 +  li R11, #-187	# int, #@loadConI
27d4    spill R29 -&gt; [sp, #8]	# spill size = 64
27d8 +  spill R29 -&gt; [sp, #32]	# spill size = 64
27dc +  spill R7 -&gt; [sp, #40]	# spill size = 64
27e0 +  spill R30 -&gt; [sp, #56]	# spill size = 64
27e4 +  spill R7 -&gt; [sp, #64]	# spill size = 64
27e8 +  spill R31 -&gt; [sp, #80]	# spill size = 32
27ec +  spill R9 -&gt; [sp, #84]	# spill size = 32
27f0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getByteArrayForSysCalls @ bci:7 (line 135) L[0]=sp + #40 L[1]=_ STK[0]=sp + #80
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:1 (line 37) L[0]=sp + #40 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #84, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=10228/0x27f4}
27f4    #@ShouldNotReachHere

2800    B381: #	out( N6588 ) &lt;- in( B106 )  Freq: 2.31166e-07
2800 +  spill [sp, #8] -&gt; R8	# spill size = 64
2804 +  li R11, #-187	# int, #@loadConI
2808    spill R29 -&gt; [sp, #8]	# spill size = 64
280c +  spill R29 -&gt; [sp, #32]	# spill size = 64
2810 +  spill R7 -&gt; [sp, #40]	# spill size = 64
2814 +  spill R30 -&gt; [sp, #56]	# spill size = 64
2818 +  spill R7 -&gt; [sp, #64]	# spill size = 64
281c +  spill R14 -&gt; [sp, #80]	# spill size = 32
2820 +  spill R9 -&gt; [sp, #84]	# spill size = 32
2824    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::isEmpty @ bci:5 (line 216) L[0]=_ STK[0]=sp + #80
        # sun.nio.fs.UnixPath::getByteArrayForSysCalls @ bci:26 (line 138) L[0]=sp + #40 L[1]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:1 (line 37) L[0]=sp + #40 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #84, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=10280/0x2828}
2828    #@ShouldNotReachHere

2834    B382: #	out( N6588 ) &lt;- in( B170 )  Freq: 2.65685e-08
2834 +  spill [sp, #8] -&gt; R7	# spill size = 64
2838 +  li R11, #-34	# int, #@loadConI
283c    spill R7 -&gt; [sp, #0]	# spill size = 64
2840 +  spill R19 -&gt; [sp, #32]	# spill size = 64
2844 +  spill R19 -&gt; [sp, #40]	# spill size = 64
2848    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #32 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=10316/0x284c}
284c    #@ShouldNotReachHere

2858    B383: #	out( N6588 ) &lt;- in( B173 )  Freq: 2.65684e-08
2858 +  spill [sp, #8] -&gt; R7	# spill size = 64
285c +  li R11, #-20	# int, #@loadConI
2860    spill R7 -&gt; [sp, #0]	# spill size = 64
2864 +  spill R19 -&gt; [sp, #40]	# spill size = 64
2868 +  spill R19 -&gt; [sp, #48]	# spill size = 64
286c +  spill R30 -&gt; [sp, #80]	# spill size = 64
2870 +  spill R10 -&gt; [sp, #88]	# spill size = 32
2874 +  spill R31 -&gt; [sp, #92]	# spill size = 32
2878 +  spill R30 -&gt; [sp, #96]	# spill size = 64
287c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_assert&apos; action=&apos;make_not_entrant&apos;)
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::hasQueuedPredecessors @ bci:6 (line 1234) L[0]=sp + #80 L[1]=#NULL L[2]=_ L[3]=_ STK[0]=R8
        # java.util.concurrent.locks.ReentrantReadWriteLock$FairSync::readerShouldBlock @ bci:1 (line 706) L[0]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:33 (line 475) L[0]=sp + #96 L[1]=_ L[2]=sp + #32 L[3]=sp + #88 L[4]=sp + #92 L[5]=_
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #80 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #40 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #48 STK[0]=sp + #40 MON-BOX0=sp+144 MON-OBJ[0]=sp + #40
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #40 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop [80]=Oop [96]=Oop off=10368/0x2880}
2880    #@ShouldNotReachHere

288c    B384: #	out( N6588 ) &lt;- in( B181 )  Freq: 1.4892e-08
288c +  li R11, #-10	# int, #@loadConI
2890    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:57 (line 94) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # OopMap {off=10388/0x2894}
2894    #@ShouldNotReachHere

28a0    B385: #	out( N6588 ) &lt;- in( B188 )  Freq: 1.44048e-08
28a0 +  li R11, #-10	# int, #@loadConI
28a4    spill [sp, #8] -&gt; R8	# spill size = 64
28a8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:109 (line 369) L[0]=_ L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_ STK[0]=#NULL
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop off=10412/0x28ac}
28ac    #@ShouldNotReachHere

28b8    B386: #	out( N6588 ) &lt;- in( B186 )  Freq: 1.42163e-08
28b8 +  spill [sp, #8] -&gt; R8	# spill size = 64
28bc +  li R11, #-34	# int, #@loadConI
28c0    spill R30 -&gt; [sp, #8]	# spill size = 64
28c4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:76 (line 361) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_ STK[0]=sp + #8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop off=10440/0x28c8}
28c8    #@ShouldNotReachHere

28d4    B387: #	out( N6588 ) &lt;- in( B218 )  Freq: 1.372e-08
28d4 +  spill [sp, #8] -&gt; R8	# spill size = 64
28d8 +  li R11, #-10	# int, #@loadConI
28dc    spill R18 -&gt; [sp, #8]	# spill size = 64
28e0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:187 (line 311) L[0]=_ L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ STK[0]=#NULL STK[1]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=10468/0x28e4}
28e4    #@ShouldNotReachHere

28f0    B388: #	out( N6588 ) &lt;- in( B176 )  Freq: 1.32842e-08
28f0 +  li R11, #-187	# int, #@loadConI
28f4    spill [sp, #8] -&gt; R8	# spill size = 64
28f8 +  spill R30 -&gt; [sp, #72]	# spill size = 64
28fc +  spill R31 -&gt; [sp, #80]	# spill size = 32
2900    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:60 (line 478) L[0]=sp + #72 L[1]=_ L[2]=sp + #32 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #80
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #72 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [72]=Oop off=10500/0x2904}
2904    #@ShouldNotReachHere

2910    B389: #	out( B178 ) &lt;- in( B281 )  Freq: 1.32838e-08
2910 +  spill R30 -&gt; R18	# spill size = 64
2914    
2914    
2914 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2914    spill R23 -&gt; R11	# spill size = 64
2918 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2948 +  spill R18 -&gt; R30	# spill size = 64
294c +  j  B178	#@branch

2950    B390: #	out( N6588 ) &lt;- in( B172 )  Freq: 1.26688e-08
2950 +  spill [sp, #8] -&gt; R7	# spill size = 64
2954 +  li R11, #-187	# int, #@loadConI
2958    spill R7 -&gt; [sp, #0]	# spill size = 64
295c +  spill R19 -&gt; [sp, #40]	# spill size = 64
2960 +  spill R19 -&gt; [sp, #48]	# spill size = 64
2964 +  spill R30 -&gt; [sp, #80]	# spill size = 64
2968 +  spill R10 -&gt; [sp, #88]	# spill size = 32
296c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:13 (line 471) L[0]=sp + #80 L[1]=_ L[2]=sp + #32 L[3]=sp + #88 L[4]=_ L[5]=_ STK[0]=R8
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #80 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #40 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #48 STK[0]=sp + #40 MON-BOX0=sp+144 MON-OBJ[0]=sp + #40
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #40 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop [80]=Oop off=10608/0x2970}
2970    #@ShouldNotReachHere

297c    B391: #	out( N6588 ) &lt;- in( B174 )  Freq: 1.26688e-08
297c +  li R11, #-187	# int, #@loadConI
2980    spill [sp, #8] -&gt; R8	# spill size = 64
2984 +  spill R30 -&gt; [sp, #72]	# spill size = 64
2988 +  spill R10 -&gt; [sp, #80]	# spill size = 32
298c +  spill R31 -&gt; [sp, #88]	# spill size = 32
2990    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:43 (line 475) L[0]=sp + #72 L[1]=_ L[2]=sp + #32 L[3]=sp + #80 L[4]=sp + #88 L[5]=_ STK[0]=sp + #88 STK[1]=#65535
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #72 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [72]=Oop off=10644/0x2994}
2994    #@ShouldNotReachHere

29a0    B392: #	out( N6588 ) &lt;- in( B175 )  Freq: 1.26688e-08
29a0 +  spill [sp, #8] -&gt; R7	# spill size = 64
29a4 +  li R11, #-187	# int, #@loadConI
29a8    spill R7 -&gt; [sp, #0]	# spill size = 64
29ac +  spill R19 -&gt; [sp, #40]	# spill size = 64
29b0 +  spill R19 -&gt; [sp, #48]	# spill size = 64
29b4 +  spill R30 -&gt; [sp, #80]	# spill size = 64
29b8 +  spill R31 -&gt; [sp, #88]	# spill size = 32
29bc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:55 (line 477) L[0]=sp + #80 L[1]=_ L[2]=sp + #32 L[3]=_ L[4]=sp + #88 L[5]=_ STK[0]=R8
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #80 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #40 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #48 STK[0]=sp + #40 MON-BOX0=sp+144 MON-OBJ[0]=sp + #40
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #40 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop [80]=Oop off=10688/0x29c0}
29c0    #@ShouldNotReachHere

29cc    B393: #	out( B202 ) &lt;- in( B288 )  Freq: 6.77008e-09
29cc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
29cc    spill R23 -&gt; R11	# spill size = 64
29d0 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2a00 +  j  B202	#@branch

2a04    B394: #	out( B205 ) &lt;- in( B291 )  Freq: 6.77008e-09
2a04 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2a04    spill R23 -&gt; R11	# spill size = 64
2a08 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2a38 +  j  B205	#@branch

2a3c    B395: #	out( B209 ) &lt;- in( B294 )  Freq: 6.77008e-09
2a3c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2a3c    spill R23 -&gt; R11	# spill size = 64
2a40 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2a70 +  j  B209	#@branch

2a74    B396: #	out( B215 ) &lt;- in( B297 )  Freq: 6.76995e-09
2a74 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2a74    spill R23 -&gt; R11	# spill size = 64
2a78 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2aa8 +  j  B215	#@branch

2aac    B397: #	out( N6588 ) &lt;- in( B164 )  Freq: 6.64215e-09
2aac +  li R11, #-187	# int, #@loadConI
2ab0    spill [sp, #8] -&gt; R8	# spill size = 64
2ab4 +  spill R20 -&gt; [sp, #64]	# spill size = 64
2ab8 +  spill R9 -&gt; [sp, #72]	# spill size = 32
2abc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::isSelfOrParent @ bci:17 (line 146) L[0]=_ L[1]=sp + #64 STK[0]=sp + #72 STK[1]=#2
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:123 (line 181) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [64]=Oop off=10944/0x2ac0}
2ac0    #@ShouldNotReachHere

2acc    B398: #	out( N6588 ) &lt;- in( B195 )  Freq: 6.45688e-09
2acc +  spill [sp, #8] -&gt; R7	# spill size = 64
2ad0 +  li R11, #-187	# int, #@loadConI
2ad4    spill R7 -&gt; [sp, #0]	# spill size = 64
2ad8 +  spill R30 -&gt; [sp, #32]	# spill size = 64
2adc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:84 (line 293) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ STK[0]=R8
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=10976/0x2ae0}
2ae0    #@ShouldNotReachHere

2aec    B399: #	out( N6588 ) &lt;- in( B7 )  Freq: 1e-35
2aec +  li R11, #-34	# int, #@loadConI
2af0    spill R9 -&gt; R8	# spill size = 64
2af4 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2af8 +  spill R24 -&gt; [sp, #8]	# spill size = 64
2afc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:7 (line 335) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=sp + #8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=11008/0x2b00}
2b00    #@ShouldNotReachHere

2b0c    B400: #	out( N6588 ) &lt;- in( B83 )  Freq: 1e-35
2b0c +  li R11, #-34	# int, #@loadConI
2b10    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:52 (line 350) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=_ L[6]=_ STK[0]=R8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop off=11028/0x2b14}
2b14    #@ShouldNotReachHere

2b20    B401: #	out( N6588 ) &lt;- in( B114 )  Freq: 1e-35
2b20 +  spill [sp, #8] -&gt; R8	# spill size = 64
2b24 +  li R11, #-34	# int, #@loadConI
2b28    spill R29 -&gt; [sp, #8]	# spill size = 64
2b2c +  spill R29 -&gt; [sp, #32]	# spill size = 64
2b30 +  spill R7 -&gt; [sp, #40]	# spill size = 64
2b34 +  spill R30 -&gt; [sp, #56]	# spill size = 64
2b38 +  spill R7 -&gt; [sp, #64]	# spill size = 64
2b3c +  spill R12 -&gt; [sp, #72]	# spill size = 64
2b40 +  spill R19 -&gt; [sp, #84]	# spill size = 32
2b44 +  spill R18 -&gt; [sp, #88]	# spill size = 64
2b48 +  spill R9 -&gt; [sp, #96]	# spill size = 32
2b4c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:6 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #88
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #40 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #96, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [88]=Oop off=11088/0x2b50}
2b50    #@ShouldNotReachHere

2b5c    B402: #	out( N6588 ) &lt;- in( B132 )  Freq: 1e-35
2b5c +  li R11, #-34	# int, #@loadConI
2b60    spill [sp, #8] -&gt; R8	# spill size = 64
2b64 +  spill R10 -&gt; [sp, #0]	# spill size = 64
2b68    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:6 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #0
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop off=11116/0x2b6c}
2b6c    #@ShouldNotReachHere

2b78    B403: #	out( B451 B501 B452 ) &lt;- in( B31 )  Freq: 5.25791e-06
2b78     -- 	// exception oop; no code emitted, #@CreateException
2b78 +  spill [sp, #0] -&gt; R28	# spill size = 64
2b7c +  lwu  R28, [R28, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
2b80 +  decode_heap_oop  R28, R28	#@decodeHeapOop
2b84    spill R28 -&gt; R8	# spill size = 64
2b88 +  spill R10 -&gt; R11	# spill size = 64
2b8c    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:52 (line 165) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=11152/0x2b90}

2b90    B404: #	out( N6588 ) &lt;- in( B28 )  Freq: 5.32774e-07
2b90 +  li R11, #-10	# int, #@loadConI
2b94    spill R9 -&gt; R8	# spill size = 64
2b98 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2b9c +  spill R24 -&gt; [sp, #8]	# spill size = 64
2ba0 +  spill R19 -&gt; [sp, #24]	# spill size = 64
2ba4 +  spill R19 -&gt; [sp, #32]	# spill size = 64
2ba8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:39 (line 164) L[0]=sp + #24 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #24 MON-BOX0=sp+144 MON-OBJ[0]=sp + #24
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #24 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop off=11180/0x2bac}
2bac    #@ShouldNotReachHere

2bb8    B405: #	out( N6588 ) &lt;- in( B30 )  Freq: 5.32774e-07
2bb8 +  li R11, #-10	# int, #@loadConI
2bbc    spill R9 -&gt; R8	# spill size = 64
2bc0 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2bc4 +  spill R24 -&gt; [sp, #8]	# spill size = 64
2bc8 +  spill R19 -&gt; [sp, #24]	# spill size = 64
2bcc +  spill R19 -&gt; [sp, #32]	# spill size = 64
2bd0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:49 (line 165) L[0]=sp + #24 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #24 MON-BOX0=sp+144 MON-OBJ[0]=sp + #24
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #24 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop off=11220/0x2bd4}
2bd4    #@ShouldNotReachHere

2be0    B406: #	out( N6588 ) &lt;- in( B32 )  Freq: 5.32762e-07
2be0 +  li R11, #-10	# int, #@loadConI
2be4    spill [sp, #8] -&gt; R8	# spill size = 64
2be8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:60 (line 171) L[0]=sp + #0 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop off=11244/0x2bec}
2bec    #@ShouldNotReachHere

2bf8    B407: #	out( N6588 ) &lt;- in( B33 )  Freq: 5.32762e-07
2bf8 +  li R11, #-10	# int, #@loadConI
2bfc    spill [sp, #8] -&gt; R8	# spill size = 64
2c00    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream::readLock @ bci:4 (line 75) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:60 (line 171) L[0]=sp + #0 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop off=11268/0x2c04}
2c04    #@ShouldNotReachHere

2c10    B408: #	out( N6588 ) &lt;- in( B34 )  Freq: 5.32761e-07
2c10 +  li R11, #-10	# int, #@loadConI
2c14    spill [sp, #8] -&gt; R8	# spill size = 64
2c18    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #0 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop off=11292/0x2c1c}
2c1c    #@ShouldNotReachHere

2c28    B409: #	out( N6588 ) &lt;- in( B36 )  Freq: 5.3276e-07
2c28 +  li R11, #-10	# int, #@loadConI
2c2c    spill [sp, #8] -&gt; R8	# spill size = 64
2c30    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_ STK[0]=#NULL STK[1]=#1
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #0 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop off=11316/0x2c34}
2c34    #@ShouldNotReachHere

2c40    B410: #	out( N6588 ) &lt;- in( B2 )  Freq: 5.06357e-07
2c40 +  li R11, #-10	# int, #@loadConI
2c44    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # OopMap {off=11336/0x2c48}
2c48    #@ShouldNotReachHere

2c54    B411: #	out( N6588 ) &lt;- in( B3 )  Freq: 5.06356e-07
2c54 +  li R11, #-10	# int, #@loadConI
2c58    spill R9 -&gt; R8	# spill size = 64
2c5c +  spill R18 -&gt; [sp, #0]	# spill size = 64
2c60    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:4 (line 335) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=#NULL
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop off=11364/0x2c64}
2c64    #@ShouldNotReachHere

2c70    B412: #	out( N6588 ) &lt;- in( B4 )  Freq: 5.06356e-07
2c70 +  li R11, #-10	# int, #@loadConI
2c74    spill R9 -&gt; R8	# spill size = 64
2c78 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2c7c +  spill R30 -&gt; [sp, #8]	# spill size = 32
2c80    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ArrayDeque::elementAt @ bci:2 (line 259) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=sp + #8
        # java.util.ArrayDeque::peekFirst @ bci:8 (line 418) L[0]=_
        # java.util.ArrayDeque::peek @ bci:1 (line 564) L[0]=_
        # java.nio.file.FileTreeWalker::next @ bci:4 (line 335) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop off=11396/0x2c84}
2c84    #@ShouldNotReachHere

2c90    B413: #	out( N6588 ) &lt;- in( B9 )  Freq: 5.05848e-07
2c90 +  li R11, #-10	# int, #@loadConI
2c94    spill R9 -&gt; R8	# spill size = 64
2c98 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2c9c +  spill R24 -&gt; [sp, #8]	# spill size = 64
2ca0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=#NULL L[6]=_ STK[0]=#NULL
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=11428/0x2ca4}
2ca4    #@ShouldNotReachHere

2cb0    B414: #	out( N6588 ) &lt;- in( B14 )  Freq: 5.05847e-07
2cb0 +  li R11, #-10	# int, #@loadConI
2cb4    spill R9 -&gt; R8	# spill size = 64
2cb8 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2cbc +  spill R24 -&gt; [sp, #8]	# spill size = 64
2cc0 +  spill R19 -&gt; [sp, #24]	# spill size = 64
2cc4 +  spill R19 -&gt; [sp, #32]	# spill size = 64
2cc8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:27 (line 162) L[0]=sp + #24 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #24 MON-BOX0=sp+144 MON-OBJ[0]=sp + #24
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #24 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop off=11468/0x2ccc}
2ccc    #@ShouldNotReachHere

2cd8    B415: #	out( N6588 ) &lt;- in( B15 )  Freq: 5.05846e-07
2cd8 +  li R11, #-10	# int, #@loadConI
2cdc    spill R9 -&gt; R8	# spill size = 64
2ce0 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2ce4 +  spill R24 -&gt; [sp, #8]	# spill size = 64
2ce8 +  spill R19 -&gt; [sp, #24]	# spill size = 64
2cec +  spill R19 -&gt; [sp, #32]	# spill size = 64
2cf0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream::readLock @ bci:4 (line 75) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:27 (line 162) L[0]=sp + #24 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #24 MON-BOX0=sp+144 MON-OBJ[0]=sp + #24
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #24 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop off=11508/0x2cf4}
2cf4    #@ShouldNotReachHere

2d00    B416: #	out( N6588 ) &lt;- in( B16 )  Freq: 5.05846e-07
2d00 +  li R11, #-10	# int, #@loadConI
2d04    spill R9 -&gt; R8	# spill size = 64
2d08 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2d0c +  spill R24 -&gt; [sp, #8]	# spill size = 64
2d10 +  spill R19 -&gt; [sp, #24]	# spill size = 64
2d14 +  spill R19 -&gt; [sp, #32]	# spill size = 64
2d18    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #24 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #24 MON-BOX0=sp+144 MON-OBJ[0]=sp + #24
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #24 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop off=11548/0x2d1c}
2d1c    #@ShouldNotReachHere

2d28    B417: #	out( N6588 ) &lt;- in( B18 )  Freq: 5.05844e-07
2d28 +  li R11, #-10	# int, #@loadConI
2d2c    spill R9 -&gt; R8	# spill size = 64
2d30 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2d34 +  spill R24 -&gt; [sp, #8]	# spill size = 64
2d38 +  spill R19 -&gt; [sp, #24]	# spill size = 64
2d3c +  spill R19 -&gt; [sp, #32]	# spill size = 64
2d40    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_ STK[0]=#NULL STK[1]=#1
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #24 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #24 MON-BOX0=sp+144 MON-OBJ[0]=sp + #24
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #24 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop off=11588/0x2d44}
2d44    #@ShouldNotReachHere

2d50    B418: #	out( N6588 ) &lt;- in( B47 )  Freq: 4.91993e-07
2d50 +  li R11, #-10	# int, #@loadConI
2d54    spill [sp, #8] -&gt; R8	# spill size = 64
2d58 +  spill R20 -&gt; [sp, #56]	# spill size = 64
2d5c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:133 (line 182) L[0]=sp + #0 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [56]=Oop off=11616/0x2d60}
2d60    #@ShouldNotReachHere

2d6c    B419: #	out( N6588 ) &lt;- in( B48 )  Freq: 4.91992e-07
2d6c +  li R11, #-10	# int, #@loadConI
2d70    spill [sp, #8] -&gt; R8	# spill size = 64
2d74 +  spill R20 -&gt; [sp, #56]	# spill size = 64
2d78    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=sp + #56
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [56]=Oop off=11644/0x2d7c}
2d7c    #@ShouldNotReachHere

2d88    B420: #	out( N6588 ) &lt;- in( B51 )  Freq: 4.91991e-07
2d88 +  li R11, #-10	# int, #@loadConI
2d8c    spill [sp, #8] -&gt; R8	# spill size = 64
2d90    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:1 (line 357) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=11668/0x2d94}
2d94    #@ShouldNotReachHere

2da0    B421: #	out( N6588 ) &lt;- in( B69 )  Freq: 4.91989e-07
2da0 +  spill [sp, #8] -&gt; R8	# spill size = 64
2da4 +  li R11, #-10	# int, #@loadConI
2da8    spill R19 -&gt; [sp, #8]	# spill size = 64
2dac +  spill R19 -&gt; [sp, #32]	# spill size = 64
2db0 +  spill R18 -&gt; [sp, #56]	# spill size = 64
2db4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:145 (line 186) L[0]=sp + #8 L[1]=_ L[2]=sp + #56 L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [56]=Oop off=11704/0x2db8}
2db8    #@ShouldNotReachHere

2dc4    B422: #	out( N6588 ) &lt;- in( B86 )  Freq: 4.91414e-07
2dc4 +  spill [sp, #8] -&gt; R8	# spill size = 64
2dc8 +  li R11, #-10	# int, #@loadConI
2dcc    spill R29 -&gt; [sp, #8]	# spill size = 64
2dd0 +  spill R29 -&gt; [sp, #32]	# spill size = 64
2dd4 +  spill R7 -&gt; [sp, #40]	# spill size = 64
2dd8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::provider @ bci:6 (line 105) L[0]=_ STK[0]=#NULL
        # java.nio.file.Files::readAttributes @ bci:1 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop off=11740/0x2ddc}
2ddc    #@ShouldNotReachHere

2de8    B423: #	out( N6588 ) &lt;- in( B88 )  Freq: 4.91413e-07
2de8 +  spill [sp, #8] -&gt; R8	# spill size = 64
2dec +  li R11, #-10	# int, #@loadConI
2df0    spill R29 -&gt; [sp, #8]	# spill size = 64
2df4 +  spill R29 -&gt; [sp, #32]	# spill size = 64
2df8 +  spill R7 -&gt; [sp, #40]	# spill size = 64
2dfc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.Util::followLinks @ bci:5 (line 121) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # sun.nio.fs.UnixFileSystemProvider::getFileAttributeView @ bci:7 (line 120) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # sun.nio.fs.LinuxFileSystemProvider::getFileAttributeView @ bci:48 (line 68) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:51 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop off=11776/0x2e00}
2e00    #@ShouldNotReachHere

2e0c    B424: #	out( N6588 ) &lt;- in( B140 )  Freq: 4.91392e-07
2e0c +  spill [sp, #8] -&gt; R8	# spill size = 64
2e10 +  spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
2e18 +  li R11, #-10	# int, #@loadConI
2e1c    spill R12 -&gt; [sp, #16]	# spill size = 64
2e20    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:42 (line 287) L[0]=sp + #8 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=sp + #16 L[5]=_ L[6]=_ L[7]=_ STK[0]=#NULL
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop off=11812/0x2e24}
2e24    #@ShouldNotReachHere

2e30    B425: #	out( N6588 ) &lt;- in( B141 )  Freq: 4.91392e-07
2e30 +  spill [sp, #8] -&gt; R8	# spill size = 64
2e34 +  spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
2e3c +  li R11, #-10	# int, #@loadConI
2e40    spill R12 -&gt; [sp, #16]	# spill size = 64
2e44    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ArrayDeque::size @ bci:12 (line 649) L[0]=_ STK[0]=_ STK[1]=_ STK[2]=#NULL
        # java.nio.file.FileTreeWalker::visit @ bci:42 (line 287) L[0]=sp + #8 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=sp + #16 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop off=11848/0x2e48}
2e48    #@ShouldNotReachHere

2e54    B426: #	out( N6588 ) &lt;- in( B144 )  Freq: 4.91391e-07
2e54 +  spill [sp, #8] -&gt; R8	# spill size = 64
2e58 +  spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
2e60 +  li R11, #-10	# int, #@loadConI
2e64    spill R30 -&gt; [sp, #16]	# spill size = 64
2e68    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes::isDirectory @ bci:4 (line 299) L[0]=_ STK[0]=#NULL
        # java.nio.file.FileTreeWalker::visit @ bci:58 (line 288) L[0]=sp + #8 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=sp + #16 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop off=11884/0x2e6c}
2e6c    #@ShouldNotReachHere

2e78    B427: #	out( N6588 ) &lt;- in( B103 )  Freq: 4.91229e-07
2e78 +  spill [sp, #8] -&gt; R8	# spill size = 64
2e7c +  li R11, #-10	# int, #@loadConI
2e80    spill R29 -&gt; [sp, #8]	# spill size = 64
2e84 +  spill R29 -&gt; [sp, #32]	# spill size = 64
2e88 +  spill R7 -&gt; [sp, #40]	# spill size = 64
2e8c +  spill R30 -&gt; [sp, #56]	# spill size = 64
2e90 +  spill R9 -&gt; [sp, #64]	# spill size = 32
2e94 +  spill R7 -&gt; [sp, #72]	# spill size = 64
2e98    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getByteArrayForSysCalls @ bci:4 (line 135) L[0]=_ L[1]=_ STK[0]=#NULL
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:1 (line 37) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [72]=Oop off=11932/0x2e9c}
2e9c    #@ShouldNotReachHere

2ea8    B428: #	out( N6588 ) &lt;- in( B105 )  Freq: 4.91228e-07
2ea8 +  spill [sp, #8] -&gt; R8	# spill size = 64
2eac +  li R11, #-10	# int, #@loadConI
2eb0    spill R29 -&gt; [sp, #8]	# spill size = 64
2eb4 +  spill R29 -&gt; [sp, #32]	# spill size = 64
2eb8 +  spill R7 -&gt; [sp, #40]	# spill size = 64
2ebc +  spill R30 -&gt; [sp, #56]	# spill size = 64
2ec0 +  spill R9 -&gt; [sp, #64]	# spill size = 32
2ec4 +  spill R7 -&gt; [sp, #72]	# spill size = 64
2ec8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::isEmpty @ bci:4 (line 216) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::getByteArrayForSysCalls @ bci:26 (line 138) L[0]=_ L[1]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:1 (line 37) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [72]=Oop off=11980/0x2ecc}
2ecc    #@ShouldNotReachHere

2ed8    B429: #	out( N6588 ) &lt;- in( B107 )  Freq: 4.91227e-07
2ed8 +  spill [sp, #8] -&gt; R8	# spill size = 64
2edc +  li R11, #-10	# int, #@loadConI
2ee0    spill R29 -&gt; [sp, #8]	# spill size = 64
2ee4 +  spill R29 -&gt; [sp, #32]	# spill size = 64
2ee8 +  spill R7 -&gt; [sp, #40]	# spill size = 64
2eec +  spill R30 -&gt; [sp, #56]	# spill size = 64
2ef0 +  spill R9 -&gt; [sp, #64]	# spill size = 32
2ef4 +  spill R7 -&gt; [sp, #72]	# spill size = 64
2ef8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [72]=Oop off=12028/0x2efc}
2efc    #@ShouldNotReachHere

2f08    B430: #	out( N6588 ) &lt;- in( B109 )  Freq: 4.91226e-07
2f08 +  spill [sp, #8] -&gt; R8	# spill size = 64
2f0c +  li R11, #-10	# int, #@loadConI
2f10    spill R29 -&gt; [sp, #8]	# spill size = 64
2f14 +  spill R29 -&gt; [sp, #32]	# spill size = 64
2f18 +  spill R7 -&gt; [sp, #40]	# spill size = 64
2f1c +  spill R30 -&gt; [sp, #56]	# spill size = 64
2f20 +  spill R9 -&gt; [sp, #64]	# spill size = 32
2f24 +  spill R7 -&gt; [sp, #72]	# spill size = 64
2f28    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:8 (line 434) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [72]=Oop off=12076/0x2f2c}
2f2c    #@ShouldNotReachHere

2f38    B431: #	out( N6588 ) &lt;- in( B113 )  Freq: 4.91225e-07
2f38 +  spill [sp, #8] -&gt; R8	# spill size = 64
2f3c +  li R11, #-12	# int, #@loadConI
2f40    spill R29 -&gt; [sp, #8]	# spill size = 64
2f44 +  spill R29 -&gt; [sp, #32]	# spill size = 64
2f48 +  spill R7 -&gt; [sp, #40]	# spill size = 64
2f4c +  spill R30 -&gt; [sp, #56]	# spill size = 64
2f50 +  spill R7 -&gt; [sp, #64]	# spill size = 64
2f54 +  spill R12 -&gt; [sp, #72]	# spill size = 64
2f58 +  spill R19 -&gt; [sp, #84]	# spill size = 32
2f5c +  spill R9 -&gt; [sp, #88]	# spill size = 32
2f60    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:6 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #40 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #88, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop off=12132/0x2f64}
2f64    #@ShouldNotReachHere

2f70    B432: #	out( N6588 ) &lt;- in( B125 )  Freq: 4.91213e-07
2f70 +  li R11, #-10	# int, #@loadConI
2f74    spill [sp, #8] -&gt; R8	# spill size = 64
2f78    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=12156/0x2f7c}
2f7c    #@ShouldNotReachHere

2f88    B433: #	out( N6588 ) &lt;- in( B127 )  Freq: 4.91213e-07
2f88 +  li R11, #-10	# int, #@loadConI
2f8c    spill [sp, #8] -&gt; R8	# spill size = 64
2f90    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:8 (line 434) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=12180/0x2f94}
2f94    #@ShouldNotReachHere

2fa0    B434: #	out( N6588 ) &lt;- in( B131 )  Freq: 4.91211e-07
2fa0 +  li R11, #-12	# int, #@loadConI
2fa4    spill [sp, #8] -&gt; R8	# spill size = 64
2fa8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:6 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop off=12204/0x2fac}
2fac    #@ShouldNotReachHere

2fb8    B435: #	out( N6588 ) &lt;- in( B70 )  Freq: 2.31524e-07
2fb8 +  spill [sp, #8] -&gt; R7	# spill size = 64
2fbc +  li R11, #-187	# int, #@loadConI
2fc0    spill R7 -&gt; [sp, #0]	# spill size = 64
2fc4 +  spill R19 -&gt; [sp, #32]	# spill size = 64
2fc8 +  spill R19 -&gt; [sp, #40]	# spill size = 64
2fcc +  spill R18 -&gt; [sp, #64]	# spill size = 64
2fd0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:148 (line 186) L[0]=sp + #32 L[1]=_ L[2]=sp + #64 L[3]=_ L[4]=_ STK[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [64]=Oop off=12244/0x2fd4}
2fd4    #@ShouldNotReachHere

2fe0    B436: #	out( N6588 ) &lt;- in( B80 )  Freq: 2.31254e-07
2fe0 +  spill [sp, #8] -&gt; R7	# spill size = 64
2fe4 +  li R11, #-187	# int, #@loadConI
2fe8    spill R7 -&gt; [sp, #0]	# spill size = 64
2fec +  spill R19 -&gt; [sp, #32]	# spill size = 64
2ff0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::next @ bci:4 (line 205) L[0]=sp + #32 L[1]=_ STK[0]=R8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::next @ bci:1 (line 132) L[0]=_
        # java.nio.file.FileTreeWalker::next @ bci:47 (line 350) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop off=12276/0x2ff4}
2ff4    #@ShouldNotReachHere

3000    B437: #	out( N6588 ) &lt;- in( B108 )  Freq: 2.31166e-07
3000 +  spill [sp, #8] -&gt; R8	# spill size = 64
3004 +  li R11, #-187	# int, #@loadConI
3008    spill R29 -&gt; [sp, #8]	# spill size = 64
300c +  spill R29 -&gt; [sp, #32]	# spill size = 64
3010 +  spill R7 -&gt; [sp, #40]	# spill size = 64
3014 +  spill R30 -&gt; [sp, #56]	# spill size = 64
3018 +  spill R7 -&gt; [sp, #64]	# spill size = 64
301c +  spill R12 -&gt; [sp, #72]	# spill size = 64
3020 +  spill R19 -&gt; [sp, #84]	# spill size = 32
3024 +  spill R16 -&gt; [sp, #88]	# spill size = 64
3028 +  spill R15 -&gt; [sp, #104]	# spill size = 64
302c +  spill R9 -&gt; [sp, #112]	# spill size = 32
3030    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal::get @ bci:11 (line 164) L[0]=sp + #88 L[1]=_ L[2]=sp + #104 L[3]=_ L[4]=_ STK[0]=sp + #104
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #40 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #112, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [88]=Oop [104]=Oop off=12340/0x3034}
3034    #@ShouldNotReachHere

3040    B438: #	out( N6588 ) &lt;- in( B111 )  Freq: 2.31165e-07
3040 +  spill [sp, #8] -&gt; R8	# spill size = 64
3044 +  li R11, #-187	# int, #@loadConI
3048    spill R29 -&gt; [sp, #8]	# spill size = 64
304c +  spill R29 -&gt; [sp, #32]	# spill size = 64
3050 +  spill R7 -&gt; [sp, #40]	# spill size = 64
3054 +  spill R30 -&gt; [sp, #56]	# spill size = 64
3058 +  spill R7 -&gt; [sp, #64]	# spill size = 64
305c +  spill R12 -&gt; [sp, #72]	# spill size = 64
3060 +  spill R19 -&gt; [sp, #84]	# spill size = 32
3064 +  spill R15 -&gt; [sp, #96]	# spill size = 64
3068 +  spill R16 -&gt; [sp, #104]	# spill size = 64
306c +  spill R13 -&gt; [sp, #112]	# spill size = 32
3070 +  spill R20 -&gt; [sp, #128]	# spill size = 64
3074 +  spill R9 -&gt; [sp, #116]	# spill size = 32
3078    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:21 (line 436) L[0]=sp + #96 L[1]=sp + #104 L[2]=sp + #112 L[3]=sp + #128 STK[0]=sp + #128
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #104 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #40 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #116, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [96]=Oop [104]=Oop [128]=Oop off=12412/0x307c}
307c    #@ShouldNotReachHere

3088    B439: #	out( N6588 ) &lt;- in( B116 )  Freq: 2.31164e-07
3088 +  spill [sp, #8] -&gt; R8	# spill size = 64
308c +  li R11, #-187	# int, #@loadConI
3090    spill R29 -&gt; [sp, #8]	# spill size = 64
3094 +  spill R29 -&gt; [sp, #32]	# spill size = 64
3098 +  spill R7 -&gt; [sp, #40]	# spill size = 64
309c +  spill R30 -&gt; [sp, #56]	# spill size = 64
30a0 +  spill R7 -&gt; [sp, #64]	# spill size = 64
30a4 +  spill R12 -&gt; [sp, #72]	# spill size = 64
30a8 +  spill R19 -&gt; [sp, #84]	# spill size = 32
30ac +  spill R18 -&gt; [sp, #88]	# spill size = 64
30b0 +  spill R21 -&gt; [sp, #104]	# spill size = 64
30b4 +  spill R9 -&gt; [sp, #112]	# spill size = 32
30b8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:26 (line 76) L[0]=sp + #84 L[1]=sp + #88 L[2]=#0 L[3]=sp + #104 STK[0]=sp + #104
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #40 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #112, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [88]=Oop [104]=Oop off=12476/0x30bc}
30bc    #@ShouldNotReachHere

30c8    B440: #	out( N6588 ) &lt;- in( B126 )  Freq: 2.31159e-07
30c8 +  li R11, #-187	# int, #@loadConI
30cc    spill [sp, #8] -&gt; R8	# spill size = 64
30d0 +  spill R28 -&gt; [sp, #0]	# spill size = 64
30d4 +  spill R30 -&gt; [sp, #64]	# spill size = 64
30d8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal::get @ bci:11 (line 164) L[0]=sp + #0 L[1]=_ L[2]=sp + #64 L[3]=_ L[4]=_ STK[0]=sp + #64
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=12508/0x30dc}
30dc    #@ShouldNotReachHere

30e8    B441: #	out( N6588 ) &lt;- in( B129 )  Freq: 2.31158e-07
30e8 +  spill [sp, #8] -&gt; R8	# spill size = 64
30ec +  li R11, #-187	# int, #@loadConI
30f0    spill R30 -&gt; [sp, #8]	# spill size = 64
30f4 +  spill R28 -&gt; [sp, #64]	# spill size = 64
30f8 +  spill R29 -&gt; [sp, #52]	# spill size = 32
30fc +  spill R7 -&gt; [sp, #80]	# spill size = 64
3100    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:21 (line 436) L[0]=sp + #8 L[1]=sp + #64 L[2]=sp + #52 L[3]=sp + #80 STK[0]=sp + #80
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #64 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [80]=Oop off=12548/0x3104}
3104    #@ShouldNotReachHere

3110    B442: #	out( B518 B491 ) &lt;- in( B187 )  Freq: 1.42163e-07
3110     -- 	// exception oop; no code emitted, #@CreateException
3110 +  spill R10 -&gt; R11	# spill size = 64
3114    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::next @ bci:76 (line 361) L[0]=sp + #16 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=12568/0x3118}

3118    B443: #	out( B492 B517 B493 ) &lt;- in( B196 )  Freq: 1.35411e-07
3118     -- 	// exception oop; no code emitted, #@CreateException
3118 +  spill R10 -&gt; R11	# spill size = 64
311c    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::visit @ bci:131 (line 301) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=12576/0x3120}

3120    B444: #	out( N6588 ) &lt;- in( B167 )  Freq: 2.69214e-08
3120 +  li R11, #-10	# int, #@loadConI
3124    spill [sp, #8] -&gt; R8	# spill size = 64
3128    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:27 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=12588/0x312c}
312c    #@ShouldNotReachHere

3138    B445: #	out( N6588 ) &lt;- in( B168 )  Freq: 2.69213e-08
3138 +  li R11, #-10	# int, #@loadConI
313c    spill [sp, #8] -&gt; R8	# spill size = 64
3140    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream::readLock @ bci:4 (line 75) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:27 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=12612/0x3144}
3144    #@ShouldNotReachHere

3150    B446: #	out( N6588 ) &lt;- in( B169 )  Freq: 2.69213e-08
3150 +  li R11, #-10	# int, #@loadConI
3154    spill [sp, #8] -&gt; R8	# spill size = 64
3158    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=12636/0x315c}
315c    #@ShouldNotReachHere

3168    B447: #	out( N6588 ) &lt;- in( B171 )  Freq: 2.69213e-08
3168 +  li R11, #-10	# int, #@loadConI
316c    spill [sp, #8] -&gt; R8	# spill size = 64
3170    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_ STK[0]=#NULL STK[1]=#1
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=12660/0x3174}
3174    #@ShouldNotReachHere

3180    B448: #	out( N6588 ) &lt;- in( B185 )  Freq: 1.44051e-08
3180 +  li R11, #-10	# int, #@loadConI
3184    spill [sp, #8] -&gt; R8	# spill size = 64
3188    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:76 (line 361) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_ STK[0]=#NULL
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop off=12684/0x318c}
318c    #@ShouldNotReachHere

3198    B449: #	out( B494 B497 ) &lt;- in( B276 )  Freq: 4.85033e-10
3198     -- 	// exception oop; no code emitted, #@CreateException
3198 +  spill R10 -&gt; R11	# spill size = 64
319c    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:20 (line 53) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [40]=Oop off=12704/0x31a0}

31a0    B450: #	out( N6588 ) &lt;- in( B510 )  Freq: 5.25879e-11
31a0     -- 	// exception oop; no code emitted, #@CreateException
31a0 +  spill R10 -&gt; [sp, #0]	# spill size = 64
31a4 +  li R11, #-75	# int, #@loadConI
31a8    spill [sp, #8] -&gt; R8	# spill size = 64
31ac    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:59 (line 352) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=_ L[5]=_ L[6]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=12720/0x31b0}
31b0    #@ShouldNotReachHere

31bc    B451: #	out( N6588 ) &lt;- in( B403 )  Freq: 5.25791e-11
31bc     -- 	// exception oop; no code emitted, #@CreateException
31bc +  spill R10 -&gt; [sp, #32]	# spill size = 64
31c0 +  li R11, #-75	# int, #@loadConI
31c4    spill [sp, #8] -&gt; R8	# spill size = 64
31c8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:71 (line 167) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #32
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop off=12748/0x31cc}
31cc    #@ShouldNotReachHere

31d8    B452: #	out( B454 B453 ) &lt;- in( B403 )  Freq: 5.25791e-11
31d8     -- 	// exception oop; no code emitted, #@CreateException
31d8 +  #@membar_release_lock (elided)
31d8    add R29, sp, #144	# box lock
31dc +  spill [sp, #0] -&gt; R18	# spill size = 64
31e0 +  fastunlock R18,R29	! kills R28, R7, #@cmpFastUnlock
3258 +  spill R10 -&gt; R9	# spill size = 64
325c +  far_bne RFLAGS, zr, B454	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

3264    B453: #	out( B516 B498 ) &lt;- in( B454 B452 )  Freq: 5.25791e-11
3264 +  spill R9 -&gt; R11	# spill size = 64
3268 +  spill R18 -&gt; R8	# spill size = 64
326c    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=R8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop off=12912/0x3270}

3270    B454: #	out( B453 ) &lt;- in( B452 )  Freq: 5.25791e-17
3270    add R11, sp, #144	# box lock
3274 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3274    spill R23 -&gt; R12	# spill size = 64
3278 +  spill R18 -&gt; R10	# spill size = 64
327c +  CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
32ac +  j  B453	#@branch

32b0    B455: #	out( N6588 ) &lt;- in( B476 )  Freq: 4.85011e-11
32b0     -- 	// exception oop; no code emitted, #@CreateException
32b0 +  spill R10 -&gt; [sp, #0]	# spill size = 64
32b4 +  li R11, #-75	# int, #@loadConI
32b8    spill [sp, #8] -&gt; R8	# spill size = 64
32bc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:24 (line 54) L[0]=#ScObj0 L[1]=_ STK[0]=sp + #0
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop off=12992/0x32c0}
32c0    #@ShouldNotReachHere

32cc    B456: #	out( N6588 ) &lt;- in( B462 )  Freq: 4.91223e-12
32cc +  li R11, #-10	# int, #@loadConI
32d0    spill [sp, #8] -&gt; R8	# spill size = 64
32d4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [64]=Oop off=13016/0x32d8}
32d8    #@ShouldNotReachHere

32e4    B457: #	out( N6588 ) &lt;- in( B464 )  Freq: 4.91223e-12
32e4 +  li R11, #-10	# int, #@loadConI
32e8    spill [sp, #8] -&gt; R8	# spill size = 64
32ec    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:8 (line 434) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [64]=Oop off=13040/0x32f0}
32f0    #@ShouldNotReachHere

32fc    B458: #	out( N6588 ) &lt;- in( B468 )  Freq: 4.91221e-12
32fc +  li R11, #-12	# int, #@loadConI
3300    spill [sp, #8] -&gt; R8	# spill size = 64
3304    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:6 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=13064/0x3308}
3308    #@ShouldNotReachHere

3314    B459: #	out( B473 ) &lt;- in( B478 )  Freq: 2.42385e-12
3314 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3314    spill R23 -&gt; R11	# spill size = 64
3318 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
3348 +  j  B473	#@branch

334c    B460: #	out( B476 ) &lt;- in( B274 )  Freq: 4.85052e-10
334c     -- 	// exception oop; no code emitted, #@CreateException
334c +  spill R10 -&gt; R11	# spill size = 64
3350 +  j  B476	#@branch

3354    B461: #	out( B476 ) &lt;- in( B268 )  Freq: 1.80146e-09
3354     -- 	// exception oop; no code emitted, #@CreateException
3354 +  spill R10 -&gt; R11	# spill size = 64
3358 +  j  B476	#@branch

335c    B462: #	out( B456 B463 ) &lt;- in( B124 )  Freq: 4.84786e-06
335c     -- 	// exception oop; no code emitted, #@CreateException
335c +  mv  R7, java/lang/Class:exact *	# ptr, #@loadConP
3374    spill R10 -&gt; [sp, #64]	# spill size = 64
3378 +  lwu  R10, [R7, #116]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/NativeBuffers.threadLocal
337c +  lwu  R7, [R8, #68]	# loadN, compressed ptr, #@loadN ! Field: java/lang/Thread.threadLocals
3380 +  decode_heap_oop  R30, R10	#@decodeHeapOop
3384 +  decode_heap_oop  R31, R7	#@decodeHeapOop
3388    lw  R28, [R30, #12]	# int, #@loadI ! Field: java/lang/ThreadLocal.threadLocalHashCode (constant)
338c    NullCheck R30

338c    B463: #	out( B489 B464 ) &lt;- in( B462 )  Freq: 4.84785e-06
338c    lwu  R7, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap.table
3390    NullCheck R31

3390    B464: #	out( B457 B465 ) &lt;- in( B463 )  Freq: 4.84785e-06
3390 +  decode_heap_oop  R12, R7	#@decodeHeapOop
3394    lwu  R29, [R12, #12]	# range, #@loadRange
3398    NullCheck R12

3398    B465: #	out( B484 B466 ) &lt;- in( B464 )  Freq: 4.84785e-06
3398 +  addiw  R7, R29, #-1	#@addI_reg_imm
339c +  andr  R28, R28, R7	#@andI_reg_reg
33a0 +  addw  R7, R28, zr	#@convI2L_reg_reg
33a4 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
33a8 +  add R7, R12, R7	# ptr, #@addP_reg_reg
33ac +  bleu  R29, zr, B484	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

33b0    B466: #	out( B490 B467 ) &lt;- in( B465 )  Freq: 4.84784e-06
33b0 +  lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN
33b4 +  decode_heap_oop  R7, R7	#@decodeHeapOop
33b8    lwu  R29, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
33bc    NullCheck R7

33bc    B467: #	out( B485 B468 ) &lt;- in( B466 )  Freq: 4.84784e-06
33bc    
33bc +  lwu  R11, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap$Entry.value
33c0 +  decode_heap_oop  R12, R11	#@decodeHeapOop
33c4 +  bne  R29, R10, B485	#@cmpN_branch  P=0.000001 C=-1.000000

33c8    B468: #	out( B458 B469 ) &lt;- in( B467 )  Freq: 4.84783e-06
33c8    lwu  R7, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
33cc    NullCheck R12

33cc    B469: #	out( B488 B470 ) &lt;- in( B468 )  Freq: 4.84783e-06
33cc +  mv  R29, narrowklass: precise klass [Lsun/nio/fs/NativeBuffer;: 0x00000040d0585d40:Constant:exact *	# compressed klass ptr, #@loadConNKlass
33dc +  bne  R7, R29, B488	#@cmpN_branch  P=0.000000 C=-1.000000

33e0    B470: #	out( B486 B471 ) &lt;- in( B469 )  Freq: 4.84783e-06
33e0 +  # checkcastPP of R12, #@checkCastPP
33e0    lwu  R7, [R12, #12]	# range, #@loadRange
33e4 +  addi  R9, R12, #16	# ptr, #@addP_reg_imm
33e8 +  bleu  R7, zr, B486	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

33ec    B471: #	out( B487 B472 ) &lt;- in( B470 )  Freq: 4.84782e-06
33ec +  lwu  R28, [R9]	# loadN, compressed ptr, #@loadN
33f0 +  decode_heap_oop  R8, R28	#@decodeHeapOop
33f4 +  bne   R8, zr, B487	#@cmpP_imm0_branch  P=0.000000 C=2801.000000

33f8    B472: #	out( B477 B473 ) &lt;- in( B471 )  Freq: 4.84782e-06
33f8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
33f8    lb  R7, [R23, #56]	# byte, #@loadB
33fc +  bne  R7, zr, B477	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

3400    B473: #	out( B475 B474 ) &lt;- in( B459 B479 B477 B472 )  Freq: 4.84782e-06
3400 +  mv  R7, R9	# ptr -&gt; long, #@castP2X
3404    spill [sp, #56] -&gt; R28	# spill size = 64
3408 +  mv  R28, R28	# ptr -&gt; long, #@castP2X
3408 +  xorr  R28, R28, R7	#@xorL_reg_reg
340c +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
3410    spill [sp, #0] -&gt; R29	# spill size = 32
3414 +  sw  R29, [R9]	# compressed ptr, #@storeN
3418 +  beq  R28, zr, B475	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

341c    B474: #	out( B480 B475 ) &lt;- in( B473 )  Freq: 4.84297e-06
341c +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
3420 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
342c +  add R10, R28, R7	# ptr, #@addP_reg_reg
3430 +  lb  R28, [R10]	# byte, #@loadB
3434 +  li R29, #4	# int, #@loadConI
3438 +  bne  R28, R29, B480	#@cmpI_branch  P=0.001000 C=-1.000000

343c    B475: #	out( B476 ) &lt;- in( B482 B483 B480 B474 B473 )  Freq: 4.84782e-06
343c +  spill [sp, #64] -&gt; R11	# spill size = 64

3440    B476: #	out( B495 B455 ) &lt;- in( B460 B461 B475 )  Freq: 4.85011e-06
3440    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [40]=Oop off=13380/0x3444}

3444    B477: #	out( B473 B478 ) &lt;- in( B472 )  Freq: 4.84776e-09
3444 +  lwu  R28, [R9]	# loadN, compressed ptr, #@loadN
3448 +  decode_heap_oop  R10, R28	#@decodeHeapOop
344c +  beq   R10, zr, B473	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

3450    B478: #	out( B459 B479 ) &lt;- in( B477 )  Freq: 2.42388e-09
3450 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3450    ld  R7, [R23, #32]	# int, #@loadL
3454 +  beq  R7, zr, B459	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

3458    B479: #	out( B473 ) &lt;- in( B478 )  Freq: 2.42146e-09
3458 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3458    ld  R28, [R23, #48]	# ptr, #@loadP
345c +  add R28, R28, R7	# ptr, #@addP_reg_reg
3460 +  addi  R7, R7, #-8	#@addL_reg_imm
3464 +  sd  R10, [R28, #-8]	# ptr, #@storeP
3468 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3468    sd  R7, [R23, #32]	# long, #@storeL
346c +  j  B473	#@branch

3470    B480: #	out( B475 B481 ) &lt;- in( B474 )  Freq: 4.84297e-09
3470 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3470    ld  R7, [R23, #64]	# int, #@loadL
3474 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3474    ld  R28, [R23, #80]	# ptr, #@loadP
3478 +  #@membar_volatile
	fence iorw iorw
347c +  lb  R29, [R10]	# byte, #@loadB
3480 +  beq  R29, zr, B475	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

3484    B481: #	out( B483 B482 ) &lt;- in( B480 )  Freq: 2.42149e-09
3484 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
3488 +  bne  R7, zr, B483	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

348c    B482: #	out( B475 ) &lt;- in( B481 )  Freq: 1.21074e-09
348c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
348c    spill R23 -&gt; R11	# spill size = 64
3490 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
34c0 +  j  B475	#@branch

34c4    B483: #	out( B475 ) &lt;- in( B481 )  Freq: 1.21074e-09
34c4 +  add R28, R28, R7	# ptr, #@addP_reg_reg
34c8 +  addi  R7, R7, #-8	#@addL_reg_imm
34cc +  sd  R10, [R28, #-8]	# ptr, #@storeP
34d0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
34d0    sd  R7, [R23, #64]	# long, #@storeL
34d4 +  j  B475	#@branch

34d8    B484: #	out( N6588 ) &lt;- in( B465 )  Freq: 4.84785e-12
34d8 +  spill [sp, #8] -&gt; R8	# spill size = 64
34dc +  li R11, #-28	# int, #@loadConI
34e0    spill R31 -&gt; [sp, #8]	# spill size = 64
34e4 +  spill R30 -&gt; [sp, #72]	# spill size = 64
34e8 +  spill R12 -&gt; [sp, #80]	# spill size = 64
34ec +  spill R28 -&gt; [sp, #88]	# spill size = 32
34f0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:18 (line 435) L[0]=sp + #8 L[1]=sp + #72 L[2]=sp + #88 L[3]=_ STK[0]=sp + #80 STK[1]=sp + #88
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #72 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [80]=Oop off=13556/0x34f4}
34f4    #@ShouldNotReachHere

3500    B485: #	out( N6588 ) &lt;- in( B467 )  Freq: 4.84784e-12
3500 +  spill [sp, #8] -&gt; R8	# spill size = 64
3504 +  li R11, #-187	# int, #@loadConI
3508    spill R31 -&gt; [sp, #8]	# spill size = 64
350c +  spill R30 -&gt; [sp, #72]	# spill size = 64
3510 +  spill R28 -&gt; [sp, #52]	# spill size = 32
3514 +  spill R7 -&gt; [sp, #80]	# spill size = 64
3518    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:29 (line 436) L[0]=sp + #8 L[1]=sp + #72 L[2]=sp + #52 L[3]=sp + #80 STK[0]=#0
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #72 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [80]=Oop off=13596/0x351c}
351c    #@ShouldNotReachHere

3528    B486: #	out( N6588 ) &lt;- in( B470 )  Freq: 4.84783e-12
3528 +  spill [sp, #8] -&gt; R8	# spill size = 64
352c +  li R11, #-28	# int, #@loadConI
3530    spill R12 -&gt; [sp, #8]	# spill size = 64
3534    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:40 (line 115) L[0]=sp + #56 L[1]=sp + #8 L[2]=#0 L[3]=_ STK[0]=sp + #8 STK[1]=#0
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=13624/0x3538}
3538    #@ShouldNotReachHere

3544    B487: #	out( N6588 ) &lt;- in( B471 )  Freq: 2.42391e-12
3544 +  spill [sp, #8] -&gt; R7	# spill size = 64
3548 +  li R11, #-187	# int, #@loadConI
354c    spill R7 -&gt; [sp, #0]	# spill size = 64
3550 +  spill R12 -&gt; [sp, #8]	# spill size = 64
3554    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:41 (line 115) L[0]=sp + #56 L[1]=sp + #8 L[2]=#0 L[3]=_ STK[0]=R8
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=13656/0x3558}
3558    #@ShouldNotReachHere

3564    B488: #	out( N6588 ) &lt;- in( B469 )  Freq: 1e-35
3564 +  li R11, #-34	# int, #@loadConI
3568    spill [sp, #8] -&gt; R8	# spill size = 64
356c +  spill R12 -&gt; [sp, #0]	# spill size = 64
3570    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:6 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #0
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=13684/0x3574}
3574    #@ShouldNotReachHere

3580    B489: #	out( N6588 ) &lt;- in( B463 )  Freq: 2.31164e-12
3580 +  li R11, #-187	# int, #@loadConI
3584    spill [sp, #8] -&gt; R8	# spill size = 64
3588 +  spill R30 -&gt; [sp, #0]	# spill size = 64
358c +  spill R31 -&gt; [sp, #72]	# spill size = 64
3590    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal::get @ bci:11 (line 164) L[0]=sp + #0 L[1]=_ L[2]=sp + #72 L[3]=_ L[4]=_ STK[0]=sp + #72
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop off=13716/0x3594}
3594    #@ShouldNotReachHere

35a0    B490: #	out( N6588 ) &lt;- in( B466 )  Freq: 2.31163e-12
35a0 +  spill [sp, #8] -&gt; R8	# spill size = 64
35a4 +  li R11, #-187	# int, #@loadConI
35a8    spill R31 -&gt; [sp, #8]	# spill size = 64
35ac +  spill R30 -&gt; [sp, #72]	# spill size = 64
35b0 +  spill R28 -&gt; [sp, #52]	# spill size = 32
35b4 +  spill R7 -&gt; [sp, #88]	# spill size = 64
35b8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:21 (line 436) L[0]=sp + #8 L[1]=sp + #72 L[2]=sp + #52 L[3]=sp + #88 STK[0]=sp + #88
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #72 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [88]=Oop off=13756/0x35bc}
35bc    #@ShouldNotReachHere

35c8    B491: #	out( N6588 ) &lt;- in( B442 )  Freq: 1.42163e-12
35c8     -- 	// exception oop; no code emitted, #@CreateException
35c8 +  spill R10 -&gt; [sp, #24]	# spill size = 64
35cc +  li R11, #-75	# int, #@loadConI
35d0    spill [sp, #8] -&gt; R8	# spill size = 64
35d4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:84 (line 362) L[0]=sp + #16 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_ STK[0]=sp + #24
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=13784/0x35d8}
35d8    #@ShouldNotReachHere

35e4    B492: #	out( N6588 ) &lt;- in( B443 )  Freq: 1.35411e-12
35e4     -- 	// exception oop; no code emitted, #@CreateException
35e4 +  spill R10 -&gt; [sp, #0]	# spill size = 64
35e8 +  li R11, #-75	# int, #@loadConI
35ec    spill [sp, #8] -&gt; R8	# spill size = 64
35f0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:155 (line 304) L[0]=_ L[1]=_ L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=13812/0x35f4}
35f4    #@ShouldNotReachHere

3600    B493: #	out( N6588 ) &lt;- in( B443 )  Freq: 1.35411e-12
3600     -- 	// exception oop; no code emitted, #@CreateException
3600 +  spill R10 -&gt; [sp, #0]	# spill size = 64
3604 +  li R11, #-75	# int, #@loadConI
3608    spill [sp, #8] -&gt; R8	# spill size = 64
360c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:139 (line 302) L[0]=_ L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop off=13840/0x3610}
3610    #@ShouldNotReachHere

361c    B494: #	out( B496 ) &lt;- in( B449 )  Freq: 4.85033e-15
361c     -- 	// exception oop; no code emitted, #@CreateException
361c +  spill R10 -&gt; R11	# spill size = 64
3620 +  j  B496	#@branch

3624    B495: #	out( B496 ) &lt;- in( B476 )  Freq: 4.85011e-11
3624     -- 	// exception oop; no code emitted, #@CreateException
3624 +  spill R10 -&gt; R11	# spill size = 64

3628    B496: #	out( B513 B514 ) &lt;- in( B494 B495 )  Freq: 4.85059e-11
3628    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [40]=Oop off=13868/0x362c}

362c    B497: #	out( N6588 ) &lt;- in( B449 )  Freq: 4.85033e-15
362c     -- 	// exception oop; no code emitted, #@CreateException
362c +  spill R10 -&gt; [sp, #0]	# spill size = 64
3630 +  li R11, #-75	# int, #@loadConI
3634    spill [sp, #8] -&gt; R8	# spill size = 64
3638    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:24 (line 54) L[0]=#ScObj0 L[1]=_ STK[0]=sp + #0
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop off=13884/0x363c}
363c    #@ShouldNotReachHere

3648    B498: #	out( N6588 ) &lt;- in( B453 )  Freq: 5.25791e-16
3648     -- 	// exception oop; no code emitted, #@CreateException
3648 +  spill R10 -&gt; [sp, #0]	# spill size = 64
364c +  li R11, #-75	# int, #@loadConI
3650    spill [sp, #8] -&gt; R8	# spill size = 64
3654    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:59 (line 352) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=_ L[5]=_ L[6]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=13912/0x3658}
3658    #@ShouldNotReachHere

3664    B499: #	out( B509 ) &lt;- in( B503 )  Freq: 5.2578e-16
3664     -- 	// exception oop; no code emitted, #@CreateException
3664 +  spill R10 -&gt; R9	# spill size = 64
3668 +  j  B509	#@branch

366c    B500: #	out( B509 ) &lt;- in( B502 )  Freq: 5.2579e-16
366c     -- 	// exception oop; no code emitted, #@CreateException
366c +  spill R10 -&gt; R9	# spill size = 64
3670 +  j  B509	#@branch

3674    B501: #	out( B512 B502 ) &lt;- in( B403 )  Freq: 5.25791e-11
3674     -- 	// exception oop; no code emitted, #@CreateException
3674 +  spill R8 -&gt; R7	# spill size = 64
3678 +  spill R10 -&gt; [sp, #32]	# spill size = 64
367c +  beq   R7, zr, B512	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

3680    B502: #	out( B500 B503 ) &lt;- in( B501 )  Freq: 5.2579e-11
3680 +  spill R7 -&gt; R11	# spill size = 64
3684    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixDirectoryStream::readLock
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:99 (line 171) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #32
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop off=13960/0x3688}

3688    B503: #	out( B499 B504 ) &lt;- in( B502 )  Freq: 5.2578e-11
        # Block is sole successor of call
3688 +  spill R10 -&gt; R11	# spill size = 64
368c    CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.concurrent.locks.Lock::unlock
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:102 (line 171) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #32
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop off=13992/0x36a8}

36a8    B504: #	out( B509 ) &lt;- in( B503 )  Freq: 5.25769e-11
        # Block is sole successor of call
36a8 +  spill [sp, #32] -&gt; R9	# spill size = 64
36ac +  j  B509	#@branch

36b0    B505: #	out( B507 ) &lt;- in( B270 )  Freq: 4.90542e-10
36b0     -- 	// exception oop; no code emitted, #@CreateException
36b0 +  j  B507	#@branch

36b4    B506: #	out( B507 ) &lt;- in( B272 )  Freq: 4.85622e-10
36b4     -- 	// exception oop; no code emitted, #@CreateException

36b4    B507: #	out( B509 ) &lt;- in( B505 B506 )  Freq: 9.76164e-10
36b4 +  spill R10 -&gt; R9	# spill size = 64
36b8 +  j  B509	#@branch

36bc    B508: #	out( B509 ) &lt;- in( B43 )  Freq: 5.25776e-06
36bc     -- 	// exception oop; no code emitted, #@CreateException
36bc +  spill R10 -&gt; R9	# spill size = 64

36c0    B509: #	out( B511 B510 ) &lt;- in( B508 B507 B500 B499 B504 )  Freq: 5.25879e-06
36c0 +  #@membar_release_lock (elided)
36c0    add R29, sp, #144	# box lock
36c4 +  spill [sp, #0] -&gt; R18	# spill size = 64
36c8 +  fastunlock R18,R29	! kills R7, R28, #@cmpFastUnlock
3740 +  far_bne RFLAGS, zr, B511	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

3748    B510: #	out( B522 B450 ) &lt;- in( B511 B509 )  Freq: 5.25879e-06
3748 +  spill R9 -&gt; R11	# spill size = 64
374c    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop off=14160/0x3750}

3750    B511: #	out( B510 ) &lt;- in( B509 )  Freq: 5.25879e-12
3750    add R11, sp, #144	# box lock
3754 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3754    spill R23 -&gt; R12	# spill size = 64
3758 +  spill [sp, #0] -&gt; R10	# spill size = 64
375c +  CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
378c +  j  B510	#@branch

3790    B512: #	out( N6588 ) &lt;- in( B501 )  Freq: 5.32773e-17
3790 +  li R11, #-10	# int, #@loadConI
3794    spill [sp, #8] -&gt; R8	# spill size = 64
3798    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:99 (line 171) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #32 STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop off=14236/0x379c}
379c    #@ShouldNotReachHere

37a8    B513: #	out( B515 B536 B535 ) &lt;- in( B496 )  Freq: 4.85059e-16
37a8     -- 	// exception oop; no code emitted, #@CreateException
37a8 +  spill R10 -&gt; R11	# spill size = 64
37ac    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [40]=Oop off=14256/0x37b0}

37b0    B514: #	out( N6588 ) &lt;- in( B496 )  Freq: 4.85059e-16
37b0     -- 	// exception oop; no code emitted, #@CreateException
37b0 +  spill R10 -&gt; [sp, #0]	# spill size = 64
37b4 +  li R11, #-75	# int, #@loadConI
37b8    spill [sp, #8] -&gt; R8	# spill size = 64
37bc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::getAttributes @ bci:63 (line 221) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop off=14272/0x37c0}
37c0    #@ShouldNotReachHere

37cc    B515: #	out( B532 ) &lt;- in( B513 )  Freq: 4.85059e-21
37cc     -- 	// exception oop; no code emitted, #@CreateException
37cc +  j  B532	#@branch

37d0    B516: #	out( B532 ) &lt;- in( B453 )  Freq: 5.25791e-16
37d0     -- 	// exception oop; no code emitted, #@CreateException
37d0 +  j  B532	#@branch

37d4    B517: #	out( B532 ) &lt;- in( B443 )  Freq: 1.35411e-12
37d4     -- 	// exception oop; no code emitted, #@CreateException
37d4 +  j  B532	#@branch

37d8    B518: #	out( B532 ) &lt;- in( B442 )  Freq: 1.42163e-12
37d8     -- 	// exception oop; no code emitted, #@CreateException
37d8 +  j  B532	#@branch

37dc    B519: #	out( B532 ) &lt;- in( B319 )  Freq: 1.35422e-11
37dc     -- 	// exception oop; no code emitted, #@CreateException
37dc +  j  B532	#@branch

37e0    B520: #	out( B532 ) &lt;- in( B317 )  Freq: 1.3543e-11
37e0     -- 	// exception oop; no code emitted, #@CreateException
37e0 +  j  B532	#@branch

37e4    B521: #	out( B532 ) &lt;- in( B315 )  Freq: 1.42181e-11
37e4     -- 	// exception oop; no code emitted, #@CreateException
37e4 +  j  B532	#@branch

37e8    B522: #	out( B532 ) &lt;- in( B510 )  Freq: 5.25879e-11
37e8     -- 	// exception oop; no code emitted, #@CreateException
37e8 +  j  B532	#@branch

37ec    B523: #	out( B532 ) &lt;- in( B278 )  Freq: 4.71488e-10
37ec     -- 	// exception oop; no code emitted, #@CreateException
37ec +  j  B532	#@branch

37f0    B524: #	out( B532 ) &lt;- in( B222 )  Freq: 1.354e-07
37f0     -- 	// exception oop; no code emitted, #@CreateException
37f0 +  j  B532	#@branch

37f4    B525: #	out( B532 ) &lt;- in( B219 )  Freq: 1.35402e-07
37f4     -- 	// exception oop; no code emitted, #@CreateException
37f4 +  j  B532	#@branch

37f8    B526: #	out( B532 ) &lt;- in( B212 )  Freq: 1.35405e-07
37f8     -- 	// exception oop; no code emitted, #@CreateException
37f8 +  j  B532	#@branch

37fc    B527: #	out( B532 ) &lt;- in( B199 )  Freq: 1.35408e-07
37fc     -- 	// exception oop; no code emitted, #@CreateException
37fc +  j  B532	#@branch

3800    B528: #	out( B532 ) &lt;- in( B192 )  Freq: 1.42157e-07
3800     -- 	// exception oop; no code emitted, #@CreateException
3800 +  j  B532	#@branch

3804    B529: #	out( B532 ) &lt;- in( B189 )  Freq: 1.4216e-07
3804     -- 	// exception oop; no code emitted, #@CreateException
3804 +  j  B532	#@branch

3808    B530: #	out( B534 ) &lt;- in( B182 )  Freq: 1.46968e-07
3808     -- 	// exception oop; no code emitted, #@CreateException
3808 +  spill R10 -&gt; R11	# spill size = 64
380c +  j  B534	#@branch

3810    B531: #	out( B532 ) &lt;- in( B148 )  Freq: 4.71409e-06
3810     -- 	// exception oop; no code emitted, #@CreateException

3810    B532: #	out( B534 ) &lt;- in( B522 B516 B518 B529 B521 B528 B515 B517 B520 B527 B526 B525 B519 B524 B523 B531 )  Freq: 5.54059e-06
3810 +  spill R10 -&gt; R11	# spill size = 64
3814 +  j  B534	#@branch

3818    B533: #	out( B534 ) &lt;- in( B151 )  Freq: 5.13841e-06
3818     -- 	// exception oop; no code emitted, #@CreateException
3818 +  spill R10 -&gt; R11	# spill size = 64

381c    B534: #	out( N6588 ) &lt;- in( B532 B533 B530 )  Freq: 1.0826e-05
381c    # pop frame 176
	add  sp, sp, #176
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
3870 +  j rethrow_stub	#@RethrowException

3878    B535: #	out( N6588 ) &lt;- in( B513 )  Freq: 4.85059e-21
3878     -- 	// exception oop; no code emitted, #@CreateException
3878 +  spill R10 -&gt; [sp, #0]	# spill size = 64
387c +  li R11, #-75	# int, #@loadConI
3880    spill [sp, #8] -&gt; R8	# spill size = 64
3884    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:27 (line 280) L[0]=_ L[1]=_ L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=14472/0x3888}
3888    #@ShouldNotReachHere

3894    B536: #	out( N6588 ) &lt;- in( B513 )  Freq: 4.85059e-21
3894     -- 	// exception oop; no code emitted, #@CreateException
3894 +  spill R10 -&gt; [sp, #0]	# spill size = 64
3898 +  li R11, #-75	# int, #@loadConI
389c    spill [sp, #8] -&gt; R8	# spill size = 64
38a0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:11 (line 278) L[0]=_ L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop off=14500/0x38a4}
38a4    #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='319'>
----------------------- MetaData before Compile_id = 319 ------------------------
{method}
 - this oop:          0x0000004096550570
 - method holder:     &apos;java/nio/file/FileTreeIterator&apos;
 - constants:         0x000000409654fe20 constant pool [128] {0x000000409654fe20} for &apos;java/nio/file/FileTreeIterator&apos; cache=0x0000004096550a20
 - access:            0xc1000002  private 
 - name:              &apos;fetchNextIfNeeded&apos;
 - signature:         &apos;()V&apos;
 - max stack:         4
 - max locals:        3
 - size of params:    1
 - method size:       13
 - highest level:     4
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x00000040139d1704
 - code size:         65
 - code start:        0x00000040965504f8
 - code end (excl):   0x0000004096550539
 - method data:       0x0000004096484b08
 - checked ex length: 0
 - linenumber start:  0x0000004096550539
 - localvar length:   3
 - localvar start:    0x000000409655054a

------------------------ OptoAssembly for Compile_id = 319 -----------------------
#
#  void ( java/nio/file/FileTreeIterator:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/nio/file/FileTreeIterator:NotNull *
# -- Old sp -- Framesize: 176 --
#r263 sp+172: in_preserve
#r262 sp+168: return address
#r261 sp+164: in_preserve
#r260 sp+160: saved fp register
#r259 sp+156: Fixed slot 3
#r258 sp+152: Fixed slot 2
#r257 sp+148: Fixed slot 1
#r256 sp+144: Fixed slot 0
#r299 sp+140: spill
#r298 sp+136: spill
#r297 sp+132: spill
#r296 sp+128: spill
#r295 sp+124: spill
#r294 sp+120: spill
#r293 sp+116: spill
#r292 sp+112: spill
#r291 sp+108: spill
#r290 sp+104: spill
#r289 sp+100: spill
#r288 sp+96: spill
#r287 sp+92: spill
#r286 sp+88: spill
#r285 sp+84: spill
#r284 sp+80: spill
#r283 sp+76: spill
#r282 sp+72: spill
#r281 sp+68: spill
#r280 sp+64: spill
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
0000    N6567: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0000    # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

0020    B1: #	out( B161 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0020    # stack bang size=176
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #176
	
003c    lwu  R7, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.next
0040    spill R11 -&gt; R9	# spill size = 64
0044 +  bne   R7, zr, B161	#@cmpP_narrowOop_imm0_branch  P=0.500454 C=5503.000000

0048    B2: #	out( B410 B3 ) &lt;- in( B1 )  Freq: 0.499546
0048 +  lwu  R28, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.walker
004c +  decode_heap_oop  R18, R28	#@decodeHeapOop
0050    lwu  R7, [R18, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker.stack
0054    NullCheck R18

0054    B3: #	out( B411 B4 ) &lt;- in( B2 )  Freq: 0.499545
0054 +  decode_heap_oop  R7, R7	#@decodeHeapOop
0058    lwu  R29, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/ArrayDeque.elements
005c    NullCheck R7

005c    B4: #	out( B412 B5 ) &lt;- in( B3 )  Freq: 0.499545
005c +  lw  R30, [R7, #12]	# int, #@loadI ! Field: java/util/ArrayDeque.head
0060 +  addw  R7, R30, zr	#@convI2L_reg_reg
0064 +  decode_heap_oop  R8, R29	#@decodeHeapOop
0068 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
006c    lwu  R28, [R8, #12]	# range, #@loadRange
0070    NullCheck R8

0070    B5: #	out( B325 B6 ) &lt;- in( B4 )  Freq: 0.499544
0070 +  add R7, R8, R7	# ptr, #@addP_reg_reg
0074 +  far_bgeu R30, R28, B325	#@far_cmpU_branch  P=0.000001 C=-1.000000

007c    B6: #	out( B161 B7 ) &lt;- in( B5 )  Freq: 0.499544
007c +  lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN
0080 +  decode_heap_oop  R24, R28	#@decodeHeapOop
0084 +  beq   R24, zr, B161	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

0088    B7: #	out( B399 B8 ) &lt;- in( B6 )  Freq: 0.499044
0088 +  lwu  R7, [R24, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
008c +  mv  R29, narrowklass: precise klass java/nio/file/FileTreeWalker$DirectoryNode: 0x00000040d09f6a90:Constant:exact *	# compressed klass ptr, #@loadConNKlass
009c +  far_bne  R7, R29, B399	#@far_cmpN_branch  P=0.000000 C=-1.000000

00a4    B8: #	out( B356 B9 ) &lt;- in( B7 )  Freq: 0.499044
00a4 +  # checkcastPP of R24, #@checkCastPP
00a4    lwu  R7, [R24, #28]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.iterator
00a8 +  lbu  R8, [R24, #12]	# byte, #@loadUB ! Field: java/nio/file/FileTreeWalker$DirectoryNode.skipped
00ac +  decode_heap_oop  R19, R7	#@decodeHeapOop
00b0 +  far_bne  R8, zr, B356	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2842.000000

00b8    B9: #	out( B413 B10 ) &lt;- in( B8 )  Freq: 0.499044
00b8    lwu  R28, [R19, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
00bc    NullCheck R19

00bc    B10: #	out( B326 B11 ) &lt;- in( B9 )  Freq: 0.499043
00bc +  mv  R7, narrowklass: precise klass sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator: 0x00000040d09eb6a0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
00cc +  far_bne  R28, R7, B326	#@far_cmpN_branch  P=0.000001 C=-1.000000

00d4    B11: #	out( B327 B12 ) &lt;- in( B10 )  Freq: 0.499043
00d4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
00d4    ld  R7, [R23, #712]	# ptr, #@loadP
00d8 +  ld  R20, [R7]	# ptr, #@loadP
00dc +  add R29, sp, #144	# box lock
00e0 +  # checkcastPP of R19, #@checkCastPP
00e0    fastlock R19,R29	! kills R7,R28, #@cmpFastLock
0174 +  far_bne RFLAGS, zr, B327	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

017c    B12: #	out( B357 B13 ) &lt;- in( B327 B11 )  Freq: 0.499043
017c +  #@membar_acquire_lock (elided)
017c +  lwu  R7, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
0180 +  lwu  R29, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
0184 +  decode_heap_oop  R8, R7	#@decodeHeapOop
0188 +  lbu  R28, [R19, #12]	# byte, #@loadUB ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.atEof
018c +  decode_heap_oop  R7, R29	#@decodeHeapOop
0190 +  far_bne   R8, zr, B357	#@far_cmpP_imm0_branch  P=0.000000 C=2846.000000

0198    B13: #	out( B358 B14 ) &lt;- in( B12 )  Freq: 0.499043
0198 +  far_bne  R28, zr, B358	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2846.000000

01a0    B14: #	out( B414 B15 ) &lt;- in( B13 )  Freq: 0.499042
01a0    lwu  R7, [R7, #32]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream.streamLock
01a4    NullCheck R7

01a4    B15: #	out( B415 B16 ) &lt;- in( B14 )  Freq: 0.499042
01a4 +  decode_heap_oop  R7, R7	#@decodeHeapOop
01a8    lwu  R28, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock.readerLock
01ac    NullCheck R7

01ac    B16: #	out( B416 B17 ) &lt;- in( B15 )  Freq: 0.499041
01ac +  decode_heap_oop  R8, R28	#@decodeHeapOop
01b0    # checkcastPP of R8, #@checkCastPP
01b0    lwu  R7, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
01b4    NullCheck R8

01b4    B17: #	out( B328 B18 ) &lt;- in( B16 )  Freq: 0.499041
01b4 +  mv  R29, narrowklass: precise klass java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock: 0x00000040d08c1250:Constant:exact *	# compressed klass ptr, #@loadConNKlass
01c4 +  far_bne  R7, R29, B328	#@far_cmpN_branch  P=0.000001 C=-1.000000

01cc    B18: #	out( B417 B19 ) &lt;- in( B17 )  Freq: 0.49904
01cc +  # checkcastPP of R8, #@checkCastPP
01cc    lwu  R7, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock.sync
01d0 +  decode_heap_oop  R21, R7	#@decodeHeapOop
01d4    lw  R31, [R21, #16]	# int, #@loadI ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.state
01d8    NullCheck R21

01d8    B19: #	out( B370 B20 ) &lt;- in( B18 )  Freq: 0.49904
01d8 +  #@membar_acquire
	fence ir iorw
01dc +  zext.h  R8, R31	# s2ui, #@convS2UI_reg_reg_b
01e0 +  far_bne  R8, zr, B370	#@far_cmpI_reg_imm0_branch  P=0.000000 C=3040.000000

01e8    B20: #	out( B329 B21 ) &lt;- in( B19 )  Freq: 0.49904
01e8 +  lwu  R28, [R21, #20]	# loadN, compressed ptr, #@loadN ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.head
01ec +  #@membar_acquire
	fence ir iorw
01f0 +  decode_heap_oop  R8, R28	#@decodeHeapOop
01f4 +  srliw  R29, R31, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
01f8 +  far_bne   R8, zr, B329	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0200    B21: #	out( B371 B22 ) &lt;- in( B20 )  Freq: 0.499039
0200 +  li R7, #65535	# int, #@loadConI
0208 +  far_bge  R29, R7, B371	#@far_cmpI_branch  P=0.000000 C=3040.000000

0210    B22: #	out( B372 B23 ) &lt;- in( B21 )  Freq: 0.499039
0210 +  #@membar_release
	fence iorw ow
0214 +  li R28, #65536	# int, #@loadConI
0218 +  addw  R28, R31, R28	#@addI_reg_reg
021c +  addi  R7, R21, #16	# ptr, #@addP_reg_imm
0220    
0220 +  cmpxchg_acq [R7], R31, R28	# (int) if [R7] == R31 then [R7] &lt;-- R28
	mv R8, R8 == R31	# R8 &lt;-- (R8 == R31 ? 1 : 0), #@compareAndSwapIAcq
023c    
023c +  #@membar_acquire
	fence ir iorw
0240 +  far_beq  R8, zr, B372	#@far_cmpI_reg_imm0_branch  P=0.000000 C=3040.000000

0248    B23: #	out( B359 B24 ) &lt;- in( B22 )  Freq: 0.499039
0248 +  far_bne  R29, zr, B359	#@far_cmpI_reg_imm0_branch  P=0.000000 C=3040.000000

0250    B24: #	out( B228 B25 ) &lt;- in( B23 )  Freq: 0.499038
0250 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0250    lb  R28, [R23, #56]	# byte, #@loadB
0254 +  far_bne  R28, zr, B228	#@far_cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

025c    B25: #	out( B27 B26 ) &lt;- in( B360 B230 B228 B24 )  Freq: 0.499038
025c +  mv  R28, R21	# ptr -&gt; long, #@castP2X
0260 +  mv  R7, R20	# ptr -&gt; long, #@castP2X
0264 +  xorr  R29, R7, R28	#@xorL_reg_reg
0268 +  encode_heap_oop  R7, R20	#@encodeHeapOop
026c +  srli  R29, R29, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0270 +  sw  R7, [R21, #40]	# compressed ptr, #@storeN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
0274 +  beq  R29, zr, B27	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0278    B26: #	out( B237 B27 ) &lt;- in( B25 )  Freq: 0.498539
0278 +  srli  R28, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
027c +  mv  R29, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
0288 +  add R10, R29, R28	# ptr, #@addP_reg_reg
028c +  lb  R28, [R10]	# byte, #@loadB
0290 +  li R30, #4	# int, #@loadConI
0294 +  far_bne  R28, R30, B237	#@far_cmpI_branch  P=0.001000 C=-1.000000

029c    B27: #	out( B28 ) &lt;- in( B239 B240 B237 B26 B25 )  Freq: 0.499038
029c +  li R28, #1	# int, #@loadConI
02a0 +  sw  R28, [R21, #28]	# int, #@storeI ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReaderHoldCount

02a4    B28: #	out( B404 B29 ) &lt;- in( B27 B180 ) Loop( B28-B180 inner ) Freq: 0.526544
02a4 +  lwu  R29, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
02a8 +  decode_heap_oop  R28, R29	#@decodeHeapOop
02ac    lbu  R28, [R28, #12]	# byte, #@loadUB ! Field: volatile sun/nio/fs/UnixDirectoryStream.isClosed
02b0    NullCheck R28

02b0    B29: #	out( B350 B30 ) &lt;- in( B28 )  Freq: 0.526543
02b0 +  #@membar_acquire
	fence ir iorw
02b4 +  lwu  R29, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
02b8 +  decode_heap_oop  R29, R29	#@decodeHeapOop
02bc +  far_bne  R28, zr, B350	#@far_cmpI_reg_imm0_branch  P=0.000000 C=3040.000000

02c4    B30: #	out( B405 B31 ) &lt;- in( B29 )  Freq: 0.526543
02c4    ld  R11, [R29, #16]	# int, #@loadL ! Field: sun/nio/fs/UnixDirectoryStream.dp
02c8    NullCheck R29

02c8    B31: #	out( B403 B32 ) &lt;- in( B30 )  Freq: 0.526543
02c8 +  spill R7 -&gt; [sp, #24]	# spill size = 32
02cc +  spill R20 -&gt; [sp, #16]	# spill size = 64
02d0 +  spill R19 -&gt; [sp, #0]	# spill size = 64
02d4 +  spill R24 -&gt; [sp, #56]	# spill size = 64
02d8 +  spill R18 -&gt; [sp, #48]	# spill size = 64
02dc +  spill R9 -&gt; [sp, #8]	# spill size = 64
02e0    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect sun.nio.fs.UnixNativeDispatcher::readdir
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:52 (line 165) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=NarrowOop [48]=Oop [56]=Oop off=740/0x2e4}

02e4    B32: #	out( B406 B33 ) &lt;- in( B31 )  Freq: 0.526532
        # Block is sole successor of call
02e4 +  spill [sp, #0] -&gt; R29	# spill size = 64
02e8 +  lwu  R28, [R29, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
02ec +  spill R10 -&gt; [sp, #64]	# spill size = 64
02f0 +  decode_heap_oop  R7, R28	#@decodeHeapOop
02f4    lwu  R7, [R7, #32]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream.streamLock
02f8    NullCheck R7

02f8    B33: #	out( B407 B34 ) &lt;- in( B32 )  Freq: 0.526531
02f8 +  decode_heap_oop  R7, R7	#@decodeHeapOop
02fc    lwu  R28, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock.readerLock
0300    NullCheck R7

0300    B34: #	out( B408 B35 ) &lt;- in( B33 )  Freq: 0.526531
0300 +  decode_heap_oop  R8, R28	#@decodeHeapOop
0304    # checkcastPP of R8, #@checkCastPP
0304    lwu  R7, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0308    NullCheck R8

0308    B35: #	out( B321 B36 ) &lt;- in( B34 )  Freq: 0.52653
0308 +  mv  R30, narrowklass: precise klass java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock: 0x00000040d08c1250:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0318 +  far_bne  R7, R30, B321	#@far_cmpN_branch  P=0.000001 C=-1.000000

0320    B36: #	out( B409 B37 ) &lt;- in( B35 )  Freq: 0.52653
0320 +  # checkcastPP of R8, #@checkCastPP
0320    lwu  R28, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock.sync
0324 +  decode_heap_oop  R12, R28	#@decodeHeapOop
0328    lwu  R7, [R12, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
032c    NullCheck R12

032c    B37: #	out( B351 B38 ) &lt;- in( B36 )  Freq: 0.526529
032c +  decode_heap_oop  R8, R7	#@decodeHeapOop
0330 +  lw  R31, [R12, #28]	# int, #@loadI ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReaderHoldCount
0334    spill [sp, #16] -&gt; R30	# spill size = 64
0338 +  far_bne  R8, R30, B351	#@far_cmpP_branch  P=0.000000 C=3040.000000

0340    B38: #	out( B352 B39 ) &lt;- in( B37 )  Freq: 0.526529
0340 +  li R7, #1	# int, #@loadConI
0344 +  far_bne  R31, R7, B352	#@far_cmpI_branch  P=0.000000 C=3040.000000

034c    B39: #	out( B225 B40 ) &lt;- in( B38 )  Freq: 0.526529
034c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
034c    lb  R28, [R23, #56]	# byte, #@loadB
0350 +  far_bne  R28, zr, B225	#@far_cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0358    B40: #	out( B355 B41 ) &lt;- in( B354 B227 B225 B39 )  Freq: 0.526529
0358 +  lw  R7, [R12, #16]	# int, #@loadI ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.state
035c +  sw  rheapbase, [R12, #40]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
0360 +  #@membar_acquire
	fence ir iorw
0364 +  #@membar_release
	fence iorw ow
0364 +  li R10, #-65536	# int, #@loadConI
0368 +  addw  R31, R7, R10	#@addI_reg_reg
036c +  addi  R28, R12, #16	# ptr, #@addP_reg_imm
0370    
0370 +  cmpxchg_acq [R28], R7, R31	# (int) if [R28] == R7 then [R28] &lt;-- R31
	mv R8, R8 == R7	# R8 &lt;-- (R8 == R7 ? 1 : 0), #@compareAndSwapIAcq
038c    
038c +  #@membar_acquire
	fence ir iorw
0390 +  far_beq  R8, zr, B355	#@far_cmpI_reg_imm0_branch  P=0.000000 C=3040.000000

0398    B41: #	out( B353 B42 ) &lt;- in( B40 )  Freq: 0.526529
0398 +  li R28, #65536	# int, #@loadConI
039c +  far_bne  R7, R28, B353	#@far_cmpI_branch  P=0.000000 C=3040.000000

03a4    B42: #	out( B322 B43 ) &lt;- in( B41 )  Freq: 0.526528
03a4 +  lwu  R28, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.head
03a8 +  #@membar_acquire
	fence ir iorw
03ac +  decode_heap_oop  R8, R28	#@decodeHeapOop
03b0 +  far_bne   R8, zr, B322	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

03b8    B43: #	out( B508 B44 ) &lt;- in( B42 )  Freq: 0.526528
03b8 +  spill R30 -&gt; [sp, #72]	# spill size = 64
03bc +  spill R29 -&gt; [sp, #0]	# spill size = 64
03c0 +  mv  R11, NULL	# NULL ptr, #@loadConP0
03c4    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.util.concurrent.locks.AbstractQueuedSynchronizer::signalNext
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:12 (line 1095) L[0]=_ L[1]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [24]=NarrowOop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=968/0x3c8}

03c8    B44: #	out( B194 B45 ) &lt;- in( B43 )  Freq: 0.526517
        # Block is sole successor of call
03c8 +  spill [sp, #64] -&gt; R20	# spill size = 64
03cc +  beq   R20, zr, B194	#@cmpP_imm0_branch  P=0.026973 C=3003.000000

03d0    B45: #	out( B324 B46 ) &lt;- in( B44 )  Freq: 0.512316
03d0 +  lwu  R22, [R20, #12]	# range, #@loadRange
03d4 +  addi  R25, R20, #16	# ptr, #@addP_reg_imm
03d8    spill [sp, #0] -&gt; R19	# spill size = 64
03dc +  lwu  R28, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
03e0 +  far_bleu  R22, zr, B324	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

03e8    B46: #	out( B162 B47 ) &lt;- in( B45 )  Freq: 0.512315
03e8 +  lb  R7, [R25]	# byte, #@loadB
03ec +  li R29, #46	# int, #@loadConI
03f0 +  decode_heap_oop  R10, R28	#@decodeHeapOop
03f4 +  beq  R7, R29, B162	#@cmpI_branch  P=0.053668 C=2944.000000

03f8    B47: #	out( B418 B48 ) &lt;- in( B46 )  Freq: 0.48482
03f8    lwu  R29, [R10, #24]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream.dir
03fc    NullCheck R10

03fc    B48: #	out( B419 B49 ) &lt;- in( B47 )  Freq: 0.484819
03fc +  decode_heap_oop  R21, R29	#@decodeHeapOop
0400    lwu  R28, [R21, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
0404    NullCheck R21

0404    B49: #	out( B374 B50 ) &lt;- in( B48 )  Freq: 0.484819
0404 +  li R29, #47	# int, #@loadConI
0408 +  decode_heap_oop  R28, R28	#@decodeHeapOop
040c +  far_beq  R7, R29, B374	#@far_cmpI_branch  P=0.000000 C=2756.000000

0414    B50: #	out( B420 B51 ) &lt;- in( B49 )  Freq: 0.484819
0414    lwu  R18, [R28, #12]	# range, #@loadRange
0418    NullCheck R28

0418    B51: #	out( B364 B52 ) &lt;- in( B50 )  Freq: 0.484818
0418 +  addw  R29, R22, R18	#@addI_reg_reg
041c +  addiw  R9, R29, #1	#@addI_reg_imm
0420 +  li R7, #1048576	# int, #@loadConI
0424 +  far_bleu  R18, zr, B364	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000000 C=2756.000000

042c    B52: #	out( B375 B53 ) &lt;- in( B51 )  Freq: 0.484818
042c +  li R30, #1	# int, #@loadConI
0430 +  far_beq  R18, R30, B375	#@far_cmpI_branch  P=0.000000 C=2756.000000

0438    B53: #	out( B331 B54 ) &lt;- in( B52 )  Freq: 0.484818
0438 +  addw  R30, R22, zr	#@convI2L_reg_reg
043c +  addw  R26, R18, zr	#@convI2L_reg_reg
0440 +  far_bgtu R9, R7, B331	#@far_cmpU_branch  P=0.000001 C=-1.000000

0448    B54: #	out( B55 ) &lt;- in( B53 )  Freq: 0.484817
0448 +  add  R29, R26, R30	#@addL_reg_reg
044c +  addi  R29, R29, #1	#@addL_reg_imm

0450    B55: #	out( B336 B56 ) &lt;- in( B54 B331 )  Freq: 0.484818
0450 +  addi  R8, R29, #23	#@addL_reg_imm
0454 +  far_bltu R9, R18, B336	#@far_cmpU_branch  P=0.000001 C=-1.000000

045c    B56: #	out( B270 B57 ) &lt;- in( B55 )  Freq: 0.484817
045c +  andi  R29, R8, #-8	#@andL_reg_imm
0460    spill R29 -&gt; [sp, #104]	# spill size = 64
0464 +  far_bgtu R9, R7, B270	#@far_cmpU_branch  P=0.000001 C=-1.000000

046c    B57: #	out( B270 B58 ) &lt;- in( B56 )  Freq: 0.484817
046c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
046c    ld  R24, [R23, #288]	# ptr, #@loadP
0470 +  add R7, R24, R29	# ptr, #@addP_reg_reg
0474 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0474    ld  R29, [R23, #304]	# ptr, #@loadP
0478 +  far_bgeu  R7, R29, B270	#@far_cmpP_branch  P=0.000100 C=-1.000000

0480    B58: #	out( B59 ) &lt;- in( B57 )  Freq: 0.484768
0480 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0480    sd  R7, [R23, #288]	# ptr, #@storeP
0484 +  li R7, #1	# long, #@loadConL
0488 +  sd  R7, [R24]	# long, #@storeL
048c +  mv  R7, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
049c +  sw  R7, [R24, #8]	# compressed klass ptr, #@storeNKlass
04a0 +  sw  R9, [R24, #12]	# int, #@storeI

04a4    B59: #	out( B337 B60 ) &lt;- in( B271 B58 )  Freq: 0.484817
04a4    
04a4 +  srli  R7, R8, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
04a8 +  # checkcastPP of R24, #@checkCastPP
04a8    addi  R11, R24, #16	# ptr, #@addP_reg_imm
04ac +  far_bleu  R18, zr, B337	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

04b4    B60: #	out( B246 B61 ) &lt;- in( B59 )  Freq: 0.484817
04b4 +  addi  R10, R28, #16	# ptr, #@addP_reg_imm
04b8 +  far_blt  R18, R9, B246	#@far_cmpI_branch  P=0.001000 C=-1.000000

04c0    B61: #	out( B62 ) &lt;- in( B60 )  Freq: 0.484332
04c0 +  spill [sp, #104] -&gt; R7	# spill size = 64
04c4 +  spill R24 -&gt; R8	# spill size = 64
04c8 +  addi  R7, R7, #-16	#@addL_reg_imm
04cc    spill R30 -&gt; R24	# spill size = 64
04d0    
04d0    
04d0 +  srli  R12, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
04d4    CALL, runtime leaf nofp 0x000000401396d840	#@CallLeafNoFPDirect jlong_disjoint_arraycopy
        No JVM State Info
        # 
04d8 +  spill R24 -&gt; R30	# spill size = 64
04dc +  spill R8 -&gt; R24	# spill size = 64

04e0    B62: #	out( B332 B63 ) &lt;- in( B246 B61 B337 )  Freq: 0.484817
04e0 +  MEMBAR-store-store	#@membar_storestore
04e4 +  add R7, R24, R26	# ptr, #@addP_reg_reg
04e8 +  addiw  R8, R18, #1	#@addI_reg_imm
04ec +  far_bgeu R18, R9, B332	#@far_cmpU_branch  P=0.000001 C=-1.000000

04f4    B63: #	out( B338 B64 ) &lt;- in( B62 )  Freq: 0.484817
04f4 +  li R29, #47	# int, #@loadConI
04f8 +  sb  R29, [R7, #16]	# byte, #@storeB
04fc +  far_blt  R8, zr, B338	#@far_cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0504    B64: #	out( B66 B65 ) &lt;- in( B63 )  Freq: 0.484816
0504 +  bleu  R22, zr, B66	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

0508    B65: #	out( B66 ) &lt;- in( B64 )  Freq: 0.484816
0508 +  spill R30 -&gt; R12	# spill size = 64
050c +  addi  R11, R7, #17	# ptr, #@addP_reg_imm
0510    spill R25 -&gt; R10	# spill size = 64
0514 +  CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

0518    B66: #	out( B272 B67 ) &lt;- in( B65 B64 )  Freq: 0.484816
0518    
0518 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0518    ld  R18, [R23, #288]	# ptr, #@loadP
051c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
051c    ld  R7, [R23, #304]	# ptr, #@loadP
0520 +  addi  R28, R18, #32	# ptr, #@addP_reg_imm
0524 +  far_bgeu  R28, R7, B272	#@far_cmpP_branch  P=0.000100 C=-1.000000

052c    B67: #	out( B68 ) &lt;- in( B66 )  Freq: 0.484768
052c +  li R7, #1	# long, #@loadConL
0530 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0530    sd  R28, [R23, #288]	# ptr, #@storeP
0534 +  sd  R7, [R18]	# long, #@storeL
0538 +  mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d09eb770:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0548 +  sw  R7, [R18, #8]	# compressed klass ptr, #@storeNKlass
054c +  sw  zr, [R18, #12]	# int, #@storeimmI0
0550 +  sw  zr, [R18, #16]	# int, #@storeimmI0
0554 +  sd  zr, [R18, #24]	# long, #@storeimmL0

0558    B68: #	out( B421 B69 ) &lt;- in( B273 B67 )  Freq: 0.484816
0558 +  encode_heap_oop  R28, R24	#@encodeHeapOop
055c +  sw  R28, [R18, #20]	# compressed ptr, #@storeN
0560    
0560 +  lwu  R7, [R21, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
0564 +  # checkcastPP of R18, #@checkCastPP
0564    sw  R7, [R18, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixPath.fs
0568 +  #@membar_release
	fence iorw ow
056c +  lwu  R28, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
0570 +  decode_heap_oop  R7, R28	#@decodeHeapOop
0574    lwu  R7, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream.filter
0578    NullCheck R7

0578    B69: #	out( B435 B70 ) &lt;- in( B68 )  Freq: 0.484816
0578 +  decode_heap_oop  R8, R7	#@decodeHeapOop
057c    lwu  R28, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0580    NullCheck R8

0580    B70: #	out( B339 B71 ) &lt;- in( B69 )  Freq: 0.484815
0580 +  mv  R7, narrowklass: precise klass java/nio/file/Files$AcceptAllFilter: 0x00000040d08c1320:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0590 +  far_bne  R28, R7, B339	#@far_cmpN_branch  P=0.000001 C=-1.000000

0598    B71: #	out( B72 ) &lt;- in( B70 )  Freq: 0.484815
0598 +  # checkcastPP of R18, #@checkCastPP

0598    B72: #	out( B231 B73 ) &lt;- in( B194 B71 )  Freq: 0.499017
0598 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0598    lb  R7, [R23, #56]	# byte, #@loadB
059c +  bne  R7, zr, B231	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

05a0    B73: #	out( B76 B74 ) &lt;- in( B361 B233 B231 B72 )  Freq: 0.499017
05a0 +  mv  R28, R19	# ptr -&gt; long, #@castP2X
05a4 +  mv  R7, R18	# ptr -&gt; long, #@castP2X
05a8 +  xorr  R7, R7, R28	#@xorL_reg_reg
05ac +  encode_heap_oop  R9, R18	#@encodeHeapOop
05b0 +  srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
05b4 +  sw  R9, [R19, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
05b8 +  beq  R7, zr, B76	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

05bc    B74: #	out( B76 B75 ) &lt;- in( B73 )  Freq: 0.498518
05bc +  beq   R18, zr, B76	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

05c0    B75: #	out( B241 B76 ) &lt;- in( B74 )  Freq: 0.498019
05c0 +  srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
05c4 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
05d0 +  add R10, R28, R7	# ptr, #@addP_reg_reg
05d4 +  lb  R28, [R10]	# byte, #@loadB
05d8 +  li R7, #4	# int, #@loadConI
05dc +  bne  R28, R7, B241	#@cmpI_branch  P=0.001000 C=-1.000000

05e0    B76: #	out( B330 B77 ) &lt;- in( B245 B75 B74 B73 )  Freq: 0.499017
05e0 +  #@membar_release_lock (elided)
05e0    add R29, sp, #144	# box lock
05e4 +  fastunlock R19,R29	! kills R7, R28, #@cmpFastUnlock
065c +  far_bne RFLAGS, zr, B330	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

0664    B77: #	out( B185 B78 ) &lt;- in( B330 B76 )  Freq: 0.499017
0664 +  beq   R9, zr, B185	#@cmpP_narrowOop_imm0_branch  P=0.029546 C=2843.000000

0668    B78: #	out( B340 B79 ) &lt;- in( B77 )  Freq: 0.484273
0668    add R29, sp, #144	# box lock
066c +  fastlock R19,R29	! kills R7,R28, #@cmpFastLock
0700 +  far_bne RFLAGS, zr, B340	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

0708    B79: #	out( B436 B80 ) &lt;- in( B340 B78 )  Freq: 0.484273
0708 +  #@membar_acquire_lock (elided)
0708 +  lwu  R28, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
070c +  decode_heap_oop  R8, R28	#@decodeHeapOop
0710    lwu  R18, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0714    NullCheck R8

0714    B80: #	out( B247 B81 ) &lt;- in( B79 )  Freq: 0.484272
0714 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0714    lb  R7, [R23, #56]	# byte, #@loadB
0718 +  bne  R7, zr, B247	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

071c    B81: #	out( B341 B82 ) &lt;- in( B365 B249 B247 B80 )  Freq: 0.484272
071c +  sw  rheapbase, [R19, #16]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
0720 +  #@membar_release_lock (elided)
0720    add R29, sp, #144	# box lock
0724 +  fastunlock R19,R29	! kills R7, R28, #@cmpFastUnlock
079c +  far_bne RFLAGS, zr, B341	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

07a4    B82: #	out( B400 B83 ) &lt;- in( B341 B81 )  Freq: 0.484272
07a4 +  mv  R14, precise klass sun/nio/fs/UnixPath: 0x00000040d09eb770:Constant:exact *	# ptr, #@loadConP
07bc +  mv  R29, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d09eb770:Constant:exact *	# compressed klass ptr, #@loadConNKlass
07cc +  ld  R28, [R14, #40]	# class, #@loadKlass
07d0 +  mv  R10, precise klass sun/nio/fs/BasicFileAttributesHolder: 0x00000040d81ddab0:Constant:exact *	# ptr, #@loadConP
07e8 +  far_bne  R18, R29, B400	#@far_cmpN_branch  P=0.000000 C=-1.000000

07f0    B83: #	out( B333 B84 ) &lt;- in( B82 )  Freq: 0.484272
07f0 +  spill R8 -&gt; R7	# spill size = 64
07f4 +  # checkcastPP of R7, #@checkCastPP
07f4    far_beq  R28, R10, B333	#@far_cmpP_branch  P=0.000001 C=-1.000000

07fc    B84: #	out( B334 B85 ) &lt;- in( B83 )  Freq: 0.484272
07fc +  partialSubtypeCheck R15, R14, R10 == 0	#@partialSubtypeCheckVsZero
0858 +  lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
085c +  spill [sp, #48] -&gt; R29	# spill size = 64
0860 +  lwu  R31, [R29, #20]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker.linkOptions
0864 +  decode_heap_oop  R28, R28	#@decodeHeapOop
0868 +  far_beq RFLAGS, zr, B334	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

0870    B85: #	out( B422 B86 ) &lt;- in( B84 )  Freq: 0.484271
0870    lwu  R30, [R28, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileSystem.provider
0874    NullCheck R28

0874    B86: #	out( B335 B87 ) &lt;- in( B85 )  Freq: 0.484271
0874 +  decode_heap_oop  R14, R31	#@decodeHeapOop
0878 +  far_beq   R30, zr, B335	#@far_cmpP_narrowOop_imm0_branch  P=0.000001 C=-1.000000

0880    B87: #	out( B423 B88 ) &lt;- in( B86 )  Freq: 0.48427
0880    lwu  R28, [R14, #12]	# range, #@loadRange
0884    NullCheck R14

0884    B88: #	out( B96 B89 ) &lt;- in( B87 )  Freq: 0.48427
0884 +  bleu  R28, zr, B96	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.500091 C=5511.000000

0888    B89: #	out( B363 B90 ) &lt;- in( B88 )  Freq: 0.242091
0888 +  addiw  R30, R28, #-1	#@addI_reg_imm
088c +  li R12, #1000	# int, #@loadConI
0890 +  far_bgeu R30, R28, B363	#@far_cmpU_branch  P=0.000001 C=-1.000000

0898    B90: #	out( B91 ) &lt;- in( B89 )  Freq: 0.242091
0898 +  mv  R15, narrowoop: java/nio/file/LinkOption:exact *	# compressed ptr, #@loadConN
08a8 +  li R13, #0	# int, #@loadConI
08ac +  li R9, #0	# int, #@loadConI

08b0    B91: #	out( B92 ) &lt;- in( B90 B94 ) Loop( B91-B94 ) Freq: 0.484093
08b0 +  subw  R31, R28, R13	#@subI_reg_reg
08b4    CMove R31, (R28 lt R13), R31, R9	#@cmovI_cmpI
	
08bc +  CMove R31, (R31 gtu R12), R31, R12	#@cmovI_cmpU
	
08c4 +  addw  R30, R31, R13	#@addI_reg_reg

08c8    B92: #	out( B349 B93 ) &lt;- in( B91 B93 ) Loop( B92-B93 inner  strip mined) Freq: 0.96801
08c8 +  addw  R31, R13, zr	#@convI2L_reg_reg
08cc +  slli  R31, R31, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
08d0 +  add R31, R14, R31	# ptr, #@addP_reg_reg
08d4 +  lwu  R10, [R31, #16]	# loadN, compressed ptr, #@loadN
08d8 +  far_bne  R10, R15, B349	#@far_cmpN_branch  P=0.000000 C=2755.000000

08e0    B93: #	out( B92 B94 ) &lt;- in( B92 )  Freq: 0.96801
08e0 +  addiw  R13, R13, #1	#@addI_reg_imm
08e4 +  blt  R13, R30, B92	#@cmpI_loop  P=0.499909 C=2755.000000

08e8    B94: #	out( B91 B95 ) &lt;- in( B93 )  Freq: 0.484093
08e8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
08e8    ld  R16, [R23, #920]	# ptr, #@loadP
08ec +  lwu zr, [R16]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.Util::followLinks @ bci:61 (line 121) L[0]=_ L[1]=#0 L[2]=R14 L[3]=R28 L[4]=R13 L[5]=_
        # sun.nio.fs.UnixFileSystemProvider::getFileAttributeView @ bci:7 (line 120) L[0]=_ L[1]=_ L[2]=#Ptr0x00000040d81932d0 L[3]=_ L[4]=R7 L[5]=_
        # sun.nio.fs.LinuxFileSystemProvider::getFileAttributeView @ bci:48 (line 68) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:51 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=R29 L[1]=R7 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=R29 L[1]=R7 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=R29 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {t2=Oop x29=Oop c_rarg4=Oop c_rarg5=NarrowOop [8]=Oop [56]=Oop [72]=Oop off=2284/0x8ec}
08f0 +  blt  R13, R28, B91	#@cmpI_branch  P=0.499909 C=2755.000000

08f4    B95: #	out( B97 ) &lt;- in( B94 )  Freq: 0.24209
08f4 +  j  B97	#@branch

08f8    B96: #	out( B97 ) &lt;- in( B88 )  Freq: 0.242179
08f8 +  li R9, #1	# int, #@loadConI

08fc    B97: #	out( B376 B98 ) &lt;- in( B95 B96 )  Freq: 0.484269
08fc +  mv  R28, java/lang/Class:exact *	# ptr, #@loadConP
0914 +  lw  R8, [R28, #156]	# int, #@loadI ! Field: java/lang/System.allowSecurityManager (constant)
0918 +  li R31, #1	# int, #@loadConI
091c +  far_beq  R8, R31, B376	#@far_cmpI_branch  P=0.000000 C=5721.000000

0924    B98: #	out( B377 B99 ) &lt;- in( B97 )  Freq: 0.484269
0924 +  lwu  R28, [R28, #124]	# loadN, compressed ptr, #@loadN ! Field: volatile java/lang/System.security
0928 +  #@membar_acquire
	fence ir iorw
092c +  decode_heap_oop  R8, R28	#@decodeHeapOop
0930 +  far_bne   R8, zr, B377	#@far_cmpP_imm0_branch  P=0.000000 C=5538.000000

0938    B99: #	out( B274 B100 ) &lt;- in( B98 )  Freq: 0.484269
0938 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0938    ld  R10, [R23, #288]	# ptr, #@loadP
093c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
093c    ld  R28, [R23, #304]	# ptr, #@loadP
0940 +  addi  R30, R10, #128	# ptr, #@addP_reg_imm
0944 +  bgeu  R30, R28, B274	#@cmpP_branch  P=0.000100 C=-1.000000

0948    B100: #	out( B101 ) &lt;- in( B99 )  Freq: 0.48422
0948 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0948    sd  R30, [R23, #288]	# ptr, #@storeP
094c +  li R28, #1	# long, #@loadConL
0950 +  mv  R30, narrowklass: precise klass sun/nio/fs/UnixFileAttributes: 0x00000040d0457910:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0960 +  sd  R28, [R10]	# long, #@storeL
0964 +  sw  R30, [R10, #8]	# compressed klass ptr, #@storeNKlass
0968 +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
096c +  sw  zr, [R10, #12]	# int, #@storeimmI0
0970 +  ClearArray #14, R28	#@clearArray_imm_reg

09a8    B101: #	out( B268 B102 ) &lt;- in( B275 B100 )  Freq: 0.484269
09a8    
09a8    MEMBAR-store-store	#@membar_storestore
09ac +  spill R10 -&gt; R30	# spill size = 64
09b0 +  encode_heap_oop  R11, R7	#@encodeHeapOop
09b4 +  # checkcastPP of R30, #@checkCastPP
09b4    bne  R9, zr, B268	#@cmpI_reg_imm0_branch  P=0.000363 C=2756.000000

09b8    B102: #	out( B427 B103 ) &lt;- in( B101 )  Freq: 0.484093
09b8 +  lwu  R10, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
09bc +  mv  R28, java/lang/Class:exact *	# ptr, #@loadConP
09d4 +  lwu  R31, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
09d8    spill [sp, #72] -&gt; R14	# spill size = 64
09dc +  lwu  R16, [R14, #68]	# loadN, compressed ptr, #@loadN ! Field: java/lang/Thread.threadLocals
09e0 +  lwu  R28, [R28, #116]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/NativeBuffers.threadLocal
09e4 +  decode_heap_oop  R10, R10	#@decodeHeapOop
09e8    lbu  R10, [R10, #12]	# byte, #@loadUB ! Field: sun/nio/fs/UnixFileSystem.needToResolveAgainstDefaultDirectory
09ec    NullCheck R10

09ec    B103: #	out( B379 B104 ) &lt;- in( B102 )  Freq: 0.484093
09ec +  decode_heap_oop  R12, R31	#@decodeHeapOop
09f0 +  far_bne  R10, zr, B379	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2869.000000

09f8    B104: #	out( B428 B105 ) &lt;- in( B103 )  Freq: 0.484092
09f8    lwu  R15, [R12, #12]	# range, #@loadRange
09fc    NullCheck R12

09fc    B105: #	out( B380 B106 ) &lt;- in( B104 )  Freq: 0.484092
09fc +  decode_heap_oop  R16, R16	#@decodeHeapOop
0a00 +  decode_heap_oop  R17, R28	#@decodeHeapOop
0a04 +  far_bleu  R15, zr, B380	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000000 C=10257.000000

0a0c    B106: #	out( B429 B107 ) &lt;- in( B105 )  Freq: 0.484092
0a0c    lw  R31, [R17, #12]	# int, #@loadI ! Field: java/lang/ThreadLocal.threadLocalHashCode (constant)
0a10    NullCheck R17

0a10    B107: #	out( B437 B108 ) &lt;- in( B106 )  Freq: 0.484091
0a10 +  addiw  R18, R15, #1	#@addI_reg_imm
0a14    lwu  R10, [R16, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap.table
0a18    NullCheck R16

0a18    B108: #	out( B430 B109 ) &lt;- in( B107 )  Freq: 0.484091
0a18 +  decode_heap_oop  R20, R10	#@decodeHeapOop
0a1c    lwu  R19, [R20, #12]	# range, #@loadRange
0a20    NullCheck R20

0a20    B109: #	out( B343 B110 ) &lt;- in( B108 )  Freq: 0.48409
0a20 +  addiw  R10, R19, #-1	#@addI_reg_imm
0a24 +  andr  R13, R31, R10	#@andI_reg_reg
0a28 +  addw  R31, R13, zr	#@convI2L_reg_reg
0a2c +  slli  R31, R31, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0a30 +  add R31, R20, R31	# ptr, #@addP_reg_reg
0a34 +  far_bleu  R19, zr, B343	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

0a3c    B110: #	out( B438 B111 ) &lt;- in( B109 )  Freq: 0.48409
0a3c +  lwu  R10, [R31, #16]	# loadN, compressed ptr, #@loadN
0a40 +  decode_heap_oop  R19, R10	#@decodeHeapOop
0a44    lwu  R10, [R19, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
0a48    NullCheck R19

0a48    B111: #	out( B344 B112 ) &lt;- in( B110 )  Freq: 0.48409
0a48    
0a48 +  lwu  R31, [R19, #28]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap$Entry.value
0a4c +  decode_heap_oop  R31, R31	#@decodeHeapOop
0a50 +  far_bne  R10, R28, B344	#@far_cmpN_branch  P=0.000001 C=-1.000000

0a58    B112: #	out( B431 B113 ) &lt;- in( B111 )  Freq: 0.484089
0a58    lwu  R28, [R31, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0a5c    NullCheck R31

0a5c    B113: #	out( B401 B114 ) &lt;- in( B112 )  Freq: 0.484089
0a5c +  mv  R13, narrowklass: precise klass [Lsun/nio/fs/NativeBuffer;: 0x00000040d01a3610:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0a6c +  far_bne  R28, R13, B401	#@far_cmpN_branch  P=0.000000 C=-1.000000

0a74    B114: #	out( B345 B115 ) &lt;- in( B113 )  Freq: 0.484089
0a74 +  # checkcastPP of R31, #@checkCastPP
0a74    lwu  R28, [R31, #12]	# range, #@loadRange
0a78 +  far_bleu  R28, zr, B345	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

0a80    B115: #	out( B439 B116 ) &lt;- in( B114 )  Freq: 0.484088
0a80 +  lwu  R28, [R31, #16]	# loadN, compressed ptr, #@loadN
0a84 +  decode_heap_oop  R21, R28	#@decodeHeapOop
0a88    lw  R8, [R21, #12]	# int, #@loadI ! Field: sun/nio/fs/NativeBuffer.size
0a8c    NullCheck R21

0a8c    B116: #	out( B366 B117 ) &lt;- in( B115 )  Freq: 0.484088
0a8c +  far_blt  R8, R18, B366	#@far_cmpI_branch  P=0.000000 C=2869.000000

0a94    B117: #	out( B250 B118 ) &lt;- in( B116 )  Freq: 0.484088
0a94 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0a94    lb  R13, [R23, #56]	# byte, #@loadB
0a98 +  lwu  R18, [R21, #28]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/NativeBuffer.owner
0a9c +  bne  R13, zr, B250	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0aa0    B118: #	out( B224 B119 ) &lt;- in( B367 B252 B250 B117 )  Freq: 0.484088
0aa0 +  decode_heap_oop  R10, R18	#@decodeHeapOop
0aa4 +  sw  rheapbase, [R31, #16]	# compressed ptr (rheapbase==0), #@storeImmN0
0aa8 +  ld  R24, [R21, #16]	# int, #@loadL ! Field: sun/nio/fs/NativeBuffer.address
0aac +  beq  R10, R7, B224	#@cmpP_branch  P=0.027884 C=2869.000000

0ab0    B119: #	out( B260 B120 ) &lt;- in( B118 )  Freq: 0.470589
0ab0 +  spill R7 -&gt; R18	# spill size = 64
0ab4 +  li R7, #1	# int, #@loadConI
0ab8    
0ab8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0ab8    sb  R7, [R23, #968]	# byte, #@storeB
0abc    spill R28 -&gt; [sp, #0]	# spill size = 32
0ac0    
0ac0    
0ac0    
0ac0 +  addi  R10, R12, #16	# ptr, #@addP_reg_imm
0ac4    spill R9 -&gt; R19	# spill size = 32
0ac8 +  addw  R25, R15, zr	#@convI2L_reg_reg
0acc    spill R11 -&gt; R22	# spill size = 32
0ad4 +  spill R30 -&gt; R20	# spill size = 64
0ad8 +  spill R14 -&gt; R8	# spill size = 64
0adc +  spill R29 -&gt; R9	# spill size = 64
0ae0 +  spill R25 -&gt; R12	# spill size = 64
0ae4 +  mv  R11, R24	# long -&gt; ptr, #@castX2P
0ae8    CALL, runtime leaf nofp 0x000000401396e3c0	#@CallLeafNoFPDirect unsafe_arraycopy
        No JVM State Info
        # 
0aec +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0aec    sb zr, [R23, #968]	# byte, #@storeimmB0
0af0    
0af0 +  ld  R24, [R21, #16]	# int, #@loadL ! Field: sun/nio/fs/NativeBuffer.address
0af4 +  mv  R7, R24	# long -&gt; ptr, #@castX2P
0af8 +  add R7, R7, R25	# ptr, #@addP_reg_reg
0afc +  sb zr, [R7]	# byte, #@storeimmB0
0b00 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0b00    lb  R28, [R23, #56]	# byte, #@loadB
0b04 +  bne  R28, zr, B260	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0b08    B120: #	out( B122 B121 ) &lt;- in( B373 B262 B260 B119 )  Freq: 0.470589
0b08 +  mv  R28, R21	# ptr -&gt; long, #@castP2X
0b0c    spill R18 -&gt; R7	# spill size = 64
0b10 +  mv  R29, R7	# ptr -&gt; long, #@castP2X
0b14 +  xorr  R29, R29, R28	#@xorL_reg_reg
0b18 +  srli  R29, R29, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0b1c +  sw  R22, [R21, #28]	# compressed ptr, #@storeN ! Field: sun/nio/fs/NativeBuffer.owner
0b20 +  beq  R29, zr, B122	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0b24    B121: #	out( B263 B122 ) &lt;- in( B120 )  Freq: 0.470119
0b24 +  srli  R28, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0b28 +  mv  R29, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
0b34 +  add R10, R29, R28	# ptr, #@addP_reg_reg
0b38 +  lb  R28, [R10]	# byte, #@loadB
0b3c +  li R30, #4	# int, #@loadConI
0b40 +  bne  R28, R30, B263	#@cmpI_branch  P=0.001000 C=-1.000000

0b44    B122: #	out( B123 ) &lt;- in( B267 B121 B120 )  Freq: 0.470589
0b44 +  spill R9 -&gt; R29	# spill size = 64
0b48 +  spill R19 -&gt; R9	# spill size = 32
0b4c +  spill R20 -&gt; R30	# spill size = 64
0b50 +  spill R22 -&gt; [sp, #4]	# spill size = 32

0b54    B123: #	out( B462 B124 ) &lt;- in( B224 B122 )  Freq: 0.484088
0b54 +  spill R21 -&gt; [sp, #48]	# spill size = 64
0b58 +  spill R30 -&gt; [sp, #40]	# spill size = 64
0b5c +  spill R9 -&gt; [sp, #32]	# spill size = 32
0b60 +  spill R7 -&gt; [sp, #24]	# spill size = 64
0b64 +  spill R29 -&gt; [sp, #16]	# spill size = 64
0b68 +  spill R24 -&gt; R11	# spill size = 64
0b6c +  spill R30 -&gt; R12	# spill size = 64
0b70    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect sun.nio.fs.UnixNativeDispatcher::lstat0
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:10 (line 308) L[0]=_ L[1]=_ L[2]=sp + #48 L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=NarrowOop [4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop off=2932/0xb74}

0b74    B124: #	out( B432 B125 ) &lt;- in( B123 )  Freq: 0.484078
        # Block is sole successor of call
0b74 +  mv  R7, java/lang/Class:exact *	# ptr, #@loadConP
0b8c +  lwu  R7, [R7, #116]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/NativeBuffers.threadLocal
0b90 +  lwu  R29, [R8, #68]	# loadN, compressed ptr, #@loadN ! Field: java/lang/Thread.threadLocals
0b94 +  decode_heap_oop  R30, R7	#@decodeHeapOop
0b98 +  decode_heap_oop  R31, R29	#@decodeHeapOop
0b9c    lw  R28, [R30, #12]	# int, #@loadI ! Field: java/lang/ThreadLocal.threadLocalHashCode (constant)
0ba0    NullCheck R30

0ba0    B125: #	out( B440 B126 ) &lt;- in( B124 )  Freq: 0.484078
0ba0    lwu  R29, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap.table
0ba4    NullCheck R31

0ba4    B126: #	out( B433 B127 ) &lt;- in( B125 )  Freq: 0.484077
0ba4 +  decode_heap_oop  R12, R29	#@decodeHeapOop
0ba8    lwu  R29, [R12, #12]	# range, #@loadRange
0bac    NullCheck R12

0bac    B127: #	out( B346 B128 ) &lt;- in( B126 )  Freq: 0.484077
0bac +  addiw  R11, R29, #-1	#@addI_reg_imm
0bb0 +  andr  R28, R28, R11	#@andI_reg_reg
0bb4 +  addw  R10, R28, zr	#@convI2L_reg_reg
0bb8 +  slli  R10, R10, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0bbc +  add R10, R12, R10	# ptr, #@addP_reg_reg
0bc0 +  far_bleu  R29, zr, B346	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

0bc8    B128: #	out( B441 B129 ) &lt;- in( B127 )  Freq: 0.484076
0bc8 +  lwu  R29, [R10, #16]	# loadN, compressed ptr, #@loadN
0bcc +  decode_heap_oop  R29, R29	#@decodeHeapOop
0bd0    lwu  R11, [R29, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
0bd4    NullCheck R29

0bd4    B129: #	out( B347 B130 ) &lt;- in( B128 )  Freq: 0.484076
0bd4    
0bd4 +  lwu  R10, [R29, #28]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap$Entry.value
0bd8 +  decode_heap_oop  R10, R10	#@decodeHeapOop
0bdc +  far_bne  R11, R7, B347	#@far_cmpN_branch  P=0.000001 C=-1.000000

0be4    B130: #	out( B434 B131 ) &lt;- in( B129 )  Freq: 0.484076
0be4    lwu  R28, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0be8    NullCheck R10

0be8    B131: #	out( B402 B132 ) &lt;- in( B130 )  Freq: 0.484075
0be8 +  mv  R7, narrowklass: precise klass [Lsun/nio/fs/NativeBuffer;: 0x00000040d01a3610:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0bf8 +  far_bne  R28, R7, B402	#@far_cmpN_branch  P=0.000000 C=-1.000000

0c00    B132: #	out( B348 B133 ) &lt;- in( B131 )  Freq: 0.484075
0c00 +  # checkcastPP of R10, #@checkCastPP
0c00    lwu  R28, [R10, #12]	# range, #@loadRange
0c04 +  addi  R9, R10, #16	# ptr, #@addP_reg_imm
0c08 +  far_bleu  R28, zr, B348	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

0c10    B133: #	out( B368 B134 ) &lt;- in( B132 )  Freq: 0.484075
0c10 +  lwu  R7, [R9]	# loadN, compressed ptr, #@loadN
0c14 +  decode_heap_oop  R8, R7	#@decodeHeapOop
0c18 +  far_bne   R8, zr, B368	#@far_cmpP_imm0_branch  P=0.000000 C=2869.000000

0c20    B134: #	out( B253 B135 ) &lt;- in( B133 )  Freq: 0.484074
0c20 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c20    lb  R28, [R23, #56]	# byte, #@loadB
0c24 +  bne  R28, zr, B253	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0c28    B135: #	out( B137 B136 ) &lt;- in( B369 B255 B253 B134 )  Freq: 0.484074
0c28 +  mv  R7, R9	# ptr -&gt; long, #@castP2X
0c2c    spill [sp, #48] -&gt; R28	# spill size = 64
0c30 +  mv  R28, R28	# ptr -&gt; long, #@castP2X
0c30 +  xorr  R28, R28, R7	#@xorL_reg_reg
0c34 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0c38    spill [sp, #0] -&gt; R29	# spill size = 32
0c3c +  sw  R29, [R9]	# compressed ptr, #@storeN
0c40 +  beq  R28, zr, B137	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0c44    B136: #	out( B256 B137 ) &lt;- in( B135 )  Freq: 0.48359
0c44 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0c48 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
0c54 +  add R10, R28, R7	# ptr, #@addP_reg_reg
0c58 +  lb  R7, [R10]	# byte, #@loadB
0c5c +  li R29, #4	# int, #@loadConI
0c60 +  bne  R7, R29, B256	#@cmpI_branch  P=0.001000 C=-1.000000

0c64    B137: #	out( B276 B138 ) &lt;- in( B258 B259 B256 B136 B135 B269 )  Freq: 0.48425
0c64 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c64    ld  R10, [R23, #288]	# ptr, #@loadP
0c68 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c68    ld  R7, [R23, #304]	# ptr, #@loadP
0c6c +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
0c70 +  bgeu  R28, R7, B276	#@cmpP_branch  P=0.000100 C=-1.000000

0c74    B138: #	out( B139 ) &lt;- in( B137 )  Freq: 0.484202
0c74 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c74    sd  R28, [R23, #288]	# ptr, #@storeP
0c78 +  li R7, #1	# long, #@loadConL
0c7c +  mv  R28, narrowklass: precise klass sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes: 0x00000040d81d8810:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0c8c +  sd  R7, [R10]	# long, #@storeL
0c90 +  sw  R28, [R10, #8]	# compressed klass ptr, #@storeNKlass
0c94 +  sw  zr, [R10, #12]	# int, #@storeimmI0

0c98    B139: #	out( B424 B140 ) &lt;- in( B277 B138 )  Freq: 0.48425
0c98    spill [sp, #40] -&gt; R7	# spill size = 64
0c9c +  encode_heap_oop  R7, R7	#@encodeHeapOop
0ca0    
0ca0 +  # checkcastPP of R10, #@checkCastPP
0ca0    sw  R7, [R10, #12]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes.attrs
0ca4 +  #@membar_release
	fence iorw ow
0ca8 +  spill [sp, #16] -&gt; R31	# spill size = 64
0cac +  lwu  R28, [R31, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker.stack
0cb0 +  spill R10 -&gt; R12	# spill size = 64
0cb4 +  # checkcastPP of R12, #@checkCastPP
0cb4    decode_heap_oop  R7, R28	#@decodeHeapOop
0cb8    lwu  R28, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/ArrayDeque.elements
0cbc    NullCheck R7

0cbc    B140: #	out( B425 B141 ) &lt;- in( B139 )  Freq: 0.48425
0cbc +  lw  R30, [R7, #12]	# int, #@loadI ! Field: java/util/ArrayDeque.head
0cc0 +  lw  R7, [R7, #16]	# int, #@loadI ! Field: java/util/ArrayDeque.tail
0cc4 +  decode_heap_oop  R28, R28	#@decodeHeapOop
0cc8    lwu  R29, [R28, #12]	# range, #@loadRange
0ccc    NullCheck R28

0ccc    B141: #	out( B378 B142 ) &lt;- in( B140 )  Freq: 0.484249
0ccc +  subw  R7, R7, R30	#@subI_reg_reg
0cd0 +  sraiw R28, R28, 31	#@cmpLTMask_reg_reg
0cd4 +  andr  R29, R28, R29	#@andI_reg_reg
0cd8 +  addw  R8, R29, R7	#@addI_reg_reg
0cdc +  lw  R28, [R31, #12]	# int, #@loadI ! Field: java/nio/file/FileTreeWalker.maxDepth
0ce0 +  lwu  R30, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0ce4 +  mv  R7, narrowklass: precise klass sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes: 0x00000040d81d8810:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0cf4 +  far_bge  R8, R28, B378	#@far_cmpI_branch  P=0.000000 C=2750.000000

0cfc    B142: #	out( B342 B143 ) &lt;- in( B141 )  Freq: 0.484249
0cfc +  far_bne  R30, R7, B342	#@far_cmpN_branch  P=0.000001 C=-1.000000

0d04    B143: #	out( B426 B144 ) &lt;- in( B142 )  Freq: 0.484248
0d04 +  spill R12 -&gt; R30	# spill size = 64
0d08 +  # checkcastPP of R30, #@checkCastPP
0d08    lwu  R28, [R30, #12]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes.attrs
0d0c +  decode_heap_oop  R7, R28	#@decodeHeapOop
0d10    lw  R7, [R7, #12]	# int, #@loadI ! Field: sun/nio/fs/UnixFileAttributes.st_mode
0d14    NullCheck R7

0d14    B144: #	out( B195 B145 ) &lt;- in( B143 )  Freq: 0.484248
0d14 +  li R29, #61440	# int, #@loadConI
0d18 +  andr  R7, R7, R29	#@andI_reg_reg
0d1c +  li R29, #16384	# int, #@loadConI
0d20 +  beq  R7, R29, B195	#@cmpI_branch  P=0.028364 C=2750.000000

0d24    B145: #	out( B278 B146 ) &lt;- in( B144 )  Freq: 0.470513
0d24 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0d24    ld  R10, [R23, #288]	# ptr, #@loadP
0d28 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0d28    ld  R7, [R23, #304]	# ptr, #@loadP
0d2c +  addi  R28, R10, #32	# ptr, #@addP_reg_imm
0d30 +  bgeu  R28, R7, B278	#@cmpP_branch  P=0.000100 C=-1.000000

0d34    B146: #	out( B147 ) &lt;- in( B145 )  Freq: 0.470466
0d34 +  li R7, #1	# long, #@loadConL
0d38 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0d38    sd  R28, [R23, #288]	# ptr, #@storeP
0d3c +  sd  R7, [R10]	# long, #@storeL
0d40 +  mv  R7, narrowklass: precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d0a1c950:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0d50 +  sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
0d54 +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
0d58 +  sw  zr, [R10, #12]	# int, #@storeimmI0
0d5c +  ClearArray #2, R28	#@clearArray_imm_reg

0d64    B147: #	out( B532 B148 ) &lt;- in( B279 B146 )  Freq: 0.470513
0d64    
0d64    MEMBAR-store-store	#@membar_storestore
0d68 +  spill R10 -&gt; R8	# spill size = 64
0d6c +  # checkcastPP of R8, #@checkCastPP
0d6c    mv  R12, java/nio/file/FileTreeWalker$EventType:exact *	# ptr, #@loadConP
0d84    spill R8 -&gt; R11	# spill size = 64
0d88 +  spill [sp, #24] -&gt; R13	# spill size = 64
0d8c +  spill R30 -&gt; R14	# spill size = 64
0d90 +  mv  R15, NULL	# NULL ptr, #@loadConP0
0d94    spill R31 -&gt; [sp, #0]	# spill size = 64
0d98    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeWalker$Event::&lt;init&gt;
        # java.nio.file.FileTreeWalker$Event::&lt;init&gt; @ bci:5 (line 141) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.nio.file.FileTreeWalker::visit @ bci:76 (line 289) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=R8
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #0 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [56]=Oop off=3484/0xd9c}

0d9c    B148: #	out( B149 ) &lt;- in( B147 )  Freq: 0.470503
        # Block is sole successor of call
0d9c +  spill R8 -&gt; [sp, #0]	# spill size = 64

0da0    B149: #	out( B150 ) &lt;- in( B223 B148 B193 )  Freq: 0.49898
0da0 +  mv  R8, narrowoop: java/nio/file/FileTreeWalker$EventType:exact *	# compressed ptr, #@loadConN

0db0    B150: #	out( B534 B151 ) &lt;- in( B149 B184 ) Loop( B150-B184 inner ) Freq: 0.514227
0db0    spill [sp, #0] -&gt; R11	# spill size = 64
0db4    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeWalker$Event::ioeException
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:20 (line 85) L[0]=sp + #8 L[1]=sp + #0 L[2]=_
        # OopMap {fp=NarrowOop [0]=Oop [8]=Oop off=3512/0xdb8}

0db8    B151: #	out( B323 B152 ) &lt;- in( B150 )  Freq: 0.514216
        # Block is sole successor of call
0db8 +  spill [sp, #0] -&gt; R9	# spill size = 64
0dbc +  lwu  R7, [R9, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.type
0dc0 +  bne   R10, zr, B323	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

0dc4    B152: #	out( B181 B153 ) &lt;- in( B151 )  Freq: 0.514216
0dc4 +  beq  R7, R8, B181	#@cmpN_branch  P=0.029671 C=2831.000000

0dc8    B153: #	out( B234 B154 ) &lt;- in( B152 )  Freq: 0.498958
0dc8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0dc8    lb  R28, [R23, #56]	# byte, #@loadB
0dcc +  bne  R28, zr, B234	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0dd0    B154: #	out( B155 ) &lt;- in( B153 )  Freq: 0.498459
0dd0 +  spill [sp, #8] -&gt; R18	# spill size = 64

0dd4    B155: #	out( B161 B156 ) &lt;- in( B362 B236 B234 B154 )  Freq: 0.498958
0dd4 +  mv  R7, R18	# ptr -&gt; long, #@castP2X
0dd8 +  mv  R28, R9	# ptr -&gt; long, #@castP2X
0ddc +  xorr  R28, R28, R7	#@xorL_reg_reg
0de0 +  encode_heap_oop  R29, R9	#@encodeHeapOop
0de4 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0de8 +  sw  R29, [R18, #16]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeIterator.next
0dec +  beq  R28, zr, B161	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0df0    B156: #	out( B161 B157 ) &lt;- in( B155 )  Freq: 0.498459
0df0 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0df4 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
0e00 +  add R10, R28, R7	# ptr, #@addP_reg_reg
0e04 +  lb  R28, [R10]	# byte, #@loadB
0e08 +  li R29, #4	# int, #@loadConI
0e0c +  beq  R28, R29, B161	#@cmpI_branch  P=0.999000 C=-1.000000

0e10    B157: #	out( B161 B158 ) &lt;- in( B156 )  Freq: 0.000498459
0e10 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e10    ld  R7, [R23, #64]	# int, #@loadL
0e14 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e14    ld  R28, [R23, #80]	# ptr, #@loadP
0e18 +  #@membar_volatile
	fence iorw iorw
0e1c +  lb  R29, [R10]	# byte, #@loadB
0e20 +  beq  R29, zr, B161	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

0e24    B158: #	out( B160 B159 ) &lt;- in( B157 )  Freq: 0.00024923
0e24 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
0e28 +  bne  R7, zr, B160	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

0e2c    B159: #	out( B161 ) &lt;- in( B158 )  Freq: 0.000124615
0e2c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e2c    spill R23 -&gt; R11	# spill size = 64
0e30 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
0e60 +  j  B161	#@branch

0e64    B160: #	out( B161 ) &lt;- in( B158 )  Freq: 0.000124615
0e64 +  add R28, R28, R7	# ptr, #@addP_reg_reg
0e68 +  addi  R7, R7, #-8	#@addL_reg_imm
0e6c +  sd  R10, [R28, #-8]	# ptr, #@storeP
0e70 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e70    sd  R7, [R23, #64]	# long, #@storeL

0e74    B161: #	out( N6567 ) &lt;- in( B159 B160 B157 B156 B155 B183 B6 B1 )  Freq: 0.999928
0e74    # pop frame 176
	add  sp, sp, #176
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0ed4 +  ret	// return register, #@Ret

0ed8    B162: #	out( B167 B163 ) &lt;- in( B46 )  Freq: 0.0274952
0ed8 +  li R7, #1	# int, #@loadConI
0edc +  beq  R22, R7, B167	#@cmpI_branch  P=0.506329 C=158.000000

0ee0    B163: #	out( B397 B164 ) &lt;- in( B162 )  Freq: 0.0135736
0ee0 +  li R28, #2	# int, #@loadConI
0ee4 +  far_bne  R22, R28, B397	#@far_cmpI_branch  P=0.000000 C=78.000000

0eec    B164: #	out( B389 B165 ) &lt;- in( B163 )  Freq: 0.0135736
0eec +  li R28, #1	# int, #@loadConI
0ef0 +  far_bleu R22, R28, B389	#@far_cmpU_branch  P=0.000001 C=-1.000000

0ef8    B165: #	out( B167 B166 ) &lt;- in( B164 )  Freq: 0.0135735
0ef8 +  lb  R8, [R20, #17]	# byte, #@loadB
0efc +  li R7, #46	# int, #@loadConI
0f00 +  beq  R8, R7, B167	#@cmpI_branch  P=1.000000 C=78.000000

0f04    B166: #	out( N6567 ) &lt;- in( B165 )  Freq: 6.78677e-09
0f04 +  spill [sp, #8] -&gt; R7	# spill size = 64
0f08 +  li R11, #-187	# int, #@loadConI
0f0c    spill R7 -&gt; [sp, #0]	# spill size = 64
0f10 +  spill R19 -&gt; [sp, #16]	# spill size = 64
0f14 +  spill R19 -&gt; [sp, #24]	# spill size = 64
0f18    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::isSelfOrParent @ bci:25 (line 146) L[0]=_ L[1]=_ STK[0]=R8 STK[1]=#46
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:123 (line 181) L[0]=sp + #16 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [64]=Oop off=3868/0xf1c}
0f1c    #@ShouldNotReachHere

0f28    B167: #	out( B444 B168 ) &lt;- in( B165 B162 )  Freq: 0.0274952
0f28 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0f28    spill R19 -&gt; R7	# spill size = 64
0f2c +  ld  R11, [R23, #920]	# ptr, #@loadP
0f30    spill R7 -&gt; R29	# spill size = 64
0f34 +  lwu zr, [R11]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:182 (line 192) L[0]=R29 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=R29 STK[0]=R29 MON-BOX0=sp+144 MON-OBJ[0]=R29
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=R29 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {x29=Oop c_rarg0=Oop x19=Oop [0]=Oop [8]=Oop [24]=NarrowOop [48]=Oop [56]=Oop [72]=Oop off=3892/0xf34}
0f38    lwu  R7, [R10, #32]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream.streamLock
0f3c    NullCheck R10

0f3c    B168: #	out( B445 B169 ) &lt;- in( B167 )  Freq: 0.0274951
0f3c +  decode_heap_oop  R7, R7	#@decodeHeapOop
0f40    lwu  R28, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock.readerLock
0f44    NullCheck R7

0f44    B169: #	out( B446 B170 ) &lt;- in( B168 )  Freq: 0.0274951
0f44 +  decode_heap_oop  R8, R28	#@decodeHeapOop
0f48    # checkcastPP of R8, #@checkCastPP
0f48    lwu  R7, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0f4c    NullCheck R8

0f4c    B170: #	out( B381 B171 ) &lt;- in( B169 )  Freq: 0.0274951
0f4c +  mv  R29, narrowklass: precise klass java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock: 0x00000040d08c1250:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0f5c +  far_bne  R7, R29, B381	#@far_cmpN_branch  P=0.000001 C=-1.000000

0f64    B171: #	out( B447 B172 ) &lt;- in( B170 )  Freq: 0.027495
0f64 +  # checkcastPP of R8, #@checkCastPP
0f64    lwu  R7, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock.sync
0f68 +  decode_heap_oop  R29, R7	#@decodeHeapOop
0f6c    lw  R31, [R29, #16]	# int, #@loadI ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.state
0f70    NullCheck R29

0f70    B172: #	out( B390 B173 ) &lt;- in( B171 )  Freq: 0.027495
0f70 +  #@membar_acquire
	fence ir iorw
0f74 +  zext.h  R8, R31	# s2ui, #@convS2UI_reg_reg_b
0f78 +  far_bne  R8, zr, B390	#@far_cmpI_reg_imm0_branch  P=0.000000 C=3040.000000

0f80    B173: #	out( B382 B174 ) &lt;- in( B172 )  Freq: 0.027495
0f80 +  lwu  R28, [R29, #20]	# loadN, compressed ptr, #@loadN ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.head
0f84 +  #@membar_acquire
	fence ir iorw
0f88 +  decode_heap_oop  R8, R28	#@decodeHeapOop
0f8c +  srliw  R30, R31, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
0f90 +  far_bne   R8, zr, B382	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0f98    B174: #	out( B391 B175 ) &lt;- in( B173 )  Freq: 0.027495
0f98 +  li R28, #65535	# int, #@loadConI
0fa0 +  far_bge  R30, R28, B391	#@far_cmpI_branch  P=0.000000 C=3040.000000

0fa8    B175: #	out( B392 B176 ) &lt;- in( B174 )  Freq: 0.027495
0fa8 +  #@membar_release
	fence iorw ow
0fac +  li R28, #65536	# int, #@loadConI
0fb0 +  addw  R28, R31, R28	#@addI_reg_reg
0fb4 +  addi  R7, R29, #16	# ptr, #@addP_reg_imm
0fb8    
0fb8 +  cmpxchg_acq [R7], R31, R28	# (int) if [R7] == R31 then [R7] &lt;-- R28
	mv R8, R8 == R31	# R8 &lt;-- (R8 == R31 ? 1 : 0), #@compareAndSwapIAcq
0fd4    
0fd4 +  #@membar_acquire
	fence ir iorw
0fd8 +  far_beq  R8, zr, B392	#@far_cmpI_reg_imm0_branch  P=0.000000 C=3040.000000

0fe0    B176: #	out( B387 B177 ) &lt;- in( B175 )  Freq: 0.0274949
0fe0 +  far_bne  R30, zr, B387	#@far_cmpI_reg_imm0_branch  P=0.000000 C=3040.000000

0fe8    B177: #	out( B280 B178 ) &lt;- in( B176 )  Freq: 0.0274949
0fe8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0fe8    lb  R28, [R23, #56]	# byte, #@loadB
0fec +  bne  R28, zr, B280	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0ff0    B178: #	out( B180 B179 ) &lt;- in( B388 B282 B280 B177 )  Freq: 0.0274949
0ff0 +  mv  R28, R29	# ptr -&gt; long, #@castP2X
0ff4    spill [sp, #72] -&gt; R20	# spill size = 64
0ff8 +  mv  R7, R20	# ptr -&gt; long, #@castP2X
0ffc +  xorr  R7, R7, R28	#@xorL_reg_reg
1000 +  srli  R30, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
1004    spill [sp, #24] -&gt; R7	# spill size = 32
1008 +  sw  R7, [R29, #40]	# compressed ptr, #@storeN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
100c +  beq  R30, zr, B180	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1010    B179: #	out( B283 B180 ) &lt;- in( B178 )  Freq: 0.0274674
1010 +  srli  R28, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1014 +  mv  R30, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1020 +  add R10, R30, R28	# ptr, #@addP_reg_reg
1024 +  lb  R30, [R10]	# byte, #@loadB
1028 +  li R31, #4	# int, #@loadConI
102c +  bne  R30, R31, B283	#@cmpI_branch  P=0.001000 C=-1.000000

1030    B180: #	out( B28 ) &lt;- in( B285 B286 B283 B179 B178 )  Freq: 0.0274949
1030 +  li R28, #1	# int, #@loadConI
1034 +  sw  R28, [R29, #28]	# int, #@storeI ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReaderHoldCount
1038    spill [sp, #8] -&gt; R9	# spill size = 64
103c +  spill [sp, #48] -&gt; R18	# spill size = 64
1040 +  spill [sp, #56] -&gt; R24	# spill size = 64
1044 +  j  B28	#@branch

1048    B181: #	out( B383 B182 ) &lt;- in( B152 )  Freq: 0.0152575
1048 +  spill [sp, #8] -&gt; R28	# spill size = 64
104c +  lwu  R7, [R28, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.walker
1050 +  decode_heap_oop  R11, R7	#@decodeHeapOop
1054 +  far_beq   R11, zr, B383	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

105c    B182: #	out( B531 B183 ) &lt;- in( B181 )  Freq: 0.0152575
105c    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeWalker::next
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:57 (line 94) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=NarrowOop [8]=Oop off=4192/0x1060}

1060    B183: #	out( B161 B184 ) &lt;- in( B182 )  Freq: 0.0152572
        # Block is sole successor of call
1060 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1060    ld  R7, [R23, #920]	# ptr, #@loadP
1064 +  lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:61 (line 95) L[0]=sp + #8 L[1]=R10 L[2]=_
        # OopMap {c_rarg0=Oop fp=NarrowOop [8]=Oop off=4196/0x1064}
1068 +  beq   R10, zr, B161	#@cmpP_imm0_branch  P=0.001059 C=84.000000

106c    B184: #	out( B150 ) &lt;- in( B183 )  Freq: 0.0152411
106c +  spill R10 -&gt; [sp, #0]	# spill size = 64
1070 +  j  B150	#@branch

1074    B185: #	out( B448 B186 ) &lt;- in( B77 )  Freq: 0.0147441
1074 +  spill [sp, #56] -&gt; R29	# spill size = 64
1078 +  lwu  R7, [R29, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.stream
107c +  decode_heap_oop  R30, R7	#@decodeHeapOop
1080    lwu  R28, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
1084    NullCheck R30

1084    B186: #	out( B385 B187 ) &lt;- in( B185 )  Freq: 0.0147441
1084 +  mv  R7, narrowklass: precise klass sun/nio/fs/UnixSecureDirectoryStream: 0x00000040d09eb840:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1094 +  far_bne  R28, R7, B385	#@far_cmpN_branch  P=0.000001 C=-1.000000

109c    B187: #	out( B442 B188 ) &lt;- in( B186 )  Freq: 0.014744
109c +  # checkcastPP of R30, #@checkCastPP
109c    spill R29 -&gt; [sp, #0]	# spill size = 64
10a0 +  spill R30 -&gt; R11	# spill size = 64
10a4    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixSecureDirectoryStream::close
        # java.nio.file.FileTreeWalker::next @ bci:76 (line 361) L[0]=sp + #48 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [48]=Oop off=4264/0x10a8}

10a8    B188: #	out( B384 B189 ) &lt;- in( B187 )  Freq: 0.0147438
        # Block is sole successor of call
10a8 +  spill [sp, #48] -&gt; R7	# spill size = 64
10ac +  lwu  R28, [R7, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker.stack
10b0 +  decode_heap_oop  R11, R28	#@decodeHeapOop
10b4 +  far_beq   R11, zr, B384	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

10bc    B189: #	out( B530 B190 ) &lt;- in( B188 )  Freq: 0.0147437
10bc    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.ArrayDeque::removeFirst
        # java.util.ArrayDeque::pop @ bci:1 (line 593) L[0]=_
        # java.nio.file.FileTreeWalker::next @ bci:109 (line 369) L[0]=_ L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop off=4288/0x10c0}

10c0    B190: #	out( B315 B191 ) &lt;- in( B189 )  Freq: 0.0147434
        # Block is sole successor of call
10c0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
10c0    ld  R10, [R23, #288]	# ptr, #@loadP
10c4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
10c4    ld  R7, [R23, #304]	# ptr, #@loadP
10c8 +  addi  R28, R10, #32	# ptr, #@addP_reg_imm
10cc +  bgeu  R28, R7, B315	#@cmpP_branch  P=0.000100 C=-1.000000

10d0    B191: #	out( B192 ) &lt;- in( B190 )  Freq: 0.014742
10d0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
10d0    sd  R28, [R23, #288]	# ptr, #@storeP
10d4 +  li R7, #1	# long, #@loadConL
10d8 +  mv  R28, narrowklass: precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d0a1c950:Constant:exact *	# compressed klass ptr, #@loadConNKlass
10e8 +  sd  R7, [R10]	# long, #@storeL
10ec +  sw  R28, [R10, #8]	# compressed klass ptr, #@storeNKlass
10f0 +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
10f4 +  sw  zr, [R10, #12]	# int, #@storeimmI0
10f8 +  ClearArray #2, R28	#@clearArray_imm_reg

1100    B192: #	out( B529 B193 ) &lt;- in( B316 B191 )  Freq: 0.0147434
1100    
1100    MEMBAR-store-store	#@membar_storestore
1104 +  spill [sp, #0] -&gt; R7	# spill size = 64
1108 +  lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.dir
110c +  spill R10 -&gt; R8	# spill size = 64
1110 +  decode_heap_oop  R13, R28	#@decodeHeapOop
1114 +  # checkcastPP of R8, #@checkCastPP
1114    mv  R12, java/nio/file/FileTreeWalker$EventType:exact *	# ptr, #@loadConP
112c    spill R8 -&gt; R11	# spill size = 64
1130 +  mv  R14, NULL	# NULL ptr, #@loadConP0
1134    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeWalker$Event::&lt;init&gt;
        # java.nio.file.FileTreeWalker::next @ bci:126 (line 370) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=R8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop off=4408/0x1138}

1138    B193: #	out( B149 ) &lt;- in( B192 )  Freq: 0.0147431
        # Block is sole successor of call
1138 +  spill R8 -&gt; [sp, #0]	# spill size = 64
113c +  j  B149	#@branch

1140    B194: #	out( B72 ) &lt;- in( B44 )  Freq: 0.0142018
1140 +  li R28, #1	# int, #@loadConI
1144    spill [sp, #0] -&gt; R19	# spill size = 64
1148 +  sb  R28, [R19, #12]	# byte, #@storeB ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.atEof
114c +  mv  R18, NULL	# NULL ptr, #@loadConP0
1150 +  j  B72	#@branch

1154    B195: #	out( B398 B196 ) &lt;- in( B144 )  Freq: 0.013735
1154 +  lbu  R8, [R31, #16]	# byte, #@loadUB ! Field: java/nio/file/FileTreeWalker.followLinks
1158 +  far_bne  R8, zr, B398	#@far_cmpI_reg_imm0_branch  P=0.000000 C=78.000000

1160    B196: #	out( B443 B197 ) &lt;- in( B195 )  Freq: 0.013735
1160 +  spill R30 -&gt; [sp, #32]	# spill size = 64
1164 +  spill [sp, #24] -&gt; R11	# spill size = 64
1168    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.nio.file.Files::newDirectoryStream
        # java.nio.file.FileTreeWalker::visit @ bci:131 (line 301) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [56]=Oop off=4460/0x116c}

116c    B197: #	out( B317 B198 ) &lt;- in( B196 )  Freq: 0.0137348
        # Block is sole successor of call
116c +  spill R10 -&gt; R8	# spill size = 64
1170 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1170    ld  R10, [R23, #288]	# ptr, #@loadP
1174    spill [sp, #16] -&gt; R30	# spill size = 64
1178 +  lwu  R28, [R30, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker.stack
117c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
117c    ld  R29, [R23, #304]	# ptr, #@loadP
1180 +  addi  R7, R10, #32	# ptr, #@addP_reg_imm
1184 +  decode_heap_oop  R31, R28	#@decodeHeapOop
1188 +  bgeu  R7, R29, B317	#@cmpP_branch  P=0.000100 C=-1.000000

118c    B198: #	out( B199 ) &lt;- in( B197 )  Freq: 0.0137334
118c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
118c    sd  R7, [R23, #288]	# ptr, #@storeP
1190 +  li R7, #1	# long, #@loadConL
1194 +  sd  R7, [R10]	# long, #@storeL
1198 +  mv  R7, narrowklass: precise klass java/nio/file/FileTreeWalker$DirectoryNode: 0x00000040d09f6a90:Constant:exact *	# compressed klass ptr, #@loadConNKlass
11a8 +  sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
11ac +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
11b0 +  sw  zr, [R10, #12]	# int, #@storeimmI0
11b4    ClearArray #2, R28	#@clearArray_imm_reg
11bc    spill R31 -&gt; [sp, #40]	# spill size = 64

11c0    B199: #	out( B528 B200 ) &lt;- in( B318 B198 )  Freq: 0.0137348
11c0    
11c0 +  spill R10 -&gt; R7	# spill size = 64
11c4 +  # checkcastPP of R7, #@checkCastPP
11c4    spill R7 -&gt; [sp, #48]	# spill size = 64
11c8 +  spill [sp, #32] -&gt; R11	# spill size = 64
11cc    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes::fileKey
        # java.nio.file.FileTreeWalker::visit @ bci:177 (line 311) L[0]=_ L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=R8 L[7]=_ STK[0]=sp + #40 STK[1]=sp + #48 STK[2]=sp + #48 STK[3]=sp + #24
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=4560/0x11d0}

11d0    B200: #	out( B293 B201 ) &lt;- in( B199 )  Freq: 0.0137345
        # Block is sole successor of call
11d0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
11d0    lb  R7, [R23, #56]	# byte, #@loadB
11d4    spill R10 -&gt; R9	# spill size = 64
11d8 +  bne  R7, zr, B293	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

11dc    B201: #	out( B202 ) &lt;- in( B200 )  Freq: 0.0137207
11dc +  spill [sp, #48] -&gt; R20	# spill size = 64

11e0    B202: #	out( B204 B203 ) &lt;- in( B393 B295 B293 B201 )  Freq: 0.0137345
11e0 +  mv  R7, R20	# ptr -&gt; long, #@castP2X
11e4    spill [sp, #24] -&gt; R18	# spill size = 64
11e8 +  mv  R28, R18	# ptr -&gt; long, #@castP2X
11ec +  xorr  R28, R28, R7	#@xorL_reg_reg
11f0 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
11f4    spill R8 -&gt; R21	# spill size = 64
11f8 +  encode_heap_oop  R19, R21	#@encodeHeapOop
11fc    spill R9 -&gt; R22	# spill size = 64
1200 +  encode_heap_oop  R9, R9	#@encodeHeapOop
1204    spill [sp, #4] -&gt; R30	# spill size = 32
1208 +  sw  R30, [R20, #16]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.dir
120c +  beq  R28, zr, B204	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1210    B203: #	out( B299 B204 ) &lt;- in( B202 )  Freq: 0.0137207
1210 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1214 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1220 +  add R10, R28, R7	# ptr, #@addP_reg_reg
1224 +  lb  R28, [R10]	# byte, #@loadB
1228 +  li R7, #4	# int, #@loadConI
122c +  bne  R28, R7, B299	#@cmpI_branch  P=0.001000 C=-1.000000

1230    B204: #	out( B287 B205 ) &lt;- in( B301 B302 B299 B203 B202 )  Freq: 0.0137345
1230 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1230    lb  R7, [R23, #56]	# byte, #@loadB
1234 +  bne  R7, zr, B287	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1238    B205: #	out( B208 B206 ) &lt;- in( B394 B289 B287 B204 )  Freq: 0.0137345
1238 +  mv  R28, R20	# ptr -&gt; long, #@castP2X
123c +  mv  R7, R22	# ptr -&gt; long, #@castP2X
1240 +  xorr  R7, R7, R28	#@xorL_reg_reg
1244 +  srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
1248 +  sw  R9, [R20, #20]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.key
124c +  beq  R7, zr, B208	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1250    B206: #	out( B208 B207 ) &lt;- in( B205 )  Freq: 0.0137207
1250 +  beq   R22, zr, B208	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

1254    B207: #	out( B303 B208 ) &lt;- in( B206 )  Freq: 0.013707
1254 +  srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1258 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1264 +  add R10, R28, R7	# ptr, #@addP_reg_reg
1268 +  lb  R28, [R10]	# byte, #@loadB
126c +  li R29, #4	# int, #@loadConI
1270 +  bne  R28, R29, B303	#@cmpI_branch  P=0.001000 C=-1.000000

1274    B208: #	out( B290 B209 ) &lt;- in( B305 B306 B303 B207 B206 B205 )  Freq: 0.0137345
1274 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1274    lb  R7, [R23, #56]	# byte, #@loadB
1278 +  bne  R7, zr, B290	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

127c    B209: #	out( B212 B210 ) &lt;- in( B395 B292 B290 B208 )  Freq: 0.0137345
127c +  mv  R28, R20	# ptr -&gt; long, #@castP2X
1280 +  mv  R7, R21	# ptr -&gt; long, #@castP2X
1284 +  xorr  R7, R7, R28	#@xorL_reg_reg
1288 +  srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
128c +  sw  R19, [R20, #24]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.stream
1290 +  beq  R7, zr, B212	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1294    B210: #	out( B212 B211 ) &lt;- in( B209 )  Freq: 0.0137207
1294 +  beq   R21, zr, B212	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

1298    B211: #	out( B307 B212 ) &lt;- in( B210 )  Freq: 0.013707
1298 +  srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
129c +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
12a8 +  add R10, R28, R7	# ptr, #@addP_reg_reg
12ac +  lb  R28, [R10]	# byte, #@loadB
12b0 +  li R7, #4	# int, #@loadConI
12b4 +  bne  R28, R7, B307	#@cmpI_branch  P=0.001000 C=-1.000000

12b8    B212: #	out( B527 B213 ) &lt;- in( B309 B310 B307 B211 B210 B209 )  Freq: 0.0137345
12b8 +  spill R20 -&gt; R8	# spill size = 64
12bc +  spill R21 -&gt; R11	# spill size = 64
12c0    CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.nio.file.DirectoryStream::iterator
        # java.nio.file.FileTreeWalker$DirectoryNode::&lt;init&gt; @ bci:21 (line 78) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=R8
        # java.nio.file.FileTreeWalker::visit @ bci:184 (line 311) L[0]=_ L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #40 STK[1]=R8
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop off=4828/0x12dc}

12dc    B213: #	out( B296 B214 ) &lt;- in( B212 )  Freq: 0.0137342
        # Block is sole successor of call
12dc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
12dc    lb  R28, [R23, #56]	# byte, #@loadB
12e0    spill R10 -&gt; R9	# spill size = 64
12e4 +  bne  R28, zr, B296	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

12e8    B214: #	out( B215 ) &lt;- in( B213 )  Freq: 0.0137205
12e8 +  spill R8 -&gt; R18	# spill size = 64

12ec    B215: #	out( B218 B216 ) &lt;- in( B396 B298 B296 B214 )  Freq: 0.0137342
12ec +  mv  R28, R18	# ptr -&gt; long, #@castP2X
12f0    spill R9 -&gt; R30	# spill size = 64
12f4 +  mv  R7, R30	# ptr -&gt; long, #@castP2X
12f8 +  xorr  R7, R7, R28	#@xorL_reg_reg
12fc +  encode_heap_oop  R29, R30	#@encodeHeapOop
1300 +  srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
1304 +  sw  R29, [R18, #28]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.iterator
1308 +  beq  R7, zr, B218	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

130c    B216: #	out( B218 B217 ) &lt;- in( B215 )  Freq: 0.0137205
130c +  beq   R30, zr, B218	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

1310    B217: #	out( B311 B218 ) &lt;- in( B216 )  Freq: 0.0137068
1310 +  srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1314 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1320 +  add R10, R28, R7	# ptr, #@addP_reg_reg
1324 +  lb  R28, [R10]	# byte, #@loadB
1328 +  li R29, #4	# int, #@loadConI
132c +  bne  R28, R29, B311	#@cmpI_branch  P=0.001000 C=-1.000000

1330    B218: #	out( B386 B219 ) &lt;- in( B313 B314 B311 B217 B216 B215 )  Freq: 0.0137342
1330 +  #@membar_release
	fence iorw ow
1334 +  spill [sp, #40] -&gt; R7	# spill size = 64
1338 +  far_beq   R7, zr, B386	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

1340    B219: #	out( B526 B220 ) &lt;- in( B218 )  Freq: 0.0137342
1340 +  spill [sp, #40] -&gt; R11	# spill size = 64
1344 +  spill R18 -&gt; R12	# spill size = 64
1348    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.ArrayDeque::addFirst
        # java.util.ArrayDeque::push @ bci:2 (line 579) L[0]=_ L[1]=_
        # java.nio.file.FileTreeWalker::visit @ bci:187 (line 311) L[0]=_ L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [32]=Oop [56]=Oop off=4940/0x134c}

134c    B220: #	out( B319 B221 ) &lt;- in( B219 )  Freq: 0.0137339
        # Block is sole successor of call
134c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
134c    ld  R10, [R23, #288]	# ptr, #@loadP
1350 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1350    ld  R7, [R23, #304]	# ptr, #@loadP
1354 +  addi  R28, R10, #32	# ptr, #@addP_reg_imm
1358 +  bgeu  R28, R7, B319	#@cmpP_branch  P=0.000100 C=-1.000000

135c    B221: #	out( B222 ) &lt;- in( B220 )  Freq: 0.0137325
135c +  li R7, #1	# long, #@loadConL
1360 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1360    sd  R28, [R23, #288]	# ptr, #@storeP
1364 +  sd  R7, [R10]	# long, #@storeL
1368 +  mv  R7, narrowklass: precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d0a1c950:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1378 +  sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
137c +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
1380 +  sw  zr, [R10, #12]	# int, #@storeimmI0
1384 +  ClearArray #2, R28	#@clearArray_imm_reg

138c    B222: #	out( B525 B223 ) &lt;- in( B320 B221 )  Freq: 0.0137339
138c    
138c    MEMBAR-store-store	#@membar_storestore
1390 +  spill R10 -&gt; R8	# spill size = 64
1394 +  # checkcastPP of R8, #@checkCastPP
1394    mv  R12, java/nio/file/FileTreeWalker$EventType:exact *	# ptr, #@loadConP
13ac    spill R8 -&gt; R11	# spill size = 64
13b0 +  spill [sp, #24] -&gt; R13	# spill size = 64
13b4 +  spill [sp, #32] -&gt; R14	# spill size = 64
13b8 +  mv  R15, NULL	# NULL ptr, #@loadConP0
13bc    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeWalker$Event::&lt;init&gt;
        # java.nio.file.FileTreeWalker$Event::&lt;init&gt; @ bci:5 (line 141) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.nio.file.FileTreeWalker::visit @ bci:200 (line 312) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=R8
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [56]=Oop off=5056/0x13c0}

13c0    B223: #	out( B149 ) &lt;- in( B222 )  Freq: 0.0137336
        # Block is sole successor of call
13c0 +  spill R8 -&gt; [sp, #0]	# spill size = 64
13c4 +  j  B149	#@branch

13c8    B224: #	out( B123 ) &lt;- in( B118 )  Freq: 0.0134984
13c8 +  spill R14 -&gt; R8	# spill size = 64
13cc +  spill R11 -&gt; [sp, #4]	# spill size = 32
13d0 +  spill R28 -&gt; [sp, #0]	# spill size = 32
13d4 +  j  B123	#@branch

13d8    B225: #	out( B40 B226 ) &lt;- in( B39 )  Freq: 0.000526522
13d8 +  lwu  R7, [R12, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
13dc +  decode_heap_oop  R10, R7	#@decodeHeapOop
13e0 +  far_beq   R10, zr, B40	#@far_cmpP_imm0_branch  P=0.500000 C=-1.000000

13e8    B226: #	out( B354 B227 ) &lt;- in( B225 )  Freq: 0.000263261
13e8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
13e8    ld  R7, [R23, #32]	# int, #@loadL
13ec +  beq  R7, zr, B354	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

13f0    B227: #	out( B40 ) &lt;- in( B226 )  Freq: 0.000262998
13f0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
13f0    ld  R28, [R23, #48]	# ptr, #@loadP
13f4 +  add R28, R28, R7	# ptr, #@addP_reg_reg
13f8 +  addi  R7, R7, #-8	#@addL_reg_imm
13fc +  sd  R10, [R28, #-8]	# ptr, #@storeP
1400 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1400    sd  R7, [R23, #32]	# long, #@storeL
1404 +  j  B40	#@branch

1408    B228: #	out( B25 B229 ) &lt;- in( B24 )  Freq: 0.000499032
1408 +  lwu  R7, [R21, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
140c +  decode_heap_oop  R10, R7	#@decodeHeapOop
1410 +  far_beq   R10, zr, B25	#@far_cmpP_imm0_branch  P=0.500000 C=-1.000000

1418    B229: #	out( B360 B230 ) &lt;- in( B228 )  Freq: 0.000249516
1418 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1418    ld  R7, [R23, #32]	# int, #@loadL
141c +  beq  R7, zr, B360	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1420    B230: #	out( B25 ) &lt;- in( B229 )  Freq: 0.000249266
1420 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1420    ld  R28, [R23, #48]	# ptr, #@loadP
1424 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1428 +  addi  R7, R7, #-8	#@addL_reg_imm
142c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1430 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1430    sd  R7, [R23, #32]	# long, #@storeL
1434 +  j  B25	#@branch

1438    B231: #	out( B73 B232 ) &lt;- in( B72 )  Freq: 0.00049901
1438 +  lwu  R28, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
143c +  decode_heap_oop  R10, R28	#@decodeHeapOop
1440 +  beq   R10, zr, B73	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1444    B232: #	out( B361 B233 ) &lt;- in( B231 )  Freq: 0.000249505
1444 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1444    ld  R7, [R23, #32]	# int, #@loadL
1448 +  beq  R7, zr, B361	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

144c    B233: #	out( B73 ) &lt;- in( B232 )  Freq: 0.000249256
144c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
144c    ld  R28, [R23, #48]	# ptr, #@loadP
1450 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1454 +  addi  R7, R7, #-8	#@addL_reg_imm
1458 +  sd  R10, [R28, #-8]	# ptr, #@storeP
145c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
145c    sd  R7, [R23, #32]	# long, #@storeL
1460 +  j  B73	#@branch

1464    B234: #	out( B155 B235 ) &lt;- in( B153 )  Freq: 0.000498952
1464 +  spill [sp, #8] -&gt; R18	# spill size = 64
1468 +  lwu  R7, [R18, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.next
146c +  decode_heap_oop  R10, R7	#@decodeHeapOop
1470 +  beq   R10, zr, B155	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1474    B235: #	out( B362 B236 ) &lt;- in( B234 )  Freq: 0.000249476
1474 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1474    ld  R7, [R23, #32]	# int, #@loadL
1478 +  beq  R7, zr, B362	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

147c    B236: #	out( B155 ) &lt;- in( B235 )  Freq: 0.000249226
147c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
147c    ld  R28, [R23, #48]	# ptr, #@loadP
1480 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1484 +  addi  R7, R7, #-8	#@addL_reg_imm
1488 +  sd  R10, [R28, #-8]	# ptr, #@storeP
148c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
148c    sd  R7, [R23, #32]	# long, #@storeL
1490 +  j  B155	#@branch

1494    B237: #	out( B27 B238 ) &lt;- in( B26 )  Freq: 0.000498539
1494 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1494    ld  R28, [R23, #64]	# int, #@loadL
1498 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1498    ld  R29, [R23, #80]	# ptr, #@loadP
149c +  #@membar_volatile
	fence iorw iorw
14a0 +  lb  R31, [R10]	# byte, #@loadB
14a4 +  far_beq  R31, zr, B27	#@far_cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

14ac    B238: #	out( B240 B239 ) &lt;- in( B237 )  Freq: 0.00024927
14ac +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
14b0 +  bne  R28, zr, B240	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

14b4    B239: #	out( B27 ) &lt;- in( B238 )  Freq: 0.000124635
14b4 +  spill R7 -&gt; R26	# spill size = 32
14bc    
14bc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
14bc    spill R23 -&gt; R11	# spill size = 64
14c0 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
14f0 +  spill R21 -&gt; R22	# spill size = 64
14f4 +  spill R20 -&gt; R21	# spill size = 64
14f8 +  spill R19 -&gt; R20	# spill size = 64
14fc +  spill R20 -&gt; R19	# spill size = 64
1500 +  spill R21 -&gt; R20	# spill size = 64
1504 +  spill R22 -&gt; R21	# spill size = 64
1508 +  spill R26 -&gt; R7	# spill size = 32
1510 +  j  B27	#@branch

1514    B240: #	out( B27 ) &lt;- in( B238 )  Freq: 0.000124635
1514 +  add R29, R29, R28	# ptr, #@addP_reg_reg
1518 +  addi  R28, R28, #-8	#@addL_reg_imm
151c +  sd  R10, [R29, #-8]	# ptr, #@storeP
1520 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1520    sd  R28, [R23, #64]	# long, #@storeL
1524 +  j  B27	#@branch

1528    B241: #	out( B245 B242 ) &lt;- in( B75 )  Freq: 0.000498019
1528 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1528    ld  R7, [R23, #64]	# int, #@loadL
152c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
152c    ld  R28, [R23, #80]	# ptr, #@loadP
1530 +  #@membar_volatile
	fence iorw iorw
1534 +  lb  R29, [R10]	# byte, #@loadB
1538 +  beq  R29, zr, B245	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

153c    B242: #	out( B244 B243 ) &lt;- in( B241 )  Freq: 0.00024901
153c +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1540 +  beq  R7, zr, B244	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1544    B243: #	out( B245 ) &lt;- in( B242 )  Freq: 0.000124505
1544 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1548 +  addi  R7, R7, #-8	#@addL_reg_imm
154c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1550 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1550    sd  R7, [R23, #64]	# long, #@storeL
1554 +  j  B245	#@branch

1558    B244: #	out( B245 ) &lt;- in( B242 )  Freq: 0.000124505
1558 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1558    spill R23 -&gt; R11	# spill size = 64
155c +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 

158c    B245: #	out( B76 ) &lt;- in( B244 B243 B241 )  Freq: 0.000498019
158c    lwu  R9, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
1590 +  j  B76	#@branch

1594    B246: #	out( B62 ) &lt;- in( B60 )  Freq: 0.000484817
1594 +  addi  R28, R26, #16	#@addL_reg_imm
1598 +  srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
159c +  andi  R28, R28, #-8	#@andL_reg_imm
15a0 +  add R28, R24, R28	# ptr, #@addP_reg_reg
15a4 +  sub  R29, R7, R29	#@subL_reg_reg
15a8    ClearArray R29, R28	#@clearArray_reg_reg
1600 +  spill R30 -&gt; [sp, #16]	# spill size = 64
1604    
1604    
1604 +  spill R26 -&gt; R12	# spill size = 64
1608 +  CALL, runtime leaf nofp 0x000000401396cf00	#@CallLeafNoFPDirect arrayof_jbyte_disjoint_arraycopy
        No JVM State Info
        # 
160c +  spill R21 -&gt; R8	# spill size = 64
1610 +  spill R18 -&gt; [sp, #0]	# spill size = 32
1614 +  spill R9 -&gt; [sp, #4]	# spill size = 32
1618 +  spill R8 -&gt; R21	# spill size = 64
161c +  spill [sp, #0] -&gt; R18	# spill size = 32
1620 +  spill [sp, #4] -&gt; R9	# spill size = 32
1624 +  spill [sp, #16] -&gt; R30	# spill size = 64
1628 +  j  B62	#@branch

162c    B247: #	out( B81 B248 ) &lt;- in( B80 )  Freq: 0.000484266
162c +  lwu  R28, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
1630 +  decode_heap_oop  R10, R28	#@decodeHeapOop
1634 +  beq   R10, zr, B81	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1638    B248: #	out( B365 B249 ) &lt;- in( B247 )  Freq: 0.000242133
1638 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1638    ld  R7, [R23, #32]	# int, #@loadL
163c +  beq  R7, zr, B365	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1640    B249: #	out( B81 ) &lt;- in( B248 )  Freq: 0.000241891
1640 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1640    ld  R28, [R23, #48]	# ptr, #@loadP
1644 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1648 +  addi  R7, R7, #-8	#@addL_reg_imm
164c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1650 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1650    sd  R7, [R23, #32]	# long, #@storeL
1654 +  j  B81	#@branch

1658    B250: #	out( B118 B251 ) &lt;- in( B117 )  Freq: 0.000484081
1658 +  lwu  R10, [R31, #16]	# loadN, compressed ptr, #@loadN
165c +  decode_heap_oop  R10, R10	#@decodeHeapOop
1660 +  beq   R10, zr, B118	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1664    B251: #	out( B367 B252 ) &lt;- in( B250 )  Freq: 0.000242041
1664 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1664    ld  R13, [R23, #32]	# int, #@loadL
1668 +  beq  R13, zr, B367	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

166c    B252: #	out( B118 ) &lt;- in( B251 )  Freq: 0.000241799
166c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
166c    ld  R16, [R23, #48]	# ptr, #@loadP
1670 +  add R16, R16, R13	# ptr, #@addP_reg_reg
1674 +  sd  R10, [R16, #-8]	# ptr, #@storeP
1678 +  addi  R10, R13, #-8	#@addL_reg_imm
167c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
167c    sd  R10, [R23, #32]	# long, #@storeL
1680 +  j  B118	#@branch

1684    B253: #	out( B135 B254 ) &lt;- in( B134 )  Freq: 0.000484068
1684 +  lwu  R7, [R9]	# loadN, compressed ptr, #@loadN
1688 +  decode_heap_oop  R10, R7	#@decodeHeapOop
168c +  beq   R10, zr, B135	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1690    B254: #	out( B369 B255 ) &lt;- in( B253 )  Freq: 0.000242034
1690 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1690    ld  R7, [R23, #32]	# int, #@loadL
1694 +  beq  R7, zr, B369	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1698    B255: #	out( B135 ) &lt;- in( B254 )  Freq: 0.000241792
1698 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1698    ld  R28, [R23, #48]	# ptr, #@loadP
169c +  add R28, R28, R7	# ptr, #@addP_reg_reg
16a0 +  addi  R7, R7, #-8	#@addL_reg_imm
16a4 +  sd  R10, [R28, #-8]	# ptr, #@storeP
16a8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16a8    sd  R7, [R23, #32]	# long, #@storeL
16ac +  j  B135	#@branch

16b0    B256: #	out( B137 B257 ) &lt;- in( B136 )  Freq: 0.00048359
16b0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16b0    ld  R7, [R23, #64]	# int, #@loadL
16b4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16b4    ld  R28, [R23, #80]	# ptr, #@loadP
16b8 +  #@membar_volatile
	fence iorw iorw
16bc +  lb  R30, [R10]	# byte, #@loadB
16c0 +  beq  R30, zr, B137	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

16c4    B257: #	out( B259 B258 ) &lt;- in( B256 )  Freq: 0.000241795
16c4 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
16c8 +  bne  R7, zr, B259	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

16cc    B258: #	out( B137 ) &lt;- in( B257 )  Freq: 0.000120898
16cc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16cc    spill R23 -&gt; R11	# spill size = 64
16d0 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1700 +  j  B137	#@branch

1704    B259: #	out( B137 ) &lt;- in( B257 )  Freq: 0.000120898
1704 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1708 +  addi  R7, R7, #-8	#@addL_reg_imm
170c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1710 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1710    sd  R7, [R23, #64]	# long, #@storeL
1714 +  j  B137	#@branch

1718    B260: #	out( B120 B261 ) &lt;- in( B119 )  Freq: 0.000470583
1718 +  lwu  R7, [R21, #28]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/NativeBuffer.owner
171c +  decode_heap_oop  R10, R7	#@decodeHeapOop
1720 +  beq   R10, zr, B120	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1724    B261: #	out( B373 B262 ) &lt;- in( B260 )  Freq: 0.000235292
1724 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1724    ld  R7, [R23, #32]	# int, #@loadL
1728 +  beq  R7, zr, B373	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

172c    B262: #	out( B120 ) &lt;- in( B261 )  Freq: 0.000235056
172c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
172c    ld  R28, [R23, #48]	# ptr, #@loadP
1730 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1734 +  addi  R7, R7, #-8	#@addL_reg_imm
1738 +  sd  R10, [R28, #-8]	# ptr, #@storeP
173c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
173c    sd  R7, [R23, #32]	# long, #@storeL
1740 +  j  B120	#@branch

1744    B263: #	out( B267 B264 ) &lt;- in( B121 )  Freq: 0.000470119
1744 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1744    ld  R28, [R23, #64]	# int, #@loadL
1748 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1748    ld  R29, [R23, #80]	# ptr, #@loadP
174c +  #@membar_volatile
	fence iorw iorw
1750 +  lb  R31, [R10]	# byte, #@loadB
1754 +  beq  R31, zr, B267	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1758    B264: #	out( B266 B265 ) &lt;- in( B263 )  Freq: 0.000235059
1758 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
175c +  beq  R28, zr, B266	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1760    B265: #	out( B267 ) &lt;- in( B264 )  Freq: 0.00011753
1760 +  add R29, R29, R28	# ptr, #@addP_reg_reg
1764 +  addi  R28, R28, #-8	#@addL_reg_imm
1768 +  sd  R10, [R29, #-8]	# ptr, #@storeP
176c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
176c    sd  R28, [R23, #64]	# long, #@storeL
1770 +  j  B267	#@branch

1774    B266: #	out( B267 ) &lt;- in( B264 )  Freq: 0.00011753
1774 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1774    spill R23 -&gt; R11	# spill size = 64
1778 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
17a8 +  spill R18 -&gt; R7	# spill size = 64

17ac    B267: #	out( B122 ) &lt;- in( B266 B265 B263 )  Freq: 0.000470119
17ac +  ld  R24, [R21, #16]	# int, #@loadL ! Field: sun/nio/fs/NativeBuffer.address
17b0 +  j  B122	#@branch

17b4    B268: #	out( B461 B269 ) &lt;- in( B101 )  Freq: 0.000175728
17b4 +  spill R11 -&gt; [sp, #4]	# spill size = 32
17b8 +  spill R30 -&gt; [sp, #40]	# spill size = 64
17bc +  spill R9 -&gt; [sp, #32]	# spill size = 32
17c0 +  spill R7 -&gt; [sp, #24]	# spill size = 64
17c4 +  spill R29 -&gt; [sp, #16]	# spill size = 64
17c8 +  spill R7 -&gt; R11	# spill size = 64
17cc +  spill R30 -&gt; R12	# spill size = 64
17d0    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect sun.nio.fs.UnixNativeDispatcher::stat
        # sun.nio.fs.UnixFileAttributes::get @ bci:14 (line 70) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop off=6100/0x17d4}

17d4    B269: #	out( B137 ) &lt;- in( B268 )  Freq: 0.000175725
        # Block is sole successor of call
17d4 +  j  B137	#@branch

17d8    B270: #	out( B505 B271 ) &lt;- in( B56 B57 )  Freq: 4.8981e-05
17d8 +  spill R26 -&gt; [sp, #96]	# spill size = 64
17dc +  spill R30 -&gt; [sp, #88]	# spill size = 64
17e0 +  spill R9 -&gt; [sp, #80]	# spill size = 32
17e4 +  spill R18 -&gt; [sp, #28]	# spill size = 32
17e8 +  spill R28 -&gt; [sp, #64]	# spill size = 64
17ec +  spill R21 -&gt; [sp, #40]	# spill size = 64
17f0 +  spill R25 -&gt; [sp, #32]	# spill size = 64
17f4 +  spill R22 -&gt; [sp, #24]	# spill size = 32
17f8 +  spill R20 -&gt; [sp, #16]	# spill size = 64
17fc +  mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
1814    spill R9 -&gt; R12	# spill size = 32
1818    CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::resolve @ bci:69 (line 369) L[0]=sp + #64 L[1]=sp + #16 L[2]=sp + #28 L[3]=sp + #24 L[4]=_
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #40 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [32]=Derived_oop_[16] [40]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=6172/0x181c}

181c    B271: #	out( B59 ) &lt;- in( B270 )  Freq: 4.898e-05
        # Block is sole successor of call
181c +  spill [sp, #0] -&gt; R19	# spill size = 64
1820 +  spill [sp, #16] -&gt; R20	# spill size = 64
1824 +  spill [sp, #24] -&gt; R22	# spill size = 32
1828 +  spill [sp, #32] -&gt; R25	# spill size = 64
182c +  spill [sp, #40] -&gt; R21	# spill size = 64
1830 +  spill [sp, #64] -&gt; R28	# spill size = 64
1834 +  spill [sp, #28] -&gt; R18	# spill size = 32
1838 +  spill [sp, #80] -&gt; R9	# spill size = 32
183c +  spill [sp, #88] -&gt; R30	# spill size = 64
1840 +  spill [sp, #96] -&gt; R26	# spill size = 64
1844 +  spill R10 -&gt; R24	# spill size = 64
1848 +  j  B59	#@branch

184c    B272: #	out( B506 B273 ) &lt;- in( B66 )  Freq: 4.84897e-05
184c +  spill R24 -&gt; [sp, #16]	# spill size = 64
1850 +  spill R21 -&gt; R8	# spill size = 64
1854 +  spill R19 -&gt; [sp, #0]	# spill size = 64
1858 +  mv  R11, precise klass sun/nio/fs/UnixPath: 0x00000040d09eb770:Constant:exact *	# ptr, #@loadConP
1870    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixPath::resolve @ bci:35 (line 383) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #16
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [48]=Oop [56]=Oop [72]=Oop off=6260/0x1874}

1874    B273: #	out( B68 ) &lt;- in( B272 )  Freq: 4.84887e-05
        # Block is sole successor of call
1874 +  spill [sp, #0] -&gt; R19	# spill size = 64
1878 +  spill R8 -&gt; R21	# spill size = 64
187c +  spill [sp, #16] -&gt; R24	# spill size = 64
1880 +  spill R10 -&gt; R18	# spill size = 64
1884 +  j  B68	#@branch

1888    B274: #	out( B460 B275 ) &lt;- in( B99 )  Freq: 4.84349e-05
1888 +  spill R9 -&gt; [sp, #32]	# spill size = 32
188c +  spill R7 -&gt; [sp, #24]	# spill size = 64
1890 +  spill R29 -&gt; [sp, #16]	# spill size = 64
1894 +  mv  R11, precise klass sun/nio/fs/UnixFileAttributes: 0x00000040d0457910:Constant:exact *	# ptr, #@loadConP
18ac    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixFileAttributes::get @ bci:0 (line 68) L[0]=sp + #24 L[1]=sp + #32 L[2]=_
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [56]=Oop [72]=Oop off=6320/0x18b0}

18b0    B275: #	out( B101 ) &lt;- in( B274 )  Freq: 4.84339e-05
        # Block is sole successor of call
18b0 +  spill [sp, #16] -&gt; R29	# spill size = 64
18b4 +  spill [sp, #24] -&gt; R7	# spill size = 64
18b8 +  spill [sp, #32] -&gt; R9	# spill size = 32
18bc +  j  B101	#@branch

18c0    B276: #	out( B449 B277 ) &lt;- in( B137 )  Freq: 4.8433e-05
18c0 +  mv  R11, precise klass sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes: 0x00000040d81d8810:Constant:exact *	# ptr, #@loadConP
18d8    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes::wrap @ bci:0 (line 274) L[0]=sp + #40
        # sun.nio.fs.UnixFileAttributes::asBasicFileAttributes @ bci:1 (line 251) L[0]=_
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:20 (line 53) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop off=6364/0x18dc}

18dc    B277: #	out( B139 ) &lt;- in( B276 )  Freq: 4.84321e-05
        # Block is sole successor of call
18dc +  j  B139	#@branch

18e0    B278: #	out( B524 B279 ) &lt;- in( B145 )  Freq: 4.70591e-05
18e0 +  spill R30 -&gt; [sp, #0]	# spill size = 64
18e4 +  mv  R11, precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d0a1c950:Constant:exact *	# ptr, #@loadConP
18fc    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.nio.file.FileTreeWalker::visit @ bci:66 (line 289) L[0]=_ L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop [56]=Oop off=6400/0x1900}

1900    B279: #	out( B147 ) &lt;- in( B278 )  Freq: 4.70582e-05
        # Block is sole successor of call
1900 +  spill [sp, #16] -&gt; R31	# spill size = 64
1904 +  spill [sp, #0] -&gt; R30	# spill size = 64
1908 +  j  B147	#@branch

190c    B280: #	out( B178 B281 ) &lt;- in( B177 )  Freq: 2.74946e-05
190c +  lwu  R7, [R29, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
1910 +  decode_heap_oop  R10, R7	#@decodeHeapOop
1914 +  beq   R10, zr, B178	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1918    B281: #	out( B388 B282 ) &lt;- in( B280 )  Freq: 1.37473e-05
1918 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1918    ld  R7, [R23, #32]	# int, #@loadL
191c +  far_beq  R7, zr, B388	#@far_cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1924    B282: #	out( B178 ) &lt;- in( B281 )  Freq: 1.37335e-05
1924 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1924    ld  R28, [R23, #48]	# ptr, #@loadP
1928 +  add R28, R28, R7	# ptr, #@addP_reg_reg
192c +  addi  R7, R7, #-8	#@addL_reg_imm
1930 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1934 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1934    sd  R7, [R23, #32]	# long, #@storeL
1938 +  j  B178	#@branch

193c    B283: #	out( B180 B284 ) &lt;- in( B179 )  Freq: 2.74674e-05
193c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
193c    ld  R28, [R23, #64]	# int, #@loadL
1940 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1940    ld  R30, [R23, #80]	# ptr, #@loadP
1944 +  #@membar_volatile
	fence iorw iorw
1948 +  lb  R31, [R10]	# byte, #@loadB
194c +  beq  R31, zr, B180	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1950    B284: #	out( B286 B285 ) &lt;- in( B283 )  Freq: 1.37337e-05
1950 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1954 +  bne  R28, zr, B286	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1958    B285: #	out( B180 ) &lt;- in( B284 )  Freq: 6.86686e-06
1958 +  spill R29 -&gt; R21	# spill size = 64
195c    
195c    
195c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
195c    spill R23 -&gt; R11	# spill size = 64
1960 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1990 +  spill [sp, #24] -&gt; R7	# spill size = 32
1994 +  spill R21 -&gt; R29	# spill size = 64
1998 +  j  B180	#@branch

199c    B286: #	out( B180 ) &lt;- in( B284 )  Freq: 6.86686e-06
199c +  add R30, R30, R28	# ptr, #@addP_reg_reg
19a0 +  addi  R28, R28, #-8	#@addL_reg_imm
19a4 +  sd  R10, [R30, #-8]	# ptr, #@storeP
19a8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
19a8    sd  R28, [R23, #64]	# long, #@storeL
19ac +  j  B180	#@branch

19b0    B287: #	out( B205 B288 ) &lt;- in( B204 )  Freq: 1.37343e-05
19b0 +  lwu  R28, [R20, #20]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.key
19b4 +  decode_heap_oop  R10, R28	#@decodeHeapOop
19b8 +  beq   R10, zr, B205	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

19bc    B288: #	out( B394 B289 ) &lt;- in( B287 )  Freq: 6.86715e-06
19bc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
19bc    ld  R7, [R23, #32]	# int, #@loadL
19c0 +  far_beq  R7, zr, B394	#@far_cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

19c8    B289: #	out( B205 ) &lt;- in( B288 )  Freq: 6.86028e-06
19c8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
19c8    ld  R28, [R23, #48]	# ptr, #@loadP
19cc +  add R28, R28, R7	# ptr, #@addP_reg_reg
19d0 +  addi  R7, R7, #-8	#@addL_reg_imm
19d4 +  sd  R10, [R28, #-8]	# ptr, #@storeP
19d8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
19d8    sd  R7, [R23, #32]	# long, #@storeL
19dc +  j  B205	#@branch

19e0    B290: #	out( B209 B291 ) &lt;- in( B208 )  Freq: 1.37343e-05
19e0 +  lwu  R28, [R20, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.stream
19e4 +  decode_heap_oop  R10, R28	#@decodeHeapOop
19e8 +  beq   R10, zr, B209	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

19ec    B291: #	out( B395 B292 ) &lt;- in( B290 )  Freq: 6.86715e-06
19ec +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
19ec    ld  R7, [R23, #32]	# int, #@loadL
19f0 +  far_beq  R7, zr, B395	#@far_cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

19f8    B292: #	out( B209 ) &lt;- in( B291 )  Freq: 6.86028e-06
19f8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
19f8    ld  R28, [R23, #48]	# ptr, #@loadP
19fc +  add R28, R28, R7	# ptr, #@addP_reg_reg
1a00 +  addi  R7, R7, #-8	#@addL_reg_imm
1a04 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1a08 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a08    sd  R7, [R23, #32]	# long, #@storeL
1a0c +  j  B209	#@branch

1a10    B293: #	out( B202 B294 ) &lt;- in( B200 )  Freq: 1.37343e-05
1a10 +  spill [sp, #48] -&gt; R20	# spill size = 64
1a14 +  lwu  R28, [R20, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.dir
1a18 +  decode_heap_oop  R10, R28	#@decodeHeapOop
1a1c +  beq   R10, zr, B202	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1a20    B294: #	out( B393 B295 ) &lt;- in( B293 )  Freq: 6.86715e-06
1a20 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a20    ld  R7, [R23, #32]	# int, #@loadL
1a24 +  beq  R7, zr, B393	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1a28    B295: #	out( B202 ) &lt;- in( B294 )  Freq: 6.86028e-06
1a28 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a28    ld  R28, [R23, #48]	# ptr, #@loadP
1a2c +  add R28, R28, R7	# ptr, #@addP_reg_reg
1a30 +  addi  R7, R7, #-8	#@addL_reg_imm
1a34 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1a38 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a38    sd  R7, [R23, #32]	# long, #@storeL
1a3c +  j  B202	#@branch

1a40    B296: #	out( B215 B297 ) &lt;- in( B213 )  Freq: 1.3734e-05
1a40 +  spill R8 -&gt; R18	# spill size = 64
1a44 +  lwu  R7, [R18, #28]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.iterator
1a48 +  decode_heap_oop  R10, R7	#@decodeHeapOop
1a4c +  beq   R10, zr, B215	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1a50    B297: #	out( B396 B298 ) &lt;- in( B296 )  Freq: 6.86701e-06
1a50 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a50    ld  R7, [R23, #32]	# int, #@loadL
1a54 +  far_beq  R7, zr, B396	#@far_cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1a5c    B298: #	out( B215 ) &lt;- in( B297 )  Freq: 6.86015e-06
1a5c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a5c    ld  R28, [R23, #48]	# ptr, #@loadP
1a60 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1a64 +  addi  R7, R7, #-8	#@addL_reg_imm
1a68 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1a6c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a6c    sd  R7, [R23, #32]	# long, #@storeL
1a70 +  j  B215	#@branch

1a74    B299: #	out( B204 B300 ) &lt;- in( B203 )  Freq: 1.37207e-05
1a74 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a74    ld  R7, [R23, #64]	# int, #@loadL
1a78 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a78    ld  R28, [R23, #80]	# ptr, #@loadP
1a7c +  #@membar_volatile
	fence iorw iorw
1a80 +  lb  R29, [R10]	# byte, #@loadB
1a84 +  beq  R29, zr, B204	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1a88    B300: #	out( B302 B301 ) &lt;- in( B299 )  Freq: 6.86037e-06
1a88 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1a8c +  bne  R7, zr, B302	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1a90    B301: #	out( B204 ) &lt;- in( B300 )  Freq: 3.43019e-06
1a90 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a90    spill R23 -&gt; R11	# spill size = 64
1a94 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1ac4 +  j  B204	#@branch

1ac8    B302: #	out( B204 ) &lt;- in( B300 )  Freq: 3.43019e-06
1ac8 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1acc +  addi  R7, R7, #-8	#@addL_reg_imm
1ad0 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1ad4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ad4    sd  R7, [R23, #64]	# long, #@storeL
1ad8 +  j  B204	#@branch

1adc    B303: #	out( B208 B304 ) &lt;- in( B207 )  Freq: 1.3707e-05
1adc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1adc    ld  R7, [R23, #64]	# int, #@loadL
1ae0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ae0    ld  R28, [R23, #80]	# ptr, #@loadP
1ae4 +  #@membar_volatile
	fence iorw iorw
1ae8 +  lb  R29, [R10]	# byte, #@loadB
1aec +  beq  R29, zr, B208	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1af0    B304: #	out( B306 B305 ) &lt;- in( B303 )  Freq: 6.85351e-06
1af0 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1af4 +  bne  R7, zr, B306	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1af8    B305: #	out( B208 ) &lt;- in( B304 )  Freq: 3.42676e-06
1af8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1af8    spill R23 -&gt; R11	# spill size = 64
1afc +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1b2c +  j  B208	#@branch

1b30    B306: #	out( B208 ) &lt;- in( B304 )  Freq: 3.42676e-06
1b30 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1b34 +  addi  R7, R7, #-8	#@addL_reg_imm
1b38 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1b3c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b3c    sd  R7, [R23, #64]	# long, #@storeL
1b40 +  j  B208	#@branch

1b44    B307: #	out( B212 B308 ) &lt;- in( B211 )  Freq: 1.3707e-05
1b44 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b44    ld  R7, [R23, #64]	# int, #@loadL
1b48 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b48    ld  R28, [R23, #80]	# ptr, #@loadP
1b4c +  #@membar_volatile
	fence iorw iorw
1b50 +  lb  R29, [R10]	# byte, #@loadB
1b54 +  beq  R29, zr, B212	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1b58    B308: #	out( B310 B309 ) &lt;- in( B307 )  Freq: 6.85351e-06
1b58 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1b5c +  bne  R7, zr, B310	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1b60    B309: #	out( B212 ) &lt;- in( B308 )  Freq: 3.42676e-06
1b60 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b60    spill R23 -&gt; R11	# spill size = 64
1b64 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1b94 +  j  B212	#@branch

1b98    B310: #	out( B212 ) &lt;- in( B308 )  Freq: 3.42676e-06
1b98 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1b9c +  addi  R7, R7, #-8	#@addL_reg_imm
1ba0 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1ba4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ba4    sd  R7, [R23, #64]	# long, #@storeL
1ba8 +  j  B212	#@branch

1bac    B311: #	out( B218 B312 ) &lt;- in( B217 )  Freq: 1.37068e-05
1bac +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1bac    ld  R7, [R23, #64]	# int, #@loadL
1bb0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1bb0    ld  R28, [R23, #80]	# ptr, #@loadP
1bb4 +  #@membar_volatile
	fence iorw iorw
1bb8 +  lb  R29, [R10]	# byte, #@loadB
1bbc +  beq  R29, zr, B218	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1bc0    B312: #	out( B314 B313 ) &lt;- in( B311 )  Freq: 6.85338e-06
1bc0 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1bc4 +  bne  R7, zr, B314	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1bc8    B313: #	out( B218 ) &lt;- in( B312 )  Freq: 3.42669e-06
1bc8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1bc8    spill R23 -&gt; R11	# spill size = 64
1bcc +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1bfc +  j  B218	#@branch

1c00    B314: #	out( B218 ) &lt;- in( B312 )  Freq: 3.42669e-06
1c00 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1c04 +  addi  R7, R7, #-8	#@addL_reg_imm
1c08 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1c0c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1c0c    sd  R7, [R23, #64]	# long, #@storeL
1c10 +  j  B218	#@branch

1c14    B315: #	out( B522 B316 ) &lt;- in( B190 )  Freq: 1.47459e-06
1c14 +  mv  R11, precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d0a1c950:Constant:exact *	# ptr, #@loadConP
1c2c    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.nio.file.FileTreeWalker::next @ bci:113 (line 370) L[0]=_ L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop off=7216/0x1c30}

1c30    B316: #	out( B192 ) &lt;- in( B315 )  Freq: 1.47456e-06
        # Block is sole successor of call
1c30 +  j  B192	#@branch

1c34    B317: #	out( B521 B318 ) &lt;- in( B197 )  Freq: 1.3737e-06
1c34 +  spill R31 -&gt; [sp, #40]	# spill size = 64
1c38 +  mv  R11, precise klass java/nio/file/FileTreeWalker$DirectoryNode: 0x00000040d09f6a90:Constant:exact *	# ptr, #@loadConP
1c50    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.nio.file.FileTreeWalker::visit @ bci:170 (line 311) L[0]=_ L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=R8 L[7]=_ STK[0]=sp + #40
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop off=7252/0x1c54}

1c54    B318: #	out( B199 ) &lt;- in( B317 )  Freq: 1.37368e-06
        # Block is sole successor of call
1c54 +  j  B199	#@branch

1c58    B319: #	out( B520 B320 ) &lt;- in( B220 )  Freq: 1.37362e-06
1c58 +  mv  R11, precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d0a1c950:Constant:exact *	# ptr, #@loadConP
1c70    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.nio.file.FileTreeWalker::visit @ bci:190 (line 312) L[0]=_ L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [32]=Oop [56]=Oop off=7284/0x1c74}

1c74    B320: #	out( B222 ) &lt;- in( B319 )  Freq: 1.37359e-06
        # Block is sole successor of call
1c74 +  j  B222	#@branch

1c78    B321: #	out( N6567 ) &lt;- in( B35 )  Freq: 5.2653e-07
1c78 +  spill [sp, #8] -&gt; R7	# spill size = 64
1c7c +  li R11, #-34	# int, #@loadConI
1c80    spill R7 -&gt; [sp, #0]	# spill size = 64
1c84 +  spill R29 -&gt; [sp, #16]	# spill size = 64
1c88 +  spill R29 -&gt; [sp, #24]	# spill size = 64
1c8c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #16 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [64]=Oop off=7312/0x1c90}
1c90    #@ShouldNotReachHere

1c9c    B322: #	out( N6567 ) &lt;- in( B42 )  Freq: 5.26528e-07
1c9c +  spill [sp, #8] -&gt; R7	# spill size = 64
1ca0 +  li R11, #-20	# int, #@loadConI
1ca4    spill R7 -&gt; [sp, #0]	# spill size = 64
1ca8 +  spill R29 -&gt; [sp, #16]	# spill size = 64
1cac +  spill R29 -&gt; [sp, #24]	# spill size = 64
1cb0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_assert&apos; action=&apos;make_not_entrant&apos;)
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:12 (line 1095) L[0]=_ L[1]=_ STK[0]=R8
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #16 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [64]=Oop off=7348/0x1cb4}
1cb4    #@ShouldNotReachHere

1cc0    B323: #	out( N6567 ) &lt;- in( B151 )  Freq: 5.14216e-07
1cc0 +  spill [sp, #8] -&gt; R8	# spill size = 64
1cc4 +  li R11, #-20	# int, #@loadConI
1cc8    spill R10 -&gt; [sp, #8]	# spill size = 64
1ccc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_assert&apos; action=&apos;make_not_entrant&apos;)
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:23 (line 85) L[0]=R8 L[1]=sp + #0 L[2]=_ STK[0]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=7376/0x1cd0}
1cd0    #@ShouldNotReachHere

1cdc    B324: #	out( N6567 ) &lt;- in( B45 )  Freq: 5.12316e-07
1cdc +  li R11, #-25	# int, #@loadConI
1ce0    spill [sp, #8] -&gt; R8	# spill size = 64
1ce4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;none&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::isSelfOrParent @ bci:2 (line 145) L[0]=_ L[1]=_ STK[0]=sp + #64 STK[1]=#0
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:123 (line 181) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop off=7400/0x1ce8}
1ce8    #@ShouldNotReachHere

1cf4    B325: #	out( N6567 ) &lt;- in( B5 )  Freq: 5.06178e-07
1cf4 +  li R11, #-28	# int, #@loadConI
1cf8    spill R9 -&gt; [sp, #0]	# spill size = 64
1cfc +  spill R18 -&gt; [sp, #8]	# spill size = 64
1d00 +  spill R30 -&gt; [sp, #16]	# spill size = 32
1d04    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ArrayDeque::elementAt @ bci:2 (line 259) L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #16
        # java.util.ArrayDeque::peekFirst @ bci:8 (line 418) L[0]=_
        # java.util.ArrayDeque::peek @ bci:1 (line 564) L[0]=_
        # java.nio.file.FileTreeWalker::next @ bci:4 (line 335) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=7432/0x1d08}
1d08    #@ShouldNotReachHere

1d14    B326: #	out( N6567 ) &lt;- in( B10 )  Freq: 4.99043e-07
1d14 +  li R11, #-34	# int, #@loadConI
1d18    spill R9 -&gt; R8	# spill size = 64
1d1c +  spill R19 -&gt; [sp, #8]	# spill size = 64
1d20 +  spill R18 -&gt; [sp, #16]	# spill size = 64
1d24 +  spill R24 -&gt; [sp, #24]	# spill size = 64
1d28    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_ STK[0]=sp + #8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop off=7468/0x1d2c}
1d2c    #@ShouldNotReachHere

1d38    B327: #	out( B12 ) &lt;- in( B11 )  Freq: 4.99043e-07
1d38 +  spill R20 -&gt; [sp, #24]	# spill size = 64
1d3c    
1d3c    
1d3c +  spill R11 -&gt; R8	# spill size = 64
1d40 +  spill R19 -&gt; [sp, #16]	# spill size = 64
1d44 +  spill R19 -&gt; R11	# spill size = 64
1d48    
1d48    
1d48 +  spill R18 -&gt; [sp, #0]	# spill size = 64
1d4c    
1d4c    
1d4c +  spill R24 -&gt; [sp, #8]	# spill size = 64
1d50    
1d50    
1d50    add R12, sp, #144	# box lock
1d54 +  CALL,static 0x000000401390c140	#@CallStaticJavaDirect wrapper for: _complete_monitor_locking_Java
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:-1 (line 197) L[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=7512/0x1d58}
1d58 +  spill R8 -&gt; R9	# spill size = 64
1d5c +  spill [sp, #0] -&gt; R18	# spill size = 64
1d60 +  spill [sp, #8] -&gt; R24	# spill size = 64
1d64 +  spill [sp, #16] -&gt; R19	# spill size = 64
1d68 +  spill [sp, #24] -&gt; R20	# spill size = 64
1d6c +  j  B12	#@branch

1d70    B328: #	out( N6567 ) &lt;- in( B17 )  Freq: 4.99041e-07
1d70 +  li R11, #-34	# int, #@loadConI
1d74    spill R9 -&gt; [sp, #0]	# spill size = 64
1d78 +  spill R19 -&gt; [sp, #16]	# spill size = 64
1d7c +  spill R19 -&gt; [sp, #24]	# spill size = 64
1d80 +  spill R18 -&gt; [sp, #48]	# spill size = 64
1d84 +  spill R24 -&gt; [sp, #56]	# spill size = 64
1d88    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #16 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop off=7564/0x1d8c}
1d8c    #@ShouldNotReachHere

1d98    B329: #	out( N6567 ) &lt;- in( B20 )  Freq: 4.9904e-07
1d98 +  li R11, #-20	# int, #@loadConI
1d9c    spill R9 -&gt; [sp, #0]	# spill size = 64
1da0 +  spill R19 -&gt; [sp, #16]	# spill size = 64
1da4 +  spill R19 -&gt; [sp, #24]	# spill size = 64
1da8 +  spill R18 -&gt; [sp, #48]	# spill size = 64
1dac +  spill R24 -&gt; [sp, #56]	# spill size = 64
1db0 +  spill R21 -&gt; [sp, #72]	# spill size = 64
1db4 +  spill R20 -&gt; [sp, #80]	# spill size = 64
1db8 +  spill R31 -&gt; [sp, #88]	# spill size = 32
1dbc +  spill R29 -&gt; [sp, #92]	# spill size = 32
1dc0 +  spill R21 -&gt; [sp, #96]	# spill size = 64
1dc4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_assert&apos; action=&apos;make_not_entrant&apos;)
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::hasQueuedPredecessors @ bci:6 (line 1234) L[0]=sp + #72 L[1]=#NULL L[2]=_ L[3]=_ STK[0]=R8
        # java.util.concurrent.locks.ReentrantReadWriteLock$FairSync::readerShouldBlock @ bci:1 (line 706) L[0]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:33 (line 475) L[0]=sp + #96 L[1]=_ L[2]=sp + #80 L[3]=sp + #88 L[4]=sp + #92 L[5]=_
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #72 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #16 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [72]=Oop [80]=Oop [96]=Oop off=7624/0x1dc8}
1dc8    #@ShouldNotReachHere

1dd4    B330: #	out( B77 ) &lt;- in( B76 )  Freq: 4.99017e-07
1dd4    add R11, sp, #144	# box lock
1dd8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1dd8    spill R23 -&gt; R12	# spill size = 64
1ddc +  spill R19 -&gt; R10	# spill size = 64
1de0 +  CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
1e10 +  j  B77	#@branch

1e14    B331: #	out( B55 ) &lt;- in( B53 )  Freq: 4.91256e-07
1e14 +  addw  R29, R9, zr	#@convI2L_reg_reg
1e18 +  j  B55	#@branch

1e1c    B332: #	out( N6567 ) &lt;- in( B62 )  Freq: 4.91255e-07
1e1c +  spill [sp, #8] -&gt; R8	# spill size = 64
1e20 +  li R11, #-26	# int, #@loadConI
1e24    spill R19 -&gt; [sp, #8]	# spill size = 64
1e28 +  spill R19 -&gt; [sp, #16]	# spill size = 64
1e2c +  spill R24 -&gt; [sp, #40]	# spill size = 64
1e30 +  spill R18 -&gt; [sp, #64]	# spill size = 32
1e34    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:88 (line 371) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #40 STK[1]=sp + #64 STK[2]=#47
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop [56]=Oop off=7736/0x1e38}
1e38    #@ShouldNotReachHere

1e44    B333: #	out( B334 ) &lt;- in( B83 )  Freq: 4.90703e-07
1e44 +  spill [sp, #48] -&gt; R29	# spill size = 64

1e48    B334: #	out( N6567 ) &lt;- in( B333 B84 )  Freq: 9.81406e-07
1e48 +  spill [sp, #8] -&gt; R8	# spill size = 64
1e4c +  li R11, #-187	# int, #@loadConI
1e50    spill R29 -&gt; [sp, #8]	# spill size = 64
1e54 +  spill R29 -&gt; [sp, #24]	# spill size = 64
1e58 +  spill R7 -&gt; [sp, #32]	# spill size = 64
1e5c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::getAttributes @ bci:8 (line 206) L[0]=sp + #8 L[1]=sp + #32 L[2]=_ L[3]=_ L[4]=_ STK[0]=#1
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [56]=Oop off=7776/0x1e60}
1e60    #@ShouldNotReachHere

1e6c    B335: #	out( N6567 ) &lt;- in( B86 )  Freq: 4.90702e-07
1e6c +  li R11, #-10	# int, #@loadConI
1e70    spill [sp, #8] -&gt; R8	# spill size = 64
1e74 +  spill R14 -&gt; [sp, #0]	# spill size = 64
1e78 +  spill R29 -&gt; [sp, #16]	# spill size = 64
1e7c +  spill R29 -&gt; [sp, #32]	# spill size = 64
1e80 +  spill R7 -&gt; [sp, #40]	# spill size = 64
1e84 +  spill R7 -&gt; [sp, #48]	# spill size = 64
1e88    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL STK[1]=sp + #40 STK[2]=#Ptr0x00000040d81dce00 STK[3]=sp + #0
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=7820/0x1e8c}
1e8c    #@ShouldNotReachHere

1e98    B336: #	out( N6567 ) &lt;- in( B55 )  Freq: 4.84818e-07
1e98 +  li R11, #-52	# int, #@loadConI
1e9c    spill [sp, #8] -&gt; R8	# spill size = 64
1ea0 +  spill R21 -&gt; [sp, #40]	# spill size = 64
1ea4 +  spill R28 -&gt; [sp, #64]	# spill size = 64
1ea8 +  spill R20 -&gt; [sp, #72]	# spill size = 64
1eac +  spill R18 -&gt; [sp, #80]	# spill size = 32
1eb0 +  spill R22 -&gt; [sp, #84]	# spill size = 32
1eb4 +  spill R9 -&gt; [sp, #88]	# spill size = 32
1eb8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:69 (line 369) L[0]=sp + #64 L[1]=sp + #72 L[2]=sp + #80 L[3]=sp + #84 L[4]=_ STK[0]=sp + #88
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #40 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=7868/0x1ebc}
1ebc    #@ShouldNotReachHere

1ec8    B337: #	out( B62 ) &lt;- in( B59 )  Freq: 4.84817e-07
1ec8 +  spill R11 -&gt; R28	# spill size = 64
1ecc +  addi  R29, R7, #-2	#@addL_reg_imm
1ed0    ClearArray R29, R28	#@clearArray_reg_reg
1f28    
1f28 +  j  B62	#@branch

1f2c    B338: #	out( N6567 ) &lt;- in( B63 )  Freq: 4.84817e-07
1f2c +  spill [sp, #8] -&gt; R7	# spill size = 64
1f30 +  li R11, #-52	# int, #@loadConI
1f34    spill R7 -&gt; [sp, #0]	# spill size = 64
1f38 +  spill R19 -&gt; [sp, #16]	# spill size = 64
1f3c +  spill R19 -&gt; [sp, #24]	# spill size = 64
1f40 +  spill R21 -&gt; [sp, #64]	# spill size = 64
1f44 +  spill R20 -&gt; [sp, #80]	# spill size = 64
1f48 +  spill R24 -&gt; [sp, #88]	# spill size = 64
1f4c +  spill R22 -&gt; [sp, #96]	# spill size = 32
1f50    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:97 (line 372) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #88 STK[0]=sp + #80 STK[1]=#0 STK[2]=sp + #88 STK[3]=R8 STK[4]=sp + #96
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #64 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [64]=Oop [80]=Oop [88]=Oop off=8020/0x1f54}
1f54    #@ShouldNotReachHere

1f60    B339: #	out( N6567 ) &lt;- in( B70 )  Freq: 4.84815e-07
1f60 +  spill [sp, #8] -&gt; R7	# spill size = 64
1f64 +  li R11, #-34	# int, #@loadConI
1f68    spill R7 -&gt; [sp, #0]	# spill size = 64
1f6c +  spill R19 -&gt; [sp, #16]	# spill size = 64
1f70 +  spill R19 -&gt; [sp, #24]	# spill size = 64
1f74 +  spill R18 -&gt; [sp, #72]	# spill size = 64
1f78    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:159 (line 186) L[0]=sp + #16 L[1]=_ L[2]=sp + #72 L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #72
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [72]=Oop off=8060/0x1f7c}
1f7c    #@ShouldNotReachHere

1f88    B340: #	out( B79 ) &lt;- in( B78 )  Freq: 4.84273e-07
1f88 +  spill R19 -&gt; R8	# spill size = 64
1f8c +  spill R19 -&gt; R11	# spill size = 64
1f90    
1f90    
1f90    add R12, sp, #144	# box lock
1f94 +  CALL,static 0x000000401390c140	#@CallStaticJavaDirect wrapper for: _complete_monitor_locking_Java
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::next @ bci:-1 (line 205) L[0]=R8 L[1]=_ MON-BOX0=sp+144 MON-OBJ[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::next @ bci:1 (line 132) L[0]=_
        # java.nio.file.FileTreeWalker::next @ bci:47 (line 350) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [48]=Oop [56]=Oop [72]=Oop off=8088/0x1f98}
1f98 +  spill R8 -&gt; R19	# spill size = 64
1f9c +  j  B79	#@branch

1fa0    B341: #	out( B82 ) &lt;- in( B81 )  Freq: 4.84272e-07
1fa0    add R11, sp, #144	# box lock
1fa4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1fa4    spill R23 -&gt; R12	# spill size = 64
1fa8 +  spill R19 -&gt; R10	# spill size = 64
1fac +  CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
1fdc +  j  B82	#@branch

1fe0    B342: #	out( N6567 ) &lt;- in( B142 )  Freq: 4.84249e-07
1fe0 +  spill [sp, #8] -&gt; R8	# spill size = 64
1fe4 +  li R11, #-34	# int, #@loadConI
1fe8    spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
1ff0 +  spill R12 -&gt; [sp, #32]	# spill size = 64
1ff4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:58 (line 288) L[0]=sp + #8 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [56]=Oop off=8184/0x1ff8}
1ff8    #@ShouldNotReachHere

2004    B343: #	out( N6567 ) &lt;- in( B109 )  Freq: 4.8409e-07
2004 +  spill [sp, #8] -&gt; R8	# spill size = 64
2008 +  li R11, #-26	# int, #@loadConI
200c    spill R29 -&gt; [sp, #8]	# spill size = 64
2010 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2014 +  spill R7 -&gt; [sp, #32]	# spill size = 64
2018 +  spill R30 -&gt; [sp, #48]	# spill size = 64
201c +  spill R20 -&gt; [sp, #64]	# spill size = 64
2020 +  spill R13 -&gt; [sp, #72]	# spill size = 32
2024 +  spill R9 -&gt; [sp, #76]	# spill size = 32
2028 +  spill R7 -&gt; [sp, #80]	# spill size = 64
202c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:18 (line 435) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #64 STK[1]=sp + #72
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #76, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #80 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop [80]=Oop off=8240/0x2030}
2030    #@ShouldNotReachHere

203c    B344: #	out( N6567 ) &lt;- in( B111 )  Freq: 4.8409e-07
203c +  spill [sp, #8] -&gt; R8	# spill size = 64
2040 +  li R11, #-187	# int, #@loadConI
2044    spill R29 -&gt; [sp, #8]	# spill size = 64
2048 +  spill R29 -&gt; [sp, #24]	# spill size = 64
204c +  spill R7 -&gt; [sp, #32]	# spill size = 64
2050 +  spill R30 -&gt; [sp, #48]	# spill size = 64
2054 +  spill R7 -&gt; [sp, #64]	# spill size = 64
2058 +  spill R12 -&gt; [sp, #72]	# spill size = 64
205c +  spill R18 -&gt; [sp, #84]	# spill size = 32
2060 +  spill R16 -&gt; [sp, #96]	# spill size = 64
2064 +  spill R17 -&gt; [sp, #104]	# spill size = 64
2068 +  spill R13 -&gt; [sp, #112]	# spill size = 32
206c +  spill R19 -&gt; [sp, #120]	# spill size = 64
2070 +  spill R9 -&gt; [sp, #116]	# spill size = 32
2074    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:29 (line 436) L[0]=sp + #96 L[1]=sp + #104 L[2]=sp + #112 L[3]=sp + #120 STK[0]=#0
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #104 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #32 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #116, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop [96]=Oop [104]=Oop [120]=Oop off=8312/0x2078}
2078    #@ShouldNotReachHere

2084    B345: #	out( N6567 ) &lt;- in( B114 )  Freq: 4.84089e-07
2084 +  spill [sp, #8] -&gt; R8	# spill size = 64
2088 +  li R11, #-26	# int, #@loadConI
208c    spill R29 -&gt; [sp, #8]	# spill size = 64
2090 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2094 +  spill R7 -&gt; [sp, #32]	# spill size = 64
2098 +  spill R30 -&gt; [sp, #48]	# spill size = 64
209c +  spill R31 -&gt; [sp, #64]	# spill size = 64
20a0 +  spill R9 -&gt; [sp, #72]	# spill size = 32
20a4 +  spill R7 -&gt; [sp, #80]	# spill size = 64
20a8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:23 (line 75) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #64 STK[1]=#0
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #72, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #80 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop [80]=Oop off=8364/0x20ac}
20ac    #@ShouldNotReachHere

20b8    B346: #	out( N6567 ) &lt;- in( B127 )  Freq: 4.84077e-07
20b8 +  spill [sp, #8] -&gt; R8	# spill size = 64
20bc +  li R11, #-26	# int, #@loadConI
20c0    spill R12 -&gt; [sp, #0]	# spill size = 64
20c4 +  spill R28 -&gt; [sp, #8]	# spill size = 32
20c8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:18 (line 435) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #0 STK[1]=sp + #8
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop off=8396/0x20cc}
20cc    #@ShouldNotReachHere

20d8    B347: #	out( N6567 ) &lt;- in( B129 )  Freq: 4.84076e-07
20d8 +  spill [sp, #8] -&gt; R8	# spill size = 64
20dc +  li R11, #-187	# int, #@loadConI
20e0    spill R31 -&gt; [sp, #8]	# spill size = 64
20e4 +  spill R30 -&gt; [sp, #64]	# spill size = 64
20e8 +  spill R28 -&gt; [sp, #36]	# spill size = 32
20ec +  spill R29 -&gt; [sp, #72]	# spill size = 64
20f0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:29 (line 436) L[0]=sp + #8 L[1]=sp + #64 L[2]=sp + #36 L[3]=sp + #72 STK[0]=#0
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #64 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #48 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=8436/0x20f4}
20f4    #@ShouldNotReachHere

2100    B348: #	out( N6567 ) &lt;- in( B132 )  Freq: 4.84075e-07
2100 +  li R11, #-26	# int, #@loadConI
2104    spill [sp, #8] -&gt; R8	# spill size = 64
2108 +  spill R10 -&gt; [sp, #0]	# spill size = 64
210c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:40 (line 115) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #0 STK[1]=#0
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop off=8464/0x2110}
2110    #@ShouldNotReachHere

211c    B349: #	out( N6567 ) &lt;- in( B92 )  Freq: 4.84005e-07
211c +  decode_heap_oop  R8, R10	#@decodeHeapOop
2120    spill [sp, #8] -&gt; R30	# spill size = 64
2124 +  li R11, #-187	# int, #@loadConI
2128    spill R30 -&gt; [sp, #0]	# spill size = 64
212c +  spill R14 -&gt; [sp, #8]	# spill size = 64
2130 +  spill R13 -&gt; [sp, #16]	# spill size = 32
2134 +  spill R29 -&gt; [sp, #32]	# spill size = 64
2138 +  spill R29 -&gt; [sp, #48]	# spill size = 64
213c +  spill R7 -&gt; [sp, #64]	# spill size = 64
2140 +  spill R7 -&gt; [sp, #72]	# spill size = 64
2144 +  spill R28 -&gt; [sp, #20]	# spill size = 32
2148    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.Util::followLinks @ bci:27 (line 122) L[0]=_ L[1]=_ L[2]=sp + #8 L[3]=sp + #20 L[4]=sp + #16 L[5]=R8 STK[0]=R8 STK[1]=#Ptr0x00000040d0452e10
        # sun.nio.fs.UnixFileSystemProvider::getFileAttributeView @ bci:7 (line 120) L[0]=_ L[1]=_ L[2]=#Ptr0x00000040d81932d0 L[3]=_ L[4]=sp + #64 L[5]=_
        # sun.nio.fs.LinuxFileSystemProvider::getFileAttributeView @ bci:48 (line 68) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:51 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #32 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #48 L[1]=sp + #64 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #32 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=8524/0x214c}
214c    #@ShouldNotReachHere

2158    B350: #	out( N6567 ) &lt;- in( B29 )  Freq: 2.63272e-07
2158 +  li R11, #-187	# int, #@loadConI
215c    spill R9 -&gt; R8	# spill size = 64
2160 +  spill R19 -&gt; [sp, #8]	# spill size = 64
2164 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2168 +  spill R28 -&gt; [sp, #40]	# spill size = 32
216c +  spill R18 -&gt; [sp, #48]	# spill size = 64
2170 +  spill R24 -&gt; [sp, #56]	# spill size = 64
2174    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream::isOpen @ bci:4 (line 83) L[0]=_ STK[0]=sp + #40
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:39 (line 164) L[0]=sp + #8 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [48]=Oop [56]=Oop off=8568/0x2178}
2178    #@ShouldNotReachHere

2184    B351: #	out( N6567 ) &lt;- in( B37 )  Freq: 2.63265e-07
2184 +  spill [sp, #8] -&gt; R7	# spill size = 64
2188 +  li R11, #-187	# int, #@loadConI
218c    spill R7 -&gt; [sp, #0]	# spill size = 64
2190 +  spill R29 -&gt; [sp, #16]	# spill size = 64
2194 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2198 +  spill R12 -&gt; [sp, #80]	# spill size = 64
219c +  spill R30 -&gt; [sp, #96]	# spill size = 64
21a0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryReleaseShared @ bci:9 (line 417) L[0]=sp + #80 L[1]=_ L[2]=sp + #96 L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #96
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:2 (line 1094) L[0]=sp + #80 L[1]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #16 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [64]=Oop [80]=Oop [96]=Oop off=8612/0x21a4}
21a4    #@ShouldNotReachHere

21b0    B352: #	out( N6567 ) &lt;- in( B38 )  Freq: 2.63265e-07
21b0 +  li R11, #-187	# int, #@loadConI
21b4    spill [sp, #8] -&gt; R8	# spill size = 64
21b8 +  spill R12 -&gt; [sp, #72]	# spill size = 64
21bc +  spill R31 -&gt; [sp, #80]	# spill size = 32
21c0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryReleaseShared @ bci:17 (line 419) L[0]=sp + #72 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #80 STK[1]=#1
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:2 (line 1094) L[0]=sp + #72 L[1]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=8644/0x21c4}
21c4    #@ShouldNotReachHere

21d0    B353: #	out( N6567 ) &lt;- in( B41 )  Freq: 2.63264e-07
21d0 +  spill [sp, #8] -&gt; R8	# spill size = 64
21d4 +  li R11, #-187	# int, #@loadConI
21d8    spill R29 -&gt; [sp, #8]	# spill size = 64
21dc +  spill R29 -&gt; [sp, #16]	# spill size = 64
21e0 +  spill R12 -&gt; [sp, #40]	# spill size = 64
21e4 +  spill R31 -&gt; [sp, #72]	# spill size = 32
21e8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryReleaseShared @ bci:134 (line 443) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #72
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:2 (line 1094) L[0]=sp + #40 L[1]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop off=8684/0x21ec}
21ec    #@ShouldNotReachHere

21f8    B354: #	out( B40 ) &lt;- in( B226 )  Freq: 2.63258e-07
21f8 +  spill R12 -&gt; R19	# spill size = 64
21fc    
21fc    
21fc +  spill R29 -&gt; R9	# spill size = 64
2200    
2200    
2200 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2200    spill R23 -&gt; R11	# spill size = 64
2204 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2234 +  spill R9 -&gt; R29	# spill size = 64
2238 +  spill [sp, #16] -&gt; R30	# spill size = 64
223c +  spill R19 -&gt; R12	# spill size = 64
2240 +  j  B40	#@branch

2244    B355: #	out( N6567 ) &lt;- in( B40 )  Freq: 2.51069e-07
2244 +  spill [sp, #8] -&gt; R7	# spill size = 64
2248 +  li R11, #-187	# int, #@loadConI
224c    spill R7 -&gt; [sp, #0]	# spill size = 64
2250 +  spill R29 -&gt; [sp, #16]	# spill size = 64
2254 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2258 +  spill R12 -&gt; [sp, #80]	# spill size = 64
225c +  spill R31 -&gt; [sp, #88]	# spill size = 32
2260    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryReleaseShared @ bci:129 (line 439) L[0]=sp + #80 L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #88 STK[0]=R8
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:2 (line 1094) L[0]=sp + #80 L[1]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #16 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [64]=Oop [80]=Oop off=8804/0x2264}
2264    #@ShouldNotReachHere

2270    B356: #	out( N6567 ) &lt;- in( B8 )  Freq: 2.49522e-07
2270 +  li R11, #-187	# int, #@loadConI
2274    spill R9 -&gt; [sp, #0]	# spill size = 64
2278 +  spill R18 -&gt; [sp, #8]	# spill size = 64
227c +  spill R24 -&gt; [sp, #16]	# spill size = 64
2280    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:26 (line 346) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=_ L[6]=_ STK[0]=R8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=8836/0x2284}
2284    #@ShouldNotReachHere

2290    B357: #	out( N6567 ) &lt;- in( B12 )  Freq: 2.49521e-07
2290 +  li R11, #-187	# int, #@loadConI
2294    spill R9 -&gt; [sp, #0]	# spill size = 64
2298 +  spill R19 -&gt; [sp, #16]	# spill size = 64
229c +  spill R19 -&gt; [sp, #24]	# spill size = 64
22a0 +  spill R18 -&gt; [sp, #32]	# spill size = 64
22a4 +  spill R24 -&gt; [sp, #40]	# spill size = 64
22a8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:4 (line 197) L[0]=sp + #24 STK[0]=R8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #32 L[1]=sp + #40 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=8876/0x22ac}
22ac    #@ShouldNotReachHere

22b8    B358: #	out( N6567 ) &lt;- in( B13 )  Freq: 2.49521e-07
22b8 +  li R11, #-187	# int, #@loadConI
22bc    spill R9 -&gt; R8	# spill size = 64
22c0 +  spill R19 -&gt; [sp, #8]	# spill size = 64
22c4 +  spill R19 -&gt; [sp, #16]	# spill size = 64
22c8 +  spill R18 -&gt; [sp, #24]	# spill size = 64
22cc +  spill R24 -&gt; [sp, #32]	# spill size = 64
22d0 +  spill R28 -&gt; [sp, #40]	# spill size = 32
22d4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:11 (line 197) L[0]=sp + #16 STK[0]=sp + #40 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #24 L[1]=sp + #32 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop off=8920/0x22d8}
22d8    #@ShouldNotReachHere

22e4    B359: #	out( N6567 ) &lt;- in( B23 )  Freq: 2.49519e-07
22e4 +  li R11, #-187	# int, #@loadConI
22e8    spill R9 -&gt; R8	# spill size = 64
22ec +  spill R19 -&gt; [sp, #8]	# spill size = 64
22f0 +  spill R19 -&gt; [sp, #16]	# spill size = 64
22f4 +  spill R18 -&gt; [sp, #40]	# spill size = 64
22f8 +  spill R24 -&gt; [sp, #48]	# spill size = 64
22fc +  spill R21 -&gt; [sp, #64]	# spill size = 64
2300 +  spill R20 -&gt; [sp, #72]	# spill size = 64
2304 +  spill R29 -&gt; [sp, #80]	# spill size = 32
2308    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:60 (line 478) L[0]=sp + #64 L[1]=_ L[2]=sp + #72 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #80
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #64 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #8 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #40 L[1]=sp + #48 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop [64]=Oop [72]=Oop off=8972/0x230c}
230c    #@ShouldNotReachHere

2318    B360: #	out( B25 ) &lt;- in( B229 )  Freq: 2.49513e-07
2318 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2318    spill R23 -&gt; R11	# spill size = 64
231c +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
234c +  j  B25	#@branch

2350    B361: #	out( B73 ) &lt;- in( B232 )  Freq: 2.49502e-07
2350 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2350    spill R23 -&gt; R11	# spill size = 64
2354 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2384 +  j  B73	#@branch

2388    B362: #	out( B155 ) &lt;- in( B235 )  Freq: 2.49473e-07
2388 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2388    spill R23 -&gt; R11	# spill size = 64
238c +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
23bc +  j  B155	#@branch

23c0    B363: #	out( N6567 ) &lt;- in( B89 )  Freq: 2.45306e-07
23c0 +  li R11, #-138	# int, #@loadConI
23c4    spill [sp, #8] -&gt; R8	# spill size = 64
23c8 +  spill R14 -&gt; [sp, #0]	# spill size = 64
23cc +  spill R29 -&gt; [sp, #16]	# spill size = 64
23d0 +  spill R29 -&gt; [sp, #32]	# spill size = 64
23d4 +  spill R7 -&gt; [sp, #40]	# spill size = 64
23d8 +  spill R7 -&gt; [sp, #48]	# spill size = 64
23dc +  spill R28 -&gt; [sp, #68]	# spill size = 32
23e0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.Util::followLinks @ bci:13 (line 121) L[0]=_ L[1]=#1 L[2]=sp + #0 L[3]=sp + #68 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=sp + #68
        # sun.nio.fs.UnixFileSystemProvider::getFileAttributeView @ bci:7 (line 120) L[0]=_ L[1]=_ L[2]=#Ptr0x00000040d81932d0 L[3]=_ L[4]=sp + #40 L[5]=_
        # sun.nio.fs.LinuxFileSystemProvider::getFileAttributeView @ bci:48 (line 68) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:51 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=9188/0x23e4}
23e4    #@ShouldNotReachHere

23f0    B364: #	out( N6567 ) &lt;- in( B51 )  Freq: 2.42409e-07
23f0 +  li R11, #-187	# int, #@loadConI
23f4    spill [sp, #8] -&gt; R8	# spill size = 64
23f8 +  spill R21 -&gt; [sp, #40]	# spill size = 64
23fc +  spill R28 -&gt; [sp, #64]	# spill size = 64
2400 +  spill R20 -&gt; [sp, #72]	# spill size = 64
2404 +  spill R22 -&gt; [sp, #84]	# spill size = 32
2408 +  spill R18 -&gt; [sp, #88]	# spill size = 32
240c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 361) L[0]=sp + #64 L[1]=sp + #72 L[2]=sp + #88 L[3]=sp + #84 L[4]=_ STK[0]=sp + #88
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #40 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=9232/0x2410}
2410    #@ShouldNotReachHere

241c    B365: #	out( B81 ) &lt;- in( B248 )  Freq: 2.4213e-07
241c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
241c    spill R23 -&gt; R11	# spill size = 64
2420 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2450 +  j  B81	#@branch

2454    B366: #	out( N6567 ) &lt;- in( B116 )  Freq: 2.42044e-07
2454 +  spill [sp, #8] -&gt; R28	# spill size = 64
2458 +  li R11, #-187	# int, #@loadConI
245c    spill R28 -&gt; [sp, #0]	# spill size = 64
2460 +  spill R29 -&gt; [sp, #16]	# spill size = 64
2464 +  spill R29 -&gt; [sp, #32]	# spill size = 64
2468 +  spill R7 -&gt; [sp, #40]	# spill size = 64
246c +  spill R30 -&gt; [sp, #64]	# spill size = 64
2470 +  spill R7 -&gt; [sp, #72]	# spill size = 64
2474 +  spill R12 -&gt; [sp, #80]	# spill size = 64
2478 +  spill R18 -&gt; [sp, #92]	# spill size = 32
247c +  spill R31 -&gt; [sp, #96]	# spill size = 64
2480 +  spill R21 -&gt; [sp, #104]	# spill size = 64
2484 +  spill R18 -&gt; [sp, #112]	# spill size = 32
2488 +  spill R9 -&gt; [sp, #116]	# spill size = 32
248c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:34 (line 76) L[0]=sp + #112 L[1]=sp + #96 L[2]=#0 L[3]=sp + #104 STK[0]=R8 STK[1]=sp + #92
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #40 L[1]=sp + #80 L[2]=sp + #92 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #64 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #64
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #116, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [80]=Oop [96]=Oop [104]=Oop off=9360/0x2490}
2490    #@ShouldNotReachHere

249c    B367: #	out( B118 ) &lt;- in( B251 )  Freq: 2.42038e-07
249c +  spill R15 -&gt; R26	# spill size = 32
24a0    
24a0 +  spill R14 -&gt; R19	# spill size = 64
24a4    
24a4    
24a4 +  spill R12 -&gt; R25	# spill size = 64
24a8    
24a8    
24a8 +  spill R31 -&gt; R8	# spill size = 64
24ac    
24ac    
24ac +  spill R21 -&gt; [sp, #16]	# spill size = 64
24b0 +  spill R30 -&gt; R21	# spill size = 64
24b4    
24b4    
24b4 +  spill R9 -&gt; R22	# spill size = 32
24b8 +  spill R29 -&gt; R9	# spill size = 64
24bc    
24bc    
24bc +  spill R28 -&gt; [sp, #0]	# spill size = 32
24c0    
24c0 +  spill R7 -&gt; R20	# spill size = 64
24c4    
24c4    
24c4 +  spill R11 -&gt; R24	# spill size = 32
24cc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
24cc    spill R23 -&gt; R11	# spill size = 64
24d0 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2500 +  spill R9 -&gt; R29	# spill size = 64
2504 +  spill R21 -&gt; R30	# spill size = 64
2508 +  spill R19 -&gt; R14	# spill size = 64
250c +  spill R20 -&gt; R7	# spill size = 64
2510 +  spill R22 -&gt; R9	# spill size = 32
2514 +  spill R24 -&gt; R11	# spill size = 32
251c +  spill R25 -&gt; R12	# spill size = 64
2520 +  spill R26 -&gt; R15	# spill size = 32
2524 +  spill R8 -&gt; R31	# spill size = 64
2528 +  spill [sp, #0] -&gt; R28	# spill size = 32
252c +  spill [sp, #16] -&gt; R21	# spill size = 64
2530 +  j  B118	#@branch

2534    B368: #	out( N6567 ) &lt;- in( B133 )  Freq: 2.42037e-07
2534 +  spill [sp, #8] -&gt; R7	# spill size = 64
2538 +  li R11, #-187	# int, #@loadConI
253c    spill R7 -&gt; [sp, #0]	# spill size = 64
2540 +  spill R10 -&gt; [sp, #8]	# spill size = 64
2544    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:41 (line 115) L[0]=sp + #48 L[1]=sp + #8 L[2]=#0 L[3]=_ STK[0]=R8
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop off=9544/0x2548}
2548    #@ShouldNotReachHere

2554    B369: #	out( B135 ) &lt;- in( B254 )  Freq: 2.42031e-07
2554 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2554    spill R23 -&gt; R11	# spill size = 64
2558 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2588 +  j  B135	#@branch

258c    B370: #	out( N6567 ) &lt;- in( B19 )  Freq: 2.37961e-07
258c +  li R11, #-187	# int, #@loadConI
2590    spill R9 -&gt; [sp, #0]	# spill size = 64
2594 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2598 +  spill R19 -&gt; [sp, #24]	# spill size = 64
259c +  spill R18 -&gt; [sp, #48]	# spill size = 64
25a0 +  spill R24 -&gt; [sp, #56]	# spill size = 64
25a4 +  spill R21 -&gt; [sp, #72]	# spill size = 64
25a8 +  spill R20 -&gt; [sp, #80]	# spill size = 64
25ac +  spill R31 -&gt; [sp, #88]	# spill size = 32
25b0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:13 (line 471) L[0]=sp + #72 L[1]=_ L[2]=sp + #80 L[3]=sp + #88 L[4]=_ L[5]=_ STK[0]=R8
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #72 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #16 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [72]=Oop [80]=Oop off=9652/0x25b4}
25b4    #@ShouldNotReachHere

25c0    B371: #	out( N6567 ) &lt;- in( B21 )  Freq: 2.3796e-07
25c0 +  li R11, #-187	# int, #@loadConI
25c4    spill R9 -&gt; R8	# spill size = 64
25c8 +  spill R19 -&gt; [sp, #8]	# spill size = 64
25cc +  spill R19 -&gt; [sp, #16]	# spill size = 64
25d0 +  spill R18 -&gt; [sp, #40]	# spill size = 64
25d4 +  spill R24 -&gt; [sp, #48]	# spill size = 64
25d8 +  spill R21 -&gt; [sp, #64]	# spill size = 64
25dc +  spill R20 -&gt; [sp, #72]	# spill size = 64
25e0 +  spill R31 -&gt; [sp, #80]	# spill size = 32
25e4 +  spill R29 -&gt; [sp, #88]	# spill size = 32
25e8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:43 (line 475) L[0]=sp + #64 L[1]=_ L[2]=sp + #72 L[3]=sp + #80 L[4]=sp + #88 L[5]=_ STK[0]=sp + #88 STK[1]=#65535
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #64 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #8 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #40 L[1]=sp + #48 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop [64]=Oop [72]=Oop off=9708/0x25ec}
25ec    #@ShouldNotReachHere

25f8    B372: #	out( N6567 ) &lt;- in( B22 )  Freq: 2.3796e-07
25f8 +  li R11, #-187	# int, #@loadConI
25fc    spill R9 -&gt; [sp, #0]	# spill size = 64
2600 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2604 +  spill R19 -&gt; [sp, #24]	# spill size = 64
2608 +  spill R18 -&gt; [sp, #48]	# spill size = 64
260c +  spill R24 -&gt; [sp, #56]	# spill size = 64
2610 +  spill R21 -&gt; [sp, #72]	# spill size = 64
2614 +  spill R20 -&gt; [sp, #80]	# spill size = 64
2618 +  spill R29 -&gt; [sp, #88]	# spill size = 32
261c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:55 (line 477) L[0]=sp + #72 L[1]=_ L[2]=sp + #80 L[3]=_ L[4]=sp + #88 L[5]=_ STK[0]=R8
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #72 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #16 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [72]=Oop [80]=Oop off=9760/0x2620}
2620    #@ShouldNotReachHere

262c    B373: #	out( B120 ) &lt;- in( B261 )  Freq: 2.35289e-07
262c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
262c    spill R23 -&gt; R11	# spill size = 64
2630 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2660 +  j  B120	#@branch

2664    B374: #	out( N6567 ) &lt;- in( B49 )  Freq: 2.3118e-07
2664 +  lwu  R28, [R21, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
2668 +  decode_heap_oop  R8, R28	#@decodeHeapOop
266c    spill [sp, #8] -&gt; R28	# spill size = 64
2670 +  li R11, #-187	# int, #@loadConI
2674    spill R28 -&gt; [sp, #0]	# spill size = 64
2678 +  spill R19 -&gt; [sp, #16]	# spill size = 64
267c +  spill R19 -&gt; [sp, #24]	# spill size = 64
2680 +  spill R21 -&gt; [sp, #64]	# spill size = 64
2684 +  spill R7 -&gt; [sp, #80]	# spill size = 32
2688 +  spill R20 -&gt; [sp, #88]	# spill size = 64
268c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:18 (line 380) L[0]=sp + #64 L[1]=#ScObj0 L[2]=sp + #88 L[3]=_ STK[0]=sp + #80 STK[1]=#47
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=R8, [path :2]=sp + #88, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [64]=Oop [88]=Oop off=9872/0x2690}
2690    #@ShouldNotReachHere

269c    B375: #	out( N6567 ) &lt;- in( B52 )  Freq: 2.31179e-07
269c +  li R11, #-187	# int, #@loadConI
26a0    spill [sp, #8] -&gt; R8	# spill size = 64
26a4 +  spill R21 -&gt; [sp, #40]	# spill size = 64
26a8 +  spill R28 -&gt; [sp, #64]	# spill size = 64
26ac +  spill R20 -&gt; [sp, #72]	# spill size = 64
26b0 +  spill R22 -&gt; [sp, #84]	# spill size = 32
26b4 +  spill R18 -&gt; [sp, #88]	# spill size = 32
26b8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:28 (line 364) L[0]=sp + #64 L[1]=sp + #72 L[2]=sp + #88 L[3]=sp + #84 L[4]=_ STK[0]=sp + #88 STK[1]=#1
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #40 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=9916/0x26bc}
26bc    #@ShouldNotReachHere

26c8    B376: #	out( N6567 ) &lt;- in( B97 )  Freq: 2.30918e-07
26c8 +  spill [sp, #8] -&gt; R28	# spill size = 64
26cc +  li R11, #-187	# int, #@loadConI
26d0    spill R28 -&gt; [sp, #0]	# spill size = 64
26d4 +  spill R29 -&gt; [sp, #16]	# spill size = 64
26d8 +  spill R29 -&gt; [sp, #32]	# spill size = 64
26dc +  spill R7 -&gt; [sp, #40]	# spill size = 64
26e0 +  spill R7 -&gt; [sp, #48]	# spill size = 64
26e4 +  spill R9 -&gt; [sp, #64]	# spill size = 32
26e8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.System::allowSecurityManager @ bci:4 (line 193) STK[0]=R8 STK[1]=#1
        # java.lang.System::getSecurityManager @ bci:0 (line 483)
        # sun.nio.fs.UnixPath::checkRead @ bci:0 (line 778) L[0]=sp + #40 L[1]=_
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:4 (line 49) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=9964/0x26ec}
26ec    #@ShouldNotReachHere

26f8    B377: #	out( N6567 ) &lt;- in( B98 )  Freq: 2.30917e-07
26f8 +  spill [sp, #8] -&gt; R28	# spill size = 64
26fc +  li R11, #-187	# int, #@loadConI
2700    spill R28 -&gt; [sp, #0]	# spill size = 64
2704 +  spill R29 -&gt; [sp, #16]	# spill size = 64
2708 +  spill R29 -&gt; [sp, #32]	# spill size = 64
270c +  spill R7 -&gt; [sp, #40]	# spill size = 64
2710 +  spill R7 -&gt; [sp, #48]	# spill size = 64
2714 +  spill R9 -&gt; [sp, #64]	# spill size = 32
2718    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::checkRead @ bci:5 (line 779) L[0]=sp + #40 L[1]=R8 STK[0]=R8
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:4 (line 49) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=10012/0x271c}
271c    #@ShouldNotReachHere

2728    B378: #	out( N6567 ) &lt;- in( B141 )  Freq: 2.30908e-07
2728 +  spill [sp, #8] -&gt; R7	# spill size = 64
272c +  li R11, #-187	# int, #@loadConI
2730    spill R7 -&gt; [sp, #0]	# spill size = 64
2734 +  spill R12 -&gt; [sp, #32]	# spill size = 64
2738 +  spill R28 -&gt; [sp, #40]	# spill size = 32
273c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:53 (line 288) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ STK[0]=R8 STK[1]=sp + #40
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop [56]=Oop off=10048/0x2740}
2740    #@ShouldNotReachHere

274c    B379: #	out( N6567 ) &lt;- in( B103 )  Freq: 2.30833e-07
274c +  spill [sp, #8] -&gt; R8	# spill size = 64
2750 +  li R11, #-187	# int, #@loadConI
2754    spill R29 -&gt; [sp, #8]	# spill size = 64
2758 +  spill R29 -&gt; [sp, #24]	# spill size = 64
275c +  spill R7 -&gt; [sp, #32]	# spill size = 64
2760 +  spill R30 -&gt; [sp, #48]	# spill size = 64
2764 +  spill R7 -&gt; [sp, #64]	# spill size = 64
2768 +  spill R10 -&gt; [sp, #80]	# spill size = 32
276c +  spill R9 -&gt; [sp, #84]	# spill size = 32
2770    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getByteArrayForSysCalls @ bci:7 (line 135) L[0]=sp + #32 L[1]=_ STK[0]=sp + #80
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:1 (line 37) L[0]=sp + #32 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #84, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop off=10100/0x2774}
2774    #@ShouldNotReachHere

2780    B380: #	out( N6567 ) &lt;- in( B105 )  Freq: 2.30833e-07
2780 +  spill [sp, #8] -&gt; R8	# spill size = 64
2784 +  li R11, #-187	# int, #@loadConI
2788    spill R29 -&gt; [sp, #8]	# spill size = 64
278c +  spill R29 -&gt; [sp, #24]	# spill size = 64
2790 +  spill R7 -&gt; [sp, #32]	# spill size = 64
2794 +  spill R30 -&gt; [sp, #48]	# spill size = 64
2798 +  spill R7 -&gt; [sp, #64]	# spill size = 64
279c +  spill R15 -&gt; [sp, #80]	# spill size = 32
27a0 +  spill R9 -&gt; [sp, #84]	# spill size = 32
27a4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::isEmpty @ bci:5 (line 216) L[0]=_ STK[0]=sp + #80
        # sun.nio.fs.UnixPath::getByteArrayForSysCalls @ bci:26 (line 138) L[0]=sp + #32 L[1]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:1 (line 37) L[0]=sp + #32 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #84, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop off=10152/0x27a8}
27a8    #@ShouldNotReachHere

27b4    B381: #	out( N6567 ) &lt;- in( B170 )  Freq: 2.74951e-08
27b4 +  spill [sp, #8] -&gt; R7	# spill size = 64
27b8 +  li R11, #-34	# int, #@loadConI
27bc    spill R7 -&gt; [sp, #0]	# spill size = 64
27c0 +  spill R19 -&gt; [sp, #16]	# spill size = 64
27c4 +  spill R19 -&gt; [sp, #24]	# spill size = 64
27c8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #16 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop off=10188/0x27cc}
27cc    #@ShouldNotReachHere

27d8    B382: #	out( N6567 ) &lt;- in( B173 )  Freq: 2.7495e-08
27d8 +  spill [sp, #8] -&gt; R7	# spill size = 64
27dc +  li R11, #-20	# int, #@loadConI
27e0    spill R7 -&gt; [sp, #0]	# spill size = 64
27e4 +  spill R19 -&gt; [sp, #16]	# spill size = 64
27e8 +  spill R19 -&gt; [sp, #24]	# spill size = 64
27ec +  spill R29 -&gt; [sp, #80]	# spill size = 64
27f0 +  spill R31 -&gt; [sp, #88]	# spill size = 32
27f4 +  spill R30 -&gt; [sp, #92]	# spill size = 32
27f8 +  spill R29 -&gt; [sp, #96]	# spill size = 64
27fc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_assert&apos; action=&apos;make_not_entrant&apos;)
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::hasQueuedPredecessors @ bci:6 (line 1234) L[0]=sp + #80 L[1]=#NULL L[2]=_ L[3]=_ STK[0]=R8
        # java.util.concurrent.locks.ReentrantReadWriteLock$FairSync::readerShouldBlock @ bci:1 (line 706) L[0]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:33 (line 475) L[0]=sp + #96 L[1]=_ L[2]=sp + #72 L[3]=sp + #88 L[4]=sp + #92 L[5]=_
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #80 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #16 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [72]=Oop [80]=Oop [96]=Oop off=10240/0x2800}
2800    #@ShouldNotReachHere

280c    B383: #	out( N6567 ) &lt;- in( B181 )  Freq: 1.54602e-08
280c +  li R11, #-10	# int, #@loadConI
2810    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:57 (line 94) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # OopMap {off=10260/0x2814}
2814    #@ShouldNotReachHere

2820    B384: #	out( N6567 ) &lt;- in( B188 )  Freq: 1.49395e-08
2820 +  li R11, #-10	# int, #@loadConI
2824    spill [sp, #8] -&gt; R8	# spill size = 64
2828    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:109 (line 369) L[0]=_ L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_ STK[0]=#NULL
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop off=10284/0x282c}
282c    #@ShouldNotReachHere

2838    B385: #	out( N6567 ) &lt;- in( B186 )  Freq: 1.47441e-08
2838 +  spill [sp, #8] -&gt; R8	# spill size = 64
283c +  li R11, #-34	# int, #@loadConI
2840    spill R30 -&gt; [sp, #8]	# spill size = 64
2844    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:76 (line 361) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_ STK[0]=sp + #8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [48]=Oop [56]=Oop off=10312/0x2848}
2848    #@ShouldNotReachHere

2854    B386: #	out( N6567 ) &lt;- in( B218 )  Freq: 1.39166e-08
2854 +  spill [sp, #8] -&gt; R8	# spill size = 64
2858 +  li R11, #-10	# int, #@loadConI
285c    spill R18 -&gt; [sp, #8]	# spill size = 64
2860    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:187 (line 311) L[0]=_ L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ STK[0]=#NULL STK[1]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [56]=Oop off=10340/0x2864}
2864    #@ShouldNotReachHere

2870    B387: #	out( N6567 ) &lt;- in( B176 )  Freq: 1.37475e-08
2870 +  li R11, #-187	# int, #@loadConI
2874    spill [sp, #8] -&gt; R8	# spill size = 64
2878 +  spill R29 -&gt; [sp, #64]	# spill size = 64
287c +  spill R30 -&gt; [sp, #80]	# spill size = 32
2880    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:60 (line 478) L[0]=sp + #64 L[1]=_ L[2]=sp + #72 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #80
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #64 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=10372/0x2884}
2884    #@ShouldNotReachHere

2890    B388: #	out( B178 ) &lt;- in( B281 )  Freq: 1.37471e-08
2890 +  spill R29 -&gt; R18	# spill size = 64
2894    
2894    
2894 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2894    spill R23 -&gt; R11	# spill size = 64
2898 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
28c8 +  spill R18 -&gt; R29	# spill size = 64
28cc +  j  B178	#@branch

28d0    B389: #	out( N6567 ) &lt;- in( B164 )  Freq: 1.35736e-08
28d0 +  li R11, #-25	# int, #@loadConI
28d4    spill [sp, #8] -&gt; R8	# spill size = 64
28d8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;none&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::isSelfOrParent @ bci:22 (line 146) L[0]=_ L[1]=_ STK[0]=sp + #64 STK[1]=#1
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:123 (line 181) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop off=10460/0x28dc}
28dc    #@ShouldNotReachHere

28e8    B390: #	out( N6567 ) &lt;- in( B172 )  Freq: 1.31106e-08
28e8 +  spill [sp, #8] -&gt; R7	# spill size = 64
28ec +  li R11, #-187	# int, #@loadConI
28f0    spill R7 -&gt; [sp, #0]	# spill size = 64
28f4 +  spill R19 -&gt; [sp, #16]	# spill size = 64
28f8 +  spill R19 -&gt; [sp, #24]	# spill size = 64
28fc +  spill R29 -&gt; [sp, #80]	# spill size = 64
2900 +  spill R31 -&gt; [sp, #88]	# spill size = 32
2904    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:13 (line 471) L[0]=sp + #80 L[1]=_ L[2]=sp + #72 L[3]=sp + #88 L[4]=_ L[5]=_ STK[0]=R8
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #80 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #16 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [72]=Oop [80]=Oop off=10504/0x2908}
2908    #@ShouldNotReachHere

2914    B391: #	out( N6567 ) &lt;- in( B174 )  Freq: 1.31106e-08
2914 +  li R11, #-187	# int, #@loadConI
2918    spill [sp, #8] -&gt; R8	# spill size = 64
291c +  spill R29 -&gt; [sp, #64]	# spill size = 64
2920 +  spill R31 -&gt; [sp, #80]	# spill size = 32
2924 +  spill R30 -&gt; [sp, #88]	# spill size = 32
2928    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:43 (line 475) L[0]=sp + #64 L[1]=_ L[2]=sp + #72 L[3]=sp + #80 L[4]=sp + #88 L[5]=_ STK[0]=sp + #88 STK[1]=#65535
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #64 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=10540/0x292c}
292c    #@ShouldNotReachHere

2938    B392: #	out( N6567 ) &lt;- in( B175 )  Freq: 1.31106e-08
2938 +  spill [sp, #8] -&gt; R7	# spill size = 64
293c +  li R11, #-187	# int, #@loadConI
2940    spill R7 -&gt; [sp, #0]	# spill size = 64
2944 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2948 +  spill R19 -&gt; [sp, #24]	# spill size = 64
294c +  spill R29 -&gt; [sp, #80]	# spill size = 64
2950 +  spill R30 -&gt; [sp, #88]	# spill size = 32
2954    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:55 (line 477) L[0]=sp + #80 L[1]=_ L[2]=sp + #72 L[3]=_ L[4]=sp + #88 L[5]=_ STK[0]=R8
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #80 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #16 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [72]=Oop [80]=Oop off=10584/0x2958}
2958    #@ShouldNotReachHere

2964    B393: #	out( B202 ) &lt;- in( B294 )  Freq: 6.86706e-09
2964 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2964    spill R23 -&gt; R11	# spill size = 64
2968 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2998 +  j  B202	#@branch

299c    B394: #	out( B205 ) &lt;- in( B288 )  Freq: 6.86706e-09
299c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
299c    spill R23 -&gt; R11	# spill size = 64
29a0 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
29d0 +  j  B205	#@branch

29d4    B395: #	out( B209 ) &lt;- in( B291 )  Freq: 6.86706e-09
29d4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
29d4    spill R23 -&gt; R11	# spill size = 64
29d8 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2a08 +  j  B209	#@branch

2a0c    B396: #	out( B215 ) &lt;- in( B297 )  Freq: 6.86693e-09
2a0c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2a0c    spill R23 -&gt; R11	# spill size = 64
2a10 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2a40 +  j  B215	#@branch

2a44    B397: #	out( N6567 ) &lt;- in( B163 )  Freq: 6.78678e-09
2a44 +  li R11, #-187	# int, #@loadConI
2a48    spill [sp, #8] -&gt; R8	# spill size = 64
2a4c +  spill R22 -&gt; [sp, #72]	# spill size = 32
2a50    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::isSelfOrParent @ bci:17 (line 146) L[0]=_ L[1]=sp + #64 STK[0]=sp + #72 STK[1]=#2
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:123 (line 181) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop off=10836/0x2a54}
2a54    #@ShouldNotReachHere

2a60    B398: #	out( N6567 ) &lt;- in( B195 )  Freq: 6.54938e-09
2a60 +  spill [sp, #8] -&gt; R7	# spill size = 64
2a64 +  li R11, #-187	# int, #@loadConI
2a68    spill R7 -&gt; [sp, #0]	# spill size = 64
2a6c +  spill R30 -&gt; [sp, #32]	# spill size = 64
2a70    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:84 (line 293) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ STK[0]=R8
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop [56]=Oop off=10868/0x2a74}
2a74    #@ShouldNotReachHere

2a80    B399: #	out( N6567 ) &lt;- in( B7 )  Freq: 1e-35
2a80 +  li R11, #-34	# int, #@loadConI
2a84    spill R9 -&gt; R8	# spill size = 64
2a88 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2a8c +  spill R24 -&gt; [sp, #8]	# spill size = 64
2a90    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:7 (line 335) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=sp + #8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=10900/0x2a94}
2a94    #@ShouldNotReachHere

2aa0    B400: #	out( N6567 ) &lt;- in( B82 )  Freq: 1e-35
2aa0 +  li R11, #-34	# int, #@loadConI
2aa4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:52 (line 350) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=_ L[6]=_ STK[0]=R8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [48]=Oop [56]=Oop off=10920/0x2aa8}
2aa8    #@ShouldNotReachHere

2ab4    B401: #	out( N6567 ) &lt;- in( B113 )  Freq: 1e-35
2ab4 +  spill [sp, #8] -&gt; R8	# spill size = 64
2ab8 +  li R11, #-34	# int, #@loadConI
2abc    spill R29 -&gt; [sp, #8]	# spill size = 64
2ac0 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2ac4 +  spill R7 -&gt; [sp, #32]	# spill size = 64
2ac8 +  spill R30 -&gt; [sp, #48]	# spill size = 64
2acc +  spill R7 -&gt; [sp, #64]	# spill size = 64
2ad0 +  spill R12 -&gt; [sp, #72]	# spill size = 64
2ad4 +  spill R18 -&gt; [sp, #84]	# spill size = 32
2ad8 +  spill R31 -&gt; [sp, #88]	# spill size = 64
2adc +  spill R9 -&gt; [sp, #96]	# spill size = 32
2ae0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:6 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #88
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #32 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #96, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop [88]=Oop off=10980/0x2ae4}
2ae4    #@ShouldNotReachHere

2af0    B402: #	out( N6567 ) &lt;- in( B131 )  Freq: 1e-35
2af0 +  li R11, #-34	# int, #@loadConI
2af4    spill [sp, #8] -&gt; R8	# spill size = 64
2af8 +  spill R10 -&gt; [sp, #0]	# spill size = 64
2afc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:6 (line 106) L[0]=sp + #48 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #0
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop off=11008/0x2b00}
2b00    #@ShouldNotReachHere

2b0c    B403: #	out( B451 B501 B452 ) &lt;- in( B31 )  Freq: 5.26543e-06
2b0c     -- 	// exception oop; no code emitted, #@CreateException
2b0c +  spill [sp, #0] -&gt; R28	# spill size = 64
2b10 +  lwu  R28, [R28, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
2b14 +  decode_heap_oop  R28, R28	#@decodeHeapOop
2b18    spill R28 -&gt; R8	# spill size = 64
2b1c +  spill R10 -&gt; R11	# spill size = 64
2b20    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:52 (line 165) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [48]=Oop [56]=Oop off=11044/0x2b24}

2b24    B404: #	out( N6567 ) &lt;- in( B28 )  Freq: 5.33536e-07
2b24 +  li R11, #-10	# int, #@loadConI
2b28    spill R9 -&gt; R8	# spill size = 64
2b2c +  spill R19 -&gt; [sp, #8]	# spill size = 64
2b30 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2b34 +  spill R18 -&gt; [sp, #40]	# spill size = 64
2b38 +  spill R24 -&gt; [sp, #48]	# spill size = 64
2b3c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:39 (line 164) L[0]=sp + #8 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #40 L[1]=sp + #48 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop off=11072/0x2b40}
2b40    #@ShouldNotReachHere

2b4c    B405: #	out( N6567 ) &lt;- in( B30 )  Freq: 5.33535e-07
2b4c +  li R11, #-10	# int, #@loadConI
2b50    spill R9 -&gt; R8	# spill size = 64
2b54 +  spill R19 -&gt; [sp, #8]	# spill size = 64
2b58 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2b5c +  spill R18 -&gt; [sp, #40]	# spill size = 64
2b60 +  spill R24 -&gt; [sp, #48]	# spill size = 64
2b64    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:49 (line 165) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #40 L[1]=sp + #48 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop off=11112/0x2b68}
2b68    #@ShouldNotReachHere

2b74    B406: #	out( N6567 ) &lt;- in( B32 )  Freq: 5.33524e-07
2b74 +  li R11, #-10	# int, #@loadConI
2b78    spill [sp, #8] -&gt; R8	# spill size = 64
2b7c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:60 (line 171) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop off=11136/0x2b80}
2b80    #@ShouldNotReachHere

2b8c    B407: #	out( N6567 ) &lt;- in( B33 )  Freq: 5.33523e-07
2b8c +  li R11, #-10	# int, #@loadConI
2b90    spill [sp, #8] -&gt; R8	# spill size = 64
2b94    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream::readLock @ bci:4 (line 75) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:60 (line 171) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop off=11160/0x2b98}
2b98    #@ShouldNotReachHere

2ba4    B408: #	out( N6567 ) &lt;- in( B34 )  Freq: 5.33523e-07
2ba4 +  li R11, #-10	# int, #@loadConI
2ba8    spill [sp, #8] -&gt; R8	# spill size = 64
2bac    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop off=11184/0x2bb0}
2bb0    #@ShouldNotReachHere

2bbc    B409: #	out( N6567 ) &lt;- in( B36 )  Freq: 5.33522e-07
2bbc +  li R11, #-10	# int, #@loadConI
2bc0    spill [sp, #8] -&gt; R8	# spill size = 64
2bc4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_ STK[0]=#NULL STK[1]=#1
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop off=11208/0x2bc8}
2bc8    #@ShouldNotReachHere

2bd4    B410: #	out( N6567 ) &lt;- in( B2 )  Freq: 5.06179e-07
2bd4 +  li R11, #-10	# int, #@loadConI
2bd8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # OopMap {off=11228/0x2bdc}
2bdc    #@ShouldNotReachHere

2be8    B411: #	out( N6567 ) &lt;- in( B3 )  Freq: 5.06179e-07
2be8 +  li R11, #-10	# int, #@loadConI
2bec    spill R9 -&gt; R8	# spill size = 64
2bf0 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2bf4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:4 (line 335) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=#NULL
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop off=11256/0x2bf8}
2bf8    #@ShouldNotReachHere

2c04    B412: #	out( N6567 ) &lt;- in( B4 )  Freq: 5.06178e-07
2c04 +  li R11, #-10	# int, #@loadConI
2c08    spill R9 -&gt; R8	# spill size = 64
2c0c +  spill R18 -&gt; [sp, #0]	# spill size = 64
2c10 +  spill R30 -&gt; [sp, #8]	# spill size = 32
2c14    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ArrayDeque::elementAt @ bci:2 (line 259) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=sp + #8
        # java.util.ArrayDeque::peekFirst @ bci:8 (line 418) L[0]=_
        # java.util.ArrayDeque::peek @ bci:1 (line 564) L[0]=_
        # java.nio.file.FileTreeWalker::next @ bci:4 (line 335) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop off=11288/0x2c18}
2c18    #@ShouldNotReachHere

2c24    B413: #	out( N6567 ) &lt;- in( B9 )  Freq: 5.05671e-07
2c24 +  li R11, #-10	# int, #@loadConI
2c28    spill R9 -&gt; R8	# spill size = 64
2c2c +  spill R18 -&gt; [sp, #0]	# spill size = 64
2c30 +  spill R24 -&gt; [sp, #8]	# spill size = 64
2c34    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=#NULL L[6]=_ STK[0]=#NULL
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=11320/0x2c38}
2c38    #@ShouldNotReachHere

2c44    B414: #	out( N6567 ) &lt;- in( B14 )  Freq: 5.05669e-07
2c44 +  li R11, #-10	# int, #@loadConI
2c48    spill R9 -&gt; R8	# spill size = 64
2c4c +  spill R19 -&gt; [sp, #8]	# spill size = 64
2c50 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2c54 +  spill R18 -&gt; [sp, #40]	# spill size = 64
2c58 +  spill R24 -&gt; [sp, #48]	# spill size = 64
2c5c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:27 (line 162) L[0]=sp + #8 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #40 L[1]=sp + #48 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop off=11360/0x2c60}
2c60    #@ShouldNotReachHere

2c6c    B415: #	out( N6567 ) &lt;- in( B15 )  Freq: 5.05669e-07
2c6c +  li R11, #-10	# int, #@loadConI
2c70    spill R9 -&gt; R8	# spill size = 64
2c74 +  spill R19 -&gt; [sp, #8]	# spill size = 64
2c78 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2c7c +  spill R18 -&gt; [sp, #40]	# spill size = 64
2c80 +  spill R24 -&gt; [sp, #48]	# spill size = 64
2c84    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream::readLock @ bci:4 (line 75) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:27 (line 162) L[0]=sp + #8 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #40 L[1]=sp + #48 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop off=11400/0x2c88}
2c88    #@ShouldNotReachHere

2c94    B416: #	out( N6567 ) &lt;- in( B16 )  Freq: 5.05668e-07
2c94 +  li R11, #-10	# int, #@loadConI
2c98    spill R9 -&gt; R8	# spill size = 64
2c9c +  spill R19 -&gt; [sp, #8]	# spill size = 64
2ca0 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2ca4 +  spill R18 -&gt; [sp, #40]	# spill size = 64
2ca8 +  spill R24 -&gt; [sp, #48]	# spill size = 64
2cac    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #8 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #40 L[1]=sp + #48 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop off=11440/0x2cb0}
2cb0    #@ShouldNotReachHere

2cbc    B417: #	out( N6567 ) &lt;- in( B18 )  Freq: 5.05667e-07
2cbc +  li R11, #-10	# int, #@loadConI
2cc0    spill R9 -&gt; R8	# spill size = 64
2cc4 +  spill R19 -&gt; [sp, #8]	# spill size = 64
2cc8 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2ccc +  spill R18 -&gt; [sp, #40]	# spill size = 64
2cd0 +  spill R24 -&gt; [sp, #48]	# spill size = 64
2cd4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_ STK[0]=#NULL STK[1]=#1
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #8 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #40 L[1]=sp + #48 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop off=11480/0x2cd8}
2cd8    #@ShouldNotReachHere

2ce4    B418: #	out( N6567 ) &lt;- in( B47 )  Freq: 4.91258e-07
2ce4 +  li R11, #-10	# int, #@loadConI
2ce8    spill [sp, #8] -&gt; R8	# spill size = 64
2cec    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:133 (line 182) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop off=11504/0x2cf0}
2cf0    #@ShouldNotReachHere

2cfc    B419: #	out( N6567 ) &lt;- in( B48 )  Freq: 4.91257e-07
2cfc +  li R11, #-10	# int, #@loadConI
2d00    spill [sp, #8] -&gt; R8	# spill size = 64
2d04    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=sp + #64
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop off=11528/0x2d08}
2d08    #@ShouldNotReachHere

2d14    B420: #	out( N6567 ) &lt;- in( B50 )  Freq: 4.91257e-07
2d14 +  li R11, #-10	# int, #@loadConI
2d18    spill [sp, #8] -&gt; R8	# spill size = 64
2d1c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:1 (line 357) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop off=11552/0x2d20}
2d20    #@ShouldNotReachHere

2d2c    B421: #	out( N6567 ) &lt;- in( B68 )  Freq: 4.91254e-07
2d2c +  spill [sp, #8] -&gt; R8	# spill size = 64
2d30 +  li R11, #-10	# int, #@loadConI
2d34    spill R19 -&gt; [sp, #8]	# spill size = 64
2d38 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2d3c +  spill R18 -&gt; [sp, #40]	# spill size = 64
2d40    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:145 (line 186) L[0]=sp + #8 L[1]=_ L[2]=sp + #40 L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop [56]=Oop off=11588/0x2d44}
2d44    #@ShouldNotReachHere

2d50    B422: #	out( N6567 ) &lt;- in( B85 )  Freq: 4.90702e-07
2d50 +  spill [sp, #8] -&gt; R8	# spill size = 64
2d54 +  li R11, #-10	# int, #@loadConI
2d58    spill R29 -&gt; [sp, #8]	# spill size = 64
2d5c +  spill R29 -&gt; [sp, #24]	# spill size = 64
2d60 +  spill R7 -&gt; [sp, #32]	# spill size = 64
2d64    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::provider @ bci:6 (line 105) L[0]=_ STK[0]=#NULL
        # java.nio.file.Files::readAttributes @ bci:1 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #32 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [56]=Oop off=11624/0x2d68}
2d68    #@ShouldNotReachHere

2d74    B423: #	out( N6567 ) &lt;- in( B87 )  Freq: 4.90701e-07
2d74 +  spill [sp, #8] -&gt; R8	# spill size = 64
2d78 +  li R11, #-10	# int, #@loadConI
2d7c    spill R29 -&gt; [sp, #8]	# spill size = 64
2d80 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2d84 +  spill R7 -&gt; [sp, #32]	# spill size = 64
2d88    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.Util::followLinks @ bci:5 (line 121) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # sun.nio.fs.UnixFileSystemProvider::getFileAttributeView @ bci:7 (line 120) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # sun.nio.fs.LinuxFileSystemProvider::getFileAttributeView @ bci:48 (line 68) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:51 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #32 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [56]=Oop off=11660/0x2d8c}
2d8c    #@ShouldNotReachHere

2d98    B424: #	out( N6567 ) &lt;- in( B139 )  Freq: 4.9068e-07
2d98 +  spill [sp, #8] -&gt; R8	# spill size = 64
2d9c +  spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
2da4 +  li R11, #-10	# int, #@loadConI
2da8    spill R12 -&gt; [sp, #16]	# spill size = 64
2dac    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:42 (line 287) L[0]=sp + #8 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=sp + #16 L[5]=_ L[6]=_ L[7]=_ STK[0]=#NULL
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [56]=Oop off=11696/0x2db0}
2db0    #@ShouldNotReachHere

2dbc    B425: #	out( N6567 ) &lt;- in( B140 )  Freq: 4.9068e-07
2dbc +  spill [sp, #8] -&gt; R8	# spill size = 64
2dc0 +  spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
2dc8 +  li R11, #-10	# int, #@loadConI
2dcc    spill R12 -&gt; [sp, #16]	# spill size = 64
2dd0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ArrayDeque::size @ bci:12 (line 649) L[0]=_ STK[0]=_ STK[1]=_ STK[2]=#NULL
        # java.nio.file.FileTreeWalker::visit @ bci:42 (line 287) L[0]=sp + #8 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=sp + #16 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [56]=Oop off=11732/0x2dd4}
2dd4    #@ShouldNotReachHere

2de0    B426: #	out( N6567 ) &lt;- in( B143 )  Freq: 4.90679e-07
2de0 +  spill [sp, #8] -&gt; R8	# spill size = 64
2de4 +  spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
2dec +  li R11, #-10	# int, #@loadConI
2df0    spill R30 -&gt; [sp, #16]	# spill size = 64
2df4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes::isDirectory @ bci:4 (line 299) L[0]=_ STK[0]=#NULL
        # java.nio.file.FileTreeWalker::visit @ bci:58 (line 288) L[0]=sp + #8 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=sp + #16 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [56]=Oop off=11768/0x2df8}
2df8    #@ShouldNotReachHere

2e04    B427: #	out( N6567 ) &lt;- in( B102 )  Freq: 4.90521e-07
2e04 +  spill [sp, #8] -&gt; R8	# spill size = 64
2e08 +  li R11, #-10	# int, #@loadConI
2e0c    spill R29 -&gt; [sp, #8]	# spill size = 64
2e10 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2e14 +  spill R7 -&gt; [sp, #32]	# spill size = 64
2e18 +  spill R30 -&gt; [sp, #48]	# spill size = 64
2e1c +  spill R9 -&gt; [sp, #64]	# spill size = 32
2e20 +  spill R7 -&gt; [sp, #72]	# spill size = 64
2e24    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getByteArrayForSysCalls @ bci:4 (line 135) L[0]=_ L[1]=_ STK[0]=#NULL
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:1 (line 37) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [72]=Oop off=11816/0x2e28}
2e28    #@ShouldNotReachHere

2e34    B428: #	out( N6567 ) &lt;- in( B104 )  Freq: 4.90521e-07
2e34 +  spill [sp, #8] -&gt; R8	# spill size = 64
2e38 +  li R11, #-10	# int, #@loadConI
2e3c    spill R29 -&gt; [sp, #8]	# spill size = 64
2e40 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2e44 +  spill R7 -&gt; [sp, #32]	# spill size = 64
2e48 +  spill R30 -&gt; [sp, #48]	# spill size = 64
2e4c +  spill R9 -&gt; [sp, #64]	# spill size = 32
2e50 +  spill R7 -&gt; [sp, #72]	# spill size = 64
2e54    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::isEmpty @ bci:4 (line 216) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::getByteArrayForSysCalls @ bci:26 (line 138) L[0]=_ L[1]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:1 (line 37) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [72]=Oop off=11864/0x2e58}
2e58    #@ShouldNotReachHere

2e64    B429: #	out( N6567 ) &lt;- in( B106 )  Freq: 4.9052e-07
2e64 +  spill [sp, #8] -&gt; R8	# spill size = 64
2e68 +  li R11, #-10	# int, #@loadConI
2e6c    spill R29 -&gt; [sp, #8]	# spill size = 64
2e70 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2e74 +  spill R7 -&gt; [sp, #32]	# spill size = 64
2e78 +  spill R30 -&gt; [sp, #48]	# spill size = 64
2e7c +  spill R9 -&gt; [sp, #64]	# spill size = 32
2e80 +  spill R7 -&gt; [sp, #72]	# spill size = 64
2e84    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [72]=Oop off=11912/0x2e88}
2e88    #@ShouldNotReachHere

2e94    B430: #	out( N6567 ) &lt;- in( B108 )  Freq: 4.90519e-07
2e94 +  spill [sp, #8] -&gt; R8	# spill size = 64
2e98 +  li R11, #-10	# int, #@loadConI
2e9c    spill R29 -&gt; [sp, #8]	# spill size = 64
2ea0 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2ea4 +  spill R7 -&gt; [sp, #32]	# spill size = 64
2ea8 +  spill R30 -&gt; [sp, #48]	# spill size = 64
2eac +  spill R9 -&gt; [sp, #64]	# spill size = 32
2eb0 +  spill R7 -&gt; [sp, #72]	# spill size = 64
2eb4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:8 (line 434) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [72]=Oop off=11960/0x2eb8}
2eb8    #@ShouldNotReachHere

2ec4    B431: #	out( N6567 ) &lt;- in( B112 )  Freq: 4.90517e-07
2ec4 +  spill [sp, #8] -&gt; R8	# spill size = 64
2ec8 +  li R11, #-12	# int, #@loadConI
2ecc    spill R29 -&gt; [sp, #8]	# spill size = 64
2ed0 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2ed4 +  spill R7 -&gt; [sp, #32]	# spill size = 64
2ed8 +  spill R30 -&gt; [sp, #48]	# spill size = 64
2edc +  spill R7 -&gt; [sp, #64]	# spill size = 64
2ee0 +  spill R12 -&gt; [sp, #72]	# spill size = 64
2ee4 +  spill R18 -&gt; [sp, #84]	# spill size = 32
2ee8 +  spill R9 -&gt; [sp, #88]	# spill size = 32
2eec    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:6 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #32 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #88, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=12016/0x2ef0}
2ef0    #@ShouldNotReachHere

2efc    B432: #	out( N6567 ) &lt;- in( B124 )  Freq: 4.90506e-07
2efc +  li R11, #-10	# int, #@loadConI
2f00    spill [sp, #8] -&gt; R8	# spill size = 64
2f04    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop off=12040/0x2f08}
2f08    #@ShouldNotReachHere

2f14    B433: #	out( N6567 ) &lt;- in( B126 )  Freq: 4.90505e-07
2f14 +  li R11, #-10	# int, #@loadConI
2f18    spill [sp, #8] -&gt; R8	# spill size = 64
2f1c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:8 (line 434) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop off=12064/0x2f20}
2f20    #@ShouldNotReachHere

2f2c    B434: #	out( N6567 ) &lt;- in( B130 )  Freq: 4.90504e-07
2f2c +  li R11, #-12	# int, #@loadConI
2f30    spill [sp, #8] -&gt; R8	# spill size = 64
2f34    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:6 (line 106) L[0]=sp + #48 L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop off=12088/0x2f38}
2f38    #@ShouldNotReachHere

2f44    B435: #	out( N6567 ) &lt;- in( B69 )  Freq: 2.31178e-07
2f44 +  spill [sp, #8] -&gt; R7	# spill size = 64
2f48 +  li R11, #-187	# int, #@loadConI
2f4c    spill R7 -&gt; [sp, #0]	# spill size = 64
2f50 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2f54 +  spill R19 -&gt; [sp, #24]	# spill size = 64
2f58 +  spill R18 -&gt; [sp, #64]	# spill size = 64
2f5c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:148 (line 186) L[0]=sp + #16 L[1]=_ L[2]=sp + #64 L[3]=_ L[4]=_ STK[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [64]=Oop off=12128/0x2f60}
2f60    #@ShouldNotReachHere

2f6c    B436: #	out( N6567 ) &lt;- in( B79 )  Freq: 2.30919e-07
2f6c +  spill [sp, #8] -&gt; R7	# spill size = 64
2f70 +  li R11, #-187	# int, #@loadConI
2f74    spill R7 -&gt; [sp, #0]	# spill size = 64
2f78 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2f7c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::next @ bci:4 (line 205) L[0]=sp + #16 L[1]=_ STK[0]=R8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::next @ bci:1 (line 132) L[0]=_
        # java.nio.file.FileTreeWalker::next @ bci:47 (line 350) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [48]=Oop [56]=Oop off=12160/0x2f80}
2f80    #@ShouldNotReachHere

2f8c    B437: #	out( N6567 ) &lt;- in( B107 )  Freq: 2.30833e-07
2f8c +  spill [sp, #8] -&gt; R8	# spill size = 64
2f90 +  li R11, #-187	# int, #@loadConI
2f94    spill R29 -&gt; [sp, #8]	# spill size = 64
2f98 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2f9c +  spill R7 -&gt; [sp, #32]	# spill size = 64
2fa0 +  spill R30 -&gt; [sp, #48]	# spill size = 64
2fa4 +  spill R7 -&gt; [sp, #64]	# spill size = 64
2fa8 +  spill R12 -&gt; [sp, #72]	# spill size = 64
2fac +  spill R18 -&gt; [sp, #84]	# spill size = 32
2fb0 +  spill R17 -&gt; [sp, #88]	# spill size = 64
2fb4 +  spill R16 -&gt; [sp, #104]	# spill size = 64
2fb8 +  spill R9 -&gt; [sp, #112]	# spill size = 32
2fbc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal::get @ bci:11 (line 164) L[0]=sp + #88 L[1]=_ L[2]=sp + #104 L[3]=_ L[4]=_ STK[0]=sp + #104
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #32 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #112, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop [88]=Oop [104]=Oop off=12224/0x2fc0}
2fc0    #@ShouldNotReachHere

2fcc    B438: #	out( N6567 ) &lt;- in( B110 )  Freq: 2.30832e-07
2fcc +  spill [sp, #8] -&gt; R8	# spill size = 64
2fd0 +  li R11, #-187	# int, #@loadConI
2fd4    spill R29 -&gt; [sp, #8]	# spill size = 64
2fd8 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2fdc +  spill R7 -&gt; [sp, #32]	# spill size = 64
2fe0 +  spill R30 -&gt; [sp, #48]	# spill size = 64
2fe4 +  spill R7 -&gt; [sp, #64]	# spill size = 64
2fe8 +  spill R12 -&gt; [sp, #72]	# spill size = 64
2fec +  spill R18 -&gt; [sp, #84]	# spill size = 32
2ff0 +  spill R16 -&gt; [sp, #96]	# spill size = 64
2ff4 +  spill R17 -&gt; [sp, #104]	# spill size = 64
2ff8 +  spill R13 -&gt; [sp, #112]	# spill size = 32
2ffc +  spill R19 -&gt; [sp, #128]	# spill size = 64
3000 +  spill R9 -&gt; [sp, #116]	# spill size = 32
3004    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:21 (line 436) L[0]=sp + #96 L[1]=sp + #104 L[2]=sp + #112 L[3]=sp + #128 STK[0]=sp + #128
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #104 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #32 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #116, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop [96]=Oop [104]=Oop [128]=Oop off=12296/0x3008}
3008    #@ShouldNotReachHere

3014    B439: #	out( N6567 ) &lt;- in( B115 )  Freq: 2.30831e-07
3014 +  spill [sp, #8] -&gt; R8	# spill size = 64
3018 +  li R11, #-187	# int, #@loadConI
301c    spill R29 -&gt; [sp, #8]	# spill size = 64
3020 +  spill R29 -&gt; [sp, #24]	# spill size = 64
3024 +  spill R7 -&gt; [sp, #32]	# spill size = 64
3028 +  spill R30 -&gt; [sp, #48]	# spill size = 64
302c +  spill R7 -&gt; [sp, #64]	# spill size = 64
3030 +  spill R12 -&gt; [sp, #72]	# spill size = 64
3034 +  spill R18 -&gt; [sp, #84]	# spill size = 32
3038 +  spill R31 -&gt; [sp, #88]	# spill size = 64
303c +  spill R21 -&gt; [sp, #104]	# spill size = 64
3040 +  spill R9 -&gt; [sp, #112]	# spill size = 32
3044    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:26 (line 76) L[0]=sp + #84 L[1]=sp + #88 L[2]=#0 L[3]=sp + #104 STK[0]=sp + #104
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #32 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #112, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop [88]=Oop [104]=Oop off=12360/0x3048}
3048    #@ShouldNotReachHere

3054    B440: #	out( N6567 ) &lt;- in( B125 )  Freq: 2.30826e-07
3054 +  li R11, #-187	# int, #@loadConI
3058    spill [sp, #8] -&gt; R8	# spill size = 64
305c +  spill R30 -&gt; [sp, #0]	# spill size = 64
3060 +  spill R31 -&gt; [sp, #64]	# spill size = 64
3064    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal::get @ bci:11 (line 164) L[0]=sp + #0 L[1]=_ L[2]=sp + #64 L[3]=_ L[4]=_ STK[0]=sp + #64
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #48 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop off=12392/0x3068}
3068    #@ShouldNotReachHere

3074    B441: #	out( N6567 ) &lt;- in( B128 )  Freq: 2.30826e-07
3074 +  spill [sp, #8] -&gt; R8	# spill size = 64
3078 +  li R11, #-187	# int, #@loadConI
307c    spill R31 -&gt; [sp, #8]	# spill size = 64
3080 +  spill R30 -&gt; [sp, #64]	# spill size = 64
3084 +  spill R28 -&gt; [sp, #36]	# spill size = 32
3088 +  spill R29 -&gt; [sp, #80]	# spill size = 64
308c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:21 (line 436) L[0]=sp + #8 L[1]=sp + #64 L[2]=sp + #36 L[3]=sp + #80 STK[0]=sp + #80
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #64 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #48 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop [80]=Oop off=12432/0x3090}
3090    #@ShouldNotReachHere

309c    B442: #	out( B519 B491 ) &lt;- in( B187 )  Freq: 1.4744e-07
309c     -- 	// exception oop; no code emitted, #@CreateException
309c +  spill R10 -&gt; R11	# spill size = 64
30a0    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::next @ bci:76 (line 361) L[0]=sp + #48 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [48]=Oop off=12452/0x30a4}

30a4    B443: #	out( B492 B493 B518 ) &lt;- in( B196 )  Freq: 1.3735e-07
30a4     -- 	// exception oop; no code emitted, #@CreateException
30a4 +  spill R10 -&gt; R11	# spill size = 64
30a8    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::visit @ bci:131 (line 301) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [32]=Oop [56]=Oop off=12460/0x30ac}

30ac    B444: #	out( N6567 ) &lt;- in( B167 )  Freq: 2.78603e-08
30ac +  li R11, #-10	# int, #@loadConI
30b0    spill [sp, #8] -&gt; R8	# spill size = 64
30b4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:27 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop off=12472/0x30b8}
30b8    #@ShouldNotReachHere

30c4    B445: #	out( N6567 ) &lt;- in( B168 )  Freq: 2.78602e-08
30c4 +  li R11, #-10	# int, #@loadConI
30c8    spill [sp, #8] -&gt; R8	# spill size = 64
30cc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream::readLock @ bci:4 (line 75) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:27 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop off=12496/0x30d0}
30d0    #@ShouldNotReachHere

30dc    B446: #	out( N6567 ) &lt;- in( B169 )  Freq: 2.78602e-08
30dc +  li R11, #-10	# int, #@loadConI
30e0    spill [sp, #8] -&gt; R8	# spill size = 64
30e4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop off=12520/0x30e8}
30e8    #@ShouldNotReachHere

30f4    B447: #	out( N6567 ) &lt;- in( B171 )  Freq: 2.78601e-08
30f4 +  li R11, #-10	# int, #@loadConI
30f8    spill [sp, #8] -&gt; R8	# spill size = 64
30fc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_ STK[0]=#NULL STK[1]=#1
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop off=12544/0x3100}
3100    #@ShouldNotReachHere

310c    B448: #	out( N6567 ) &lt;- in( B185 )  Freq: 1.49399e-08
310c +  li R11, #-10	# int, #@loadConI
3110    spill [sp, #8] -&gt; R8	# spill size = 64
3114    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:76 (line 361) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_ STK[0]=#NULL
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [48]=Oop [56]=Oop off=12568/0x3118}
3118    #@ShouldNotReachHere

3124    B449: #	out( B494 B497 ) &lt;- in( B276 )  Freq: 4.8433e-10
3124     -- 	// exception oop; no code emitted, #@CreateException
3124 +  spill R10 -&gt; R11	# spill size = 64
3128    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:20 (line 53) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [56]=Oop off=12588/0x312c}

312c    B450: #	out( N6567 ) &lt;- in( B510 )  Freq: 5.26631e-11
312c     -- 	// exception oop; no code emitted, #@CreateException
312c +  spill R10 -&gt; [sp, #0]	# spill size = 64
3130 +  li R11, #-75	# int, #@loadConI
3134    spill [sp, #8] -&gt; R8	# spill size = 64
3138    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:59 (line 352) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=_ L[5]=_ L[6]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop off=12604/0x313c}
313c    #@ShouldNotReachHere

3148    B451: #	out( N6567 ) &lt;- in( B403 )  Freq: 5.26543e-11
3148     -- 	// exception oop; no code emitted, #@CreateException
3148 +  spill R10 -&gt; [sp, #40]	# spill size = 64
314c +  li R11, #-75	# int, #@loadConI
3150    spill [sp, #8] -&gt; R8	# spill size = 64
3154    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:71 (line 167) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #40
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [40]=Oop [48]=Oop [56]=Oop off=12632/0x3158}
3158    #@ShouldNotReachHere

3164    B452: #	out( B454 B453 ) &lt;- in( B403 )  Freq: 5.26543e-11
3164     -- 	// exception oop; no code emitted, #@CreateException
3164 +  #@membar_release_lock (elided)
3164    add R29, sp, #144	# box lock
3168 +  spill [sp, #0] -&gt; R18	# spill size = 64
316c +  fastunlock R18,R29	! kills R28, R7, #@cmpFastUnlock
31e4 +  spill R10 -&gt; R9	# spill size = 64
31e8 +  far_bne RFLAGS, zr, B454	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

31f0    B453: #	out( B517 B498 ) &lt;- in( B454 B452 )  Freq: 5.26543e-11
31f0 +  spill R18 -&gt; R8	# spill size = 64
31f4 +  spill R9 -&gt; R11	# spill size = 64
31f8    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=R8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [48]=Oop [56]=Oop off=12796/0x31fc}

31fc    B454: #	out( B453 ) &lt;- in( B452 )  Freq: 5.26543e-17
31fc    add R11, sp, #144	# box lock
3200 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3200    spill R23 -&gt; R12	# spill size = 64
3204 +  spill R18 -&gt; R10	# spill size = 64
3208 +  CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
3238 +  j  B453	#@branch

323c    B455: #	out( N6567 ) &lt;- in( B476 )  Freq: 4.84308e-11
323c     -- 	// exception oop; no code emitted, #@CreateException
323c +  spill R10 -&gt; [sp, #0]	# spill size = 64
3240 +  li R11, #-75	# int, #@loadConI
3244    spill [sp, #8] -&gt; R8	# spill size = 64
3248    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:24 (line 54) L[0]=#ScObj0 L[1]=_ STK[0]=sp + #0
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [56]=Oop off=12876/0x324c}
324c    #@ShouldNotReachHere

3258    B456: #	out( N6567 ) &lt;- in( B462 )  Freq: 4.90516e-12
3258 +  li R11, #-10	# int, #@loadConI
325c    spill [sp, #8] -&gt; R8	# spill size = 64
3260    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop [64]=Oop off=12900/0x3264}
3264    #@ShouldNotReachHere

3270    B457: #	out( N6567 ) &lt;- in( B464 )  Freq: 4.90515e-12
3270 +  li R11, #-10	# int, #@loadConI
3274    spill [sp, #8] -&gt; R8	# spill size = 64
3278    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:8 (line 434) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop [64]=Oop off=12924/0x327c}
327c    #@ShouldNotReachHere

3288    B458: #	out( N6567 ) &lt;- in( B468 )  Freq: 4.90513e-12
3288 +  li R11, #-12	# int, #@loadConI
328c    spill [sp, #8] -&gt; R8	# spill size = 64
3290    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:6 (line 106) L[0]=sp + #48 L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop off=12948/0x3294}
3294    #@ShouldNotReachHere

32a0    B459: #	out( B473 ) &lt;- in( B478 )  Freq: 2.42036e-12
32a0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
32a0    spill R23 -&gt; R11	# spill size = 64
32a4 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
32d4 +  j  B473	#@branch

32d8    B460: #	out( B476 ) &lt;- in( B274 )  Freq: 4.84349e-10
32d8     -- 	// exception oop; no code emitted, #@CreateException
32d8 +  spill R10 -&gt; R11	# spill size = 64
32dc +  j  B476	#@branch

32e0    B461: #	out( B476 ) &lt;- in( B268 )  Freq: 1.75728e-09
32e0     -- 	// exception oop; no code emitted, #@CreateException
32e0 +  spill R10 -&gt; R11	# spill size = 64
32e4 +  j  B476	#@branch

32e8    B462: #	out( B456 B463 ) &lt;- in( B123 )  Freq: 4.84088e-06
32e8     -- 	// exception oop; no code emitted, #@CreateException
32e8 +  mv  R7, java/lang/Class:exact *	# ptr, #@loadConP
3300    spill R10 -&gt; [sp, #64]	# spill size = 64
3304 +  lwu  R10, [R7, #116]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/NativeBuffers.threadLocal
3308 +  lwu  R7, [R8, #68]	# loadN, compressed ptr, #@loadN ! Field: java/lang/Thread.threadLocals
330c +  decode_heap_oop  R31, R10	#@decodeHeapOop
3310 +  decode_heap_oop  R12, R7	#@decodeHeapOop
3314    lw  R28, [R31, #12]	# int, #@loadI ! Field: java/lang/ThreadLocal.threadLocalHashCode (constant)
3318    NullCheck R31

3318    B463: #	out( B489 B464 ) &lt;- in( B462 )  Freq: 4.84087e-06
3318    lwu  R7, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap.table
331c    NullCheck R12

331c    B464: #	out( B457 B465 ) &lt;- in( B463 )  Freq: 4.84087e-06
331c +  decode_heap_oop  R29, R7	#@decodeHeapOop
3320    lwu  R30, [R29, #12]	# range, #@loadRange
3324    NullCheck R29

3324    B465: #	out( B484 B466 ) &lt;- in( B464 )  Freq: 4.84086e-06
3324 +  addiw  R7, R30, #-1	#@addI_reg_imm
3328 +  andr  R7, R28, R7	#@andI_reg_reg
332c +  addw  R28, R7, zr	#@convI2L_reg_reg
3330 +  slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
3334 +  add R28, R29, R28	# ptr, #@addP_reg_reg
3338 +  bleu  R30, zr, B484	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

333c    B466: #	out( B490 B467 ) &lt;- in( B465 )  Freq: 4.84086e-06
333c +  lwu  R29, [R28, #16]	# loadN, compressed ptr, #@loadN
3340 +  decode_heap_oop  R29, R29	#@decodeHeapOop
3344    lwu  R28, [R29, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
3348    NullCheck R29

3348    B467: #	out( B485 B468 ) &lt;- in( B466 )  Freq: 4.84086e-06
3348    
3348 +  lwu  R30, [R29, #28]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap$Entry.value
334c +  decode_heap_oop  R30, R30	#@decodeHeapOop
3350 +  bne  R28, R10, B485	#@cmpN_branch  P=0.000001 C=-1.000000

3354    B468: #	out( B458 B469 ) &lt;- in( B467 )  Freq: 4.84085e-06
3354    lwu  R7, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
3358    NullCheck R30

3358    B469: #	out( B488 B470 ) &lt;- in( B468 )  Freq: 4.84085e-06
3358 +  mv  R29, narrowklass: precise klass [Lsun/nio/fs/NativeBuffer;: 0x00000040d01a3610:Constant:exact *	# compressed klass ptr, #@loadConNKlass
3368 +  bne  R7, R29, B488	#@cmpN_branch  P=0.000000 C=-1.000000

336c    B470: #	out( B486 B471 ) &lt;- in( B469 )  Freq: 4.84085e-06
336c +  # checkcastPP of R30, #@checkCastPP
336c    lwu  R7, [R30, #12]	# range, #@loadRange
3370 +  addi  R9, R30, #16	# ptr, #@addP_reg_imm
3374 +  bleu  R7, zr, B486	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

3378    B471: #	out( B487 B472 ) &lt;- in( B470 )  Freq: 4.84084e-06
3378 +  lwu  R28, [R9]	# loadN, compressed ptr, #@loadN
337c +  decode_heap_oop  R8, R28	#@decodeHeapOop
3380 +  bne   R8, zr, B487	#@cmpP_imm0_branch  P=0.000000 C=2869.000000

3384    B472: #	out( B477 B473 ) &lt;- in( B471 )  Freq: 4.84084e-06
3384 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3384    lb  R7, [R23, #56]	# byte, #@loadB
3388 +  bne  R7, zr, B477	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

338c    B473: #	out( B475 B474 ) &lt;- in( B459 B479 B477 B472 )  Freq: 4.84084e-06
338c +  mv  R7, R9	# ptr -&gt; long, #@castP2X
3390    spill [sp, #48] -&gt; R28	# spill size = 64
3394 +  mv  R28, R28	# ptr -&gt; long, #@castP2X
3394 +  xorr  R28, R28, R7	#@xorL_reg_reg
3398 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
339c    spill [sp, #0] -&gt; R29	# spill size = 32
33a0 +  sw  R29, [R9]	# compressed ptr, #@storeN
33a4 +  beq  R28, zr, B475	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

33a8    B474: #	out( B480 B475 ) &lt;- in( B473 )  Freq: 4.836e-06
33a8 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
33ac +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
33b8 +  add R10, R28, R7	# ptr, #@addP_reg_reg
33bc +  lb  R28, [R10]	# byte, #@loadB
33c0 +  li R29, #4	# int, #@loadConI
33c4 +  bne  R28, R29, B480	#@cmpI_branch  P=0.001000 C=-1.000000

33c8    B475: #	out( B476 ) &lt;- in( B482 B483 B480 B474 B473 )  Freq: 4.84084e-06
33c8 +  spill [sp, #64] -&gt; R11	# spill size = 64

33cc    B476: #	out( B495 B455 ) &lt;- in( B460 B461 B475 )  Freq: 4.84308e-06
33cc    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [56]=Oop off=13264/0x33d0}

33d0    B477: #	out( B473 B478 ) &lt;- in( B472 )  Freq: 4.84078e-09
33d0 +  lwu  R28, [R9]	# loadN, compressed ptr, #@loadN
33d4 +  decode_heap_oop  R10, R28	#@decodeHeapOop
33d8 +  beq   R10, zr, B473	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

33dc    B478: #	out( B459 B479 ) &lt;- in( B477 )  Freq: 2.42039e-09
33dc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
33dc    ld  R7, [R23, #32]	# int, #@loadL
33e0 +  beq  R7, zr, B459	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

33e4    B479: #	out( B473 ) &lt;- in( B478 )  Freq: 2.41797e-09
33e4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
33e4    ld  R28, [R23, #48]	# ptr, #@loadP
33e8 +  add R28, R28, R7	# ptr, #@addP_reg_reg
33ec +  addi  R7, R7, #-8	#@addL_reg_imm
33f0 +  sd  R10, [R28, #-8]	# ptr, #@storeP
33f4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
33f4    sd  R7, [R23, #32]	# long, #@storeL
33f8 +  j  B473	#@branch

33fc    B480: #	out( B475 B481 ) &lt;- in( B474 )  Freq: 4.836e-09
33fc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
33fc    ld  R7, [R23, #64]	# int, #@loadL
3400 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3400    ld  R28, [R23, #80]	# ptr, #@loadP
3404 +  #@membar_volatile
	fence iorw iorw
3408 +  lb  R29, [R10]	# byte, #@loadB
340c +  beq  R29, zr, B475	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

3410    B481: #	out( B483 B482 ) &lt;- in( B480 )  Freq: 2.418e-09
3410 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
3414 +  bne  R7, zr, B483	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

3418    B482: #	out( B475 ) &lt;- in( B481 )  Freq: 1.209e-09
3418 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3418    spill R23 -&gt; R11	# spill size = 64
341c +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
344c +  j  B475	#@branch

3450    B483: #	out( B475 ) &lt;- in( B481 )  Freq: 1.209e-09
3450 +  add R28, R28, R7	# ptr, #@addP_reg_reg
3454 +  addi  R7, R7, #-8	#@addL_reg_imm
3458 +  sd  R10, [R28, #-8]	# ptr, #@storeP
345c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
345c    sd  R7, [R23, #64]	# long, #@storeL
3460 +  j  B475	#@branch

3464    B484: #	out( N6567 ) &lt;- in( B465 )  Freq: 4.84086e-12
3464 +  spill [sp, #8] -&gt; R8	# spill size = 64
3468 +  li R11, #-26	# int, #@loadConI
346c    spill R29 -&gt; [sp, #0]	# spill size = 64
3470 +  spill R7 -&gt; [sp, #8]	# spill size = 32
3474    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:18 (line 435) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #0 STK[1]=sp + #8
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop [64]=Oop off=13432/0x3478}
3478    #@ShouldNotReachHere

3484    B485: #	out( N6567 ) &lt;- in( B467 )  Freq: 4.84086e-12
3484 +  spill [sp, #8] -&gt; R8	# spill size = 64
3488 +  li R11, #-187	# int, #@loadConI
348c    spill R12 -&gt; [sp, #8]	# spill size = 64
3490 +  spill R31 -&gt; [sp, #72]	# spill size = 64
3494 +  spill R7 -&gt; [sp, #36]	# spill size = 32
3498 +  spill R29 -&gt; [sp, #80]	# spill size = 64
349c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:29 (line 436) L[0]=sp + #8 L[1]=sp + #72 L[2]=sp + #36 L[3]=sp + #80 STK[0]=#0
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #72 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #48 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop [80]=Oop off=13472/0x34a0}
34a0    #@ShouldNotReachHere

34ac    B486: #	out( N6567 ) &lt;- in( B470 )  Freq: 4.84085e-12
34ac +  li R11, #-26	# int, #@loadConI
34b0    spill [sp, #8] -&gt; R8	# spill size = 64
34b4 +  spill R30 -&gt; [sp, #0]	# spill size = 64
34b8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:40 (line 115) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #0 STK[1]=#0
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop [64]=Oop off=13500/0x34bc}
34bc    #@ShouldNotReachHere

34c8    B487: #	out( N6567 ) &lt;- in( B471 )  Freq: 2.42042e-12
34c8 +  spill [sp, #8] -&gt; R7	# spill size = 64
34cc +  li R11, #-187	# int, #@loadConI
34d0    spill R7 -&gt; [sp, #0]	# spill size = 64
34d4 +  spill R30 -&gt; [sp, #8]	# spill size = 64
34d8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:41 (line 115) L[0]=sp + #48 L[1]=sp + #8 L[2]=#0 L[3]=_ STK[0]=R8
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop off=13532/0x34dc}
34dc    #@ShouldNotReachHere

34e8    B488: #	out( N6567 ) &lt;- in( B469 )  Freq: 1e-35
34e8 +  li R11, #-34	# int, #@loadConI
34ec    spill [sp, #8] -&gt; R8	# spill size = 64
34f0 +  spill R30 -&gt; [sp, #0]	# spill size = 64
34f4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:6 (line 106) L[0]=sp + #48 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #0
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop off=13560/0x34f8}
34f8    #@ShouldNotReachHere

3504    B489: #	out( N6567 ) &lt;- in( B463 )  Freq: 2.30831e-12
3504 +  li R11, #-187	# int, #@loadConI
3508    spill [sp, #8] -&gt; R8	# spill size = 64
350c +  spill R31 -&gt; [sp, #0]	# spill size = 64
3510 +  spill R12 -&gt; [sp, #72]	# spill size = 64
3514    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal::get @ bci:11 (line 164) L[0]=sp + #0 L[1]=_ L[2]=sp + #72 L[3]=_ L[4]=_ STK[0]=sp + #72
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #48 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=13592/0x3518}
3518    #@ShouldNotReachHere

3524    B490: #	out( N6567 ) &lt;- in( B466 )  Freq: 2.3083e-12
3524 +  spill [sp, #8] -&gt; R8	# spill size = 64
3528 +  li R11, #-187	# int, #@loadConI
352c    spill R12 -&gt; [sp, #8]	# spill size = 64
3530 +  spill R31 -&gt; [sp, #72]	# spill size = 64
3534 +  spill R7 -&gt; [sp, #36]	# spill size = 32
3538 +  spill R29 -&gt; [sp, #88]	# spill size = 64
353c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:21 (line 436) L[0]=sp + #8 L[1]=sp + #72 L[2]=sp + #36 L[3]=sp + #88 STK[0]=sp + #88
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #72 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #48 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop [88]=Oop off=13632/0x3540}
3540    #@ShouldNotReachHere

354c    B491: #	out( N6567 ) &lt;- in( B442 )  Freq: 1.4744e-12
354c     -- 	// exception oop; no code emitted, #@CreateException
354c +  spill R10 -&gt; [sp, #16]	# spill size = 64
3550 +  li R11, #-75	# int, #@loadConI
3554    spill [sp, #8] -&gt; R8	# spill size = 64
3558    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:84 (line 362) L[0]=sp + #48 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_ STK[0]=sp + #16
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [48]=Oop off=13660/0x355c}
355c    #@ShouldNotReachHere

3568    B492: #	out( N6567 ) &lt;- in( B443 )  Freq: 1.3735e-12
3568     -- 	// exception oop; no code emitted, #@CreateException
3568 +  spill R10 -&gt; [sp, #0]	# spill size = 64
356c +  li R11, #-75	# int, #@loadConI
3570    spill [sp, #8] -&gt; R8	# spill size = 64
3574    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:139 (line 302) L[0]=_ L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [56]=Oop off=13688/0x3578}
3578    #@ShouldNotReachHere

3584    B493: #	out( N6567 ) &lt;- in( B443 )  Freq: 1.3735e-12
3584     -- 	// exception oop; no code emitted, #@CreateException
3584 +  spill R10 -&gt; [sp, #0]	# spill size = 64
3588 +  li R11, #-75	# int, #@loadConI
358c    spill [sp, #8] -&gt; R8	# spill size = 64
3590    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:155 (line 304) L[0]=_ L[1]=_ L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [56]=Oop off=13716/0x3594}
3594    #@ShouldNotReachHere

35a0    B494: #	out( B496 ) &lt;- in( B449 )  Freq: 4.8433e-15
35a0     -- 	// exception oop; no code emitted, #@CreateException
35a0 +  spill R10 -&gt; R11	# spill size = 64
35a4 +  j  B496	#@branch

35a8    B495: #	out( B496 ) &lt;- in( B476 )  Freq: 4.84308e-11
35a8     -- 	// exception oop; no code emitted, #@CreateException
35a8 +  spill R10 -&gt; R11	# spill size = 64

35ac    B496: #	out( B513 B514 ) &lt;- in( B494 B495 )  Freq: 4.84357e-11
35ac    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [56]=Oop off=13744/0x35b0}

35b0    B497: #	out( N6567 ) &lt;- in( B449 )  Freq: 4.8433e-15
35b0     -- 	// exception oop; no code emitted, #@CreateException
35b0 +  spill R10 -&gt; [sp, #0]	# spill size = 64
35b4 +  li R11, #-75	# int, #@loadConI
35b8    spill [sp, #8] -&gt; R8	# spill size = 64
35bc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:24 (line 54) L[0]=#ScObj0 L[1]=_ STK[0]=sp + #0
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [56]=Oop off=13760/0x35c0}
35c0    #@ShouldNotReachHere

35cc    B498: #	out( N6567 ) &lt;- in( B453 )  Freq: 5.26543e-16
35cc     -- 	// exception oop; no code emitted, #@CreateException
35cc +  spill R10 -&gt; [sp, #0]	# spill size = 64
35d0 +  li R11, #-75	# int, #@loadConI
35d4    spill [sp, #8] -&gt; R8	# spill size = 64
35d8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:59 (line 352) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=_ L[5]=_ L[6]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop off=13788/0x35dc}
35dc    #@ShouldNotReachHere

35e8    B499: #	out( B509 ) &lt;- in( B503 )  Freq: 5.26531e-16
35e8     -- 	// exception oop; no code emitted, #@CreateException
35e8 +  spill R10 -&gt; R9	# spill size = 64
35ec +  j  B509	#@branch

35f0    B500: #	out( B509 ) &lt;- in( B502 )  Freq: 5.26542e-16
35f0     -- 	// exception oop; no code emitted, #@CreateException
35f0 +  spill R10 -&gt; R9	# spill size = 64
35f4 +  j  B509	#@branch

35f8    B501: #	out( B512 B502 ) &lt;- in( B403 )  Freq: 5.26543e-11
35f8     -- 	// exception oop; no code emitted, #@CreateException
35f8 +  spill R8 -&gt; R7	# spill size = 64
35fc +  spill R10 -&gt; [sp, #32]	# spill size = 64
3600 +  beq   R7, zr, B512	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

3604    B502: #	out( B500 B503 ) &lt;- in( B501 )  Freq: 5.26542e-11
3604 +  spill R7 -&gt; R11	# spill size = 64
3608    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixDirectoryStream::readLock
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:99 (line 171) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #32
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [32]=Oop [48]=Oop [56]=Oop off=13836/0x360c}

360c    B503: #	out( B499 B504 ) &lt;- in( B502 )  Freq: 5.26531e-11
        # Block is sole successor of call
360c +  spill R10 -&gt; R11	# spill size = 64
3610    CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.concurrent.locks.Lock::unlock
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:102 (line 171) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #32
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [32]=Oop [48]=Oop [56]=Oop off=13868/0x362c}

362c    B504: #	out( B509 ) &lt;- in( B503 )  Freq: 5.26521e-11
        # Block is sole successor of call
362c +  spill [sp, #32] -&gt; R9	# spill size = 64
3630 +  j  B509	#@branch

3634    B505: #	out( B507 ) &lt;- in( B270 )  Freq: 4.8981e-10
3634     -- 	// exception oop; no code emitted, #@CreateException
3634 +  j  B507	#@branch

3638    B506: #	out( B507 ) &lt;- in( B272 )  Freq: 4.84897e-10
3638     -- 	// exception oop; no code emitted, #@CreateException

3638    B507: #	out( B509 ) &lt;- in( B505 B506 )  Freq: 9.74706e-10
3638 +  spill R10 -&gt; R9	# spill size = 64
363c +  j  B509	#@branch

3640    B508: #	out( B509 ) &lt;- in( B43 )  Freq: 5.26528e-06
3640     -- 	// exception oop; no code emitted, #@CreateException
3640 +  spill R10 -&gt; R9	# spill size = 64

3644    B509: #	out( B511 B510 ) &lt;- in( B508 B507 B500 B499 B504 )  Freq: 5.26631e-06
3644 +  #@membar_release_lock (elided)
3644    add R29, sp, #144	# box lock
3648 +  spill [sp, #0] -&gt; R18	# spill size = 64
364c +  fastunlock R18,R29	! kills R7, R28, #@cmpFastUnlock
36c4 +  far_bne RFLAGS, zr, B511	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

36cc    B510: #	out( B523 B450 ) &lt;- in( B511 B509 )  Freq: 5.26631e-06
36cc +  spill R9 -&gt; R11	# spill size = 64
36d0    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [48]=Oop [56]=Oop off=14036/0x36d4}

36d4    B511: #	out( B510 ) &lt;- in( B509 )  Freq: 5.26631e-12
36d4    add R11, sp, #144	# box lock
36d8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
36d8    spill R23 -&gt; R12	# spill size = 64
36dc +  spill [sp, #0] -&gt; R10	# spill size = 64
36e0 +  CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
3710 +  j  B510	#@branch

3714    B512: #	out( N6567 ) &lt;- in( B501 )  Freq: 5.33534e-17
3714 +  li R11, #-10	# int, #@loadConI
3718    spill [sp, #8] -&gt; R8	# spill size = 64
371c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:99 (line 171) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #32 STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [32]=Oop [48]=Oop [56]=Oop off=14112/0x3720}
3720    #@ShouldNotReachHere

372c    B513: #	out( B515 B536 B516 ) &lt;- in( B496 )  Freq: 4.84357e-16
372c     -- 	// exception oop; no code emitted, #@CreateException
372c +  spill R10 -&gt; R11	# spill size = 64
3730    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [56]=Oop off=14132/0x3734}

3734    B514: #	out( N6567 ) &lt;- in( B496 )  Freq: 4.84357e-16
3734     -- 	// exception oop; no code emitted, #@CreateException
3734 +  spill R10 -&gt; [sp, #0]	# spill size = 64
3738 +  li R11, #-75	# int, #@loadConI
373c    spill [sp, #8] -&gt; R8	# spill size = 64
3740    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::getAttributes @ bci:63 (line 221) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [56]=Oop off=14148/0x3744}
3744    #@ShouldNotReachHere

3750    B515: #	out( N6567 ) &lt;- in( B513 )  Freq: 4.84357e-21
3750     -- 	// exception oop; no code emitted, #@CreateException
3750 +  spill R10 -&gt; [sp, #0]	# spill size = 64
3754 +  li R11, #-75	# int, #@loadConI
3758    spill [sp, #8] -&gt; R8	# spill size = 64
375c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:27 (line 280) L[0]=_ L[1]=_ L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [56]=Oop off=14176/0x3760}
3760    #@ShouldNotReachHere

376c    B516: #	out( B533 ) &lt;- in( B513 )  Freq: 4.84357e-21
376c     -- 	// exception oop; no code emitted, #@CreateException
376c +  j  B533	#@branch

3770    B517: #	out( B533 ) &lt;- in( B453 )  Freq: 5.26543e-16
3770     -- 	// exception oop; no code emitted, #@CreateException
3770 +  j  B533	#@branch

3774    B518: #	out( B533 ) &lt;- in( B443 )  Freq: 1.3735e-12
3774     -- 	// exception oop; no code emitted, #@CreateException
3774 +  j  B533	#@branch

3778    B519: #	out( B533 ) &lt;- in( B442 )  Freq: 1.4744e-12
3778     -- 	// exception oop; no code emitted, #@CreateException
3778 +  j  B533	#@branch

377c    B520: #	out( B533 ) &lt;- in( B319 )  Freq: 1.37362e-11
377c     -- 	// exception oop; no code emitted, #@CreateException
377c +  j  B533	#@branch

3780    B521: #	out( B533 ) &lt;- in( B317 )  Freq: 1.3737e-11
3780     -- 	// exception oop; no code emitted, #@CreateException
3780 +  j  B533	#@branch

3784    B522: #	out( B533 ) &lt;- in( B315 )  Freq: 1.47459e-11
3784     -- 	// exception oop; no code emitted, #@CreateException
3784 +  j  B533	#@branch

3788    B523: #	out( B533 ) &lt;- in( B510 )  Freq: 5.26631e-11
3788     -- 	// exception oop; no code emitted, #@CreateException
3788 +  j  B533	#@branch

378c    B524: #	out( B533 ) &lt;- in( B278 )  Freq: 4.70591e-10
378c     -- 	// exception oop; no code emitted, #@CreateException
378c +  j  B533	#@branch

3790    B525: #	out( B533 ) &lt;- in( B222 )  Freq: 1.37339e-07
3790     -- 	// exception oop; no code emitted, #@CreateException
3790 +  j  B533	#@branch

3794    B526: #	out( B533 ) &lt;- in( B219 )  Freq: 1.37342e-07
3794     -- 	// exception oop; no code emitted, #@CreateException
3794 +  j  B533	#@branch

3798    B527: #	out( B533 ) &lt;- in( B212 )  Freq: 1.37345e-07
3798     -- 	// exception oop; no code emitted, #@CreateException
3798 +  j  B533	#@branch

379c    B528: #	out( B533 ) &lt;- in( B199 )  Freq: 1.37348e-07
379c     -- 	// exception oop; no code emitted, #@CreateException
379c +  j  B533	#@branch

37a0    B529: #	out( B533 ) &lt;- in( B192 )  Freq: 1.47434e-07
37a0     -- 	// exception oop; no code emitted, #@CreateException
37a0 +  j  B533	#@branch

37a4    B530: #	out( B533 ) &lt;- in( B189 )  Freq: 1.47437e-07
37a4     -- 	// exception oop; no code emitted, #@CreateException
37a4 +  j  B533	#@branch

37a8    B531: #	out( B535 ) &lt;- in( B182 )  Freq: 1.52575e-07
37a8     -- 	// exception oop; no code emitted, #@CreateException
37a8 +  spill R10 -&gt; R11	# spill size = 64
37ac +  j  B535	#@branch

37b0    B532: #	out( B533 ) &lt;- in( B147 )  Freq: 4.70513e-06
37b0     -- 	// exception oop; no code emitted, #@CreateException

37b0    B533: #	out( B535 ) &lt;- in( B523 B517 B519 B530 B522 B529 B516 B518 B521 B528 B527 B526 B520 B525 B524 B532 )  Freq: 5.54994e-06
37b0 +  spill R10 -&gt; R11	# spill size = 64
37b4 +  j  B535	#@branch

37b8    B534: #	out( B535 ) &lt;- in( B150 )  Freq: 5.14227e-06
37b8     -- 	// exception oop; no code emitted, #@CreateException
37b8 +  spill R10 -&gt; R11	# spill size = 64

37bc    B535: #	out( N6567 ) &lt;- in( B533 B534 B531 )  Freq: 1.08448e-05
37bc    # pop frame 176
	add  sp, sp, #176
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
3810 +  j rethrow_stub	#@RethrowException

3818    B536: #	out( N6567 ) &lt;- in( B513 )  Freq: 4.84357e-21
3818     -- 	// exception oop; no code emitted, #@CreateException
3818 +  spill R10 -&gt; [sp, #0]	# spill size = 64
381c +  li R11, #-75	# int, #@loadConI
3820    spill [sp, #8] -&gt; R8	# spill size = 64
3824    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:11 (line 278) L[0]=_ L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [56]=Oop off=14376/0x3828}
3828    #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='322'>
----------------------- MetaData before Compile_id = 322 ------------------------
{method}
 - this oop:          0x00000040961646d0
 - method holder:     &apos;java/util/ImmutableCollections$SetN&apos;
 - constants:         0x00000040961639e8 constant pool [168] {0x00000040961639e8} for &apos;java/util/ImmutableCollections$SetN&apos; cache=0x0000004096164c20
 - access:            0xc1000002  private 
 - name:              &apos;probe&apos;
 - signature:         &apos;(Ljava/lang/Object;)I&apos;
 - max stack:         3
 - max locals:        4
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bd00: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c4f5000
 - code size:         56
 - code start:        0x0000004096164658
 - code end (excl):   0x0000004096164690
 - method data:       0x00000040965ee138
 - checked ex length: 0
 - linenumber start:  0x0000004096164690
 - localvar length:   4
 - localvar start:    0x000000409616469e
 - compiled code: nmethod  13691  133       3       java.util.ImmutableCollections$SetN::probe (56 bytes)

------------------------ OptoAssembly for Compile_id = 322 -----------------------
#
#  int ( java/util/ImmutableCollections$SetN:NotNull:exact *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/ImmutableCollections$SetN:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N957: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B103 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
03c     spill R11 -&gt; [sp, #8]	# spill size = 64
040 +   spill R12 -&gt; [sp, #16]	# spill size = 64
044     lwu  R28, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
048     NullCheck R12

048     B2: #	out( B68 B3 ) &lt;- in( B1 )  Freq: 0.999999
048 +   mv  R7, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
058     spill R28 -&gt; [sp, #0]	# spill size = 32
05c +   li R11, #1	# int, #@loadConI
060 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
060     bne  R28, R7, B68	#@cmpN_branch  P=0.000977 C=-1.000000

064     B3: #	out( B22 B4 ) &lt;- in( B2 )  Freq: 0.999022
064 +   # checkcastPP of R12, #@checkCastPP
064     lw  R10, [R12, #12]	# int, #@loadI ! Field: java/lang/String.hash
068 +   bne  R10, zr, B22	#@cmpI_reg_imm0_branch  P=0.474144 C=5376.000000

06c     B4: #	out( B70 B5 ) &lt;- in( B3 )  Freq: 0.525342
06c +   lbu  R7, [R12, #17]	# byte, #@loadUB ! Field: java/lang/String.hashIsZero
070 +   li R14, #0	# int, #@loadConI
074 +   bne  R7, zr, B70	#@cmpI_reg_imm0_branch  P=0.001062 C=2826.000000

078     B5: #	out( B94 B6 ) &lt;- in( B4 )  Freq: 0.524784
078 +   lwu  R28, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
07c +   lb  R8, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
080 +   decode_heap_oop  R13, R28	#@decodeHeapOop
084 +   bne  R8, zr, B94	#@cmpI_reg_imm0_branch  P=0.000000 C=51074.000000

088     B6: #	out( B105 B7 ) &lt;- in( B5 )  Freq: 0.524784
088     lwu  R30, [R13, #12]	# range, #@loadRange
08c     NullCheck R13

08c     B7: #	out( B67 B8 ) &lt;- in( B6 )  Freq: 0.524783
08c +   bleu  R30, zr, B67	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.056079 C=18260.000000

090     B8: #	out( B86 B9 ) &lt;- in( B7 )  Freq: 0.495354
090 +   addiw  R7, R30, #-1	#@addI_reg_imm
094 +   bgeu  R7, R30, B86	#@cmpU_branch  P=0.000001 C=-1.000000

098     B9: #	out( B87 B10 ) &lt;- in( B8 )  Freq: 0.495353
098 +   addiw  R15, R30, #-3	#@addI_reg_imm
09c +   li R17, #4000	# int, #@loadConI
0a4 +   lbu  R10, [R13, #16]	# byte, #@loadUB
0a8 +   ble  R15, R11, B87	#@cmpI_branch  P=0.000001 C=-1.000000

0ac     B10: #	out( B88 B11 ) &lt;- in( B9 )  Freq: 0.495353
0ac +   slliw  R28, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0b0 +   subw  R31, R28, R10	#@subI_reg_reg
0b4 +   li R7, #4	# int, #@loadConI
0b8 +   bleu  R30, R11, B88	#@cmpU_branch  P=0.000001 C=-1.000000

0bc     B11: #	out( B89 B12 ) &lt;- in( B10 )  Freq: 0.495352
0bc +   bleu  R30, R7, B89	#@cmpU_branch  P=0.000001 C=-1.000000

0c0     B12: #	out( B13 ) &lt;- in( B11 )  Freq: 0.495352
0c0 +   li R16, #1	# int, #@loadConI

0c4     B13: #	out( B14 ) &lt;- in( B12 B15 ) Loop( B13-B15 ) Freq: 8.83313
0c4 +   subw  R28, R30, R16	#@subI_reg_reg
0c8 +   addiw  R7, R28, #-3	#@addI_reg_imm
0cc     CMove R7, (R15 lt R16), R7, R14	#@cmovI_cmpI
	
0d4 +   CMove R7, (R7 gtu R17), R7, R17	#@cmovI_cmpU
	
0dc +   addw  R18, R7, R16	#@addI_reg_reg

0e0     B14: #	out( B14 B15 ) &lt;- in( B13 B14 ) Loop( B14-B14 inner main of N87 strip mined) Freq: 157.513
0e0 +   addw  R7, R16, zr	#@convI2L_reg_reg
0e4 +   add R7, R13, R7	# ptr, #@addP_reg_reg
0e8 +   lbu  R29, [R7, #16]	# byte, #@loadUB
0ec +   addw  R31, R31, R29	#@addI_reg_reg
0f0 +   lbu  R28, [R7, #17]	# byte, #@loadUB
0f4 +   slliw  R29, R31, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0f8 +   subw  R31, R29, R31	#@subI_reg_reg
0fc +   addw  R28, R31, R28	#@addI_reg_reg
100 +   lbu  R29, [R7, #18]	# byte, #@loadUB
104 +   slliw  R10, R28, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
108 +   lbu  R31, [R7, #19]	# byte, #@loadUB
10c +   subw  R28, R10, R28	#@subI_reg_reg
110 +   addw  R7, R28, R29	#@addI_reg_reg
114 +   slliw  R29, R7, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
118 +   subw  R7, R29, R7	#@subI_reg_reg
11c +   addw  R10, R7, R31	#@addI_reg_reg
120 +   slliw  R28, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
124 +   addiw  R16, R16, #4	#@addI_reg_imm
128 +   subw  R31, R28, R10	#@subI_reg_reg
12c +   blt  R16, R18, B14	#@cmpI_loop  P=0.943921 C=17236.000000

130     B15: #	out( B13 B16 ) &lt;- in( B14 )  Freq: 8.83313
130 +   ld  R7, [R23, #920]	# ptr, #@loadP
134 +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::hashCode @ bci:37 (line 196) L[0]=_ L[1]=R10 L[2]=R13 L[3]=R30 L[4]=R16 L[5]=_
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=R12 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #8 L[1]=R12 L[2]=_ L[3]=_
        # OopMap {c_rarg2=Oop c_rarg3=Oop [8]=Oop [16]=Oop off=308/0x134}
138 +   blt  R16, R15, B13	#@cmpI_branch  P=0.943921 C=17236.000000

13c     B16: #	out( B20 B17 ) &lt;- in( B87 B15 )  Freq: 0.495352
13c +   bge  R16, R30, B20	#@cmpI_branch  P=0.500000 C=-1.000000

140     B17: #	out( B95 B18 ) &lt;- in( B16 )  Freq: 0.247676
140 +   # castII of R16, #@castII
140     bgeu  R16, R30, B95	#@cmpU_branch  P=0.000001 C=-1.000000

144     B18: #	out( B96 B19 ) &lt;- in( B17 )  Freq: 0.247676
144 +   spill R16 -&gt; R28	# spill size = 32
148 +   # castII of R28, #@castII
148     bgeu  R28, R30, B96	#@cmpU_branch  P=0.000001 C=-1.000000

14c     B19: #	out( B19 B20 ) &lt;- in( B18 B19 ) Loop( B19-B19 inner post of N842) Freq: 0.495351
14c +   addw  R7, R16, zr	#@convI2L_reg_reg
150 +   add R7, R13, R7	# ptr, #@addP_reg_reg
154 +   slliw  R29, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
158 +   lbu  R7, [R7, #16]	# byte, #@loadUB
15c +   subw  R28, R29, R10	#@subI_reg_reg
160 +   addiw  R16, R16, #1	#@addI_reg_imm
164 +   addw  R10, R28, R7	#@addI_reg_reg
168 +   blt  R16, R30, B19	#@cmpI_loop  P=0.500000 C=17236.000000

16c     B20: #	out( B67 B21 ) &lt;- in( B19 B16 )  Freq: 0.495352
16c +   beq  R10, zr, B67	#@cmpI_reg_imm0_branch  P=0.000354 C=2823.000000

170     B21: #	out( B22 ) &lt;- in( B20 )  Freq: 0.495176
170 +   sw  R10, [R12, #12]	# int, #@storeI ! Field: java/lang/String.hash

174     B22: #	out( B104 B23 ) &lt;- in( B21 B67 B70 B3 B69 )  Freq: 0.999996
174     spill [sp, #8] -&gt; R7	# spill size = 64
178 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$SetN.elements (constant)
17c +   decode_heap_oop  R29, R28	#@decodeHeapOop
180     lwu  R30, [R29, #12]	# range, #@loadRange
184     NullCheck R29

184     B23: #	out( B83 B24 ) &lt;- in( B22 )  Freq: 0.999995
184 +   bleu  R30, zr, B83	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

188     B24: #	out( B65 B25 ) &lt;- in( B23 )  Freq: 0.999994
188 +   remw  R8, R10, R30	#@modI
18c +   xorr  R7, R8, R30	#@xorI_reg_reg
190 +   blt  R7, zr, B65	#@cmpI_reg_imm0_branch  P=0.127333 C=5411.000000

194     B25: #	out( B82 B26 ) &lt;- in( B24 B66 )  Freq: 0.999994
194 +   addw  R7, R8, zr	#@convI2L_reg_reg
198 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
19c +   add R18, R29, R7	# ptr, #@addP_reg_reg
1a0 +   bgeu  R8, R30, B82	#@cmpU_branch  P=0.000001 C=-1.000000

1a4     B26: #	out( B39 B27 ) &lt;- in( B25 )  Freq: 0.999993
1a4 +   lwu  R7, [R18, #16]	# loadN, compressed ptr, #@loadN
1a8 +   decode_heap_oop  R13, R7	#@decodeHeapOop
1ac +   beq   R13, zr, B39	#@cmpP_imm0_branch  P=0.333442 C=15352.000000

1b0     B27: #	out( B72 B28 ) &lt;- in( B26 )  Freq: 0.666553
1b0 +   mv  R28, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1c0     spill [sp, #0] -&gt; R7	# spill size = 32
1c4 +   bne  R7, R28, B72	#@cmpN_branch  P=0.000098 C=-1.000000

1c8     B28: #	out( B50 B29 ) &lt;- in( B27 )  Freq: 0.666488
1c8 +   spill [sp, #16] -&gt; R12	# spill size = 64
1cc +   lwu  R28, [R13, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
1d0 +   # checkcastPP of R12, #@checkCastPP
1d0     lb  R31, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
1d4 +   mv  R7, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1e4 +   beq  R12, R13, B50	#@cmpP_branch  P=0.000001 C=5338.000000

1e8     B29: #	out( B102 B30 ) &lt;- in( B28 )  Freq: 0.666488
1e8 +   bne  R28, R7, B102	#@cmpN_branch  P=0.000000 C=-1.000000

1ec     B30: #	out( B91 B31 ) &lt;- in( B29 )  Freq: 0.666488
1ec +   # checkcastPP of R13, #@checkCastPP
1ec     lb  R28, [R13, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
1f0 +   bne  R31, R28, B91	#@cmpI_branch  P=0.000000 C=4992.000000

1f4     B31: #	out( B85 B32 ) &lt;- in( B30 )  Freq: 0.666487
1f4 +   lwu  R28, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
1f8 +   decode_heap_oop  R15, R28	#@decodeHeapOop
1fc +   lwu  R10, [R13, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
200 +   beq   R15, zr, B85	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

204     B32: #	out( B84 B33 ) &lt;- in( B31 )  Freq: 0.666487
204 +   decode_heap_oop  R7, R10	#@decodeHeapOop
208 +   lwu  R16, [R15, #12]	# range, #@loadRange
20c +   beq   R7, zr, B84	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

210     B33: #	out( B35 B34 ) &lt;- in( B32 )  Freq: 0.666486
210 +   lwu  R28, [R7, #12]	# range, #@loadRange
214 +   addiw  R17, R8, #1	#@addI_reg_imm
218 +   addi  R9, R15, #16	# ptr, #@addP_reg_imm
21c +   bne  R16, R28, B35	#@cmpI_branch  P=0.001000 C=-1.000000

220     B34: #	out( B63 B35 ) &lt;- in( B33 )  Freq: 0.66582
220 +   spill R16 -&gt; R14	# spill size = 32
224 +   addi  R13, R7, #16	# ptr, #@addP_reg_imm
228     spill R9 -&gt; R11	# spill size = 64
22c +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
2bc +   bne  R10, zr, B63	#@cmpI_reg_imm0_branch  P=0.000000 C=10233.000000

2c0     B35: #	out( B92 B36 ) &lt;- in( B34 B33 )  Freq: 0.666486
2c0 +   beq  R17, R30, B92	#@cmpI_branch  P=0.000000 C=10233.000000

2c4     B36: #	out( B80 B37 ) &lt;- in( B35 )  Freq: 0.666485
2c4 +   bgeu  R17, R30, B80	#@cmpU_branch  P=0.000001 C=-1.000000

2c8     B37: #	out( B40 B38 ) &lt;- in( B36 )  Freq: 0.666485
2c8 +   lwu  R28, [R18, #20]	# loadN, compressed ptr, #@loadN
2cc +   decode_heap_oop  R13, R28	#@decodeHeapOop
2d0 +   bne   R13, zr, B40	#@cmpP_imm0_branch  P=0.666558 C=10233.000000

2d4     B38: #	out( B39 ) &lt;- in( B37 )  Freq: 0.222234
2d4 +   spill R17 -&gt; R8	# spill size = 32

2d8     B39: #	out( N957 ) &lt;- in( B38 B54 B79 B26 )  Freq: 0.999983
2d8 +   li R28, #-1	# int, #@loadConI
2dc +   subw  R10, R28, R8	#@subI_reg_reg
2e0     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
2f8 +   ret	// return register, #@Ret

2fc     B40: #	out( B49 B41 ) &lt;- in( B37 )  Freq: 0.444251
2fc +   lwu  R7, [R13, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
300 +   mv  R10, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
310 +   beq  R12, R13, B49	#@cmpP_branch  P=0.000001 C=5338.000000

314     B41: #	out( B101 B42 ) &lt;- in( B40 )  Freq: 0.44425
314 +   bne  R7, R10, B101	#@cmpN_branch  P=0.000000 C=-1.000000

318     B42: #	out( B90 B43 ) &lt;- in( B41 )  Freq: 0.44425
318 +   # checkcastPP of R13, #@checkCastPP
318     lwu  R7, [R13, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
31c +   lb  R28, [R13, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
320 +   decode_heap_oop  R7, R7	#@decodeHeapOop
324 +   bne  R31, R28, B90	#@cmpI_branch  P=0.000000 C=4992.000000

328     B43: #	out( B85 B44 ) &lt;- in( B42 )  Freq: 0.44425
328 +   beq   R15, zr, B85	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

32c     B44: #	out( B84 B45 ) &lt;- in( B43 )  Freq: 0.44425
32c +   beq   R7, zr, B84	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

330     B45: #	out( B47 B46 ) &lt;- in( B44 )  Freq: 0.444249
330 +   lwu  R28, [R7, #12]	# range, #@loadRange
334 +   addiw  R8, R8, #2	#@addI_reg_imm
338 +   bne  R16, R28, B47	#@cmpI_branch  P=0.001000 C=-1.000000

33c     B46: #	out( B62 B47 ) &lt;- in( B45 )  Freq: 0.443805
33c +   spill R16 -&gt; R14	# spill size = 32
340 +   addi  R13, R7, #16	# ptr, #@addP_reg_imm
344     spill R9 -&gt; R11	# spill size = 64
348 +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
3d8 +   bne  R10, zr, B62	#@cmpI_reg_imm0_branch  P=0.000000 C=10233.000000

3dc     B47: #	out( B93 B48 ) &lt;- in( B46 B45 )  Freq: 0.444249
3dc +   beq  R8, R30, B93	#@cmpI_branch  P=0.000000 C=10233.000000

3e0     B48: #	out( B53 ) &lt;- in( B47 )  Freq: 0.444249
3e0 +   ld  R7, [R23, #920]	# ptr, #@loadP
3e4 +   mv  R18, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
3f4 +   j  B53	#@branch

3f8     B49: #	out( B50 ) &lt;- in( B40 )  Freq: 4.5015e-07
3f8 +   spill R17 -&gt; R8	# spill size = 32

3fc     B50: #	out( B63 ) &lt;- in( B28 B49 B55 )  Freq: 2.02534e-06
3fc +   li R10, #1	# int, #@loadConI
400 +   j  B63	#@branch
        nop 	# 6 bytes pad for loops and calls

410     B51: #	out( B93 B52 ) &lt;- in( B60 B59 ) top-of-loop Freq: 0.888052
410 +   addiw  R8, R8, #1	#@addI_reg_imm
414 +   beq  R8, R30, B93	#@cmpI_branch  P=0.000000 C=10233.000000

418     B52: #	out( B53 ) &lt;- in( B51 )  Freq: 0.888052
418 +   ld  R7, [R23, #920]	# ptr, #@loadP

41c     B53: #	out( B81 B54 ) &lt;- in( B48 B52 ) Loop( B53-B52 inner partial_peel ) Freq: 1.3323
41c +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.util.ImmutableCollections$SetN::probe @ bci:53 (line 1017) L[0]=sp + #8 L[1]=sp + #16 L[2]=R8 L[3]=_
        # OopMap {x29=Oop c_rarg2=Oop c_rarg5=Oop x9=Derived_oop_c_rarg5 [8]=Oop [16]=Oop off=1052/0x41c}
420 +   addw  R7, R8, zr	#@convI2L_reg_reg
424 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
428 +   add R7, R29, R7	# ptr, #@addP_reg_reg
42c +   bgeu  R8, R30, B81	#@cmpU_branch  P=0.000001 C=-1.000000

430     B54: #	out( B39 B55 ) &lt;- in( B53 )  Freq: 1.3323
430 +   lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN
434 +   decode_heap_oop  R13, R7	#@decodeHeapOop
438 +   beq   R13, zr, B39	#@cmpP_imm0_branch  P=0.333442 C=10233.000000

43c     B55: #	out( B50 B56 ) &lt;- in( B54 )  Freq: 0.888055
43c +   lwu  R28, [R13, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
440 +   beq  R12, R13, B50	#@cmpP_branch  P=0.000001 C=5338.000000

444     B56: #	out( B102 B57 ) &lt;- in( B55 )  Freq: 0.888054
444 +   bne  R28, R18, B102	#@cmpN_branch  P=0.000000 C=-1.000000

448     B57: #	out( B91 B58 ) &lt;- in( B56 )  Freq: 0.888054
448 +   # checkcastPP of R13, #@checkCastPP
448     lwu  R7, [R13, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
44c +   lb  R28, [R13, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
450 +   decode_heap_oop  R7, R7	#@decodeHeapOop
454 +   bne  R31, R28, B91	#@cmpI_branch  P=0.000000 C=4992.000000

458     B58: #	out( B84 B59 ) &lt;- in( B57 )  Freq: 0.888053
458 +   beq   R7, zr, B84	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

45c     B59: #	out( B51 B60 ) &lt;- in( B58 )  Freq: 0.888052
45c +   lwu  R10, [R7, #12]	# range, #@loadRange
460 +   bne  R16, R10, B51	#@cmpI_branch  P=0.001000 C=-1.000000

464     B60: #	out( B51 B61 ) &lt;- in( B59 )  Freq: 0.887164
464 +   spill R16 -&gt; R14	# spill size = 32
468 +   addi  R13, R7, #16	# ptr, #@addP_reg_imm
46c     spill R9 -&gt; R11	# spill size = 64
470 +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
500 +   beq  R10, zr, B51	#@cmpI_reg_imm0_branch  P=1.000000 C=10233.000000

504     B61: #	out( B62 ) &lt;- in( B60 )  Freq: 4.23033e-07
504 +   spill R8 -&gt; R17	# spill size = 32

508     B62: #	out( B63 ) &lt;- in( B46 B61 )  Freq: 6.34656e-07
508 +   spill R17 -&gt; R8	# spill size = 32

50c     B63: #	out( B64 ) &lt;- in( B50 B34 B62 )  Freq: 2.97748e-06
50c +   spill R10 -&gt; [sp, #0]	# spill size = 32

510     B64: #	out( N957 ) &lt;- in( B63 B99 )  Freq: 2.97757e-06
510 +   li R11, #-187	# int, #@loadConI
514     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:34 (line 1012) L[0]=sp + #8 L[1]=sp + #16 L[2]=R8 L[3]=_ STK[0]=sp + #0
        # OopMap {[8]=Oop [16]=Oop off=1304/0x518}
518     #@ShouldNotReachHere

524     B65: #	out( B97 B66 ) &lt;- in( B24 )  Freq: 0.127332
524 +   addw  R28, R8, R30	#@addI_reg_reg
528 +   beq  R8, zr, B97	#@cmpI_reg_imm0_branch  P=0.000000 C=689.000000

52c     B66: #	out( B25 ) &lt;- in( B65 )  Freq: 0.127332
52c +   spill R28 -&gt; R8	# spill size = 32
530 +   j  B25	#@branch

534     B67: #	out( B22 ) &lt;- in( B20 B7 )  Freq: 0.0296047
534 +   sb  R11, [R12, #17]	# byte, #@storeB ! Field: java/lang/String.hashIsZero
538 +   li R10, #0	# int, #@loadConI
53c +   j  B22	#@branch

540     B68: #	out( B107 B69 ) &lt;- in( B2 )  Freq: 0.00097674
540 +   spill R12 -&gt; R11	# spill size = 64
544 +   spill R12 -&gt; R8	# spill size = 64
548     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #8 L[1]=R8 L[2]=_ L[3]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=1380/0x564}

564     B69: #	out( B22 ) &lt;- in( B68 )  Freq: 0.000976721
        # Block is sole successor of call
564 +   j  B22	#@branch

568     B70: #	out( B22 ) &lt;- in( B4 )  Freq: 0.000557687
568 +   li R10, #0	# int, #@loadConI
56c +   j  B22	#@branch

570     B71: #	out( B73 ) &lt;- in( B78 ) top-of-loop Freq: 0.000130245
570 +   spill R10 -&gt; R8	# spill size = 32
574 +   j  B73	#@branch

578     B72: #	out( B73 ) &lt;- in( B27 )  Freq: 6.51567e-05
578 +   spill R13 -&gt; R12	# spill size = 64

57c     B73: #	out( B106 B74 ) &lt;- in( B72 B71 ) Loop( B73-B71 inner ) Freq: 0.000195403
57c +   spill [sp, #16] -&gt; R11	# spill size = 64
580     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::equals
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=sp + #8 L[1]=sp + #16 L[2]=R8 L[3]=_
        # OopMap {[8]=Oop [16]=Oop off=1436/0x59c}

59c     B74: #	out( B99 B75 ) &lt;- in( B73 )  Freq: 0.000195399
        # Block is sole successor of call
59c +   spill [sp, #8] -&gt; R7	# spill size = 64
5a0 +   lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$SetN.elements (constant)
5a4 +   decode_heap_oop  R29, R7	#@decodeHeapOop
5a8 +   bne  R10, zr, B99	#@cmpI_reg_imm0_branch  P=0.000000 C=10233.000000

5ac     B75: #	out( B109 B76 ) &lt;- in( B74 )  Freq: 0.000195399
5ac     lwu  R30, [R29, #12]	# range, #@loadRange
5b0     NullCheck R29

5b0     B76: #	out( B100 B77 ) &lt;- in( B75 )  Freq: 0.000195399
5b0 +   addiw  R10, R8, #1	#@addI_reg_imm
5b4 +   beq  R10, R30, B100	#@cmpI_branch  P=0.000000 C=10233.000000

5b8     B77: #	out( B98 B78 ) &lt;- in( B76 )  Freq: 0.000195399
5b8 +   ld  R31, [R23, #920]	# ptr, #@loadP
5bc     spill [sp, #8] -&gt; R7	# spill size = 64
5c0 +   lwu zr, [R31]	# Safepoint: poll for GC, #@safePoint        # java.util.ImmutableCollections$SetN::probe @ bci:53 (line 1017) L[0]=R7 L[1]=sp + #16 L[2]=R10 L[3]=_
        # OopMap {t2=Oop x29=Oop [8]=Oop [16]=Oop off=1472/0x5c0}
5c4 +   bgeu  R10, R30, B98	#@cmpU_branch  P=0.000001 C=-1.000000

5c8     B78: #	out( B71 B79 ) &lt;- in( B77 )  Freq: 0.000195399
5c8 +   addw  R7, R8, zr	#@convI2L_reg_reg
5cc +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
5d0 +   add R7, R29, R7	# ptr, #@addP_reg_reg
5d4 +   lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN
5d8 +   decode_heap_oop  R12, R7	#@decodeHeapOop
5dc +   bne   R12, zr, B71	#@cmpP_imm0_branch  P=0.666558 C=10233.000000

5e0     B79: #	out( B39 ) &lt;- in( B78 )  Freq: 6.51541e-05
5e0 +   spill R10 -&gt; R8	# spill size = 32
5e4 +   j  B39	#@branch

5e8     B80: #	out( B81 ) &lt;- in( B36 )  Freq: 6.75336e-07
5e8 +   spill R17 -&gt; R8	# spill size = 32

5ec     B81: #	out( N957 ) &lt;- in( B80 B53 B98 )  Freq: 2.02553e-06
5ec +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
5f4 +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
5fc +   li R11, #-28	# int, #@loadConI
600     spill R29 -&gt; [sp, #16]	# spill size = 64
604     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:18 (line 1009) L[0]=sp + #0 L[1]=sp + #8 L[2]=R8 L[3]=_ STK[0]=sp + #16 STK[1]=R8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=1544/0x608}
608     #@ShouldNotReachHere

614     B82: #	out( N957 ) &lt;- in( B25 )  Freq: 1.01327e-06
614 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
61c +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
624 +   li R11, #-28	# int, #@loadConI
628     spill R29 -&gt; [sp, #16]	# spill size = 64
62c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:18 (line 1009) L[0]=sp + #0 L[1]=sp + #8 L[2]=R8 L[3]=_ STK[0]=sp + #16 STK[1]=R8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=1584/0x630}
630     #@ShouldNotReachHere

63c     B83: #	out( N957 ) &lt;- in( B23 )  Freq: 9.99995e-07
63c +   li R11, #-122	# int, #@loadConI
640     spill R10 -&gt; R8	# spill size = 32
644     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;div0_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.Math::floorMod @ bci:2 (line 1342) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8 STK[1]=#0
        # java.util.ImmutableCollections$SetN::probe @ bci:9 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=1608/0x648}
648     #@ShouldNotReachHere

654     B84: #	out( N957 ) &lt;- in( B32 B58 B44 )  Freq: 2.02533e-06
654     #@ShouldNotReachHere

660     B85: #	out( N957 ) &lt;- in( B31 B43 )  Freq: 1.12549e-06
660     #@ShouldNotReachHere

66c     B86: #	out( N957 ) &lt;- in( B8 )  Freq: 5.01932e-07
66c +   spill [sp, #8] -&gt; R8	# spill size = 64
670 +   li R11, #-138	# int, #@loadConI
674     spill R12 -&gt; [sp, #8]	# spill size = 64
678 +   spill R13 -&gt; [sp, #16]	# spill size = 64
67c +   spill R30 -&gt; [sp, #28]	# spill size = 32
680     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:13 (line 196) L[0]=_ L[1]=#0 L[2]=sp + #16 L[3]=sp + #28 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=sp + #28
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=sp + #8 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=1668/0x684}
684     #@ShouldNotReachHere

690     B87: #	out( B16 ) &lt;- in( B9 )  Freq: 5.01931e-07
690 +   li R16, #1	# int, #@loadConI
694 +   j  B16	#@branch

698     B88: #	out( N957 ) &lt;- in( B10 )  Freq: 4.95353e-07
698     #@ShouldNotReachHere

6a4     B89: #	out( N957 ) &lt;- in( B11 )  Freq: 4.95352e-07
6a4     #@ShouldNotReachHere

6b0     B90: #	out( B91 ) &lt;- in( B42 )  Freq: 2.22125e-07
6b0 +   spill R17 -&gt; R8	# spill size = 32

6b4     B91: #	out( N957 ) &lt;- in( B30 B90 B57 )  Freq: 9.99396e-07
6b4 +   li R11, #-187	# int, #@loadConI
6b8     spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
6c0 +   spill R12 -&gt; [sp, #16]	# spill size = 64
6c4 +   spill R13 -&gt; [sp, #24]	# spill size = 64
6c8 +   spill R31 -&gt; [sp, #32]	# spill size = 32
6cc +   spill R28 -&gt; [sp, #36]	# spill size = 32
6d0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #16 L[1]=_ L[2]=sp + #24 STK[0]=sp + #32 STK[1]=sp + #36
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=sp + #0 L[1]=sp + #16 L[2]=R8 L[3]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop off=1748/0x6d4}
6d4     #@ShouldNotReachHere

6e0     B92: #	out( B93 ) &lt;- in( B35 )  Freq: 3.17805e-07
6e0 +   spill R17 -&gt; R8	# spill size = 32

6e4     B93: #	out( N957 ) &lt;- in( B92 B47 B51 B100 )  Freq: 9.53189e-07
6e4 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
6ec +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
6f4 +   li R11, #-187	# int, #@loadConI
6f8     spill R30 -&gt; [sp, #20]	# spill size = 32
6fc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:48 (line 1014) L[0]=sp + #0 L[1]=sp + #8 L[2]=R8 L[3]=_ STK[0]=R8 STK[1]=sp + #20
        # OopMap {[0]=Oop [8]=Oop off=1792/0x700}
700     #@ShouldNotReachHere

70c     B94: #	out( N957 ) &lt;- in( B5 )  Freq: 2.62392e-07
70c +   li R11, #-187	# int, #@loadConI
710     spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
718 +   spill R12 -&gt; [sp, #16]	# spill size = 64
71c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=R8
        # java.lang.String::hashCode @ bci:17 (line 2337) L[0]=sp + #16 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # OopMap {[0]=Oop [16]=Oop off=1824/0x720}
720     #@ShouldNotReachHere

72c     B95: #	out( N957 ) &lt;- in( B17 )  Freq: 2.50965e-07
72c     #@ShouldNotReachHere

738     B96: #	out( N957 ) &lt;- in( B18 )  Freq: 2.50965e-07
738     #@ShouldNotReachHere

744     B97: #	out( N957 ) &lt;- in( B65 )  Freq: 6.07169e-08
744 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
74c +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
754 +   li R11, #-187	# int, #@loadConI
758     spill R30 -&gt; [sp, #16]	# spill size = 32
75c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.Math::floorMod @ bci:11 (line 1344) L[0]=_ L[1]=sp + #16 L[2]=R8 STK[0]=R8
        # java.util.ImmutableCollections$SetN::probe @ bci:9 (line 1007) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=_
        # OopMap {[0]=Oop [8]=Oop off=1888/0x760}
760     #@ShouldNotReachHere

76c     B98: #	out( B81 ) &lt;- in( B77 )  Freq: 1.97994e-10
76c +   spill R10 -&gt; R8	# spill size = 32
770 +   j  B81	#@branch

774     B99: #	out( B64 ) &lt;- in( B74 )  Freq: 9.31737e-11
774 +   spill R10 -&gt; [sp, #0]	# spill size = 32
778 +   j  B64	#@branch

77c     B100: #	out( B93 ) &lt;- in( B76 )  Freq: 9.31735e-11
77c +   spill R10 -&gt; R8	# spill size = 32
780 +   j  B93	#@branch

784     B101: #	out( B102 ) &lt;- in( B41 )  Freq: 1e-35
784 +   spill R17 -&gt; R8	# spill size = 32

788     B102: #	out( N957 ) &lt;- in( B29 B101 B56 )  Freq: 1e-35
788 +   li R11, #-34	# int, #@loadConI
78c     spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
794 +   spill R12 -&gt; [sp, #16]	# spill size = 64
798 +   spill R13 -&gt; [sp, #32]	# spill size = 64
79c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #16 L[1]=sp + #32 L[2]=_ STK[0]=sp + #32
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=sp + #0 L[1]=sp + #16 L[2]=R8 L[3]=_
        # OopMap {[0]=Oop [16]=Oop [32]=Oop off=1952/0x7a0}
7a0     #@ShouldNotReachHere

7ac     B103: #	out( N957 ) &lt;- in( B1 )  Freq: 1.01328e-06
7ac +   li R11, #-10	# int, #@loadConI
7b0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # OopMap {off=1972/0x7b4}
7b4     #@ShouldNotReachHere

7c0     B104: #	out( N957 ) &lt;- in( B22 )  Freq: 1.01328e-06
7c0 +   li R11, #-10	# int, #@loadConI
7c4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:8 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=1992/0x7c8}
7c8     #@ShouldNotReachHere

7d4     B105: #	out( N957 ) &lt;- in( B6 )  Freq: 5.31752e-07
7d4 +   li R11, #-10	# int, #@loadConI
7d8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:5 (line 196) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=_ L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=2012/0x7dc}
7dc     #@ShouldNotReachHere

7e8     B106: #	out( B108 ) &lt;- in( B73 )  Freq: 1.95403e-09
7e8      -- 	// exception oop; no code emitted, #@CreateException
7e8 +   spill R10 -&gt; R11	# spill size = 64
7ec +   j  B108	#@branch

7f0     B107: #	out( B108 ) &lt;- in( B68 )  Freq: 9.7674e-09
7f0      -- 	// exception oop; no code emitted, #@CreateException
7f0 +   spill R10 -&gt; R11	# spill size = 64

7f4     B108: #	out( N957 ) &lt;- in( B107 B106 )  Freq: 1.17214e-08
7f4     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
800 +   j rethrow_stub	#@RethrowException

808     B109: #	out( N957 ) &lt;- in( B75 )  Freq: 1.97994e-10
808 +   li R11, #-10	# int, #@loadConI
80c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:47 (line 1014) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=2064/0x810}
810     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='323'>
----------------------- MetaData before Compile_id = 323 ------------------------
{method}
 - this oop:          0x00000040961e96b0
 - method holder:     &apos;java/lang/CharacterDataLatin1&apos;
 - constants:         0x00000040961e89b8 constant pool [130] {0x00000040961e89b8} for &apos;java/lang/CharacterDataLatin1&apos; cache=0x00000040961eb818
 - access:            0x81000000  
 - name:              &apos;isJavaIdentifierStart&apos;
 - signature:         &apos;(I)Z&apos;
 - max stack:         3
 - max locals:        3
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      27
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bb30: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c4fdd00
 - code size:         23
 - code start:        0x00000040961e9668
 - code end (excl):   0x00000040961e967f
 - method data:       0x0000004096482808
 - checked ex length: 0
 - linenumber start:  0x00000040961e967f
 - localvar length:   3
 - localvar start:    0x00000040961e968a
 - compiled code: nmethod  13737  157       3       java.lang.CharacterDataLatin1::isJavaIdentifierStart (23 bytes)

------------------------ OptoAssembly for Compile_id = 323 -----------------------
#
#  bool ( java/lang/CharacterDataLatin1:NotNull *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/CharacterDataLatin1:NotNull *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N50: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B4 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     zext.h  R7, R12	# s2ui, #@convS2UI_reg_reg_b
040 +   addw  R28, R7, zr	#@convI2L_reg_reg
044 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
048 +   mv  R29, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1157 address=0x00000040d07cf5e0&gt; *	# ptr, #@loadConP
060 +   li R30, #256	# int, #@loadConI
064 +   add R28, R29, R28	# ptr, #@addP_reg_reg
068 +   bgeu  R7, R30, B4	#@cmpU_branch  P=0.000001 C=-1.000000

06c     B2: #	out( B5 B3 ) &lt;- in( B1 )  Freq: 0.999999
06c +   lw  R7, [R28, #16]	# int, #@loadI
070 +   li R29, #28672	# int, #@loadConI
074 +   li R28, #20480	# int, #@loadConI
078 +   andr  R8, R7, R29	#@andI_reg_reg
07c +   blt  R8, R28, B5	#@cmpI_branch  P=0.000000 C=5375.000000

080     B3: #	out( N50 ) &lt;- in( B2 )  Freq: 0.999999
080 +   li R10, #1	# int, #@loadConI
084     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
09c +   ret	// return register, #@Ret

0a0     B4: #	out( N50 ) &lt;- in( B1 )  Freq: 1.01328e-06
0a0 +   li R11, #-28	# int, #@loadConI
0a4     spill R7 -&gt; R8	# spill size = 32
0a8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.CharacterDataLatin1::getProperties @ bci:7 (line 74) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#Ptr0x00000040d07cf5e0 STK[1]=R8
        # java.lang.CharacterDataLatin1::isJavaIdentifierStart @ bci:2 (line 115) L[0]=_ L[1]=_ L[2]=_
        # OopMap {off=172/0xac}
0ac     #@ShouldNotReachHere

0b8     B5: #	out( N50 ) &lt;- in( B2 )  Freq: 4.99999e-07
0b8 +   li R11, #-187	# int, #@loadConI
0bc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.CharacterDataLatin1::isJavaIdentifierStart @ bci:14 (line 116) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8 STK[1]=#20480
        # OopMap {off=192/0xc0}
0c0 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='324'>
----------------------- MetaData before Compile_id = 324 ------------------------
{method}
 - this oop:          0x0000004096503df8
 - method holder:     &apos;java/util/concurrent/locks/ReentrantReadWriteLock$Sync&apos;
 - constants:         0x0000004096503508 constant pool [193] {0x0000004096503508} for &apos;java/util/concurrent/locks/ReentrantReadWriteLock$Sync&apos; cache=0x0000004096509398
 - access:            0x81000008  static 
 - name:              &apos;exclusiveCount&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         3
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b960: 0xa i2c: 0x00000040139d7540 c2i: 0x00000040139d7584 c2iUV: 0x00000040139d7550
 - compiled entry     0x000000400c508ec0
 - code size:         5
 - code start:        0x0000004096503de0
 - code end (excl):   0x0000004096503de5
 - method data:       0x0000004096487b18
 - checked ex length: 0
 - linenumber start:  0x0000004096503de5
 - localvar length:   1
 - localvar start:    0x0000004096503dea
 - compiled code: nmethod  13761  182       3       java.util.concurrent.locks.ReentrantReadWriteLock$Sync::exclusiveCount (5 bytes)

------------------------ OptoAssembly for Compile_id = 324 -----------------------
#
#  int ( int )
#
#r012 c_rarg1   : parm 0: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N1: #	out( B1 ) &lt;- in( B1 )  Freq: 1

000     B1: #	out( N1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
01c     zext.h  R10, R11	# s2ui, #@convS2UI_reg_reg_b
020     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
038 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='327'>
----------------------- MetaData before Compile_id = 327 ------------------------
{method}
 - this oop:          0x00000040965e8a98
 - method holder:     &apos;jdk/internal/module/Checks&apos;
 - constants:         0x00000040965e7798 constant pool [250] {0x00000040965e7798} for &apos;jdk/internal/module/Checks&apos; cache=0x00000040965e8ce8
 - access:            0xc100000a  private static 
 - name:              &apos;isJavaIdentifier&apos;
 - signature:         &apos;(Ljava/lang/String;)Z&apos;
 - max stack:         3
 - max locals:        4
 - size of params:    1
 - method size:       13
 - highest level:     4
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c574480
 - code size:         76
 - code start:        0x00000040965e8a08
 - code end (excl):   0x00000040965e8a54
 - method data:       0x0000004096482320
 - checked ex length: 0
 - linenumber start:  0x00000040965e8a54
 - localvar length:   4
 - localvar start:    0x00000040965e8a66
 - compiled code: nmethod  13956  321       3       jdk.internal.module.Checks::isJavaIdentifier (76 bytes)

------------------------ OptoAssembly for Compile_id = 327 -----------------------
#
#  bool ( java/lang/String:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:exact *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B41 B42 B35 B36 B33 B43 B37 B40 B34 B30 B32 B39 B28 B31 B38 )  Freq: 1

000     B1: #	out( B41 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
01c     spill R11 -&gt; [sp, #0]	# spill size = 64
020     lwu  R28, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
024     NullCheck R11

024     B2: #	out( B42 B3 ) &lt;- in( B1 )  Freq: 0.999999
024 +   decode_heap_oop  R7, R28	#@decodeHeapOop
028     lwu  R8, [R7, #12]	# range, #@loadRange
02c     NullCheck R7

02c     B3: #	out( B35 B4 ) &lt;- in( B2 )  Freq: 0.999998
02c +   bleu  R8, zr, B35	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=8567.000000

030     B4: #	out( B40 B5 ) &lt;- in( B3 )  Freq: 0.999997
030 +   mv  R11, java/util/ImmutableCollections$SetN:exact *	# ptr, #@loadConP
048     spill [sp, #0] -&gt; R12	# spill size = 64
04c     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.ImmutableCollections$SetN::probe
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=80/0x50}

050     B5: #	out( B36 B6 ) &lt;- in( B4 )  Freq: 0.999977
        # Block is sole successor of call
050 +   spill [sp, #0] -&gt; R7	# spill size = 64
054 +   lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
058 +   spill [sp, #0] -&gt; R28	# spill size = 64
05c +   lb  R30, [R28, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
060 +   decode_heap_oop  R14, R7	#@decodeHeapOop
064 +   bge  R10, zr, B36	#@cmpI_reg_imm0_branch  P=0.000000 C=8452.000000

068     B6: #	out( B33 B7 ) &lt;- in( B5 )  Freq: 0.999977
068 +   bne  R30, zr, B33	#@cmpI_reg_imm0_branch  P=0.000000 C=56642.000000

06c     B7: #	out( B43 B8 ) &lt;- in( B6 )  Freq: 0.999977
06c     lwu  R12, [R14, #12]	# range, #@loadRange
070     NullCheck R14

070     B8: #	out( B37 B9 ) &lt;- in( B7 )  Freq: 0.999976
070 +   bleu  R12, zr, B37	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=30867.000000

074     B9: #	out( B34 B10 ) &lt;- in( B8 )  Freq: 0.999975
074 +   lbu  R29, [R14, #16]	# byte, #@loadUB
078 +   addw  R7, R29, zr	#@convI2L_reg_reg
07c +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
080 +   mv  R11, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1215 address=0x00000040d053c110&gt; *	# ptr, #@loadConP
098 +   add R7, R11, R7	# ptr, #@addP_reg_reg
09c +   lw  R28, [R7, #16]	# int, #@loadI
0a0 +   li R7, #28672	# int, #@loadConI
0a4 +   andr  R8, R28, R7	#@andI_reg_reg
0a8 +   li R28, #20480	# int, #@loadConI
0ac +   sraw  R13, R12, R30	#@rShiftI_reg_reg
0b0 +   li R10, #1	# int, #@loadConI
0b4 +   blt  R8, R28, B34	#@cmpI_branch  P=0.000000 C=5376.000000

0b8     B10: #	out( B28 B11 ) &lt;- in( B9 )  Freq: 0.999975
0b8 +   ble  R13, R10, B28	#@cmpI_branch  P=0.216418 C=37848.000000

0bc     B11: #	out( B30 B12 ) &lt;- in( B10 )  Freq: 0.783562
0bc +   bleu  R12, R10, B30	#@cmpU_branch  P=0.000001 C=-1.000000

0c0     B12: #	out( B30 B13 ) &lt;- in( B11 )  Freq: 0.783561
0c0 +   li R7, #-2147483648	# int, #@loadConI
0c4 +   addiw  R15, R13, #-1	#@addI_reg_imm
0c8     CMove R15, (R13 lt R15), R15, R7	#@cmovI_cmpI
	
0d0 +   addw  R28, R13, zr	#@convI2L_reg_reg
0d4 +   addw  R30, R12, zr	#@convI2L_reg_reg
0d8 +   addi  R28, R28, #-1	#@addL_reg_imm
0dc +   li R7, #2	# int, #@loadConI
0e0 +   li R29, #0	# int, #@loadConI
0e4 +   bgeu  R28, R30, B30	#@cmpUL_branch  P=0.000001 C=-1.000000

0e8     B13: #	out( B29 B14 ) &lt;- in( B12 )  Freq: 0.78356
0e8 +   lbu  R30, [R14, #17]	# byte, #@loadUB2L
0ec +   slli  R30, R30, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0f0 +   add R30, R11, R30	# ptr, #@addP_reg_reg
0f4 +   lw  R30, [R30, #16]	# int, #@loadI
0f8 +   li R31, #12288	# int, #@loadConI
0fc +   andr  R16, R30, R31	#@andI_reg_reg
100 +   li R28, #2000	# int, #@loadConI
104 +   beq  R16, zr, B29	#@cmpI_reg_imm0_branch  P=0.000034 C=29658.000000

108     B14: #	out( B23 B15 ) &lt;- in( B13 )  Freq: 0.783534
108 +   ble  R15, R7, B23	#@cmpI_branch  P=0.000001 C=-1.000000

10c     B15: #	out( B31 B16 ) &lt;- in( B14 )  Freq: 0.783533
10c +   li R30, #3	# int, #@loadConI
110 +   bleu  R12, R7, B31	#@cmpU_branch  P=0.000001 C=-1.000000

114     B16: #	out( B32 B17 ) &lt;- in( B15 )  Freq: 0.783532
114 +   bleu  R12, R30, B32	#@cmpU_branch  P=0.000001 C=-1.000000

118     B17: #	out( B18 ) &lt;- in( B16 )  Freq: 0.783531
118 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP

118     B18: #	out( B19 ) &lt;- in( B17 B22 ) Loop( B18-B22 ) Freq: 3.61637
118 +   subw  R16, R15, R7	#@subI_reg_reg
11c     CMove R16, (R15 lt R7), R16, R29	#@cmovI_cmpI
	
124 +   CMove R16, (R16 gtu R28), R16, R28	#@cmovI_cmpU
	
12c +   addw  R17, R16, R7	#@addI_reg_reg

130     B19: #	out( B29 B20 ) &lt;- in( B18 B21 ) Loop( B19-B21 inner main of N176 strip mined) Freq: 16.706
130 +   addw  R30, R7, zr	#@convI2L_reg_reg
134 +   add R30, R14, R30	# ptr, #@addP_reg_reg
138 +   lbu  R16, [R30, #16]	# byte, #@loadUB2L
13c +   lbu  R30, [R30, #17]	# byte, #@loadUB2L
140 +   slli  R16, R16, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
144 +   slli  R30, R30, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
148 +   add R16, R11, R16	# ptr, #@addP_reg_reg
14c +   add R30, R11, R30	# ptr, #@addP_reg_reg
150 +   lw  R9, [R16, #16]	# int, #@loadI
154 +   lw  R30, [R30, #16]	# int, #@loadI
158 +   andr  R9, R9, R31	#@andI_reg_reg
15c +   andr  R30, R30, R31	#@andI_reg_reg
160 +   beq  R9, zr, B29	#@cmpI_reg_imm0_branch  P=0.000034 C=29658.000000

164     B20: #	out( B29 B21 ) &lt;- in( B19 )  Freq: 16.7054
164 +   beq  R30, zr, B29	#@cmpI_reg_imm0_branch  P=0.000034 C=29658.000000

168     B21: #	out( B19 B22 ) &lt;- in( B20 )  Freq: 16.7049
168 +   addiw  R7, R7, #2	#@addI_reg_imm
16c +   blt  R7, R17, B19	#@cmpI_loop  P=0.783582 C=29657.000000

170     B22: #	out( B18 B23 ) &lt;- in( B21 )  Freq: 3.61524
170 +   ld  R30, [R23, #920]	# ptr, #@loadP
174 +   lwu zr, [R30]	# Safepoint: poll for GC, #@safePoint        # jdk.internal.module.Checks::isJavaIdentifier @ bci:71 (line 185) L[0]=sp + #0 L[1]=_ L[2]=R7 L[3]=_
        # OopMap {c_rarg1=Oop c_rarg4=Oop [0]=Oop off=372/0x174}
178 +   blt  R7, R15, B18	#@cmpI_branch  P=0.783582 C=29657.000000

17c     B23: #	out( B28 B24 ) &lt;- in( B14 B22 )  Freq: 0.782405
17c +   bge  R7, R13, B28	#@cmpI_branch  P=0.500000 C=-1.000000

180     B24: #	out( B38 B25 ) &lt;- in( B23 )  Freq: 0.391202
180 +   # castII of R7, #@castII
180     bgeu  R7, R12, B38	#@cmpU_branch  P=0.000001 C=-1.000000

184     B25: #	out( B39 B26 ) &lt;- in( B24 )  Freq: 0.391202
184 +   spill R7 -&gt; R29	# spill size = 32
188 +   # castII of R29, #@castII
188     bgeu  R29, R12, B39	#@cmpU_branch  P=0.000001 C=-1.000000

18c     B26: #	out( B29 B27 ) &lt;- in( B25 B27 ) Loop( B26-B27 inner post of N1096) Freq: 0.782377
18c +   addw  R28, R7, zr	#@convI2L_reg_reg
190 +   add R28, R14, R28	# ptr, #@addP_reg_reg
194 +   lbu  R28, [R28, #16]	# byte, #@loadUB2L
198 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
19c +   add R28, R11, R28	# ptr, #@addP_reg_reg
1a0 +   lw  R28, [R28, #16]	# int, #@loadI
1a4 +   andr  R29, R28, R31	#@andI_reg_reg
1a8 +   beq  R29, zr, B29	#@cmpI_reg_imm0_branch  P=0.000034 C=29658.000000

1ac     B27: #	out( B26 B28 ) &lt;- in( B26 )  Freq: 0.782351
1ac +   addiw  R7, R7, #1	#@addI_reg_imm
1b0 +   blt  R7, R13, B26	#@cmpI_loop  P=0.500000 C=29657.000000

1b4     B28: #	out( N1 ) &lt;- in( B29 B23 B10 B27 )  Freq: 0.999971
1b4     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
1cc +   ret	// return register, #@Ret

1d0     B29: #	out( B28 ) &lt;- in( B26 B20 B13 B19 )  Freq: 0.00118
1d0 +   li R10, #0	# int, #@loadConI
1d4 +   j  B28	#@branch

1d8     B30: #	out( N1 ) &lt;- in( B12 B11 )  Freq: 1.57753e-06
1d8 +   spill [sp, #0] -&gt; R8	# spill size = 64
1dc +   li R11, #-138	# int, #@loadConI
1e0     spill R13 -&gt; [sp, #0]	# spill size = 32
1e4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:46 (line 180) L[0]=R8 L[1]=_ L[2]=#1 L[3]=_ STK[0]=#1 STK[1]=sp + #0
        # OopMap {fp=Oop off=488/0x1e8}
1e8     #@ShouldNotReachHere

1f4     B31: #	out( N1 ) &lt;- in( B15 )  Freq: 7.83533e-07
1f4     #@ShouldNotReachHere

200     B32: #	out( N1 ) &lt;- in( B16 )  Freq: 7.83532e-07
200     #@ShouldNotReachHere

20c     B33: #	out( N1 ) &lt;- in( B6 )  Freq: 4.99988e-07
20c +   li R11, #-187	# int, #@loadConI
210     spill R28 -&gt; [sp, #8]	# spill size = 64
214 +   spill R30 -&gt; [sp, #16]	# spill size = 32
218     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #16
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=sp + #0 L[1]=#0
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #0 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop [8]=Oop off=540/0x21c}
21c     #@ShouldNotReachHere

228     B34: #	out( N1 ) &lt;- in( B9 )  Freq: 4.99988e-07
228 +   li R11, #-187	# int, #@loadConI
22c     spill R29 -&gt; [sp, #8]	# spill size = 32
230     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.CharacterDataLatin1::isJavaIdentifierStart @ bci:14 (line 116) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8 STK[1]=#20480
        # java.lang.Character::isJavaIdentifierStart @ bci:5 (line 10070) L[0]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:28 (line 176) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=564/0x234}
234     #@ShouldNotReachHere

240     B35: #	out( N1 ) &lt;- in( B3 )  Freq: 4.76836e-07
240 +   li R11, #-187	# int, #@loadConI
244     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isEmpty @ bci:5 (line 1487) L[0]=_ STK[0]=R8
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=584/0x248}
248     #@ShouldNotReachHere

254     B36: #	out( N1 ) &lt;- in( B5 )  Freq: 4.76826e-07
254 +   li R11, #-187	# int, #@loadConI
258     spill R28 -&gt; R8	# spill size = 64
25c +   spill R10 -&gt; [sp, #0]	# spill size = 32
260     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::contains @ bci:17 (line 938) L[0]=_ L[1]=_ STK[0]=sp + #0
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop off=612/0x264}
264     #@ShouldNotReachHere

270     B37: #	out( N1 ) &lt;- in( B8 )  Freq: 4.76825e-07
270 +   li R11, #-187	# int, #@loadConI
274     spill R14 -&gt; R8	# spill size = 64
278 +   spill R12 -&gt; [sp, #16]	# spill size = 32
27c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:7 (line 47) L[0]=R8 L[1]=#0 STK[0]=#0 STK[1]=sp + #16
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #0 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop [0]=Oop off=640/0x280}
280     #@ShouldNotReachHere

28c     B38: #	out( N1 ) &lt;- in( B24 )  Freq: 3.96397e-07
28c     #@ShouldNotReachHere

298     B39: #	out( N1 ) &lt;- in( B25 )  Freq: 3.96397e-07
298     #@ShouldNotReachHere

2a4     B40: #	out( N1 ) &lt;- in( B4 )  Freq: 9.99997e-06
2a4      -- 	// exception oop; no code emitted, #@CreateException
2a4 +   spill R10 -&gt; R11	# spill size = 64
2a8 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
2b4 +   j rethrow_stub	#@RethrowException

2bc     B41: #	out( N1 ) &lt;- in( B1 )  Freq: 1.01328e-06
2bc +   li R11, #-10	# int, #@loadConI
2c0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # OopMap {off=708/0x2c4}
2c4     #@ShouldNotReachHere

2d0     B42: #	out( N1 ) &lt;- in( B2 )  Freq: 1.01328e-06
2d0 +   li R11, #-10	# int, #@loadConI
2d4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::isEmpty @ bci:4 (line 1487) L[0]=_ STK[0]=#NULL
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=728/0x2d8}
2d8     #@ShouldNotReachHere

2e4     B43: #	out( N1 ) &lt;- in( B7 )  Freq: 1.01326e-06
2e4 +   li R11, #-10	# int, #@loadConI
2e8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::charAt @ bci:6 (line 47) L[0]=_ L[1]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=748/0x2ec}
2ec     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='328'>
----------------------- MetaData before Compile_id = 328 ------------------------
{method}
 - this oop:          0x0000004096506980
 - method holder:     &apos;java/util/concurrent/locks/AbstractQueuedSynchronizer&apos;
 - constants:         0x0000004096505498 constant pool [349] {0x0000004096505498} for &apos;java/util/concurrent/locks/AbstractQueuedSynchronizer&apos; cache=0x0000004096508bb8
 - access:            0x8100000a  private static 
 - name:              &apos;signalNext&apos;
 - signature:         &apos;(Ljava/util/concurrent/locks/AbstractQueuedSynchronizer$Node;)V&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c50a000
 - code size:         34
 - code start:        0x0000004096506938
 - code end (excl):   0x000000409650695a
 - method data:       0x00000040964882d8
 - checked ex length: 0
 - linenumber start:  0x000000409650695a
 - localvar length:   2
 - localvar start:    0x0000004096506966
 - compiled code: nmethod  14065  185       3       java.util.concurrent.locks.AbstractQueuedSynchronizer::signalNext (34 bytes)

------------------------ OptoAssembly for Compile_id = 328 -----------------------
#
#  void ( java/util/concurrent/locks/AbstractQueuedSynchronizer$Node * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/concurrent/locks/AbstractQueuedSynchronizer$Node *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B3 B2 )  Freq: 1

000     B1: #	out( B3 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     bne   R11, zr, B3	#@cmpP_imm0_branch  P=0.000000 C=5375.000000

020     B2: #	out( N1 ) &lt;- in( B1 )  Freq: 1
020     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
038 +   ret	// return register, #@Ret

03c     B3: #	out( N1 ) &lt;- in( B1 )  Freq: 4.76837e-07
03c +   spill R11 -&gt; [sp, #0]	# spill size = 64
040 +   li R11, #-187	# int, #@loadConI
044     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::signalNext @ bci:1 (line 609) L[0]=sp + #0 L[1]=_ STK[0]=sp + #0
        # OopMap {[0]=Oop off=72/0x48}
048 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='329'>
----------------------- MetaData before Compile_id = 329 ------------------------
{method}
 - this oop:          0x00000040965563c0
 - method holder:     &apos;java/nio/file/FileTreeWalker$Event&apos;
 - constants:         0x00000040965560a0 constant pool [51] {0x00000040965560a0} for &apos;java/nio/file/FileTreeWalker$Event&apos; cache=0x00000040965568c8
 - access:            0x81000002  private 
 - name:              &apos;&lt;init&gt;&apos;
 - signature:         &apos;(Ljava/nio/file/FileTreeWalker$EventType;Ljava/nio/file/Path;Ljava/nio/file/attribute/BasicFileAttributes;Ljava/io/IOException;)V&apos;
 - max stack:         3
 - max locals:        5
 - size of params:    5
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008324870: 0xbbbbb i2c: 0x0000004013936140 c2i: 0x0000004013936194 c2iUV: 0x0000004013936160
 - compiled entry     0x000000400c510480
 - code size:         26
 - code start:        0x0000004096556358
 - code end (excl):   0x0000004096556372
 - method data:       0x000000409648c1c0
 - checked ex length: 0
 - linenumber start:  0x0000004096556372
 - localvar length:   5
 - localvar start:    0x0000004096556382
 - compiled code: nmethod  14175  202       3       java.nio.file.FileTreeWalker$Event::&lt;init&gt; (26 bytes)

------------------------ OptoAssembly for Compile_id = 329 -----------------------
#
#  void ( java/nio/file/FileTreeWalker$Event:NotNull *, java/nio/file/FileTreeWalker$EventType:exact *, java/nio/file/Path *, java/nio/file/attribute/BasicFileAttributes *, java/io/IOException * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/nio/file/FileTreeWalker$Event:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/nio/file/FileTreeWalker$EventType:exact *
#r016 c_rarg3:c_rarg3   : parm 2: java/nio/file/Path *
#r018 c_rarg4:c_rarg4   : parm 3: java/nio/file/attribute/BasicFileAttributes *
#r020 c_rarg5:c_rarg5   : parm 4: java/io/IOException *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N579: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B19 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c      -- 	// R23=Thread::current(), empty, #@tlsLoadP
03c     lb  R7, [R23, #56]	# byte, #@loadB
040     spill R15 -&gt; R20	# spill size = 64
044 +   spill R14 -&gt; R18	# spill size = 64
048 +   spill R13 -&gt; R19	# spill size = 64
04c +   spill R12 -&gt; R9	# spill size = 64
050 +   bne  R7, zr, B19	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

054     B2: #	out( B3 ) &lt;- in( B1 )  Freq: 0.999
054 +   spill R11 -&gt; R21	# spill size = 64

058     B3: #	out( B6 B4 ) &lt;- in( B47 B21 B19 B2 )  Freq: 1
058 +   mv  R7, R21	# ptr -&gt; long, #@castP2X
05c     spill R9 -&gt; R30	# spill size = 64
060 +   mv  R28, R30	# ptr -&gt; long, #@castP2X
064 +   xorr  R28, R28, R7	#@xorL_reg_reg
068 +   srli  R29, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
06c +   encode_heap_oop  R22, R19	#@encodeHeapOop
070 +   encode_heap_oop  R28, R30	#@encodeHeapOop
074     spill R18 -&gt; R25	# spill size = 64
078 +   encode_heap_oop  R18, R18	#@encodeHeapOop
07c     spill R19 -&gt; R26	# spill size = 64
080 +   encode_heap_oop  R19, R20	#@encodeHeapOop
084 +   li R24, #4	# int, #@loadConI
088 +   mv  R9, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
094 +   sw  R28, [R21, #12]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$Event.type
098 +   beq  R29, zr, B6	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

09c     B4: #	out( B6 B5 ) &lt;- in( B3 )  Freq: 0.999
09c +   beq   R30, zr, B6	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

0a0     B5: #	out( B31 B6 ) &lt;- in( B4 )  Freq: 0.998001
0a0 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0a4 +   add R10, R9, R7	# ptr, #@addP_reg_reg
0a8 +   lb  R28, [R10]	# byte, #@loadB
0ac +   bne  R28, R24, B31	#@cmpI_branch  P=0.001000 C=-1.000000

0b0     B6: #	out( B22 B7 ) &lt;- in( B33 B34 B31 B5 B4 B3 )  Freq: 1
0b0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0b0     lb  R7, [R23, #56]	# byte, #@loadB
0b4 +   bne  R7, zr, B22	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0b8     B7: #	out( B10 B8 ) &lt;- in( B48 B24 B22 B6 )  Freq: 1
0b8 +   mv  R7, R21	# ptr -&gt; long, #@castP2X
0bc +   mv  R28, R26	# ptr -&gt; long, #@castP2X
0c0 +   xorr  R28, R28, R7	#@xorL_reg_reg
0c4 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0c8 +   sw  R22, [R21, #16]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$Event.file
0cc +   beq  R28, zr, B10	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0d0     B8: #	out( B10 B9 ) &lt;- in( B7 )  Freq: 0.999
0d0 +   beq   R26, zr, B10	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

0d4     B9: #	out( B35 B10 ) &lt;- in( B8 )  Freq: 0.998001
0d4 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0d8 +   add R10, R9, R7	# ptr, #@addP_reg_reg
0dc +   lb  R28, [R10]	# byte, #@loadB
0e0 +   bne  R28, R24, B35	#@cmpI_branch  P=0.001000 C=-1.000000

0e4     B10: #	out( B25 B11 ) &lt;- in( B37 B38 B35 B9 B8 B7 )  Freq: 1
0e4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e4     lb  R7, [R23, #56]	# byte, #@loadB
0e8 +   bne  R7, zr, B25	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0ec     B11: #	out( B14 B12 ) &lt;- in( B49 B27 B25 B10 )  Freq: 1
0ec +   mv  R7, R21	# ptr -&gt; long, #@castP2X
0f0 +   mv  R28, R25	# ptr -&gt; long, #@castP2X
0f4 +   xorr  R28, R28, R7	#@xorL_reg_reg
0f8 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0fc +   sw  R18, [R21, #20]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$Event.attrs
100 +   beq  R28, zr, B14	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

104     B12: #	out( B14 B13 ) &lt;- in( B11 )  Freq: 0.999
104 +   beq   R25, zr, B14	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

108     B13: #	out( B39 B14 ) &lt;- in( B12 )  Freq: 0.998001
108 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
10c +   add R10, R9, R7	# ptr, #@addP_reg_reg
110 +   lb  R28, [R10]	# byte, #@loadB
114 +   bne  R28, R24, B39	#@cmpI_branch  P=0.001000 C=-1.000000

118     B14: #	out( B28 B15 ) &lt;- in( B41 B42 B39 B13 B12 B11 )  Freq: 1
118 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
118     lb  R7, [R23, #56]	# byte, #@loadB
11c +   bne  R7, zr, B28	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

120     B15: #	out( B18 B16 ) &lt;- in( B50 B30 B28 B14 )  Freq: 1
120 +   mv  R7, R21	# ptr -&gt; long, #@castP2X
124 +   mv  R28, R20	# ptr -&gt; long, #@castP2X
128 +   xorr  R28, R28, R7	#@xorL_reg_reg
12c +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
130 +   sw  R19, [R21, #24]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$Event.ioe
134 +   beq  R28, zr, B18	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

138     B16: #	out( B18 B17 ) &lt;- in( B15 )  Freq: 0.999
138 +   beq   R20, zr, B18	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

13c     B17: #	out( B43 B18 ) &lt;- in( B16 )  Freq: 0.998001
13c +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
140 +   add R10, R9, R7	# ptr, #@addP_reg_reg
144 +   lb  R28, [R10]	# byte, #@loadB
148 +   bne  R28, R24, B43	#@cmpI_branch  P=0.001000 C=-1.000000

14c     B18: #	out( N579 ) &lt;- in( B45 B46 B43 B17 B16 B15 )  Freq: 1
14c +   #@membar_release
	fence iorw ow
150 +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
168 +   ret	// return register, #@Ret

16c     B19: #	out( B3 B20 ) &lt;- in( B1 )  Freq: 0.000999987
16c +   lwu  R28, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.type
170 +   decode_heap_oop  R10, R28	#@decodeHeapOop
174     spill R11 -&gt; R21	# spill size = 64
178 +   beq   R10, zr, B3	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

17c     B20: #	out( B47 B21 ) &lt;- in( B19 )  Freq: 0.000499994
17c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
17c     ld  R7, [R23, #32]	# int, #@loadL
180 +   beq  R7, zr, B47	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

184     B21: #	out( B3 ) &lt;- in( B20 )  Freq: 0.000499494
184 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
184     ld  R28, [R23, #48]	# ptr, #@loadP
188 +   add R28, R28, R7	# ptr, #@addP_reg_reg
18c +   addi  R7, R7, #-8	#@addL_reg_imm
190 +   sd  R10, [R28, #-8]	# ptr, #@storeP
194 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
194     sd  R7, [R23, #32]	# long, #@storeL
198 +   j  B3	#@branch

19c     B22: #	out( B7 B23 ) &lt;- in( B6 )  Freq: 0.000999987
19c +   lwu  R28, [R21, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.file
1a0 +   decode_heap_oop  R10, R28	#@decodeHeapOop
1a4 +   beq   R10, zr, B7	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1a8     B23: #	out( B48 B24 ) &lt;- in( B22 )  Freq: 0.000499994
1a8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a8     ld  R7, [R23, #32]	# int, #@loadL
1ac +   beq  R7, zr, B48	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1b0     B24: #	out( B7 ) &lt;- in( B23 )  Freq: 0.000499494
1b0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b0     ld  R28, [R23, #48]	# ptr, #@loadP
1b4 +   add R28, R28, R7	# ptr, #@addP_reg_reg
1b8 +   addi  R7, R7, #-8	#@addL_reg_imm
1bc +   sd  R10, [R28, #-8]	# ptr, #@storeP
1c0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1c0     sd  R7, [R23, #32]	# long, #@storeL
1c4 +   j  B7	#@branch

1c8     B25: #	out( B11 B26 ) &lt;- in( B10 )  Freq: 0.000999987
1c8 +   lwu  R28, [R21, #20]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.attrs
1cc +   decode_heap_oop  R10, R28	#@decodeHeapOop
1d0 +   beq   R10, zr, B11	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1d4     B26: #	out( B49 B27 ) &lt;- in( B25 )  Freq: 0.000499994
1d4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1d4     ld  R7, [R23, #32]	# int, #@loadL
1d8 +   beq  R7, zr, B49	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1dc     B27: #	out( B11 ) &lt;- in( B26 )  Freq: 0.000499494
1dc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1dc     ld  R28, [R23, #48]	# ptr, #@loadP
1e0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
1e4 +   addi  R7, R7, #-8	#@addL_reg_imm
1e8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
1ec +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ec     sd  R7, [R23, #32]	# long, #@storeL
1f0 +   j  B11	#@branch

1f4     B28: #	out( B15 B29 ) &lt;- in( B14 )  Freq: 0.000999987
1f4 +   lwu  R28, [R21, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.ioe
1f8 +   decode_heap_oop  R10, R28	#@decodeHeapOop
1fc +   beq   R10, zr, B15	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

200     B29: #	out( B50 B30 ) &lt;- in( B28 )  Freq: 0.000499994
200 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
200     ld  R7, [R23, #32]	# int, #@loadL
204 +   beq  R7, zr, B50	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

208     B30: #	out( B15 ) &lt;- in( B29 )  Freq: 0.000499494
208 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
208     ld  R28, [R23, #48]	# ptr, #@loadP
20c +   add R28, R28, R7	# ptr, #@addP_reg_reg
210 +   addi  R7, R7, #-8	#@addL_reg_imm
214 +   sd  R10, [R28, #-8]	# ptr, #@storeP
218 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
218     sd  R7, [R23, #32]	# long, #@storeL
21c +   j  B15	#@branch

220     B31: #	out( B6 B32 ) &lt;- in( B5 )  Freq: 0.000998001
220 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
220     ld  R7, [R23, #64]	# int, #@loadL
224 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
224     ld  R28, [R23, #80]	# ptr, #@loadP
228 +   #@membar_volatile
	fence iorw iorw
22c +   lb  R29, [R10]	# byte, #@loadB
230 +   beq  R29, zr, B6	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

234     B32: #	out( B34 B33 ) &lt;- in( B31 )  Freq: 0.000499001
234 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
238 +   bne  R7, zr, B34	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

23c     B33: #	out( B6 ) &lt;- in( B32 )  Freq: 0.0002495
23c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
23c     spill R23 -&gt; R11	# spill size = 64
240 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
270 +   j  B6	#@branch

274     B34: #	out( B6 ) &lt;- in( B32 )  Freq: 0.0002495
274 +   add R28, R28, R7	# ptr, #@addP_reg_reg
278 +   addi  R7, R7, #-8	#@addL_reg_imm
27c +   sd  R10, [R28, #-8]	# ptr, #@storeP
280 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
280     sd  R7, [R23, #64]	# long, #@storeL
284 +   j  B6	#@branch

288     B35: #	out( B10 B36 ) &lt;- in( B9 )  Freq: 0.000998001
288 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
288     ld  R7, [R23, #64]	# int, #@loadL
28c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
28c     ld  R28, [R23, #80]	# ptr, #@loadP
290 +   #@membar_volatile
	fence iorw iorw
294 +   lb  R29, [R10]	# byte, #@loadB
298 +   beq  R29, zr, B10	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

29c     B36: #	out( B38 B37 ) &lt;- in( B35 )  Freq: 0.000499001
29c +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
2a0 +   bne  R7, zr, B38	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

2a4     B37: #	out( B10 ) &lt;- in( B36 )  Freq: 0.0002495
2a4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2a4     spill R23 -&gt; R11	# spill size = 64
2a8 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
2d8 +   j  B10	#@branch

2dc     B38: #	out( B10 ) &lt;- in( B36 )  Freq: 0.0002495
2dc +   add R28, R28, R7	# ptr, #@addP_reg_reg
2e0 +   addi  R7, R7, #-8	#@addL_reg_imm
2e4 +   sd  R10, [R28, #-8]	# ptr, #@storeP
2e8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2e8     sd  R7, [R23, #64]	# long, #@storeL
2ec +   j  B10	#@branch

2f0     B39: #	out( B14 B40 ) &lt;- in( B13 )  Freq: 0.000998001
2f0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2f0     ld  R7, [R23, #64]	# int, #@loadL
2f4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2f4     ld  R28, [R23, #80]	# ptr, #@loadP
2f8 +   #@membar_volatile
	fence iorw iorw
2fc +   lb  R29, [R10]	# byte, #@loadB
300 +   beq  R29, zr, B14	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

304     B40: #	out( B42 B41 ) &lt;- in( B39 )  Freq: 0.000499001
304 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
308 +   bne  R7, zr, B42	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

30c     B41: #	out( B14 ) &lt;- in( B40 )  Freq: 0.0002495
30c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
30c     spill R23 -&gt; R11	# spill size = 64
310 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
340 +   j  B14	#@branch

344     B42: #	out( B14 ) &lt;- in( B40 )  Freq: 0.0002495
344 +   add R28, R28, R7	# ptr, #@addP_reg_reg
348 +   addi  R7, R7, #-8	#@addL_reg_imm
34c +   sd  R10, [R28, #-8]	# ptr, #@storeP
350 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
350     sd  R7, [R23, #64]	# long, #@storeL
354 +   j  B14	#@branch

358     B43: #	out( B18 B44 ) &lt;- in( B17 )  Freq: 0.000998001
358 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
358     ld  R7, [R23, #64]	# int, #@loadL
35c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
35c     ld  R28, [R23, #80]	# ptr, #@loadP
360 +   #@membar_volatile
	fence iorw iorw
364 +   lb  R29, [R10]	# byte, #@loadB
368 +   beq  R29, zr, B18	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

36c     B44: #	out( B46 B45 ) &lt;- in( B43 )  Freq: 0.000499001
36c +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
370 +   bne  R7, zr, B46	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

374     B45: #	out( B18 ) &lt;- in( B44 )  Freq: 0.0002495
374 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
374     spill R23 -&gt; R11	# spill size = 64
378 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
3a8 +   j  B18	#@branch

3ac     B46: #	out( B18 ) &lt;- in( B44 )  Freq: 0.0002495
3ac +   add R28, R28, R7	# ptr, #@addP_reg_reg
3b0 +   addi  R7, R7, #-8	#@addL_reg_imm
3b4 +   sd  R10, [R28, #-8]	# ptr, #@storeP
3b8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3b8     sd  R7, [R23, #64]	# long, #@storeL
3bc +   j  B18	#@branch

3c0     B47: #	out( B3 ) &lt;- in( B20 )  Freq: 4.99987e-07
3c0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3c0     spill R23 -&gt; R11	# spill size = 64
3c4 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
3f4 +   j  B3	#@branch

3f8     B48: #	out( B7 ) &lt;- in( B23 )  Freq: 4.99987e-07
3f8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3f8     spill R23 -&gt; R11	# spill size = 64
3fc +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
42c +   j  B7	#@branch

430     B49: #	out( B11 ) &lt;- in( B26 )  Freq: 4.99987e-07
430 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
430     spill R23 -&gt; R11	# spill size = 64
434 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
464 +   j  B11	#@branch

468     B50: #	out( B15 ) &lt;- in( B29 )  Freq: 4.99987e-07
468 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
468     spill R23 -&gt; R11	# spill size = 64
46c +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
49c +   j  B15	#@branch

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='330'>
----------------------- MetaData before Compile_id = 330 ------------------------
{method}
 - this oop:          0x000000409600c560
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;replace&apos;
 - signature:         &apos;(CC)Ljava/lang/String;&apos;
 - max stack:         4
 - max locals:        4
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008317620: 0xbaa i2c: 0x0000004013945bc0 c2i: 0x0000004013945c0c c2iUV: 0x0000004013945bd8
 - compiled entry     0x000000400c4f7340
 - code size:         42
 - code start:        0x000000409600c4f8
 - code end (excl):   0x000000409600c522
 - method data:       0x00000040965ee6e8
 - checked ex length: 0
 - linenumber start:  0x000000409600c522
 - localvar length:   4
 - localvar start:    0x000000409600c52e
 - compiled code: nmethod  14216  137       3       java.lang.String::replace (42 bytes)

------------------------ OptoAssembly for Compile_id = 330 -----------------------
#
#  java/lang/String:exact * ( java/lang/String:NotNull:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N79: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B8 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
040 +   lb  R28, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
044     spill R11 -&gt; R8	# spill size = 64
048 +   beq  R12, R13, B8	#@cmpI_branch  P=0.000000 C=5375.000000

04c     B2: #	out( B7 B3 ) &lt;- in( B1 )  Freq: 1
04c +   bne  R28, zr, B7	#@cmpI_reg_imm0_branch  P=0.000000 C=65142.000000

050     B3: #	out( B9 B4 ) &lt;- in( B2 )  Freq: 0.999999
050 +   decode_heap_oop  R11, R7	#@decodeHeapOop
054     CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringLatin1::replace
        # java.lang.String::replace @ bci:18 (line 2801) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop off=88/0x58}

058     B4: #	out( B6 B5 ) &lt;- in( B3 )  Freq: 0.999979
        # Block is sole successor of call
058 +   beq   R10, zr, B6	#@cmpP_imm0_branch  P=0.000744 C=5375.000000

05c     B5: #	out( N79 ) &lt;- in( B4 B6 )  Freq: 0.999979
05c     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
074 +   ret	// return register, #@Ret

078     B6: #	out( B5 ) &lt;- in( B4 )  Freq: 0.000744148
078 +   spill R8 -&gt; R10	# spill size = 64
07c +   j  B5	#@branch

080     B7: #	out( N79 ) &lt;- in( B2 )  Freq: 5e-07
080 +   li R11, #-187	# int, #@loadConI
084     spill R12 -&gt; [sp, #0]	# spill size = 32
088 +   spill R13 -&gt; [sp, #4]	# spill size = 32
08c +   spill R28 -&gt; [sp, #8]	# spill size = 32
090     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #8
        # java.lang.String::replace @ bci:6 (line 2801) L[0]=R8 L[1]=sp + #0 L[2]=sp + #4 L[3]=_
        # OopMap {fp=Oop off=148/0x94}
094     #@ShouldNotReachHere

0a0     B8: #	out( N79 ) &lt;- in( B1 )  Freq: 4.76837e-07
0a0 +   li R11, #-187	# int, #@loadConI
0a4     spill R12 -&gt; [sp, #8]	# spill size = 32
0a8 +   spill R13 -&gt; [sp, #12]	# spill size = 32
0ac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:2 (line 2800) L[0]=R8 L[1]=sp + #8 L[2]=sp + #12 L[3]=_ STK[0]=sp + #8 STK[1]=sp + #12
        # OopMap {fp=Oop off=176/0xb0}
0b0     #@ShouldNotReachHere

0bc     B9: #	out( N79 ) &lt;- in( B3 )  Freq: 9.99999e-06
0bc      -- 	// exception oop; no code emitted, #@CreateException
0bc +   spill R10 -&gt; R11	# spill size = 64
0c0 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
0cc +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='331'>
----------------------- MetaData before Compile_id = 331 ------------------------
{method}
 - this oop:          0x0000004096550648
 - method holder:     &apos;java/nio/file/FileTreeIterator&apos;
 - constants:         0x000000409654fe20 constant pool [128] {0x000000409654fe20} for &apos;java/nio/file/FileTreeIterator&apos; cache=0x0000004096550a20
 - access:            0x81000001  public 
 - name:              &apos;hasNext&apos;
 - signature:         &apos;()Z&apos;
 - max stack:         3
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      5
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c520240
 - code size:         35
 - code start:        0x0000004096550608
 - code end (excl):   0x000000409655062b
 - method data:       0x0000004096490dd0
 - checked ex length: 0
 - linenumber start:  0x000000409655062b
 - localvar length:   1
 - localvar start:    0x000000409655063a
 - compiled code: nmethod  14249  220       3       java.nio.file.FileTreeIterator::hasNext (35 bytes)

------------------------ OptoAssembly for Compile_id = 331 -----------------------
#
#  bool ( java/nio/file/FileTreeIterator:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/nio/file/FileTreeIterator:NotNull *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N71: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B7 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.walker
040 +   spill R11 -&gt; R8	# spill size = 64
044 +   decode_heap_oop  R7, R7	#@decodeHeapOop
048     lbu  R7, [R7, #17]	# byte, #@loadUB ! Field: java/nio/file/FileTreeWalker.closed
04c     NullCheck R7

04c     B2: #	out( B5 B3 ) &lt;- in( B1 )  Freq: 0.999999
04c +   bne  R7, zr, B5	#@cmpI_reg_imm0_branch  P=0.000000 C=10746.000000

050     B3: #	out( B6 B4 ) &lt;- in( B2 )  Freq: 0.999999
050     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeIterator::fetchNextIfNeeded
        # java.nio.file.FileTreeIterator::hasNext @ bci:19 (line 103) L[0]=R8
        # OopMap {fp=Oop off=84/0x54}

054     B4: #	out( N71 ) &lt;- in( B3 )  Freq: 0.999978
        # Block is sole successor of call
054 +   lwu  R28, [R8, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.next
058 +   decode_heap_oop  R7, R28	#@decodeHeapOop
05c +   snez  R10, R7	#@convP2Bool
060     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
078 +   ret	// return register, #@Ret

07c     B5: #	out( N71 ) &lt;- in( B2 )  Freq: 4.99999e-07
07c +   li R11, #-187	# int, #@loadConI
080     spill R7 -&gt; [sp, #0]	# spill size = 32
084     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::isOpen @ bci:4 (line 412) L[0]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeIterator::hasNext @ bci:4 (line 101) L[0]=R8
        # OopMap {fp=Oop off=136/0x88}
088     #@ShouldNotReachHere

094     B6: #	out( N71 ) &lt;- in( B3 )  Freq: 9.99998e-06
094      -- 	// exception oop; no code emitted, #@CreateException
094 +   spill R10 -&gt; R11	# spill size = 64
098 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
0a4 +   j rethrow_stub	#@RethrowException

0ac     B7: #	out( N71 ) &lt;- in( B1 )  Freq: 1.01328e-06
0ac +   li R11, #-10	# int, #@loadConI
0b0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeIterator::hasNext @ bci:4 (line 101) L[0]=_ STK[0]=#NULL
        # OopMap {off=180/0xb4}
0b4 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='332'>
----------------------- MetaData before Compile_id = 332 ------------------------
{method}
 - this oop:          0x0000004096550738
 - method holder:     &apos;java/nio/file/FileTreeIterator&apos;
 - constants:         0x000000409654fe20 constant pool [128] {0x000000409654fe20} for &apos;java/nio/file/FileTreeIterator&apos; cache=0x0000004096550a20
 - access:            0x81000001  public 
 - name:              &apos;next&apos;
 - signature:         &apos;()Ljava/nio/file/FileTreeWalker$Event;&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      7
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c54c380
 - code size:         49
 - code start:        0x00000040965506e0
 - code end (excl):   0x0000004096550711
 - method data:       0x0000004096492330
 - checked ex length: 0
 - linenumber start:  0x0000004096550711
 - localvar length:   2
 - localvar start:    0x000000409655071e
 - compiled code: nmethod  14272  270       3       java.nio.file.FileTreeIterator::next (49 bytes)

------------------------ OptoAssembly for Compile_id = 332 -----------------------
#
#  java/nio/file/FileTreeWalker$Event * ( java/nio/file/FileTreeIterator:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/nio/file/FileTreeIterator:NotNull *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N133: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B14 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.walker
040 +   spill R11 -&gt; R8	# spill size = 64
044 +   decode_heap_oop  R7, R7	#@decodeHeapOop
048     lbu  R7, [R7, #17]	# byte, #@loadUB ! Field: java/nio/file/FileTreeWalker.closed
04c     NullCheck R7

04c     B2: #	out( B10 B3 ) &lt;- in( B1 )  Freq: 0.999999
04c +   bne  R7, zr, B10	#@cmpI_reg_imm0_branch  P=0.000000 C=10750.000000

050     B3: #	out( B13 B4 ) &lt;- in( B2 )  Freq: 0.999999
050     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeIterator::fetchNextIfNeeded
        # java.nio.file.FileTreeIterator::next @ bci:19 (line 111) L[0]=R8 L[1]=_
        # OopMap {fp=Oop off=84/0x54}

054     B4: #	out( B12 B5 ) &lt;- in( B3 )  Freq: 0.999978
        # Block is sole successor of call
054 +   lwu  R28, [R8, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.next
058 +   decode_heap_oop  R9, R28	#@decodeHeapOop
05c +   beq   R9, zr, B12	#@cmpP_imm0_branch  P=0.000000 C=5374.000000

060     B5: #	out( B7 B6 ) &lt;- in( B4 )  Freq: 0.999978
060 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
060     lb  R7, [R23, #56]	# byte, #@loadB
064 +   bne  R7, zr, B7	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

068     B6: #	out( N133 ) &lt;- in( B11 B9 B7 B5 )  Freq: 0.999978
068 +   sw  rheapbase, [R8, #16]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/nio/file/FileTreeIterator.next
06c     spill R9 -&gt; R10	# spill size = 64
070 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
088 +   ret	// return register, #@Ret

08c     B7: #	out( B6 B8 ) &lt;- in( B5 )  Freq: 0.000999965
08c +   lwu  R28, [R8, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.next
090 +   decode_heap_oop  R10, R28	#@decodeHeapOop
094 +   beq   R10, zr, B6	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

098     B8: #	out( B11 B9 ) &lt;- in( B7 )  Freq: 0.000499983
098 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
098     ld  R7, [R23, #32]	# int, #@loadL
09c +   beq  R7, zr, B11	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0a0     B9: #	out( B6 ) &lt;- in( B8 )  Freq: 0.000499483
0a0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0a0     ld  R28, [R23, #48]	# ptr, #@loadP
0a4 +   add R28, R28, R7	# ptr, #@addP_reg_reg
0a8 +   addi  R7, R7, #-8	#@addL_reg_imm
0ac +   sd  R10, [R28, #-8]	# ptr, #@storeP
0b0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0b0     sd  R7, [R23, #32]	# long, #@storeL
0b4 +   j  B6	#@branch

0b8     B10: #	out( N133 ) &lt;- in( B2 )  Freq: 4.99999e-07
0b8 +   li R11, #-187	# int, #@loadConI
0bc     spill R7 -&gt; [sp, #0]	# spill size = 32
0c0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::isOpen @ bci:4 (line 412) L[0]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeIterator::next @ bci:4 (line 109) L[0]=R8 L[1]=_
        # OopMap {fp=Oop off=196/0xc4}
0c4     #@ShouldNotReachHere

0d0     B11: #	out( B6 ) &lt;- in( B8 )  Freq: 4.99976e-07
0d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0d0     spill R23 -&gt; R11	# spill size = 64
0d4 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
104 +   j  B6	#@branch

108     B12: #	out( N133 ) &lt;- in( B4 )  Freq: 4.76827e-07
108 +   li R11, #-187	# int, #@loadConI
10c     spill R9 -&gt; [sp, #0]	# spill size = 64
110     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeIterator::next @ bci:26 (line 112) L[0]=R8 L[1]=_ STK[0]=sp + #0
        # OopMap {fp=Oop [0]=Oop off=276/0x114}
114     #@ShouldNotReachHere

120     B13: #	out( N133 ) &lt;- in( B3 )  Freq: 9.99998e-06
120      -- 	// exception oop; no code emitted, #@CreateException
120 +   spill R10 -&gt; R11	# spill size = 64
124 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
130 +   j rethrow_stub	#@RethrowException

138     B14: #	out( N133 ) &lt;- in( B1 )  Freq: 1.01328e-06
138 +   li R11, #-10	# int, #@loadConI
13c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeIterator::next @ bci:4 (line 109) L[0]=_ L[1]=_ STK[0]=#NULL
        # OopMap {off=320/0x140}
140     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='333'>
----------------------- MetaData before Compile_id = 333 ------------------------
{method}
 - this oop:          0x00000040965508a0
 - method holder:     &apos;java/nio/file/FileTreeIterator&apos;
 - constants:         0x000000409654fe20 constant pool [128] {0x000000409654fe20} for &apos;java/nio/file/FileTreeIterator&apos; cache=0x0000004096550a20
 - access:            0x81001041  public volatile synthetic 
 - name:              &apos;next&apos;
 - signature:         &apos;()Ljava/lang/Object;&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      6
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c524e80
 - code size:         5
 - code start:        0x0000004096550888
 - code end (excl):   0x000000409655088d
 - method data:       0x0000004096492180
 - checked ex length: 0
 - linenumber start:  0x000000409655088d
 - localvar length:   1
 - localvar start:    0x0000004096550892
 - compiled code: nmethod  14298  228       3       java.nio.file.FileTreeIterator::next (5 bytes)

------------------------ OptoAssembly for Compile_id = 333 -----------------------
#
#  java/lang/Object * ( java/nio/file/FileTreeIterator:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/nio/file/FileTreeIterator:NotNull *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N133: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B14 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.walker
040 +   spill R11 -&gt; R8	# spill size = 64
044 +   decode_heap_oop  R7, R7	#@decodeHeapOop
048     lbu  R7, [R7, #17]	# byte, #@loadUB ! Field: java/nio/file/FileTreeWalker.closed
04c     NullCheck R7

04c     B2: #	out( B10 B3 ) &lt;- in( B1 )  Freq: 0.999999
04c +   bne  R7, zr, B10	#@cmpI_reg_imm0_branch  P=0.000000 C=10751.000000

050     B3: #	out( B13 B4 ) &lt;- in( B2 )  Freq: 0.999999
050     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeIterator::fetchNextIfNeeded
        # java.nio.file.FileTreeIterator::next @ bci:19 (line 111) L[0]=R8 L[1]=_
        # java.nio.file.FileTreeIterator::next @ bci:1 (line 50) L[0]=_
        # OopMap {fp=Oop off=84/0x54}

054     B4: #	out( B12 B5 ) &lt;- in( B3 )  Freq: 0.999978
        # Block is sole successor of call
054 +   lwu  R28, [R8, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.next
058 +   decode_heap_oop  R9, R28	#@decodeHeapOop
05c +   beq   R9, zr, B12	#@cmpP_imm0_branch  P=0.000000 C=5375.000000

060     B5: #	out( B7 B6 ) &lt;- in( B4 )  Freq: 0.999978
060 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
060     lb  R7, [R23, #56]	# byte, #@loadB
064 +   bne  R7, zr, B7	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

068     B6: #	out( N133 ) &lt;- in( B11 B9 B7 B5 )  Freq: 0.999978
068 +   sw  rheapbase, [R8, #16]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/nio/file/FileTreeIterator.next
06c     spill R9 -&gt; R10	# spill size = 64
070 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
088 +   ret	// return register, #@Ret

08c     B7: #	out( B6 B8 ) &lt;- in( B5 )  Freq: 0.000999965
08c +   lwu  R28, [R8, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.next
090 +   decode_heap_oop  R10, R28	#@decodeHeapOop
094 +   beq   R10, zr, B6	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

098     B8: #	out( B11 B9 ) &lt;- in( B7 )  Freq: 0.000499983
098 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
098     ld  R7, [R23, #32]	# int, #@loadL
09c +   beq  R7, zr, B11	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0a0     B9: #	out( B6 ) &lt;- in( B8 )  Freq: 0.000499483
0a0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0a0     ld  R28, [R23, #48]	# ptr, #@loadP
0a4 +   add R28, R28, R7	# ptr, #@addP_reg_reg
0a8 +   addi  R7, R7, #-8	#@addL_reg_imm
0ac +   sd  R10, [R28, #-8]	# ptr, #@storeP
0b0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0b0     sd  R7, [R23, #32]	# long, #@storeL
0b4 +   j  B6	#@branch

0b8     B10: #	out( N133 ) &lt;- in( B2 )  Freq: 4.99999e-07
0b8 +   li R11, #-187	# int, #@loadConI
0bc     spill R7 -&gt; [sp, #0]	# spill size = 32
0c0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::isOpen @ bci:4 (line 412) L[0]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeIterator::next @ bci:4 (line 109) L[0]=R8 L[1]=_
        # java.nio.file.FileTreeIterator::next @ bci:1 (line 50) L[0]=_
        # OopMap {fp=Oop off=196/0xc4}
0c4     #@ShouldNotReachHere

0d0     B11: #	out( B6 ) &lt;- in( B8 )  Freq: 4.99976e-07
0d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0d0     spill R23 -&gt; R11	# spill size = 64
0d4 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
104 +   j  B6	#@branch

108     B12: #	out( N133 ) &lt;- in( B4 )  Freq: 4.76827e-07
108 +   li R11, #-187	# int, #@loadConI
10c     spill R9 -&gt; [sp, #0]	# spill size = 64
110     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeIterator::next @ bci:26 (line 112) L[0]=R8 L[1]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeIterator::next @ bci:1 (line 50) L[0]=_
        # OopMap {fp=Oop [0]=Oop off=276/0x114}
114     #@ShouldNotReachHere

120     B13: #	out( N133 ) &lt;- in( B3 )  Freq: 9.99998e-06
120      -- 	// exception oop; no code emitted, #@CreateException
120 +   spill R10 -&gt; R11	# spill size = 64
124 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
130 +   j rethrow_stub	#@RethrowException

138     B14: #	out( N133 ) &lt;- in( B1 )  Freq: 1.01328e-06
138 +   li R11, #-10	# int, #@loadConI
13c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeIterator::next @ bci:4 (line 109) L[0]=_ L[1]=_ STK[0]=#NULL
        # java.nio.file.FileTreeIterator::next @ bci:1 (line 50) L[0]=_
        # OopMap {off=320/0x140}
140     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='334'>
----------------------- MetaData before Compile_id = 334 ------------------------
{method}
 - this oop:          0x00000040965e6108
 - method holder:     &apos;java/util/stream/ReferencePipeline$2$1&apos;
 - constants:         0x00000040965e5c18 constant pool [69] {0x00000040965e5c18} for &apos;java/util/stream/ReferencePipeline$2$1&apos; cache=0x00000040965e61d8
 - access:            0x81000001  public 
 - name:              &apos;accept&apos;
 - signature:         &apos;(Ljava/lang/Object;)V&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      7
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bd00: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c525440
 - code size:         27
 - code start:        0x00000040965e60c8
 - code end (excl):   0x00000040965e60e3
 - method data:       0x0000004096492570
 - checked ex length: 0
 - linenumber start:  0x00000040965e60e3
 - localvar length:   2
 - localvar start:    0x00000040965e60ec
 - compiled code: nmethod  14449  229       3       java.util.stream.ReferencePipeline$2$1::accept (27 bytes)

------------------------ OptoAssembly for Compile_id = 334 -----------------------
#
#  void ( java/util/stream/ReferencePipeline$2$1:NotNull *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/stream/ReferencePipeline$2$1:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 112 --
#r263 sp+108: in_preserve
#r262 sp+104: return address
#r261 sp+100: in_preserve
#r260 sp+96: saved fp register
#r259 sp+92: pad2, stack alignment
#r258 sp+88: pad2, stack alignment
#r257 sp+84: Fixed slot 1
#r256 sp+80: Fixed slot 0
#r283 sp+76: spill
#r282 sp+72: spill
#r281 sp+68: spill
#r280 sp+64: spill
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N742: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B59 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=112
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #112
	
03c     lwu  R7, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$2$1.this$1
040 +   spill R12 -&gt; [sp, #8]	# spill size = 64
044 +   spill R11 -&gt; [sp, #0]	# spill size = 64
048 +   decode_heap_oop  R7, R7	#@decodeHeapOop
04c     lwu  R28, [R7, #52]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$2.val$predicate
050     NullCheck R7

050     B2: #	out( B60 B3 ) &lt;- in( B1 )  Freq: 0.999999
050 +   decode_heap_oop  R8, R28	#@decodeHeapOop
054     lwu  R7, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
058     NullCheck R8

058     B3: #	out( B43 B4 ) &lt;- in( B2 )  Freq: 0.999998
058 +   mv  R29, narrowklass: precise klass java/nio/file/Files$$Lambda$6+0x00000008000180e8: 0x00000040d012d690:Constant:exact *	# compressed klass ptr, #@loadConNKlass
068 +   bne  R7, R29, B43	#@cmpN_branch  P=0.000001 C=-1.000000

06c     B4: #	out( B61 B5 ) &lt;- in( B3 )  Freq: 0.999997
06c +   # checkcastPP of R8, #@checkCastPP
06c     lwu  R7, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/Files$$Lambda$6+0x00000008000180e8.arg$1 (constant)
070 +   decode_heap_oop  R30, R7	#@decodeHeapOop
074     lwu  R28, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
078     NullCheck R12

078     B5: #	out( B56 B6 ) &lt;- in( B4 )  Freq: 0.999996
078 +   mv  R7, narrowklass: precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d0132780:Constant:exact *	# compressed klass ptr, #@loadConNKlass
088 +   bne  R28, R7, B56	#@cmpN_branch  P=0.000000 C=-1.000000

08c     B6: #	out( B62 B7 ) &lt;- in( B5 )  Freq: 0.999996
08c +   spill R12 -&gt; R7	# spill size = 64
090 +   # checkcastPP of R7, #@checkCastPP
090     lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.file
094     spill R7 -&gt; [sp, #48]	# spill size = 64
098 +   lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.attrs
09c +   decode_heap_oop  R31, R28	#@decodeHeapOop
0a0 +   decode_heap_oop  R7, R7	#@decodeHeapOop
0a4     lwu  R28, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0a8     NullCheck R30

0a8     B7: #	out( B44 B8 ) &lt;- in( B6 )  Freq: 0.999995
0a8 +   mv  R29, narrowklass: precise klass jdk/internal/module/ModulePath$$Lambda$4+0x000000080003fd28: 0x00000040d04f5470:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0b8 +   bne  R28, R29, B44	#@cmpN_branch  P=0.000001 C=-1.000000

0bc     B8: #	out( B63 B9 ) &lt;- in( B7 )  Freq: 0.999994
0bc +   # checkcastPP of R30, #@checkCastPP
0bc     lwu  R29, [R30, #12]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/module/ModulePath$$Lambda$4+0x000000080003fd28.arg$1 (constant)
0c0 +   decode_heap_oop  R29, R29	#@decodeHeapOop
0c4     lwu  R28, [R31, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0c8     NullCheck R31

0c8     B9: #	out( B57 B10 ) &lt;- in( B8 )  Freq: 0.999993
0c8 +   mv  R30, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d04f91d0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0d8 +   bne  R28, R30, B57	#@cmpN_branch  P=0.000000 C=-1.000000

0dc     B10: #	out( B64 B11 ) &lt;- in( B9 )  Freq: 0.999993
0dc +   # checkcastPP of R31, #@checkCastPP
0dc     spill R31 -&gt; [sp, #16]	# spill size = 64
0e0     lwu  R28, [R7, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0e4     NullCheck R7

0e4     B11: #	out( B58 B12 ) &lt;- in( B10 )  Freq: 0.999992
0e4 +   mv  R30, narrowklass: precise klass sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes: 0x00000040d04f92a0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0f4 +   bne  R28, R30, B58	#@cmpN_branch  P=0.000000 C=-1.000000

0f8     B12: #	out( B42 B13 ) &lt;- in( B11 )  Freq: 0.999992
0f8 +   # checkcastPP of R7, #@checkCastPP
0f8     lwu  R28, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes.attrs
0fc +   decode_heap_oop  R28, R28	#@decodeHeapOop
100 +   beq   R29, zr, B42	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

104     B13: #	out( B65 B14 ) &lt;- in( B12 )  Freq: 0.999991
104     lw  R28, [R28, #12]	# int, #@loadI ! Field: sun/nio/fs/UnixFileAttributes.st_mode
108     NullCheck R28

108     B14: #	out( B39 B15 ) &lt;- in( B13 )  Freq: 0.99999
108 +   li R7, #61440	# int, #@loadConI
10c +   andr  R28, R28, R7	#@andI_reg_reg
110 +   li R7, #32768	# int, #@loadConI
114 +   bne  R28, R7, B39	#@cmpI_branch  P=0.030140 C=5375.000000

118     B15: #	out( B66 B16 ) &lt;- in( B14 )  Freq: 0.969851
118 +   lwu  R28, [R31, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
11c +   mv  R7, java/lang/Class:exact *	# ptr, #@loadConP
134 +   lw  R8, [R7, #156]	# int, #@loadI ! Field: java/lang/System.allowSecurityManager (constant)
138 +   decode_heap_oop  R28, R28	#@decodeHeapOop
13c     lwu  R28, [R28, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileSystem.provider
140     NullCheck R28

140     B16: #	out( B45 B17 ) &lt;- in( B15 )  Freq: 0.96985
140 +   beq   R28, zr, B45	#@cmpP_narrowOop_imm0_branch  P=0.000001 C=-1.000000

144     B17: #	out( B50 B18 ) &lt;- in( B16 )  Freq: 0.969849
144 +   li R28, #1	# int, #@loadConI
148 +   beq  R8, R28, B50	#@cmpI_branch  P=0.000000 C=8384.000000

14c     B18: #	out( B51 B19 ) &lt;- in( B17 )  Freq: 0.969848
14c +   lwu  R28, [R7, #124]	# loadN, compressed ptr, #@loadN ! Field: volatile java/lang/System.security
150 +   #@membar_acquire
	fence ir iorw
154 +   decode_heap_oop  R8, R28	#@decodeHeapOop
158 +   bne   R8, zr, B51	#@cmpP_imm0_branch  P=0.000000 C=8201.000000

15c     B19: #	out( B72 B20 ) &lt;- in( B18 )  Freq: 0.969848
15c +   spill R31 -&gt; R11	# spill size = 64
160     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getFileName @ bci:1 (line 255) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [48]=Oop off=356/0x164}

164     B20: #	out( B68 B21 ) &lt;- in( B19 )  Freq: 0.969828
        # Block is sole successor of call
164 +   spill [sp, #16] -&gt; R7	# spill size = 64
168 +   lwu  R7, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
16c +   #@membar_acquire
	fence ir iorw
170 +   decode_heap_oop  R7, R7	#@decodeHeapOop
174     lwu  R28, [R7, #12]	# range, #@loadRange
178     NullCheck R7

178     B21: #	out( B52 B22 ) &lt;- in( B20 )  Freq: 0.969827
178 +   bleu  R28, zr, B52	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=5192.000000

17c     B22: #	out( B53 B23 ) &lt;- in( B21 )  Freq: 0.969827
17c +   li R29, #1	# int, #@loadConI
180 +   beq  R28, R29, B53	#@cmpI_branch  P=0.000000 C=5192.000000

184     B23: #	out( B69 B24 ) &lt;- in( B22 )  Freq: 0.969826
184 +   spill [sp, #16] -&gt; R7	# spill size = 64
188 +   lwu  R29, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
18c +   #@membar_acquire
	fence ir iorw
190 +   decode_heap_oop  R31, R29	#@decodeHeapOop
194 +   addw  R30, R28, zr	#@convI2L_reg_reg
198 +   lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
19c +   slli  R29, R30, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
1a0 +   addiw  R8, R28, #-1	#@addI_reg_imm
1a4     lwu  R30, [R31, #12]	# range, #@loadRange
1a8     NullCheck R31

1a8     B24: #	out( B46 B25 ) &lt;- in( B23 )  Freq: 0.969825
1a8 +   add R28, R31, R29	# ptr, #@addP_reg_reg
1ac +   decode_heap_oop  R29, R7	#@decodeHeapOop
1b0 +   bgeu  R8, R30, B46	#@cmpU_branch  P=0.000001 C=-1.000000

1b4     B25: #	out( B70 B26 ) &lt;- in( B24 )  Freq: 0.969824
1b4     lwu  R19, [R29, #12]	# range, #@loadRange
1b8     NullCheck R29

1b8     B26: #	out( B47 B27 ) &lt;- in( B25 )  Freq: 0.969823
1b8 +   lw  R8, [R28, #12]	# int, #@loadI
1bc +   subw  R18, R19, R8	#@subI_reg_reg
1c0 +   li R7, #1048576	# int, #@loadConI
1c4 +   addw  R30, R8, zr	#@convI2L_reg_reg
1c8 +   addw  R12, R18, zr	#@convI2L_reg_reg
1cc +   bgtu  R18, R7, B47	#@cmpU_branch  P=0.000001 C=-1.000000

1d0     B27: #	out( B28 ) &lt;- in( B26 )  Freq: 0.969822
1d0 +   addw  R28, R19, zr	#@convI2L_reg_reg
1d4 +   sub  R28, R28, R30	#@subL_reg_reg

1d8     B28: #	out( B49 B29 ) &lt;- in( B27 B47 )  Freq: 0.969823
1d8 +   blt  R8, zr, B49	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

1dc     B29: #	out( B40 B30 ) &lt;- in( B28 )  Freq: 0.969822
1dc +   bgtu  R18, R7, B40	#@cmpU_branch  P=0.000001 C=-1.000000

1e0     B30: #	out( B40 B31 ) &lt;- in( B29 )  Freq: 0.969821
1e0 +   addi  R7, R28, #23	#@addL_reg_imm
1e4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1e4     ld  R9, [R23, #288]	# ptr, #@loadP
1e8 +   andi  R7, R7, #-8	#@andL_reg_imm
1ec +   ld  R28, [R23, #304]	# ptr, #@loadP
1f0 +   add R7, R9, R7	# ptr, #@addP_reg_reg
1f4 +   bgeu  R7, R28, B40	#@cmpP_branch  P=0.000100 C=-1.000000

1f8     B31: #	out( B32 ) &lt;- in( B30 )  Freq: 0.969724
1f8 +   sd  R7, [R23, #288]	# ptr, #@storeP
1fc +   li R7, #1	# long, #@loadConL
200 +   sd  R7, [R9]	# long, #@storeL
204 +   mv  R7, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
214 +   sw  R7, [R9, #8]	# compressed klass ptr, #@storeNKlass
218 +   sw  R18, [R9, #12]	# int, #@storeI

21c     B32: #	out( B34 B33 ) &lt;- in( B41 B31 )  Freq: 0.969822
21c     
21c +   # checkcastPP of R9, #@checkCastPP
21c     addi  R20, R9, #16	# ptr, #@addP_reg_imm
220 +   beq  R19, R8, B34	#@cmpI_branch  P=0.000001 C=-1.000000

224     B33: #	out( B34 ) &lt;- in( B32 )  Freq: 0.969821
224 +   add R7, R29, R30	# ptr, #@addP_reg_reg
228     spill R20 -&gt; R11	# spill size = 64
22c +   addi  R10, R7, #16	# ptr, #@addP_reg_imm
230 +   CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

234     B34: #	out( B54 B35 ) &lt;- in( B33 B32 )  Freq: 0.969822
234     
234     beq  R19, R8, B54	#@cmpI_branch  P=0.000000 C=12920.000000

238     B35: #	out( B55 B36 ) &lt;- in( B34 )  Freq: 0.969822
238 +   lb  R8, [R20]	# byte, #@loadB
23c +   li R7, #46	# int, #@loadConI
240 +   beq  R8, R7, B55	#@cmpI_branch  P=0.000000 C=5192.000000

244     B36: #	out( B67 B37 ) &lt;- in( B35 B73 )  Freq: 0.96983
244 +   spill [sp, #0] -&gt; R7	# spill size = 64
248 +   lwu  R7, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/Sink$ChainedReference.downstream
24c +   decode_heap_oop  R29, R7	#@decodeHeapOop
250     lwu  R28, [R29, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
254     NullCheck R29

254     B37: #	out( B48 B38 ) &lt;- in( B36 )  Freq: 0.969829
254 +   mv  R7, narrowklass: precise klass java/util/stream/ReferencePipeline$3$1: 0x00000040d012d760:Constant:exact *	# compressed klass ptr, #@loadConNKlass
264 +   bne  R28, R7, B48	#@cmpN_branch  P=0.000001 C=-1.000000

268     B38: #	out( B75 B39 ) &lt;- in( B37 )  Freq: 0.969828
268 +   # checkcastPP of R29, #@checkCastPP
268     spill R29 -&gt; R11	# spill size = 64
26c +   spill [sp, #48] -&gt; R12	# spill size = 64
270     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.stream.ReferencePipeline$3$1::accept
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:21 (line 179) L[0]=_ L[1]=_
        # OopMap {off=628/0x274}

274     B39: #	out( N742 ) &lt;- in( B38 B14 )  Freq: 0.999948
274     # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
28c +   ret	// return register, #@Ret

290     B40: #	out( B71 B41 ) &lt;- in( B29 B30 )  Freq: 9.79809e-05
290 +   spill R12 -&gt; [sp, #40]	# spill size = 64
294 +   spill R30 -&gt; [sp, #64]	# spill size = 64
298 +   spill R29 -&gt; [sp, #56]	# spill size = 64
29c +   spill R18 -&gt; [sp, #36]	# spill size = 32
2a0 +   spill R19 -&gt; [sp, #32]	# spill size = 32
2a4 +   spill [sp, #16] -&gt; [sp, #24]	# spill size = 64
2ac +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
2c4     spill R18 -&gt; R12	# spill size = 32
2c8     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getFileName @ bci:60 (line 269) L[0]=sp + #24 L[1]=_ L[2]=R8 L[3]=sp + #36 L[4]=_
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [24]=Oop [48]=Oop [56]=Oop off=716/0x2cc}

2cc     B41: #	out( B32 ) &lt;- in( B40 )  Freq: 9.7979e-05
        # Block is sole successor of call
2cc +   spill [sp, #24] -&gt; [sp, #16]	# spill size = 64
2d4 +   spill [sp, #32] -&gt; R19	# spill size = 32
2d8 +   spill [sp, #36] -&gt; R18	# spill size = 32
2dc +   spill [sp, #40] -&gt; R12	# spill size = 64
2e0 +   spill R10 -&gt; R9	# spill size = 64
2e4 +   spill [sp, #56] -&gt; R29	# spill size = 64
2e8 +   spill [sp, #64] -&gt; R30	# spill size = 64
2ec +   j  B32	#@branch

2f0     B42: #	out( N742 ) &lt;- in( B12 )  Freq: 1.01327e-06
2f0 +   li R11, #-10	# int, #@loadConI
2f4     spill R31 -&gt; R8	# spill size = 64
2f8 +   spill R7 -&gt; [sp, #0]	# spill size = 64
2fc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL STK[1]=R8 STK[2]=sp + #0
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=768/0x300}
300     #@ShouldNotReachHere

30c     B43: #	out( N742 ) &lt;- in( B3 )  Freq: 9.99998e-07
30c +   li R11, #-34	# int, #@loadConI
310     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8 STK[0]=R8 STK[1]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=788/0x314}
314     #@ShouldNotReachHere

320     B44: #	out( N742 ) &lt;- in( B7 )  Freq: 9.99995e-07
320 +   spill [sp, #0] -&gt; R8	# spill size = 64
324 +   li R11, #-34	# int, #@loadConI
328     spill R12 -&gt; [sp, #0]	# spill size = 64
32c +   spill R30 -&gt; [sp, #8]	# spill size = 64
330 +   spill R31 -&gt; [sp, #16]	# spill size = 64
334 +   spill R7 -&gt; [sp, #24]	# spill size = 64
338     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_ STK[0]=sp + #8 STK[1]=sp + #16 STK[2]=sp + #24
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=828/0x33c}
33c     #@ShouldNotReachHere

348     B45: #	out( N742 ) &lt;- in( B16 )  Freq: 9.82728e-07
348 +   spill [sp, #0] -&gt; R8	# spill size = 64
34c +   li R11, #-10	# int, #@loadConI
350     spill R12 -&gt; [sp, #0]	# spill size = 64
354     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_ STK[0]=#NULL STK[1]=sp + #16
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=856/0x358}
358     #@ShouldNotReachHere

364     B46: #	out( N742 ) &lt;- in( B24 )  Freq: 9.82704e-07
364 +   li R11, #-28	# int, #@loadConI
368     spill R31 -&gt; [sp, #24]	# spill size = 64
36c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:49 (line 267) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #24 STK[1]=R8
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop off=880/0x370}
370     #@ShouldNotReachHere

37c     B47: #	out( B28 ) &lt;- in( B26 )  Freq: 9.82702e-07
37c +   spill R12 -&gt; R28	# spill size = 64
380 +   j  B28	#@branch

384     B48: #	out( N742 ) &lt;- in( B37 )  Freq: 9.69829e-07
384 +   li R11, #-34	# int, #@loadConI
388     spill R29 -&gt; R8	# spill size = 64
38c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:21 (line 179) L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #48
        # OopMap {fp=Oop [48]=Oop off=912/0x390}
390     #@ShouldNotReachHere

39c     B49: #	out( N742 ) &lt;- in( B28 )  Freq: 9.69823e-07
39c +   li R11, #-52	# int, #@loadConI
3a0     spill R18 -&gt; [sp, #28]	# spill size = 32
3a4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:60 (line 269) L[0]=sp + #16 L[1]=_ L[2]=R8 L[3]=sp + #28 L[4]=_ STK[0]=sp + #28
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=936/0x3a8}
3a8     #@ShouldNotReachHere

3b4     B50: #	out( N742 ) &lt;- in( B17 )  Freq: 4.6246e-07
3b4 +   li R11, #-187	# int, #@loadConI
3b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.System::allowSecurityManager @ bci:4 (line 193) STK[0]=R8 STK[1]=#1
        # java.lang.System::getSecurityManager @ bci:0 (line 483)
        # sun.nio.fs.UnixPath::checkRead @ bci:0 (line 778) L[0]=sp + #16 L[1]=_
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:6 (line 352) L[0]=_ L[1]=_ L[2]=sp + #16 L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=956/0x3bc}
3bc     #@ShouldNotReachHere

3c8     B51: #	out( N742 ) &lt;- in( B18 )  Freq: 4.6246e-07
3c8 +   li R11, #-187	# int, #@loadConI
3cc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::checkRead @ bci:5 (line 779) L[0]=sp + #16 L[1]=R8 STK[0]=R8
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:6 (line 352) L[0]=_ L[1]=_ L[2]=sp + #16 L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=976/0x3d0}
3d0     #@ShouldNotReachHere

3dc     B52: #	out( N742 ) &lt;- in( B21 )  Freq: 4.6245e-07
3dc +   spill [sp, #0] -&gt; R8	# spill size = 64
3e0 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
3e8 +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
3f0 +   li R11, #-187	# int, #@loadConI
3f4     spill R28 -&gt; [sp, #20]	# spill size = 32
3f8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:11 (line 260) L[0]=sp + #8 L[1]=sp + #20 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #20
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=1020/0x3fc}
3fc     #@ShouldNotReachHere

408     B53: #	out( N742 ) &lt;- in( B22 )  Freq: 4.62449e-07
408 +   spill [sp, #0] -&gt; R8	# spill size = 64
40c +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
414 +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
41c +   li R11, #-187	# int, #@loadConI
420     spill R28 -&gt; [sp, #20]	# spill size = 32
424     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:18 (line 264) L[0]=sp + #8 L[1]=sp + #20 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #20 STK[1]=#1
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=1064/0x428}
428     #@ShouldNotReachHere

434     B54: #	out( N742 ) &lt;- in( B34 )  Freq: 4.62447e-07
434 +   spill [sp, #16] -&gt; R7	# spill size = 64
438 +   lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
43c +   decode_heap_oop  R8, R7	#@decodeHeapOop
440 +   li R11, #-187	# int, #@loadConI
444     spill R18 -&gt; [sp, #16]	# spill size = 32
448 +   spill R9 -&gt; [sp, #24]	# spill size = 64
44c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::isEmpty @ bci:5 (line 216) L[0]=_ STK[0]=sp + #16
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:21 (line 358) L[0]=_ L[1]=_ L[2]=_ L[3]=#ScObj0 L[4]=_
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=R8, [path :2]=sp + #24, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop off=1104/0x450}
450     #@ShouldNotReachHere

45c     B55: #	out( N742 ) &lt;- in( B35 )  Freq: 4.62447e-07
45c +   li R11, #-187	# int, #@loadConI
460     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:51 (line 363) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=R8 STK[1]=#46
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop off=1124/0x464}
464     #@ShouldNotReachHere

470     B56: #	out( N742 ) &lt;- in( B5 )  Freq: 1e-35
470 +   li R11, #-34	# int, #@loadConI
474     spill [sp, #0] -&gt; R8	# spill size = 64
478 +   spill R30 -&gt; [sp, #16]	# spill size = 64
47c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:5 L[0]=_ L[1]=_ STK[0]=sp + #16 STK[1]=sp + #8
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=1152/0x480}
480     #@ShouldNotReachHere

48c     B57: #	out( N742 ) &lt;- in( B9 )  Freq: 1e-35
48c +   spill [sp, #0] -&gt; R8	# spill size = 64
490 +   li R11, #-34	# int, #@loadConI
494     spill R12 -&gt; [sp, #0]	# spill size = 64
498 +   spill R7 -&gt; [sp, #8]	# spill size = 64
49c +   spill R29 -&gt; [sp, #16]	# spill size = 64
4a0 +   spill R31 -&gt; [sp, #24]	# spill size = 64
4a4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:5 L[0]=_ L[1]=_ L[2]=sp + #8 STK[0]=sp + #16 STK[1]=sp + #24
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=1192/0x4a8}
4a8     #@ShouldNotReachHere

4b4     B58: #	out( N742 ) &lt;- in( B11 )  Freq: 1e-35
4b4 +   spill [sp, #0] -&gt; R8	# spill size = 64
4b8 +   li R11, #-34	# int, #@loadConI
4bc     spill R12 -&gt; [sp, #0]	# spill size = 64
4c0 +   spill R29 -&gt; [sp, #8]	# spill size = 64
4c4 +   spill R7 -&gt; [sp, #24]	# spill size = 64
4c8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:9 L[0]=_ L[1]=_ L[2]=_ STK[0]=sp + #8 STK[1]=sp + #16 STK[2]=sp + #24
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=1228/0x4cc}
4cc     #@ShouldNotReachHere

4d8     B59: #	out( N742 ) &lt;- in( B1 )  Freq: 1.01328e-06
4d8 +   li R11, #-10	# int, #@loadConI
4dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:4 (line 178) L[0]=_ L[1]=_ STK[0]=#NULL
        # OopMap {off=1248/0x4e0}
4e0     #@ShouldNotReachHere

4ec     B60: #	out( N742 ) &lt;- in( B2 )  Freq: 1.01328e-06
4ec +   li R11, #-10	# int, #@loadConI
4f0     spill R12 -&gt; R8	# spill size = 64
4f4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8
        # OopMap {fp=Oop off=1272/0x4f8}
4f8     #@ShouldNotReachHere

504     B61: #	out( N742 ) &lt;- in( B4 )  Freq: 1.01328e-06
504 +   spill [sp, #0] -&gt; R8	# spill size = 64
508 +   li R11, #-12	# int, #@loadConI
50c     spill R12 -&gt; [sp, #0]	# spill size = 64
510 +   spill R30 -&gt; [sp, #8]	# spill size = 64
514     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:5 L[0]=_ L[1]=_ STK[0]=sp + #8 STK[1]=#NULL
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=1304/0x518}
518     #@ShouldNotReachHere

524     B62: #	out( N742 ) &lt;- in( B6 )  Freq: 1.01327e-06
524 +   li R11, #-10	# int, #@loadConI
528     spill R31 -&gt; R8	# spill size = 64
52c +   spill R7 -&gt; [sp, #0]	# spill size = 64
530     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8 STK[2]=sp + #0
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=1332/0x534}
534     #@ShouldNotReachHere

540     B63: #	out( N742 ) &lt;- in( B8 )  Freq: 1.01327e-06
540 +   spill [sp, #0] -&gt; R8	# spill size = 64
544 +   li R11, #-12	# int, #@loadConI
548     spill R12 -&gt; [sp, #0]	# spill size = 64
54c +   spill R7 -&gt; [sp, #8]	# spill size = 64
550 +   spill R29 -&gt; [sp, #16]	# spill size = 64
554     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:5 L[0]=_ L[1]=_ L[2]=sp + #8 STK[0]=sp + #16 STK[1]=#NULL
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=1368/0x558}
558     #@ShouldNotReachHere

564     B64: #	out( N742 ) &lt;- in( B10 )  Freq: 1.01327e-06
564 +   spill [sp, #0] -&gt; R8	# spill size = 64
568 +   li R11, #-12	# int, #@loadConI
56c     spill R12 -&gt; [sp, #0]	# spill size = 64
570 +   spill R29 -&gt; [sp, #8]	# spill size = 64
574     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:9 L[0]=_ L[1]=_ L[2]=_ STK[0]=sp + #8 STK[1]=sp + #16 STK[2]=#NULL
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=1400/0x578}
578     #@ShouldNotReachHere

584     B65: #	out( N742 ) &lt;- in( B13 )  Freq: 1.01327e-06
584 +   li R11, #-10	# int, #@loadConI
588     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes::isRegularFile @ bci:4 (line 295) L[0]=_ STK[0]=#NULL
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:1 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=_ L[1]=_
        # OopMap {off=1420/0x58c}
58c     #@ShouldNotReachHere

598     B66: #	out( N742 ) &lt;- in( B15 )  Freq: 9.82729e-07
598 +   li R11, #-10	# int, #@loadConI
59c     spill [sp, #0] -&gt; R8	# spill size = 64
5a0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::provider @ bci:6 (line 105) L[0]=_ STK[0]=#NULL
        # java.nio.file.Files::isHidden @ bci:1 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=1444/0x5a4}
5a4     #@ShouldNotReachHere

5b0     B67: #	out( N742 ) &lt;- in( B36 )  Freq: 9.82709e-07
5b0 +   li R11, #-10	# int, #@loadConI
5b4     spill [sp, #48] -&gt; R8	# spill size = 64
5b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:21 (line 179) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8
        # OopMap {fp=Oop off=1468/0x5bc}
5bc     #@ShouldNotReachHere

5c8     B68: #	out( N742 ) &lt;- in( B20 )  Freq: 9.82707e-07
5c8 +   li R11, #-10	# int, #@loadConI
5cc     spill [sp, #0] -&gt; R8	# spill size = 64
5d0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:8 (line 257) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=1492/0x5d4}
5d4     #@ShouldNotReachHere

5e0     B69: #	out( N742 ) &lt;- in( B23 )  Freq: 9.82705e-07
5e0 +   li R11, #-10	# int, #@loadConI
5e4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:49 (line 267) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop off=1512/0x5e8}
5e8     #@ShouldNotReachHere

5f4     B70: #	out( N742 ) &lt;- in( B25 )  Freq: 9.82703e-07
5f4 +   li R11, #-10	# int, #@loadConI
5f8     spill [sp, #0] -&gt; R8	# spill size = 64
5fc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:55 (line 268) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=1536/0x600}
600     #@ShouldNotReachHere

60c     B71: #	out( B73 ) &lt;- in( B40 )  Freq: 9.79809e-10
60c      -- 	// exception oop; no code emitted, #@CreateException
60c +   lwu  R7, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
610 +   j  B73	#@branch

614     B72: #	out( B73 ) &lt;- in( B19 )  Freq: 9.69848e-06
614      -- 	// exception oop; no code emitted, #@CreateException
614 +   lwu  R7, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass

618     B73: #	out( B36 B74 ) &lt;- in( B72 B71 )  Freq: 9.69946e-06
618 +   mv  R29, narrowklass: precise klass java/io/IOException: 0x00000040d81cda30:Constant:exact *	# compressed klass ptr, #@loadConNKlass
628 +   beq  R7, R29, B36	#@cmpN_branch  P=0.900000 C=-1.000000

62c     B74: #	out( B76 ) &lt;- in( B73 )  Freq: 9.69946e-07
62c +   spill R10 -&gt; R11	# spill size = 64
630 +   j  B76	#@branch

634     B75: #	out( B76 ) &lt;- in( B38 )  Freq: 9.69828e-06
634      -- 	// exception oop; no code emitted, #@CreateException
634 +   spill R10 -&gt; R11	# spill size = 64

638     B76: #	out( N742 ) &lt;- in( B74 B75 )  Freq: 1.06682e-05
638     # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
644 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='335'>
----------------------- MetaData before Compile_id = 335 ------------------------
{method}
 - this oop:          0x00000040963fae58
 - method holder:     &apos;sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes&apos;
 - constants:         0x00000040963fa698 constant pool [66] {0x00000040963fa698} for &apos;sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes&apos; cache=0x00000040963fb270
 - access:            0x81000001  public 
 - name:              &apos;isRegularFile&apos;
 - signature:         &apos;()Z&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      6
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c527080
 - code size:         8
 - code start:        0x00000040963fae38
 - code end (excl):   0x00000040963fae40
 - method data:       0x0000004096493660
 - checked ex length: 0
 - linenumber start:  0x00000040963fae40
 - localvar length:   1
 - localvar start:    0x00000040963fae4a
 - compiled code: nmethod  14495  230       3       sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes::isRegularFile (8 bytes)

------------------------ OptoAssembly for Compile_id = 335 -----------------------
#
#  bool ( sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes:NotNull *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N44: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B6 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     lwu  R28, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes.attrs
040 +   decode_heap_oop  R7, R28	#@decodeHeapOop
044     lw  R7, [R7, #12]	# int, #@loadI ! Field: sun/nio/fs/UnixFileAttributes.st_mode
048     NullCheck R7

048     B2: #	out( B5 B3 ) &lt;- in( B1 )  Freq: 0.999999
048 +   li R29, #61440	# int, #@loadConI
04c +   andr  R7, R7, R29	#@andI_reg_reg
050 +   li R29, #32768	# int, #@loadConI
054 +   bne  R7, R29, B5	#@cmpI_branch  P=0.030140 C=5375.000000

058     B3: #	out( B4 ) &lt;- in( B2 )  Freq: 0.969859
058 +   li R10, #1	# int, #@loadConI

05c     B4: #	out( N44 ) &lt;- in( B5 B3 )  Freq: 0.999999
05c     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
074 +   ret	// return register, #@Ret

078     B5: #	out( B4 ) &lt;- in( B2 )  Freq: 0.0301395
078 +   li R10, #0	# int, #@loadConI
07c +   j  B4	#@branch

080     B6: #	out( N44 ) &lt;- in( B1 )  Freq: 1.01328e-06
080 +   li R11, #-10	# int, #@loadConI
084     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes::isRegularFile @ bci:4 (line 295) L[0]=_ STK[0]=#NULL
        # OopMap {off=136/0x88}
088 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='336'>
----------------------- MetaData before Compile_id = 336 ------------------------
{method}
 - this oop:          0x000000409600ffc0
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000008  static 
 - name:              &apos;checkBoundsOffCount&apos;
 - signature:         &apos;(III)V&apos;
 - max stack:         5
 - max locals:        3
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008318820: 0xaaa i2c: 0x0000004013943c40 c2i: 0x0000004013943c8c c2iUV: 0x0000004013943c58
 - compiled entry     0x000000400c510cc0
 - code size:         64
 - code start:        0x000000409600ff50
 - code end (excl):   0x000000409600ff90
 - method data:       0x000000409648c348
 - checked ex length: 0
 - linenumber start:  0x000000409600ff90
 - localvar length:   3
 - localvar start:    0x000000409600ff9a
 - compiled code: nmethod  14507  203       3       java.lang.String::checkBoundsOffCount (64 bytes)

------------------------ OptoAssembly for Compile_id = 336 -----------------------
#
#  void ( int, int, int )
#
#r012 c_rarg1   : parm 0: int
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B5 B6 B7 B4 )  Freq: 1

000     B1: #	out( B5 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     subw  R28, R13, R12	#@subI_reg_reg
020 +   blt  R11, zr, B5	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

024     B2: #	out( B6 B3 ) &lt;- in( B1 )  Freq: 1
024 +   blt  R12, zr, B6	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

028     B3: #	out( B7 B4 ) &lt;- in( B2 )  Freq: 0.999999
028 +   bgt  R11, R28, B7	#@cmpI_branch  P=0.000000 C=5375.000000

02c     B4: #	out( N1 ) &lt;- in( B3 )  Freq: 0.999999
02c     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
044 +   ret	// return register, #@Ret

048     B5: #	out( N1 ) &lt;- in( B1 )  Freq: 5e-07
048 +   spill R11 -&gt; [sp, #8]	# spill size = 32
04c +   spill R12 -&gt; [sp, #0]	# spill size = 32
050 +   spill R13 -&gt; [sp, #4]	# spill size = 32
054 +   li R11, #-187	# int, #@loadConI
058     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsOffCount @ bci:1 (line 4583) L[0]=sp + #8 L[1]=sp + #0 L[2]=sp + #4 STK[0]=sp + #8
        # OopMap {off=92/0x5c}
05c     #@ShouldNotReachHere

068     B6: #	out( N1 ) &lt;- in( B2 )  Freq: 5e-07
068 +   spill R11 -&gt; R8	# spill size = 32
06c +   spill R13 -&gt; [sp, #4]	# spill size = 32
070 +   spill R12 -&gt; [sp, #8]	# spill size = 32
074 +   li R11, #-187	# int, #@loadConI
078     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsOffCount @ bci:5 (line 4583) L[0]=R8 L[1]=sp + #8 L[2]=sp + #4 STK[0]=sp + #8
        # OopMap {off=124/0x7c}
07c     #@ShouldNotReachHere

088     B7: #	out( N1 ) &lt;- in( B3 )  Freq: 4.76837e-07
088 +   spill R11 -&gt; [sp, #8]	# spill size = 32
08c +   spill R12 -&gt; [sp, #0]	# spill size = 32
090 +   spill R13 -&gt; [sp, #4]	# spill size = 32
094 +   spill R28 -&gt; [sp, #12]	# spill size = 32
098 +   li R11, #-187	# int, #@loadConI
09c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsOffCount @ bci:12 (line 4583) L[0]=sp + #8 L[1]=sp + #0 L[2]=sp + #4 STK[0]=sp + #8 STK[1]=sp + #12
        # OopMap {off=160/0xa0}
0a0 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='337'>
----------------------- MetaData before Compile_id = 337 ------------------------
{method}
 - this oop:          0x0000004096009968
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;&lt;init&gt;&apos;
 - signature:         &apos;([BLjava/nio/charset/Charset;)V&apos;
 - max stack:         6
 - max locals:        3
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008317290: 0xbbb i2c: 0x0000004013944dc0 c2i: 0x0000004013944e0c c2iUV: 0x0000004013944dd8
 - compiled entry     0x000000400c528600
 - code size:         10
 - code start:        0x0000004096009930
 - code end (excl):   0x000000409600993a
 - method data:       0x00000040964844c0
 - checked ex length: 0
 - linenumber start:  0x000000409600993a
 - localvar length:   3
 - localvar start:    0x0000004096009942
 - compiled code: nmethod  14522  233       3       java.lang.String::&lt;init&gt; (10 bytes)

------------------------ OptoAssembly for Compile_id = 337 -----------------------
#
#  void ( java/lang/String:NotNull:exact *, byte[int:&gt;=0]:exact *, sun/nio/cs/UTF_8:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: byte[int:&gt;=0]:exact *
#r016 c_rarg3:c_rarg3   : parm 2: sun/nio/cs/UTF_8:exact *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N48: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B5 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     spill R13 -&gt; R15	# spill size = 64
040     lwu  R14, [R12, #12]	# range, #@loadRange
044     NullCheck R12

044     B2: #	out( B4 B3 ) &lt;- in( B1 )  Freq: 0.999999
044 +   li R13, #0	# int, #@loadConI
048     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.String::&lt;init&gt;
        # java.lang.String::&lt;init&gt; @ bci:6 (line 1380) L[0]=_ L[1]=_ L[2]=_
        # OopMap {off=76/0x4c}

04c     B3: #	out( N48 ) &lt;- in( B2 )  Freq: 0.999979
        # Block is sole successor of call
04c     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

068     B4: #	out( N48 ) &lt;- in( B2 )  Freq: 9.99999e-06
068      -- 	// exception oop; no code emitted, #@CreateException
068 +   spill R10 -&gt; R11	# spill size = 64
06c +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
078 +   j rethrow_stub	#@RethrowException

080     B5: #	out( N48 ) &lt;- in( B1 )  Freq: 1.01328e-06
080 +   li R11, #-10	# int, #@loadConI
084     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::&lt;init&gt; @ bci:4 (line 1380) L[0]=_ L[1]=_ L[2]=_ STK[0]=_ STK[1]=_ STK[2]=_ STK[3]=#NULL
        # OopMap {off=136/0x88}
088 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='338'>
----------------------- MetaData before Compile_id = 338 ------------------------
{method}
 - this oop:          0x0000004096006b50
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0xc1000001  public 
 - name:              &apos;&lt;init&gt;&apos;
 - signature:         &apos;([BIILjava/nio/charset/Charset;)V&apos;
 - max stack:         7
 - max locals:        11
 - size of params:    5
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x00000040083214b0: 0xbbaab i2c: 0x0000004013941240 c2i: 0x0000004013941294 c2iUV: 0x0000004013941260
 - compiled entry     0x000000400c54f440
 - code size:         813
 - code start:        0x0000004096006680
 - code end (excl):   0x00000040960069ad
 - method data:       0x00000040964939a0
 - checked ex length: 0
 - linenumber start:  0x00000040960069ad
 - localvar length:   25
 - localvar start:    0x0000004096006a22
 - compiled code: nmethod  14652  272       3       java.lang.String::&lt;init&gt; (813 bytes)

------------------------ OptoAssembly for Compile_id = 338 -----------------------
#
#  void ( java/lang/String:NotNull:exact *, byte[int:&gt;=0]:exact *, int, int, sun/nio/cs/UTF_8:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: byte[int:&gt;=0]:exact *
#r016 c_rarg3   : parm 2: int
#r018 c_rarg4   : parm 3: int
#r020 c_rarg5:c_rarg5   : parm 4: sun/nio/cs/UTF_8:exact *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N754: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B74 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
03c     spill R14 -&gt; [sp, #28]	# spill size = 32
040 +   spill R13 -&gt; [sp, #24]	# spill size = 32
044 +   spill R12 -&gt; [sp, #16]	# spill size = 64
048 +   spill R11 -&gt; [sp, #0]	# spill size = 64
04c +   beq   R15, zr, B74	#@cmpP_imm0_branch  P=0.000000 C=24058.000000

050     B2: #	out( B77 B3 ) &lt;- in( B1 )  Freq: 1
050     lwu  R7, [R12, #12]	# range, #@loadRange
054     NullCheck R12

054     B3: #	out( B69 B4 ) &lt;- in( B2 )  Freq: 0.999999
054 +   addw  R12, R13, R14	#@addI_reg_reg
058 +   subw  R8, R7, R14	#@subI_reg_reg
05c +   mv  R28, sun/nio/cs/UTF_8:exact *	# ptr, #@loadConP
074 +   blt  R13, zr, B69	#@cmpI_reg_imm0_branch  P=0.000000 C=5376.000000

078     B4: #	out( B70 B5 ) &lt;- in( B3 )  Freq: 0.999998
078 +   blt  R14, zr, B70	#@cmpI_reg_imm0_branch  P=0.000000 C=5376.000000

07c     B5: #	out( B75 B6 ) &lt;- in( B4 )  Freq: 0.999998
07c +   bgt  R13, R8, B75	#@cmpI_branch  P=0.000000 C=5376.000000

080     B6: #	out( B76 B7 ) &lt;- in( B5 )  Freq: 0.999997
080 +   beq  R14, zr, B76	#@cmpI_reg_imm0_branch  P=0.000000 C=5351.000000

084     B7: #	out( B71 B8 ) &lt;- in( B6 )  Freq: 0.999997
084 +   bne  R15, R28, B71	#@cmpP_branch  P=0.000000 C=5351.000000

088     B8: #	out( B30 B9 ) &lt;- in( B7 )  Freq: 0.999996
088 +   bge  R13, R12, B30	#@cmpI_branch  P=0.053171 C=98418.000000

08c     B9: #	out( B63 B10 ) &lt;- in( B8 )  Freq: 0.946825
08c +   addw  R28, R12, zr	#@convI2L_reg_reg
090 +   addw  R29, R7, zr	#@convI2L_reg_reg
094 +   addi  R28, R28, #-1	#@addL_reg_imm
098 +   bgeu  R13, R7, B63	#@cmpU_branch  P=0.000001 C=-1.000000

09c     B10: #	out( B63 B11 ) &lt;- in( B9 )  Freq: 0.946824
09c +   bgeu  R28, R29, B63	#@cmpUL_branch  P=0.000001 C=-1.000000

0a0     B11: #	out( B12 ) &lt;- in( B10 )  Freq: 0.946823
0a0 +   addiw  R29, R13, #1	#@addI_reg_imm
0a4     spill R13 -&gt; R28	# spill size = 32

0a8     B12: #	out( B68 B13 ) &lt;- in( B11 B14 ) Loop( B12-B14 inner pre of N639) Freq: 1.89365
0a8 +   addw  R30, R28, zr	#@convI2L_reg_reg
0ac     spill [sp, #16] -&gt; R31	# spill size = 64
0b0 +   add R30, R31, R30	# ptr, #@addP_reg_reg
0b4 +   lb  R31, [R30, #16]	# byte, #@loadB
0b8 +   blt  R31, zr, B68	#@cmpI_reg_imm0_branch  P=0.000000 C=93185.000000

0bc     B13: #	out( B15 B14 ) &lt;- in( B12 )  Freq: 1.89364
0bc +   addiw  R31, R28, #1	#@addI_reg_imm
0c0 +   bge  R31, R29, B15	#@cmpI_loop  P=0.500000 C=93185.000000

0c4     B14: #	out( B12 ) &lt;- in( B13 )  Freq: 0.946822
0c4 +   spill R31 -&gt; R28	# spill size = 32
0c8 +   j  B12	#@branch

0cc     B15: #	out( B64 B16 ) &lt;- in( B13 )  Freq: 0.946822
0cc +   li R29, #-2147483648	# int, #@loadConI
0d0 +   addiw  R16, R12, #-3	#@addI_reg_imm
0d4     CMove R16, (R12 lt R16), R16, R29	#@cmovI_cmpI
	
0dc +   bge  R31, R16, B64	#@cmpI_branch  P=0.000001 C=-1.000000

0e0     B16: #	out( B65 B17 ) &lt;- in( B15 )  Freq: 0.946821
0e0 +   li R14, #0	# int, #@loadConI
0e4 +   li R15, #4000	# int, #@loadConI
0ec     spill R31 -&gt; R13	# spill size = 32
0f0 +   addiw  R29, R28, #4	#@addI_reg_imm
0f4 +   # castII of R13, #@castII
0f4     bgeu  R13, R7, B65	#@cmpU_branch  P=0.000001 C=-1.000000

0f8     B17: #	out( B66 B18 ) &lt;- in( B16 )  Freq: 0.94682
0f8 +   bgeu  R31, R7, B66	#@cmpU_branch  P=0.000001 C=-1.000000

0fc     B18: #	out( B67 B19 ) &lt;- in( B17 )  Freq: 0.946819
0fc +   bgeu  R29, R7, B67	#@cmpU_branch  P=0.000001 C=-1.000000

100     B19: #	out( B20 ) &lt;- in( B18 B25 ) Loop( B19-B25 ) Freq: 17.7956
100 +   subw  R28, R16, R13	#@subI_reg_reg
104     CMove R28, (R16 lt R13), R28, R14	#@cmovI_cmpI
	
10c +   CMove R28, (R28 gtu R15), R28, R15	#@cmovI_cmpU
	
114 +   addw  R29, R28, R13	#@addI_reg_reg
        nop 	# 4 bytes pad for loops and calls

120     B20: #	out( B53 B21 ) &lt;- in( B19 B24 ) Loop( B20-B24 inner main of N132 strip mined) Freq: 334.674
120 +   addw  R28, R13, zr	#@convI2L_reg_reg
124     spill [sp, #16] -&gt; R30	# spill size = 64
128 +   add R28, R30, R28	# ptr, #@addP_reg_reg
12c +   lb  R30, [R28, #16]	# byte, #@loadB
130 +   lb  R31, [R28, #19]	# byte, #@loadB
134 +   lb  R10, [R28, #18]	# byte, #@loadB
138 +   lb  R11, [R28, #17]	# byte, #@loadB
13c +   blt  R30, zr, B53	#@cmpI_reg_imm0_branch  P=0.000000 C=93185.000000

140     B21: #	out( B56 B22 ) &lt;- in( B20 )  Freq: 334.674
140 +   blt  R11, zr, B56	#@cmpI_reg_imm0_branch  P=0.000000 C=93185.000000

144     B22: #	out( B54 B23 ) &lt;- in( B21 )  Freq: 334.674
144 +   blt  R10, zr, B54	#@cmpI_reg_imm0_branch  P=0.000000 C=93185.000000

148     B23: #	out( B57 B24 ) &lt;- in( B22 )  Freq: 334.674
148 +   blt  R31, zr, B57	#@cmpI_reg_imm0_branch  P=0.000000 C=93185.000000

14c     B24: #	out( B20 B25 ) &lt;- in( B23 )  Freq: 334.674
14c +   addiw  R13, R13, #4	#@addI_reg_imm
150 +   blt  R13, R29, B20	#@cmpI_loop  P=0.946829 C=93185.000000

154     B25: #	out( B19 B26 ) &lt;- in( B24 )  Freq: 17.795
154 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
154     ld  R31, [R23, #920]	# ptr, #@loadP
158 +   lwu zr, [R31]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringCoding::hasNegatives @ bci:20 (line 39) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #28 L[3]=R13
        # java.lang.String::&lt;init&gt; @ bci:59 (line 528) L[0]=sp + #0 L[1]=sp + #16 L[2]=sp + #24 L[3]=sp + #28 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_
        # OopMap {[0]=Oop [16]=Oop off=344/0x158}
15c +   blt  R13, R16, B19	#@cmpI_branch  P=0.946829 C=93185.000000

160     B26: #	out( B30 B27 ) &lt;- in( B64 B25 )  Freq: 0.946181
160 +   bge  R13, R12, B30	#@cmpI_branch  P=0.500000 C=-1.000000

164     B27: #	out( B73 B28 ) &lt;- in( B26 )  Freq: 0.473091
164 +   # castII of R13, #@castII
164     bgeu  R13, R7, B73	#@cmpU_branch  P=0.000001 C=-1.000000

168     B28: #	out( B58 B29 ) &lt;- in( B27 B29 ) Loop( B28-B29 inner post of N639) Freq: 0.94618
168 +   addw  R28, R13, zr	#@convI2L_reg_reg
16c     spill [sp, #16] -&gt; R29	# spill size = 64
170 +   add R28, R29, R28	# ptr, #@addP_reg_reg
174 +   lb  R31, [R28, #16]	# byte, #@loadB
178 +   blt  R31, zr, B58	#@cmpI_reg_imm0_branch  P=0.000000 C=93185.000000

17c     B29: #	out( B28 B30 ) &lt;- in( B28 )  Freq: 0.946179
17c +   addiw  R13, R13, #1	#@addI_reg_imm
180 +   blt  R13, R12, B28	#@cmpI_loop  P=0.500000 C=93185.000000

184     B30: #	out( B31 B31 ) &lt;- in( B26 B8 B29 )  Freq: 0.999351
184 +   spill [sp, #24] -&gt; R28	# spill size = 32
188 +   subw  R29, R7, R28	#@subI_reg_reg
18c     spill [sp, #28] -&gt; R8	# spill size = 32
190 +   CMove R8, (R29 lt R8), R8, R29	#@cmovI_cmpI
	
198 +   li R30, #1048576	# int, #@loadConI
19c +   addw  R28, R28, R8	#@addI_reg_reg
1a0     spill [sp, #28] -&gt; R31	# spill size = 32
1a4 +   addw  R29, R31, zr	#@convI2L_reg_reg
1a8 +   bleu  R31, R30, B31	#@cmpU_branch  P=0.999999 C=-1.000000

1ac     B31: #	out( B62 B32 ) &lt;- in( B30 B30 )  Freq: 0.999351
1ac +   bltu  R7, R28, B62	#@cmpU_branch  P=0.000001 C=-1.000000

1b0     B32: #	out( B62 B33 ) &lt;- in( B31 )  Freq: 0.99935
1b0 +   bltu  R31, R8, B62	#@cmpU_branch  P=0.000001 C=-1.000000

1b4     B33: #	out( B62 B34 ) &lt;- in( B32 )  Freq: 0.999349
1b4 +   blt  R8, zr, B62	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

1b8     B34: #	out( B59 B35 ) &lt;- in( B33 )  Freq: 0.999348
1b8 +   addi  R29, R29, #23	#@addL_reg_imm
1bc +   bgtu  R31, R30, B59	#@cmpU_branch  P=0.000001 C=-1.000000

1c0     B35: #	out( B59 B36 ) &lt;- in( B34 )  Freq: 0.999347
1c0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1c0     ld  R9, [R23, #288]	# ptr, #@loadP
1c4 +   andi  R7, R29, #-8	#@andL_reg_imm
1c8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1c8     ld  R28, [R23, #304]	# ptr, #@loadP
1cc +   add R7, R9, R7	# ptr, #@addP_reg_reg
1d0 +   bgeu  R7, R28, B59	#@cmpP_branch  P=0.000100 C=-1.000000

1d4     B36: #	out( B37 ) &lt;- in( B35 )  Freq: 0.999247
1d4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1d4     sd  R7, [R23, #288]	# ptr, #@storeP
1d8 +   li R7, #1	# long, #@loadConL
1dc +   sd  R7, [R9]	# long, #@storeL
1e0 +   mv  R7, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1f0 +   sw  R7, [R9, #8]	# compressed klass ptr, #@storeNKlass
1f4 +   sw  R31, [R9, #12]	# int, #@storeI

1f8     B37: #	out( B61 B38 ) &lt;- in( B60 B36 )  Freq: 0.999348
1f8     
1f8 +   srli  R7, R29, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
1fc +   # checkcastPP of R9, #@checkCastPP
1fc     addi  R11, R9, #16	# ptr, #@addP_reg_imm
200 +   encode_heap_oop  R19, R9	#@encodeHeapOop
204 +   beq  R8, zr, B61	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

208     B38: #	out( B45 B39 ) &lt;- in( B37 )  Freq: 0.999347
208 +   spill [sp, #24] -&gt; R28	# spill size = 32
20c +   addw  R28, R28, zr	#@convI2L_reg_reg
210     spill [sp, #16] -&gt; R29	# spill size = 64
214 +   add R28, R29, R28	# ptr, #@addP_reg_reg
218 +   addw  R12, R8, zr	#@convI2L_reg_reg
21c +   addi  R10, R28, #16	# ptr, #@addP_reg_imm
220     spill [sp, #28] -&gt; R29	# spill size = 32
224 +   blt  R8, R29, B45	#@cmpI_branch  P=0.001000 C=-1.000000

228     B39: #	out( B40 ) &lt;- in( B38 B45 )  Freq: 0.999347
228 +   CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

22c     B40: #	out( B46 B41 ) &lt;- in( B39 B61 )  Freq: 0.999348
22c     MEMBAR-store-store	#@membar_storestore
230 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
230     lb  R28, [R23, #56]	# byte, #@loadB
234 +   bne  R28, zr, B46	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

238     B41: #	out( B42 ) &lt;- in( B40 )  Freq: 0.998349
238 +   spill [sp, #0] -&gt; R18	# spill size = 64

23c     B42: #	out( B44 B43 ) &lt;- in( B72 B48 B46 B41 )  Freq: 0.999348
23c +   mv  R7, R18	# ptr -&gt; long, #@castP2X
240 +   mv  R28, R9	# ptr -&gt; long, #@castP2X
244 +   xorr  R28, R28, R7	#@xorL_reg_reg
248 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
24c +   sw  R19, [R18, #20]	# compressed ptr, #@storeN ! Field: java/lang/String.value (constant)
250 +   beq  R28, zr, B44	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

254     B43: #	out( B49 B44 ) &lt;- in( B42 )  Freq: 0.998349
254 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
258 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
264 +   add R10, R28, R7	# ptr, #@addP_reg_reg
268 +   lb  R7, [R10]	# byte, #@loadB
26c +   li R29, #4	# int, #@loadConI
270 +   bne  R7, R29, B49	#@cmpI_branch  P=0.001000 C=-1.000000

274     B44: #	out( N754 ) &lt;- in( B51 B52 B49 B43 B42 )  Freq: 0.999348
274 +   sb zr, [R18, #16]	# byte, #@storeimmB0 ! Field: java/lang/String.coder (constant)
278 +   #@membar_release
	fence iorw ow
27c +   #@membar_release
	fence iorw ow
27c +   # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
294 +   ret	// return register, #@Ret

298     B45: #	out( B39 ) &lt;- in( B38 )  Freq: 0.000999347
298 +   addi  R28, R12, #16	#@addL_reg_imm
29c +   srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
2a0 +   andi  R28, R28, #-8	#@andL_reg_imm
2a4 +   add R28, R9, R28	# ptr, #@addP_reg_reg
2a8 +   sub  R29, R7, R29	#@subL_reg_reg
2ac +   ClearArray R29, R28	#@clearArray_reg_reg
304     j  B39	#@branch

308     B46: #	out( B42 B47 ) &lt;- in( B40 )  Freq: 0.000999335
308 +   spill [sp, #0] -&gt; R18	# spill size = 64
30c +   lwu  R7, [R18, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
310 +   decode_heap_oop  R10, R7	#@decodeHeapOop
314 +   beq   R10, zr, B42	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

318     B47: #	out( B72 B48 ) &lt;- in( B46 )  Freq: 0.000499668
318 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
318     ld  R7, [R23, #32]	# int, #@loadL
31c +   beq  R7, zr, B72	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

320     B48: #	out( B42 ) &lt;- in( B47 )  Freq: 0.000499168
320 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
320     ld  R28, [R23, #48]	# ptr, #@loadP
324 +   add R28, R28, R7	# ptr, #@addP_reg_reg
328 +   addi  R7, R7, #-8	#@addL_reg_imm
32c +   sd  R10, [R28, #-8]	# ptr, #@storeP
330 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
330     sd  R7, [R23, #32]	# long, #@storeL
334 +   j  B42	#@branch

338     B49: #	out( B44 B50 ) &lt;- in( B43 )  Freq: 0.000998349
338 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
338     ld  R7, [R23, #64]	# int, #@loadL
33c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
33c     ld  R28, [R23, #80]	# ptr, #@loadP
340 +   #@membar_volatile
	fence iorw iorw
344 +   lb  R29, [R10]	# byte, #@loadB
348 +   beq  R29, zr, B44	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

34c     B50: #	out( B52 B51 ) &lt;- in( B49 )  Freq: 0.000499174
34c +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
350 +   bne  R7, zr, B52	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

354     B51: #	out( B44 ) &lt;- in( B50 )  Freq: 0.000249587
354 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
354     spill R23 -&gt; R11	# spill size = 64
358 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
388 +   j  B44	#@branch

38c     B52: #	out( B44 ) &lt;- in( B50 )  Freq: 0.000249587
38c +   add R28, R28, R7	# ptr, #@addP_reg_reg
390 +   addi  R7, R7, #-8	#@addL_reg_imm
394 +   sd  R10, [R28, #-8]	# ptr, #@storeP
398 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
398     sd  R7, [R23, #64]	# long, #@storeL
39c +   j  B44	#@branch

3a0     B53: #	out( B55 ) &lt;- in( B20 )  Freq: 0.000159585
3a0 +   spill R30 -&gt; R10	# spill size = 32
3a4 +   j  B55	#@branch

3a8     B54: #	out( B55 ) &lt;- in( B22 )  Freq: 0.000159585
3a8 +   addiw  R13, R13, #2	#@addI_reg_imm

3ac     B55: #	out( B58 ) &lt;- in( B53 B54 )  Freq: 0.00031917
3ac     spill R10 -&gt; R31	# spill size = 32
3b0 +   j  B58	#@branch

3b4     B56: #	out( B58 ) &lt;- in( B21 )  Freq: 0.000159585
3b4 +   addiw  R13, R13, #1	#@addI_reg_imm
3b8     spill R11 -&gt; R31	# spill size = 32
3bc +   j  B58	#@branch

3c0     B57: #	out( B58 ) &lt;- in( B23 )  Freq: 0.000159585
3c0 +   addiw  R13, R13, #3	#@addI_reg_imm

3c4     B58: #	out( N754 ) &lt;- in( B28 B68 B55 B56 B57 )  Freq: 0.000639694
3c4 +   li R11, #-187	# int, #@loadConI
3c8     spill [sp, #0] -&gt; R8	# spill size = 64
3cc +   spill R13 -&gt; [sp, #32]	# spill size = 32
3d0 +   spill R31 -&gt; [sp, #36]	# spill size = 32
3d4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringCoding::hasNegatives @ bci:12 (line 40) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #28 L[3]=sp + #32 STK[0]=sp + #36
        # java.lang.String::&lt;init&gt; @ bci:59 (line 528) L[0]=R8 L[1]=sp + #16 L[2]=sp + #24 L[3]=sp + #28 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_
        # OopMap {fp=Oop [16]=Oop off=984/0x3d8}
3d8     #@ShouldNotReachHere

3e4     B59: #	out( B78 B60 ) &lt;- in( B34 B35 )  Freq: 0.000100964
3e4 +   spill R29 -&gt; [sp, #32]	# spill size = 64
3e8 +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
400     spill [sp, #28] -&gt; R12	# spill size = 32
404     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # java.util.Arrays::copyOfRange @ bci:41 (line 3822) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=sp + #28 L[4]=_
        # java.lang.String::&lt;init&gt; @ bci:71 (line 529) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ STK[0]=sp + #0
        # OopMap {[0]=Oop [16]=Oop off=1032/0x408}

408     B60: #	out( B37 ) &lt;- in( B59 )  Freq: 0.000100962
        # Block is sole successor of call
408 +   spill R10 -&gt; R9	# spill size = 64
40c +   spill [sp, #32] -&gt; R29	# spill size = 64
410 +   j  B37	#@branch

414     B61: #	out( B40 ) &lt;- in( B37 )  Freq: 1.01262e-06
414 +   spill R11 -&gt; R28	# spill size = 64
418 +   addi  R29, R7, #-2	#@addL_reg_imm
41c     ClearArray R29, R28	#@clearArray_reg_reg
474     
474 +   j  B40	#@branch

478     B62: #	out( N754 ) &lt;- in( B33 B31 B32 )  Freq: 2.99805e-06
478 +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
480 +   li R11, #-52	# int, #@loadConI
484     spill [sp, #0] -&gt; R8	# spill size = 64
488 +   spill [sp, #24] -&gt; [sp, #16]	# spill size = 32
490     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # java.util.Arrays::copyOfRange @ bci:41 (line 3822) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=sp + #28 L[4]=_ STK[0]=sp + #28
        # java.lang.String::&lt;init&gt; @ bci:71 (line 529) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ STK[0]=R8
        # OopMap {fp=Oop [8]=Oop off=1172/0x494}
494     #@ShouldNotReachHere

4a0     B63: #	out( N754 ) &lt;- in( B10 B9 )  Freq: 1.9188e-06
4a0 +   li R11, #-138	# int, #@loadConI
4a4     spill [sp, #0] -&gt; R8	# spill size = 64
4a8 +   spill R12 -&gt; [sp, #40]	# spill size = 32
4ac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringCoding::hasNegatives @ bci:6 (line 39) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #28 L[3]=sp + #24 STK[0]=sp + #24 STK[1]=sp + #40
        # java.lang.String::&lt;init&gt; @ bci:59 (line 528) L[0]=R8 L[1]=sp + #16 L[2]=sp + #24 L[3]=sp + #28 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_
        # OopMap {fp=Oop [16]=Oop off=1200/0x4b0}
4b0     #@ShouldNotReachHere

4bc     B64: #	out( B26 ) &lt;- in( B15 )  Freq: 9.59395e-07
4bc +   spill R31 -&gt; R13	# spill size = 32
4c0 +   j  B26	#@branch

4c4     B65: #	out( N754 ) &lt;- in( B16 )  Freq: 9.59394e-07
4c4     #@ShouldNotReachHere

4d0     B66: #	out( N754 ) &lt;- in( B17 )  Freq: 9.59393e-07
4d0     #@ShouldNotReachHere

4dc     B67: #	out( N754 ) &lt;- in( B18 )  Freq: 9.59392e-07
4dc     #@ShouldNotReachHere

4e8     B68: #	out( B58 ) &lt;- in( B12 )  Freq: 9.02961e-07
4e8 +   spill R28 -&gt; R13	# spill size = 32
4ec +   j  B58	#@branch

4f0     B69: #	out( N754 ) &lt;- in( B3 )  Freq: 4.99999e-07
4f0 +   spill [sp, #0] -&gt; R8	# spill size = 64
4f4 +   spill [sp, #16] -&gt; [sp, #0]	# spill size = 64
4fc +   li R11, #-187	# int, #@loadConI
500     spill R13 -&gt; [sp, #16]	# spill size = 32
504 +   spill R14 -&gt; [sp, #20]	# spill size = 32
508 +   spill R15 -&gt; [sp, #32]	# spill size = 64
50c +   spill R7 -&gt; [sp, #28]	# spill size = 32
510     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsOffCount @ bci:1 (line 4583) L[0]=sp + #24 L[1]=sp + #20 L[2]=sp + #28 STK[0]=sp + #16
        # java.lang.String::&lt;init&gt; @ bci:14 (line 523) L[0]=R8 L[1]=sp + #0 L[2]=sp + #16 L[3]=sp + #20 L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_
        # OopMap {fp=Oop [0]=Oop [32]=Oop off=1300/0x514}
514     #@ShouldNotReachHere

520     B70: #	out( N754 ) &lt;- in( B4 )  Freq: 4.99999e-07
520 +   spill [sp, #0] -&gt; R8	# spill size = 64
524 +   spill [sp, #16] -&gt; [sp, #0]	# spill size = 64
52c +   li R11, #-187	# int, #@loadConI
530     spill R13 -&gt; [sp, #16]	# spill size = 32
534 +   spill R14 -&gt; [sp, #20]	# spill size = 32
538 +   spill R14 -&gt; [sp, #24]	# spill size = 32
53c +   spill R15 -&gt; [sp, #32]	# spill size = 64
540 +   spill R7 -&gt; [sp, #28]	# spill size = 32
544     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsOffCount @ bci:5 (line 4583) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #28 STK[0]=sp + #20
        # java.lang.String::&lt;init&gt; @ bci:14 (line 523) L[0]=R8 L[1]=sp + #0 L[2]=sp + #16 L[3]=sp + #20 L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_
        # OopMap {fp=Oop [0]=Oop [32]=Oop off=1352/0x548}
548     #@ShouldNotReachHere

554     B71: #	out( N754 ) &lt;- in( B7 )  Freq: 4.99998e-07
554 +   spill [sp, #0] -&gt; R8	# spill size = 64
558 +   li R11, #-187	# int, #@loadConI
55c     spill [sp, #16] -&gt; [sp, #0]	# spill size = 64
564 +   spill R13 -&gt; [sp, #8]	# spill size = 32
568 +   spill R14 -&gt; [sp, #12]	# spill size = 32
56c +   spill R15 -&gt; [sp, #24]	# spill size = 64
570     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::&lt;init&gt; @ bci:47 (line 527) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #12 L[4]=sp + #24 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ STK[0]=sp + #24 STK[1]=#Ptr0x00000040d827d700
        # OopMap {fp=Oop [0]=Oop [24]=Oop off=1396/0x574}
574     #@ShouldNotReachHere

580     B72: #	out( B42 ) &lt;- in( B47 )  Freq: 4.99661e-07
580 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
580     spill R23 -&gt; R11	# spill size = 64
584 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
5b4 +   j  B42	#@branch

5b8     B73: #	out( N754 ) &lt;- in( B27 )  Freq: 4.79373e-07
5b8     #@ShouldNotReachHere

5c4     B74: #	out( N754 ) &lt;- in( B1 )  Freq: 4.76837e-07
5c4 +   spill [sp, #0] -&gt; R8	# spill size = 64
5c8 +   li R11, #-187	# int, #@loadConI
5cc     spill R12 -&gt; [sp, #0]	# spill size = 64
5d0 +   spill R13 -&gt; [sp, #8]	# spill size = 32
5d4 +   spill R14 -&gt; [sp, #12]	# spill size = 32
5d8 +   spill R15 -&gt; [sp, #24]	# spill size = 64
5dc +   spill R15 -&gt; [sp, #32]	# spill size = 64
5e0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.Objects::requireNonNull @ bci:1 (line 208) L[0]=sp + #32 STK[0]=sp + #24
        # java.lang.String::&lt;init&gt; @ bci:6 (line 522) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #12 L[4]=sp + #24 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_
        # OopMap {fp=Oop [0]=Oop [24]=Oop [32]=Oop off=1508/0x5e4}
5e4     #@ShouldNotReachHere

5f0     B75: #	out( N754 ) &lt;- in( B5 )  Freq: 4.76836e-07
5f0 +   li R11, #-187	# int, #@loadConI
5f4     spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
5fc +   spill R15 -&gt; [sp, #40]	# spill size = 64
600 +   spill R7 -&gt; [sp, #36]	# spill size = 32
604     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsOffCount @ bci:12 (line 4583) L[0]=sp + #24 L[1]=sp + #28 L[2]=sp + #36 STK[0]=sp + #24 STK[1]=R8
        # java.lang.String::&lt;init&gt; @ bci:14 (line 523) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #24 L[3]=sp + #28 L[4]=sp + #40 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_
        # OopMap {[0]=Oop [8]=Oop [40]=Oop off=1544/0x608}
608     #@ShouldNotReachHere

614     B76: #	out( N754 ) &lt;- in( B6 )  Freq: 4.76836e-07
614 +   spill [sp, #0] -&gt; R8	# spill size = 64
618 +   spill [sp, #16] -&gt; [sp, #0]	# spill size = 64
620 +   li R11, #-187	# int, #@loadConI
624     spill R13 -&gt; [sp, #8]	# spill size = 32
628 +   spill R14 -&gt; [sp, #16]	# spill size = 32
62c +   spill R15 -&gt; [sp, #24]	# spill size = 64
630     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::&lt;init&gt; @ bci:18 (line 524) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #24 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ STK[0]=sp + #16
        # OopMap {fp=Oop [0]=Oop [24]=Oop off=1588/0x634}
634     #@ShouldNotReachHere

640     B77: #	out( N754 ) &lt;- in( B2 )  Freq: 1.01328e-06
640 +   li R11, #-10	# int, #@loadConI
644     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::&lt;init&gt; @ bci:13 (line 523) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ STK[0]=_ STK[1]=_ STK[2]=#NULL
        # OopMap {off=1608/0x648}
648     #@ShouldNotReachHere

654     B78: #	out( N754 ) &lt;- in( B59 )  Freq: 1.00964e-09
654      -- 	// exception oop; no code emitted, #@CreateException
654 +   spill R10 -&gt; R11	# spill size = 64
658 +   # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
664 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='339'>
----------------------- MetaData before Compile_id = 339 ------------------------
{method}
 - this oop:          0x0000004096307e80
 - method holder:     &apos;jdk/internal/module/ModulePath&apos;
 - constants:         0x0000004096302d28 constant pool [1026]/operands[112] {0x0000004096302d28} for &apos;jdk/internal/module/ModulePath&apos; cache=0x0000004096308cb8
 - access:            0x81000002  private 
 - name:              &apos;toPackageName&apos;
 - signature:         &apos;(Ljava/nio/file/Path;Ljava/lang/String;)Ljava/util/Optional;&apos;
 - max stack:         4
 - max locals:        6
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008317290: 0xbbb i2c: 0x0000004013944dc0 c2i: 0x0000004013944e0c c2iUV: 0x0000004013944dd8
 - compiled entry     0x000000400c55d340
 - code size:         133
 - code start:        0x0000004096307d90
 - code end (excl):   0x0000004096307e15
 - method data:       0x0000004096497c98
 - checked ex length: 0
 - linenumber start:  0x0000004096307e15
 - localvar length:   7
 - localvar start:    0x0000004096307e28
 - compiled code: nmethod  15201  276       3       jdk.internal.module.ModulePath::toPackageName (133 bytes)

------------------------ OptoAssembly for Compile_id = 339 -----------------------
#
#  java/util/Optional:exact * ( jdk/internal/module/ModulePath:NotNull *, java/nio/file/Path *, java/lang/String:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: jdk/internal/module/ModulePath:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/nio/file/Path *
#r016 c_rarg3:c_rarg3   : parm 2: java/lang/String:exact *
# -- Old sp -- Framesize: 96 --
#r263 sp+92: in_preserve
#r262 sp+88: return address
#r261 sp+84: in_preserve
#r260 sp+80: saved fp register
#r259 sp+76: pad2, stack alignment
#r258 sp+72: pad2, stack alignment
#r257 sp+68: Fixed slot 1
#r256 sp+64: Fixed slot 0
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
0000    N2589: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0000    # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

0020    B1: #	out( B244 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0020    # stack bang size=96
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #96
	
003c    spill R13 -&gt; [sp, #0]	# spill size = 64
0040    lwu  R28, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0044    NullCheck R12

0044    B2: #	out( B203 B3 ) &lt;- in( B1 )  Freq: 0.999999
0044 +  mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d06f9290:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0054 +  far_bne  R28, R7, B203	#@far_cmpN_branch  P=0.000001 C=-1.000000

005c    B3: #	out( B272 B4 ) &lt;- in( B2 )  Freq: 0.999998
005c +  # checkcastPP of R12, #@checkCastPP
005c    spill R12 -&gt; [sp, #8]	# spill size = 64
0060 +  spill R12 -&gt; R11	# spill size = 64
0064 +  spill R12 -&gt; R8	# spill size = 64
0068    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 276) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=R8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=108/0x6c}

006c    B4: #	out( B245 B5 ) &lt;- in( B3 )  Freq: 0.999978
        # Block is sole successor of call
006c +  lwu  R28, [R8, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0070 +  #@membar_acquire
	fence ir iorw
0074 +  decode_heap_oop  R7, R28	#@decodeHeapOop
0078    lwu  R30, [R7, #12]	# range, #@loadRange
007c    NullCheck R7

007c    B5: #	out( B222 B6 ) &lt;- in( B4 )  Freq: 0.999977
007c +  far_bleu  R30, zr, B222	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000000 C=5374.000000

0084    B6: #	out( B246 B7 ) &lt;- in( B5 )  Freq: 0.999976
0084 +  lwu  R7, [R8, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0088 +  decode_heap_oop  R31, R7	#@decodeHeapOop
008c +  addw  R28, R30, zr	#@convI2L_reg_reg
0090 +  #@membar_acquire
	fence ir iorw
0094 +  slli  R7, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0098 +  addiw  R8, R30, #-1	#@addI_reg_imm
009c    lwu  R29, [R31, #12]	# range, #@loadRange
00a0    NullCheck R31

00a0    B7: #	out( B199 B8 ) &lt;- in( B6 )  Freq: 0.999975
00a0 +  add R7, R31, R7	# ptr, #@addP_reg_reg
00a4 +  far_bgeu R8, R29, B199	#@far_cmpU_branch  P=0.000001 C=-1.000000

00ac    B8: #	out( B140 B9 ) &lt;- in( B7 )  Freq: 0.999974
00ac +  lw  R8, [R7, #12]	# int, #@loadI
00b0 +  addiw  R29, R8, #-1	#@addI_reg_imm
00b4 +  ble  R29, zr, B140	#@cmpI_reg_imm0_branch  P=0.001489 C=5374.000000

00b8    B9: #	out( B200 B10 ) &lt;- in( B8 )  Freq: 0.998486
00b8 +  spill [sp, #8] -&gt; R7	# spill size = 64
00bc +  lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
00c0 +  li R28, #1048576	# int, #@loadConI
00c4 +  decode_heap_oop  R10, R7	#@decodeHeapOop
00c8 +  far_bgtu R29, R28, B200	#@far_cmpU_branch  P=0.000001 C=-1.000000

00d0    B10: #	out( B11 ) &lt;- in( B9 )  Freq: 0.998485
00d0 +  addw  R7, R8, zr	#@convI2L_reg_reg
00d4 +  addi  R7, R7, #-1	#@addL_reg_imm

00d8    B11: #	out( B247 B12 ) &lt;- in( B10 B200 )  Freq: 0.998486
00d8    lwu  R31, [R10, #12]	# range, #@loadRange
00dc    NullCheck R10

00dc    B12: #	out( B204 B13 ) &lt;- in( B11 )  Freq: 0.998485
00dc +  addi  R30, R7, #23	#@addL_reg_imm
00e0 +  far_bltu R31, R29, B204	#@far_cmpU_branch  P=0.000001 C=-1.000000

00e8    B13: #	out( B168 B14 ) &lt;- in( B12 )  Freq: 0.998484
00e8 +  andi  R31, R30, #-8	#@andL_reg_imm
00ec +  far_bgtu R29, R28, B168	#@far_cmpU_branch  P=0.000001 C=-1.000000

00f4    B14: #	out( B168 B15 ) &lt;- in( B13 )  Freq: 0.998483
00f4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
00f4    ld  R9, [R23, #288]	# ptr, #@loadP
00f8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
00f8    ld  R28, [R23, #304]	# ptr, #@loadP
00fc +  add R7, R9, R31	# ptr, #@addP_reg_reg
0100 +  far_bgeu  R7, R28, B168	#@far_cmpP_branch  P=0.000100 C=-1.000000

0108    B15: #	out( B16 ) &lt;- in( B14 )  Freq: 0.998383
0108 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0108    sd  R7, [R23, #288]	# ptr, #@storeP
010c +  li R7, #1	# long, #@loadConL
0110 +  sd  R7, [R9]	# long, #@storeL
0114 +  mv  R7, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0124 +  sw  R7, [R9, #8]	# compressed klass ptr, #@storeNKlass
0128 +  sw  R29, [R9, #12]	# int, #@storeI

012c    B16: #	out( B201 B17 ) &lt;- in( B169 B15 )  Freq: 0.998484
012c    
012c +  li R28, #1	# int, #@loadConI
0130 +  srli  R7, R30, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
0134 +  # checkcastPP of R9, #@checkCastPP
0134    addi  R11, R9, #16	# ptr, #@addP_reg_imm
0138 +  encode_heap_oop  R18, R9	#@encodeHeapOop
013c +  # castII of R8, #@castII
013c    far_beq  R8, R28, B201	#@far_cmpI_branch  P=0.000001 C=-1.000000

0144    B17: #	out( B158 B18 ) &lt;- in( B16 )  Freq: 0.998483
0144 +  addiw  R30, R8, #-1	#@addI_reg_imm
0148 +  addi  R10, R10, #16	# ptr, #@addP_reg_imm
014c +  blt  R30, R29, B158	#@cmpI_branch  P=0.001000 C=-1.000000

0150    B18: #	out( B19 ) &lt;- in( B17 )  Freq: 0.997484
0150 +  addi  R7, R31, #-16	#@addL_reg_imm
0154 +  srli  R12, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
0158 +  CALL, runtime leaf nofp 0x000000401396d840	#@CallLeafNoFPDirect jlong_disjoint_arraycopy
        No JVM State Info
        # 

015c    B19: #	out( B166 B20 ) &lt;- in( B158 B18 B201 )  Freq: 0.998484
015c    MEMBAR-store-store	#@membar_storestore
0160 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0160    ld  R31, [R23, #288]	# ptr, #@loadP
0164 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0164    ld  R7, [R23, #304]	# ptr, #@loadP
0168 +  addi  R28, R31, #32	# ptr, #@addP_reg_imm
016c +  far_bgeu  R28, R7, B166	#@far_cmpP_branch  P=0.000100 C=-1.000000

0174    B20: #	out( B21 ) &lt;- in( B19 )  Freq: 0.998384
0174 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0174    sd  R28, [R23, #288]	# ptr, #@storeP
0178 +  li R7, #1	# long, #@loadConL
017c +  mv  R28, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d06f9290:Constant:exact *	# compressed klass ptr, #@loadConNKlass
018c +  sd  R7, [R31]	# long, #@storeL
0190 +  sw  R28, [R31, #8]	# compressed klass ptr, #@storeNKlass
0194 +  sw  zr, [R31, #12]	# int, #@storeimmI0
0198 +  sw  zr, [R31, #16]	# int, #@storeimmI0
019c +  sd  zr, [R31, #24]	# long, #@storeimmL0

01a0    B21: #	out( B22 ) &lt;- in( B167 B20 )  Freq: 0.998484
01a0 +  sw  R18, [R31, #20]	# compressed ptr, #@storeN
01a4    
01a4    spill [sp, #8] -&gt; R7	# spill size = 64
01a8 +  lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
01ac +  # checkcastPP of R31, #@checkCastPP
01ac    sw  R7, [R31, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixPath.fs

01b0    B22: #	out( B142 B23 ) &lt;- in( B141 B21 )  Freq: 0.999972
01b0 +  mv  R11, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
01c0 +  # checkcastPP of R31, #@checkCastPP
01c0    beq   R31, zr, B142	#@cmpP_imm0_branch  P=0.001489 C=5374.000000

01c4    B23: #	out( B205 B24 ) &lt;- in( B22 )  Freq: 0.998484
01c4 +  lwu  R28, [R31, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
01c8 +  mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d06f9290:Constant:exact *	# compressed klass ptr, #@loadConNKlass
01d8 +  far_bne  R28, R7, B205	#@far_cmpN_branch  P=0.000001 C=-1.000000

01e0    B24: #	out( B212 B25 ) &lt;- in( B23 )  Freq: 0.998483
01e0 +  # checkcastPP of R31, #@checkCastPP
01e0    lwu  R28, [R31, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
01e4 +  #@membar_acquire
	fence ir iorw
01e8 +  decode_heap_oop  R8, R28	#@decodeHeapOop
01ec +  far_bne   R8, zr, B212	#@far_cmpP_imm0_branch  P=0.000000 C=5379.000000

01f4    B25: #	out( B170 B26 ) &lt;- in( B24 )  Freq: 0.998482
01f4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
01f4    ld  R10, [R23, #288]	# ptr, #@loadP
01f8 +  lwu  R29, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
01fc +  lwu  R7, [R31, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
0200 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0200    ld  R28, [R23, #304]	# ptr, #@loadP
0204 +  addi  R30, R10, #24	# ptr, #@addP_reg_imm
0208 +  decode_heap_oop  R12, R29	#@decodeHeapOop
020c +  decode_heap_oop  R8, R7	#@decodeHeapOop
0210 +  far_bgeu  R30, R28, B170	#@far_cmpP_branch  P=0.000100 C=-1.000000

0218    B26: #	out( B27 ) &lt;- in( B25 )  Freq: 0.998382
0218 +  li R7, #1	# long, #@loadConL
021c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
021c    sd  R30, [R23, #288]	# ptr, #@storeP
0220 +  sd  R7, [R10]	# long, #@storeL
0224 +  sw  R11, [R10, #8]	# compressed klass ptr, #@storeNKlass
0228 +  sw  zr, [R10, #12]	# int, #@storeimmI0
022c +  sd  zr, [R10, #16]	# long, #@storeimmL0

0230    B27: #	out( B248 B28 ) &lt;- in( B171 B26 )  Freq: 0.998482
0230    
0230 +  MEMBAR-store-store	#@membar_storestore
0234 +  # checkcastPP of R10, #@checkCastPP
0234    lwu  R14, [R12, #12]	# range, #@loadRange
0238    NullCheck R12

0238    B28: #	out( B270 B29 ) &lt;- in( B27 )  Freq: 0.998481
0238 +  spill R10 -&gt; [sp, #16]	# spill size = 64
023c +  spill R31 -&gt; [sp, #8]	# spill size = 64
0240 +  li R13, #0	# int, #@loadConI
0244    spill R10 -&gt; R11	# spill size = 64
0248 +  mv  R15, sun/nio/cs/UTF_8:exact *	# ptr, #@loadConP
0260    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.String::&lt;init&gt;
        # java.lang.String::&lt;init&gt; @ bci:6 (line 1380) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.Util::toString @ bci:8 (line 63) L[0]=_ STK[0]=sp + #16
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=sp + #8 STK[0]=sp + #8 STK[1]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=612/0x264}

0264    B29: #	out( B202 B30 ) &lt;- in( B28 )  Freq: 0.998461
        # Block is sole successor of call
0264 +  far_beq   R8, zr, B202	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

026c    B30: #	out( B159 B31 ) &lt;- in( B29 )  Freq: 0.99846
026c +  #@membar_release
	fence iorw ow
0270 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0270    lb  R28, [R23, #56]	# byte, #@loadB
0274 +  bne  R28, zr, B159	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0278    B31: #	out( B32 ) &lt;- in( B30 )  Freq: 0.997462
0278 +  spill [sp, #8] -&gt; R9	# spill size = 64

027c    B32: #	out( B34 B33 ) &lt;- in( B217 B161 B159 B31 )  Freq: 0.99846
027c +  mv  R7, R9	# ptr -&gt; long, #@castP2X
0280    spill [sp, #16] -&gt; R29	# spill size = 64
0284 +  mv  R28, R29	# ptr -&gt; long, #@castP2X
0288 +  xorr  R28, R28, R7	#@xorL_reg_reg
028c +  encode_heap_oop  R29, R29	#@encodeHeapOop
0290 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0294 +  sw  R29, [R9, #24]	# compressed ptr, #@storeN ! Field: volatile sun/nio/fs/UnixPath.stringValue
0298 +  beq  R28, zr, B34	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

029c    B33: #	out( B162 B34 ) &lt;- in( B32 )  Freq: 0.997462
029c +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
02a0 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
02ac +  add R10, R28, R7	# ptr, #@addP_reg_reg
02b0 +  lb  R28, [R10]	# byte, #@loadB
02b4 +  li R29, #4	# int, #@loadConI
02b8 +  bne  R28, R29, B162	#@cmpI_branch  P=0.001000 C=-1.000000

02bc    B34: #	out( B249 B35 ) &lt;- in( B164 B165 B162 B33 B32 )  Freq: 0.99846
02bc +  #@membar_volatile
	fence iorw iorw
02c0 +  lwu  R7, [R9, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
02c4 +  #@membar_acquire
	fence ir iorw
02c8 +  decode_heap_oop  R30, R7	#@decodeHeapOop
02cc    lwu  R28, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
02d0    NullCheck R30

02d0    B35: #	out( B250 B36 ) &lt;- in( B34 )  Freq: 0.998459
02d0 +  spill [sp, #0] -&gt; R29	# spill size = 64
02d4    lwu  R7, [R29, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
02d8    NullCheck R29

02d8    B36: #	out( B251 B37 ) &lt;- in( B35 )  Freq: 0.998458
02d8 +  decode_heap_oop  R31, R7	#@decodeHeapOop
02dc +  decode_heap_oop  R11, R28	#@decodeHeapOop
02e0    lwu  R28, [R11, #12]	# range, #@loadRange
02e4    NullCheck R11

02e4    B37: #	out( B252 B38 ) &lt;- in( B36 )  Freq: 0.998457
02e4 +  lb  R13, [R30, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
02e8 +  sraw  R10, R28, R13	#@rShiftI_reg_reg
02ec    lwu  R12, [R31, #12]	# range, #@loadRange
02f0    NullCheck R31

02f0    B38: #	out( B213 B39 ) &lt;- in( B37 )  Freq: 0.998456
02f0 +  lb  R14, [R29, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
02f4 +  sraw  R8, R12, R14	#@rShiftI_reg_reg
02f8 +  far_ble  R8, zr, B213	#@far_cmpI_reg_imm0_branch  P=0.000000 C=5330.000000

0300    B39: #	out( B214 B40 ) &lt;- in( B38 )  Freq: 0.998456
0300 +  li R7, #1	# int, #@loadConI
0304 +  far_bne  R8, R7, B214	#@far_cmpI_branch  P=0.000000 C=5330.000000

030c    B40: #	out( B215 B41 ) &lt;- in( B39 )  Freq: 0.998455
030c +  far_bne  R14, zr, B215	#@far_cmpI_reg_imm0_branch  P=0.000000 C=66755.000000

0314    B41: #	out( B223 B42 ) &lt;- in( B40 )  Freq: 0.998455
0314 +  far_bleu  R12, zr, B223	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000000 C=33969.000000

031c    B42: #	out( B224 B43 ) &lt;- in( B41 )  Freq: 0.998454
031c +  lbu  R12, [R31, #16]	# byte, #@loadUB
0320 +  li R28, #46	# int, #@loadConI
0324 +  far_beq  R12, R28, B224	#@far_cmpI_branch  P=0.000000 C=5376.000000

032c    B43: #	out( B216 B44 ) &lt;- in( B42 )  Freq: 0.998454
032c +  far_bne  R13, zr, B216	#@far_cmpI_reg_imm0_branch  P=0.000000 C=66755.000000

0334    B44: #	out( B269 B45 ) &lt;- in( B43 )  Freq: 0.998453
0334 +  spill R30 -&gt; R8	# spill size = 64
0338 +  li R13, #46	# int, #@loadConI
033c    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringLatin1::replace
        # java.lang.String::replace @ bci:18 (line 2801) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # java.lang.String::replace @ bci:63 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop off=832/0x340}

0340    B45: #	out( B47 B46 ) &lt;- in( B44 )  Freq: 0.998433
        # Block is sole successor of call
0340 +  beq   R10, zr, B47	#@cmpP_imm0_branch  P=0.000744 C=5376.000000

0344    B46: #	out( B47 ) &lt;- in( B45 )  Freq: 0.997691
0344 +  spill R10 -&gt; R8	# spill size = 64

0348    B47: #	out( B218 B48 ) &lt;- in( B46 B45 )  Freq: 0.998433
0348 +  lwu  R16, [R8, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
034c +  lb  R15, [R8, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0350    spill R8 -&gt; R14	# spill size = 64
0354 +  decode_heap_oop  R8, R16	#@decodeHeapOop
0358 +  far_bne  R15, zr, B218	#@far_cmpI_reg_imm0_branch  P=0.000000 C=66755.000000

0360    B48: #	out( B253 B49 ) &lt;- in( B47 )  Freq: 0.998433
0360    lwu  R12, [R8, #12]	# range, #@loadRange
0364    NullCheck R8

0364    B49: #	out( B225 B50 ) &lt;- in( B48 )  Freq: 0.998432
0364 +  far_bleu  R12, zr, B225	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000000 C=5375.000000

036c    B50: #	out( B52 B51 ) &lt;- in( B49 )  Freq: 0.998431
036c +  li R13, #46	# int, #@loadConI
0370 +  addi  R11, R8, #16	# ptr, #@addP_reg_imm
0374    StringUTF16 IndexOf char[] R11,R12,R13 -&gt; R10
0618 +  li R28, #-1	# int, #@loadConI
061c +  bne  R10, R28, B52	#@cmpI_branch  P=0.705438 C=17229.000000

0620    B51: #	out( B62 ) &lt;- in( B50 )  Freq: 0.294099
0620 +  li R29, #2	# int, #@loadConI
0624 +  li R30, #0	# int, #@loadConI
0628 +  j  B62	#@branch

062c    B52: #	out( B100 ) &lt;- in( B50 )  Freq: 0.704332
062c +  li R31, #2	# int, #@loadConI
0630 +  li R12, #0	# int, #@loadConI
0634 +  j  B100	#@branch

0638    B53: #	out( B54 ) &lt;- in( B120 )  Freq: 0.517388
0638 +  spill [sp, #8] -&gt; R13	# spill size = 32

063c    B54: #	out( B191 B55 ) &lt;- in( B133 B53 B138 ) top-of-loop Freq: 2.39055
063c +  spill [sp, #16] -&gt; R10	# spill size = 32
0640 +  addiw  R30, R10, #1	#@addI_reg_imm
0644 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0644    ld  R7, [R23, #920]	# ptr, #@loadP
0648 +  lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # jdk.internal.module.Checks::isTypeName @ bci:35 (line 135) L[0]=sp + #0 L[1]=_ L[2]=R30 L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {[0]=Oop off=1608/0x648}
064c +  spill [sp, #0] -&gt; R17	# spill size = 64
0650 +  lwu  R16, [R17, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0654 +  lb  R31, [R17, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0658 +  decode_heap_oop  R14, R16	#@decodeHeapOop
065c +  bne  R31, zr, B191	#@cmpI_reg_imm0_branch  P=0.000000 C=66755.000000

0660    B55: #	out( B243 B56 ) &lt;- in( B54 )  Freq: 2.39055
0660    lwu  R8, [R14, #12]	# range, #@loadRange
0664    NullCheck R14

0664    B56: #	out( B198 B57 ) &lt;- in( B55 )  Freq: 2.39055
0664 +  subw  R28, R8, R10	#@subI_reg_reg
0668 +  addiw  R12, R28, #-1	#@addI_reg_imm
066c +  bgeu  R30, R8, B198	#@cmpU_branch  P=0.000000 C=5375.000000

0670    B57: #	out( B176 B58 ) &lt;- in( B56 )  Freq: 2.39055
0670 +  blt  R12, zr, B176	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0674    B58: #	out( B60 B59 ) &lt;- in( B57 )  Freq: 2.39055
0674 +  spill R31 -&gt; R28	# spill size = 32
0678 +  addw  R31, R10, zr	#@convI2L_reg_reg
067c +  add R31, R14, R31	# ptr, #@addP_reg_reg
0680 +  addi  R11, R31, #17	# ptr, #@addP_reg_imm
0684    spill R10 -&gt; R7	# spill size = 32
0688 +  spill R13 -&gt; R29	# spill size = 32
068c +  li R13, #46	# int, #@loadConI
0690    StringUTF16 IndexOf char[] R11,R12,R13 -&gt; R10
0934 +  blt  R10, zr, B60	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0938    B59: #	out( B60 ) &lt;- in( B58 )  Freq: 2.38816
0938 +  addw  R31, R7, R10	#@addI_reg_reg
093c +  addiw  R10, R31, #1	#@addI_reg_imm

0940    B60: #	out( B99 B61 ) &lt;- in( B59 B58 )  Freq: 2.39055
0940 +  li R31, #-1	# int, #@loadConI
0944 +  bne  R10, R31, B99	#@cmpI_branch  P=0.705438 C=12154.000000

0948    B61: #	out( B62 ) &lt;- in( B60 )  Freq: 0.704163
0948 +  spill R17 -&gt; R14	# spill size = 64
094c +  spill R28 -&gt; R15	# spill size = 32

0950    B62: #	out( B219 B63 ) &lt;- in( B61 B51 )  Freq: 0.998262
0950 +  decode_heap_oop  R11, R16	#@decodeHeapOop
0954 +  lwu  R28, [R11, #12]	# range, #@loadRange
0958 +  sraw  R8, R28, R15	#@rShiftI_reg_reg
095c +  blt  R30, zr, B219	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

0960    B63: #	out( B226 B64 ) &lt;- in( B62 )  Freq: 0.998262
0960 +  bgt  R30, R8, B226	#@cmpI_branch  P=0.000000 C=5375.000000

0964    B64: #	out( B66 B65 ) &lt;- in( B63 )  Freq: 0.998261
0964 +  bne  R30, zr, B66	#@cmpI_reg_imm0_branch  P=0.627790 C=5376.000000

0968    B65: #	out( B70 ) &lt;- in( B64 )  Freq: 0.371563
0968 +  spill R14 -&gt; R10	# spill size = 64
096c +  j  B70	#@branch

0970    B66: #	out( B232 B67 ) &lt;- in( B64 )  Freq: 0.626699
0970 +  subw  R13, R8, R30	#@subI_reg_reg
0974 +  far_bne  R15, zr, B232	#@far_cmpI_reg_imm0_branch  P=0.000000 C=66755.000000

097c    B67: #	out( B267 B68 ) &lt;- in( B66 )  Freq: 0.626698
097c +  spill R29 -&gt; [sp, #0]	# spill size = 32
0980 +  spill R14 -&gt; R8	# spill size = 64
0984 +  spill R30 -&gt; R12	# spill size = 32
0988    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringLatin1::newString
        # java.lang.String::substring @ bci:41 (line 2707) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isTypeName @ bci:40 (line 136) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=2444/0x98c}

098c    B68: #	out( B211 B69 ) &lt;- in( B67 )  Freq: 0.626686
        # Block is sole successor of call
098c +  beq   R10, zr, B211	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

0990    B69: #	out( B70 ) &lt;- in( B68 )  Freq: 0.626685
0990 +  spill R8 -&gt; R14	# spill size = 64
0994 +  spill [sp, #0] -&gt; R29	# spill size = 32

0998    B70: #	out( B254 B71 ) &lt;- in( B65 B69 )  Freq: 0.998248
0998 +  lwu  R28, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
099c +  decode_heap_oop  R7, R28	#@decodeHeapOop
09a0    lwu  R8, [R7, #12]	# range, #@loadRange
09a4    NullCheck R7

09a4    B71: #	out( B227 B72 ) &lt;- in( B70 )  Freq: 0.998247
09a4 +  bleu  R8, zr, B227	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=8568.000000

09a8    B72: #	out( B268 B73 ) &lt;- in( B71 )  Freq: 0.998246
09a8 +  spill R10 -&gt; R8	# spill size = 64
09ac +  spill R29 -&gt; [sp, #8]	# spill size = 32
09b0 +  spill R14 -&gt; [sp, #0]	# spill size = 64
09b4 +  mv  R11, java/util/ImmutableCollections$SetN:exact *	# ptr, #@loadConP
09cc    spill R10 -&gt; R12	# spill size = 64
09d0    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.ImmutableCollections$SetN::probe
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {fp=Oop [0]=Oop off=2516/0x9d4}

09d4    B73: #	out( B228 B74 ) &lt;- in( B72 )  Freq: 0.998226
        # Block is sole successor of call
09d4 +  spill R8 -&gt; R30	# spill size = 64
09d8 +  lwu  R7, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
09dc +  lb  R28, [R30, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
09e0 +  decode_heap_oop  R12, R7	#@decodeHeapOop
09e4 +  bge  R10, zr, B228	#@cmpI_reg_imm0_branch  P=0.000000 C=8453.000000

09e8    B74: #	out( B220 B75 ) &lt;- in( B73 )  Freq: 0.998226
09e8 +  bne  R28, zr, B220	#@cmpI_reg_imm0_branch  P=0.000000 C=66755.000000

09ec    B75: #	out( B255 B76 ) &lt;- in( B74 )  Freq: 0.998225
09ec    lwu  R31, [R12, #12]	# range, #@loadRange
09f0    NullCheck R12

09f0    B76: #	out( B229 B77 ) &lt;- in( B75 )  Freq: 0.998224
09f0 +  bleu  R31, zr, B229	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=33969.000000

09f4    B77: #	out( B221 B78 ) &lt;- in( B76 )  Freq: 0.998224
09f4 +  lbu  R14, [R12, #16]	# byte, #@loadUB
09f8 +  addw  R7, R14, zr	#@convI2L_reg_reg
09fc +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0a00 +  mv  R10, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058ba80&gt; *	# ptr, #@loadConP
0a18 +  mv  R29, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058ba80&gt; *	# ptr, #@loadConP
0a30 +  add R7, R10, R7	# ptr, #@addP_reg_reg
0a34 +  sraw  R10, R31, R28	#@rShiftI_reg_reg
0a38 +  lw  R29, [R7, #16]	# int, #@loadI
0a3c +  li R28, #28672	# int, #@loadConI
0a40 +  li R7, #20480	# int, #@loadConI
0a44 +  andr  R8, R29, R28	#@andI_reg_reg
0a48 +  blt  R8, R7, B221	#@cmpI_branch  P=0.000000 C=5376.000000

0a4c    B78: #	out( B95 B79 ) &lt;- in( B77 )  Freq: 0.998223
0a4c +  li R28, #1	# int, #@loadConI
0a50 +  ble  R10, R28, B95	#@cmpI_branch  P=0.216422 C=37852.000000

0a54    B79: #	out( B208 B80 ) &lt;- in( B78 )  Freq: 0.782186
0a54 +  li R7, #1	# int, #@loadConI
0a58 +  bleu  R31, R7, B208	#@cmpU_branch  P=0.000001 C=-1.000000

0a5c    B80: #	out( B208 B81 ) &lt;- in( B79 )  Freq: 0.782185
0a5c +  li R28, #-2147483648	# int, #@loadConI
0a60 +  addiw  R11, R10, #-1	#@addI_reg_imm
0a64    CMove R11, (R10 lt R11), R11, R28	#@cmovI_cmpI
	
0a6c +  addw  R7, R10, zr	#@convI2L_reg_reg
0a70 +  addw  R28, R31, zr	#@convI2L_reg_reg
0a74 +  addi  R7, R7, #-1	#@addL_reg_imm
0a78 +  bgeu  R7, R28, B208	#@cmpUL_branch  P=0.000001 C=-1.000000

0a7c    B81: #	out( B157 B82 ) &lt;- in( B80 )  Freq: 0.782184
0a7c +  lbu  R7, [R12, #17]	# byte, #@loadUB2L
0a80 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0a84 +  mv  R29, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058ba80&gt; *	# ptr, #@loadConP
0a9c +  mv  R28, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058ba80&gt; *	# ptr, #@loadConP
0ab4 +  add R7, R29, R7	# ptr, #@addP_reg_reg
0ab8 +  lw  R28, [R7, #16]	# int, #@loadI
0abc +  li R7, #12288	# int, #@loadConI
0ac0 +  andr  R7, R28, R7	#@andI_reg_reg
0ac4 +  beq  R7, zr, B157	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

0ac8    B82: #	out( B90 B83 ) &lt;- in( B81 )  Freq: 0.782158
0ac8 +  spill [sp, #8] -&gt; R29	# spill size = 32
0acc +  ble  R11, R29, B90	#@cmpI_branch  P=0.000001 C=-1.000000

0ad0    B83: #	out( B209 B84 ) &lt;- in( B82 )  Freq: 0.782157
0ad0 +  bleu  R31, R29, B209	#@cmpU_branch  P=0.000001 C=-1.000000

0ad4    B84: #	out( B210 B85 ) &lt;- in( B83 )  Freq: 0.782156
0ad4 +  li R28, #3	# int, #@loadConI
0ad8 +  bleu  R31, R28, B210	#@cmpU_branch  P=0.000001 C=-1.000000

0adc    B85: #	out( B86 ) &lt;- in( B84 B89 ) Loop( B85-B89 ) Freq: 3.60996
0adc +  li R7, #0	# int, #@loadConI
0ae0 +  subw  R28, R11, R29	#@subI_reg_reg
0ae4    CMove R28, (R11 lt R29), R28, R7	#@cmovI_cmpI
	
0aec +  li R7, #2000	# int, #@loadConI
0af0 +  li R13, #2000	# int, #@loadConI
0af4    CMove R28, (R28 gtu R13), R28, R7	#@cmovI_cmpU
	
0afc +  addw  R14, R28, R29	#@addI_reg_reg

0b00    B86: #	out( B157 B87 ) &lt;- in( B85 B88 ) Loop( B86-B88 inner main of N1157 strip mined) Freq: 16.6761
0b00 +  addw  R7, R29, zr	#@convI2L_reg_reg
0b04 +  add R7, R12, R7	# ptr, #@addP_reg_reg
0b08 +  lbu  R28, [R7, #16]	# byte, #@loadUB2L
0b0c +  lbu  R7, [R7, #17]	# byte, #@loadUB2L
0b10 +  slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0b14 +  mv  R15, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058ba80&gt; *	# ptr, #@loadConP
0b2c +  mv  R13, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058ba80&gt; *	# ptr, #@loadConP
0b44 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0b48 +  add R28, R15, R28	# ptr, #@addP_reg_reg
0b4c +  add R7, R15, R7	# ptr, #@addP_reg_reg
0b50 +  lw  R28, [R28, #16]	# int, #@loadI
0b54 +  lw  R13, [R7, #16]	# int, #@loadI
0b58 +  li R15, #12288	# int, #@loadConI
0b5c +  andr  R7, R28, R15	#@andI_reg_reg
0b60 +  li R28, #12288	# int, #@loadConI
0b64 +  andr  R13, R13, R28	#@andI_reg_reg
0b68 +  beq  R7, zr, B157	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

0b6c    B87: #	out( B157 B88 ) &lt;- in( B86 )  Freq: 16.6756
0b6c +  beq  R13, zr, B157	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

0b70    B88: #	out( B86 B89 ) &lt;- in( B87 )  Freq: 16.675
0b70 +  addiw  R29, R29, #2	#@addI_reg_imm
0b74 +  blt  R29, R14, B86	#@cmpI_loop  P=0.783578 C=29660.000000

0b78    B89: #	out( B85 B90 ) &lt;- in( B88 )  Freq: 3.60883
0b78 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0b78    ld  R13, [R23, #920]	# ptr, #@loadP
0b7c +  lwu zr, [R13]	# Safepoint: poll for GC, #@safePoint        # jdk.internal.module.Checks::isJavaIdentifier @ bci:71 (line 185) L[0]=R30 L[1]=_ L[2]=R29 L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {x30=Oop c_rarg2=Oop [0]=Oop off=2940/0xb7c}
0b80 +  blt  R29, R11, B85	#@cmpI_branch  P=0.783578 C=29660.000000

0b84    B90: #	out( B95 B91 ) &lt;- in( B82 B89 )  Freq: 0.781031
0b84 +  bge  R29, R10, B95	#@cmpI_branch  P=0.500000 C=-1.000000

0b88    B91: #	out( B230 B92 ) &lt;- in( B90 )  Freq: 0.390516
0b88 +  # castII of R29, #@castII
0b88    bgeu  R29, R31, B230	#@cmpU_branch  P=0.000001 C=-1.000000

0b8c    B92: #	out( B231 B93 ) &lt;- in( B91 )  Freq: 0.390515
0b8c +  spill R29 -&gt; R7	# spill size = 32
0b90 +  # castII of R7, #@castII
0b90    bgeu  R7, R31, B231	#@cmpU_branch  P=0.000001 C=-1.000000

0b94    B93: #	out( B157 B94 ) &lt;- in( B92 B94 ) Loop( B93-B94 inner post of N1668) Freq: 0.781003
0b94 +  addw  R7, R29, zr	#@convI2L_reg_reg
0b98 +  add R7, R12, R7	# ptr, #@addP_reg_reg
0b9c +  lbu  R7, [R7, #16]	# byte, #@loadUB2L
0ba0 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0ba4 +  mv  R30, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058ba80&gt; *	# ptr, #@loadConP
0bbc +  mv  R28, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058ba80&gt; *	# ptr, #@loadConP
0bd4 +  add R7, R30, R7	# ptr, #@addP_reg_reg
0bd8 +  lw  R28, [R7, #16]	# int, #@loadI
0bdc +  li R30, #12288	# int, #@loadConI
0be0 +  andr  R7, R28, R30	#@andI_reg_reg
0be4 +  beq  R7, zr, B157	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

0be8    B94: #	out( B93 B95 ) &lt;- in( B93 )  Freq: 0.780977
0be8 +  addiw  R29, R29, #1	#@addI_reg_imm
0bec +  blt  R29, R10, B93	#@cmpI_loop  P=0.500000 C=29660.000000

0bf0    B95: #	out( B172 B96 ) &lt;- in( B90 B78 B94 )  Freq: 0.997041
0bf0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0bf0    ld  R10, [R23, #288]	# ptr, #@loadP
0bf4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0bf4    ld  R7, [R23, #304]	# ptr, #@loadP
0bf8 +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
0bfc +  bgeu  R28, R7, B172	#@cmpP_branch  P=0.000100 C=-1.000000

0c00    B96: #	out( B97 ) &lt;- in( B95 )  Freq: 0.996942
0c00 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c00    sd  R28, [R23, #288]	# ptr, #@storeP
0c04 +  li R7, #1	# long, #@loadConL
0c08 +  mv  R28, narrowklass: precise klass java/util/Optional: 0x00000040d06f85a0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0c18 +  sd  R7, [R10]	# long, #@storeL
0c1c +  sw  R28, [R10, #8]	# compressed klass ptr, #@storeNKlass
0c20 +  sw  zr, [R10, #12]	# int, #@storeimmI0

0c24    B97: #	out( B98 ) &lt;- in( B173 B96 )  Freq: 0.997041
0c24    spill [sp, #0] -&gt; R7	# spill size = 64
0c28 +  encode_heap_oop  R7, R7	#@encodeHeapOop
0c2c    
0c2c +  # checkcastPP of R10, #@checkCastPP
0c2c    sw  R7, [R10, #12]	# compressed ptr, #@storeN ! Field: java/util/Optional.value
0c30 +  #@membar_release
	fence iorw ow

0c34    B98: #	out( N2589 ) &lt;- in( B97 B157 )  Freq: 0.999708
0c34    # pop frame 96
	add  sp, sp, #96
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0c4c +  ret	// return register, #@Ret

0c50    B99: #	out( B100 ) &lt;- in( B60 )  Freq: 1.68638
0c50 +  spill R17 -&gt; R14	# spill size = 64
0c54 +  spill R29 -&gt; R31	# spill size = 32
0c58 +  spill R30 -&gt; R12	# spill size = 32

0c5c    B100: #	out( B240 B101 ) &lt;- in( B52 B99 ) Loop( B100-B99 ) Freq: 2.39076
0c5c +  decode_heap_oop  R11, R16	#@decodeHeapOop
0c60    lwu  R28, [R11, #12]	# range, #@loadRange
0c64    NullCheck R11

0c64    B101: #	out( B188 B102 ) &lt;- in( B100 )  Freq: 2.39076
0c64 +  lb  R29, [R14, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0c68 +  sraw  R8, R28, R29	#@rShiftI_reg_reg
0c6c +  blt  R12, zr, B188	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

0c70    B102: #	out( B193 B103 ) &lt;- in( B101 )  Freq: 2.39076
0c70 +  bgt  R12, R10, B193	#@cmpI_branch  P=0.000000 C=5375.000000

0c74    B103: #	out( B194 B104 ) &lt;- in( B102 )  Freq: 2.39076
0c74 +  bgt  R10, R8, B194	#@cmpI_branch  P=0.000000 C=5375.000000

0c78    B104: #	out( B107 B105 ) &lt;- in( B103 )  Freq: 2.39076
0c78 +  bne  R12, zr, B107	#@cmpI_reg_imm0_branch  P=0.627790 C=5376.000000

0c7c    B105: #	out( B139 B106 ) &lt;- in( B104 )  Freq: 0.889863
0c7c +  beq  R10, R8, B139	#@cmpI_branch  P=0.011494 C=2001.000000

0c80    B106: #	out( B108 ) &lt;- in( B105 )  Freq: 0.879635
0c80 +  li R12, #0	# int, #@loadConI
0c84    spill R10 -&gt; R13	# spill size = 32
0c88 +  j  B108	#@branch

0c8c    B107: #	out( B108 ) &lt;- in( B104 )  Freq: 1.50089
0c8c +  subw  R13, R10, R12	#@subI_reg_reg

0c90    B108: #	out( B192 B109 ) &lt;- in( B106 B107 )  Freq: 2.38053
0c90 +  bne  R29, zr, B192	#@cmpI_reg_imm0_branch  P=0.000000 C=66755.000000

0c94    B109: #	out( B275 B110 ) &lt;- in( B108 )  Freq: 2.38053
0c94 +  spill R10 -&gt; [sp, #4]	# spill size = 32
0c98 +  spill R31 -&gt; [sp, #0]	# spill size = 32
0c9c +  spill R14 -&gt; R8	# spill size = 64
0ca0    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringLatin1::newString
        # java.lang.String::substring @ bci:41 (line 2707) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=R8 L[1]=sp + #4 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=3236/0xca4}

0ca4    B110: #	out( B175 B111 ) &lt;- in( B109 )  Freq: 2.38048
        # Block is sole successor of call
0ca4 +  beq   R10, zr, B175	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

0ca8    B111: #	out( B112 ) &lt;- in( B110 )  Freq: 2.38048
0ca8 +  spill R10 -&gt; R29	# spill size = 64
0cac +  spill R8 -&gt; R14	# spill size = 64
0cb0 +  spill [sp, #0] -&gt; R31	# spill size = 32
0cb4 +  spill [sp, #4] -&gt; R10	# spill size = 32

0cb8    B112: #	out( B241 B113 ) &lt;- in( B139 B111 )  Freq: 2.39071
0cb8 +  lwu  R28, [R29, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0cbc +  decode_heap_oop  R7, R28	#@decodeHeapOop
0cc0    lwu  R8, [R7, #12]	# range, #@loadRange
0cc4    NullCheck R7

0cc4    B113: #	out( B195 B114 ) &lt;- in( B112 )  Freq: 2.3907
0cc4 +  bleu  R8, zr, B195	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=8568.000000

0cc8    B114: #	out( B274 B115 ) &lt;- in( B113 )  Freq: 2.3907
0cc8 +  spill R29 -&gt; R8	# spill size = 64
0ccc +  spill R10 -&gt; [sp, #16]	# spill size = 32
0cd0 +  spill R31 -&gt; [sp, #8]	# spill size = 32
0cd4 +  spill R14 -&gt; [sp, #0]	# spill size = 64
0cd8 +  mv  R11, java/util/ImmutableCollections$SetN:exact *	# ptr, #@loadConP
0cf0    spill R29 -&gt; R12	# spill size = 64
0cf4    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.ImmutableCollections$SetN::probe
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {fp=Oop [0]=Oop off=3320/0xcf8}

0cf8    B115: #	out( B196 B116 ) &lt;- in( B114 )  Freq: 2.39065
        # Block is sole successor of call
0cf8 +  spill R8 -&gt; R31	# spill size = 64
0cfc +  lwu  R7, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0d00 +  lb  R28, [R31, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0d04 +  decode_heap_oop  R12, R7	#@decodeHeapOop
0d08 +  bge  R10, zr, B196	#@cmpI_reg_imm0_branch  P=0.000000 C=8453.000000

0d0c    B116: #	out( B189 B117 ) &lt;- in( B115 )  Freq: 2.39065
0d0c +  bne  R28, zr, B189	#@cmpI_reg_imm0_branch  P=0.000000 C=66755.000000

0d10    B117: #	out( B242 B118 ) &lt;- in( B116 )  Freq: 2.39065
0d10    lwu  R29, [R12, #12]	# range, #@loadRange
0d14    NullCheck R12

0d14    B118: #	out( B197 B119 ) &lt;- in( B117 )  Freq: 2.39065
0d14 +  bleu  R29, zr, B197	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=33969.000000

0d18    B119: #	out( B190 B120 ) &lt;- in( B118 )  Freq: 2.39065
0d18 +  lbu  R13, [R12, #16]	# byte, #@loadUB
0d1c +  addw  R7, R13, zr	#@convI2L_reg_reg
0d20 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0d24 +  mv  R10, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058ba80&gt; *	# ptr, #@loadConP
0d3c +  mv  R30, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058ba80&gt; *	# ptr, #@loadConP
0d54 +  add R7, R10, R7	# ptr, #@addP_reg_reg
0d58 +  lw  R30, [R7, #16]	# int, #@loadI
0d5c +  sraw  R10, R29, R28	#@rShiftI_reg_reg
0d60 +  li R7, #28672	# int, #@loadConI
0d64 +  li R28, #20480	# int, #@loadConI
0d68 +  andr  R8, R30, R7	#@andI_reg_reg
0d6c +  blt  R8, R28, B190	#@cmpI_branch  P=0.000000 C=5376.000000

0d70    B120: #	out( B53 B121 ) &lt;- in( B119 )  Freq: 2.39065
0d70 +  li R7, #1	# int, #@loadConI
0d74 +  ble  R10, R7, B53	#@cmpI_branch  P=0.216422 C=37852.000000

0d78    B121: #	out( B177 B122 ) &lt;- in( B120 )  Freq: 1.87326
0d78 +  addw  R7, R10, zr	#@convI2L_reg_reg
0d7c +  li R11, #1	# int, #@loadConI
0d80 +  addw  R28, R29, zr	#@convI2L_reg_reg
0d84 +  addi  R7, R7, #-1	#@addL_reg_imm
0d88 +  bleu  R29, R11, B177	#@cmpU_branch  P=0.000001 C=-1.000000

0d8c    B122: #	out( B177 B123 ) &lt;- in( B121 )  Freq: 1.87326
0d8c +  bgeu  R7, R28, B177	#@cmpUL_branch  P=0.000001 C=-1.000000

0d90    B123: #	out( B174 B124 ) &lt;- in( B122 )  Freq: 1.87325
0d90 +  lbu  R7, [R12, #17]	# byte, #@loadUB2L
0d94 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0d98 +  mv  R30, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058ba80&gt; *	# ptr, #@loadConP
0db0 +  mv  R28, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058ba80&gt; *	# ptr, #@loadConP
0dc8 +  add R7, R30, R7	# ptr, #@addP_reg_reg
0dcc +  lw  R28, [R7, #16]	# int, #@loadI
0dd0 +  li R7, #12288	# int, #@loadConI
0dd4 +  andr  R28, R28, R7	#@andI_reg_reg
0dd8 +  beq  R28, zr, B174	#@cmpI_reg_imm0_branch  P=0.000001 C=29661.000000

0ddc    B124: #	out( B178 B125 ) &lt;- in( B123 )  Freq: 1.87325
0ddc +  li R28, #-2147483648	# int, #@loadConI
0de0 +  addiw  R11, R10, #-1	#@addI_reg_imm
0de4    CMove R11, (R10 lt R11), R11, R28	#@cmovI_cmpI
	
0dec +  spill [sp, #8] -&gt; R13	# spill size = 32
0df0 +  ble  R11, R13, B178	#@cmpI_branch  P=0.000001 C=-1.000000

0df4    B125: #	out( B179 B126 ) &lt;- in( B124 )  Freq: 1.87325
0df4 +  bleu  R29, R13, B179	#@cmpU_branch  P=0.000001 C=-1.000000

0df8    B126: #	out( B180 B127 ) &lt;- in( B125 )  Freq: 1.87325
0df8 +  li R7, #3	# int, #@loadConI
0dfc +  bleu  R29, R7, B180	#@cmpU_branch  P=0.000001 C=-1.000000

0e00    B127: #	out( B128 ) &lt;- in( B126 )  Freq: 1.87325
0e00 +  li R15, #2	# int, #@loadConI

0e04    B128: #	out( B129 ) &lt;- in( B127 B132 ) Loop( B128-B132 ) Freq: 8.65524
0e04 +  li R30, #0	# int, #@loadConI
0e08 +  subw  R7, R11, R15	#@subI_reg_reg
0e0c    CMove R7, (R11 lt R15), R7, R30	#@cmovI_cmpI
	
0e14 +  li R14, #2000	# int, #@loadConI
0e18 +  li R28, #2000	# int, #@loadConI
0e1c    CMove R7, (R7 gtu R28), R7, R14	#@cmovI_cmpU
	
0e24 +  addw  R7, R7, R15	#@addI_reg_reg
        nop 	# 4 bytes pad for loops and calls

0e30    B129: #	out( B174 B130 ) &lt;- in( B128 B131 ) Loop( B129-B131 inner main of N993 strip mined) Freq: 39.9922
0e30 +  addw  R28, R15, zr	#@convI2L_reg_reg
0e34 +  add R28, R12, R28	# ptr, #@addP_reg_reg
0e38 +  lbu  R30, [R28, #16]	# byte, #@loadUB2L
0e3c +  lbu  R28, [R28, #17]	# byte, #@loadUB2L
0e40 +  slli  R30, R30, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0e44 +  mv  R16, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058ba80&gt; *	# ptr, #@loadConP
0e5c +  mv  R14, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058ba80&gt; *	# ptr, #@loadConP
0e74 +  slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0e78 +  add R30, R16, R30	# ptr, #@addP_reg_reg
0e7c +  add R28, R16, R28	# ptr, #@addP_reg_reg
0e80 +  lw  R14, [R28, #16]	# int, #@loadI
0e84 +  lw  R30, [R30, #16]	# int, #@loadI
0e88 +  li R28, #12288	# int, #@loadConI
0e8c +  li R16, #12288	# int, #@loadConI
0e90 +  andr  R28, R30, R28	#@andI_reg_reg
0e94 +  andr  R14, R14, R16	#@andI_reg_reg
0e98 +  beq  R28, zr, B174	#@cmpI_reg_imm0_branch  P=0.000001 C=29661.000000

0e9c    B130: #	out( B174 B131 ) &lt;- in( B129 )  Freq: 39.9921
0e9c +  beq  R14, zr, B174	#@cmpI_reg_imm0_branch  P=0.000001 C=29661.000000

0ea0    B131: #	out( B129 B132 ) &lt;- in( B130 )  Freq: 39.9921
0ea0 +  addiw  R15, R15, #2	#@addI_reg_imm
0ea4 +  blt  R15, R7, B129	#@cmpI_loop  P=0.783578 C=29660.000000

0ea8    B132: #	out( B128 B133 ) &lt;- in( B131 )  Freq: 8.65516
0ea8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0ea8    ld  R28, [R23, #920]	# ptr, #@loadP
0eac +  lwu zr, [R28]	# Safepoint: poll for GC, #@safePoint        # jdk.internal.module.Checks::isJavaIdentifier @ bci:71 (line 185) L[0]=R31 L[1]=_ L[2]=R15 L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {xmethod=Oop c_rarg2=Oop [0]=Oop off=3756/0xeac}
0eb0 +  blt  R15, R11, B128	#@cmpI_branch  P=0.783578 C=29660.000000

0eb4    B133: #	out( B54 B134 ) &lt;- in( B178 B132 )  Freq: 1.87317
0eb4 +  bge  R15, R10, B54	#@cmpI_branch  P=0.500000 C=-1.000000

0eb8    B134: #	out( B206 B135 ) &lt;- in( B133 )  Freq: 0.936584
0eb8 +  # castII of R15, #@castII
0eb8    bgeu  R15, R29, B206	#@cmpU_branch  P=0.000001 C=-1.000000

0ebc    B135: #	out( B207 B136 ) &lt;- in( B134 )  Freq: 0.936583
0ebc +  spill R15 -&gt; R7	# spill size = 32
0ec0 +  # castII of R7, #@castII
0ec0    bgeu  R7, R29, B207	#@cmpU_branch  P=0.000001 C=-1.000000

0ec4    B136: #	out( B174 B137 ) &lt;- in( B135 B137 ) Loop( B136-B137 inner post of N1657) Freq: 1.87316
0ec4 +  addw  R7, R15, zr	#@convI2L_reg_reg
0ec8 +  add R7, R12, R7	# ptr, #@addP_reg_reg
0ecc +  lbu  R7, [R7, #16]	# byte, #@loadUB2L
0ed0 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0ed4 +  mv  R29, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058ba80&gt; *	# ptr, #@loadConP
0eec +  mv  R28, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058ba80&gt; *	# ptr, #@loadConP
0f04 +  add R7, R29, R7	# ptr, #@addP_reg_reg
0f08 +  lw  R28, [R7, #16]	# int, #@loadI
0f0c +  li R7, #12288	# int, #@loadConI
0f10 +  andr  R7, R28, R7	#@andI_reg_reg
0f14 +  beq  R7, zr, B174	#@cmpI_reg_imm0_branch  P=0.000001 C=29661.000000

0f18    B137: #	out( B136 B138 ) &lt;- in( B136 )  Freq: 1.87316
0f18 +  addiw  R15, R15, #1	#@addI_reg_imm
0f1c +  blt  R15, R10, B136	#@cmpI_loop  P=0.500000 C=29660.000000

0f20    B138: #	out( B54 ) &lt;- in( B137 )  Freq: 0.93658
0f20 +  j  B54	#@branch

0f24    B139: #	out( B112 ) &lt;- in( B105 )  Freq: 0.0102283
0f24 +  spill R14 -&gt; R29	# spill size = 64
0f28 +  j  B112	#@branch

0f2c    B140: #	out( B264 B141 ) &lt;- in( B8 )  Freq: 0.00148859
0f2c +  spill [sp, #8] -&gt; R11	# spill size = 64
0f30 +  spill R11 -&gt; R8	# spill size = 64
0f34    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::getRoot
        # sun.nio.fs.UnixPath::getParent @ bci:32 (line 286) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=R8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=3896/0xf38}

0f38    B141: #	out( B22 ) &lt;- in( B140 )  Freq: 0.00148856
        # Block is sole successor of call
0f38 +  spill R10 -&gt; R31	# spill size = 64
0f3c +  j  B22	#@branch

0f40    B142: #	out( B238 B143 ) &lt;- in( B22 )  Freq: 0.00148858
0f40 +  spill [sp, #8] -&gt; R7	# spill size = 64
0f44 +  lwu  R28, [R7, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
0f48 +  #@membar_acquire
	fence ir iorw
0f4c +  decode_heap_oop  R8, R28	#@decodeHeapOop
0f50 +  bne   R8, zr, B238	#@cmpP_imm0_branch  P=0.000000 C=5379.000000

0f54    B143: #	out( B233 B144 ) &lt;- in( B142 )  Freq: 0.00148858
0f54 +  spill [sp, #8] -&gt; R28	# spill size = 64
0f58 +  lwu  R29, [R28, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
0f5c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0f5c    ld  R10, [R23, #288]	# ptr, #@loadP
0f60 +  lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
0f64 +  decode_heap_oop  R8, R29	#@decodeHeapOop
0f68 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0f68    ld  R28, [R23, #304]	# ptr, #@loadP
0f6c +  addi  R30, R10, #24	# ptr, #@addP_reg_imm
0f70 +  decode_heap_oop  R29, R7	#@decodeHeapOop
0f74 +  bgeu  R30, R28, B233	#@cmpP_branch  P=0.000100 C=-1.000000

0f78    B144: #	out( B145 ) &lt;- in( B143 )  Freq: 0.00148844
0f78 +  li R7, #1	# long, #@loadConL
0f7c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0f7c    sd  R30, [R23, #288]	# ptr, #@storeP
0f80 +  sd  R7, [R10]	# long, #@storeL
0f84 +  sw  R11, [R10, #8]	# compressed klass ptr, #@storeNKlass
0f88 +  sw  zr, [R10, #12]	# int, #@storeimmI0
0f8c +  sd  zr, [R10, #16]	# long, #@storeimmL0

0f90    B145: #	out( B256 B146 ) &lt;- in( B234 B144 )  Freq: 0.00148858
0f90    
0f90 +  MEMBAR-store-store	#@membar_storestore
0f94 +  spill R10 -&gt; R7	# spill size = 64
0f98 +  # checkcastPP of R7, #@checkCastPP
0f98    lwu  R14, [R29, #12]	# range, #@loadRange
0f9c    NullCheck R29

0f9c    B146: #	out( B265 B147 ) &lt;- in( B145 )  Freq: 0.00148858
0f9c +  spill R7 -&gt; [sp, #16]	# spill size = 64
0fa0 +  spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
0fa8 +  spill [sp, #16] -&gt; R11	# spill size = 64
0fac +  li R13, #0	# int, #@loadConI
0fb0    spill R29 -&gt; R12	# spill size = 64
0fb4 +  mv  R15, sun/nio/cs/UTF_8:exact *	# ptr, #@loadConP
0fcc    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.String::&lt;init&gt;
        # java.lang.String::&lt;init&gt; @ bci:6 (line 1380) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.Util::toString @ bci:8 (line 63) L[0]=_ STK[0]=sp + #16
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=sp + #0 STK[0]=sp + #0 STK[1]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:35 (line 747) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=4048/0xfd0}

0fd0    B147: #	out( B235 B148 ) &lt;- in( B146 )  Freq: 0.00148855
        # Block is sole successor of call
0fd0 +  beq   R8, zr, B235	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

0fd4    B148: #	out( B181 B149 ) &lt;- in( B147 )  Freq: 0.00148855
0fd4 +  #@membar_release
	fence iorw ow
0fd8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0fd8    lb  R7, [R23, #56]	# byte, #@loadB
0fdc +  bne  R7, zr, B181	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0fe0    B149: #	out( B150 ) &lt;- in( B148 )  Freq: 0.00148706
0fe0 +  spill [sp, #0] -&gt; R9	# spill size = 64

0fe4    B150: #	out( B152 B151 ) &lt;- in( B239 B183 B181 B149 )  Freq: 0.00148855
0fe4 +  mv  R28, R9	# ptr -&gt; long, #@castP2X
0fe8    spill [sp, #16] -&gt; R29	# spill size = 64
0fec +  mv  R7, R29	# ptr -&gt; long, #@castP2X
0ff0 +  xorr  R7, R7, R28	#@xorL_reg_reg
0ff4 +  encode_heap_oop  R30, R29	#@encodeHeapOop
0ff8 +  srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0ffc +  sw  R30, [R9, #24]	# compressed ptr, #@storeN ! Field: volatile sun/nio/fs/UnixPath.stringValue
1000 +  beq  R7, zr, B152	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1004    B151: #	out( B184 B152 ) &lt;- in( B150 )  Freq: 0.00148706
1004 +  srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1008 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1014 +  add R10, R28, R7	# ptr, #@addP_reg_reg
1018 +  lb  R7, [R10]	# byte, #@loadB
101c +  li R29, #4	# int, #@loadConI
1020 +  bne  R7, R29, B184	#@cmpI_branch  P=0.001000 C=-1.000000

1024    B152: #	out( B236 B153 ) &lt;- in( B186 B187 B184 B151 B150 )  Freq: 0.00148855
1024 +  #@membar_volatile
	fence iorw iorw
1028 +  lwu  R28, [R9, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
102c +  #@membar_acquire
	fence ir iorw
1030 +  decode_heap_oop  R8, R28	#@decodeHeapOop
1034 +  beq   R8, zr, B236	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

1038    B153: #	out( B263 B154 ) &lt;- in( B152 )  Freq: 0.00148855
1038 +  mv  R12, java/lang/String:exact *	# ptr, #@loadConP
1050    spill R8 -&gt; R11	# spill size = 64
1054    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.String::endsWith
        # jdk.internal.module.ModulePath::toPackageName @ bci:47 (line 748) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=4184/0x1058}

1058    B154: #	out( B157 B155 ) &lt;- in( B153 )  Freq: 0.00148852
        # Block is sole successor of call
1058 +  beq  R10, zr, B157	#@cmpI_reg_imm0_branch  P=0.100000 C=-1.000000

105c    B155: #	out( B262 B156 ) &lt;- in( B154 )  Freq: 0.00133967
105c +  mv  R12, java/lang/String:exact *	# ptr, #@loadConP
1074    spill R8 -&gt; R11	# spill size = 64
1078    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.String::equals
        # jdk.internal.module.ModulePath::toPackageName @ bci:57 (line 748) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=4220/0x107c}

107c    B156: #	out( B237 B157 ) &lt;- in( B155 )  Freq: 0.00133964
        # Block is sole successor of call
107c +  beq  R10, zr, B237	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

1080    B157: #	out( B98 ) &lt;- in( B93 B87 B81 B86 B156 B154 )  Freq: 0.00266639
1080 +  mv  R10, java/util/Optional:exact *	# ptr, #@loadConP
1098 +  j  B98	#@branch

109c    B158: #	out( B19 ) &lt;- in( B17 )  Freq: 0.000998483
109c +  addw  R30, R8, zr	#@convI2L_reg_reg
10a0 +  addi  R28, R30, #15	#@addL_reg_imm
10a4 +  srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
10a8 +  andi  R28, R28, #-8	#@andL_reg_imm
10ac +  add R28, R9, R28	# ptr, #@addP_reg_reg
10b0 +  sub  R29, R7, R29	#@subL_reg_reg
10b4    ClearArray R29, R28	#@clearArray_reg_reg
110c +  addi  R12, R30, #-1	#@addL_reg_imm
1110    CALL, runtime leaf nofp 0x000000401396cf00	#@CallLeafNoFPDirect arrayof_jbyte_disjoint_arraycopy
        No JVM State Info
        # 
1114 +  j  B19	#@branch

1118    B159: #	out( B32 B160 ) &lt;- in( B30 )  Freq: 0.000998447
1118 +  spill [sp, #8] -&gt; R9	# spill size = 64
111c +  lwu  R7, [R9, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
1120 +  decode_heap_oop  R10, R7	#@decodeHeapOop
1124 +  beq   R10, zr, B32	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1128    B160: #	out( B217 B161 ) &lt;- in( B159 )  Freq: 0.000499224
1128 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1128    ld  R7, [R23, #32]	# int, #@loadL
112c +  beq  R7, zr, B217	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1130    B161: #	out( B32 ) &lt;- in( B160 )  Freq: 0.000498725
1130 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1130    ld  R28, [R23, #48]	# ptr, #@loadP
1134 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1138 +  addi  R7, R7, #-8	#@addL_reg_imm
113c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1140 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1140    sd  R7, [R23, #32]	# long, #@storeL
1144 +  j  B32	#@branch

1148    B162: #	out( B34 B163 ) &lt;- in( B33 )  Freq: 0.000997462
1148 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1148    ld  R7, [R23, #64]	# int, #@loadL
114c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
114c    ld  R28, [R23, #80]	# ptr, #@loadP
1150 +  #@membar_volatile
	fence iorw iorw
1154 +  lb  R29, [R10]	# byte, #@loadB
1158 +  beq  R29, zr, B34	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

115c    B163: #	out( B165 B164 ) &lt;- in( B162 )  Freq: 0.000498731
115c +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1160 +  bne  R7, zr, B165	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1164    B164: #	out( B34 ) &lt;- in( B163 )  Freq: 0.000249365
1164 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1164    spill R23 -&gt; R11	# spill size = 64
1168 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1198 +  j  B34	#@branch

119c    B165: #	out( B34 ) &lt;- in( B163 )  Freq: 0.000249365
119c +  add R28, R28, R7	# ptr, #@addP_reg_reg
11a0 +  addi  R7, R7, #-8	#@addL_reg_imm
11a4 +  sd  R10, [R28, #-8]	# ptr, #@storeP
11a8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
11a8    sd  R7, [R23, #64]	# long, #@storeL
11ac +  j  B34	#@branch

11b0    B166: #	out( B260 B167 ) &lt;- in( B19 )  Freq: 9.9865e-05
11b0 +  spill R18 -&gt; [sp, #24]	# spill size = 32
11b4 +  spill R9 -&gt; [sp, #16]	# spill size = 64
11b8 +  spill [sp, #8] -&gt; R8	# spill size = 64
11bc +  mv  R11, precise klass sun/nio/fs/UnixPath: 0x00000040d06f9290:Constant:exact *	# ptr, #@loadConP
11d4    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixPath::getParent @ bci:51 (line 290) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #16
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=R8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=NarrowOop off=4568/0x11d8}

11d8    B167: #	out( B21 ) &lt;- in( B166 )  Freq: 9.9863e-05
        # Block is sole successor of call
11d8 +  spill [sp, #24] -&gt; R18	# spill size = 32
11dc +  spill R10 -&gt; R31	# spill size = 64
11e0 +  j  B21	#@branch

11e4    B168: #	out( B261 B169 ) &lt;- in( B13 B14 )  Freq: 0.000100877
11e4 +  spill R31 -&gt; [sp, #40]	# spill size = 64
11e8 +  spill R30 -&gt; [sp, #32]	# spill size = 64
11ec +  spill R10 -&gt; [sp, #24]	# spill size = 64
11f0 +  spill R29 -&gt; [sp, #16]	# spill size = 32
11f4 +  mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
120c    spill R29 -&gt; R12	# spill size = 32
1210    CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=sp + #8 L[1]=_ L[2]=sp + #16 L[3]=_
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=sp + #8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {[0]=Oop [8]=Oop [24]=Oop off=4628/0x1214}

1214    B169: #	out( B16 ) &lt;- in( B168 )  Freq: 0.000100875
        # Block is sole successor of call
1214 +  spill R10 -&gt; R9	# spill size = 64
1218 +  spill [sp, #16] -&gt; R29	# spill size = 32
121c +  spill [sp, #24] -&gt; R10	# spill size = 64
1220 +  spill [sp, #32] -&gt; R30	# spill size = 64
1224 +  spill [sp, #40] -&gt; R31	# spill size = 64
1228 +  j  B16	#@branch

122c    B170: #	out( B259 B171 ) &lt;- in( B25 )  Freq: 9.98648e-05
122c +  spill R12 -&gt; [sp, #16]	# spill size = 64
1230 +  spill R31 -&gt; [sp, #8]	# spill size = 64
1234 +  mv  R11, precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# ptr, #@loadConP
124c    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.Util::toString @ bci:0 (line 63) L[0]=sp + #16
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=sp + #8 STK[0]=sp + #8 STK[1]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=4688/0x1250}

1250    B171: #	out( B27 ) &lt;- in( B170 )  Freq: 9.98628e-05
        # Block is sole successor of call
1250 +  spill [sp, #8] -&gt; R31	# spill size = 64
1254 +  spill [sp, #16] -&gt; R12	# spill size = 64
1258 +  j  B27	#@branch

125c    B172: #	out( B258 B173 ) &lt;- in( B95 )  Freq: 9.97207e-05
125c +  mv  R11, precise klass java/util/Optional: 0x00000040d06f85a0:Constant:exact *	# ptr, #@loadConP
1274    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.Optional::of @ bci:0 (line 113) L[0]=sp + #0
        # jdk.internal.module.ModulePath::toPackageName @ bci:125 (line 758) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {[0]=Oop off=4728/0x1278}

1278    B173: #	out( B97 ) &lt;- in( B172 )  Freq: 9.97187e-05
        # Block is sole successor of call
1278 +  j  B97	#@branch

127c    B174: #	out( N2589 ) &lt;- in( B136 B130 B123 B129 )  Freq: 8.48426e-05
127c +  li R11, #-187	# int, #@loadConI
1280    spill [sp, #0] -&gt; R8	# spill size = 64
1284    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # jdk.internal.module.Checks::isTypeName @ bci:26 (line 132) L[0]=R8 L[1]=sp + #16 L[2]=_ L[3]=_ STK[0]=#0
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=4744/0x1288}
1288    #@ShouldNotReachHere

1294    B175: #	out( N2589 ) &lt;- in( B110 )  Freq: 2.41209e-06
1294 +  li R11, #-10	# int, #@loadConI
1298    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=4764/0x129c}
129c    #@ShouldNotReachHere

12a8    B176: #	out( N2589 ) &lt;- in( B57 )  Freq: 2.39055e-06
12a8 +  li R11, #-50	# int, #@loadConI
12ac    spill R14 -&gt; [sp, #24]	# spill size = 64
12b0 +  spill R30 -&gt; [sp, #20]	# spill size = 32
12b4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::indexOf @ bci:32 (line 213) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #24 STK[1]=#46 STK[2]=sp + #20 STK[3]=R8
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=sp + #0 L[1]=_ L[2]=sp + #20 L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {[0]=Oop [24]=Oop off=4792/0x12b8}
12b8    #@ShouldNotReachHere

12c4    B177: #	out( N2589 ) &lt;- in( B122 B121 )  Freq: 3.77139e-06
12c4 +  spill [sp, #16] -&gt; R28	# spill size = 32
12c8 +  li R11, #-138	# int, #@loadConI
12cc    spill [sp, #0] -&gt; R8	# spill size = 64
12d0 +  spill R28 -&gt; [sp, #8]	# spill size = 32
12d4 +  spill R31 -&gt; [sp, #16]	# spill size = 64
12d8 +  spill R10 -&gt; [sp, #12]	# spill size = 32
12dc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:46 (line 180) L[0]=sp + #16 L[1]=_ L[2]=#1 L[3]=_ STK[0]=#1 STK[1]=sp + #12
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop [16]=Oop off=4832/0x12e0}
12e0    #@ShouldNotReachHere

12ec    B178: #	out( B133 ) &lt;- in( B124 )  Freq: 1.89813e-06
12ec +  li R15, #2	# int, #@loadConI
12f0 +  j  B133	#@branch

12f4    B179: #	out( N2589 ) &lt;- in( B125 )  Freq: 1.87325e-06
12f4    #@ShouldNotReachHere

1300    B180: #	out( N2589 ) &lt;- in( B126 )  Freq: 1.87325e-06
1300    #@ShouldNotReachHere

130c    B181: #	out( B150 B182 ) &lt;- in( B148 )  Freq: 1.48853e-06
130c +  spill [sp, #0] -&gt; R9	# spill size = 64
1310 +  lwu  R28, [R9, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
1314 +  decode_heap_oop  R10, R28	#@decodeHeapOop
1318 +  beq   R10, zr, B150	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

131c    B182: #	out( B239 B183 ) &lt;- in( B181 )  Freq: 7.44266e-07
131c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
131c    ld  R7, [R23, #32]	# int, #@loadL
1320 +  beq  R7, zr, B239	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1324    B183: #	out( B150 ) &lt;- in( B182 )  Freq: 7.43522e-07
1324 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1324    ld  R28, [R23, #48]	# ptr, #@loadP
1328 +  add R28, R28, R7	# ptr, #@addP_reg_reg
132c +  addi  R7, R7, #-8	#@addL_reg_imm
1330 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1334 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1334    sd  R7, [R23, #32]	# long, #@storeL
1338 +  j  B150	#@branch

133c    B184: #	out( B152 B185 ) &lt;- in( B151 )  Freq: 1.48706e-06
133c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
133c    ld  R7, [R23, #64]	# int, #@loadL
1340 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1340    ld  R28, [R23, #80]	# ptr, #@loadP
1344 +  #@membar_volatile
	fence iorw iorw
1348 +  lb  R30, [R10]	# byte, #@loadB
134c +  beq  R30, zr, B152	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1350    B185: #	out( B187 B186 ) &lt;- in( B184 )  Freq: 7.43531e-07
1350 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1354 +  bne  R7, zr, B187	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1358    B186: #	out( B152 ) &lt;- in( B185 )  Freq: 3.71766e-07
1358 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1358    spill R23 -&gt; R11	# spill size = 64
135c +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
138c +  j  B152	#@branch

1390    B187: #	out( B152 ) &lt;- in( B185 )  Freq: 3.71766e-07
1390 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1394 +  addi  R7, R7, #-8	#@addL_reg_imm
1398 +  sd  R10, [R28, #-8]	# ptr, #@storeP
139c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
139c    sd  R7, [R23, #64]	# long, #@storeL
13a0 +  j  B152	#@branch

13a4    B188: #	out( N2589 ) &lt;- in( B101 )  Freq: 1.19538e-06
13a4 +  li R11, #-187	# int, #@loadConI
13a8    spill R14 -&gt; [sp, #8]	# spill size = 64
13ac +  spill R14 -&gt; [sp, #24]	# spill size = 64
13b0 +  spill R10 -&gt; [sp, #20]	# spill size = 32
13b4 +  spill R10 -&gt; [sp, #32]	# spill size = 32
13b8 +  spill R12 -&gt; [sp, #40]	# spill size = 32
13bc +  spill R12 -&gt; [sp, #44]	# spill size = 32
13c0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:1 (line 4598) L[0]=sp + #44 L[1]=sp + #20 L[2]=R8 STK[0]=sp + #40
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #8 L[1]=sp + #40 L[2]=sp + #32 L[3]=R8 L[4]=_
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=sp + #24 L[1]=sp + #20 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #8 L[5]=_
        # OopMap {[8]=Oop [24]=Oop off=5060/0x13c4}
13c4    #@ShouldNotReachHere

13d0    B189: #	out( N2589 ) &lt;- in( B116 )  Freq: 1.19533e-06
13d0 +  spill [sp, #16] -&gt; R7	# spill size = 32
13d4 +  li R11, #-187	# int, #@loadConI
13d8    spill [sp, #0] -&gt; R8	# spill size = 64
13dc +  spill R7 -&gt; [sp, #8]	# spill size = 32
13e0 +  spill R31 -&gt; [sp, #24]	# spill size = 64
13e4 +  spill R31 -&gt; [sp, #32]	# spill size = 64
13e8 +  spill R28 -&gt; [sp, #12]	# spill size = 32
13ec    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #12
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=sp + #24 L[1]=#0
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #32 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=sp + #24 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop [24]=Oop [32]=Oop off=5104/0x13f0}
13f0    #@ShouldNotReachHere

13fc    B190: #	out( N2589 ) &lt;- in( B119 )  Freq: 1.19532e-06
13fc +  li R11, #-187	# int, #@loadConI
1400    spill R31 -&gt; [sp, #24]	# spill size = 64
1404 +  spill R13 -&gt; [sp, #20]	# spill size = 32
1408    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.CharacterDataLatin1::isJavaIdentifierStart @ bci:14 (line 116) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8 STK[1]=#20480
        # java.lang.Character::isJavaIdentifierStart @ bci:5 (line 10070) L[0]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:28 (line 176) L[0]=sp + #24 L[1]=sp + #20 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {[0]=Oop [24]=Oop off=5132/0x140c}
140c    #@ShouldNotReachHere

1418    B191: #	out( N2589 ) &lt;- in( B54 )  Freq: 1.19528e-06
1418 +  li R11, #-187	# int, #@loadConI
141c    spill R17 -&gt; [sp, #8]	# spill size = 64
1420 +  spill R30 -&gt; [sp, #20]	# spill size = 32
1424 +  spill R31 -&gt; [sp, #24]	# spill size = 32
1428    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #24
        # java.lang.String::indexOf @ bci:1 (line 2416) L[0]=sp + #0 L[1]=#46 L[2]=sp + #20
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=sp + #0 L[1]=_ L[2]=sp + #20 L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #8 L[5]=_
        # OopMap {[0]=Oop [8]=Oop off=5164/0x142c}
142c    #@ShouldNotReachHere

1438    B192: #	out( N2589 ) &lt;- in( B108 )  Freq: 1.19026e-06
1438 +  li R11, #-187	# int, #@loadConI
143c    spill R14 -&gt; [sp, #0]	# spill size = 64
1440 +  spill R10 -&gt; [sp, #8]	# spill size = 32
1444 +  spill R14 -&gt; [sp, #16]	# spill size = 64
1448 +  spill R12 -&gt; [sp, #12]	# spill size = 32
144c +  spill R13 -&gt; [sp, #24]	# spill size = 32
1450 +  spill R29 -&gt; [sp, #28]	# spill size = 32
1454    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #28
        # java.lang.String::substring @ bci:28 (line 2707) L[0]=sp + #0 L[1]=sp + #12 L[2]=_ L[3]=_ L[4]=sp + #24
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=sp + #16 L[1]=sp + #8 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {[0]=Oop [16]=Oop off=5208/0x1458}
1458    #@ShouldNotReachHere

1464    B193: #	out( N2589 ) &lt;- in( B102 )  Freq: 1.14e-06
1464 +  li R11, #-187	# int, #@loadConI
1468    spill R14 -&gt; [sp, #8]	# spill size = 64
146c +  spill R14 -&gt; [sp, #24]	# spill size = 64
1470 +  spill R10 -&gt; [sp, #20]	# spill size = 32
1474 +  spill R10 -&gt; [sp, #32]	# spill size = 32
1478 +  spill R12 -&gt; [sp, #44]	# spill size = 32
147c +  spill R12 -&gt; [sp, #48]	# spill size = 32
1480    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:6 (line 4598) L[0]=sp + #48 L[1]=sp + #20 L[2]=R8 STK[0]=sp + #44 STK[1]=sp + #20
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #8 L[1]=sp + #44 L[2]=sp + #32 L[3]=R8 L[4]=_
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=sp + #24 L[1]=sp + #20 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #8 L[5]=_
        # OopMap {[8]=Oop [24]=Oop off=5252/0x1484}
1484    #@ShouldNotReachHere

1490    B194: #	out( N2589 ) &lt;- in( B103 )  Freq: 1.14e-06
1490 +  li R11, #-187	# int, #@loadConI
1494    spill R14 -&gt; [sp, #8]	# spill size = 64
1498 +  spill R14 -&gt; [sp, #24]	# spill size = 64
149c +  spill R10 -&gt; [sp, #20]	# spill size = 32
14a0 +  spill R10 -&gt; [sp, #32]	# spill size = 32
14a4 +  spill R12 -&gt; [sp, #44]	# spill size = 32
14a8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:11 (line 4598) L[0]=sp + #44 L[1]=sp + #20 L[2]=R8 STK[0]=sp + #20 STK[1]=R8
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #8 L[1]=sp + #44 L[2]=sp + #32 L[3]=R8 L[4]=_
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=sp + #24 L[1]=sp + #20 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #8 L[5]=_
        # OopMap {[8]=Oop [24]=Oop off=5292/0x14ac}
14ac    #@ShouldNotReachHere

14b8    B195: #	out( N2589 ) &lt;- in( B113 )  Freq: 1.13998e-06
14b8 +  li R11, #-187	# int, #@loadConI
14bc    spill R14 -&gt; [sp, #8]	# spill size = 64
14c0 +  spill R10 -&gt; [sp, #16]	# spill size = 32
14c4 +  spill R29 -&gt; [sp, #24]	# spill size = 64
14c8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isEmpty @ bci:5 (line 1487) L[0]=_ STK[0]=R8
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=sp + #24 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #8 L[5]=_
        # OopMap {[8]=Oop [24]=Oop off=5324/0x14cc}
14cc    #@ShouldNotReachHere

14d8    B196: #	out( N2589 ) &lt;- in( B115 )  Freq: 1.13995e-06
14d8 +  spill [sp, #16] -&gt; R28	# spill size = 32
14dc +  li R11, #-187	# int, #@loadConI
14e0    spill [sp, #0] -&gt; R8	# spill size = 64
14e4 +  spill R28 -&gt; [sp, #8]	# spill size = 32
14e8 +  spill R31 -&gt; [sp, #16]	# spill size = 64
14ec +  spill R10 -&gt; [sp, #12]	# spill size = 32
14f0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::contains @ bci:17 (line 938) L[0]=_ L[1]=_ STK[0]=sp + #12
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop [16]=Oop off=5364/0x14f4}
14f4    #@ShouldNotReachHere

1500    B197: #	out( N2589 ) &lt;- in( B118 )  Freq: 1.13995e-06
1500 +  spill [sp, #16] -&gt; R28	# spill size = 32
1504 +  li R11, #-187	# int, #@loadConI
1508    spill [sp, #0] -&gt; R8	# spill size = 64
150c +  spill R28 -&gt; [sp, #8]	# spill size = 32
1510 +  spill R31 -&gt; [sp, #24]	# spill size = 64
1514 +  spill R12 -&gt; [sp, #32]	# spill size = 64
1518 +  spill R29 -&gt; [sp, #12]	# spill size = 32
151c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:7 (line 47) L[0]=sp + #32 L[1]=#0 STK[0]=#0 STK[1]=sp + #12
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #24 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=sp + #24 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop [24]=Oop [32]=Oop off=5408/0x1520}
1520    #@ShouldNotReachHere

152c    B198: #	out( N2589 ) &lt;- in( B56 )  Freq: 1.1399e-06
152c +  li R11, #-27	# int, #@loadConI
1530    spill R14 -&gt; [sp, #24]	# spill size = 64
1534 +  spill R30 -&gt; [sp, #20]	# spill size = 32
1538 +  spill R30 -&gt; [sp, #32]	# spill size = 32
153c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::indexOf @ bci:13 (line 207) L[0]=sp + #24 L[1]=#46 L[2]=sp + #32 L[3]=R8 STK[0]=sp + #20
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=sp + #0 L[1]=_ L[2]=sp + #20 L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {[0]=Oop [24]=Oop off=5440/0x1540}
1540    #@ShouldNotReachHere

154c    B199: #	out( N2589 ) &lt;- in( B7 )  Freq: 1.01325e-06
154c +  li R11, #-28	# int, #@loadConI
1550    spill R31 -&gt; [sp, #24]	# spill size = 64
1554    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:23 (line 283) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #24 STK[1]=R8
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=sp + #8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {[0]=Oop [8]=Oop [24]=Oop off=5464/0x1558}
1558    #@ShouldNotReachHere

1564    B200: #	out( B11 ) &lt;- in( B9 )  Freq: 1.01174e-06
1564 +  addw  R7, R29, zr	#@convI2L_reg_reg
1568 +  j  B11	#@branch

156c    B201: #	out( B19 ) &lt;- in( B16 )  Freq: 1.01174e-06
156c +  spill R11 -&gt; R28	# spill size = 64
1570 +  addi  R29, R7, #-2	#@addL_reg_imm
1574    ClearArray R29, R28	#@clearArray_reg_reg
15cc    
15cc +  j  B19	#@branch

15d0    B202: #	out( N2589 ) &lt;- in( B29 )  Freq: 1.01172e-06
15d0 +  li R11, #-10	# int, #@loadConI
15d4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::toString @ bci:19 (line 757) L[0]=_ STK[0]=_ STK[1]=#NULL STK[2]=sp + #16
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {[16]=Oop off=5592/0x15d8}
15d8    #@ShouldNotReachHere

15e4    B203: #	out( N2589 ) &lt;- in( B2 )  Freq: 9.99999e-07
15e4 +  li R11, #-34	# int, #@loadConI
15e8    spill R12 -&gt; [sp, #8]	# spill size = 64
15ec    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=sp + #8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #8
        # OopMap {[0]=Oop [8]=Oop off=5616/0x15f0}
15f0    #@ShouldNotReachHere

15fc    B204: #	out( N2589 ) &lt;- in( B12 )  Freq: 9.98485e-07
15fc +  li R11, #-52	# int, #@loadConI
1600    spill [sp, #8] -&gt; R8	# spill size = 64
1604 +  spill R29 -&gt; [sp, #20]	# spill size = 32
1608    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=R8 L[1]=_ L[2]=sp + #20 L[3]=_ STK[0]=sp + #20
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=R8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=5644/0x160c}
160c    #@ShouldNotReachHere

1618    B205: #	out( N2589 ) &lt;- in( B23 )  Freq: 9.98484e-07
1618 +  li R11, #-34	# int, #@loadConI
161c    spill R31 -&gt; R8	# spill size = 64
1620    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_ STK[0]=R8
        # OopMap {fp=Oop [0]=Oop off=5668/0x1624}
1624    #@ShouldNotReachHere

1630    B206: #	out( N2589 ) &lt;- in( B134 )  Freq: 9.49021e-07
1630    #@ShouldNotReachHere

163c    B207: #	out( N2589 ) &lt;- in( B135 )  Freq: 9.4902e-07
163c    #@ShouldNotReachHere

1648    B208: #	out( N2589 ) &lt;- in( B80 B79 )  Freq: 1.57476e-06
1648 +  spill [sp, #0] -&gt; R8	# spill size = 64
164c +  li R11, #-138	# int, #@loadConI
1650    spill R30 -&gt; [sp, #0]	# spill size = 64
1654 +  spill R10 -&gt; [sp, #8]	# spill size = 32
1658    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:46 (line 180) L[0]=sp + #0 L[1]=_ L[2]=#1 L[3]=_ STK[0]=#1 STK[1]=sp + #8
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop [0]=Oop off=5724/0x165c}
165c    #@ShouldNotReachHere

1668    B209: #	out( N2589 ) &lt;- in( B83 )  Freq: 7.82157e-07
1668    #@ShouldNotReachHere

1674    B210: #	out( N2589 ) &lt;- in( B84 )  Freq: 7.82156e-07
1674    #@ShouldNotReachHere

1680    B211: #	out( N2589 ) &lt;- in( B68 )  Freq: 6.35007e-07
1680 +  li R11, #-10	# int, #@loadConI
1684    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=5768/0x1688}
1688    #@ShouldNotReachHere

1694    B212: #	out( N2589 ) &lt;- in( B24 )  Freq: 4.99241e-07
1694 +  li R11, #-187	# int, #@loadConI
1698    spill R31 -&gt; [sp, #8]	# spill size = 64
169c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::toString @ bci:4 (line 756) L[0]=sp + #8 STK[0]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=5792/0x16a0}
16a0    #@ShouldNotReachHere

16ac    B213: #	out( N2589 ) &lt;- in( B38 )  Freq: 4.99228e-07
16ac +  li R11, #-187	# int, #@loadConI
16b0    spill R30 -&gt; [sp, #0]	# spill size = 64
16b4 +  spill R29 -&gt; [sp, #8]	# spill size = 64
16b8 +  spill R10 -&gt; [sp, #16]	# spill size = 32
16bc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:36 (line 2959) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=sp + #8 L[4]=#Ptr0x00000040d06fbfd0 L[5]=sp + #16 L[6]=R8 L[7]=#1 L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {[0]=Oop [8]=Oop off=5824/0x16c0}
16c0    #@ShouldNotReachHere

16cc    B214: #	out( N2589 ) &lt;- in( B39 )  Freq: 4.99228e-07
16cc +  li R11, #-187	# int, #@loadConI
16d0    spill R30 -&gt; [sp, #0]	# spill size = 64
16d4 +  spill R29 -&gt; [sp, #8]	# spill size = 64
16d8 +  spill R10 -&gt; [sp, #16]	# spill size = 32
16dc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:42 (line 2960) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=sp + #8 L[4]=#Ptr0x00000040d06fbfd0 L[5]=sp + #16 L[6]=R8 L[7]=#1 L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=R8 STK[1]=#1
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {[0]=Oop [8]=Oop off=5856/0x16e0}
16e0    #@ShouldNotReachHere

16ec    B215: #	out( N2589 ) &lt;- in( B40 )  Freq: 4.99228e-07
16ec +  li R11, #-187	# int, #@loadConI
16f0    spill R30 -&gt; R8	# spill size = 64
16f4 +  spill R14 -&gt; [sp, #8]	# spill size = 32
16f8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #8
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=sp + #0 L[1]=#0
        # java.lang.String::replace @ bci:54 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=#Ptr0x00000040d06fbfd0 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=5884/0x16fc}
16fc    #@ShouldNotReachHere

1708    B216: #	out( N2589 ) &lt;- in( B43 )  Freq: 4.99227e-07
1708 +  li R11, #-187	# int, #@loadConI
170c    spill R30 -&gt; R8	# spill size = 64
1710 +  spill R12 -&gt; [sp, #0]	# spill size = 32
1714 +  spill R13 -&gt; [sp, #4]	# spill size = 32
1718    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #4
        # java.lang.String::replace @ bci:6 (line 2801) L[0]=R8 L[1]=sp + #0 L[2]=#46 L[3]=_
        # java.lang.String::replace @ bci:63 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop off=5916/0x171c}
171c    #@ShouldNotReachHere

1728    B217: #	out( B32 ) &lt;- in( B160 )  Freq: 4.99217e-07
1728 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1728    spill R23 -&gt; R11	# spill size = 64
172c +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
175c +  j  B32	#@branch

1760    B218: #	out( N2589 ) &lt;- in( B47 )  Freq: 4.99217e-07
1760 +  li R11, #-187	# int, #@loadConI
1764    spill R14 -&gt; R8	# spill size = 64
1768 +  spill R15 -&gt; [sp, #16]	# spill size = 32
176c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #16
        # java.lang.String::indexOf @ bci:1 (line 2416) L[0]=R8 L[1]=#46 L[2]=#0
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=R8 L[1]=_ L[2]=#0 L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=6000/0x1770}
1770    #@ShouldNotReachHere

177c    B219: #	out( N2589 ) &lt;- in( B62 )  Freq: 4.99131e-07
177c +  li R11, #-187	# int, #@loadConI
1780    spill R14 -&gt; [sp, #8]	# spill size = 64
1784 +  spill R30 -&gt; [sp, #20]	# spill size = 32
1788 +  spill R30 -&gt; [sp, #24]	# spill size = 32
178c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:1 (line 4598) L[0]=sp + #24 L[1]=R8 L[2]=R8 STK[0]=sp + #20
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #8 L[1]=sp + #20 L[2]=R8 L[3]=R8 L[4]=_
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isTypeName @ bci:40 (line 136) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #8 L[5]=_
        # OopMap {[8]=Oop off=6032/0x1790}
1790    #@ShouldNotReachHere

179c    B220: #	out( N2589 ) &lt;- in( B74 )  Freq: 4.99113e-07
179c +  li R11, #-187	# int, #@loadConI
17a0    spill [sp, #0] -&gt; R8	# spill size = 64
17a4 +  spill R30 -&gt; [sp, #8]	# spill size = 64
17a8 +  spill R30 -&gt; [sp, #16]	# spill size = 64
17ac +  spill R28 -&gt; [sp, #24]	# spill size = 32
17b0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #24
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=sp + #8 L[1]=#0
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #16 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=6068/0x17b4}
17b4    #@ShouldNotReachHere

17c0    B221: #	out( N2589 ) &lt;- in( B77 )  Freq: 4.99112e-07
17c0 +  li R11, #-187	# int, #@loadConI
17c4    spill R30 -&gt; [sp, #8]	# spill size = 64
17c8 +  spill R14 -&gt; [sp, #16]	# spill size = 32
17cc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.CharacterDataLatin1::isJavaIdentifierStart @ bci:14 (line 116) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8 STK[1]=#20480
        # java.lang.Character::isJavaIdentifierStart @ bci:5 (line 10070) L[0]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:28 (line 176) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {[0]=Oop [8]=Oop off=6096/0x17d0}
17d0    #@ShouldNotReachHere

17dc    B222: #	out( N2589 ) &lt;- in( B5 )  Freq: 4.76826e-07
17dc +  li R11, #-187	# int, #@loadConI
17e0    spill R30 -&gt; [sp, #20]	# spill size = 32
17e4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:11 (line 279) L[0]=R8 L[1]=sp + #20 L[2]=_ L[3]=_ STK[0]=sp + #20
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=R8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=6120/0x17e8}
17e8    #@ShouldNotReachHere

17f4    B223: #	out( N2589 ) &lt;- in( B41 )  Freq: 4.761e-07
17f4 +  li R11, #-187	# int, #@loadConI
17f8    spill R30 -&gt; R8	# spill size = 64
17fc +  spill R31 -&gt; [sp, #0]	# spill size = 64
1800 +  spill R12 -&gt; [sp, #8]	# spill size = 32
1804    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:7 (line 47) L[0]=sp + #0 L[1]=#0 STK[0]=#0 STK[1]=sp + #8
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.String::replace @ bci:54 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=#Ptr0x00000040d06fbfd0 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=6152/0x1808}
1808    #@ShouldNotReachHere

1814    B224: #	out( N2589 ) &lt;- in( B42 )  Freq: 4.761e-07
1814 +  li R11, #-187	# int, #@loadConI
1818    spill R30 -&gt; R8	# spill size = 64
181c +  spill R12 -&gt; [sp, #4]	# spill size = 32
1820    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:2 (line 2800) L[0]=R8 L[1]=sp + #4 L[2]=#46 L[3]=_ STK[0]=sp + #4 STK[1]=#46
        # java.lang.String::replace @ bci:63 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop off=6180/0x1824}
1824    #@ShouldNotReachHere

1830    B225: #	out( N2589 ) &lt;- in( B49 )  Freq: 4.76089e-07
1830 +  li R11, #-187	# int, #@loadConI
1834    spill R14 -&gt; [sp, #8]	# spill size = 64
1838 +  spill R12 -&gt; [sp, #20]	# spill size = 32
183c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::indexOf @ bci:23 (line 209) L[0]=R8 L[1]=#46 L[2]=#0 L[3]=sp + #20 STK[0]=#0 STK[1]=sp + #20
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=sp + #8 L[1]=_ L[2]=#0 L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #8 L[5]=_
        # OopMap {fp=Oop [8]=Oop off=6208/0x1840}
1840    #@ShouldNotReachHere

184c    B226: #	out( N2589 ) &lt;- in( B63 )  Freq: 4.76008e-07
184c +  li R11, #-187	# int, #@loadConI
1850    spill R14 -&gt; [sp, #8]	# spill size = 64
1854 +  spill R30 -&gt; [sp, #20]	# spill size = 32
1858 +  spill R30 -&gt; [sp, #24]	# spill size = 32
185c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:6 (line 4598) L[0]=sp + #24 L[1]=R8 L[2]=R8 STK[0]=sp + #20 STK[1]=R8
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #8 L[1]=sp + #20 L[2]=R8 L[3]=R8 L[4]=_
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isTypeName @ bci:40 (line 136) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #8 L[5]=_
        # OopMap {[8]=Oop off=6240/0x1860}
1860    #@ShouldNotReachHere

186c    B227: #	out( N2589 ) &lt;- in( B71 )  Freq: 4.76001e-07
186c +  li R11, #-187	# int, #@loadConI
1870    spill R14 -&gt; [sp, #0]	# spill size = 64
1874 +  spill R10 -&gt; [sp, #8]	# spill size = 64
1878    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isEmpty @ bci:5 (line 1487) L[0]=_ STK[0]=R8
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {[0]=Oop [8]=Oop off=6268/0x187c}
187c    #@ShouldNotReachHere

1888    B228: #	out( N2589 ) &lt;- in( B73 )  Freq: 4.75991e-07
1888 +  spill [sp, #0] -&gt; R8	# spill size = 64
188c +  li R11, #-187	# int, #@loadConI
1890    spill R30 -&gt; [sp, #0]	# spill size = 64
1894 +  spill R10 -&gt; [sp, #8]	# spill size = 32
1898    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::contains @ bci:17 (line 938) L[0]=_ L[1]=_ STK[0]=sp + #8
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop [0]=Oop off=6300/0x189c}
189c    #@ShouldNotReachHere

18a8    B229: #	out( N2589 ) &lt;- in( B76 )  Freq: 4.7599e-07
18a8 +  li R11, #-187	# int, #@loadConI
18ac    spill [sp, #0] -&gt; R8	# spill size = 64
18b0 +  spill R30 -&gt; [sp, #8]	# spill size = 64
18b4 +  spill R12 -&gt; [sp, #16]	# spill size = 64
18b8 +  spill R31 -&gt; [sp, #24]	# spill size = 32
18bc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:7 (line 47) L[0]=sp + #16 L[1]=#0 STK[0]=#0 STK[1]=sp + #24
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #8 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=6336/0x18c0}
18c0    #@ShouldNotReachHere

18cc    B230: #	out( N2589 ) &lt;- in( B91 )  Freq: 3.95701e-07
18cc    #@ShouldNotReachHere

18d8    B231: #	out( N2589 ) &lt;- in( B92 )  Freq: 3.95701e-07
18d8    #@ShouldNotReachHere

18e4    B232: #	out( N2589 ) &lt;- in( B66 )  Freq: 3.13349e-07
18e4 +  li R11, #-187	# int, #@loadConI
18e8    spill R14 -&gt; [sp, #0]	# spill size = 64
18ec +  spill R30 -&gt; [sp, #8]	# spill size = 32
18f0 +  spill R13 -&gt; [sp, #12]	# spill size = 32
18f4 +  spill R15 -&gt; [sp, #16]	# spill size = 32
18f8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #16
        # java.lang.String::substring @ bci:28 (line 2707) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=_ L[4]=sp + #12
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isTypeName @ bci:40 (line 136) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {[0]=Oop off=6396/0x18fc}
18fc    #@ShouldNotReachHere

1908    B233: #	out( B257 B234 ) &lt;- in( B143 )  Freq: 1.48883e-07
1908 +  spill R29 -&gt; [sp, #16]	# spill size = 64
190c +  spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
1914 +  mv  R11, precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# ptr, #@loadConP
192c    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.Util::toString @ bci:0 (line 63) L[0]=sp + #16
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=sp + #0 STK[0]=sp + #0 STK[1]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:35 (line 747) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=6448/0x1930}

1930    B234: #	out( B145 ) &lt;- in( B233 )  Freq: 1.4888e-07
        # Block is sole successor of call
1930 +  spill [sp, #16] -&gt; R29	# spill size = 64
1934 +  j  B145	#@branch

1938    B235: #	out( N2589 ) &lt;- in( B147 )  Freq: 1.50832e-09
1938 +  li R11, #-10	# int, #@loadConI
193c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::toString @ bci:19 (line 757) L[0]=_ STK[0]=_ STK[1]=#NULL STK[2]=sp + #16
        # jdk.internal.module.ModulePath::toPackageName @ bci:35 (line 747) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {[16]=Oop off=6464/0x1940}
1940    #@ShouldNotReachHere

194c    B236: #	out( N2589 ) &lt;- in( B152 )  Freq: 1.50832e-09
194c +  li R11, #-10	# int, #@loadConI
1950    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:47 (line 748) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL STK[1]=#Ptr0x00000040d06fd030
        # OopMap {off=6484/0x1954}
1954    #@ShouldNotReachHere

1960    B237: #	out( N2589 ) &lt;- in( B156 )  Freq: 1.35743e-09
1960 +  li R11, #238	# int, #@loadConI
1964    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos; index=&apos;238&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:63 (line 749) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=6504/0x1968}
1968    #@ShouldNotReachHere

1974    B238: #	out( N2589 ) &lt;- in( B142 )  Freq: 7.44292e-10
1974 +  li R11, #-187	# int, #@loadConI
1978    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::toString @ bci:4 (line 756) L[0]=sp + #8 STK[0]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:35 (line 747) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [8]=Oop off=6524/0x197c}
197c    #@ShouldNotReachHere

1988    B239: #	out( B150 ) &lt;- in( B182 )  Freq: 7.44257e-10
1988 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1988    spill R23 -&gt; R11	# spill size = 64
198c +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
19bc +  j  B150	#@branch

19c0    B240: #	out( N2589 ) &lt;- in( B100 )  Freq: 2.42251e-06
19c0 +  li R11, #-10	# int, #@loadConI
19c4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::substring @ bci:1 (line 2701) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6600/0x19c8}
19c8    #@ShouldNotReachHere

19d4    B241: #	out( N2589 ) &lt;- in( B112 )  Freq: 2.42245e-06
19d4 +  li R11, #-10	# int, #@loadConI
19d8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::isEmpty @ bci:4 (line 1487) L[0]=_ STK[0]=#NULL
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6620/0x19dc}
19dc    #@ShouldNotReachHere

19e8    B242: #	out( N2589 ) &lt;- in( B117 )  Freq: 2.4224e-06
19e8 +  li R11, #-10	# int, #@loadConI
19ec    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::charAt @ bci:6 (line 47) L[0]=_ L[1]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6640/0x19f0}
19f0    #@ShouldNotReachHere

19fc    B243: #	out( N2589 ) &lt;- in( B55 )  Freq: 2.4223e-06
19fc +  li R11, #-10	# int, #@loadConI
1a00    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::indexOf @ bci:10 (line 206) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6660/0x1a04}
1a04    #@ShouldNotReachHere

1a10    B244: #	out( N2589 ) &lt;- in( B1 )  Freq: 1.01328e-06
1a10 +  li R11, #-10	# int, #@loadConI
1a14    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # OopMap {off=6680/0x1a18}
1a18    #@ShouldNotReachHere

1a24    B245: #	out( N2589 ) &lt;- in( B4 )  Freq: 1.01326e-06
1a24 +  li R11, #-10	# int, #@loadConI
1a28    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:8 (line 278) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6700/0x1a2c}
1a2c    #@ShouldNotReachHere

1a38    B246: #	out( N2589 ) &lt;- in( B6 )  Freq: 1.01326e-06
1a38 +  li R11, #-10	# int, #@loadConI
1a3c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:23 (line 283) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6720/0x1a40}
1a40    #@ShouldNotReachHere

1a4c    B247: #	out( N2589 ) &lt;- in( B11 )  Freq: 1.01174e-06
1a4c +  li R11, #-12	# int, #@loadConI
1a50    spill [sp, #8] -&gt; R8	# spill size = 64
1a54 +  spill R29 -&gt; [sp, #20]	# spill size = 32
1a58    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=R8 L[1]=_ L[2]=sp + #20 L[3]=_ STK[0]=sp + #20
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=R8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=6748/0x1a5c}
1a5c    #@ShouldNotReachHere

1a68    B248: #	out( N2589 ) &lt;- in( B27 )  Freq: 1.01174e-06
1a68 +  li R11, #-10	# int, #@loadConI
1a6c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::&lt;init&gt; @ bci:4 (line 1380) L[0]=_ L[1]=_ L[2]=_ STK[0]=_ STK[1]=_ STK[2]=_ STK[3]=#NULL
        # sun.nio.fs.Util::toString @ bci:8 (line 63) L[0]=_ STK[0]=_
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=_ STK[0]=_ STK[1]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6768/0x1a70}
1a70    #@ShouldNotReachHere

1a7c    B249: #	out( N2589 ) &lt;- in( B34 )  Freq: 1.01172e-06
1a7c +  li R11, #-10	# int, #@loadConI
1a80    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL STK[1]=sp + #0 STK[2]=#Ptr0x00000040d06fbfd0
        # OopMap {[0]=Oop off=6788/0x1a84}
1a84    #@ShouldNotReachHere

1a90    B250: #	out( N2589 ) &lt;- in( B35 )  Freq: 1.01172e-06
1a90 +  li R11, #-10	# int, #@loadConI
1a94    spill R30 -&gt; R8	# spill size = 64
1a98    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::replace @ bci:1 (line 2953) L[0]=R8 L[1]=_ L[2]=#Ptr0x00000040d06fbfd0 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=#NULL
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop off=6812/0x1a9c}
1a9c    #@ShouldNotReachHere

1aa8    B251: #	out( N2589 ) &lt;- in( B36 )  Freq: 1.01172e-06
1aa8 +  li R11, #-10	# int, #@loadConI
1aac    spill R30 -&gt; R8	# spill size = 64
1ab0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::replace @ bci:16 (line 2955) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=#Ptr0x00000040d06fbfd0 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=6836/0x1ab4}
1ab4    #@ShouldNotReachHere

1ac0    B252: #	out( N2589 ) &lt;- in( B37 )  Freq: 1.01172e-06
1ac0 +  li R11, #-10	# int, #@loadConI
1ac4    spill R30 -&gt; R8	# spill size = 64
1ac8 +  spill R10 -&gt; [sp, #8]	# spill size = 32
1acc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::replace @ bci:22 (line 2956) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=#Ptr0x00000040d06fbfd0 L[5]=sp + #8 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=6864/0x1ad0}
1ad0    #@ShouldNotReachHere

1adc    B253: #	out( N2589 ) &lt;- in( B48 )  Freq: 1.01169e-06
1adc +  li R11, #-10	# int, #@loadConI
1ae0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::indexOf @ bci:10 (line 206) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6884/0x1ae4}
1ae4    #@ShouldNotReachHere

1af0    B254: #	out( N2589 ) &lt;- in( B70 )  Freq: 1.0115e-06
1af0 +  li R11, #-10	# int, #@loadConI
1af4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::isEmpty @ bci:4 (line 1487) L[0]=_ STK[0]=#NULL
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6904/0x1af8}
1af8    #@ShouldNotReachHere

1b04    B255: #	out( N2589 ) &lt;- in( B75 )  Freq: 1.01148e-06
1b04 +  li R11, #-10	# int, #@loadConI
1b08    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::charAt @ bci:6 (line 47) L[0]=_ L[1]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6924/0x1b0c}
1b0c    #@ShouldNotReachHere

1b18    B256: #	out( N2589 ) &lt;- in( B145 )  Freq: 1.50835e-09
1b18 +  li R11, #-10	# int, #@loadConI
1b1c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::&lt;init&gt; @ bci:4 (line 1380) L[0]=_ L[1]=_ L[2]=_ STK[0]=_ STK[1]=_ STK[2]=_ STK[3]=#NULL
        # sun.nio.fs.Util::toString @ bci:8 (line 63) L[0]=_ STK[0]=_
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=_ STK[0]=_ STK[1]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:35 (line 747) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6944/0x1b20}
1b20    #@ShouldNotReachHere

1b2c    B257: #	out( B266 ) &lt;- in( B233 )  Freq: 1.48883e-12
1b2c     -- 	// exception oop; no code emitted, #@CreateException
1b2c +  j  B266	#@branch

1b30    B258: #	out( B276 ) &lt;- in( B172 )  Freq: 9.97207e-10
1b30     -- 	// exception oop; no code emitted, #@CreateException
1b30 +  spill R10 -&gt; R11	# spill size = 64
1b34 +  j  B276	#@branch

1b38    B259: #	out( B271 ) &lt;- in( B170 )  Freq: 9.98648e-10
1b38     -- 	// exception oop; no code emitted, #@CreateException
1b38 +  j  B271	#@branch

1b3c    B260: #	out( B273 ) &lt;- in( B166 )  Freq: 9.98649e-10
1b3c     -- 	// exception oop; no code emitted, #@CreateException
1b3c +  j  B273	#@branch

1b40    B261: #	out( B273 ) &lt;- in( B168 )  Freq: 1.00877e-09
1b40     -- 	// exception oop; no code emitted, #@CreateException
1b40 +  j  B273	#@branch

1b44    B262: #	out( B276 ) &lt;- in( B155 )  Freq: 1.33967e-08
1b44     -- 	// exception oop; no code emitted, #@CreateException
1b44 +  spill R10 -&gt; R11	# spill size = 64
1b48 +  j  B276	#@branch

1b4c    B263: #	out( B276 ) &lt;- in( B153 )  Freq: 1.48855e-08
1b4c     -- 	// exception oop; no code emitted, #@CreateException
1b4c +  spill R10 -&gt; R11	# spill size = 64
1b50 +  j  B276	#@branch

1b54    B264: #	out( B273 ) &lt;- in( B140 )  Freq: 1.48859e-08
1b54     -- 	// exception oop; no code emitted, #@CreateException
1b54 +  j  B273	#@branch

1b58    B265: #	out( B266 ) &lt;- in( B146 )  Freq: 1.48858e-08
1b58     -- 	// exception oop; no code emitted, #@CreateException

1b58    B266: #	out( B276 ) &lt;- in( B257 B265 )  Freq: 1.48873e-08
1b58 +  spill R10 -&gt; R11	# spill size = 64
1b5c +  j  B276	#@branch

1b60    B267: #	out( B276 ) &lt;- in( B67 )  Freq: 6.26698e-06
1b60     -- 	// exception oop; no code emitted, #@CreateException
1b60 +  spill R10 -&gt; R11	# spill size = 64
1b64 +  j  B276	#@branch

1b68    B268: #	out( B276 ) &lt;- in( B72 )  Freq: 9.98246e-06
1b68     -- 	// exception oop; no code emitted, #@CreateException
1b68 +  spill R10 -&gt; R11	# spill size = 64
1b6c +  j  B276	#@branch

1b70    B269: #	out( B276 ) &lt;- in( B44 )  Freq: 9.98453e-06
1b70     -- 	// exception oop; no code emitted, #@CreateException
1b70 +  spill R10 -&gt; R11	# spill size = 64
1b74 +  j  B276	#@branch

1b78    B270: #	out( B271 ) &lt;- in( B28 )  Freq: 9.98481e-06
1b78     -- 	// exception oop; no code emitted, #@CreateException

1b78    B271: #	out( B276 ) &lt;- in( B259 B270 )  Freq: 9.98581e-06
1b78 +  spill R10 -&gt; R11	# spill size = 64
1b7c +  j  B276	#@branch

1b80    B272: #	out( B273 ) &lt;- in( B3 )  Freq: 9.99998e-06
1b80     -- 	// exception oop; no code emitted, #@CreateException

1b80    B273: #	out( B276 ) &lt;- in( B272 B264 B261 B260 )  Freq: 1.00169e-05
1b80 +  spill R10 -&gt; R11	# spill size = 64
1b84 +  j  B276	#@branch

1b88    B274: #	out( B276 ) &lt;- in( B114 )  Freq: 2.3907e-05
1b88     -- 	// exception oop; no code emitted, #@CreateException
1b88 +  spill R10 -&gt; R11	# spill size = 64
1b8c +  j  B276	#@branch

1b90    B275: #	out( B276 ) &lt;- in( B109 )  Freq: 2.38053e-05
1b90     -- 	// exception oop; no code emitted, #@CreateException
1b90 +  spill R10 -&gt; R11	# spill size = 64

1b94    B276: #	out( N2589 ) &lt;- in( B273 B266 B263 B262 B271 B269 B275 B274 B267 B268 B258 )  Freq: 9.39931e-05
1b94    # pop frame 96
	add  sp, sp, #96
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
1ba0 +  j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='340'>
----------------------- MetaData before Compile_id = 340 ------------------------
{method}
 - this oop:          0x00000040962b78b0
 - method holder:     &apos;sun/nio/fs/UnixPath&apos;
 - constants:         0x00000040962b5440 constant pool [472] {0x00000040962b5440} for &apos;sun/nio/fs/UnixPath&apos; cache=0x00000040962ba1a0
 - access:            0x81000001  public 
 - name:              &apos;getParent&apos;
 - signature:         &apos;()Lsun/nio/fs/UnixPath;&apos;
 - max stack:         6
 - max locals:        4
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      31
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c5609c0
 - code size:         64
 - code start:        0x00000040962b7830
 - code end (excl):   0x00000040962b7870
 - method data:       0x00000040964982e8
 - checked ex length: 0
 - linenumber start:  0x00000040962b7870
 - localvar length:   4
 - localvar start:    0x00000040962b787e
 - compiled code: nmethod  15361  277       3       sun.nio.fs.UnixPath::getParent (64 bytes)

------------------------ OptoAssembly for Compile_id = 340 -----------------------
#
#  sun/nio/fs/UnixPath * ( sun/nio/fs/UnixPath:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixPath:NotNull *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N375: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B39 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
03c     spill R11 -&gt; [sp, #0]	# spill size = 64
040     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 276) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=68/0x44}

044     B2: #	out( B33 B3 ) &lt;- in( B1 )  Freq: 0.99998
        # Block is sole successor of call
044 +   spill [sp, #0] -&gt; R7	# spill size = 64
048 +   lwu  R28, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
04c +   #@membar_acquire
	fence ir iorw
050 +   decode_heap_oop  R7, R28	#@decodeHeapOop
054     lwu  R29, [R7, #12]	# range, #@loadRange
058     NullCheck R7

058     B3: #	out( B32 B4 ) &lt;- in( B2 )  Freq: 0.999979
058 +   bleu  R29, zr, B32	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=5374.000000

05c     B4: #	out( B34 B5 ) &lt;- in( B3 )  Freq: 0.999978
05c +   spill [sp, #0] -&gt; R7	# spill size = 64
060 +   lwu  R7, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
064 +   decode_heap_oop  R30, R7	#@decodeHeapOop
068 +   addw  R28, R29, zr	#@convI2L_reg_reg
06c +   #@membar_acquire
	fence ir iorw
070 +   slli  R7, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
074 +   addiw  R8, R29, #-1	#@addI_reg_imm
078     lwu  R29, [R30, #12]	# range, #@loadRange
07c     NullCheck R30

07c     B5: #	out( B28 B6 ) &lt;- in( B4 )  Freq: 0.999977
07c +   add R7, R30, R7	# ptr, #@addP_reg_reg
080 +   bgeu  R8, R29, B28	#@cmpU_branch  P=0.000001 C=-1.000000

084     B6: #	out( B21 B7 ) &lt;- in( B5 )  Freq: 0.999976
084 +   lw  R8, [R7, #12]	# int, #@loadI
088 +   addiw  R28, R8, #-1	#@addI_reg_imm
08c +   ble  R28, zr, B21	#@cmpI_reg_imm0_branch  P=0.001489 C=5374.000000

090     B7: #	out( B29 B8 ) &lt;- in( B6 )  Freq: 0.998488
090 +   spill [sp, #0] -&gt; R7	# spill size = 64
094 +   lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
098 +   li R29, #1048576	# int, #@loadConI
09c +   decode_heap_oop  R31, R7	#@decodeHeapOop
0a0 +   bgtu  R28, R29, B29	#@cmpU_branch  P=0.000001 C=-1.000000

0a4     B8: #	out( B9 ) &lt;- in( B7 )  Freq: 0.998487
0a4 +   addw  R7, R8, zr	#@convI2L_reg_reg
0a8 +   addi  R7, R7, #-1	#@addL_reg_imm

0ac     B9: #	out( B35 B10 ) &lt;- in( B8 B29 )  Freq: 0.998488
0ac     lwu  R30, [R31, #12]	# range, #@loadRange
0b0     NullCheck R31

0b0     B10: #	out( B31 B11 ) &lt;- in( B9 )  Freq: 0.998487
0b0 +   addi  R10, R7, #23	#@addL_reg_imm
0b4 +   bltu  R30, R28, B31	#@cmpU_branch  P=0.000001 C=-1.000000

0b8     B11: #	out( B26 B12 ) &lt;- in( B10 )  Freq: 0.998486
0b8 +   andi  R12, R10, #-8	#@andL_reg_imm
0bc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0bc     bgtu  R28, R29, B26	#@cmpU_branch  P=0.000001 C=-1.000000

0c0     B12: #	out( B26 B13 ) &lt;- in( B11 )  Freq: 0.998485
0c0 +   ld  R9, [R23, #288]	# ptr, #@loadP
0c4 +   ld  R29, [R23, #304]	# ptr, #@loadP
0c8 +   add R7, R9, R12	# ptr, #@addP_reg_reg
0cc +   bgeu  R7, R29, B26	#@cmpP_branch  P=0.000100 C=-1.000000

0d0     B13: #	out( B14 ) &lt;- in( B12 )  Freq: 0.998385
0d0 +   sd  R7, [R23, #288]	# ptr, #@storeP
0d4 +   li R7, #1	# long, #@loadConL
0d8 +   mv  R29, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0e8 +   sd  R7, [R9]	# long, #@storeL
0ec +   sw  R29, [R9, #8]	# compressed klass ptr, #@storeNKlass
0f0 +   sw  R28, [R9, #12]	# int, #@storeI

0f4     B14: #	out( B30 B15 ) &lt;- in( B27 B13 )  Freq: 0.998486
0f4 +   srli  R7, R10, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
0f8     
0f8 +   # checkcastPP of R9, #@checkCastPP
0f8     encode_heap_oop  R10, R9	#@encodeHeapOop
0fc +   li R29, #1	# int, #@loadConI
100 +   # castII of R8, #@castII
100     addi  R11, R9, #16	# ptr, #@addP_reg_imm
104     spill R10 -&gt; [sp, #16]	# spill size = 32
108 +   beq  R8, R29, B30	#@cmpI_branch  P=0.000001 C=-1.000000

10c     B15: #	out( B23 B16 ) &lt;- in( B14 )  Freq: 0.998485
10c +   addiw  R30, R8, #-1	#@addI_reg_imm
110 +   addi  R10, R31, #16	# ptr, #@addP_reg_imm
114 +   blt  R30, R28, B23	#@cmpI_branch  P=0.001000 C=-1.000000

118     B16: #	out( B17 ) &lt;- in( B15 )  Freq: 0.997486
118 +   addi  R7, R12, #-16	#@addL_reg_imm
11c +   srli  R12, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
120 +   CALL, runtime leaf nofp 0x000000401396d840	#@CallLeafNoFPDirect jlong_disjoint_arraycopy
        No JVM State Info
        # 

124     B17: #	out( B24 B18 ) &lt;- in( B23 B16 B30 )  Freq: 0.998486
124     MEMBAR-store-store	#@membar_storestore
128 +   ld  R10, [R23, #288]	# ptr, #@loadP
12c +   ld  R7, [R23, #304]	# ptr, #@loadP
130 +   addi  R28, R10, #32	# ptr, #@addP_reg_imm
134 +   bgeu  R28, R7, B24	#@cmpP_branch  P=0.000100 C=-1.000000

138     B18: #	out( B19 ) &lt;- in( B17 )  Freq: 0.998386
138 +   li R7, #1	# long, #@loadConL
13c +   sd  R28, [R23, #288]	# ptr, #@storeP
140 +   sd  R7, [R10]	# long, #@storeL
144 +   mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d0672140:Constant:exact *	# compressed klass ptr, #@loadConNKlass
154 +   sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
158 +   sw  zr, [R10, #12]	# int, #@storeimmI0
15c +   sw  zr, [R10, #16]	# int, #@storeimmI0
160 +   sd  zr, [R10, #24]	# long, #@storeimmL0

164     B19: #	out( B20 ) &lt;- in( B25 B18 )  Freq: 0.998486
164     spill [sp, #16] -&gt; R7	# spill size = 32
168 +   sw  R7, [R10, #20]	# compressed ptr, #@storeN
16c     
16c     spill [sp, #0] -&gt; R7	# spill size = 64
170 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
174 +   # checkcastPP of R10, #@checkCastPP
174     sw  R28, [R10, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixPath.fs
178 +   #@membar_release
	fence iorw ow

17c     B20: #	out( N375 ) &lt;- in( B22 B19 )  Freq: 0.999974
17c     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
194 +   ret	// return register, #@Ret

198     B21: #	out( B38 B22 ) &lt;- in( B6 )  Freq: 0.00148859
198 +   spill [sp, #0] -&gt; R11	# spill size = 64
19c     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::getRoot
        # sun.nio.fs.UnixPath::getParent @ bci:32 (line 286) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=416/0x1a0}

1a0     B22: #	out( B20 ) &lt;- in( B21 )  Freq: 0.00148856
        # Block is sole successor of call
1a0 +   j  B20	#@branch

1a4     B23: #	out( B17 ) &lt;- in( B15 )  Freq: 0.000998485
1a4 +   addw  R30, R8, zr	#@convI2L_reg_reg
1a8 +   addi  R28, R30, #15	#@addL_reg_imm
1ac +   srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
1b0 +   andi  R28, R28, #-8	#@andL_reg_imm
1b4 +   add R28, R9, R28	# ptr, #@addP_reg_reg
1b8 +   sub  R29, R7, R29	#@subL_reg_reg
1bc     ClearArray R29, R28	#@clearArray_reg_reg
214 +   addi  R12, R30, #-1	#@addL_reg_imm
218     CALL, runtime leaf nofp 0x000000401396cf00	#@CallLeafNoFPDirect arrayof_jbyte_disjoint_arraycopy
        No JVM State Info
        # 
21c +   j  B17	#@branch

220     B24: #	out( B36 B25 ) &lt;- in( B17 )  Freq: 9.98652e-05
220 +   mv  R11, precise klass sun/nio/fs/UnixPath: 0x00000040d0672140:Constant:exact *	# ptr, #@loadConP
238     spill [sp, #0] -&gt; R8	# spill size = 64
23c +   spill R9 -&gt; [sp, #8]	# spill size = 64
240     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixPath::getParent @ bci:51 (line 290) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=NarrowOop off=580/0x244}

244     B25: #	out( B19 ) &lt;- in( B24 )  Freq: 9.98632e-05
        # Block is sole successor of call
244 +   j  B19	#@branch

248     B26: #	out( B37 B27 ) &lt;- in( B11 B12 )  Freq: 0.000100877
248 +   spill R12 -&gt; [sp, #32]	# spill size = 64
24c +   spill R10 -&gt; [sp, #24]	# spill size = 64
250 +   spill R31 -&gt; [sp, #16]	# spill size = 64
254 +   spill R28 -&gt; [sp, #8]	# spill size = 32
258 +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
270     spill R28 -&gt; R12	# spill size = 32
274     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=sp + #0 L[1]=_ L[2]=sp + #8 L[3]=_
        # OopMap {[0]=Oop [16]=Oop off=632/0x278}

278     B27: #	out( B14 ) &lt;- in( B26 )  Freq: 0.000100875
        # Block is sole successor of call
278 +   spill R10 -&gt; R9	# spill size = 64
27c +   spill [sp, #8] -&gt; R28	# spill size = 32
280 +   spill [sp, #16] -&gt; R31	# spill size = 64
284 +   spill [sp, #24] -&gt; R10	# spill size = 64
288 +   spill [sp, #32] -&gt; R12	# spill size = 64
28c +   j  B14	#@branch

290     B28: #	out( N375 ) &lt;- in( B5 )  Freq: 1.01326e-06
290 +   li R11, #-28	# int, #@loadConI
294     spill R30 -&gt; [sp, #8]	# spill size = 64
298     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:23 (line 283) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #8 STK[1]=R8
        # OopMap {[0]=Oop [8]=Oop off=668/0x29c}
29c     #@ShouldNotReachHere

2a8     B29: #	out( B9 ) &lt;- in( B7 )  Freq: 1.01175e-06
2a8 +   addw  R7, R28, zr	#@convI2L_reg_reg
2ac +   j  B9	#@branch

2b0     B30: #	out( B17 ) &lt;- in( B14 )  Freq: 1.01174e-06
2b0 +   spill R11 -&gt; R28	# spill size = 64
2b4 +   addi  R29, R7, #-2	#@addL_reg_imm
2b8     ClearArray R29, R28	#@clearArray_reg_reg
310     
310 +   j  B17	#@branch

314     B31: #	out( N375 ) &lt;- in( B10 )  Freq: 9.98487e-07
314 +   spill [sp, #0] -&gt; R8	# spill size = 64
318 +   li R11, #-52	# int, #@loadConI
31c     spill R28 -&gt; [sp, #4]	# spill size = 32
320     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=R8 L[1]=_ L[2]=sp + #4 L[3]=_ STK[0]=sp + #4
        # OopMap {fp=Oop off=804/0x324}
324     #@ShouldNotReachHere

330     B32: #	out( N375 ) &lt;- in( B3 )  Freq: 4.76827e-07
330 +   spill [sp, #0] -&gt; R8	# spill size = 64
334 +   li R11, #-187	# int, #@loadConI
338     spill R29 -&gt; [sp, #4]	# spill size = 32
33c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:11 (line 279) L[0]=R8 L[1]=sp + #4 L[2]=_ L[3]=_ STK[0]=sp + #4
        # OopMap {fp=Oop off=832/0x340}
340     #@ShouldNotReachHere

34c     B33: #	out( N375 ) &lt;- in( B2 )  Freq: 1.01326e-06
34c +   li R11, #-10	# int, #@loadConI
350     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:8 (line 278) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # OopMap {off=852/0x354}
354     #@ShouldNotReachHere

360     B34: #	out( N375 ) &lt;- in( B4 )  Freq: 1.01326e-06
360 +   li R11, #-10	# int, #@loadConI
364     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:23 (line 283) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL STK[1]=R8
        # OopMap {off=872/0x368}
368     #@ShouldNotReachHere

374     B35: #	out( N375 ) &lt;- in( B9 )  Freq: 1.01175e-06
374 +   spill [sp, #0] -&gt; R8	# spill size = 64
378 +   li R11, #-12	# int, #@loadConI
37c     spill R28 -&gt; [sp, #4]	# spill size = 32
380     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=R8 L[1]=_ L[2]=sp + #4 L[3]=_ STK[0]=sp + #4
        # OopMap {fp=Oop off=900/0x384}
384     #@ShouldNotReachHere

390     B36: #	out( B40 ) &lt;- in( B24 )  Freq: 9.98652e-10
390      -- 	// exception oop; no code emitted, #@CreateException
390 +   spill R10 -&gt; R11	# spill size = 64
394 +   j  B40	#@branch

398     B37: #	out( B40 ) &lt;- in( B26 )  Freq: 1.00877e-09
398      -- 	// exception oop; no code emitted, #@CreateException
398 +   spill R10 -&gt; R11	# spill size = 64
39c +   j  B40	#@branch

3a0     B38: #	out( B40 ) &lt;- in( B21 )  Freq: 1.48859e-08
3a0      -- 	// exception oop; no code emitted, #@CreateException
3a0 +   spill R10 -&gt; R11	# spill size = 64
3a4 +   j  B40	#@branch

3a8     B39: #	out( B40 ) &lt;- in( B1 )  Freq: 1e-05
3a8      -- 	// exception oop; no code emitted, #@CreateException
3a8 +   spill R10 -&gt; R11	# spill size = 64

3ac     B40: #	out( N375 ) &lt;- in( B39 B38 B37 B36 )  Freq: 1.00169e-05
3ac     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
3b8 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='341'>
----------------------- MetaData before Compile_id = 341 ------------------------
{method}
 - this oop:          0x0000004096592288
 - method holder:     &apos;java/nio/file/Files$$Lambda$7+0x00000008000191b8&apos;
 - constants:         0x0000004096592040 constant pool [23] {0x0000004096592040} for &apos;java/nio/file/Files$$Lambda$7+0x00000008000191b8&apos; cache=0x0000004096592318
 - access:            0x81000001  public 
 - name:              &apos;apply&apos;
 - signature:         &apos;(Ljava/lang/Object;)Ljava/lang/Object;&apos;
 - max stack:         2
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bd00: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c52d3c0
 - code size:         8
 - code start:        0x0000004096592280
 - code end (excl):   0x0000004096592288
 - method data:       0x0000004096496338
 - checked ex length: 0
 - localvar length:   0
 - compiled code: nmethod  15384  241       3       java.nio.file.Files$$Lambda$7/0x00000008000191b8::apply (8 bytes)

------------------------ OptoAssembly for Compile_id = 341 -----------------------
#
#  java/lang/Object * ( java/nio/file/Files$$Lambda$7+0x00000008000191b8:NotNull:exact *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/nio/file/Files$$Lambda$7+0x00000008000191b8:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N44: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B5 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     lwu  R28, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
040     NullCheck R12

040     B2: #	out( B4 B3 ) &lt;- in( B1 )  Freq: 0.999999
040 +   mv  R7, narrowklass: precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d8328f00:Constant:exact *	# compressed klass ptr, #@loadConNKlass
050 +   bne  R28, R7, B4	#@cmpN_branch  P=0.000000 C=-1.000000

054     B3: #	out( N44 ) &lt;- in( B2 )  Freq: 0.999999
054 +   # checkcastPP of R12, #@checkCastPP
054     lwu  R28, [R12, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.file
058 +   decode_heap_oop  R10, R28	#@decodeHeapOop
05c     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
074 +   ret	// return register, #@Ret

078     B4: #	out( N44 ) &lt;- in( B2 )  Freq: 1e-35
078 +   li R11, #-34	# int, #@loadConI
07c     spill R12 -&gt; R8	# spill size = 64
080     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files$$Lambda$7/0x00000008000191b8::apply @ bci:1 L[0]=_ L[1]=_ STK[0]=R8
        # OopMap {fp=Oop off=132/0x84}
084     #@ShouldNotReachHere

090     B5: #	out( N44 ) &lt;- in( B1 )  Freq: 1.01328e-06
090 +   li R11, #-12	# int, #@loadConI
094     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.nio.file.Files$$Lambda$7/0x00000008000191b8::apply @ bci:1 L[0]=_ L[1]=_ STK[0]=#NULL
        # OopMap {off=152/0x98}
098 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='342'>
----------------------- MetaData before Compile_id = 342 ------------------------
{method}
 - this oop:          0x00000040965c0348
 - method holder:     &apos;jdk/internal/module/ModulePath$$Lambda$8+0x000000080001dd80&apos;
 - constants:         0x00000040965c00c0 constant pool [28] {0x00000040965c00c0} for &apos;jdk/internal/module/ModulePath$$Lambda$8+0x000000080001dd80&apos; cache=0x00000040965c03d8
 - access:            0x81000001  public 
 - name:              &apos;apply&apos;
 - signature:         &apos;(Ljava/lang/Object;)Ljava/lang/Object;&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bd00: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c52dac0
 - code size:         12
 - code start:        0x00000040965c0338
 - code end (excl):   0x00000040965c0344
 - method data:       0x00000040964966b0
 - checked ex length: 0
 - localvar length:   0
 - compiled code: nmethod  15403  242       3       jdk.internal.module.ModulePath$$Lambda$8/0x000000080001dd80::apply (12 bytes)

------------------------ OptoAssembly for Compile_id = 342 -----------------------
#
#  java/lang/Object * ( jdk/internal/module/ModulePath$$Lambda$8+0x000000080001dd80:NotNull:exact *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: jdk/internal/module/ModulePath$$Lambda$8+0x000000080001dd80:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N97: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B10 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/module/ModulePath$$Lambda$8+0x000000080001dd80.arg$1 (constant)
040 +   decode_heap_oop  R11, R7	#@decodeHeapOop
044     lwu  R28, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
048     NullCheck R12

048     B2: #	out( B8 B3 ) &lt;- in( B1 )  Freq: 0.999999
048 +   mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d01edbe0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
058 +   bne  R28, R7, B8	#@cmpN_branch  P=0.000000 C=-1.000000

05c     B3: #	out( B11 B4 ) &lt;- in( B2 )  Freq: 0.999999
05c +   # checkcastPP of R12, #@checkCastPP
05c     lwu  R28, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
060     NullCheck R11

060     B4: #	out( B7 B5 ) &lt;- in( B3 )  Freq: 0.999998
060 +   bne  R28, R7, B7	#@cmpN_branch  P=0.000001 C=-1.000000

064     B5: #	out( B9 B6 ) &lt;- in( B4 )  Freq: 0.999997
064 +   # checkcastPP of R11, #@checkCastPP
064     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::relativize
        # sun.nio.fs.UnixPath::relativize @ bci:2 (line 43) L[0]=_ L[1]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$8 @ bci:2 (line 670) L[0]=_ L[1]=_
        # jdk.internal.module.ModulePath$$Lambda$8/0x000000080001dd80::apply @ bci:8 L[0]=_ L[1]=_
        # OopMap {off=104/0x68}

068     B6: #	out( N97 ) &lt;- in( B5 )  Freq: 0.999977
        # Block is sole successor of call
068 +   # checkcastPP of R10, #@checkCastPP
068     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
080 +   ret	// return register, #@Ret

084     B7: #	out( N97 ) &lt;- in( B4 )  Freq: 9.99998e-07
084 +   spill R11 -&gt; R8	# spill size = 64
088 +   spill R12 -&gt; [sp, #0]	# spill size = 64
08c +   li R11, #-34	# int, #@loadConI
090     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::lambda$explodedPackages$8 @ bci:2 (line 670) L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #0
        # jdk.internal.module.ModulePath$$Lambda$8/0x000000080001dd80::apply @ bci:8 L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=148/0x94}
094     #@ShouldNotReachHere

0a0     B8: #	out( N97 ) &lt;- in( B2 )  Freq: 1e-35
0a0 +   spill R11 -&gt; R8	# spill size = 64
0a4 +   spill R12 -&gt; [sp, #0]	# spill size = 64
0a8 +   li R11, #-34	# int, #@loadConI
0ac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$8/0x000000080001dd80::apply @ bci:5 L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop off=176/0xb0}
0b0     #@ShouldNotReachHere

0bc     B9: #	out( N97 ) &lt;- in( B5 )  Freq: 9.99997e-06
0bc      -- 	// exception oop; no code emitted, #@CreateException
0bc +   spill R10 -&gt; R11	# spill size = 64
0c0 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
0cc +   j rethrow_stub	#@RethrowException

0d4     B10: #	out( N97 ) &lt;- in( B1 )  Freq: 1.01328e-06
0d4 +   spill R11 -&gt; R8	# spill size = 64
0d8 +   li R11, #-12	# int, #@loadConI
0dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.module.ModulePath$$Lambda$8/0x000000080001dd80::apply @ bci:5 L[0]=_ L[1]=_ STK[0]=R8 STK[1]=#NULL
        # OopMap {fp=Oop off=224/0xe0}
0e0     #@ShouldNotReachHere

0ec     B11: #	out( N97 ) &lt;- in( B3 )  Freq: 1.01328e-06
0ec +   li R11, #-10	# int, #@loadConI
0f0     spill R12 -&gt; R8	# spill size = 64
0f4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::lambda$explodedPackages$8 @ bci:2 (line 670) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8
        # jdk.internal.module.ModulePath$$Lambda$8/0x000000080001dd80::apply @ bci:8 L[0]=_ L[1]=_
        # OopMap {fp=Oop off=248/0xf8}
0f8 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='343'>
----------------------- MetaData before Compile_id = 343 ------------------------
{method}
 - this oop:          0x00000040965c2418
 - method holder:     &apos;jdk/internal/module/ModulePath$$Lambda$9+0x000000080001dfd8&apos;
 - constants:         0x00000040965c2168 constant pool [32] {0x00000040965c2168} for &apos;jdk/internal/module/ModulePath$$Lambda$9+0x000000080001dfd8&apos; cache=0x00000040965c24a8
 - access:            0x81000001  public 
 - name:              &apos;apply&apos;
 - signature:         &apos;(Ljava/lang/Object;)Ljava/lang/Object;&apos;
 - max stack:         4
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bd00: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c52fb40
 - code size:         16
 - code start:        0x00000040965c2408
 - code end (excl):   0x00000040965c2418
 - method data:       0x00000040964978f0
 - checked ex length: 0
 - localvar length:   0
 - compiled code: nmethod  15422  244       3       jdk.internal.module.ModulePath$$Lambda$9/0x000000080001dfd8::apply (16 bytes)

------------------------ OptoAssembly for Compile_id = 343 -----------------------
#
#  java/lang/Object * ( jdk/internal/module/ModulePath$$Lambda$9+0x000000080001dfd8:NotNull:exact *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: jdk/internal/module/ModulePath$$Lambda$9+0x000000080001dfd8:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N83: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B9 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/module/ModulePath$$Lambda$9+0x000000080001dfd8.arg$1 (constant)
040 +   lwu  R29, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/module/ModulePath$$Lambda$9+0x000000080001dfd8.arg$2 (constant)
044 +   decode_heap_oop  R11, R7	#@decodeHeapOop
048 +   decode_heap_oop  R13, R29	#@decodeHeapOop
04c     lwu  R7, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
050     NullCheck R12

050     B2: #	out( B7 B3 ) &lt;- in( B1 )  Freq: 0.999999
050 +   mv  R29, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d0646f30:Constant:exact *	# compressed klass ptr, #@loadConNKlass
060 +   bne  R7, R29, B7	#@cmpN_branch  P=0.000000 C=-1.000000

064     B3: #	out( B6 B4 ) &lt;- in( B2 )  Freq: 0.999999
064 +   # checkcastPP of R12, #@checkCastPP
064     beq   R11, zr, B6	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

068     B4: #	out( B8 B5 ) &lt;- in( B3 )  Freq: 0.999998
068     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect jdk.internal.module.ModulePath::toPackageName
        # jdk.internal.module.ModulePath::lambda$explodedPackages$9 @ bci:3 (line 671) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$9/0x000000080001dfd8::apply @ bci:12 L[0]=_ L[1]=_
        # OopMap {off=108/0x6c}

06c     B5: #	out( N83 ) &lt;- in( B4 )  Freq: 0.999978
        # Block is sole successor of call
06c     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
084 +   ret	// return register, #@Ret

088     B6: #	out( N83 ) &lt;- in( B3 )  Freq: 1.01328e-06
088 +   li R11, #-10	# int, #@loadConI
08c     spill R13 -&gt; R8	# spill size = 64
090 +   spill R12 -&gt; [sp, #0]	# spill size = 64
094     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$9/0x000000080001dfd8::apply @ bci:12 L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8 STK[2]=sp + #0
        # OopMap {fp=Oop [0]=Oop off=152/0x98}
098     #@ShouldNotReachHere

0a4     B7: #	out( N83 ) &lt;- in( B2 )  Freq: 1e-35
0a4 +   spill R11 -&gt; R8	# spill size = 64
0a8 +   spill R13 -&gt; [sp, #0]	# spill size = 64
0ac +   spill R12 -&gt; [sp, #8]	# spill size = 64
0b0 +   li R11, #-34	# int, #@loadConI
0b4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$9/0x000000080001dfd8::apply @ bci:9 L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #0 STK[2]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=184/0xb8}
0b8     #@ShouldNotReachHere

0c4     B8: #	out( N83 ) &lt;- in( B4 )  Freq: 9.99998e-06
0c4      -- 	// exception oop; no code emitted, #@CreateException
0c4 +   spill R10 -&gt; R11	# spill size = 64
0c8 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
0d4 +   j rethrow_stub	#@RethrowException

0dc     B9: #	out( N83 ) &lt;- in( B1 )  Freq: 1.01328e-06
0dc +   spill R11 -&gt; R8	# spill size = 64
0e0 +   spill R13 -&gt; [sp, #0]	# spill size = 64
0e4 +   li R11, #-12	# int, #@loadConI
0e8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.module.ModulePath$$Lambda$9/0x000000080001dfd8::apply @ bci:9 L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #0 STK[2]=#NULL
        # OopMap {fp=Oop [0]=Oop off=236/0xec}
0ec +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='351'>
----------------------- MetaData before Compile_id = 351 ------------------------
{method}
 - this oop:          0x00000040961646d0
 - method holder:     &apos;java/util/ImmutableCollections$SetN&apos;
 - constants:         0x00000040961639e8 constant pool [168] {0x00000040961639e8} for &apos;java/util/ImmutableCollections$SetN&apos; cache=0x0000004096164c20
 - access:            0xc1000002  private 
 - name:              &apos;probe&apos;
 - signature:         &apos;(Ljava/lang/Object;)I&apos;
 - max stack:         3
 - max locals:        4
 - size of params:    2
 - method size:       13
 - highest level:     4
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bd00: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c578800
 - code size:         56
 - code start:        0x0000004096164658
 - code end (excl):   0x0000004096164690
 - method data:       0x00000040965ee138
 - checked ex length: 0
 - linenumber start:  0x0000004096164690
 - localvar length:   4
 - localvar start:    0x000000409616469e
 - compiled code: nmethod  15863  349       3       java.util.ImmutableCollections$SetN::probe (56 bytes)

------------------------ OptoAssembly for Compile_id = 351 -----------------------
#
#  int ( java/util/ImmutableCollections$SetN:NotNull:exact *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/ImmutableCollections$SetN:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N851: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B93 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
03c     spill R11 -&gt; [sp, #8]	# spill size = 64
040 +   spill R12 -&gt; [sp, #16]	# spill size = 64
044     lwu  R7, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
048     NullCheck R12

048     B2: #	out( B56 B3 ) &lt;- in( B1 )  Freq: 0.999999
048 +   spill R7 -&gt; [sp, #0]	# spill size = 32
04c +   mv  R7, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
05c +   li R30, #0	# int, #@loadConI
060     spill [sp, #0] -&gt; R28	# spill size = 32
064 +   li R11, #1	# int, #@loadConI
068 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
068     bne  R28, R7, B56	#@cmpN_branch  P=0.000488 C=-1.000000

06c     B3: #	out( B22 B4 ) &lt;- in( B2 )  Freq: 0.999511
06c +   spill R12 -&gt; R14	# spill size = 64
070 +   # checkcastPP of R14, #@checkCastPP
070     lw  R10, [R14, #12]	# int, #@loadI ! Field: java/lang/String.hash
074 +   bne  R10, zr, B22	#@cmpI_reg_imm0_branch  P=0.474144 C=5376.000000

078     B4: #	out( B55 B5 ) &lt;- in( B3 )  Freq: 0.525598
078 +   lbu  R28, [R14, #17]	# byte, #@loadUB ! Field: java/lang/String.hashIsZero
07c +   bne  R28, zr, B55	#@cmpI_reg_imm0_branch  P=0.001062 C=2826.000000

080     B5: #	out( B85 B6 ) &lt;- in( B4 )  Freq: 0.52504
080 +   lwu  R7, [R14, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
084 +   lb  R8, [R14, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
088 +   decode_heap_oop  R29, R7	#@decodeHeapOop
08c +   bne  R8, zr, B85	#@cmpI_reg_imm0_branch  P=0.000000 C=68009.000000

090     B6: #	out( B95 B7 ) &lt;- in( B5 )  Freq: 0.52504
090     lwu  R8, [R29, #12]	# range, #@loadRange
094     NullCheck R29

094     B7: #	out( B54 B8 ) &lt;- in( B6 )  Freq: 0.52504
094 +   bleu  R8, zr, B54	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.056079 C=18260.000000

098     B8: #	out( B78 B9 ) &lt;- in( B7 )  Freq: 0.495596
098 +   addiw  R28, R8, #-1	#@addI_reg_imm
09c +   bgeu  R28, R8, B78	#@cmpU_branch  P=0.000001 C=-1.000000

0a0     B9: #	out( B79 B10 ) &lt;- in( B8 )  Freq: 0.495595
0a0 +   addiw  R13, R8, #-3	#@addI_reg_imm
0a4 +   li R12, #4000	# int, #@loadConI
0ac +   lbu  R10, [R29, #16]	# byte, #@loadUB
0b0 +   ble  R13, R11, B79	#@cmpI_branch  P=0.000001 C=-1.000000

0b4     B10: #	out( B80 B11 ) &lt;- in( B9 )  Freq: 0.495595
0b4 +   slliw  R7, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0b8 +   subw  R31, R7, R10	#@subI_reg_reg
0bc +   li R28, #4	# int, #@loadConI
0c0 +   bleu  R8, R11, B80	#@cmpU_branch  P=0.000001 C=-1.000000

0c4     B11: #	out( B81 B12 ) &lt;- in( B10 )  Freq: 0.495594
0c4 +   bleu  R8, R28, B81	#@cmpU_branch  P=0.000001 C=-1.000000

0c8     B12: #	out( B13 ) &lt;- in( B11 )  Freq: 0.495594
0c8 +   li R15, #1	# int, #@loadConI

0cc     B13: #	out( B14 ) &lt;- in( B12 B15 ) Loop( B13-B15 ) Freq: 8.83745
0cc +   subw  R7, R8, R15	#@subI_reg_reg
0d0 +   addiw  R28, R7, #-3	#@addI_reg_imm
0d4     CMove R28, (R13 lt R15), R28, R30	#@cmovI_cmpI
	
0dc +   CMove R28, (R28 gtu R12), R28, R12	#@cmovI_cmpU
	
0e4 +   addw  R9, R28, R15	#@addI_reg_reg
        nop 	# 4 bytes pad for loops and calls

0f0     B14: #	out( B14 B15 ) &lt;- in( B13 B14 ) Loop( B14-B14 inner main of N84 strip mined) Freq: 157.59
0f0 +   addw  R7, R15, zr	#@convI2L_reg_reg
0f4 +   add R7, R29, R7	# ptr, #@addP_reg_reg
0f8 +   lbu  R28, [R7, #16]	# byte, #@loadUB
0fc +   addw  R28, R31, R28	#@addI_reg_reg
100 +   lbu  R16, [R7, #17]	# byte, #@loadUB
104 +   slliw  R10, R28, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
108 +   subw  R28, R10, R28	#@subI_reg_reg
10c +   addw  R10, R28, R16	#@addI_reg_reg
110 +   lbu  R31, [R7, #18]	# byte, #@loadUB
114 +   slliw  R28, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
118 +   subw  R10, R28, R10	#@subI_reg_reg
11c +   addw  R31, R10, R31	#@addI_reg_reg
120 +   lbu  R7, [R7, #19]	# byte, #@loadUB
124 +   slliw  R28, R31, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
128 +   subw  R31, R28, R31	#@subI_reg_reg
12c +   addw  R10, R31, R7	#@addI_reg_reg
130 +   slliw  R7, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
134 +   addiw  R15, R15, #4	#@addI_reg_imm
138 +   subw  R31, R7, R10	#@subI_reg_reg
13c +   blt  R15, R9, B14	#@cmpI_loop  P=0.943921 C=17236.000000

140     B15: #	out( B13 B16 ) &lt;- in( B14 )  Freq: 8.83745
140 +   ld  R16, [R23, #920]	# ptr, #@loadP
144 +   lwu zr, [R16]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::hashCode @ bci:37 (line 196) L[0]=_ L[1]=R10 L[2]=R29 L[3]=R8 L[4]=R15 L[5]=_
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=R14 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #8 L[1]=R14 L[2]=_ L[3]=_
        # OopMap {x29=Oop c_rarg4=Oop [8]=Oop [16]=Oop off=324/0x144}
148 +   blt  R15, R13, B13	#@cmpI_branch  P=0.943921 C=17236.000000

14c     B16: #	out( B20 B17 ) &lt;- in( B79 B15 )  Freq: 0.495594
14c +   bge  R15, R8, B20	#@cmpI_branch  P=0.500000 C=-1.000000

150     B17: #	out( B86 B18 ) &lt;- in( B16 )  Freq: 0.247797
150 +   # castII of R15, #@castII
150     bgeu  R15, R8, B86	#@cmpU_branch  P=0.000001 C=-1.000000

154     B18: #	out( B87 B19 ) &lt;- in( B17 )  Freq: 0.247797
154 +   spill R15 -&gt; R28	# spill size = 32
158 +   # castII of R28, #@castII
158     bgeu  R28, R8, B87	#@cmpU_branch  P=0.000001 C=-1.000000

15c     B19: #	out( B19 B20 ) &lt;- in( B18 B19 ) Loop( B19-B19 inner post of N849) Freq: 0.495593
15c +   addw  R7, R15, zr	#@convI2L_reg_reg
160 +   add R7, R29, R7	# ptr, #@addP_reg_reg
164 +   slliw  R30, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
168 +   lbu  R7, [R7, #16]	# byte, #@loadUB
16c +   subw  R28, R30, R10	#@subI_reg_reg
170 +   addiw  R15, R15, #1	#@addI_reg_imm
174 +   addw  R10, R28, R7	#@addI_reg_reg
178 +   blt  R15, R8, B19	#@cmpI_loop  P=0.500000 C=17236.000000

17c     B20: #	out( B54 B21 ) &lt;- in( B19 B16 )  Freq: 0.495594
17c +   beq  R10, zr, B54	#@cmpI_reg_imm0_branch  P=0.000354 C=2823.000000

180     B21: #	out( B22 ) &lt;- in( B20 )  Freq: 0.495418
180 +   sw  R10, [R14, #12]	# int, #@storeI ! Field: java/lang/String.hash

184     B22: #	out( B94 B23 ) &lt;- in( B21 B54 B55 B3 B57 )  Freq: 0.999996
184     spill [sp, #8] -&gt; R7	# spill size = 64
188 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$SetN.elements (constant)
18c +   decode_heap_oop  R31, R28	#@decodeHeapOop
190     lwu  R7, [R31, #12]	# range, #@loadRange
194     NullCheck R31

194     B23: #	out( B69 B24 ) &lt;- in( B22 )  Freq: 0.999995
194 +   bleu  R7, zr, B69	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

198     B24: #	out( B52 B25 ) &lt;- in( B23 )  Freq: 0.999994
198 +   remw  R8, R10, R7	#@modI
19c +   xorr  R28, R8, R7	#@xorI_reg_reg
1a0 +   blt  R28, zr, B52	#@cmpI_reg_imm0_branch  P=0.080904 C=10531.000000

1a4     B25: #	out( B68 B26 ) &lt;- in( B24 B53 )  Freq: 0.999994
1a4 +   addw  R28, R8, zr	#@convI2L_reg_reg
1a8 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
1ac +   add R28, R31, R28	# ptr, #@addP_reg_reg
1b0 +   bgeu  R8, R7, B68	#@cmpU_branch  P=0.000001 C=-1.000000

1b4     B26: #	out( B51 B27 ) &lt;- in( B25 )  Freq: 0.999993
1b4 +   lwu  R28, [R28, #16]	# loadN, compressed ptr, #@loadN
1b8 +   decode_heap_oop  R10, R28	#@decodeHeapOop
1bc +   beq   R10, zr, B51	#@cmpP_imm0_branch  P=0.437888 C=23385.000000

1c0     B27: #	out( B58 B28 ) &lt;- in( B26 )  Freq: 0.562109
1c0 +   mv  R29, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1d0     spill [sp, #0] -&gt; R30	# spill size = 32
1d4 +   bne  R30, R29, B58	#@cmpN_branch  P=0.000152 C=-1.000000

1d8     B28: #	out( B70 B29 ) &lt;- in( B27 )  Freq: 0.562023
1d8 +   spill [sp, #16] -&gt; R12	# spill size = 64
1dc +   lwu  R29, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
1e0 +   # checkcastPP of R12, #@checkCastPP
1e0     lb  R15, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
1e4 +   mv  R28, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1f4 +   beq  R12, R10, B70	#@cmpP_branch  P=0.000001 C=5338.000000

1f8     B29: #	out( B91 B30 ) &lt;- in( B28 )  Freq: 0.562022
1f8 +   bne  R29, R28, B91	#@cmpN_branch  P=0.000000 C=-1.000000

1fc     B30: #	out( B82 B31 ) &lt;- in( B29 )  Freq: 0.562022
1fc +   # checkcastPP of R10, #@checkCastPP
1fc     lb  R29, [R10, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
200 +   bne  R15, R29, B82	#@cmpI_branch  P=0.000000 C=4992.000000

204     B31: #	out( B77 B32 ) &lt;- in( B30 )  Freq: 0.562022
204 +   lwu  R28, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
208 +   decode_heap_oop  R16, R28	#@decodeHeapOop
20c +   lwu  R10, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
210 +   beq   R16, zr, B77	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

214     B32: #	out( B74 B33 ) &lt;- in( B31 )  Freq: 0.562022
214 +   decode_heap_oop  R29, R10	#@decodeHeapOop
218 +   lwu  R28, [R16, #12]	# range, #@loadRange
21c +   addiw  R30, R8, #1	#@addI_reg_imm
220 +   beq   R29, zr, B74	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

224     B33: #	out( B35 B34 ) &lt;- in( B32 )  Freq: 0.562021
224 +   lwu  R10, [R29, #12]	# range, #@loadRange
228 +   addi  R17, R16, #16	# ptr, #@addP_reg_imm
22c +   bne  R28, R10, B35	#@cmpI_branch  P=0.001000 C=-1.000000

230     B34: #	out( B72 B35 ) &lt;- in( B33 )  Freq: 0.561459
230 +   spill R28 -&gt; R14	# spill size = 32
234 +   addi  R13, R29, #16	# ptr, #@addP_reg_imm
238     spill R17 -&gt; R11	# spill size = 64
23c +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
2cc +   bne  R10, zr, B72	#@cmpI_reg_imm0_branch  P=0.000000 C=13145.000000

2d0     B35: #	out( B67 B36 ) &lt;- in( B34 B33 )  Freq: 0.562021
2d0 +   beq  R30, R7, B67	#@cmpI_branch  P=0.000076 C=13146.000000

2d4     B36: #	out( B75 B37 ) &lt;- in( B67 B35 )  Freq: 0.562021
2d4 +   addw  R29, R30, zr	#@convI2L_reg_reg
2d8 +   slli  R29, R29, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
2dc +   add R29, R31, R29	# ptr, #@addP_reg_reg
2e0 +   bgeu  R30, R7, B75	#@cmpU_branch  P=0.000001 C=-1.000000

2e4     B37: #	out( B50 B38 ) &lt;- in( B36 )  Freq: 0.56202
2e4 +   lwu  R10, [R29, #16]	# loadN, compressed ptr, #@loadN
2e8 +   decode_heap_oop  R10, R10	#@decodeHeapOop
2ec +   beq   R10, zr, B50	#@cmpP_imm0_branch  P=0.437888 C=13146.000000

2f0     B38: #	out( B40 ) &lt;- in( B37 )  Freq: 0.315919
2f0 +   mv  R9, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
300 +   j  B40	#@branch
        nop 	# 6 bytes pad for loops and calls

310     B39: #	out( B40 ) &lt;- in( B48 ) top-of-loop Freq: 0.405538
310 +   spill R8 -&gt; R30	# spill size = 32

314     B40: #	out( B71 B41 ) &lt;- in( B38 B39 ) Loop( B40-B39 inner ) Freq: 0.721457
314 +   lwu  R11, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
318 +   beq  R12, R10, B71	#@cmpP_branch  P=0.000001 C=5338.000000

31c     B41: #	out( B92 B42 ) &lt;- in( B40 )  Freq: 0.721456
31c +   bne  R11, R9, B92	#@cmpN_branch  P=0.000000 C=-1.000000

320     B42: #	out( B83 B43 ) &lt;- in( B41 )  Freq: 0.721456
320 +   # checkcastPP of R10, #@checkCastPP
320     lwu  R11, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
324 +   lb  R29, [R10, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
328 +   decode_heap_oop  R11, R11	#@decodeHeapOop
32c +   bne  R15, R29, B83	#@cmpI_branch  P=0.000000 C=4992.000000

330     B43: #	out( B74 B44 ) &lt;- in( B42 )  Freq: 0.721456
330 +   beq   R11, zr, B74	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

334     B44: #	out( B46 B45 ) &lt;- in( B43 )  Freq: 0.721455
334 +   lwu  R10, [R11, #12]	# range, #@loadRange
338 +   addiw  R8, R30, #1	#@addI_reg_imm
33c +   bne  R28, R10, B46	#@cmpI_branch  P=0.001000 C=-1.000000

340     B45: #	out( B84 B46 ) &lt;- in( B44 )  Freq: 0.720734
340 +   addi  R13, R11, #16	# ptr, #@addP_reg_imm
344     spill R28 -&gt; R14	# spill size = 32
348 +   spill R17 -&gt; R11	# spill size = 64
34c +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
3dc +   bne  R10, zr, B84	#@cmpI_reg_imm0_branch  P=0.000000 C=13145.000000

3e0     B46: #	out( B66 B47 ) &lt;- in( B45 B44 )  Freq: 0.721455
3e0 +   beq  R8, R7, B66	#@cmpI_branch  P=0.000076 C=13146.000000

3e4     B47: #	out( B76 B48 ) &lt;- in( B66 B46 )  Freq: 0.721455
3e4 +   ld  R29, [R23, #920]	# ptr, #@loadP
3e8 +   lwu zr, [R29]	# Safepoint: poll for GC, #@safePoint        # java.util.ImmutableCollections$SetN::probe @ bci:53 (line 1017) L[0]=sp + #8 L[1]=sp + #16 L[2]=R8 L[3]=_
        # OopMap {xmethod=Oop c_rarg2=Oop c_rarg6=Oop c_rarg7=Derived_oop_c_rarg6 [8]=Oop [16]=Oop off=1000/0x3e8}
3ec +   addw  R29, R8, zr	#@convI2L_reg_reg
3f0 +   slli  R29, R29, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
3f4 +   add R29, R31, R29	# ptr, #@addP_reg_reg
3f8 +   bgeu  R8, R7, B76	#@cmpU_branch  P=0.000001 C=-1.000000

3fc     B48: #	out( B39 B49 ) &lt;- in( B47 )  Freq: 0.721454
3fc +   lwu  R29, [R29, #16]	# loadN, compressed ptr, #@loadN
400 +   decode_heap_oop  R10, R29	#@decodeHeapOop
404 +   bne   R10, zr, B39	#@cmpP_imm0_branch  P=0.562112 C=13146.000000

408     B49: #	out( B51 ) &lt;- in( B48 )  Freq: 0.315916
408 +   j  B51	#@branch

40c     B50: #	out( B51 ) &lt;- in( B37 )  Freq: 0.246102
40c +   spill R30 -&gt; R8	# spill size = 32

410     B51: #	out( N851 ) &lt;- in( B50 B49 B65 B26 )  Freq: 0.999987
410 +   li R28, #-1	# int, #@loadConI
414 +   subw  R10, R28, R8	#@subI_reg_reg
418     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
430 +   ret	// return register, #@Ret

434     B52: #	out( B88 B53 ) &lt;- in( B24 )  Freq: 0.0809035
434 +   addw  R29, R8, R7	#@addI_reg_reg
438 +   beq  R8, zr, B88	#@cmpI_reg_imm0_branch  P=0.000000 C=852.000000

43c     B53: #	out( B25 ) &lt;- in( B52 )  Freq: 0.0809035
43c +   spill R29 -&gt; R8	# spill size = 32
440 +   j  B25	#@branch

444     B54: #	out( B22 ) &lt;- in( B20 B7 )  Freq: 0.0296192
444 +   sb  R11, [R14, #17]	# byte, #@storeB ! Field: java/lang/String.hashIsZero
448 +   li R10, #0	# int, #@loadConI
44c +   j  B22	#@branch

450     B55: #	out( B22 ) &lt;- in( B4 )  Freq: 0.00055796
450 +   li R10, #0	# int, #@loadConI
454 +   j  B22	#@branch

458     B56: #	out( B96 B57 ) &lt;- in( B2 )  Freq: 0.00048834
458 +   spill R12 -&gt; R11	# spill size = 64
45c +   spill R12 -&gt; R8	# spill size = 64
460     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #8 L[1]=R8 L[2]=_ L[3]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=1148/0x47c}

47c     B57: #	out( B22 ) &lt;- in( B56 )  Freq: 0.000488331
        # Block is sole successor of call
47c +   j  B22	#@branch

480     B58: #	out( B59 ) &lt;- in( B27 )  Freq: 8.55364e-05
480 +   spill R10 -&gt; R12	# spill size = 64
        nop 	# 6 bytes pad for loops and calls

490     B59: #	out( B97 B60 ) &lt;- in( B58 B64 ) Loop( B59-B64 inner ) Freq: 0.000195338
490 +   spill [sp, #16] -&gt; R11	# spill size = 64
494     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::equals
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=sp + #8 L[1]=sp + #16 L[2]=R8 L[3]=_
        # OopMap {[8]=Oop [16]=Oop off=1200/0x4b0}

4b0     B60: #	out( B90 B61 ) &lt;- in( B59 )  Freq: 0.000195334
        # Block is sole successor of call
4b0 +   spill [sp, #8] -&gt; R7	# spill size = 64
4b4 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$SetN.elements (constant)
4b8 +   decode_heap_oop  R31, R28	#@decodeHeapOop
4bc +   bne  R10, zr, B90	#@cmpI_reg_imm0_branch  P=0.000000 C=13145.000000

4c0     B61: #	out( B99 B62 ) &lt;- in( B60 )  Freq: 0.000195334
4c0     lwu  R30, [R31, #12]	# range, #@loadRange
4c4     NullCheck R31

4c4     B62: #	out( B89 B63 ) &lt;- in( B61 )  Freq: 0.000195333
4c4 +   addiw  R8, R8, #1	#@addI_reg_imm
4c8 +   beq  R8, R30, B89	#@cmpI_branch  P=0.000076 C=13146.000000

4cc     B63: #	out( B76 B64 ) &lt;- in( B89 B62 )  Freq: 0.000195333
4cc +   ld  R10, [R23, #920]	# ptr, #@loadP
4d0 +   lwu zr, [R10]	# Safepoint: poll for GC, #@safePoint        # java.util.ImmutableCollections$SetN::probe @ bci:53 (line 1017) L[0]=R7 L[1]=sp + #16 L[2]=R8 L[3]=_
        # OopMap {t2=Oop xmethod=Oop [8]=Oop [16]=Oop off=1232/0x4d0}
4d4 +   bgeu  R8, R30, B76	#@cmpU_branch  P=0.000001 C=-1.000000

4d8     B64: #	out( B59 B65 ) &lt;- in( B63 )  Freq: 0.000195333
4d8 +   addw  R7, R8, zr	#@convI2L_reg_reg
4dc +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
4e0 +   add R7, R31, R7	# ptr, #@addP_reg_reg
4e4 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN
4e8 +   decode_heap_oop  R12, R28	#@decodeHeapOop
4ec +   bne   R12, zr, B59	#@cmpP_imm0_branch  P=0.562112 C=13146.000000

4f0     B65: #	out( B51 ) &lt;- in( B64 )  Freq: 8.5534e-05
4f0 +   j  B51	#@branch

4f4     B66: #	out( B47 ) &lt;- in( B46 )  Freq: 5.48706e-05
4f4 +   li R8, #0	# int, #@loadConI
4f8 +   j  B47	#@branch

4fc     B67: #	out( B36 ) &lt;- in( B35 )  Freq: 4.27448e-05
4fc +   li R30, #0	# int, #@loadConI
500 +   j  B36	#@branch

504     B68: #	out( N851 ) &lt;- in( B25 )  Freq: 1.01327e-06
504 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
50c +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
514 +   li R11, #-28	# int, #@loadConI
518     spill R31 -&gt; [sp, #16]	# spill size = 64
51c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:18 (line 1009) L[0]=sp + #0 L[1]=sp + #8 L[2]=R8 L[3]=_ STK[0]=sp + #16 STK[1]=R8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=1312/0x520}
520     #@ShouldNotReachHere

52c     B69: #	out( N851 ) &lt;- in( B23 )  Freq: 9.99995e-07
52c +   li R11, #-122	# int, #@loadConI
530     spill R10 -&gt; R8	# spill size = 32
534     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;div0_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.Math::floorMod @ bci:2 (line 1342) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8 STK[1]=#0
        # java.util.ImmutableCollections$SetN::probe @ bci:9 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=1336/0x538}
538     #@ShouldNotReachHere

544     B70: #	out( B71 ) &lt;- in( B28 )  Freq: 5.69486e-07
544 +   spill R8 -&gt; R30	# spill size = 32

548     B71: #	out( B72 ) &lt;- in( B70 B40 )  Freq: 1.30052e-06
548 +   li R10, #1	# int, #@loadConI
54c     spill R30 -&gt; R8	# spill size = 32

550     B72: #	out( B73 ) &lt;- in( B71 B34 B84 )  Freq: 1.91192e-06
550 +   spill R10 -&gt; [sp, #0]	# spill size = 32

554     B73: #	out( N851 ) &lt;- in( B72 B90 )  Freq: 1.91201e-06
554 +   li R11, #-187	# int, #@loadConI
558     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:34 (line 1012) L[0]=sp + #8 L[1]=sp + #16 L[2]=R8 L[3]=_ STK[0]=sp + #0
        # OopMap {[8]=Oop [16]=Oop off=1372/0x55c}
55c     #@ShouldNotReachHere

568     B74: #	out( N851 ) &lt;- in( B32 B43 )  Freq: 1.30052e-06
568     #@ShouldNotReachHere

574     B75: #	out( B76 ) &lt;- in( B36 )  Freq: 5.69484e-07
574 +   spill R30 -&gt; R8	# spill size = 32

578     B76: #	out( N851 ) &lt;- in( B75 B47 B63 )  Freq: 1.30072e-06
578 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
580 +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
588 +   li R11, #-28	# int, #@loadConI
58c     spill R31 -&gt; [sp, #16]	# spill size = 64
590     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:18 (line 1009) L[0]=sp + #0 L[1]=sp + #8 L[2]=R8 L[3]=_ STK[0]=sp + #16 STK[1]=R8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=1428/0x594}
594     #@ShouldNotReachHere

5a0     B77: #	out( N851 ) &lt;- in( B31 )  Freq: 5.69485e-07
5a0     #@ShouldNotReachHere

5ac     B78: #	out( N851 ) &lt;- in( B8 )  Freq: 5.02177e-07
5ac +   li R11, #-138	# int, #@loadConI
5b0     spill R29 -&gt; [sp, #0]	# spill size = 64
5b4 +   spill R14 -&gt; [sp, #24]	# spill size = 64
5b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:13 (line 196) L[0]=_ L[1]=#0 L[2]=sp + #0 L[3]=R8 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=R8
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=sp + #24 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_
        # OopMap {[0]=Oop [8]=Oop [24]=Oop off=1468/0x5bc}
5bc     #@ShouldNotReachHere

5c8     B79: #	out( B16 ) &lt;- in( B9 )  Freq: 5.02176e-07
5c8 +   li R15, #1	# int, #@loadConI
5cc +   j  B16	#@branch

5d0     B80: #	out( N851 ) &lt;- in( B10 )  Freq: 4.95595e-07
5d0     #@ShouldNotReachHere

5dc     B81: #	out( N851 ) &lt;- in( B11 )  Freq: 4.95594e-07
5dc     #@ShouldNotReachHere

5e8     B82: #	out( B83 ) &lt;- in( B30 )  Freq: 2.81011e-07
5e8 +   spill R8 -&gt; R30	# spill size = 32

5ec     B83: #	out( N851 ) &lt;- in( B82 B42 )  Freq: 6.41739e-07
5ec +   spill [sp, #8] -&gt; R8	# spill size = 64
5f0 +   li R11, #-187	# int, #@loadConI
5f4     spill R30 -&gt; [sp, #8]	# spill size = 32
5f8 +   spill R12 -&gt; [sp, #16]	# spill size = 64
5fc +   spill R10 -&gt; [sp, #24]	# spill size = 64
600 +   spill R15 -&gt; [sp, #12]	# spill size = 32
604 +   spill R29 -&gt; [sp, #32]	# spill size = 32
608     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #16 L[1]=_ L[2]=sp + #24 STK[0]=sp + #12 STK[1]=sp + #32
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=R8 L[1]=sp + #16 L[2]=sp + #8 L[3]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop off=1548/0x60c}
60c     #@ShouldNotReachHere

618     B84: #	out( B72 ) &lt;- in( B45 )  Freq: 3.43673e-07
618 +   spill R30 -&gt; R8	# spill size = 32
61c +   j  B72	#@branch

620     B85: #	out( N851 ) &lt;- in( B5 )  Freq: 2.6252e-07
620 +   li R11, #-187	# int, #@loadConI
624     spill R14 -&gt; [sp, #16]	# spill size = 64
628     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=R8
        # java.lang.String::hashCode @ bci:17 (line 2337) L[0]=sp + #16 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=_
        # OopMap {[8]=Oop [16]=Oop off=1580/0x62c}
62c     #@ShouldNotReachHere

638     B86: #	out( N851 ) &lt;- in( B17 )  Freq: 2.51088e-07
638     #@ShouldNotReachHere

644     B87: #	out( N851 ) &lt;- in( B18 )  Freq: 2.51087e-07
644     #@ShouldNotReachHere

650     B88: #	out( N851 ) &lt;- in( B52 )  Freq: 3.85778e-08
650 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
658 +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
660 +   li R11, #-187	# int, #@loadConI
664     spill R7 -&gt; [sp, #16]	# spill size = 32
668     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.Math::floorMod @ bci:11 (line 1344) L[0]=_ L[1]=sp + #16 L[2]=R8 STK[0]=R8
        # java.util.ImmutableCollections$SetN::probe @ bci:9 (line 1007) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=_
        # OopMap {[0]=Oop [8]=Oop off=1644/0x66c}
66c     #@ShouldNotReachHere

678     B89: #	out( B63 ) &lt;- in( B62 )  Freq: 1.48562e-08
678 +   li R8, #0	# int, #@loadConI
67c +   j  B63	#@branch

680     B90: #	out( B73 ) &lt;- in( B60 )  Freq: 9.31424e-11
680 +   spill R10 -&gt; [sp, #0]	# spill size = 32
684 +   j  B73	#@branch

688     B91: #	out( B92 ) &lt;- in( B29 )  Freq: 1e-35
688 +   spill R8 -&gt; R30	# spill size = 32

68c     B92: #	out( N851 ) &lt;- in( B91 B41 )  Freq: 1e-35
68c +   spill [sp, #8] -&gt; R8	# spill size = 64
690 +   li R11, #-34	# int, #@loadConI
694     spill R30 -&gt; [sp, #8]	# spill size = 32
698 +   spill R12 -&gt; [sp, #16]	# spill size = 64
69c +   spill R10 -&gt; [sp, #32]	# spill size = 64
6a0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #16 L[1]=sp + #32 L[2]=_ STK[0]=sp + #32
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=R8 L[1]=sp + #16 L[2]=sp + #8 L[3]=_
        # OopMap {fp=Oop [16]=Oop [32]=Oop off=1700/0x6a4}
6a4     #@ShouldNotReachHere

6b0     B93: #	out( N851 ) &lt;- in( B1 )  Freq: 1.01328e-06
6b0 +   li R11, #-10	# int, #@loadConI
6b4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # OopMap {off=1720/0x6b8}
6b8     #@ShouldNotReachHere

6c4     B94: #	out( N851 ) &lt;- in( B22 )  Freq: 1.01328e-06
6c4 +   li R11, #-10	# int, #@loadConI
6c8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:8 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=1740/0x6cc}
6cc     #@ShouldNotReachHere

6d8     B95: #	out( N851 ) &lt;- in( B6 )  Freq: 5.32012e-07
6d8 +   li R11, #-10	# int, #@loadConI
6dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:5 (line 196) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=_ L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=1760/0x6e0}
6e0     #@ShouldNotReachHere

6ec     B96: #	out( B98 ) &lt;- in( B56 )  Freq: 4.8834e-09
6ec      -- 	// exception oop; no code emitted, #@CreateException
6ec +   spill R10 -&gt; R11	# spill size = 64
6f0 +   j  B98	#@branch

6f4     B97: #	out( B98 ) &lt;- in( B59 )  Freq: 1.95338e-09
6f4      -- 	// exception oop; no code emitted, #@CreateException
6f4 +   spill R10 -&gt; R11	# spill size = 64

6f8     B98: #	out( N851 ) &lt;- in( B96 B97 )  Freq: 6.83678e-09
6f8     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
704 +   j rethrow_stub	#@RethrowException

70c     B99: #	out( N851 ) &lt;- in( B61 )  Freq: 1.97927e-10
70c +   li R11, #-10	# int, #@loadConI
710     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:47 (line 1014) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=1812/0x714}
714     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='398'>
----------------------- MetaData before Compile_id = 398 ------------------------
{method}
 - this oop:          0x00000040962b9ef8
 - method holder:     &apos;sun/nio/fs/UnixPath&apos;
 - constants:         0x00000040962b5440 constant pool [472] {0x00000040962b5440} for &apos;sun/nio/fs/UnixPath&apos; cache=0x00000040962ba1a0
 - access:            0x81001041  public volatile synthetic 
 - name:              &apos;getFileSystem&apos;
 - signature:         &apos;()Ljava/nio/file/FileSystem;&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      5
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4ff400
 - code size:         5
 - code start:        0x00000040962b9ee0
 - code end (excl):   0x00000040962b9ee5
 - method data:       0x0000004096483888
 - checked ex length: 0
 - linenumber start:  0x00000040962b9ee5
 - localvar length:   1
 - localvar start:    0x00000040962b9eea
 - compiled code: nmethod  16435  164       3       sun.nio.fs.UnixPath::getFileSystem (5 bytes)

------------------------ OptoAssembly for Compile_id = 398 -----------------------
#
#  sun/nio/fs/LinuxFileSystem * ( sun/nio/fs/UnixPath:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixPath:NotNull *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N16: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N16 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     lwu  R28, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
040 +   decode_heap_oop  R10, R28	#@decodeHeapOop
044     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
05c +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='399'>
----------------------- MetaData before Compile_id = 399 ------------------------
{method}
 - this oop:          0x00000040962e4308
 - method holder:     &apos;java/nio/file/Files&apos;
 - constants:         0x00000040962e1770 constant pool [1157]/operands[42] {0x00000040962e1770} for &apos;java/nio/file/Files&apos; cache=0x00000040962e97c0
 - access:            0x8100000a  private static 
 - name:              &apos;provider&apos;
 - signature:         &apos;(Ljava/nio/file/Path;)Ljava/nio/file/spi/FileSystemProvider;&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4ff840
 - code size:         10
 - code start:        0x00000040962e42e8
 - code end (excl):   0x00000040962e42f2
 - method data:       0x0000004096483a38
 - checked ex length: 0
 - linenumber start:  0x00000040962e42f2
 - localvar length:   1
 - localvar start:    0x00000040962e42fa
 - compiled code: nmethod  16474  165       3       java.nio.file.Files::provider (10 bytes)

------------------------ OptoAssembly for Compile_id = 399 -----------------------
#
#  sun/nio/fs/LinuxFileSystemProvider * ( java/nio/file/Path * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/nio/file/Path *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N1: #	out( B1 ) &lt;- in( B6 B5 B7 B4 )  Freq: 1

000     B1: #	out( B6 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
01c     lwu  R7, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
020     NullCheck R11

020     B2: #	out( B5 B3 ) &lt;- in( B1 )  Freq: 0.999999
020 +   mv  R29, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d05a81e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
030 +   bne  R7, R29, B5	#@cmpN_branch  P=0.000001 C=-1.000000

034     B3: #	out( B7 B4 ) &lt;- in( B2 )  Freq: 0.999998
034 +   # checkcastPP of R11, #@checkCastPP
034     lwu  R7, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
038 +   decode_heap_oop  R7, R7	#@decodeHeapOop
03c     lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileSystem.provider
040     NullCheck R7

040     B4: #	out( N1 ) &lt;- in( B3 )  Freq: 0.999997
040 +   decode_heap_oop  R10, R28	#@decodeHeapOop
044     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
05c +   ret	// return register, #@Ret

060     B5: #	out( N1 ) &lt;- in( B2 )  Freq: 9.99999e-07
060 +   spill R11 -&gt; R8	# spill size = 64
064 +   li R11, #-34	# int, #@loadConI
068     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::provider @ bci:1 (line 105) L[0]=_ STK[0]=R8
        # OopMap {fp=Oop off=108/0x6c}
06c     #@ShouldNotReachHere

078     B6: #	out( N1 ) &lt;- in( B1 )  Freq: 1.01328e-06
078 +   li R11, #-10	# int, #@loadConI
07c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::provider @ bci:1 (line 105) L[0]=_ STK[0]=#NULL
        # OopMap {off=128/0x80}
080     #@ShouldNotReachHere

08c     B7: #	out( N1 ) &lt;- in( B3 )  Freq: 1.01328e-06
08c +   li R11, #-10	# int, #@loadConI
090     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::provider @ bci:6 (line 105) L[0]=_ STK[0]=#NULL
        # OopMap {off=148/0x94}
094 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='407'>
----------------------- MetaData before Compile_id = 407 ------------------------
{method}
 - this oop:          0x000000409611ffc8
 - method holder:     &apos;java/lang/Character&apos;
 - constants:         0x000000409611d860 constant pool [576] {0x000000409611d860} for &apos;java/lang/Character&apos; cache=0x00000040961e65e8
 - access:            0x81000009  public static 
 - name:              &apos;charCount&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         3
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b960: 0xa i2c: 0x00000040139d7540 c2i: 0x00000040139d7584 c2iUV: 0x00000040139d7550
 - compiled entry     0x000000400c4ef240
 - code size:         12
 - code start:        0x000000409611ffa8
 - code end (excl):   0x000000409611ffb4
 - method data:       0x00000040965eca50
 - checked ex length: 0
 - linenumber start:  0x000000409611ffb4
 - localvar length:   1
 - localvar start:    0x000000409611ffba
 - compiled code: nmethod  16520  115       3       java.lang.Character::charCount (12 bytes)

------------------------ OptoAssembly for Compile_id = 407 -----------------------
#
#  int ( int )
#
#r012 c_rarg1   : parm 0: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N1: #	out( B1 ) &lt;- in( B3 B2 )  Freq: 1

000     B1: #	out( B3 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
01c     li R7, #65536	# int, #@loadConI
020 +   bge  R11, R7, B3	#@cmpI_branch  P=0.000000 C=40191.000000

024     B2: #	out( N1 ) &lt;- in( B1 )  Freq: 1
024 +   li R10, #1	# int, #@loadConI
028     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
040 +   ret	// return register, #@Ret

044     B3: #	out( N1 ) &lt;- in( B1 )  Freq: 4.76837e-07
044 +   spill R11 -&gt; R8	# spill size = 32
048 +   li R11, #-187	# int, #@loadConI
04c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.Character::charCount @ bci:3 (line 8862) L[0]=_ STK[0]=R8 STK[1]=#65536
        # OopMap {off=80/0x50}
050 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='408'>
----------------------- MetaData before Compile_id = 408 ------------------------
{method}
 - this oop:          0x000000409600c1a8
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;substring&apos;
 - signature:         &apos;(I)Ljava/lang/String;&apos;
 - max stack:         4
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bb30: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c5345c0
 - code size:         10
 - code start:        0x000000409600c178
 - code end (excl):   0x000000409600c182
 - method data:       0x000000409649aa40
 - checked ex length: 0
 - linenumber start:  0x000000409600c182
 - localvar length:   2
 - localvar start:    0x000000409600c18e
 - compiled code: nmethod  16544  249       3       java.lang.String::substring (10 bytes)

------------------------ OptoAssembly for Compile_id = 408 -----------------------
#
#  java/lang/String:exact * ( java/lang/String:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N110: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B12 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
040 +   spill R11 -&gt; R10	# spill size = 64
044 +   decode_heap_oop  R11, R7	#@decodeHeapOop
048     lwu  R28, [R11, #12]	# range, #@loadRange
04c     NullCheck R11

04c     B2: #	out( B8 B3 ) &lt;- in( B1 )  Freq: 0.999999
04c +   lb  R7, [R10, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
050 +   sraw  R8, R28, R7	#@rShiftI_reg_reg
054 +   blt  R12, zr, B8	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

058     B3: #	out( B9 B4 ) &lt;- in( B2 )  Freq: 0.999999
058 +   bgt  R12, R8, B9	#@cmpI_branch  P=0.000000 C=5375.000000

05c     B4: #	out( B7 B5 ) &lt;- in( B3 )  Freq: 0.999998
05c +   beq  R12, zr, B7	#@cmpI_reg_imm0_branch  P=0.372210 C=5376.000000

060     B5: #	out( B10 B6 ) &lt;- in( B4 )  Freq: 0.627789
060 +   subw  R13, R8, R12	#@subI_reg_reg
064 +   bne  R7, zr, B10	#@cmpI_reg_imm0_branch  P=0.000000 C=71048.000000

068     B6: #	out( B11 B7 ) &lt;- in( B5 )  Freq: 0.627789
068     CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringLatin1::newString
        # java.lang.String::substring @ bci:41 (line 2707) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # OopMap {off=108/0x6c}

06c     B7: #	out( N110 ) &lt;- in( B4 B6 )  Freq: 0.999985
06c     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
084 +   ret	// return register, #@Ret

088     B8: #	out( N110 ) &lt;- in( B2 )  Freq: 4.99999e-07
088 +   li R11, #-187	# int, #@loadConI
08c     spill R10 -&gt; [sp, #0]	# spill size = 64
090 +   spill R12 -&gt; [sp, #12]	# spill size = 32
094 +   spill R12 -&gt; [sp, #16]	# spill size = 32
098     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:1 (line 4598) L[0]=sp + #16 L[1]=R8 L[2]=R8 STK[0]=sp + #12
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #0 L[1]=sp + #12 L[2]=R8 L[3]=R8 L[4]=_
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # OopMap {[0]=Oop off=156/0x9c}
09c     #@ShouldNotReachHere

0a8     B9: #	out( N110 ) &lt;- in( B3 )  Freq: 4.76836e-07
0a8 +   li R11, #-187	# int, #@loadConI
0ac     spill R10 -&gt; [sp, #0]	# spill size = 64
0b0 +   spill R12 -&gt; [sp, #12]	# spill size = 32
0b4 +   spill R12 -&gt; [sp, #16]	# spill size = 32
0b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:6 (line 4598) L[0]=sp + #16 L[1]=R8 L[2]=R8 STK[0]=sp + #12 STK[1]=R8
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #0 L[1]=sp + #12 L[2]=R8 L[3]=R8 L[4]=_
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # OopMap {[0]=Oop off=188/0xbc}
0bc     #@ShouldNotReachHere

0c8     B10: #	out( N110 ) &lt;- in( B5 )  Freq: 3.13894e-07
0c8 +   li R11, #-187	# int, #@loadConI
0cc     spill R10 -&gt; R8	# spill size = 64
0d0 +   spill R12 -&gt; [sp, #0]	# spill size = 32
0d4 +   spill R13 -&gt; [sp, #4]	# spill size = 32
0d8 +   spill R7 -&gt; [sp, #8]	# spill size = 32
0dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #8
        # java.lang.String::substring @ bci:28 (line 2707) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=sp + #4
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=224/0xe0}
0e0     #@ShouldNotReachHere

0ec     B11: #	out( N110 ) &lt;- in( B6 )  Freq: 6.27789e-06
0ec      -- 	// exception oop; no code emitted, #@CreateException
0ec +   spill R10 -&gt; R11	# spill size = 64
0f0 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
0fc +   j rethrow_stub	#@RethrowException

104     B12: #	out( N110 ) &lt;- in( B1 )  Freq: 1.01328e-06
104 +   li R11, #-10	# int, #@loadConI
108     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::substring @ bci:3 (line 2675) L[0]=_ L[1]=_ STK[0]=_ STK[1]=_
        # OopMap {off=268/0x10c}
10c     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='429'>
----------------------- MetaData before Compile_id = 429 ------------------------
{method}
 - this oop:          0x000000409615df98
 - method holder:     &apos;java/util/Objects&apos;
 - constants:         0x000000409615d300 constant pool [151] {0x000000409615d300} for &apos;java/util/Objects&apos; cache=0x000000409615e9e0
 - access:            0x81000009  public static 
 - name:              &apos;requireNonNull&apos;
 - signature:         &apos;(Ljava/lang/Object;)Ljava/lang/Object;&apos;
 - max stack:         3
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4aeb40
 - code size:         14
 - code start:        0x000000409615df68
 - code end (excl):   0x000000409615df76
 - method data:       0x00000040963c4fb0
 - checked ex length: 0
 - linenumber start:  0x000000409615df76
 - localvar length:   1
 - localvar start:    0x000000409615df80
 - compiled code: nmethod  16873   11       3       java.util.Objects::requireNonNull (14 bytes)

------------------------ OptoAssembly for Compile_id = 429 -----------------------
#
#  java/lang/Object * ( java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/Object *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B3 B2 )  Freq: 1

000     B1: #	out( B3 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     spill R11 -&gt; R10	# spill size = 64
020 +   beq   R11, zr, B3	#@cmpP_imm0_branch  P=0.000000 C=24831.000000

024     B2: #	out( N1 ) &lt;- in( B1 )  Freq: 1
024     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
03c +   ret	// return register, #@Ret

040     B3: #	out( N1 ) &lt;- in( B1 )  Freq: 4.76837e-07
040 +   li R11, #-187	# int, #@loadConI
044     spill R10 -&gt; [sp, #0]	# spill size = 64
048     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.Objects::requireNonNull @ bci:1 (line 208) L[0]=sp + #0 STK[0]=sp + #0
        # OopMap {[0]=Oop off=76/0x4c}
04c +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='434'>
----------------------- MetaData before Compile_id = 434 ------------------------
{method}
 - this oop:          0x00000040962b9ce8
 - method holder:     &apos;sun/nio/fs/UnixPath&apos;
 - constants:         0x00000040962b5440 constant pool [472] {0x00000040962b5440} for &apos;sun/nio/fs/UnixPath&apos; cache=0x00000040962ba1a0
 - access:            0x81001041  public volatile synthetic 
 - name:              &apos;getParent&apos;
 - signature:         &apos;()Ljava/nio/file/Path;&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      32
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c530300
 - code size:         5
 - code start:        0x00000040962b9cd0
 - code end (excl):   0x00000040962b9cd5
 - method data:       0x0000004096498138
 - checked ex length: 0
 - linenumber start:  0x00000040962b9cd5
 - localvar length:   1
 - localvar start:    0x00000040962b9cda
 - compiled code: nmethod  17044  245       3       sun.nio.fs.UnixPath::getParent (5 bytes)

------------------------ OptoAssembly for Compile_id = 434 -----------------------
#
#  java/nio/file/Path * ( sun/nio/fs/UnixPath:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixPath:NotNull *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N376: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B39 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
03c     spill R11 -&gt; [sp, #0]	# spill size = 64
040     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 276) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # OopMap {[0]=Oop off=68/0x44}

044     B2: #	out( B33 B3 ) &lt;- in( B1 )  Freq: 0.99998
        # Block is sole successor of call
044 +   spill [sp, #0] -&gt; R7	# spill size = 64
048 +   lwu  R28, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
04c +   #@membar_acquire
	fence ir iorw
050 +   decode_heap_oop  R7, R28	#@decodeHeapOop
054     lwu  R29, [R7, #12]	# range, #@loadRange
058     NullCheck R7

058     B3: #	out( B32 B4 ) &lt;- in( B2 )  Freq: 0.999979
058 +   bleu  R29, zr, B32	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=5375.000000

05c     B4: #	out( B34 B5 ) &lt;- in( B3 )  Freq: 0.999978
05c +   spill [sp, #0] -&gt; R7	# spill size = 64
060 +   lwu  R7, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
064 +   decode_heap_oop  R30, R7	#@decodeHeapOop
068 +   addw  R28, R29, zr	#@convI2L_reg_reg
06c +   #@membar_acquire
	fence ir iorw
070 +   slli  R7, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
074 +   addiw  R8, R29, #-1	#@addI_reg_imm
078     lwu  R29, [R30, #12]	# range, #@loadRange
07c     NullCheck R30

07c     B5: #	out( B28 B6 ) &lt;- in( B4 )  Freq: 0.999977
07c +   add R7, R30, R7	# ptr, #@addP_reg_reg
080 +   bgeu  R8, R29, B28	#@cmpU_branch  P=0.000001 C=-1.000000

084     B6: #	out( B21 B7 ) &lt;- in( B5 )  Freq: 0.999976
084 +   lw  R8, [R7, #12]	# int, #@loadI
088 +   addiw  R28, R8, #-1	#@addI_reg_imm
08c +   ble  R28, zr, B21	#@cmpI_reg_imm0_branch  P=0.001488 C=5375.000000

090     B7: #	out( B29 B8 ) &lt;- in( B6 )  Freq: 0.998488
090 +   spill [sp, #0] -&gt; R7	# spill size = 64
094 +   lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
098 +   li R29, #1048576	# int, #@loadConI
09c +   decode_heap_oop  R31, R7	#@decodeHeapOop
0a0 +   bgtu  R28, R29, B29	#@cmpU_branch  P=0.000001 C=-1.000000

0a4     B8: #	out( B9 ) &lt;- in( B7 )  Freq: 0.998487
0a4 +   addw  R7, R8, zr	#@convI2L_reg_reg
0a8 +   addi  R7, R7, #-1	#@addL_reg_imm

0ac     B9: #	out( B35 B10 ) &lt;- in( B8 B29 )  Freq: 0.998488
0ac     lwu  R30, [R31, #12]	# range, #@loadRange
0b0     NullCheck R31

0b0     B10: #	out( B31 B11 ) &lt;- in( B9 )  Freq: 0.998487
0b0 +   addi  R10, R7, #23	#@addL_reg_imm
0b4 +   bltu  R30, R28, B31	#@cmpU_branch  P=0.000001 C=-1.000000

0b8     B11: #	out( B26 B12 ) &lt;- in( B10 )  Freq: 0.998486
0b8 +   andi  R12, R10, #-8	#@andL_reg_imm
0bc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0bc     bgtu  R28, R29, B26	#@cmpU_branch  P=0.000001 C=-1.000000

0c0     B12: #	out( B26 B13 ) &lt;- in( B11 )  Freq: 0.998485
0c0 +   ld  R9, [R23, #288]	# ptr, #@loadP
0c4 +   ld  R29, [R23, #304]	# ptr, #@loadP
0c8 +   add R7, R9, R12	# ptr, #@addP_reg_reg
0cc +   bgeu  R7, R29, B26	#@cmpP_branch  P=0.000100 C=-1.000000

0d0     B13: #	out( B14 ) &lt;- in( B12 )  Freq: 0.998385
0d0 +   sd  R7, [R23, #288]	# ptr, #@storeP
0d4 +   li R7, #1	# long, #@loadConL
0d8 +   mv  R29, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0e8 +   sd  R7, [R9]	# long, #@storeL
0ec +   sw  R29, [R9, #8]	# compressed klass ptr, #@storeNKlass
0f0 +   sw  R28, [R9, #12]	# int, #@storeI

0f4     B14: #	out( B30 B15 ) &lt;- in( B27 B13 )  Freq: 0.998486
0f4 +   srli  R7, R10, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
0f8     
0f8 +   # checkcastPP of R9, #@checkCastPP
0f8     encode_heap_oop  R10, R9	#@encodeHeapOop
0fc +   li R29, #1	# int, #@loadConI
100 +   # castII of R8, #@castII
100     addi  R11, R9, #16	# ptr, #@addP_reg_imm
104     spill R10 -&gt; [sp, #16]	# spill size = 32
108 +   beq  R8, R29, B30	#@cmpI_branch  P=0.000001 C=-1.000000

10c     B15: #	out( B23 B16 ) &lt;- in( B14 )  Freq: 0.998485
10c +   addiw  R30, R8, #-1	#@addI_reg_imm
110 +   addi  R10, R31, #16	# ptr, #@addP_reg_imm
114 +   blt  R30, R28, B23	#@cmpI_branch  P=0.001000 C=-1.000000

118     B16: #	out( B17 ) &lt;- in( B15 )  Freq: 0.997487
118 +   addi  R7, R12, #-16	#@addL_reg_imm
11c +   srli  R12, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
120 +   CALL, runtime leaf nofp 0x000000401396d840	#@CallLeafNoFPDirect jlong_disjoint_arraycopy
        No JVM State Info
        # 

124     B17: #	out( B24 B18 ) &lt;- in( B23 B16 B30 )  Freq: 0.998486
124     MEMBAR-store-store	#@membar_storestore
128 +   ld  R10, [R23, #288]	# ptr, #@loadP
12c +   ld  R7, [R23, #304]	# ptr, #@loadP
130 +   addi  R28, R10, #32	# ptr, #@addP_reg_imm
134 +   bgeu  R28, R7, B24	#@cmpP_branch  P=0.000100 C=-1.000000

138     B18: #	out( B19 ) &lt;- in( B17 )  Freq: 0.998386
138 +   li R7, #1	# long, #@loadConL
13c +   sd  R28, [R23, #288]	# ptr, #@storeP
140 +   sd  R7, [R10]	# long, #@storeL
144 +   mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d01ed040:Constant:exact *	# compressed klass ptr, #@loadConNKlass
154 +   sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
158 +   sw  zr, [R10, #12]	# int, #@storeimmI0
15c +   sw  zr, [R10, #16]	# int, #@storeimmI0
160 +   sd  zr, [R10, #24]	# long, #@storeimmL0

164     B19: #	out( B20 ) &lt;- in( B25 B18 )  Freq: 0.998486
164     spill [sp, #16] -&gt; R7	# spill size = 32
168 +   sw  R7, [R10, #20]	# compressed ptr, #@storeN
16c     
16c     spill [sp, #0] -&gt; R7	# spill size = 64
170 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
174 +   # checkcastPP of R10, #@checkCastPP
174     sw  R28, [R10, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixPath.fs
178 +   #@membar_release
	fence iorw ow

17c     B20: #	out( N376 ) &lt;- in( B22 B19 )  Freq: 0.999974
17c     # checkcastPP of R10, #@checkCastPP
17c     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
194 +   ret	// return register, #@Ret

198     B21: #	out( B38 B22 ) &lt;- in( B6 )  Freq: 0.00148835
198 +   spill [sp, #0] -&gt; R11	# spill size = 64
19c     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::getRoot
        # sun.nio.fs.UnixPath::getParent @ bci:32 (line 286) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # OopMap {off=416/0x1a0}

1a0     B22: #	out( B20 ) &lt;- in( B21 )  Freq: 0.00148832
        # Block is sole successor of call
1a0 +   j  B20	#@branch

1a4     B23: #	out( B17 ) &lt;- in( B15 )  Freq: 0.000998485
1a4 +   addw  R30, R8, zr	#@convI2L_reg_reg
1a8 +   addi  R28, R30, #15	#@addL_reg_imm
1ac +   srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
1b0 +   andi  R28, R28, #-8	#@andL_reg_imm
1b4 +   add R28, R9, R28	# ptr, #@addP_reg_reg
1b8 +   sub  R29, R7, R29	#@subL_reg_reg
1bc     ClearArray R29, R28	#@clearArray_reg_reg
214 +   addi  R12, R30, #-1	#@addL_reg_imm
218     CALL, runtime leaf nofp 0x000000401396cf00	#@CallLeafNoFPDirect arrayof_jbyte_disjoint_arraycopy
        No JVM State Info
        # 
21c +   j  B17	#@branch

220     B24: #	out( B36 B25 ) &lt;- in( B17 )  Freq: 9.98652e-05
220 +   mv  R11, precise klass sun/nio/fs/UnixPath: 0x00000040d01ed040:Constant:exact *	# ptr, #@loadConP
238     spill [sp, #0] -&gt; R8	# spill size = 64
23c +   spill R9 -&gt; [sp, #8]	# spill size = 64
240     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixPath::getParent @ bci:51 (line 290) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #8
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=NarrowOop off=580/0x244}

244     B25: #	out( B19 ) &lt;- in( B24 )  Freq: 9.98632e-05
        # Block is sole successor of call
244 +   j  B19	#@branch

248     B26: #	out( B37 B27 ) &lt;- in( B11 B12 )  Freq: 0.000100877
248 +   spill R12 -&gt; [sp, #32]	# spill size = 64
24c +   spill R10 -&gt; [sp, #24]	# spill size = 64
250 +   spill R31 -&gt; [sp, #16]	# spill size = 64
254 +   spill R28 -&gt; [sp, #8]	# spill size = 32
258 +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
270     spill R28 -&gt; R12	# spill size = 32
274     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=sp + #0 L[1]=_ L[2]=sp + #8 L[3]=_
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # OopMap {[0]=Oop [16]=Oop off=632/0x278}

278     B27: #	out( B14 ) &lt;- in( B26 )  Freq: 0.000100875
        # Block is sole successor of call
278 +   spill R10 -&gt; R9	# spill size = 64
27c +   spill [sp, #8] -&gt; R28	# spill size = 32
280 +   spill [sp, #16] -&gt; R31	# spill size = 64
284 +   spill [sp, #24] -&gt; R10	# spill size = 64
288 +   spill [sp, #32] -&gt; R12	# spill size = 64
28c +   j  B14	#@branch

290     B28: #	out( N376 ) &lt;- in( B5 )  Freq: 1.01326e-06
290 +   li R11, #-28	# int, #@loadConI
294     spill R30 -&gt; [sp, #8]	# spill size = 64
298     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:23 (line 283) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #8 STK[1]=R8
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # OopMap {[0]=Oop [8]=Oop off=668/0x29c}
29c     #@ShouldNotReachHere

2a8     B29: #	out( B9 ) &lt;- in( B7 )  Freq: 1.01175e-06
2a8 +   addw  R7, R28, zr	#@convI2L_reg_reg
2ac +   j  B9	#@branch

2b0     B30: #	out( B17 ) &lt;- in( B14 )  Freq: 1.01174e-06
2b0 +   spill R11 -&gt; R28	# spill size = 64
2b4 +   addi  R29, R7, #-2	#@addL_reg_imm
2b8     ClearArray R29, R28	#@clearArray_reg_reg
310     
310 +   j  B17	#@branch

314     B31: #	out( N376 ) &lt;- in( B10 )  Freq: 9.98487e-07
314 +   spill [sp, #0] -&gt; R8	# spill size = 64
318 +   li R11, #-52	# int, #@loadConI
31c     spill R28 -&gt; [sp, #4]	# spill size = 32
320     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=R8 L[1]=_ L[2]=sp + #4 L[3]=_ STK[0]=sp + #4
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # OopMap {fp=Oop off=804/0x324}
324     #@ShouldNotReachHere

330     B32: #	out( N376 ) &lt;- in( B3 )  Freq: 4.76827e-07
330 +   spill [sp, #0] -&gt; R8	# spill size = 64
334 +   li R11, #-187	# int, #@loadConI
338     spill R29 -&gt; [sp, #4]	# spill size = 32
33c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:11 (line 279) L[0]=R8 L[1]=sp + #4 L[2]=_ L[3]=_ STK[0]=sp + #4
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # OopMap {fp=Oop off=832/0x340}
340     #@ShouldNotReachHere

34c     B33: #	out( N376 ) &lt;- in( B2 )  Freq: 1.01326e-06
34c +   li R11, #-10	# int, #@loadConI
350     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:8 (line 278) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # OopMap {off=852/0x354}
354     #@ShouldNotReachHere

360     B34: #	out( N376 ) &lt;- in( B4 )  Freq: 1.01326e-06
360 +   li R11, #-10	# int, #@loadConI
364     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:23 (line 283) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # OopMap {off=872/0x368}
368     #@ShouldNotReachHere

374     B35: #	out( N376 ) &lt;- in( B9 )  Freq: 1.01175e-06
374 +   spill [sp, #0] -&gt; R8	# spill size = 64
378 +   li R11, #-12	# int, #@loadConI
37c     spill R28 -&gt; [sp, #4]	# spill size = 32
380     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=R8 L[1]=_ L[2]=sp + #4 L[3]=_ STK[0]=sp + #4
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # OopMap {fp=Oop off=900/0x384}
384     #@ShouldNotReachHere

390     B36: #	out( B40 ) &lt;- in( B24 )  Freq: 9.98652e-10
390      -- 	// exception oop; no code emitted, #@CreateException
390 +   spill R10 -&gt; R11	# spill size = 64
394 +   j  B40	#@branch

398     B37: #	out( B40 ) &lt;- in( B26 )  Freq: 1.00877e-09
398      -- 	// exception oop; no code emitted, #@CreateException
398 +   spill R10 -&gt; R11	# spill size = 64
39c +   j  B40	#@branch

3a0     B38: #	out( B40 ) &lt;- in( B21 )  Freq: 1.48835e-08
3a0      -- 	// exception oop; no code emitted, #@CreateException
3a0 +   spill R10 -&gt; R11	# spill size = 64
3a4 +   j  B40	#@branch

3a8     B39: #	out( B40 ) &lt;- in( B1 )  Freq: 1e-05
3a8      -- 	// exception oop; no code emitted, #@CreateException
3a8 +   spill R10 -&gt; R11	# spill size = 64

3ac     B40: #	out( N376 ) &lt;- in( B39 B38 B37 B36 )  Freq: 1.00169e-05
3ac     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
3b8 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='435'>
----------------------- MetaData before Compile_id = 435 ------------------------
{method}
 - this oop:          0x000000409600cb30
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0xc1000001  public 
 - name:              &apos;replace&apos;
 - signature:         &apos;(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Ljava/lang/String;&apos;
 - max stack:         10
 - max locals:        12
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008317290: 0xbbb i2c: 0x0000004013944dc0 c2i: 0x0000004013944e0c c2iUV: 0x0000004013944dd8
 - compiled entry     0x000000400c539700
 - code size:         258
 - code start:        0x000000409600c928
 - code end (excl):   0x000000409600ca2a
 - method data:       0x000000409649b648
 - checked ex length: 0
 - linenumber start:  0x000000409600ca2a
 - localvar length:   17
 - localvar start:    0x000000409600ca58
 - compiled code: nmethod  17129  254   !   3       java.lang.String::replace (258 bytes)

------------------------ OptoAssembly for Compile_id = 435 -----------------------
#
#  java/lang/String:exact * ( java/lang/String:NotNull:exact *, java/lang/CharSequence *, java/lang/CharSequence * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/CharSequence *
#r016 c_rarg3:c_rarg3   : parm 2: java/lang/CharSequence *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N331: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B33 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
03c     spill R11 -&gt; [sp, #0]	# spill size = 64
040     lwu  R7, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
044     NullCheck R12

044     B2: #	out( B21 B3 ) &lt;- in( B1 )  Freq: 0.999999
044 +   mv  R29, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
054 +   bne  R7, R29, B21	#@cmpN_branch  P=0.000001 C=-1.000000

058     B3: #	out( B34 B4 ) &lt;- in( B2 )  Freq: 0.999998
058 +   # checkcastPP of R12, #@checkCastPP
058     lwu  R7, [R13, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
05c     NullCheck R13

05c     B4: #	out( B22 B5 ) &lt;- in( B3 )  Freq: 0.999997
05c +   bne  R7, R29, B22	#@cmpN_branch  P=0.000001 C=-1.000000

060     B5: #	out( B35 B6 ) &lt;- in( B4 )  Freq: 0.999996
060 +   lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
064 +   lwu  R28, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
068 +   # checkcastPP of R13, #@checkCastPP
068     lwu  R29, [R13, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
06c +   decode_heap_oop  R11, R7	#@decodeHeapOop
070 +   decode_heap_oop  R30, R28	#@decodeHeapOop
074 +   decode_heap_oop  R29, R29	#@decodeHeapOop
078     lwu  R28, [R11, #12]	# range, #@loadRange
07c     NullCheck R11

07c     B6: #	out( B36 B7 ) &lt;- in( B5 )  Freq: 0.999995
07c +   spill [sp, #0] -&gt; R7	# spill size = 64
080 +   lb  R10, [R7, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
084 +   sraw  R15, R28, R10	#@rShiftI_reg_reg
088     lwu  R28, [R30, #12]	# range, #@loadRange
08c     NullCheck R30

08c     B7: #	out( B37 B8 ) &lt;- in( B6 )  Freq: 0.999994
08c +   lb  R31, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
090 +   sraw  R14, R28, R31	#@rShiftI_reg_reg
094     lwu  R16, [R29, #12]	# range, #@loadRange
098     NullCheck R29

098     B8: #	out( B23 B9 ) &lt;- in( B7 )  Freq: 0.999993
098 +   lb  R9, [R13, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
09c +   sraw  R8, R16, R9	#@rShiftI_reg_reg
0a0 +   li R7, #1	# int, #@loadConI
0a4 +   ble  R14, zr, B23	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

0a8     B9: #	out( B24 B10 ) &lt;- in( B8 )  Freq: 0.999992
0a8 +   bne  R14, R7, B24	#@cmpI_branch  P=0.000000 C=5375.000000

0ac     B10: #	out( B25 B11 ) &lt;- in( B9 )  Freq: 0.999992
0ac +   bne  R8, R7, B25	#@cmpI_branch  P=0.000000 C=5375.000000

0b0     B11: #	out( B26 B12 ) &lt;- in( B10 )  Freq: 0.999991
0b0 +   bne  R31, zr, B26	#@cmpI_reg_imm0_branch  P=0.000000 C=74703.000000

0b4     B12: #	out( B29 B13 ) &lt;- in( B11 )  Freq: 0.999991
0b4 +   bleu  R28, zr, B29	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=37812.000000

0b8     B13: #	out( B27 B14 ) &lt;- in( B12 )  Freq: 0.999991
0b8 +   lbu  R12, [R30, #16]	# byte, #@loadUB
0bc +   bne  R9, zr, B27	#@cmpI_reg_imm0_branch  P=0.000000 C=74703.000000

0c0     B14: #	out( B30 B15 ) &lt;- in( B13 )  Freq: 0.99999
0c0 +   bleu  R16, zr, B30	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=37812.000000

0c4     B15: #	out( B31 B16 ) &lt;- in( B14 )  Freq: 0.99999
0c4 +   lbu  R13, [R29, #16]	# byte, #@loadUB
0c8 +   beq  R12, R13, B31	#@cmpI_branch  P=0.000000 C=5376.000000

0cc     B16: #	out( B28 B17 ) &lt;- in( B15 )  Freq: 0.999989
0cc +   bne  R10, zr, B28	#@cmpI_reg_imm0_branch  P=0.000000 C=74703.000000

0d0     B17: #	out( B32 B18 ) &lt;- in( B16 )  Freq: 0.999989
0d0     CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringLatin1::replace
        # java.lang.String::replace @ bci:18 (line 2801) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # java.lang.String::replace @ bci:63 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # OopMap {[0]=Oop off=212/0xd4}

0d4     B18: #	out( B20 B19 ) &lt;- in( B17 )  Freq: 0.999969
        # Block is sole successor of call
0d4 +   beq   R10, zr, B20	#@cmpP_imm0_branch  P=0.000744 C=5376.000000

0d8     B19: #	out( N331 ) &lt;- in( B18 B20 )  Freq: 0.999969
0d8     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0f0 +   ret	// return register, #@Ret

0f4     B20: #	out( B19 ) &lt;- in( B18 )  Freq: 0.000744021
0f4 +   spill [sp, #0] -&gt; R10	# spill size = 64
0f8 +   j  B19	#@branch

0fc     B21: #	out( N331 ) &lt;- in( B2 )  Freq: 9.99999e-07
0fc +   spill [sp, #0] -&gt; R8	# spill size = 64
100 +   li R11, #-34	# int, #@loadConI
104     spill R13 -&gt; [sp, #0]	# spill size = 64
108 +   spill R12 -&gt; [sp, #8]	# spill size = 64
10c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::replace @ bci:1 (line 2953) L[0]=R8 L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=272/0x110}
110     #@ShouldNotReachHere

11c     B22: #	out( N331 ) &lt;- in( B4 )  Freq: 9.99997e-07
11c +   spill [sp, #0] -&gt; R8	# spill size = 64
120 +   li R11, #-34	# int, #@loadConI
124     spill R12 -&gt; [sp, #0]	# spill size = 64
128 +   spill R13 -&gt; [sp, #8]	# spill size = 64
12c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::replace @ bci:8 (line 2954) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=304/0x130}
130     #@ShouldNotReachHere

13c     B23: #	out( N331 ) &lt;- in( B8 )  Freq: 4.99996e-07
13c +   li R11, #-187	# int, #@loadConI
140     spill R12 -&gt; [sp, #8]	# spill size = 64
144 +   spill R13 -&gt; [sp, #16]	# spill size = 64
148 +   spill R15 -&gt; [sp, #24]	# spill size = 32
14c +   spill R14 -&gt; [sp, #32]	# spill size = 32
150     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:36 (line 2959) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=sp + #8 L[4]=sp + #16 L[5]=sp + #24 L[6]=sp + #32 L[7]=R8 L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=sp + #32
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=340/0x154}
154     #@ShouldNotReachHere

160     B24: #	out( N331 ) &lt;- in( B9 )  Freq: 4.99996e-07
160 +   li R11, #-187	# int, #@loadConI
164     spill R12 -&gt; [sp, #8]	# spill size = 64
168 +   spill R13 -&gt; [sp, #16]	# spill size = 64
16c +   spill R15 -&gt; [sp, #24]	# spill size = 32
170 +   spill R14 -&gt; [sp, #32]	# spill size = 32
174     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:42 (line 2960) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=sp + #8 L[4]=sp + #16 L[5]=sp + #24 L[6]=sp + #32 L[7]=R8 L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=sp + #32 STK[1]=#1
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=376/0x178}
178     #@ShouldNotReachHere

184     B25: #	out( N331 ) &lt;- in( B10 )  Freq: 4.99996e-07
184 +   li R11, #-187	# int, #@loadConI
188     spill R12 -&gt; [sp, #8]	# spill size = 64
18c +   spill R13 -&gt; [sp, #16]	# spill size = 64
190 +   spill R15 -&gt; [sp, #24]	# spill size = 32
194     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:48 (line 2960) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=sp + #8 L[4]=sp + #16 L[5]=sp + #24 L[6]=#1 L[7]=R8 L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=R8 STK[1]=#1
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=408/0x198}
198     #@ShouldNotReachHere

1a4     B26: #	out( N331 ) &lt;- in( B11 )  Freq: 4.99996e-07
1a4 +   li R11, #-187	# int, #@loadConI
1a8     spill R13 -&gt; R8	# spill size = 64
1ac +   spill R12 -&gt; [sp, #8]	# spill size = 64
1b0 +   spill R31 -&gt; [sp, #16]	# spill size = 32
1b4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #16
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=sp + #8 L[1]=#0
        # java.lang.String::replace @ bci:54 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=440/0x1b8}
1b8     #@ShouldNotReachHere

1c4     B27: #	out( N331 ) &lt;- in( B13 )  Freq: 4.99995e-07
1c4 +   spill [sp, #0] -&gt; R8	# spill size = 64
1c8 +   li R11, #-187	# int, #@loadConI
1cc     spill R13 -&gt; [sp, #0]	# spill size = 64
1d0 +   spill R12 -&gt; [sp, #8]	# spill size = 32
1d4 +   spill R9 -&gt; [sp, #12]	# spill size = 32
1d8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #12
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=sp + #0 L[1]=#0
        # java.lang.String::replace @ bci:60 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=R8 STK[1]=sp + #8
        # OopMap {fp=Oop [0]=Oop off=476/0x1dc}
1dc     #@ShouldNotReachHere

1e8     B28: #	out( N331 ) &lt;- in( B16 )  Freq: 4.99995e-07
1e8 +   spill [sp, #0] -&gt; R8	# spill size = 64
1ec +   li R11, #-187	# int, #@loadConI
1f0     spill R12 -&gt; [sp, #0]	# spill size = 32
1f4 +   spill R13 -&gt; [sp, #4]	# spill size = 32
1f8 +   spill R10 -&gt; [sp, #8]	# spill size = 32
1fc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #8
        # java.lang.String::replace @ bci:6 (line 2801) L[0]=R8 L[1]=sp + #0 L[2]=sp + #4 L[3]=_
        # java.lang.String::replace @ bci:63 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # OopMap {fp=Oop off=512/0x200}
200     #@ShouldNotReachHere

20c     B29: #	out( N331 ) &lt;- in( B12 )  Freq: 4.76833e-07
20c +   li R11, #-187	# int, #@loadConI
210     spill R13 -&gt; R8	# spill size = 64
214 +   spill R30 -&gt; [sp, #8]	# spill size = 64
218 +   spill R28 -&gt; [sp, #16]	# spill size = 32
21c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:7 (line 47) L[0]=sp + #8 L[1]=#0 STK[0]=#0 STK[1]=sp + #16
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.String::replace @ bci:54 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=544/0x220}
220     #@ShouldNotReachHere

22c     B30: #	out( N331 ) &lt;- in( B14 )  Freq: 4.76832e-07
22c +   spill [sp, #0] -&gt; R8	# spill size = 64
230 +   li R11, #-187	# int, #@loadConI
234     spill R12 -&gt; [sp, #0]	# spill size = 32
238 +   spill R29 -&gt; [sp, #8]	# spill size = 64
23c +   spill R16 -&gt; [sp, #4]	# spill size = 32
240     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:7 (line 47) L[0]=sp + #8 L[1]=#0 STK[0]=#0 STK[1]=sp + #4
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.String::replace @ bci:60 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=R8 STK[1]=sp + #0
        # OopMap {fp=Oop [8]=Oop off=580/0x244}
244     #@ShouldNotReachHere

250     B31: #	out( N331 ) &lt;- in( B15 )  Freq: 4.76832e-07
250 +   li R11, #-187	# int, #@loadConI
254     spill [sp, #0] -&gt; R8	# spill size = 64
258 +   spill R12 -&gt; [sp, #8]	# spill size = 32
25c +   spill R13 -&gt; [sp, #12]	# spill size = 32
260     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:2 (line 2800) L[0]=R8 L[1]=sp + #8 L[2]=sp + #12 L[3]=_ STK[0]=sp + #8 STK[1]=sp + #12
        # java.lang.String::replace @ bci:63 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # OopMap {fp=Oop off=612/0x264}
264     #@ShouldNotReachHere

270     B32: #	out( N331 ) &lt;- in( B17 )  Freq: 9.99989e-06
270      -- 	// exception oop; no code emitted, #@CreateException
270 +   spill R10 -&gt; R11	# spill size = 64
274 +   # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
280 +   j rethrow_stub	#@RethrowException

288     B33: #	out( N331 ) &lt;- in( B1 )  Freq: 1.01328e-06
288 +   spill [sp, #0] -&gt; R8	# spill size = 64
28c +   li R11, #-10	# int, #@loadConI
290     spill R13 -&gt; [sp, #0]	# spill size = 64
294     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::replace @ bci:1 (line 2953) L[0]=R8 L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=#NULL
        # OopMap {fp=Oop [0]=Oop off=664/0x298}
298     #@ShouldNotReachHere

2a4     B34: #	out( N331 ) &lt;- in( B3 )  Freq: 1.01328e-06
2a4 +   spill [sp, #0] -&gt; R8	# spill size = 64
2a8 +   li R11, #-10	# int, #@loadConI
2ac     spill R12 -&gt; [sp, #0]	# spill size = 64
2b0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::replace @ bci:8 (line 2954) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=#NULL
        # OopMap {fp=Oop [0]=Oop off=692/0x2b4}
2b4     #@ShouldNotReachHere

2c0     B35: #	out( N331 ) &lt;- in( B5 )  Freq: 1.01327e-06
2c0 +   spill [sp, #0] -&gt; R8	# spill size = 64
2c4 +   li R11, #-10	# int, #@loadConI
2c8     spill R12 -&gt; [sp, #0]	# spill size = 64
2cc +   spill R13 -&gt; [sp, #8]	# spill size = 64
2d0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::replace @ bci:16 (line 2955) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=sp + #8 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=724/0x2d4}
2d4     #@ShouldNotReachHere

2e0     B36: #	out( N331 ) &lt;- in( B6 )  Freq: 1.01327e-06
2e0 +   li R11, #-10	# int, #@loadConI
2e4     spill R7 -&gt; R8	# spill size = 64
2e8 +   spill R12 -&gt; [sp, #0]	# spill size = 64
2ec +   spill R13 -&gt; [sp, #8]	# spill size = 64
2f0 +   spill R15 -&gt; [sp, #16]	# spill size = 32
2f4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::replace @ bci:22 (line 2956) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=sp + #8 L[5]=sp + #16 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=760/0x2f8}
2f8     #@ShouldNotReachHere

304     B37: #	out( N331 ) &lt;- in( B7 )  Freq: 1.01327e-06
304 +   li R11, #-10	# int, #@loadConI
308     spill R7 -&gt; R8	# spill size = 64
30c +   spill R12 -&gt; [sp, #0]	# spill size = 64
310 +   spill R13 -&gt; [sp, #8]	# spill size = 64
314 +   spill R15 -&gt; [sp, #16]	# spill size = 32
318 +   spill R14 -&gt; [sp, #20]	# spill size = 32
31c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::replace @ bci:29 (line 2957) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=sp + #8 L[5]=sp + #16 L[6]=sp + #20 L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=800/0x320}
320     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='436'>
----------------------- MetaData before Compile_id = 436 ------------------------
{method}
 - this oop:          0x000000409633a4f0
 - method holder:     &apos;java/util/Optional&apos;
 - constants:         0x0000004096339bb0 constant pool [185] {0x0000004096339bb0} for &apos;java/util/Optional&apos; cache=0x000000409633b518
 - access:            0x81000009  public static 
 - name:              &apos;of&apos;
 - signature:         &apos;(Ljava/lang/Object;)Ljava/util/Optional;&apos;
 - max stack:         4
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c535280
 - code size:         12
 - code start:        0x000000409633a4c8
 - code end (excl):   0x000000409633a4d4
 - method data:       0x000000409649ad98
 - checked ex length: 0
 - linenumber start:  0x000000409633a4d4
 - localvar length:   1
 - localvar start:    0x000000409633a4e0
 - compiled code: nmethod  17168  251       3       java.util.Optional::of (12 bytes)

------------------------ OptoAssembly for Compile_id = 436 -----------------------
#
#  java/util/Optional:exact * ( java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/Object *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B13 B6 B14 )  Freq: 1

000     B1: #	out( B11 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
01c      -- 	// R23=Thread::current(), empty, #@tlsLoadP
01c     ld  R9, [R23, #288]	# ptr, #@loadP
020 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
020     ld  R7, [R23, #304]	# ptr, #@loadP
024 +   addi  R28, R9, #16	# ptr, #@addP_reg_imm
028     spill R11 -&gt; R8	# spill size = 64
02c +   bgeu  R28, R7, B11	#@cmpP_branch  P=0.000100 C=-1.000000

030     B2: #	out( B3 ) &lt;- in( B1 )  Freq: 0.9999
030 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
030     sd  R28, [R23, #288]	# ptr, #@storeP
034 +   li R7, #1	# long, #@loadConL
038 +   mv  R28, narrowklass: precise klass java/util/Optional: 0x00000040d021d120:Constant:exact *	# compressed klass ptr, #@loadConNKlass
048 +   sd  R7, [R9]	# long, #@storeL
04c +   sw  R28, [R9, #8]	# compressed klass ptr, #@storeNKlass
050 +   sw  zr, [R9, #12]	# int, #@storeimmI0

054     B3: #	out( B13 B4 ) &lt;- in( B12 B2 )  Freq: 1
054     
054     spill R8 -&gt; R29	# spill size = 64
058 +   # checkcastPP of R9, #@checkCastPP
058     beq   R29, zr, B13	#@cmpP_imm0_branch  P=0.000000 C=24948.000000

05c     B4: #	out( B6 B5 ) &lt;- in( B3 )  Freq: 1
05c +   mv  R7, R9	# ptr -&gt; long, #@castP2X
060 +   mv  R28, R29	# ptr -&gt; long, #@castP2X
064 +   xorr  R28, R28, R7	#@xorL_reg_reg
068 +   encode_heap_oop  R29, R29	#@encodeHeapOop
06c +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
070 +   sw  R29, [R9, #12]	# compressed ptr, #@storeN ! Field: java/util/Optional.value
074 +   beq  R28, zr, B6	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

078     B5: #	out( B7 B6 ) &lt;- in( B4 )  Freq: 0.999
078 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
07c +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
088 +   add R10, R28, R7	# ptr, #@addP_reg_reg
08c +   lb  R28, [R10]	# byte, #@loadB
090 +   li R7, #4	# int, #@loadConI
094 +   bne  R28, R7, B7	#@cmpI_branch  P=0.001000 C=-1.000000

098     B6: #	out( N1 ) &lt;- in( B9 B10 B7 B5 B4 )  Freq: 1
098 +   #@membar_release
	fence iorw ow
09c +   spill R9 -&gt; R10	# spill size = 64
0a0 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0b8 +   ret	// return register, #@Ret

0bc     B7: #	out( B6 B8 ) &lt;- in( B5 )  Freq: 0.000999
0bc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0bc     ld  R7, [R23, #64]	# int, #@loadL
0c0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c0     ld  R28, [R23, #80]	# ptr, #@loadP
0c4 +   #@membar_volatile
	fence iorw iorw
0c8 +   lb  R30, [R10]	# byte, #@loadB
0cc +   beq  R30, zr, B6	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

0d0     B8: #	out( B10 B9 ) &lt;- in( B7 )  Freq: 0.0004995
0d0 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
0d4 +   bne  R7, zr, B10	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

0d8     B9: #	out( B6 ) &lt;- in( B8 )  Freq: 0.00024975
0d8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0d8     spill R23 -&gt; R11	# spill size = 64
0dc +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
10c +   j  B6	#@branch

110     B10: #	out( B6 ) &lt;- in( B8 )  Freq: 0.00024975
110 +   add R28, R28, R7	# ptr, #@addP_reg_reg
114 +   addi  R7, R7, #-8	#@addL_reg_imm
118 +   sd  R10, [R28, #-8]	# ptr, #@storeP
11c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
11c     sd  R7, [R23, #64]	# long, #@storeL
120 +   j  B6	#@branch

124     B11: #	out( B14 B12 ) &lt;- in( B1 )  Freq: 0.000100017
124 +   mv  R11, precise klass java/util/Optional: 0x00000040d021d120:Constant:exact *	# ptr, #@loadConP
13c     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.Optional::of @ bci:0 (line 113) L[0]=R8
        # OopMap {fp=Oop off=320/0x140}

140     B12: #	out( B3 ) &lt;- in( B11 )  Freq: 0.000100015
        # Block is sole successor of call
140 +   spill R10 -&gt; R9	# spill size = 64
144 +   j  B3	#@branch

148     B13: #	out( N1 ) &lt;- in( B3 )  Freq: 4.76837e-07
148 +   li R11, #-187	# int, #@loadConI
14c     spill R9 -&gt; [sp, #0]	# spill size = 64
150 +   spill R29 -&gt; [sp, #16]	# spill size = 64
154     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.Objects::requireNonNull @ bci:1 (line 208) L[0]=sp + #16 STK[0]=sp + #16
        # java.util.Optional::of @ bci:5 (line 113) L[0]=_ STK[0]=sp + #0 STK[1]=sp + #0
        # OopMap {[0]=Oop [16]=Oop off=344/0x158}
158     #@ShouldNotReachHere

164     B14: #	out( N1 ) &lt;- in( B11 )  Freq: 1.00017e-09
164      -- 	// exception oop; no code emitted, #@CreateException
164 +   spill R10 -&gt; R11	# spill size = 64
168 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
174 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='438'>
----------------------- MetaData before Compile_id = 438 ------------------------
{method}
 - this oop:          0x00000040961fb118
 - method holder:     &apos;java/io/BufferedInputStream&apos;
 - constants:         0x00000040961fa4f0 constant pool [155] {0x00000040961fa4f0} for &apos;java/io/BufferedInputStream&apos; cache=0x00000040961fc6e8
 - access:            0x81000021  public synchronized 
 - name:              &apos;read&apos;
 - signature:         &apos;()I&apos;
 - max stack:         6
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      7
 - i2i entry:         0x00000040138cd000
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c505cc0
 - code size:         49
 - code start:        0x00000040961fb0c8
 - code end (excl):   0x00000040961fb0f9
 - method data:       0x0000004096486b50
 - checked ex length: 1
 - checked ex start:  0x00000040961fb114
 - linenumber start:  0x00000040961fb0f9
 - localvar length:   1
 - localvar start:    0x00000040961fb106
 - compiled code: nmethod  17263  175  s    3       java.io.BufferedInputStream::read (49 bytes)

------------------------ OptoAssembly for Compile_id = 438 -----------------------
#
#  int ( java/io/BufferedInputStream:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/io/BufferedInputStream:NotNull *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: Fixed slot 3
#r258 sp+24: Fixed slot 2
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N231: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B12 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     add R29, sp, #16	# box lock
040 +   fastlock R11,R29	! kills R28,R7, #@cmpFastLock
0d4 +   spill R11 -&gt; [sp, #0]	# spill size = 64
0d8 +   far_bne RFLAGS, zr, B12	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

0e0     B2: #	out( B7 B3 ) &lt;- in( B12 B1 )  Freq: 1
0e0 +   #@membar_acquire_lock (elided)
0e0 +   spill [sp, #0] -&gt; R7	# spill size = 64
0e4 +   lw  R28, [R7, #20]	# int, #@loadI ! Field: java/io/BufferedInputStream.pos
0e8 +   lw  R7, [R7, #16]	# int, #@loadI ! Field: java/io/BufferedInputStream.count
0ec +   bge  R28, R7, B7	#@cmpI_branch  P=0.004651 C=5375.000000

0f0     B3: #	out( B15 B4 ) &lt;- in( B8 B2 )  Freq: 0.997674
0f0 +   spill [sp, #0] -&gt; R7	# spill size = 64
0f4 +   lwu  R28, [R7, #32]	# loadN, compressed ptr, #@loadN ! Field: volatile java/io/BufferedInputStream.buf
0f8 +   #@membar_acquire
	fence ir iorw
0fc +   lw  R31, [R7, #20]	# int, #@loadI ! Field: java/io/BufferedInputStream.pos
100 +   decode_heap_oop  R8, R28	#@decodeHeapOop
104     lwu  R7, [R8, #12]	# range, #@loadRange
108     NullCheck R8

108     B4: #	out( B11 B5 ) &lt;- in( B3 )  Freq: 0.997674
108 +   addiw  R29, R31, #1	#@addI_reg_imm
10c     spill [sp, #0] -&gt; R28	# spill size = 64
110 +   sw  R29, [R28, #20]	# int, #@storeI ! Field: java/io/BufferedInputStream.pos
114 +   bgeu  R31, R7, B11	#@cmpU_branch  P=0.000001 C=-1.000000

118     B5: #	out( B13 B6 ) &lt;- in( B4 )  Freq: 0.997673
118 +   addw  R7, R31, zr	#@convI2L_reg_reg
11c +   add R7, R8, R7	# ptr, #@addP_reg_reg
120 +   lbu  R9, [R7, #16]	# byte, #@loadUB
124 +   #@membar_release_lock (elided)
124     add R29, sp, #16	# box lock
128 +   spill [sp, #0] -&gt; R30	# spill size = 64
12c +   fastunlock R30,R29	! kills R28, R7, #@cmpFastUnlock
1a4 +   far_bne RFLAGS, zr, B13	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

1ac     B6: #	out( N231 ) &lt;- in( B10 B13 B5 )  Freq: 0.999998
1ac +   spill R9 -&gt; R10	# spill size = 32
1b0 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
1c8 +   ret	// return register, #@Ret

1cc     B7: #	out( B16 B8 ) &lt;- in( B2 )  Freq: 0.00465119
1cc +   spill [sp, #0] -&gt; R11	# spill size = 64
1d0 +   spill R11 -&gt; R8	# spill size = 64
1d4     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.io.BufferedInputStream::fill
        # java.io.BufferedInputStream::read @ bci:12 (line 263) L[0]=R8 MON-BOX0=sp+16 MON-OBJ[0]=R8
        # OopMap {fp=Oop [0]=Oop off=472/0x1d8}

1d8     B8: #	out( B3 B9 ) &lt;- in( B7 )  Freq: 0.0046511
        # Block is sole successor of call
1d8 +   lw  R28, [R8, #20]	# int, #@loadI ! Field: java/io/BufferedInputStream.pos
1dc +   lw  R7, [R8, #16]	# int, #@loadI ! Field: java/io/BufferedInputStream.count
1e0 +   blt  R28, R7, B3	#@cmpI_branch  P=0.500000 C=-1.000000

1e4     B9: #	out( B14 B10 ) &lt;- in( B8 )  Freq: 0.00232555
1e4 +   #@membar_release_lock (elided)
1e4     add R29, sp, #16	# box lock
1e8 +   fastunlock R8,R29	! kills R28, R7, #@cmpFastUnlock
260 +   far_bne RFLAGS, zr, B14	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

268     B10: #	out( B6 ) &lt;- in( B14 B9 )  Freq: 0.00232555
268 +   li R9, #-1	# int, #@loadConI
26c +   j  B6	#@branch

270     B11: #	out( N231 ) &lt;- in( B4 )  Freq: 1.01092e-06
270 +   li R11, #-28	# int, #@loadConI
274     spill R31 -&gt; [sp, #8]	# spill size = 32
278     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.io.BufferedInputStream::read @ bci:43 (line 267) L[0]=_ STK[0]=R8 STK[1]=sp + #8 MON-BOX0=sp+16 MON-OBJ[0]=sp + #0
        # OopMap {fp=Oop [0]=Oop off=636/0x27c}
27c     #@ShouldNotReachHere

288     B12: #	out( B2 ) &lt;- in( B1 )  Freq: 1e-06
288     add R12, sp, #16	# box lock
28c +   spill R11 -&gt; R8	# spill size = 64
290 +   CALL,static 0x000000401390c140	#@CallStaticJavaDirect wrapper for: _complete_monitor_locking_Java
        # java.io.BufferedInputStream::read @ bci:-1 (line 262) L[0]=R8 MON-BOX0=sp+16 MON-OBJ[0]=R8
        # OopMap {fp=Oop [0]=Oop off=660/0x294}
294 +   j  B2	#@branch

298     B13: #	out( B6 ) &lt;- in( B5 )  Freq: 9.97673e-07
298     add R11, sp, #16	# box lock
29c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
29c     spill R23 -&gt; R12	# spill size = 64
2a0 +   spill R30 -&gt; R10	# spill size = 64
2a4 +   CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
2d4 +   j  B6	#@branch

2d8     B14: #	out( B10 ) &lt;- in( B9 )  Freq: 2.32555e-09
2d8     add R11, sp, #16	# box lock
2dc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2dc     spill R23 -&gt; R12	# spill size = 64
2e0 +   spill R8 -&gt; R10	# spill size = 64
2e4 +   CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
314 +   j  B10	#@branch

318     B15: #	out( N231 ) &lt;- in( B3 )  Freq: 4.75728e-07
318 +   li R11, #-187	# int, #@loadConI
31c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.io.BufferedInputStream::getBufIfOpen @ bci:6 (line 167) L[0]=_ L[1]=R8 STK[0]=R8
        # java.io.BufferedInputStream::read @ bci:29 (line 267) L[0]=sp + #0 MON-BOX0=sp+16 MON-OBJ[0]=sp + #0
        # OopMap {fp=Oop [0]=Oop off=800/0x320}
320     #@ShouldNotReachHere

32c     B16: #	out( B18 B17 ) &lt;- in( B7 )  Freq: 4.65119e-08
32c      -- 	// exception oop; no code emitted, #@CreateException
32c +   #@membar_release_lock (elided)
32c     add R29, sp, #16	# box lock
330 +   fastunlock R8,R29	! kills R7, R28, #@cmpFastUnlock
3a8 +   spill R10 -&gt; R9	# spill size = 64
3ac +   far_bne RFLAGS, zr, B18	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

3b4     B17: #	out( N231 ) &lt;- in( B18 B16 )  Freq: 4.65119e-08
3b4 +   spill R9 -&gt; R11	# spill size = 64
3b8 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
3c4 +   j rethrow_stub	#@RethrowException

3cc     B18: #	out( B17 ) &lt;- in( B16 )  Freq: 4.65119e-14
3cc     add R11, sp, #16	# box lock
3d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3d0     spill R23 -&gt; R12	# spill size = 64
3d4 +   spill R8 -&gt; R10	# spill size = 64
3d8 +   CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
408 +   j  B17	#@branch

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='443'>
----------------------- MetaData before Compile_id = 443 ------------------------
{method}
 - this oop:          0x00000040962b74d8
 - method holder:     &apos;sun/nio/fs/UnixPath&apos;
 - constants:         0x00000040962b5440 constant pool [472] {0x00000040962b5440} for &apos;sun/nio/fs/UnixPath&apos; cache=0x00000040962ba1a0
 - access:            0xc1000002  private 
 - name:              &apos;hasDotOrDotDot&apos;
 - signature:         &apos;()Z&apos;
 - max stack:         3
 - max locals:        4
 - size of params:    1
 - method size:       13
 - highest level:     4
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c5ade00
 - code size:         69
 - code start:        0x00000040962b7450
 - code end (excl):   0x00000040962b7495
 - method data:       0x0000004096487860
 - checked ex length: 0
 - linenumber start:  0x00000040962b7495
 - localvar length:   4
 - localvar start:    0x00000040962b74a6
 - compiled code: nmethod  17637  442       3       sun.nio.fs.UnixPath::hasDotOrDotDot (69 bytes)

------------------------ OptoAssembly for Compile_id = 443 -----------------------
#
#  bool ( sun/nio/fs/UnixPath:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixPath:NotNull *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N533: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B54 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     spill R11 -&gt; R8	# spill size = 64
040     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getNameCount @ bci:1 (line 295) L[0]=R8
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:1 (line 227) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop off=68/0x44}

044     B2: #	out( B51 B3 ) &lt;- in( B1 )  Freq: 0.99998
        # Block is sole successor of call
044 +   spill R8 -&gt; R19	# spill size = 64
048 +   lwu  R28, [R19, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
04c +   #@membar_acquire
	fence ir iorw
050 +   decode_heap_oop  R7, R28	#@decodeHeapOop
054     lwu  R28, [R7, #12]	# range, #@loadRange
058     NullCheck R7

058     B3: #	out( B31 B4 ) &lt;- in( B2 )  Freq: 0.999979
058 +   bleu  R28, zr, B31	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.088024 C=46533.000000

05c     B4: #	out( B5 ) &lt;- in( B3 )  Freq: 0.911957
05c +   li R29, #0	# int, #@loadConI
060 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
060     li R9, #0	# int, #@loadConI
064     spill R29 -&gt; [sp, #28]	# spill size = 32
        nop 	# 4 bytes pad for loops and calls

070     B5: #	out( B55 B6 ) &lt;- in( B4 B26 ) Loop( B5-B26 inner ) Freq: 10.3506
070 +   spill R9 -&gt; [sp, #0]	# spill size = 32
074 +   spill R28 -&gt; [sp, #8]	# spill size = 32
078 +   spill R19 -&gt; R8	# spill size = 64
07c +   spill R19 -&gt; R11	# spill size = 64
080     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getName @ bci:1 (line 301) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=R8 L[1]=sp + #8 L[2]=sp + #0 L[3]=_
        # OopMap {fp=Oop off=132/0x84}

084     B6: #	out( B46 B7 ) &lt;- in( B5 )  Freq: 10.3504
        # Block is sole successor of call
084 +   spill R8 -&gt; R19	# spill size = 64
088 +   lwu  R7, [R19, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
08c +   #@membar_acquire
	fence ir iorw
090 +   decode_heap_oop  R7, R7	#@decodeHeapOop
094     lwu  R8, [R7, #12]	# range, #@loadRange
098     NullCheck R7

098     B7: #	out( B43 B8 ) &lt;- in( B6 )  Freq: 10.3503
098 +   spill [sp, #0] -&gt; R18	# spill size = 32
09c +   bge  R18, R8, B43	#@cmpI_branch  P=0.000000 C=5376.000000

0a0     B8: #	out( B47 B9 ) &lt;- in( B7 )  Freq: 10.3503
0a0 +   lwu  R28, [R19, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0a4 +   #@membar_acquire
	fence ir iorw
0a8 +   decode_heap_oop  R8, R28	#@decodeHeapOop
0ac     lwu  R7, [R8, #12]	# range, #@loadRange
0b0     NullCheck R8

0b0     B9: #	out( B40 B10 ) &lt;- in( B8 )  Freq: 10.3503
0b0 +   bgeu  R18, R7, B40	#@cmpU_branch  P=0.000001 C=-1.000000

0b4     B10: #	out( B48 B11 ) &lt;- in( B9 )  Freq: 10.3503
0b4 +   addw  R7, R18, zr	#@convI2L_reg_reg
0b8 +   slli  R29, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0bc +   lwu  R28, [R19, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0c0 +   add R7, R8, R29	# ptr, #@addP_reg_reg
0c4 +   lw  R7, [R7, #16]	# int, #@loadI
0c8 +   decode_heap_oop  R28, R28	#@decodeHeapOop
0cc +   #@membar_acquire
	fence ir iorw
0d0     lwu  R28, [R28, #12]	# range, #@loadRange
0d4     NullCheck R28

0d4     B11: #	out( B29 B12 ) &lt;- in( B10 )  Freq: 10.3503
0d4 +   addiw  R30, R28, #-1	#@addI_reg_imm
0d8 +   addiw  R9, R18, #1	#@addI_reg_imm
0dc +   beq  R18, R30, B29	#@cmpI_branch  P=0.084635 C=5376.000000

0e0     B12: #	out( B50 B13 ) &lt;- in( B11 )  Freq: 9.4743
0e0 +   lwu  R28, [R19, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0e4 +   #@membar_acquire
	fence ir iorw
0e8 +   decode_heap_oop  R8, R28	#@decodeHeapOop
0ec     lwu  R30, [R8, #12]	# range, #@loadRange
0f0     NullCheck R8

0f0     B13: #	out( B42 B14 ) &lt;- in( B12 )  Freq: 9.47429
0f0 +   bgeu  R9, R30, B42	#@cmpU_branch  P=0.000001 C=-1.000000

0f4     B14: #	out( B15 ) &lt;- in( B13 )  Freq: 9.47428
0f4 +   add R28, R8, R29	# ptr, #@addP_reg_reg
0f8 +   lw  R28, [R28, #20]	# int, #@loadI
0fc +   subw  R29, R28, R7	#@subI_reg_reg
100 +   addiw  R20, R29, #-1	#@addI_reg_imm

104     B15: #	out( B16 B16 ) &lt;- in( B14 B30 )  Freq: 10.3503
104 +   lwu  R28, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
108 +   decode_heap_oop  R8, R28	#@decodeHeapOop
10c +   li R30, #1048576	# int, #@loadConI
110 +   addw  R28, R20, zr	#@convI2L_reg_reg
114 +   bleu  R20, R30, B16	#@cmpU_branch  P=0.999999 C=-1.000000

118     B16: #	out( B49 B17 ) &lt;- in( B15 B15 )  Freq: 10.3503
118     lwu  R30, [R8, #12]	# range, #@loadRange
11c     NullCheck R8

11c     B17: #	out( B41 B18 ) &lt;- in( B16 )  Freq: 10.3503
11c +   addw  R29, R20, R7	#@addI_reg_reg
120 +   blt  R7, zr, B41	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

124     B18: #	out( B41 B19 ) &lt;- in( B17 )  Freq: 10.3503
124 +   bltu  R30, R29, B41	#@cmpU_branch  P=0.000001 C=-1.000000

128     B19: #	out( B38 B20 ) &lt;- in( B18 )  Freq: 10.3503
128 +   li R29, #1048576	# int, #@loadConI
12c +   bgtu  R20, R29, B38	#@cmpU_branch  P=0.000001 C=-1.000000

130     B20: #	out( B38 B21 ) &lt;- in( B19 )  Freq: 10.3502
130 +   addi  R28, R28, #23	#@addL_reg_imm
134 +   ld  R21, [R23, #288]	# ptr, #@loadP
138 +   andi  R28, R28, #-8	#@andL_reg_imm
13c +   ld  R29, [R23, #304]	# ptr, #@loadP
140 +   add R28, R21, R28	# ptr, #@addP_reg_reg
144 +   bgeu  R28, R29, B38	#@cmpP_branch  P=0.000100 C=-1.000000

148     B21: #	out( B22 ) &lt;- in( B20 )  Freq: 10.3492
148 +   sd  R28, [R23, #288]	# ptr, #@storeP
14c +   li R28, #1	# long, #@loadConL
150 +   mv  R29, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
160 +   sd  R28, [R21]	# long, #@storeL
164 +   sw  R29, [R21, #8]	# compressed klass ptr, #@storeNKlass
168 +   sw  R20, [R21, #12]	# int, #@storeI

16c     B22: #	out( B24 B23 ) &lt;- in( B39 B21 )  Freq: 10.3503
16c     
16c +   # checkcastPP of R21, #@checkCastPP
16c     addi  R22, R21, #16	# ptr, #@addP_reg_imm
170 +   # castII of R20, #@castII
170     beq  R20, zr, B24	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

174     B23: #	out( B24 ) &lt;- in( B22 )  Freq: 10.3502
174 +   addw  R7, R7, zr	#@convI2L_reg_reg
178 +   add R7, R8, R7	# ptr, #@addP_reg_reg
17c +   addw  R12, R20, zr	#@convI2L_reg_reg
180     spill R22 -&gt; R11	# spill size = 64
184 +   addi  R10, R7, #16	# ptr, #@addP_reg_imm
188 +   CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

18c     B24: #	out( B35 B25 ) &lt;- in( B23 B22 )  Freq: 10.3503
18c     
18c     li R28, #1	# int, #@loadConI
190 +   beq  R20, R28, B35	#@cmpI_branch  P=0.000730 C=42438.000000

194     B25: #	out( B32 B26 ) &lt;- in( B36 B24 )  Freq: 10.3495
194 +   li R28, #2	# int, #@loadConI
198 +   beq  R20, R28, B32	#@cmpI_branch  P=0.005844 C=42438.000000

19c     B26: #	out( B5 B27 ) &lt;- in( B25 B33 )  Freq: 10.3495
19c +   spill [sp, #8] -&gt; R28	# spill size = 32
1a0 +   blt  R9, R28, B5	#@cmpI_loop  P=0.911976 C=42438.000000

1a4     B27: #	out( B28 ) &lt;- in( B26 )  Freq: 0.910999
1a4 +   spill [sp, #28] -&gt; R10	# spill size = 32

1a8     B28: #	out( N533 ) &lt;- in( B37 B27 B31 )  Freq: 0.999777
1a8     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
1c0 +   ret	// return register, #@Ret

1c4     B29: #	out( B52 B30 ) &lt;- in( B11 )  Freq: 0.876003
1c4 +   lwu  R28, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
1c8 +   decode_heap_oop  R28, R28	#@decodeHeapOop
1cc     lwu  R29, [R28, #12]	# range, #@loadRange
1d0     NullCheck R28

1d0     B30: #	out( B15 ) &lt;- in( B29 )  Freq: 0.876002
1d0 +   subw  R20, R29, R7	#@subI_reg_reg
1d4 +   j  B15	#@branch

1d8     B31: #	out( B28 ) &lt;- in( B3 )  Freq: 0.0880217
1d8 +   li R10, #0	# int, #@loadConI
1dc +   j  B28	#@branch

1e0     B32: #	out( B44 B33 ) &lt;- in( B25 )  Freq: 0.0604806
1e0 +   beq  R20, zr, B44	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

1e4     B33: #	out( B26 B34 ) &lt;- in( B32 )  Freq: 0.0604805
1e4 +   lb  R8, [R22]	# byte, #@loadB
1e8 +   li R7, #46	# int, #@loadConI
1ec +   bne  R8, R7, B26	#@cmpI_branch  P=1.000000 C=248.000000

1f0     B34: #	out( N533 ) &lt;- in( B33 )  Freq: 2.88394e-08
1f0 +   li R11, #-187	# int, #@loadConI
1f4     spill R19 -&gt; [sp, #0]	# spill size = 64
1f8 +   spill R18 -&gt; [sp, #12]	# spill size = 32
1fc +   spill R21 -&gt; [sp, #16]	# spill size = 64
200     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:48 (line 232) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #12 L[3]=sp + #16 STK[0]=R8 STK[1]=#46
        # OopMap {[0]=Oop [16]=Oop off=516/0x204}
204     #@ShouldNotReachHere

210     B35: #	out( B45 B36 ) &lt;- in( B24 )  Freq: 0.00756039
210 +   beq  R20, zr, B45	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

214     B36: #	out( B25 B37 ) &lt;- in( B35 )  Freq: 0.00756039
214 +   lb  R7, [R22]	# byte, #@loadB
218 +   li R28, #46	# int, #@loadConI
21c +   bne  R7, R28, B25	#@cmpI_branch  P=0.900000 C=-1.000000

220     B37: #	out( B28 ) &lt;- in( B36 )  Freq: 0.000756039
220 +   li R10, #1	# int, #@loadConI
224 +   j  B28	#@branch

228     B38: #	out( B53 B39 ) &lt;- in( B19 B20 )  Freq: 0.00104568
228 +   spill R20 -&gt; [sp, #24]	# spill size = 32
22c +   spill R9 -&gt; [sp, #20]	# spill size = 32
230 +   spill R7 -&gt; [sp, #16]	# spill size = 32
234 +   spill R18 -&gt; [sp, #12]	# spill size = 32
238 +   spill R19 -&gt; [sp, #0]	# spill size = 64
23c +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
254     spill R20 -&gt; R12	# spill size = 32
258     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #0 L[1]=_ L[2]=sp + #16 L[3]=sp + #24 L[4]=_
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #12 L[3]=_
        # OopMap {fp=Oop [0]=Oop off=604/0x25c}

25c     B39: #	out( B22 ) &lt;- in( B38 )  Freq: 0.00104566
        # Block is sole successor of call
25c +   spill [sp, #0] -&gt; R19	# spill size = 64
260 +   spill [sp, #12] -&gt; R18	# spill size = 32
264 +   spill [sp, #16] -&gt; R7	# spill size = 32
268 +   spill [sp, #20] -&gt; R9	# spill size = 32
26c +   spill [sp, #24] -&gt; R20	# spill size = 32
270 +   spill R10 -&gt; R21	# spill size = 64
274 +   j  B22	#@branch

278     B40: #	out( N533 ) &lt;- in( B9 )  Freq: 1.04878e-05
278 +   li R11, #-28	# int, #@loadConI
27c     spill R19 -&gt; [sp, #16]	# spill size = 64
280 +   spill R18 -&gt; [sp, #24]	# spill size = 32
284 +   spill R18 -&gt; [sp, #28]	# spill size = 32
288     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:38 (line 307) L[0]=sp + #16 L[1]=sp + #28 L[2]=_ L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #24
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #16 L[1]=sp + #8 L[2]=sp + #24 L[3]=_
        # OopMap {fp=Oop [16]=Oop off=652/0x28c}
28c     #@ShouldNotReachHere

298     B41: #	out( N533 ) &lt;- in( B17 B18 )  Freq: 2.07005e-05
298 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 32
2a0 +   li R11, #-52	# int, #@loadConI
2a4     spill R18 -&gt; [sp, #4]	# spill size = 32
2a8 +   spill R19 -&gt; [sp, #8]	# spill size = 64
2ac +   spill R7 -&gt; [sp, #16]	# spill size = 32
2b0 +   spill R20 -&gt; [sp, #24]	# spill size = 32
2b4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #8 L[1]=_ L[2]=sp + #16 L[3]=sp + #24 L[4]=_ STK[0]=sp + #24
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #8 L[1]=sp + #0 L[2]=sp + #4 L[3]=_
        # OopMap {[8]=Oop off=696/0x2b8}
2b8     #@ShouldNotReachHere

2c4     B42: #	out( N533 ) &lt;- in( B13 )  Freq: 9.6001e-06
2c4 +   li R11, #-28	# int, #@loadConI
2c8     spill R18 -&gt; [sp, #12]	# spill size = 32
2cc +   spill R19 -&gt; [sp, #16]	# spill size = 64
2d0 +   spill R9 -&gt; [sp, #24]	# spill size = 32
2d4 +   spill R7 -&gt; [sp, #28]	# spill size = 32
2d8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:69 (line 312) L[0]=sp + #16 L[1]=_ L[2]=sp + #28 L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #24
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #16 L[1]=sp + #8 L[2]=sp + #12 L[3]=_
        # OopMap {fp=Oop [16]=Oop off=732/0x2dc}
2dc     #@ShouldNotReachHere

2e8     B43: #	out( N533 ) &lt;- in( B7 )  Freq: 4.93543e-06
2e8 +   li R11, #-187	# int, #@loadConI
2ec     spill R19 -&gt; [sp, #16]	# spill size = 64
2f0 +   spill R18 -&gt; [sp, #24]	# spill size = 32
2f4 +   spill R18 -&gt; [sp, #28]	# spill size = 32
2f8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:22 (line 304) L[0]=sp + #16 L[1]=sp + #28 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #24 STK[1]=R8
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #16 L[1]=sp + #8 L[2]=sp + #24 L[3]=_
        # OopMap {[16]=Oop off=764/0x2fc}
2fc     #@ShouldNotReachHere

308     B44: #	out( N533 ) &lt;- in( B32 )  Freq: 6.12837e-08
308 +   li R11, #-28	# int, #@loadConI
30c     spill R19 -&gt; R8	# spill size = 64
310 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 32
318 +   spill R18 -&gt; [sp, #4]	# spill size = 32
31c +   spill R21 -&gt; [sp, #16]	# spill size = 64
320     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:45 (line 232) L[0]=R8 L[1]=sp + #0 L[2]=sp + #4 L[3]=sp + #16 STK[0]=sp + #16 STK[1]=#0
        # OopMap {fp=Oop [16]=Oop off=804/0x324}
324     #@ShouldNotReachHere

330     B45: #	out( N533 ) &lt;- in( B35 )  Freq: 7.66079e-09
330 +   li R11, #-28	# int, #@loadConI
334     spill R19 -&gt; R8	# spill size = 64
338 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 32
340 +   spill R18 -&gt; [sp, #4]	# spill size = 32
344 +   spill R21 -&gt; [sp, #16]	# spill size = 64
348     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:29 (line 230) L[0]=R8 L[1]=sp + #0 L[2]=sp + #4 L[3]=sp + #16 STK[0]=sp + #16 STK[1]=#0
        # OopMap {fp=Oop [16]=Oop off=844/0x34c}
34c     #@ShouldNotReachHere

358     B46: #	out( N533 ) &lt;- in( B6 )  Freq: 1.04878e-05
358 +   li R11, #-10	# int, #@loadConI
35c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:21 (line 304) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=864/0x360}
360     #@ShouldNotReachHere

36c     B47: #	out( N533 ) &lt;- in( B8 )  Freq: 1.04878e-05
36c +   li R11, #-10	# int, #@loadConI
370     spill R18 -&gt; R8	# spill size = 32
374     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:38 (line 307) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=888/0x378}
378     #@ShouldNotReachHere

384     B48: #	out( N533 ) &lt;- in( B10 )  Freq: 1.04878e-05
384 +   li R11, #-10	# int, #@loadConI
388     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:45 (line 309) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=908/0x38c}
38c     #@ShouldNotReachHere

398     B49: #	out( N533 ) &lt;- in( B16 )  Freq: 1.04877e-05
398 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 32
3a0 +   li R11, #-12	# int, #@loadConI
3a4     spill R18 -&gt; [sp, #4]	# spill size = 32
3a8 +   spill R19 -&gt; [sp, #8]	# spill size = 64
3ac +   spill R7 -&gt; [sp, #16]	# spill size = 32
3b0 +   spill R20 -&gt; [sp, #24]	# spill size = 32
3b4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #8 L[1]=_ L[2]=sp + #16 L[3]=sp + #24 L[4]=_ STK[0]=sp + #24
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #8 L[1]=sp + #0 L[2]=sp + #4 L[3]=_
        # OopMap {[8]=Oop off=952/0x3b8}
3b8     #@ShouldNotReachHere

3c4     B50: #	out( N533 ) &lt;- in( B12 )  Freq: 9.60011e-06
3c4 +   li R11, #-10	# int, #@loadConI
3c8     spill R9 -&gt; R8	# spill size = 32
3cc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:69 (line 312) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=976/0x3d0}
3d0     #@ShouldNotReachHere

3dc     B51: #	out( N533 ) &lt;- in( B2 )  Freq: 1.01326e-06
3dc +   li R11, #-10	# int, #@loadConI
3e0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getNameCount @ bci:8 (line 296) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:1 (line 227) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=996/0x3e4}
3e4     #@ShouldNotReachHere

3f0     B52: #	out( N533 ) &lt;- in( B29 )  Freq: 8.87635e-07
3f0 +   li R11, #-10	# int, #@loadConI
3f4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:55 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=1016/0x3f8}
3f8     #@ShouldNotReachHere

404     B53: #	out( B56 ) &lt;- in( B38 )  Freq: 1.04568e-08
404      -- 	// exception oop; no code emitted, #@CreateException
404 +   j  B56	#@branch

408     B54: #	out( B57 ) &lt;- in( B1 )  Freq: 1e-05
408      -- 	// exception oop; no code emitted, #@CreateException
408 +   spill R10 -&gt; R11	# spill size = 64
40c +   j  B57	#@branch

410     B55: #	out( B56 ) &lt;- in( B5 )  Freq: 0.000103506
410      -- 	// exception oop; no code emitted, #@CreateException

410     B56: #	out( B57 ) &lt;- in( B55 B53 )  Freq: 0.000103516
410 +   spill R10 -&gt; R11	# spill size = 64

414     B57: #	out( N533 ) &lt;- in( B54 B56 )  Freq: 0.000113516
414     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
420 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='452'>
----------------------- MetaData before Compile_id = 452 ------------------------
{method}
 - this oop:          0x00000040965e87c0
 - method holder:     &apos;jdk/internal/module/Checks&apos;
 - constants:         0x00000040965e7798 constant pool [250] {0x00000040965e7798} for &apos;jdk/internal/module/Checks&apos; cache=0x00000040965e8ce8
 - access:            0xc100000a  private static 
 - name:              &apos;isTypeName&apos;
 - signature:         &apos;(Ljava/lang/String;)Z&apos;
 - max stack:         4
 - max locals:        4
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c572ac0
 - code size:         49
 - code start:        0x00000040965e8740
 - code end (excl):   0x00000040965e8771
 - method data:       0x000000409649d1c8
 - checked ex length: 0
 - linenumber start:  0x00000040965e8771
 - localvar length:   5
 - localvar start:    0x00000040965e8782
 - compiled code: nmethod  18080  297       3       jdk.internal.module.Checks::isTypeName (49 bytes)

------------------------ OptoAssembly for Compile_id = 452 -----------------------
#
#  bool ( java/lang/String:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:exact *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
0000    N1: #	out( B1 ) &lt;- in( B138 B117 B139 B121 B100 B115 B126 B134 B101 B106 B107 B105 B95 B135 B108 B109 B102 B136 B110 B112 B103 B97 B113 B127 B141 B125 B30 B120 B119 B44 B104 B137 B111 B133 B96 B114 B118 B122 B128 B116 B140 B123 B124 B99 )  Freq: 1

0000    B1: #	out( B138 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0000    # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
001c    spill R11 -&gt; R30	# spill size = 64
0020    lb  R17, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0024    NullCheck R11

0024    B2: #	out( B117 B3 ) &lt;- in( B1 )  Freq: 0.999999
0024 +  lwu  R15, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0028 +  decode_heap_oop  R8, R15	#@decodeHeapOop
002c +  bne  R17, zr, B117	#@cmpI_reg_imm0_branch  P=0.000000 C=91997.000000

0030    B3: #	out( B139 B4 ) &lt;- in( B2 )  Freq: 0.999999
0030    lwu  R12, [R8, #12]	# range, #@loadRange
0034    NullCheck R8

0034    B4: #	out( B121 B5 ) &lt;- in( B3 )  Freq: 0.999997
0034 +  bleu  R12, zr, B121	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=5375.000000

0038    B5: #	out( B31 B6 ) &lt;- in( B4 )  Freq: 0.999997
0038 +  li R13, #46	# int, #@loadConI
003c +  addi  R11, R8, #16	# ptr, #@addP_reg_imm
0040    StringUTF16 IndexOf char[] R11,R12,R13 -&gt; R10
02e4 +  li R7, #-1	# int, #@loadConI
02e8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
02e8    bne  R10, R7, B31	#@cmpI_branch  P=0.747718 C=32428.000000

02ec    B6: #	out( B7 ) &lt;- in( B5 )  Freq: 0.252281
02ec +  li R16, #0	# int, #@loadConI
02f0 +  li R29, #1	# int, #@loadConI
02f4 +  li R14, #2	# int, #@loadConI
02f8 +  li R9, #0	# int, #@loadConI

02fc    B7: #	out( B118 B8 ) &lt;- in( B62 B6 )  Freq: 0.996408
02fc +  decode_heap_oop  R11, R15	#@decodeHeapOop
0300 +  lwu  R7, [R11, #12]	# range, #@loadRange
0304 +  sraw  R8, R7, R17	#@rShiftI_reg_reg
0308 +  blt  R9, zr, B118	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

030c    B8: #	out( B122 B9 ) &lt;- in( B7 )  Freq: 0.996408
030c +  bgt  R9, R8, B122	#@cmpI_branch  P=0.000000 C=5375.000000

0310    B9: #	out( B11 B10 ) &lt;- in( B8 )  Freq: 0.996407
0310 +  bne  R9, zr, B11	#@cmpI_reg_imm0_branch  P=0.627790 C=5376.000000

0314    B10: #	out( B15 ) &lt;- in( B9 )  Freq: 0.370873
0314 +  spill R30 -&gt; R10	# spill size = 64
0318 +  j  B15	#@branch

031c    B11: #	out( B128 B12 ) &lt;- in( B9 )  Freq: 0.625535
031c +  subw  R13, R8, R9	#@subI_reg_reg
0320 +  bne  R17, zr, B128	#@cmpI_reg_imm0_branch  P=0.000000 C=91997.000000

0324    B12: #	out( B129 B13 ) &lt;- in( B11 )  Freq: 0.625534
0324 +  spill R9 -&gt; R12	# spill size = 32
0328 +  spill R14 -&gt; [sp, #4]	# spill size = 32
032c +  spill R29 -&gt; [sp, #0]	# spill size = 32
0330 +  spill R16 -&gt; R8	# spill size = 32
0334    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringLatin1::newString
        # java.lang.String::substring @ bci:41 (line 2707) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isTypeName @ bci:40 (line 136) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=824/0x338}

0338    B13: #	out( B116 B14 ) &lt;- in( B12 )  Freq: 0.625522
        # Block is sole successor of call
0338 +  beq   R10, zr, B116	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

033c    B14: #	out( B15 ) &lt;- in( B13 )  Freq: 0.625521
033c +  spill R8 -&gt; R16	# spill size = 32
0340 +  spill [sp, #0] -&gt; R29	# spill size = 32
0344 +  spill [sp, #4] -&gt; R14	# spill size = 32

0348    B15: #	out( B140 B16 ) &lt;- in( B10 B14 )  Freq: 0.996394
0348 +  lwu  R28, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
034c +  decode_heap_oop  R7, R28	#@decodeHeapOop
0350    lwu  R8, [R7, #12]	# range, #@loadRange
0354    NullCheck R7

0354    B16: #	out( B123 B17 ) &lt;- in( B15 )  Freq: 0.996393
0354 +  bleu  R8, zr, B123	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=8622.000000

0358    B17: #	out( B130 B18 ) &lt;- in( B16 )  Freq: 0.996392
0358 +  spill R10 -&gt; R8	# spill size = 64
035c +  spill R14 -&gt; [sp, #8]	# spill size = 32
0360 +  spill R29 -&gt; [sp, #4]	# spill size = 32
0364 +  spill R16 -&gt; [sp, #0]	# spill size = 32
0368 +  mv  R11, java/util/ImmutableCollections$SetN:exact *	# ptr, #@loadConP
0380    spill R10 -&gt; R12	# spill size = 64
0384    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.ImmutableCollections$SetN::probe
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop off=904/0x388}

0388    B18: #	out( B124 B19 ) &lt;- in( B17 )  Freq: 0.996372
        # Block is sole successor of call
0388 +  spill R8 -&gt; R30	# spill size = 64
038c +  lwu  R7, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0390 +  lb  R28, [R30, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0394 +  decode_heap_oop  R13, R7	#@decodeHeapOop
0398 +  bge  R10, zr, B124	#@cmpI_reg_imm0_branch  P=0.000000 C=8485.000000

039c    B19: #	out( B119 B20 ) &lt;- in( B18 )  Freq: 0.996372
039c +  bne  R28, zr, B119	#@cmpI_reg_imm0_branch  P=0.000000 C=91997.000000

03a0    B20: #	out( B141 B21 ) &lt;- in( B19 )  Freq: 0.996371
03a0    lwu  R31, [R13, #12]	# range, #@loadRange
03a4    NullCheck R13

03a4    B21: #	out( B125 B22 ) &lt;- in( B20 )  Freq: 0.99637
03a4 +  bleu  R31, zr, B125	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=38842.000000

03a8    B22: #	out( B120 B23 ) &lt;- in( B21 )  Freq: 0.99637
03a8 +  lbu  R15, [R13, #16]	# byte, #@loadUB
03ac +  addw  R7, R15, zr	#@convI2L_reg_reg
03b0 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
03b4 +  mv  R10, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d01d5ab0&gt; *	# ptr, #@loadConP
03cc +  mv  R29, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d01d5ab0&gt; *	# ptr, #@loadConP
03e4 +  add R7, R10, R7	# ptr, #@addP_reg_reg
03e8 +  sraw  R12, R31, R28	#@rShiftI_reg_reg
03ec +  lw  R29, [R7, #16]	# int, #@loadI
03f0 +  li R28, #28672	# int, #@loadConI
03f4 +  li R7, #20480	# int, #@loadConI
03f8 +  andr  R8, R29, R28	#@andI_reg_reg
03fc +  blt  R8, R7, B120	#@cmpI_branch  P=0.000000 C=5376.000000

0400    B23: #	out( B43 B24 ) &lt;- in( B22 )  Freq: 0.996369
0400 +  spill [sp, #4] -&gt; R11	# spill size = 32
0404 +  ble  R12, R11, B43	#@cmpI_branch  P=0.216422 C=37852.000000

0408    B24: #	out( B114 B25 ) &lt;- in( B23 )  Freq: 0.780733
0408 +  bleu  R31, R11, B114	#@cmpU_branch  P=0.000001 C=-1.000000

040c    B25: #	out( B114 B26 ) &lt;- in( B24 )  Freq: 0.780732
040c +  li R28, #-2147483648	# int, #@loadConI
0410 +  addiw  R10, R12, #-1	#@addI_reg_imm
0414    CMove R10, (R12 lt R10), R10, R28	#@cmovI_cmpI
	
041c +  addw  R7, R12, zr	#@convI2L_reg_reg
0420 +  addw  R28, R31, zr	#@convI2L_reg_reg
0424 +  addi  R7, R7, #-1	#@addL_reg_imm
0428 +  bgeu  R7, R28, B114	#@cmpUL_branch  P=0.000001 C=-1.000000

042c    B26: #	out( B93 B27 ) &lt;- in( B25 )  Freq: 0.780732
042c +  lbu  R7, [R13, #17]	# byte, #@loadUB2L
0430 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0434 +  mv  R29, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d01d5ab0&gt; *	# ptr, #@loadConP
044c +  mv  R28, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d01d5ab0&gt; *	# ptr, #@loadConP
0464 +  add R7, R29, R7	# ptr, #@addP_reg_reg
0468 +  lw  R7, [R7, #16]	# int, #@loadI
046c +  li R28, #12288	# int, #@loadConI
0470 +  andr  R28, R7, R28	#@andI_reg_reg
0474 +  beq  R28, zr, B93	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

0478    B27: #	out( B38 B28 ) &lt;- in( B26 )  Freq: 0.780705
0478 +  spill [sp, #8] -&gt; R29	# spill size = 32
047c +  ble  R10, R29, B38	#@cmpI_branch  P=0.000001 C=-1.000000

0480    B28: #	out( B115 B29 ) &lt;- in( B27 )  Freq: 0.780705
0480 +  bleu  R31, R29, B115	#@cmpU_branch  P=0.000001 C=-1.000000

0484    B29: #	out( B33 B30 ) &lt;- in( B28 )  Freq: 0.780704
0484 +  li R28, #3	# int, #@loadConI
0488 +  bgtu  R31, R28, B33	#@cmpU_branch  P=0.999999 C=-1.000000

048c    B30: #	out( N1 ) &lt;- in( B29 )  Freq: 7.80704e-07
048c    #@ShouldNotReachHere

0498    B31: #	out( B63 ) &lt;- in( B5 )  Freq: 0.747716
0498 +  li R16, #0	# int, #@loadConI
049c +  li R29, #1	# int, #@loadConI
04a0 +  li R14, #2	# int, #@loadConI
04a4 +  li R9, #0	# int, #@loadConI
04a8 +  j  B63	#@branch

04ac    B32: #	out( B33 ) &lt;- in( B37 ) top-of-loop Freq: 2.82255
04ac +  spill R14 -&gt; [sp, #0]	# spill size = 32

04b0    B33: #	out( B34 ) &lt;- in( B29 B32 ) Loop( B33-B32 ) Freq: 3.60325
04b0 +  spill [sp, #0] -&gt; R14	# spill size = 32
04b4 +  subw  R7, R10, R29	#@subI_reg_reg
04b8    CMove R7, (R10 lt R29), R7, R14	#@cmovI_cmpI
	
04c0 +  li R16, #2000	# int, #@loadConI
04c4 +  li R28, #2000	# int, #@loadConI
04c8    CMove R7, (R7 gtu R28), R7, R16	#@cmovI_cmpU
	
04d0 +  addw  R16, R7, R29	#@addI_reg_reg
        nop 	# 6 bytes pad for loops and calls

04e0    B34: #	out( B93 B35 ) &lt;- in( B33 B36 ) Loop( B34-B36 inner main of N405 strip mined) Freq: 16.6452
04e0 +  addw  R7, R29, zr	#@convI2L_reg_reg
04e4 +  add R7, R13, R7	# ptr, #@addP_reg_reg
04e8 +  lbu  R28, [R7, #16]	# byte, #@loadUB2L
04ec +  lbu  R7, [R7, #17]	# byte, #@loadUB2L
04f0 +  slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
04f4 +  mv  R17, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d01d5ab0&gt; *	# ptr, #@loadConP
050c +  mv  R15, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d01d5ab0&gt; *	# ptr, #@loadConP
0524 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0528 +  add R28, R17, R28	# ptr, #@addP_reg_reg
052c +  add R7, R17, R7	# ptr, #@addP_reg_reg
0530 +  lw  R15, [R7, #16]	# int, #@loadI
0534 +  lw  R28, [R28, #16]	# int, #@loadI
0538 +  li R7, #12288	# int, #@loadConI
053c +  li R17, #12288	# int, #@loadConI
0540 +  andr  R7, R28, R7	#@andI_reg_reg
0544 +  andr  R15, R15, R17	#@andI_reg_reg
0548 +  beq  R7, zr, B93	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

054c    B35: #	out( B93 B36 ) &lt;- in( B34 )  Freq: 16.6446
054c +  beq  R15, zr, B93	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

0550    B36: #	out( B34 B37 ) &lt;- in( B35 )  Freq: 16.644
0550 +  addiw  R29, R29, #2	#@addI_reg_imm
0554 +  blt  R29, R16, B34	#@cmpI_loop  P=0.783578 C=29660.000000

0558    B37: #	out( B32 B38 ) &lt;- in( B36 )  Freq: 3.60213
0558 +  ld  R15, [R23, #920]	# ptr, #@loadP
055c +  lwu zr, [R15]	# Safepoint: poll for GC, #@safePoint        # jdk.internal.module.Checks::isJavaIdentifier @ bci:71 (line 185) L[0]=R30 L[1]=_ L[2]=R29 L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {x30=Oop c_rarg3=Oop off=1372/0x55c}
0560 +  blt  R29, R10, B32	#@cmpI_branch  P=0.783578 C=29660.000000

0564    B38: #	out( B43 B39 ) &lt;- in( B27 B37 )  Freq: 0.779581
0564 +  bge  R29, R12, B43	#@cmpI_branch  P=0.500000 C=-1.000000

0568    B39: #	out( B126 B40 ) &lt;- in( B38 )  Freq: 0.38979
0568 +  # castII of R29, #@castII
0568    bgeu  R29, R31, B126	#@cmpU_branch  P=0.000001 C=-1.000000

056c    B40: #	out( B127 B41 ) &lt;- in( B39 )  Freq: 0.38979
056c +  spill R29 -&gt; R7	# spill size = 32
0570 +  # castII of R7, #@castII
0570    bgeu  R7, R31, B127	#@cmpU_branch  P=0.000001 C=-1.000000

0574    B41: #	out( B93 B42 ) &lt;- in( B40 B42 ) Loop( B41-B42 inner post of N839) Freq: 0.779553
0574 +  addw  R7, R29, zr	#@convI2L_reg_reg
0578 +  add R7, R13, R7	# ptr, #@addP_reg_reg
057c +  lbu  R7, [R7, #16]	# byte, #@loadUB2L
0580 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0584 +  mv  R30, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d01d5ab0&gt; *	# ptr, #@loadConP
059c +  mv  R28, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d01d5ab0&gt; *	# ptr, #@loadConP
05b4 +  add R7, R30, R7	# ptr, #@addP_reg_reg
05b8 +  lw  R28, [R7, #16]	# int, #@loadI
05bc +  li R7, #12288	# int, #@loadConI
05c0 +  andr  R7, R28, R7	#@andI_reg_reg
05c4 +  beq  R7, zr, B93	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

05c8    B42: #	out( B41 B43 ) &lt;- in( B41 )  Freq: 0.779526
05c8 +  addiw  R29, R29, #1	#@addI_reg_imm
05cc +  blt  R29, R12, B41	#@cmpI_loop  P=0.500000 C=29660.000000

05d0    B43: #	out( B44 ) &lt;- in( B93 B38 B23 B42 )  Freq: 0.996365
05d0 +  spill R11 -&gt; R16	# spill size = 32

05d4    B44: #	out( N1 ) &lt;- in( B54 B48 B94 B47 B43 )  Freq: 0.99985
05d4 +  spill R16 -&gt; R10	# spill size = 32
05d8 +  # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
05f0 +  ret	// return register, #@Ret

05f4    B45: #	out( B46 ) &lt;- in( B50 ) top-of-loop Freq: 8.36562
05f4 +  spill R16 -&gt; [sp, #8]	# spill size = 32

05f8    B46: #	out( B47 ) &lt;- in( B91 B45 ) Loop( B46-B45 ) Freq: 10.6795
05f8 +  spill [sp, #8] -&gt; R16	# spill size = 32
05fc +  subw  R28, R11, R15	#@subI_reg_reg
0600    CMove R28, (R11 lt R15), R28, R16	#@cmovI_cmpI
	
0608 +  li R17, #2000	# int, #@loadConI
060c +  li R7, #2000	# int, #@loadConI
0610    CMove R28, (R28 gtu R7), R28, R17	#@cmovI_cmpU
	
0618 +  addw  R7, R28, R15	#@addI_reg_reg
        nop 	# 2 bytes pad for loops and calls

0620    B47: #	out( B44 B48 ) &lt;- in( B46 B49 ) Loop( B47-B49 inner main of N168 strip mined) Freq: 49.3337
0620 +  addw  R28, R15, zr	#@convI2L_reg_reg
0624 +  add R28, R10, R28	# ptr, #@addP_reg_reg
0628 +  lbu  R12, [R28, #16]	# byte, #@loadUB2L
062c +  lbu  R28, [R28, #17]	# byte, #@loadUB2L
0630 +  slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0634 +  mv  R9, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d01d5ab0&gt; *	# ptr, #@loadConP
064c +  mv  R17, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d01d5ab0&gt; *	# ptr, #@loadConP
0664 +  slli  R12, R12, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0668 +  add R28, R9, R28	# ptr, #@addP_reg_reg
066c +  add R12, R9, R12	# ptr, #@addP_reg_reg
0670 +  lw  R17, [R12, #16]	# int, #@loadI
0674 +  lw  R28, [R28, #16]	# int, #@loadI
0678 +  li R12, #12288	# int, #@loadConI
067c +  li R9, #12288	# int, #@loadConI
0680 +  andr  R17, R17, R12	#@andI_reg_reg
0684 +  andr  R28, R28, R9	#@andI_reg_reg
0688 +  beq  R17, zr, B44	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

068c    B48: #	out( B44 B49 ) &lt;- in( B47 )  Freq: 49.3321
068c +  beq  R28, zr, B44	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

0690    B49: #	out( B47 B50 ) &lt;- in( B48 )  Freq: 49.3304
0690 +  addiw  R15, R15, #2	#@addI_reg_imm
0694 +  blt  R15, R7, B47	#@cmpI_loop  P=0.783578 C=29660.000000

0698    B50: #	out( B45 B51 ) &lt;- in( B49 )  Freq: 10.6762
0698 +  ld  R28, [R23, #920]	# ptr, #@loadP
069c +  lwu zr, [R28]	# Safepoint: poll for GC, #@safePoint        # jdk.internal.module.Checks::isJavaIdentifier @ bci:71 (line 185) L[0]=R30 L[1]=_ L[2]=R15 L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=sp + #0 L[1]=sp + #20 L[2]=_ L[3]=_
        # OopMap {x30=Oop c_rarg0=Oop [0]=Oop off=1692/0x69c}
06a0 +  blt  R15, R11, B45	#@cmpI_branch  P=0.783578 C=29660.000000

06a4    B51: #	out( B56 B52 ) &lt;- in( B98 B50 )  Freq: 2.31056
06a4 +  bge  R15, R13, B56	#@cmpI_branch  P=0.500000 C=-1.000000

06a8    B52: #	out( B112 B53 ) &lt;- in( B51 )  Freq: 1.15528
06a8 +  # castII of R15, #@castII
06a8    bgeu  R15, R31, B112	#@cmpU_branch  P=0.000001 C=-1.000000

06ac    B53: #	out( B113 B54 ) &lt;- in( B52 )  Freq: 1.15528
06ac +  spill R15 -&gt; R28	# spill size = 32
06b0 +  # castII of R28, #@castII
06b0    bgeu  R28, R31, B113	#@cmpU_branch  P=0.000001 C=-1.000000

06b4    B54: #	out( B44 B55 ) &lt;- in( B53 B55 ) Loop( B54-B55 inner post of N828) Freq: 2.31048
06b4 +  addw  R7, R15, zr	#@convI2L_reg_reg
06b8 +  add R7, R10, R7	# ptr, #@addP_reg_reg
06bc +  lbu  R7, [R7, #16]	# byte, #@loadUB2L
06c0 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
06c4 +  mv  R30, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d01d5ab0&gt; *	# ptr, #@loadConP
06dc +  mv  R28, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d01d5ab0&gt; *	# ptr, #@loadConP
06f4 +  add R7, R30, R7	# ptr, #@addP_reg_reg
06f8 +  lw  R7, [R7, #16]	# int, #@loadI
06fc +  li R28, #12288	# int, #@loadConI
0700 +  andr  R28, R7, R28	#@andI_reg_reg
0704 +  beq  R28, zr, B44	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

0708    B55: #	out( B54 B56 ) &lt;- in( B54 )  Freq: 2.3104
0708 +  addiw  R15, R15, #1	#@addI_reg_imm
070c +  blt  R15, R13, B54	#@cmpI_loop  P=0.500000 C=29660.000000

0710    B56: #	out( B104 B57 ) &lt;- in( B51 B84 B55 )  Freq: 2.94959
0710 +  spill [sp, #20] -&gt; R31	# spill size = 32
0714 +  addiw  R9, R31, #1	#@addI_reg_imm
0718 +  ld  R28, [R23, #920]	# ptr, #@loadP
071c +  lwu zr, [R28]	# Safepoint: poll for GC, #@safePoint        # jdk.internal.module.Checks::isTypeName @ bci:35 (line 135) L[0]=sp + #0 L[1]=_ L[2]=R9 L[3]=_
        # OopMap {[0]=Oop off=1820/0x71c}
0720 +  spill [sp, #0] -&gt; R30	# spill size = 64
0724 +  lwu  R15, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0728 +  lb  R17, [R30, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
072c +  decode_heap_oop  R28, R15	#@decodeHeapOop
0730 +  bne  R17, zr, B104	#@cmpI_reg_imm0_branch  P=0.000000 C=91997.000000

0734    B57: #	out( B137 B58 ) &lt;- in( B56 )  Freq: 2.94959
0734    lwu  R8, [R28, #12]	# range, #@loadRange
0738    NullCheck R28

0738    B58: #	out( B111 B59 ) &lt;- in( B57 )  Freq: 2.94959
0738 +  subw  R7, R8, R31	#@subI_reg_reg
073c +  addiw  R12, R7, #-1	#@addI_reg_imm
0740 +  bgeu  R9, R8, B111	#@cmpU_branch  P=0.000000 C=5375.000000

0744    B59: #	out( B96 B60 ) &lt;- in( B58 )  Freq: 2.94959
0744 +  blt  R12, zr, B96	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0748    B60: #	out( B62 B61 ) &lt;- in( B59 )  Freq: 2.94958
0748 +  addw  R7, R31, zr	#@convI2L_reg_reg
074c +  add R7, R28, R7	# ptr, #@addP_reg_reg
0750 +  addi  R11, R7, #17	# ptr, #@addP_reg_imm
0754 +  li R13, #46	# int, #@loadConI
0758    StringUTF16 IndexOf char[] R11,R12,R13 -&gt; R10
09fc +  blt  R10, zr, B62	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0a00    B61: #	out( B62 ) &lt;- in( B60 )  Freq: 2.94663
0a00 +  addw  R28, R31, R10	#@addI_reg_reg
0a04 +  addiw  R10, R28, #1	#@addI_reg_imm

0a08    B62: #	out( B7 B63 ) &lt;- in( B61 B60 )  Freq: 2.94958
0a08 +  li R28, #-1	# int, #@loadConI
0a0c +  beq  R10, R28, B7	#@cmpI_branch  P=0.252282 C=24237.000000

0a10    B63: #	out( B134 B64 ) &lt;- in( B31 B62 ) Loop( B63-B62 ) Freq: 2.95323
0a10 +  decode_heap_oop  R11, R15	#@decodeHeapOop
0a14    lwu  R28, [R11, #12]	# range, #@loadRange
0a18    NullCheck R11

0a18    B64: #	out( B101 B65 ) &lt;- in( B63 )  Freq: 2.95323
0a18 +  lb  R7, [R30, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0a1c +  sraw  R8, R28, R7	#@rShiftI_reg_reg
0a20 +  blt  R9, zr, B101	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

0a24    B65: #	out( B106 B66 ) &lt;- in( B64 )  Freq: 2.95323
0a24 +  bgt  R9, R10, B106	#@cmpI_branch  P=0.000000 C=5375.000000

0a28    B66: #	out( B107 B67 ) &lt;- in( B65 )  Freq: 2.95323
0a28 +  bgt  R10, R8, B107	#@cmpI_branch  P=0.000000 C=5375.000000

0a2c    B67: #	out( B70 B68 ) &lt;- in( B66 )  Freq: 2.95322
0a2c +  bne  R9, zr, B70	#@cmpI_reg_imm0_branch  P=0.627790 C=5376.000000

0a30    B68: #	out( B92 B69 ) &lt;- in( B67 )  Freq: 1.09922
0a30 +  beq  R10, R8, B92	#@cmpI_branch  P=0.011494 C=2001.000000

0a34    B69: #	out( B71 ) &lt;- in( B68 )  Freq: 1.08658
0a34 +  li R9, #0	# int, #@loadConI
0a38    spill R10 -&gt; R13	# spill size = 32
0a3c +  j  B71	#@branch

0a40    B70: #	out( B71 ) &lt;- in( B67 )  Freq: 1.85401
0a40 +  subw  R13, R10, R9	#@subI_reg_reg

0a44    B71: #	out( B105 B72 ) &lt;- in( B69 B70 )  Freq: 2.94059
0a44 +  bne  R7, zr, B105	#@cmpI_reg_imm0_branch  P=0.000000 C=91997.000000

0a48    B72: #	out( B132 B73 ) &lt;- in( B71 )  Freq: 2.94059
0a48 +  spill R10 -&gt; [sp, #12]	# spill size = 32
0a4c +  spill R9 -&gt; R12	# spill size = 32
0a50 +  spill R14 -&gt; [sp, #8]	# spill size = 32
0a54 +  spill R29 -&gt; [sp, #4]	# spill size = 32
0a58 +  spill R16 -&gt; [sp, #0]	# spill size = 32
0a5c +  spill R30 -&gt; R8	# spill size = 64
0a60    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringLatin1::newString
        # java.lang.String::substring @ bci:41 (line 2707) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=R8 L[1]=sp + #12 L[2]=_ L[3]=_
        # OopMap {fp=Oop off=2660/0xa64}

0a64    B73: #	out( B95 B74 ) &lt;- in( B72 )  Freq: 2.94053
        # Block is sole successor of call
0a64 +  beq   R10, zr, B95	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

0a68    B74: #	out( B75 ) &lt;- in( B73 )  Freq: 2.94053
0a68 +  spill R10 -&gt; R31	# spill size = 64
0a6c +  spill R8 -&gt; R30	# spill size = 64
0a70 +  spill [sp, #0] -&gt; R16	# spill size = 32
0a74 +  spill [sp, #4] -&gt; R29	# spill size = 32
0a78 +  spill [sp, #8] -&gt; R14	# spill size = 32
0a7c +  spill [sp, #12] -&gt; R10	# spill size = 32

0a80    B75: #	out( B135 B76 ) &lt;- in( B92 B74 )  Freq: 2.95316
0a80 +  lwu  R28, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0a84 +  decode_heap_oop  R7, R28	#@decodeHeapOop
0a88    lwu  R8, [R7, #12]	# range, #@loadRange
0a8c    NullCheck R7

0a8c    B76: #	out( B108 B77 ) &lt;- in( B75 )  Freq: 2.95316
0a8c +  bleu  R8, zr, B108	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=8622.000000

0a90    B77: #	out( B131 B78 ) &lt;- in( B76 )  Freq: 2.95316
0a90 +  spill R31 -&gt; R8	# spill size = 64
0a94 +  spill R10 -&gt; [sp, #20]	# spill size = 32
0a98 +  spill R14 -&gt; [sp, #16]	# spill size = 32
0a9c +  spill R29 -&gt; [sp, #12]	# spill size = 32
0aa0 +  spill R16 -&gt; [sp, #8]	# spill size = 32
0aa4 +  spill R30 -&gt; [sp, #0]	# spill size = 64
0aa8 +  mv  R11, java/util/ImmutableCollections$SetN:exact *	# ptr, #@loadConP
0ac0    spill R31 -&gt; R12	# spill size = 64
0ac4    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.ImmutableCollections$SetN::probe
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=sp + #0 L[1]=sp + #20 L[2]=_ L[3]=_
        # OopMap {fp=Oop [0]=Oop off=2760/0xac8}

0ac8    B78: #	out( B109 B79 ) &lt;- in( B77 )  Freq: 2.9531
        # Block is sole successor of call
0ac8 +  spill R8 -&gt; R30	# spill size = 64
0acc +  lwu  R7, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0ad0 +  lb  R28, [R30, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0ad4    spill R10 -&gt; R29	# spill size = 32
0ad8 +  decode_heap_oop  R10, R7	#@decodeHeapOop
0adc +  bge  R29, zr, B109	#@cmpI_reg_imm0_branch  P=0.000000 C=8485.000000

0ae0    B79: #	out( B102 B80 ) &lt;- in( B78 )  Freq: 2.9531
0ae0 +  bne  R28, zr, B102	#@cmpI_reg_imm0_branch  P=0.000000 C=91997.000000

0ae4    B80: #	out( B136 B81 ) &lt;- in( B79 )  Freq: 2.9531
0ae4    lwu  R31, [R10, #12]	# range, #@loadRange
0ae8    NullCheck R10

0ae8    B81: #	out( B110 B82 ) &lt;- in( B80 )  Freq: 2.95309
0ae8 +  bleu  R31, zr, B110	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=38842.000000

0aec    B82: #	out( B103 B83 ) &lt;- in( B81 )  Freq: 2.95309
0aec +  lbu  R12, [R10, #16]	# byte, #@loadUB
0af0 +  addw  R7, R12, zr	#@convI2L_reg_reg
0af4 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0af8 +  mv  R11, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d01d5ab0&gt; *	# ptr, #@loadConP
0b10 +  mv  R29, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d01d5ab0&gt; *	# ptr, #@loadConP
0b28 +  add R7, R11, R7	# ptr, #@addP_reg_reg
0b2c +  sraw  R13, R31, R28	#@rShiftI_reg_reg
0b30 +  lw  R29, [R7, #16]	# int, #@loadI
0b34 +  li R28, #28672	# int, #@loadConI
0b38 +  li R7, #20480	# int, #@loadConI
0b3c +  andr  R8, R29, R28	#@andI_reg_reg
0b40 +  blt  R8, R7, B103	#@cmpI_branch  P=0.000000 C=5376.000000

0b44    B83: #	out( B85 B84 ) &lt;- in( B82 )  Freq: 2.95309
0b44 +  spill [sp, #12] -&gt; R29	# spill size = 32
0b48 +  bgt  R13, R29, B85	#@cmpI_branch  P=0.783578 C=37852.000000

0b4c    B84: #	out( B56 ) &lt;- in( B83 )  Freq: 0.639113
0b4c +  spill [sp, #8] -&gt; R16	# spill size = 32
0b50 +  spill [sp, #16] -&gt; R14	# spill size = 32
0b54 +  j  B56	#@branch

0b58    B85: #	out( B97 B86 ) &lt;- in( B83 )  Freq: 2.31398
0b58 +  bleu  R31, R29, B97	#@cmpU_branch  P=0.000001 C=-1.000000

0b5c    B86: #	out( B97 B87 ) &lt;- in( B85 )  Freq: 2.31397
0b5c +  li R28, #-2147483648	# int, #@loadConI
0b60 +  addiw  R11, R13, #-1	#@addI_reg_imm
0b64    CMove R11, (R13 lt R11), R11, R28	#@cmovI_cmpI
	
0b6c +  addw  R7, R13, zr	#@convI2L_reg_reg
0b70 +  addw  R28, R31, zr	#@convI2L_reg_reg
0b74 +  addi  R7, R7, #-1	#@addL_reg_imm
0b78 +  bgeu  R7, R28, B97	#@cmpUL_branch  P=0.000001 C=-1.000000

0b7c    B87: #	out( B94 B88 ) &lt;- in( B86 )  Freq: 2.31397
0b7c +  lbu  R7, [R10, #17]	# byte, #@loadUB2L
0b80 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0b84 +  mv  R12, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d01d5ab0&gt; *	# ptr, #@loadConP
0b9c +  mv  R28, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d01d5ab0&gt; *	# ptr, #@loadConP
0bb4 +  add R7, R12, R7	# ptr, #@addP_reg_reg
0bb8 +  lw  R28, [R7, #16]	# int, #@loadI
0bbc +  li R7, #12288	# int, #@loadConI
0bc0 +  andr  R7, R28, R7	#@andI_reg_reg
0bc4 +  beq  R7, zr, B94	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

0bc8    B88: #	out( B98 B89 ) &lt;- in( B87 )  Freq: 2.31389
0bc8 +  spill [sp, #16] -&gt; R14	# spill size = 32
0bcc +  ble  R11, R14, B98	#@cmpI_branch  P=0.000001 C=-1.000000

0bd0    B89: #	out( B99 B90 ) &lt;- in( B88 )  Freq: 2.31389
0bd0 +  bleu  R31, R14, B99	#@cmpU_branch  P=0.000001 C=-1.000000

0bd4    B90: #	out( B100 B91 ) &lt;- in( B89 )  Freq: 2.31389
0bd4 +  li R28, #3	# int, #@loadConI
0bd8 +  bleu  R31, R28, B100	#@cmpU_branch  P=0.000001 C=-1.000000

0bdc    B91: #	out( B46 ) &lt;- in( B90 )  Freq: 2.31389
0bdc +  li R15, #2	# int, #@loadConI
0be0 +  j  B46	#@branch

0be4    B92: #	out( B75 ) &lt;- in( B68 )  Freq: 0.0126347
0be4 +  spill R30 -&gt; R31	# spill size = 64
0be8 +  j  B75	#@branch

0bec    B93: #	out( B43 ) &lt;- in( B41 B35 B26 B34 )  Freq: 0.00117571
0bec +  li R11, #0	# int, #@loadConI
0bf0 +  j  B43	#@branch

0bf4    B94: #	out( B44 ) &lt;- in( B87 )  Freq: 7.80647e-05
0bf4 +  spill [sp, #8] -&gt; R16	# spill size = 32
0bf8 +  j  B44	#@branch

0bfc    B95: #	out( N1 ) &lt;- in( B73 )  Freq: 2.97958e-06
0bfc +  li R11, #-10	# int, #@loadConI
0c00    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=3076/0xc04}
0c04    #@ShouldNotReachHere

0c10    B96: #	out( N1 ) &lt;- in( B59 )  Freq: 2.94959e-06
0c10 +  li R11, #-50	# int, #@loadConI
0c14    spill R28 -&gt; [sp, #16]	# spill size = 64
0c18 +  spill R9 -&gt; [sp, #12]	# spill size = 32
0c1c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::indexOf @ bci:32 (line 213) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #16 STK[1]=#46 STK[2]=sp + #12 STK[3]=R8
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=sp + #0 L[1]=_ L[2]=sp + #12 L[3]=_
        # OopMap {[0]=Oop [16]=Oop off=3104/0xc20}
0c20    #@ShouldNotReachHere

0c2c    B97: #	out( N1 ) &lt;- in( B86 B85 )  Freq: 4.65868e-06
0c2c +  spill [sp, #0] -&gt; R8	# spill size = 64
0c30 +  li R11, #-138	# int, #@loadConI
0c34    spill R30 -&gt; [sp, #8]	# spill size = 64
0c38 +  spill R13 -&gt; [sp, #4]	# spill size = 32
0c3c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:46 (line 180) L[0]=sp + #8 L[1]=_ L[2]=#1 L[3]=_ STK[0]=#1 STK[1]=sp + #4
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=R8 L[1]=sp + #20 L[2]=_ L[3]=_
        # OopMap {fp=Oop [8]=Oop off=3136/0xc40}
0c40    #@ShouldNotReachHere

0c4c    B98: #	out( B51 ) &lt;- in( B88 )  Freq: 2.34462e-06
0c4c +  li R15, #2	# int, #@loadConI
0c50    spill [sp, #8] -&gt; R16	# spill size = 32
0c54 +  j  B51	#@branch

0c58    B99: #	out( N1 ) &lt;- in( B89 )  Freq: 2.31389e-06
0c58    #@ShouldNotReachHere

0c64    B100: #	out( N1 ) &lt;- in( B90 )  Freq: 2.31389e-06
0c64    #@ShouldNotReachHere

0c70    B101: #	out( N1 ) &lt;- in( B64 )  Freq: 1.47661e-06
0c70 +  li R11, #-187	# int, #@loadConI
0c74    spill R30 -&gt; [sp, #16]	# spill size = 64
0c78 +  spill R10 -&gt; [sp, #12]	# spill size = 32
0c7c +  spill R10 -&gt; [sp, #24]	# spill size = 32
0c80 +  spill R9 -&gt; [sp, #32]	# spill size = 32
0c84 +  spill R9 -&gt; [sp, #36]	# spill size = 32
0c88    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:1 (line 4598) L[0]=sp + #36 L[1]=sp + #12 L[2]=R8 STK[0]=sp + #32
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #16 L[1]=sp + #32 L[2]=sp + #24 L[3]=R8 L[4]=_
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=sp + #16 L[1]=sp + #12 L[2]=_ L[3]=_
        # OopMap {[16]=Oop off=3212/0xc8c}
0c8c    #@ShouldNotReachHere

0c98    B102: #	out( N1 ) &lt;- in( B79 )  Freq: 1.47655e-06
0c98 +  spill [sp, #0] -&gt; R8	# spill size = 64
0c9c +  spill [sp, #20] -&gt; [sp, #0]	# spill size = 32
0ca4 +  li R11, #-187	# int, #@loadConI
0ca8    spill R30 -&gt; [sp, #16]	# spill size = 64
0cac +  spill R30 -&gt; [sp, #24]	# spill size = 64
0cb0 +  spill R28 -&gt; [sp, #4]	# spill size = 32
0cb4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #4
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=sp + #16 L[1]=#0
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #24 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop off=3256/0xcb8}
0cb8    #@ShouldNotReachHere

0cc4    B103: #	out( N1 ) &lt;- in( B82 )  Freq: 1.47655e-06
0cc4 +  spill [sp, #20] -&gt; [sp, #8]	# spill size = 32
0ccc +  li R11, #-187	# int, #@loadConI
0cd0    spill R30 -&gt; [sp, #16]	# spill size = 64
0cd4 +  spill R12 -&gt; [sp, #12]	# spill size = 32
0cd8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.CharacterDataLatin1::isJavaIdentifierStart @ bci:14 (line 116) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8 STK[1]=#20480
        # java.lang.Character::isJavaIdentifierStart @ bci:5 (line 10070) L[0]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:28 (line 176) L[0]=sp + #16 L[1]=sp + #12 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=_
        # OopMap {[0]=Oop [16]=Oop off=3292/0xcdc}
0cdc    #@ShouldNotReachHere

0ce8    B104: #	out( N1 ) &lt;- in( B56 )  Freq: 1.4748e-06
0ce8 +  li R11, #-187	# int, #@loadConI
0cec    spill R9 -&gt; [sp, #12]	# spill size = 32
0cf0 +  spill R17 -&gt; [sp, #16]	# spill size = 32
0cf4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #16
        # java.lang.String::indexOf @ bci:1 (line 2416) L[0]=sp + #0 L[1]=#46 L[2]=sp + #12
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=sp + #0 L[1]=_ L[2]=sp + #12 L[3]=_
        # OopMap {[0]=Oop off=3320/0xcf8}
0cf8    #@ShouldNotReachHere

0d04    B105: #	out( N1 ) &lt;- in( B71 )  Freq: 1.47029e-06
0d04 +  li R11, #-187	# int, #@loadConI
0d08    spill R10 -&gt; [sp, #0]	# spill size = 32
0d0c +  spill R30 -&gt; [sp, #8]	# spill size = 64
0d10 +  spill R9 -&gt; [sp, #4]	# spill size = 32
0d14 +  spill R13 -&gt; [sp, #16]	# spill size = 32
0d18 +  spill R7 -&gt; [sp, #20]	# spill size = 32
0d1c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #20
        # java.lang.String::substring @ bci:28 (line 2707) L[0]=sp + #8 L[1]=sp + #4 L[2]=_ L[3]=_ L[4]=sp + #16
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=sp + #8 L[1]=sp + #0 L[2]=_ L[3]=_
        # OopMap {[8]=Oop off=3360/0xd20}
0d20    #@ShouldNotReachHere

0d2c    B106: #	out( N1 ) &lt;- in( B65 )  Freq: 1.40821e-06
0d2c +  li R11, #-187	# int, #@loadConI
0d30    spill R30 -&gt; [sp, #16]	# spill size = 64
0d34 +  spill R10 -&gt; [sp, #12]	# spill size = 32
0d38 +  spill R10 -&gt; [sp, #24]	# spill size = 32
0d3c +  spill R9 -&gt; [sp, #36]	# spill size = 32
0d40 +  spill R9 -&gt; [sp, #40]	# spill size = 32
0d44    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:6 (line 4598) L[0]=sp + #40 L[1]=sp + #12 L[2]=R8 STK[0]=sp + #36 STK[1]=sp + #12
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #16 L[1]=sp + #36 L[2]=sp + #24 L[3]=R8 L[4]=_
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=sp + #16 L[1]=sp + #12 L[2]=_ L[3]=_
        # OopMap {[16]=Oop off=3400/0xd48}
0d48    #@ShouldNotReachHere

0d54    B107: #	out( N1 ) &lt;- in( B66 )  Freq: 1.40821e-06
0d54 +  li R11, #-187	# int, #@loadConI
0d58    spill R30 -&gt; [sp, #16]	# spill size = 64
0d5c +  spill R10 -&gt; [sp, #12]	# spill size = 32
0d60 +  spill R10 -&gt; [sp, #24]	# spill size = 32
0d64 +  spill R9 -&gt; [sp, #36]	# spill size = 32
0d68    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:11 (line 4598) L[0]=sp + #36 L[1]=sp + #12 L[2]=R8 STK[0]=sp + #12 STK[1]=R8
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #16 L[1]=sp + #36 L[2]=sp + #24 L[3]=R8 L[4]=_
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=sp + #16 L[1]=sp + #12 L[2]=_ L[3]=_
        # OopMap {[16]=Oop off=3436/0xd6c}
0d6c    #@ShouldNotReachHere

0d78    B108: #	out( N1 ) &lt;- in( B76 )  Freq: 1.40818e-06
0d78 +  li R11, #-187	# int, #@loadConI
0d7c    spill R30 -&gt; [sp, #0]	# spill size = 64
0d80 +  spill R10 -&gt; [sp, #8]	# spill size = 32
0d84 +  spill R31 -&gt; [sp, #16]	# spill size = 64
0d88    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isEmpty @ bci:5 (line 1487) L[0]=_ STK[0]=R8
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=_
        # OopMap {[0]=Oop [16]=Oop off=3468/0xd8c}
0d8c    #@ShouldNotReachHere

0d98    B109: #	out( N1 ) &lt;- in( B78 )  Freq: 1.40815e-06
0d98 +  spill [sp, #0] -&gt; R8	# spill size = 64
0d9c +  li R11, #-187	# int, #@loadConI
0da0    spill R30 -&gt; [sp, #8]	# spill size = 64
0da4 +  spill R29 -&gt; [sp, #4]	# spill size = 32
0da8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::contains @ bci:17 (line 938) L[0]=_ L[1]=_ STK[0]=sp + #4
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=R8 L[1]=sp + #20 L[2]=_ L[3]=_
        # OopMap {fp=Oop [8]=Oop off=3500/0xdac}
0dac    #@ShouldNotReachHere

0db8    B110: #	out( N1 ) &lt;- in( B81 )  Freq: 1.40814e-06
0db8 +  spill [sp, #0] -&gt; R8	# spill size = 64
0dbc +  spill [sp, #20] -&gt; [sp, #0]	# spill size = 32
0dc4 +  li R11, #-187	# int, #@loadConI
0dc8    spill R30 -&gt; [sp, #16]	# spill size = 64
0dcc +  spill R10 -&gt; [sp, #24]	# spill size = 64
0dd0 +  spill R31 -&gt; [sp, #4]	# spill size = 32
0dd4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:7 (line 47) L[0]=sp + #24 L[1]=#0 STK[0]=#0 STK[1]=sp + #4
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #16 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop off=3544/0xdd8}
0dd8    #@ShouldNotReachHere

0de4    B111: #	out( N1 ) &lt;- in( B58 )  Freq: 1.40647e-06
0de4 +  li R11, #-27	# int, #@loadConI
0de8    spill R28 -&gt; [sp, #16]	# spill size = 64
0dec +  spill R9 -&gt; [sp, #12]	# spill size = 32
0df0 +  spill R9 -&gt; [sp, #24]	# spill size = 32
0df4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::indexOf @ bci:13 (line 207) L[0]=sp + #16 L[1]=#46 L[2]=sp + #24 L[3]=R8 STK[0]=sp + #12
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=sp + #0 L[1]=_ L[2]=sp + #12 L[3]=_
        # OopMap {[0]=Oop [16]=Oop off=3576/0xdf8}
0df8    #@ShouldNotReachHere

0e04    B112: #	out( N1 ) &lt;- in( B52 )  Freq: 1.17062e-06
0e04    #@ShouldNotReachHere

0e10    B113: #	out( N1 ) &lt;- in( B53 )  Freq: 1.17062e-06
0e10    #@ShouldNotReachHere

0e1c    B114: #	out( N1 ) &lt;- in( B25 B24 )  Freq: 1.57183e-06
0e1c +  li R11, #-138	# int, #@loadConI
0e20    spill R30 -&gt; R8	# spill size = 64
0e24 +  spill R12 -&gt; [sp, #0]	# spill size = 32
0e28    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:46 (line 180) L[0]=R8 L[1]=_ L[2]=#1 L[3]=_ STK[0]=#1 STK[1]=sp + #0
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop off=3628/0xe2c}
0e2c    #@ShouldNotReachHere

0e38    B115: #	out( N1 ) &lt;- in( B28 )  Freq: 7.80705e-07
0e38    #@ShouldNotReachHere

0e44    B116: #	out( N1 ) &lt;- in( B13 )  Freq: 6.33828e-07
0e44 +  li R11, #-10	# int, #@loadConI
0e48    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=3660/0xe4c}
0e4c    #@ShouldNotReachHere

0e58    B117: #	out( N1 ) &lt;- in( B2 )  Freq: 4.99999e-07
0e58 +  li R11, #-187	# int, #@loadConI
0e5c    spill R30 -&gt; [sp, #0]	# spill size = 64
0e60 +  spill R17 -&gt; [sp, #8]	# spill size = 32
0e64    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #8
        # java.lang.String::indexOf @ bci:1 (line 2416) L[0]=sp + #0 L[1]=#46 L[2]=#0
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=sp + #0 L[1]=_ L[2]=#0 L[3]=_
        # OopMap {[0]=Oop off=3688/0xe68}
0e68    #@ShouldNotReachHere

0e74    B118: #	out( N1 ) &lt;- in( B7 )  Freq: 4.98204e-07
0e74 +  li R11, #-187	# int, #@loadConI
0e78    spill R30 -&gt; [sp, #0]	# spill size = 64
0e7c +  spill R9 -&gt; [sp, #12]	# spill size = 32
0e80 +  spill R9 -&gt; [sp, #16]	# spill size = 32
0e84    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:1 (line 4598) L[0]=sp + #16 L[1]=R8 L[2]=R8 STK[0]=sp + #12
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #0 L[1]=sp + #12 L[2]=R8 L[3]=R8 L[4]=_
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isTypeName @ bci:40 (line 136) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=3720/0xe88}
0e88    #@ShouldNotReachHere

0e94    B119: #	out( N1 ) &lt;- in( B19 )  Freq: 4.98186e-07
0e94 +  li R11, #-187	# int, #@loadConI
0e98    spill R28 -&gt; [sp, #16]	# spill size = 32
0e9c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #16
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=R8 L[1]=#0
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=R8 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop off=3744/0xea0}
0ea0    #@ShouldNotReachHere

0eac    B120: #	out( N1 ) &lt;- in( B22 )  Freq: 4.98185e-07
0eac +  li R11, #-187	# int, #@loadConI
0eb0    spill R30 -&gt; [sp, #0]	# spill size = 64
0eb4 +  spill R15 -&gt; [sp, #8]	# spill size = 32
0eb8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.CharacterDataLatin1::isJavaIdentifierStart @ bci:14 (line 116) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8 STK[1]=#20480
        # java.lang.Character::isJavaIdentifierStart @ bci:5 (line 10070) L[0]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:28 (line 176) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=3772/0xebc}
0ebc    #@ShouldNotReachHere

0ec8    B121: #	out( N1 ) &lt;- in( B4 )  Freq: 4.76836e-07
0ec8 +  li R11, #-187	# int, #@loadConI
0ecc    spill R30 -&gt; [sp, #0]	# spill size = 64
0ed0 +  spill R12 -&gt; [sp, #12]	# spill size = 32
0ed4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::indexOf @ bci:23 (line 209) L[0]=R8 L[1]=#46 L[2]=#0 L[3]=sp + #12 STK[0]=#0 STK[1]=sp + #12
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=sp + #0 L[1]=_ L[2]=#0 L[3]=_
        # OopMap {fp=Oop [0]=Oop off=3800/0xed8}
0ed8    #@ShouldNotReachHere

0ee4    B122: #	out( N1 ) &lt;- in( B8 )  Freq: 4.75124e-07
0ee4 +  li R11, #-187	# int, #@loadConI
0ee8    spill R30 -&gt; [sp, #0]	# spill size = 64
0eec +  spill R9 -&gt; [sp, #12]	# spill size = 32
0ef0 +  spill R9 -&gt; [sp, #16]	# spill size = 32
0ef4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:6 (line 4598) L[0]=sp + #16 L[1]=R8 L[2]=R8 STK[0]=sp + #12 STK[1]=R8
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #0 L[1]=sp + #12 L[2]=R8 L[3]=R8 L[4]=_
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isTypeName @ bci:40 (line 136) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=3832/0xef8}
0ef8    #@ShouldNotReachHere

0f04    B123: #	out( N1 ) &lt;- in( B16 )  Freq: 4.75117e-07
0f04 +  li R11, #-187	# int, #@loadConI
0f08    spill R10 -&gt; [sp, #0]	# spill size = 64
0f0c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isEmpty @ bci:5 (line 1487) L[0]=_ STK[0]=R8
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=3856/0xf10}
0f10    #@ShouldNotReachHere

0f1c    B124: #	out( N1 ) &lt;- in( B18 )  Freq: 4.75107e-07
0f1c +  li R11, #-187	# int, #@loadConI
0f20    spill R10 -&gt; [sp, #0]	# spill size = 32
0f24    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::contains @ bci:17 (line 938) L[0]=_ L[1]=_ STK[0]=sp + #0
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop off=3880/0xf28}
0f28    #@ShouldNotReachHere

0f34    B125: #	out( N1 ) &lt;- in( B21 )  Freq: 4.75106e-07
0f34 +  li R11, #-187	# int, #@loadConI
0f38    spill R13 -&gt; [sp, #8]	# spill size = 64
0f3c +  spill R31 -&gt; [sp, #16]	# spill size = 32
0f40    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:7 (line 47) L[0]=sp + #8 L[1]=#0 STK[0]=#0 STK[1]=sp + #16
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=R8 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop [8]=Oop off=3908/0xf44}
0f44    #@ShouldNotReachHere

0f50    B126: #	out( N1 ) &lt;- in( B39 )  Freq: 3.94966e-07
0f50    #@ShouldNotReachHere

0f5c    B127: #	out( N1 ) &lt;- in( B40 )  Freq: 3.94966e-07
0f5c    #@ShouldNotReachHere

0f68    B128: #	out( N1 ) &lt;- in( B11 )  Freq: 3.12767e-07
0f68 +  li R11, #-187	# int, #@loadConI
0f6c    spill R30 -&gt; R8	# spill size = 64
0f70 +  spill R9 -&gt; [sp, #0]	# spill size = 32
0f74 +  spill R13 -&gt; [sp, #4]	# spill size = 32
0f78 +  spill R17 -&gt; [sp, #8]	# spill size = 32
0f7c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #8
        # java.lang.String::substring @ bci:28 (line 2707) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=sp + #4
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isTypeName @ bci:40 (line 136) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop off=3968/0xf80}
0f80    #@ShouldNotReachHere

0f8c    B129: #	out( B133 ) &lt;- in( B12 )  Freq: 6.25534e-06
0f8c     -- 	// exception oop; no code emitted, #@CreateException
0f8c +  spill R10 -&gt; R11	# spill size = 64
0f90 +  j  B133	#@branch

0f94    B130: #	out( B133 ) &lt;- in( B17 )  Freq: 9.96392e-06
0f94     -- 	// exception oop; no code emitted, #@CreateException
0f94 +  spill R10 -&gt; R11	# spill size = 64
0f98 +  j  B133	#@branch

0f9c    B131: #	out( B133 ) &lt;- in( B77 )  Freq: 2.95316e-05
0f9c     -- 	// exception oop; no code emitted, #@CreateException
0f9c +  spill R10 -&gt; R11	# spill size = 64
0fa0 +  j  B133	#@branch

0fa4    B132: #	out( B133 ) &lt;- in( B72 )  Freq: 2.94059e-05
0fa4     -- 	// exception oop; no code emitted, #@CreateException
0fa4 +  spill R10 -&gt; R11	# spill size = 64

0fa8    B133: #	out( N1 ) &lt;- in( B132 B131 B129 B130 )  Freq: 7.51567e-05
0fa8    # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
0fb4 +  j rethrow_stub	#@RethrowException

0fbc    B134: #	out( N1 ) &lt;- in( B63 )  Freq: 2.99245e-06
0fbc +  li R11, #-10	# int, #@loadConI
0fc0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::substring @ bci:1 (line 2701) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=4036/0xfc4}
0fc4    #@ShouldNotReachHere

0fd0    B135: #	out( N1 ) &lt;- in( B75 )  Freq: 2.99238e-06
0fd0 +  li R11, #-10	# int, #@loadConI
0fd4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::isEmpty @ bci:4 (line 1487) L[0]=_ STK[0]=#NULL
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=4056/0xfd8}
0fd8    #@ShouldNotReachHere

0fe4    B136: #	out( N1 ) &lt;- in( B80 )  Freq: 2.99231e-06
0fe4 +  li R11, #-10	# int, #@loadConI
0fe8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::charAt @ bci:6 (line 47) L[0]=_ L[1]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=4076/0xfec}
0fec    #@ShouldNotReachHere

0ff8    B137: #	out( N1 ) &lt;- in( B57 )  Freq: 2.98876e-06
0ff8 +  li R11, #-10	# int, #@loadConI
0ffc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::indexOf @ bci:10 (line 206) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=4096/0x1000}
1000    #@ShouldNotReachHere

100c    B138: #	out( N1 ) &lt;- in( B1 )  Freq: 1.01328e-06
100c +  li R11, #-10	# int, #@loadConI
1010    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL STK[1]=#46 STK[2]=#0
        # OopMap {off=4116/0x1014}
1014    #@ShouldNotReachHere

1020    B139: #	out( N1 ) &lt;- in( B3 )  Freq: 1.01328e-06
1020 +  li R11, #-10	# int, #@loadConI
1024    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::indexOf @ bci:10 (line 206) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=4136/0x1028}
1028    #@ShouldNotReachHere

1034    B140: #	out( N1 ) &lt;- in( B15 )  Freq: 1.00962e-06
1034 +  li R11, #-10	# int, #@loadConI
1038    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::isEmpty @ bci:4 (line 1487) L[0]=_ STK[0]=#NULL
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=4156/0x103c}
103c    #@ShouldNotReachHere

1048    B141: #	out( N1 ) &lt;- in( B20 )  Freq: 1.0096e-06
1048 +  li R11, #-10	# int, #@loadConI
104c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::charAt @ bci:6 (line 47) L[0]=_ L[1]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=4176/0x1050}
1050    #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='456'>
----------------------- MetaData before Compile_id = 456 ------------------------
{method}
 - this oop:          0x0000004096307e80
 - method holder:     &apos;jdk/internal/module/ModulePath&apos;
 - constants:         0x0000004096302d28 constant pool [1026]/operands[112] {0x0000004096302d28} for &apos;jdk/internal/module/ModulePath&apos; cache=0x0000004096308cb8
 - access:            0x81000002  private 
 - name:              &apos;toPackageName&apos;
 - signature:         &apos;(Ljava/nio/file/Path;Ljava/lang/String;)Ljava/util/Optional;&apos;
 - max stack:         4
 - max locals:        6
 - size of params:    3
 - method size:       13
 - highest level:     4
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008317290: 0xbbb i2c: 0x0000004013944dc0 c2i: 0x0000004013944e0c c2iUV: 0x0000004013944dd8
 - compiled entry     0x000000400c5a9b40
 - code size:         133
 - code start:        0x0000004096307d90
 - code end (excl):   0x0000004096307e15
 - method data:       0x0000004096497c98
 - checked ex length: 0
 - linenumber start:  0x0000004096307e15
 - localvar length:   7
 - localvar start:    0x0000004096307e28
 - compiled code: nmethod  18595  437       3       jdk.internal.module.ModulePath::toPackageName (133 bytes)

------------------------ OptoAssembly for Compile_id = 456 -----------------------
#
#  java/util/Optional:exact * ( jdk/internal/module/ModulePath:NotNull *, java/nio/file/Path *, java/lang/String:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: jdk/internal/module/ModulePath:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/nio/file/Path *
#r016 c_rarg3:c_rarg3   : parm 2: java/lang/String:exact *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1413: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B123 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
03c     spill R13 -&gt; [sp, #0]	# spill size = 64
040     lwu  R28, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
044     NullCheck R12

044     B2: #	out( B108 B3 ) &lt;- in( B1 )  Freq: 0.999999
044 +   mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d0885ea0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
054 +   bne  R28, R7, B108	#@cmpN_branch  P=0.000001 C=-1.000000

058     B3: #	out( B146 B4 ) &lt;- in( B2 )  Freq: 0.999998
058 +   # checkcastPP of R12, #@checkCastPP
058     spill R12 -&gt; [sp, #8]	# spill size = 64
05c +   spill R12 -&gt; R11	# spill size = 64
060 +   spill R12 -&gt; R8	# spill size = 64
064     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 276) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=R8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=104/0x68}

068     B4: #	out( B124 B5 ) &lt;- in( B3 )  Freq: 0.999978
        # Block is sole successor of call
068 +   lwu  R28, [R8, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
06c +   #@membar_acquire
	fence ir iorw
070 +   decode_heap_oop  R7, R28	#@decodeHeapOop
074     lwu  R30, [R7, #12]	# range, #@loadRange
078     NullCheck R7

078     B5: #	out( B117 B6 ) &lt;- in( B4 )  Freq: 0.999977
078 +   bleu  R30, zr, B117	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=5375.000000

07c     B6: #	out( B125 B7 ) &lt;- in( B5 )  Freq: 0.999976
07c +   lwu  R7, [R8, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
080 +   decode_heap_oop  R31, R7	#@decodeHeapOop
084 +   addw  R28, R30, zr	#@convI2L_reg_reg
088 +   #@membar_acquire
	fence ir iorw
08c +   slli  R7, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
090 +   addiw  R8, R30, #-1	#@addI_reg_imm
094     lwu  R29, [R31, #12]	# range, #@loadRange
098     NullCheck R31

098     B7: #	out( B104 B8 ) &lt;- in( B6 )  Freq: 0.999975
098 +   add R7, R31, R7	# ptr, #@addP_reg_reg
09c +   bgeu  R8, R29, B104	#@cmpU_branch  P=0.000001 C=-1.000000

0a0     B8: #	out( B68 B9 ) &lt;- in( B7 )  Freq: 0.999974
0a0 +   spill [sp, #8] -&gt; R28	# spill size = 64
0a4 +   lwu  R28, [R28, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
0a8 +   lw  R8, [R7, #12]	# int, #@loadI
0ac +   decode_heap_oop  R31, R28	#@decodeHeapOop
0b0 +   addiw  R28, R8, #-1	#@addI_reg_imm
0b4 +   ble  R28, zr, B68	#@cmpI_reg_imm0_branch  P=0.001488 C=5375.000000

0b8     B9: #	out( B105 B10 ) &lt;- in( B8 )  Freq: 0.998486
0b8 +   li R29, #1048576	# int, #@loadConI
0bc +   bgtu  R28, R29, B105	#@cmpU_branch  P=0.000001 C=-1.000000

0c0     B10: #	out( B11 ) &lt;- in( B9 )  Freq: 0.998485
0c0 +   addw  R7, R8, zr	#@convI2L_reg_reg
0c4 +   addi  R7, R7, #-1	#@addL_reg_imm

0c8     B11: #	out( B126 B12 ) &lt;- in( B10 B105 )  Freq: 0.998486
0c8     lwu  R30, [R31, #12]	# range, #@loadRange
0cc     NullCheck R31

0cc     B12: #	out( B109 B13 ) &lt;- in( B11 )  Freq: 0.998485
0cc +   addi  R10, R7, #23	#@addL_reg_imm
0d0 +   bltu  R30, R28, B109	#@cmpU_branch  P=0.000001 C=-1.000000

0d4     B13: #	out( B89 B14 ) &lt;- in( B12 )  Freq: 0.998484
0d4 +   andi  R12, R10, #-8	#@andL_reg_imm
0d8 +   bgtu  R28, R29, B89	#@cmpU_branch  P=0.000001 C=-1.000000

0dc     B14: #	out( B89 B15 ) &lt;- in( B13 )  Freq: 0.998483
0dc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0dc     ld  R9, [R23, #288]	# ptr, #@loadP
0e0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e0     ld  R29, [R23, #304]	# ptr, #@loadP
0e4 +   add R7, R9, R12	# ptr, #@addP_reg_reg
0e8 +   bgeu  R7, R29, B89	#@cmpP_branch  P=0.000100 C=-1.000000

0ec     B15: #	out( B16 ) &lt;- in( B14 )  Freq: 0.998383
0ec +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0ec     sd  R7, [R23, #288]	# ptr, #@storeP
0f0 +   li R7, #1	# long, #@loadConL
0f4 +   mv  R29, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
104 +   sd  R7, [R9]	# long, #@storeL
108 +   sw  R29, [R9, #8]	# compressed klass ptr, #@storeNKlass
10c +   sw  R28, [R9, #12]	# int, #@storeI

110     B16: #	out( B106 B17 ) &lt;- in( B90 B15 )  Freq: 0.998484
110     
110 +   li R30, #1	# int, #@loadConI
114 +   srli  R7, R10, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
118 +   # checkcastPP of R9, #@checkCastPP
118     addi  R11, R9, #16	# ptr, #@addP_reg_imm
11c +   encode_heap_oop  R19, R9	#@encodeHeapOop
120 +   # castII of R8, #@castII
120     beq  R8, R30, B106	#@cmpI_branch  P=0.000001 C=-1.000000

124     B17: #	out( B78 B18 ) &lt;- in( B16 )  Freq: 0.998483
124 +   addiw  R29, R8, #-1	#@addI_reg_imm
128 +   addi  R10, R31, #16	# ptr, #@addP_reg_imm
12c +   blt  R29, R28, B78	#@cmpI_branch  P=0.001000 C=-1.000000

130     B18: #	out( B19 ) &lt;- in( B17 )  Freq: 0.997485
130 +   addi  R7, R12, #-16	#@addL_reg_imm
134 +   srli  R12, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
138 +   CALL, runtime leaf nofp 0x000000401396d840	#@CallLeafNoFPDirect jlong_disjoint_arraycopy
        No JVM State Info
        # 

13c     B19: #	out( B87 B20 ) &lt;- in( B78 B18 B106 )  Freq: 0.998484
13c     MEMBAR-store-store	#@membar_storestore
140 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
140     ld  R12, [R23, #288]	# ptr, #@loadP
144 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
144     ld  R7, [R23, #304]	# ptr, #@loadP
148 +   addi  R28, R12, #32	# ptr, #@addP_reg_imm
14c +   bgeu  R28, R7, B87	#@cmpP_branch  P=0.000100 C=-1.000000

150     B20: #	out( B21 ) &lt;- in( B19 )  Freq: 0.998384
150 +   li R7, #1	# long, #@loadConL
154 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
154     sd  R28, [R23, #288]	# ptr, #@storeP
158 +   sd  R7, [R12]	# long, #@storeL
15c +   mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d0885ea0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
16c +   sw  R7, [R12, #8]	# compressed klass ptr, #@storeNKlass
170 +   sw  zr, [R12, #12]	# int, #@storeimmI0
174 +   sw  zr, [R12, #16]	# int, #@storeimmI0
178 +   sd  zr, [R12, #24]	# long, #@storeimmL0

17c     B21: #	out( B22 ) &lt;- in( B88 B20 )  Freq: 0.998484
17c +   sw  R19, [R12, #20]	# compressed ptr, #@storeN
180     
180     spill [sp, #8] -&gt; R7	# spill size = 64
184 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
188 +   # checkcastPP of R12, #@checkCastPP
188     sw  R28, [R12, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixPath.fs

18c     B22: #	out( B53 B23 ) &lt;- in( B74 B21 )  Freq: 0.999972
18c +   mv  R31, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
19c +   # checkcastPP of R12, #@checkCastPP
19c     beq   R12, zr, B53	#@cmpP_imm0_branch  P=0.013055 C=10494.000000

1a0     B23: #	out( B110 B24 ) &lt;- in( B22 )  Freq: 0.986918
1a0 +   lwu  R7, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
1a4 +   mv  R29, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d0885ea0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1b4 +   bne  R7, R29, B110	#@cmpN_branch  P=0.000001 C=-1.000000

1b8     B24: #	out( B111 B25 ) &lt;- in( B23 )  Freq: 0.986917
1b8 +   # checkcastPP of R12, #@checkCastPP
1b8     lwu  R7, [R12, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
1bc +   #@membar_acquire
	fence ir iorw
1c0 +   decode_heap_oop  R8, R7	#@decodeHeapOop
1c4 +   bne   R8, zr, B111	#@cmpP_imm0_branch  P=0.000000 C=10534.000000

1c8     B25: #	out( B91 B26 ) &lt;- in( B24 )  Freq: 0.986916
1c8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1c8     ld  R10, [R23, #288]	# ptr, #@loadP
1cc +   lwu  R7, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
1d0 +   lwu  R28, [R12, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
1d4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1d4     ld  R29, [R23, #304]	# ptr, #@loadP
1d8 +   addi  R30, R10, #24	# ptr, #@addP_reg_imm
1dc +   decode_heap_oop  R13, R7	#@decodeHeapOop
1e0 +   decode_heap_oop  R8, R28	#@decodeHeapOop
1e4 +   bgeu  R30, R29, B91	#@cmpP_branch  P=0.000100 C=-1.000000

1e8     B26: #	out( B27 ) &lt;- in( B25 )  Freq: 0.986818
1e8 +   li R7, #1	# long, #@loadConL
1ec +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ec     sd  R30, [R23, #288]	# ptr, #@storeP
1f0 +   sd  R7, [R10]	# long, #@storeL
1f4 +   sw  R31, [R10, #8]	# compressed klass ptr, #@storeNKlass
1f8 +   sw  zr, [R10, #12]	# int, #@storeimmI0
1fc +   sd  zr, [R10, #16]	# long, #@storeimmL0

200     B27: #	out( B127 B28 ) &lt;- in( B92 B26 )  Freq: 0.986916
200     
200 +   MEMBAR-store-store	#@membar_storestore
204 +   # checkcastPP of R10, #@checkCastPP
204     lwu  R14, [R13, #12]	# range, #@loadRange
208     NullCheck R13

208     B28: #	out( B148 B29 ) &lt;- in( B27 )  Freq: 0.986915
208 +   spill R12 -&gt; [sp, #8]	# spill size = 64
20c +   spill R13 -&gt; R12	# spill size = 64
210 +   spill R10 -&gt; [sp, #16]	# spill size = 64
214 +   li R13, #0	# int, #@loadConI
218     spill R10 -&gt; R11	# spill size = 64
21c +   mv  R15, sun/nio/cs/UTF_8:exact *	# ptr, #@loadConP
234     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.String::&lt;init&gt;
        # java.lang.String::&lt;init&gt; @ bci:6 (line 1380) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.Util::toString @ bci:8 (line 63) L[0]=_ STK[0]=sp + #16
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=sp + #8 STK[0]=sp + #8 STK[1]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=568/0x238}

238     B29: #	out( B107 B30 ) &lt;- in( B28 )  Freq: 0.986895
        # Block is sole successor of call
238 +   beq   R8, zr, B107	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

23c     B30: #	out( B79 B31 ) &lt;- in( B29 )  Freq: 0.986894
23c +   #@membar_release
	fence iorw ow
240 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
240     lb  R7, [R23, #56]	# byte, #@loadB
244 +   bne  R7, zr, B79	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

248     B31: #	out( B32 ) &lt;- in( B30 )  Freq: 0.985908
248 +   spill [sp, #8] -&gt; R9	# spill size = 64

24c     B32: #	out( B34 B33 ) &lt;- in( B116 B81 B79 B31 )  Freq: 0.986894
24c +   mv  R7, R9	# ptr -&gt; long, #@castP2X
250     spill [sp, #16] -&gt; R29	# spill size = 64
254 +   mv  R28, R29	# ptr -&gt; long, #@castP2X
258 +   xorr  R28, R28, R7	#@xorL_reg_reg
25c +   encode_heap_oop  R30, R29	#@encodeHeapOop
260 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
264 +   sw  R30, [R9, #24]	# compressed ptr, #@storeN ! Field: volatile sun/nio/fs/UnixPath.stringValue
268 +   beq  R28, zr, B34	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

26c     B33: #	out( B82 B34 ) &lt;- in( B32 )  Freq: 0.985908
26c +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
270 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
27c +   add R10, R28, R7	# ptr, #@addP_reg_reg
280 +   lb  R7, [R10]	# byte, #@loadB
284 +   li R28, #4	# int, #@loadConI
288 +   bne  R7, R28, B82	#@cmpI_branch  P=0.001000 C=-1.000000

28c     B34: #	out( B128 B35 ) &lt;- in( B84 B85 B82 B33 B32 )  Freq: 0.986894
28c +   #@membar_volatile
	fence iorw iorw
290 +   lwu  R28, [R9, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
294 +   decode_heap_oop  R7, R28	#@decodeHeapOop
298 +   #@membar_acquire
	fence ir iorw
29c     spill R7 -&gt; [sp, #8]	# spill size = 64
2a0     lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
2a4     NullCheck R7

2a4     B35: #	out( B129 B36 ) &lt;- in( B34 )  Freq: 0.986893
2a4 +   spill [sp, #0] -&gt; R28	# spill size = 64
2a8     lwu  R29, [R28, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
2ac     NullCheck R28

2ac     B36: #	out( B130 B37 ) &lt;- in( B35 )  Freq: 0.986892
2ac +   decode_heap_oop  R11, R7	#@decodeHeapOop
2b0 +   decode_heap_oop  R30, R29	#@decodeHeapOop
2b4     lwu  R7, [R11, #12]	# range, #@loadRange
2b8     NullCheck R11

2b8     B37: #	out( B131 B38 ) &lt;- in( B36 )  Freq: 0.986891
2b8 +   spill [sp, #8] -&gt; R29	# spill size = 64
2bc +   lb  R31, [R29, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
2c0 +   sraw  R7, R7, R31	#@rShiftI_reg_reg
2c4     lwu  R12, [R30, #12]	# range, #@loadRange
2c8     NullCheck R30

2c8     B38: #	out( B112 B39 ) &lt;- in( B37 )  Freq: 0.98689
2c8 +   lb  R13, [R28, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
2cc +   sraw  R8, R12, R13	#@rShiftI_reg_reg
2d0 +   ble  R8, zr, B112	#@cmpI_reg_imm0_branch  P=0.000000 C=5376.000000

2d4     B39: #	out( B113 B40 ) &lt;- in( B38 )  Freq: 0.98689
2d4 +   li R29, #1	# int, #@loadConI
2d8 +   bne  R8, R29, B113	#@cmpI_branch  P=0.000000 C=5376.000000

2dc     B40: #	out( B114 B41 ) &lt;- in( B39 )  Freq: 0.98689
2dc +   bne  R13, zr, B114	#@cmpI_reg_imm0_branch  P=0.000000 C=93736.000000

2e0     B41: #	out( B118 B42 ) &lt;- in( B40 )  Freq: 0.986889
2e0 +   bleu  R12, zr, B118	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=39572.000000

2e4     B42: #	out( B119 B43 ) &lt;- in( B41 )  Freq: 0.986889
2e4 +   lbu  R12, [R30, #16]	# byte, #@loadUB
2e8 +   li R13, #46	# int, #@loadConI
2ec +   beq  R12, R13, B119	#@cmpI_branch  P=0.000000 C=5376.000000

2f0     B43: #	out( B115 B44 ) &lt;- in( B42 )  Freq: 0.986888
2f0 +   bne  R31, zr, B115	#@cmpI_reg_imm0_branch  P=0.000000 C=93736.000000

2f4     B44: #	out( B150 B45 ) &lt;- in( B43 )  Freq: 0.986888
2f4     CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringLatin1::replace
        # java.lang.String::replace @ bci:18 (line 2801) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_
        # java.lang.String::replace @ bci:63 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {[8]=Oop off=760/0x2f8}

2f8     B45: #	out( B86 B46 ) &lt;- in( B44 )  Freq: 0.986868
        # Block is sole successor of call
2f8 +   beq   R10, zr, B86	#@cmpP_imm0_branch  P=0.000744 C=5376.000000

2fc     B46: #	out( B47 ) &lt;- in( B45 )  Freq: 0.986134
2fc +   spill R10 -&gt; R8	# spill size = 64

300     B47: #	out( B151 B48 ) &lt;- in( B46 B86 )  Freq: 0.986868
300 +   spill R8 -&gt; R11	# spill size = 64
304     CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect jdk.internal.module.Checks::isTypeName
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=776/0x308}

308     B48: #	out( B67 B49 ) &lt;- in( B47 )  Freq: 0.986848
        # Block is sole successor of call
308 +   beq  R10, zr, B67	#@cmpI_reg_imm0_branch  P=0.001545 C=10357.000000

30c     B49: #	out( B93 B50 ) &lt;- in( B48 )  Freq: 0.985324
30c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
30c     ld  R10, [R23, #288]	# ptr, #@loadP
310 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
310     ld  R7, [R23, #304]	# ptr, #@loadP
314 +   addi  R28, R10, #16	# ptr, #@addP_reg_imm
318 +   bgeu  R28, R7, B93	#@cmpP_branch  P=0.000100 C=-1.000000

31c     B50: #	out( B51 ) &lt;- in( B49 )  Freq: 0.985225
31c +   li R7, #1	# long, #@loadConL
320 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
320     sd  R28, [R23, #288]	# ptr, #@storeP
324 +   sd  R7, [R10]	# long, #@storeL
328 +   mv  R7, narrowklass: precise klass java/util/Optional: 0x00000040d08851b0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
338 +   sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
33c +   sw  zr, [R10, #12]	# int, #@storeimmI0

340     B51: #	out( B52 ) &lt;- in( B94 B50 )  Freq: 0.985324
340 +   encode_heap_oop  R28, R8	#@encodeHeapOop
344     
344 +   # checkcastPP of R10, #@checkCastPP
344     sw  R28, [R10, #12]	# compressed ptr, #@storeN ! Field: java/util/Optional.value
348 +   #@membar_release
	fence iorw ow

34c     B52: #	out( N1413 ) &lt;- in( B51 B67 )  Freq: 0.999902
34c     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
364 +   ret	// return register, #@Ret

368     B53: #	out( B121 B54 ) &lt;- in( B22 )  Freq: 0.0130547
368 +   spill [sp, #8] -&gt; R7	# spill size = 64
36c +   lwu  R28, [R7, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
370 +   #@membar_acquire
	fence ir iorw
374 +   decode_heap_oop  R8, R28	#@decodeHeapOop
378 +   bne   R8, zr, B121	#@cmpP_imm0_branch  P=0.000000 C=10534.000000

37c     B54: #	out( B102 B55 ) &lt;- in( B53 )  Freq: 0.0130547
37c +   spill [sp, #8] -&gt; R28	# spill size = 64
380 +   lwu  R29, [R28, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
384 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
384     ld  R10, [R23, #288]	# ptr, #@loadP
388 +   lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
38c +   decode_heap_oop  R8, R29	#@decodeHeapOop
390 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
390     ld  R28, [R23, #304]	# ptr, #@loadP
394 +   addi  R30, R10, #24	# ptr, #@addP_reg_imm
398 +   decode_heap_oop  R29, R7	#@decodeHeapOop
39c +   bgeu  R30, R28, B102	#@cmpP_branch  P=0.000100 C=-1.000000

3a0     B55: #	out( B56 ) &lt;- in( B54 )  Freq: 0.0130534
3a0 +   li R7, #1	# long, #@loadConL
3a4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3a4     sd  R30, [R23, #288]	# ptr, #@storeP
3a8 +   sd  R7, [R10]	# long, #@storeL
3ac +   sw  R31, [R10, #8]	# compressed klass ptr, #@storeNKlass
3b0 +   sw  zr, [R10, #12]	# int, #@storeimmI0
3b4 +   sd  zr, [R10, #16]	# long, #@storeimmL0

3b8     B56: #	out( B132 B57 ) &lt;- in( B103 B55 )  Freq: 0.0130547
3b8     
3b8 +   MEMBAR-store-store	#@membar_storestore
3bc +   spill R10 -&gt; R7	# spill size = 64
3c0 +   # checkcastPP of R7, #@checkCastPP
3c0     lwu  R14, [R29, #12]	# range, #@loadRange
3c4     NullCheck R29

3c4     B57: #	out( B144 B58 ) &lt;- in( B56 )  Freq: 0.0130547
3c4 +   spill R7 -&gt; [sp, #16]	# spill size = 64
3c8 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
3d0 +   spill [sp, #16] -&gt; R11	# spill size = 64
3d4 +   li R13, #0	# int, #@loadConI
3d8     spill R29 -&gt; R12	# spill size = 64
3dc +   mv  R15, sun/nio/cs/UTF_8:exact *	# ptr, #@loadConP
3f4     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.String::&lt;init&gt;
        # java.lang.String::&lt;init&gt; @ bci:6 (line 1380) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.Util::toString @ bci:8 (line 63) L[0]=_ STK[0]=sp + #16
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=sp + #0 STK[0]=sp + #0 STK[1]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:35 (line 747) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=1016/0x3f8}

3f8     B58: #	out( B120 B59 ) &lt;- in( B57 )  Freq: 0.0130544
        # Block is sole successor of call
3f8 +   beq   R8, zr, B120	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

3fc     B59: #	out( B95 B60 ) &lt;- in( B58 )  Freq: 0.0130544
3fc +   #@membar_release
	fence iorw ow
400 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
400     lb  R7, [R23, #56]	# byte, #@loadB
404 +   bne  R7, zr, B95	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

408     B60: #	out( B61 ) &lt;- in( B59 )  Freq: 0.0130414
408 +   spill [sp, #0] -&gt; R9	# spill size = 64

40c     B61: #	out( B63 B62 ) &lt;- in( B122 B97 B95 B60 )  Freq: 0.0130544
40c +   mv  R28, R9	# ptr -&gt; long, #@castP2X
410     spill [sp, #16] -&gt; R29	# spill size = 64
414 +   mv  R7, R29	# ptr -&gt; long, #@castP2X
418 +   xorr  R7, R7, R28	#@xorL_reg_reg
41c +   encode_heap_oop  R30, R29	#@encodeHeapOop
420 +   srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
424 +   sw  R30, [R9, #24]	# compressed ptr, #@storeN ! Field: volatile sun/nio/fs/UnixPath.stringValue
428 +   beq  R7, zr, B63	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

42c     B62: #	out( B98 B63 ) &lt;- in( B61 )  Freq: 0.0130414
42c +   srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
430 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
43c +   add R10, R28, R7	# ptr, #@addP_reg_reg
440 +   lb  R7, [R10]	# byte, #@loadB
444 +   li R29, #4	# int, #@loadConI
448 +   bne  R7, R29, B98	#@cmpI_branch  P=0.001000 C=-1.000000

44c     B63: #	out( B133 B64 ) &lt;- in( B100 B101 B98 B62 B61 )  Freq: 0.0130544
44c +   #@membar_volatile
	fence iorw iorw
450 +   lwu  R28, [R9, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
454 +   #@membar_acquire
	fence ir iorw
458 +   decode_heap_oop  R8, R28	#@decodeHeapOop
45c     lwu  R7, [R8, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
460     NullCheck R8

460     B64: #	out( B134 B65 ) &lt;- in( B63 )  Freq: 0.0130544
460 +   decode_heap_oop  R7, R7	#@decodeHeapOop
464     lwu  R28, [R7, #12]	# range, #@loadRange
468     NullCheck R7

468     B65: #	out( B143 B66 ) &lt;- in( B64 )  Freq: 0.0130544
468 +   lb  R7, [R8, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
46c +   sraw  R28, R28, R7	#@rShiftI_reg_reg
470 +   addiw  R13, R28, #-6	#@addI_reg_imm
474 +   mv  R12, java/lang/String:exact *	# ptr, #@loadConP
48c     spill R8 -&gt; R11	# spill size = 64
490     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.String::startsWith
        # java.lang.String::endsWith @ bci:11 (line 2310) L[0]=_ L[1]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:47 (line 748) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=1172/0x494}

494     B66: #	out( B75 B67 ) &lt;- in( B65 )  Freq: 0.0130541
        # Block is sole successor of call
494 +   bne  R10, zr, B75	#@cmpI_reg_imm0_branch  P=0.109489 C=137.000000

498     B67: #	out( B52 ) &lt;- in( B48 B76 B66 )  Freq: 0.0145786
498 +   mv  R10, java/util/Optional:exact *	# ptr, #@loadConP
4b0 +   j  B52	#@branch

4b4     B68: #	out( B135 B69 ) &lt;- in( B8 )  Freq: 0.00148835
4b4     lwu  R7, [R31, #12]	# range, #@loadRange
4b8     NullCheck R31

4b8     B69: #	out( B73 B70 ) &lt;- in( B68 )  Freq: 0.00148835
4b8 +   bleu  R7, zr, B73	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.500000 C=-1.000000

4bc     B70: #	out( B73 B71 ) &lt;- in( B69 )  Freq: 0.000744174
4bc +   lb  R28, [R31, #16]	# byte, #@loadB
4c0 +   li R7, #47	# int, #@loadConI
4c4 +   bne  R28, R7, B73	#@cmpI_branch  P=0.900000 C=-1.000000

4c8     B71: #	out( B136 B72 ) &lt;- in( B70 )  Freq: 7.44174e-05
4c8 +   spill [sp, #8] -&gt; R7	# spill size = 64
4cc +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
4d0 +   decode_heap_oop  R7, R28	#@decodeHeapOop
4d4     lwu  R7, [R7, #24]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileSystem.rootDirectory
4d8     NullCheck R7

4d8     B72: #	out( B74 ) &lt;- in( B71 )  Freq: 7.44173e-05
4d8 +   decode_heap_oop  R7, R7	#@decodeHeapOop
4dc +   j  B74	#@branch

4e0     B73: #	out( B74 ) &lt;- in( B70 B69 )  Freq: 0.00141393
4e0 +   mv  R7, NULL	# NULL ptr, #@loadConP0

4e4     B74: #	out( B22 ) &lt;- in( B72 B73 )  Freq: 0.00148835
4e4     spill R7 -&gt; R12	# spill size = 64
4e8 +   j  B22	#@branch

4ec     B75: #	out( B142 B76 ) &lt;- in( B66 )  Freq: 0.00142929
4ec +   mv  R12, java/lang/String:exact *	# ptr, #@loadConP
504     spill R8 -&gt; R11	# spill size = 64
508     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.String::equals
        # jdk.internal.module.ModulePath::toPackageName @ bci:57 (line 748) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=1292/0x50c}

50c     B76: #	out( B67 B77 ) &lt;- in( B75 )  Freq: 0.00142926
        # Block is sole successor of call
50c +   bne  R10, zr, B67	#@cmpI_reg_imm0_branch  P=0.999999 C=-1.000000

510     B77: #	out( N1413 ) &lt;- in( B76 )  Freq: 1.44824e-09
510 +   li R11, #238	# int, #@loadConI
514     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos; index=&apos;238&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:63 (line 749) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=1304/0x518}
518     #@ShouldNotReachHere

524     B78: #	out( B19 ) &lt;- in( B17 )  Freq: 0.000998483
524 +   addw  R30, R8, zr	#@convI2L_reg_reg
528 +   addi  R28, R30, #15	#@addL_reg_imm
52c +   srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
530 +   andi  R28, R28, #-8	#@andL_reg_imm
534 +   add R28, R9, R28	# ptr, #@addP_reg_reg
538 +   sub  R29, R7, R29	#@subL_reg_reg
53c     ClearArray R29, R28	#@clearArray_reg_reg
594 +   addi  R12, R30, #-1	#@addL_reg_imm
598     CALL, runtime leaf nofp 0x000000401396cf00	#@CallLeafNoFPDirect arrayof_jbyte_disjoint_arraycopy
        No JVM State Info
        # 
59c +   j  B19	#@branch

5a0     B79: #	out( B32 B80 ) &lt;- in( B30 )  Freq: 0.000986882
5a0 +   spill [sp, #8] -&gt; R9	# spill size = 64
5a4 +   lwu  R28, [R9, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
5a8 +   decode_heap_oop  R10, R28	#@decodeHeapOop
5ac +   beq   R10, zr, B32	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

5b0     B80: #	out( B116 B81 ) &lt;- in( B79 )  Freq: 0.000493441
5b0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5b0     ld  R7, [R23, #32]	# int, #@loadL
5b4 +   beq  R7, zr, B116	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

5b8     B81: #	out( B32 ) &lt;- in( B80 )  Freq: 0.000492947
5b8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5b8     ld  R28, [R23, #48]	# ptr, #@loadP
5bc +   add R28, R28, R7	# ptr, #@addP_reg_reg
5c0 +   addi  R7, R7, #-8	#@addL_reg_imm
5c4 +   sd  R10, [R28, #-8]	# ptr, #@storeP
5c8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5c8     sd  R7, [R23, #32]	# long, #@storeL
5cc +   j  B32	#@branch

5d0     B82: #	out( B34 B83 ) &lt;- in( B33 )  Freq: 0.000985908
5d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5d0     ld  R7, [R23, #64]	# int, #@loadL
5d4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5d4     ld  R28, [R23, #80]	# ptr, #@loadP
5d8 +   #@membar_volatile
	fence iorw iorw
5dc +   lb  R30, [R10]	# byte, #@loadB
5e0 +   beq  R30, zr, B34	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

5e4     B83: #	out( B85 B84 ) &lt;- in( B82 )  Freq: 0.000492954
5e4 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
5e8 +   bne  R7, zr, B85	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

5ec     B84: #	out( B34 ) &lt;- in( B83 )  Freq: 0.000246477
5ec +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5ec     spill R23 -&gt; R11	# spill size = 64
5f0 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
620 +   j  B34	#@branch

624     B85: #	out( B34 ) &lt;- in( B83 )  Freq: 0.000246477
624 +   add R28, R28, R7	# ptr, #@addP_reg_reg
628 +   addi  R7, R7, #-8	#@addL_reg_imm
62c +   sd  R10, [R28, #-8]	# ptr, #@storeP
630 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
630     sd  R7, [R23, #64]	# long, #@storeL
634 +   j  B34	#@branch

638     B86: #	out( B47 ) &lt;- in( B45 )  Freq: 0.000734274
638 +   spill [sp, #8] -&gt; R8	# spill size = 64
63c +   j  B47	#@branch

640     B87: #	out( B140 B88 ) &lt;- in( B19 )  Freq: 9.9865e-05
640 +   spill R19 -&gt; [sp, #24]	# spill size = 32
644 +   spill R9 -&gt; [sp, #16]	# spill size = 64
648 +   spill [sp, #8] -&gt; R8	# spill size = 64
64c +   mv  R11, precise klass sun/nio/fs/UnixPath: 0x00000040d0885ea0:Constant:exact *	# ptr, #@loadConP
664     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixPath::getParent @ bci:51 (line 290) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #16
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=R8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=NarrowOop off=1640/0x668}

668     B88: #	out( B21 ) &lt;- in( B87 )  Freq: 9.9863e-05
        # Block is sole successor of call
668 +   spill [sp, #24] -&gt; R19	# spill size = 32
66c +   spill R10 -&gt; R12	# spill size = 64
670 +   j  B21	#@branch

674     B89: #	out( B141 B90 ) &lt;- in( B13 B14 )  Freq: 0.000100877
674 +   spill R12 -&gt; [sp, #40]	# spill size = 64
678 +   spill R10 -&gt; [sp, #32]	# spill size = 64
67c +   spill R31 -&gt; [sp, #24]	# spill size = 64
680 +   spill R28 -&gt; [sp, #16]	# spill size = 32
684 +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
69c     spill R28 -&gt; R12	# spill size = 32
6a0     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=sp + #8 L[1]=_ L[2]=sp + #16 L[3]=_
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=sp + #8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {[0]=Oop [8]=Oop [24]=Oop off=1700/0x6a4}

6a4     B90: #	out( B16 ) &lt;- in( B89 )  Freq: 0.000100875
        # Block is sole successor of call
6a4 +   spill R10 -&gt; R9	# spill size = 64
6a8 +   spill [sp, #16] -&gt; R28	# spill size = 32
6ac +   spill [sp, #24] -&gt; R31	# spill size = 64
6b0 +   spill [sp, #32] -&gt; R10	# spill size = 64
6b4 +   spill [sp, #40] -&gt; R12	# spill size = 64
6b8 +   j  B16	#@branch

6bc     B91: #	out( B139 B92 ) &lt;- in( B25 )  Freq: 9.8708e-05
6bc +   spill R13 -&gt; [sp, #16]	# spill size = 64
6c0 +   spill R12 -&gt; [sp, #8]	# spill size = 64
6c4 +   mv  R11, precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# ptr, #@loadConP
6dc     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.Util::toString @ bci:0 (line 63) L[0]=sp + #16
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=sp + #8 STK[0]=sp + #8 STK[1]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=1760/0x6e0}

6e0     B92: #	out( B27 ) &lt;- in( B91 )  Freq: 9.8706e-05
        # Block is sole successor of call
6e0 +   spill [sp, #8] -&gt; R12	# spill size = 64
6e4 +   spill [sp, #16] -&gt; R13	# spill size = 64
6e8 +   j  B27	#@branch

6ec     B93: #	out( B138 B94 ) &lt;- in( B49 )  Freq: 9.85487e-05
6ec +   mv  R11, precise klass java/util/Optional: 0x00000040d08851b0:Constant:exact *	# ptr, #@loadConP
704     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.Optional::of @ bci:0 (line 113) L[0]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:125 (line 758) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop off=1800/0x708}

708     B94: #	out( B51 ) &lt;- in( B93 )  Freq: 9.85467e-05
        # Block is sole successor of call
708 +   j  B51	#@branch

70c     B95: #	out( B61 B96 ) &lt;- in( B59 )  Freq: 1.30543e-05
70c +   spill [sp, #0] -&gt; R9	# spill size = 64
710 +   lwu  R28, [R9, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
714 +   decode_heap_oop  R10, R28	#@decodeHeapOop
718 +   beq   R10, zr, B61	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

71c     B96: #	out( B122 B97 ) &lt;- in( B95 )  Freq: 6.52713e-06
71c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
71c     ld  R7, [R23, #32]	# int, #@loadL
720 +   beq  R7, zr, B122	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

724     B97: #	out( B61 ) &lt;- in( B96 )  Freq: 6.5206e-06
724 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
724     ld  R28, [R23, #48]	# ptr, #@loadP
728 +   add R28, R28, R7	# ptr, #@addP_reg_reg
72c +   addi  R7, R7, #-8	#@addL_reg_imm
730 +   sd  R10, [R28, #-8]	# ptr, #@storeP
734 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
734     sd  R7, [R23, #32]	# long, #@storeL
738 +   j  B61	#@branch

73c     B98: #	out( B63 B99 ) &lt;- in( B62 )  Freq: 1.30414e-05
73c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
73c     ld  R7, [R23, #64]	# int, #@loadL
740 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
740     ld  R28, [R23, #80]	# ptr, #@loadP
744 +   #@membar_volatile
	fence iorw iorw
748 +   lb  R30, [R10]	# byte, #@loadB
74c +   beq  R30, zr, B63	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

750     B99: #	out( B101 B100 ) &lt;- in( B98 )  Freq: 6.52069e-06
750 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
754 +   bne  R7, zr, B101	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

758     B100: #	out( B63 ) &lt;- in( B99 )  Freq: 3.26034e-06
758 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
758     spill R23 -&gt; R11	# spill size = 64
75c +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
78c +   j  B63	#@branch

790     B101: #	out( B63 ) &lt;- in( B99 )  Freq: 3.26034e-06
790 +   add R28, R28, R7	# ptr, #@addP_reg_reg
794 +   addi  R7, R7, #-8	#@addL_reg_imm
798 +   sd  R10, [R28, #-8]	# ptr, #@storeP
79c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
79c     sd  R7, [R23, #64]	# long, #@storeL
7a0 +   j  B63	#@branch

7a4     B102: #	out( B137 B103 ) &lt;- in( B54 )  Freq: 1.30569e-06
7a4 +   spill R29 -&gt; [sp, #16]	# spill size = 64
7a8 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
7b0 +   mv  R11, precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# ptr, #@loadConP
7c8     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.Util::toString @ bci:0 (line 63) L[0]=sp + #16
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=sp + #0 STK[0]=sp + #0 STK[1]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:35 (line 747) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=1996/0x7cc}

7cc     B103: #	out( B56 ) &lt;- in( B102 )  Freq: 1.30566e-06
        # Block is sole successor of call
7cc +   spill [sp, #16] -&gt; R29	# spill size = 64
7d0 +   j  B56	#@branch

7d4     B104: #	out( N1413 ) &lt;- in( B7 )  Freq: 1.01325e-06
7d4 +   li R11, #-28	# int, #@loadConI
7d8     spill R31 -&gt; [sp, #24]	# spill size = 64
7dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:23 (line 283) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #24 STK[1]=R8
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=sp + #8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {[0]=Oop [8]=Oop [24]=Oop off=2016/0x7e0}
7e0     #@ShouldNotReachHere

7ec     B105: #	out( B11 ) &lt;- in( B9 )  Freq: 1.01174e-06
7ec +   addw  R7, R28, zr	#@convI2L_reg_reg
7f0 +   j  B11	#@branch

7f4     B106: #	out( B19 ) &lt;- in( B16 )  Freq: 1.01174e-06
7f4 +   spill R11 -&gt; R28	# spill size = 64
7f8 +   addi  R29, R7, #-2	#@addL_reg_imm
7fc     ClearArray R29, R28	#@clearArray_reg_reg
854     
854 +   j  B19	#@branch

858     B107: #	out( N1413 ) &lt;- in( B29 )  Freq: 1e-06
858 +   li R11, #-10	# int, #@loadConI
85c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::toString @ bci:19 (line 757) L[0]=_ STK[0]=_ STK[1]=#NULL STK[2]=sp + #16
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {[16]=Oop off=2144/0x860}
860     #@ShouldNotReachHere

86c     B108: #	out( N1413 ) &lt;- in( B2 )  Freq: 9.99999e-07
86c +   li R11, #-34	# int, #@loadConI
870     spill R12 -&gt; [sp, #8]	# spill size = 64
874     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=sp + #8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #8
        # OopMap {[0]=Oop [8]=Oop off=2168/0x878}
878     #@ShouldNotReachHere

884     B109: #	out( N1413 ) &lt;- in( B12 )  Freq: 9.98485e-07
884 +   li R11, #-52	# int, #@loadConI
888     spill [sp, #0] -&gt; R8	# spill size = 64
88c +   spill R28 -&gt; [sp, #20]	# spill size = 32
890     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=sp + #8 L[1]=_ L[2]=sp + #20 L[3]=_ STK[0]=sp + #20
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=sp + #8 L[2]=R8 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [8]=Oop off=2196/0x894}
894     #@ShouldNotReachHere

8a0     B110: #	out( N1413 ) &lt;- in( B23 )  Freq: 9.86918e-07
8a0 +   spill [sp, #0] -&gt; R8	# spill size = 64
8a4 +   li R11, #-34	# int, #@loadConI
8a8     spill R12 -&gt; [sp, #0]	# spill size = 64
8ac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #0
        # OopMap {fp=Oop [0]=Oop off=2224/0x8b0}
8b0     #@ShouldNotReachHere

8bc     B111: #	out( N1413 ) &lt;- in( B24 )  Freq: 4.93458e-07
8bc +   li R11, #-187	# int, #@loadConI
8c0     spill R12 -&gt; [sp, #8]	# spill size = 64
8c4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::toString @ bci:4 (line 756) L[0]=sp + #8 STK[0]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=2248/0x8c8}
8c8     #@ShouldNotReachHere

8d4     B112: #	out( N1413 ) &lt;- in( B38 )  Freq: 4.93445e-07
8d4 +   li R11, #-187	# int, #@loadConI
8d8     spill R7 -&gt; [sp, #16]	# spill size = 32
8dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:36 (line 2959) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=#Ptr0x00000040d0888be0 L[5]=sp + #16 L[6]=R8 L[7]=#1 L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {[0]=Oop [8]=Oop off=2272/0x8e0}
8e0     #@ShouldNotReachHere

8ec     B113: #	out( N1413 ) &lt;- in( B39 )  Freq: 4.93445e-07
8ec +   li R11, #-187	# int, #@loadConI
8f0     spill R7 -&gt; [sp, #16]	# spill size = 32
8f4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:42 (line 2960) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=#Ptr0x00000040d0888be0 L[5]=sp + #16 L[6]=R8 L[7]=#1 L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=R8 STK[1]=#1
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {[0]=Oop [8]=Oop off=2296/0x8f8}
8f8     #@ShouldNotReachHere

904     B114: #	out( N1413 ) &lt;- in( B40 )  Freq: 4.93445e-07
904 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
90c +   li R11, #-187	# int, #@loadConI
910     spill R28 -&gt; R8	# spill size = 64
914 +   spill R13 -&gt; [sp, #8]	# spill size = 32
918     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #8
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=R8 L[1]=#0
        # java.lang.String::replace @ bci:54 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=#Ptr0x00000040d0888be0 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=sp + #0
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=2332/0x91c}
91c     #@ShouldNotReachHere

928     B115: #	out( N1413 ) &lt;- in( B43 )  Freq: 4.93444e-07
928 +   li R11, #-187	# int, #@loadConI
92c     spill [sp, #8] -&gt; R8	# spill size = 64
930 +   spill R12 -&gt; [sp, #0]	# spill size = 32
934 +   spill R31 -&gt; [sp, #4]	# spill size = 32
938     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #4
        # java.lang.String::replace @ bci:6 (line 2801) L[0]=R8 L[1]=sp + #0 L[2]=#46 L[3]=_
        # java.lang.String::replace @ bci:63 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop off=2364/0x93c}
93c     #@ShouldNotReachHere

948     B116: #	out( B32 ) &lt;- in( B80 )  Freq: 4.93435e-07
948 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
948     spill R23 -&gt; R11	# spill size = 64
94c +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
97c +   j  B32	#@branch

980     B117: #	out( N1413 ) &lt;- in( B5 )  Freq: 4.76826e-07
980 +   li R11, #-187	# int, #@loadConI
984     spill [sp, #0] -&gt; R8	# spill size = 64
988 +   spill R30 -&gt; [sp, #20]	# spill size = 32
98c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:11 (line 279) L[0]=sp + #8 L[1]=sp + #20 L[2]=_ L[3]=_ STK[0]=sp + #20
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=sp + #8 L[2]=R8 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [8]=Oop off=2448/0x990}
990     #@ShouldNotReachHere

99c     B118: #	out( N1413 ) &lt;- in( B41 )  Freq: 4.70585e-07
99c +   spill [sp, #8] -&gt; R8	# spill size = 64
9a0 +   li R11, #-187	# int, #@loadConI
9a4     spill R30 -&gt; [sp, #0]	# spill size = 64
9a8 +   spill R12 -&gt; [sp, #8]	# spill size = 32
9ac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:7 (line 47) L[0]=sp + #0 L[1]=#0 STK[0]=#0 STK[1]=sp + #8
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.String::replace @ bci:54 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=#Ptr0x00000040d0888be0 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=2480/0x9b0}
9b0     #@ShouldNotReachHere

9bc     B119: #	out( N1413 ) &lt;- in( B42 )  Freq: 4.70585e-07
9bc +   li R11, #-187	# int, #@loadConI
9c0     spill [sp, #8] -&gt; R8	# spill size = 64
9c4 +   spill R12 -&gt; [sp, #4]	# spill size = 32
9c8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:2 (line 2800) L[0]=R8 L[1]=sp + #4 L[2]=#46 L[3]=_ STK[0]=sp + #4 STK[1]=#46
        # java.lang.String::replace @ bci:63 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop off=2508/0x9cc}
9cc     #@ShouldNotReachHere

9d8     B120: #	out( N1413 ) &lt;- in( B58 )  Freq: 1.32278e-08
9d8 +   li R11, #-10	# int, #@loadConI
9dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::toString @ bci:19 (line 757) L[0]=_ STK[0]=_ STK[1]=#NULL STK[2]=sp + #16
        # jdk.internal.module.ModulePath::toPackageName @ bci:35 (line 747) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {[16]=Oop off=2528/0x9e0}
9e0     #@ShouldNotReachHere

9ec     B121: #	out( N1413 ) &lt;- in( B53 )  Freq: 6.52736e-09
9ec +   li R11, #-187	# int, #@loadConI
9f0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::toString @ bci:4 (line 756) L[0]=sp + #8 STK[0]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:35 (line 747) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [8]=Oop off=2548/0x9f4}
9f4     #@ShouldNotReachHere

a00     B122: #	out( B61 ) &lt;- in( B96 )  Freq: 6.52705e-09
a00 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
a00     spill R23 -&gt; R11	# spill size = 64
a04 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
a34 +   j  B61	#@branch

a38     B123: #	out( N1413 ) &lt;- in( B1 )  Freq: 1.01328e-06
a38 +   li R11, #-10	# int, #@loadConI
a3c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # OopMap {off=2624/0xa40}
a40     #@ShouldNotReachHere

a4c     B124: #	out( N1413 ) &lt;- in( B4 )  Freq: 1.01326e-06
a4c +   li R11, #-10	# int, #@loadConI
a50     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:8 (line 278) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=2644/0xa54}
a54     #@ShouldNotReachHere

a60     B125: #	out( N1413 ) &lt;- in( B6 )  Freq: 1.01326e-06
a60 +   li R11, #-10	# int, #@loadConI
a64     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:23 (line 283) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=2664/0xa68}
a68     #@ShouldNotReachHere

a74     B126: #	out( N1413 ) &lt;- in( B11 )  Freq: 1.01174e-06
a74 +   li R11, #-12	# int, #@loadConI
a78     spill [sp, #0] -&gt; R8	# spill size = 64
a7c +   spill R28 -&gt; [sp, #20]	# spill size = 32
a80     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=sp + #8 L[1]=_ L[2]=sp + #20 L[3]=_ STK[0]=sp + #20
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=sp + #8 L[2]=R8 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [8]=Oop off=2692/0xa84}
a84     #@ShouldNotReachHere

a90     B127: #	out( N1413 ) &lt;- in( B27 )  Freq: 1.00002e-06
a90 +   li R11, #-10	# int, #@loadConI
a94     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::&lt;init&gt; @ bci:4 (line 1380) L[0]=_ L[1]=_ L[2]=_ STK[0]=_ STK[1]=_ STK[2]=_ STK[3]=#NULL
        # sun.nio.fs.Util::toString @ bci:8 (line 63) L[0]=_ STK[0]=_
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=_ STK[0]=_ STK[1]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=2712/0xa98}
a98     #@ShouldNotReachHere

aa4     B128: #	out( N1413 ) &lt;- in( B34 )  Freq: 9.99999e-07
aa4 +   li R11, #-10	# int, #@loadConI
aa8     spill [sp, #0] -&gt; R8	# spill size = 64
aac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL STK[1]=R8 STK[2]=#Ptr0x00000040d0888be0
        # OopMap {fp=Oop off=2736/0xab0}
ab0     #@ShouldNotReachHere

abc     B129: #	out( N1413 ) &lt;- in( B35 )  Freq: 9.99998e-07
abc +   li R11, #-10	# int, #@loadConI
ac0     spill [sp, #8] -&gt; R8	# spill size = 64
ac4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::replace @ bci:1 (line 2953) L[0]=R8 L[1]=_ L[2]=#Ptr0x00000040d0888be0 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=#NULL
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop off=2760/0xac8}
ac8     #@ShouldNotReachHere

ad4     B130: #	out( N1413 ) &lt;- in( B36 )  Freq: 9.99997e-07
ad4 +   li R11, #-10	# int, #@loadConI
ad8     spill R28 -&gt; R8	# spill size = 64
adc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::replace @ bci:16 (line 2955) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=R8 L[4]=#Ptr0x00000040d0888be0 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [8]=Oop off=2784/0xae0}
ae0     #@ShouldNotReachHere

aec     B131: #	out( N1413 ) &lt;- in( B37 )  Freq: 9.99996e-07
aec +   li R11, #-10	# int, #@loadConI
af0     spill R28 -&gt; R8	# spill size = 64
af4 +   spill R29 -&gt; [sp, #0]	# spill size = 64
af8 +   spill R7 -&gt; [sp, #8]	# spill size = 32
afc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::replace @ bci:22 (line 2956) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=R8 L[4]=#Ptr0x00000040d0888be0 L[5]=sp + #8 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=2816/0xb00}
b00     #@ShouldNotReachHere

b0c     B132: #	out( N1413 ) &lt;- in( B56 )  Freq: 1.32281e-08
b0c +   li R11, #-10	# int, #@loadConI
b10     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::&lt;init&gt; @ bci:4 (line 1380) L[0]=_ L[1]=_ L[2]=_ STK[0]=_ STK[1]=_ STK[2]=_ STK[3]=#NULL
        # sun.nio.fs.Util::toString @ bci:8 (line 63) L[0]=_ STK[0]=_
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=_ STK[0]=_ STK[1]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:35 (line 747) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=2836/0xb14}
b14     #@ShouldNotReachHere

b20     B133: #	out( N1413 ) &lt;- in( B63 )  Freq: 1.32278e-08
b20 +   li R11, #-10	# int, #@loadConI
b24     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:47 (line 748) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL STK[1]=#Ptr0x00000040d0889c40
        # OopMap {off=2856/0xb28}
b28     #@ShouldNotReachHere

b34     B134: #	out( N1413 ) &lt;- in( B64 )  Freq: 1.32278e-08
b34 +   li R11, #-10	# int, #@loadConI
b38     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::endsWith @ bci:3 (line 2310) L[0]=_ L[1]=_ STK[0]=_ STK[1]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:47 (line 748) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=2876/0xb3c}
b3c     #@ShouldNotReachHere

b48     B135: #	out( N1413 ) &lt;- in( B68 )  Freq: 1.50811e-09
b48 +   li R11, #-10	# int, #@loadConI
b4c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getRoot @ bci:4 (line 246) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::getParent @ bci:32 (line 286) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=2896/0xb50}
b50     #@ShouldNotReachHere

b5c     B136: #	out( N1413 ) &lt;- in( B71 )  Freq: 7.54056e-11
b5c +   li R11, #-10	# int, #@loadConI
b60     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getRoot @ bci:23 (line 247) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::getParent @ bci:32 (line 286) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=2916/0xb64}
b64     #@ShouldNotReachHere

b70     B137: #	out( B145 ) &lt;- in( B102 )  Freq: 1.30569e-11
b70      -- 	// exception oop; no code emitted, #@CreateException
b70 +   j  B145	#@branch

b74     B138: #	out( B152 ) &lt;- in( B93 )  Freq: 9.85487e-10
b74      -- 	// exception oop; no code emitted, #@CreateException
b74 +   spill R10 -&gt; R11	# spill size = 64
b78 +   j  B152	#@branch

b7c     B139: #	out( B149 ) &lt;- in( B91 )  Freq: 9.8708e-10
b7c      -- 	// exception oop; no code emitted, #@CreateException
b7c +   j  B149	#@branch

b80     B140: #	out( B147 ) &lt;- in( B87 )  Freq: 9.9865e-10
b80      -- 	// exception oop; no code emitted, #@CreateException
b80 +   j  B147	#@branch

b84     B141: #	out( B147 ) &lt;- in( B89 )  Freq: 1.00877e-09
b84      -- 	// exception oop; no code emitted, #@CreateException
b84 +   j  B147	#@branch

b88     B142: #	out( B152 ) &lt;- in( B75 )  Freq: 1.42929e-08
b88      -- 	// exception oop; no code emitted, #@CreateException
b88 +   spill R10 -&gt; R11	# spill size = 64
b8c +   j  B152	#@branch

b90     B143: #	out( B152 ) &lt;- in( B65 )  Freq: 1.30544e-07
b90      -- 	// exception oop; no code emitted, #@CreateException
b90 +   spill R10 -&gt; R11	# spill size = 64
b94 +   j  B152	#@branch

b98     B144: #	out( B145 ) &lt;- in( B57 )  Freq: 1.30547e-07
b98      -- 	// exception oop; no code emitted, #@CreateException

b98     B145: #	out( B152 ) &lt;- in( B137 B144 )  Freq: 1.3056e-07
b98 +   spill R10 -&gt; R11	# spill size = 64
b9c +   j  B152	#@branch

ba0     B146: #	out( B147 ) &lt;- in( B3 )  Freq: 9.99998e-06
ba0      -- 	// exception oop; no code emitted, #@CreateException

ba0     B147: #	out( B152 ) &lt;- in( B146 B141 B140 )  Freq: 1.0002e-05
ba0 +   spill R10 -&gt; R11	# spill size = 64
ba4 +   j  B152	#@branch

ba8     B148: #	out( B149 ) &lt;- in( B28 )  Freq: 9.86915e-06
ba8      -- 	// exception oop; no code emitted, #@CreateException

ba8     B149: #	out( B152 ) &lt;- in( B139 B148 )  Freq: 9.87014e-06
ba8 +   spill R10 -&gt; R11	# spill size = 64
bac +   j  B152	#@branch

bb0     B150: #	out( B152 ) &lt;- in( B44 )  Freq: 9.86888e-06
bb0      -- 	// exception oop; no code emitted, #@CreateException
bb0 +   spill R10 -&gt; R11	# spill size = 64
bb4 +   j  B152	#@branch

bb8     B151: #	out( B152 ) &lt;- in( B47 )  Freq: 9.86868e-06
bb8      -- 	// exception oop; no code emitted, #@CreateException
bb8 +   spill R10 -&gt; R11	# spill size = 64

bbc     B152: #	out( N1413 ) &lt;- in( B147 B145 B143 B142 B149 B150 B151 B138 )  Freq: 3.98861e-05
bbc     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
bc8 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='472'>
----------------------- MetaData before Compile_id = 472 ------------------------
{method}
 - this oop:          0x00000040961a1da0
 - method holder:     &apos;java/util/HashMap&apos;
 - constants:         0x000000409619f4e0 constant pool [610] {0x000000409619f4e0} for &apos;java/util/HashMap&apos; cache=0x00000040961a4fd8
 - access:            0xc1000010  final 
 - name:              &apos;putVal&apos;
 - signature:         &apos;(ILjava/lang/Object;Ljava/lang/Object;ZZ)Ljava/lang/Object;&apos;
 - max stack:         8
 - max locals:        13
 - size of params:    6
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400832ef00: 0xbabbaa i2c: 0x0000004013930340 c2i: 0x0000004013930398 c2iUV: 0x0000004013930364
 - compiled entry     0x000000400c502880
 - code size:         300
 - code start:        0x00000040961a1b70
 - code end (excl):   0x00000040961a1c9c
 - method data:       0x0000004096485328
 - checked ex length: 0
 - linenumber start:  0x00000040961a1c9c
 - localvar length:   18
 - localvar start:    0x00000040961a1cc4
 - compiled code: nmethod  19686  172       3       java.util.HashMap::putVal (300 bytes)

------------------------ OptoAssembly for Compile_id = 472 -----------------------
#
#  java/lang/Object * ( java/util/HashMap:NotNull *, int, java/lang/Object *, java/lang/Object *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/HashMap:NotNull *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3:c_rarg3   : parm 2: java/lang/Object *
#r018 c_rarg4:c_rarg4   : parm 3: java/lang/Object *
#r020 c_rarg5   : parm 4: int
#r022 c_rarg6   : parm 5: int
# -- Old sp -- Framesize: 112 --
#r263 sp+108: in_preserve
#r262 sp+104: return address
#r261 sp+100: in_preserve
#r260 sp+96: saved fp register
#r259 sp+92: pad2, stack alignment
#r258 sp+88: pad2, stack alignment
#r257 sp+84: Fixed slot 1
#r256 sp+80: Fixed slot 0
#r283 sp+76: spill
#r282 sp+72: spill
#r281 sp+68: spill
#r280 sp+64: spill
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1360: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B60 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=112
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #112
	
03c     lwu  R28, [R11, #36]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap.table
040 +   decode_heap_oop  R9, R28	#@decodeHeapOop
044     spill R16 -&gt; [sp, #24]	# spill size = 32
048 +   spill R15 -&gt; [sp, #28]	# spill size = 32
04c +   spill R14 -&gt; [sp, #32]	# spill size = 64
050 +   spill R13 -&gt; [sp, #16]	# spill size = 64
054 +   spill R12 -&gt; [sp, #8]	# spill size = 32
058 +   spill R11 -&gt; [sp, #0]	# spill size = 64
05c +   beq   R9, zr, B60	#@cmpP_imm0_branch  P=0.174698 C=5375.000000

060     B2: #	out( B92 B3 ) &lt;- in( B1 )  Freq: 0.825302
060 +   lwu  R7, [R9, #12]	# range, #@loadRange
064 +   bleu  R7, zr, B92	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=4436.000000

068     B3: #	out( B90 B4 ) &lt;- in( B62 B2 )  Freq: 0.999996
068 +   addiw  R28, R7, #-1	#@addI_reg_imm
06c     spill [sp, #8] -&gt; R20	# spill size = 32
070 +   andr  R12, R28, R20	#@andI_reg_reg
074 +   addw  R28, R12, zr	#@convI2L_reg_reg
078 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
07c +   add R28, R9, R28	# ptr, #@addP_reg_reg
080 +   addi  R8, R28, #16	# ptr, #@addP_reg_imm
084 +   ble  R7, zr, B90	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

088     B4: #	out( B33 B5 ) &lt;- in( B3 )  Freq: 0.999995
088 +   lwu  R28, [R8]	# loadN, compressed ptr, #@loadN
08c +   decode_heap_oop  R29, R28	#@decodeHeapOop
090     spill [sp, #16] -&gt; R28	# spill size = 64
094 +   encode_heap_oop  R30, R28	#@encodeHeapOop
098     spill [sp, #32] -&gt; R19	# spill size = 64
09c +   encode_heap_oop  R18, R19	#@encodeHeapOop
0a0 +   li R31, #1	# long, #@loadConL
0a4 +   mv  R10, narrowklass: precise klass java/util/HashMap$Node: 0x00000040d06a9190:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0b4 +   beq   R29, zr, B33	#@cmpP_imm0_branch  P=0.511070 C=5375.000000

0b8     B5: #	out( B41 B6 ) &lt;- in( B4 )  Freq: 0.488928
0b8 +   lw  R12, [R29, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
0bc +   li R7, #0	# int, #@loadConI
0c0 +   beq  R12, R20, B41	#@cmpI_branch  P=0.443515 C=2629.000000

0c4     B6: #	out( B93 B7 ) &lt;- in( B5 )  Freq: 0.272081
0c4 +   lwu  R11, [R29, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
0c8 +   lwu  R13, [R29, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0cc +   decode_heap_oop  R22, R11	#@decodeHeapOop
0d0 +   mv  R11, narrowklass: precise klass java/util/HashMap$TreeNode: 0x00000040d06ad7a0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0e0 +   beq  R13, R11, B93	#@cmpN_branch  P=0.000001 C=-1.000000

0e4     B7: #	out( B16 B8 ) &lt;- in( B6 )  Freq: 0.272081
0e4 +   bne   R22, zr, B16	#@cmpP_imm0_branch  P=0.620164 C=1706.000000

0e8     B8: #	out( B9 ) &lt;- in( B7 )  Freq: 0.103346
0e8 +   li R21, #0	# int, #@loadConI
0ec     spill R29 -&gt; R22	# spill size = 64

0f0     B9: #	out( B88 B10 ) &lt;- in( B18 B8 )  Freq: 0.120575
0f0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0f0     ld  R24, [R23, #288]	# ptr, #@loadP
0f4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0f4     ld  R7, [R23, #304]	# ptr, #@loadP
0f8 +   addi  R29, R24, #32	# ptr, #@addP_reg_imm
0fc +   bgeu  R29, R7, B88	#@cmpP_branch  P=0.000100 C=-1.000000

100     B10: #	out( B11 ) &lt;- in( B9 )  Freq: 0.120563
100 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
100     sd  R29, [R23, #288]	# ptr, #@storeP
104 +   sd  R31, [R24]	# long, #@storeL
108 +   sw  R10, [R24, #8]	# compressed klass ptr, #@storeNKlass
10c +   sd  zr, [R24, #24]	# long, #@storeimmL0

110     B11: #	out( B79 B12 ) &lt;- in( B89 B10 )  Freq: 0.120575
110 +   sw  R20, [R24, #12]	# int, #@storeI
114 +   sw  R30, [R24, #16]	# compressed ptr, #@storeN
118 +   sw  R18, [R24, #20]	# compressed ptr, #@storeN
11c     
11c +   #@membar_release
	fence iorw ow
120 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
120     lb  R28, [R23, #56]	# byte, #@loadB
124 +   # checkcastPP of R24, #@checkCastPP
124     bne  R28, zr, B79	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

128     B12: #	out( B14 B13 ) &lt;- in( B109 B81 B79 B11 )  Freq: 0.120575
128 +   mv  R7, R22	# ptr -&gt; long, #@castP2X
12c +   mv  R28, R24	# ptr -&gt; long, #@castP2X
130 +   xorr  R28, R28, R7	#@xorL_reg_reg
134 +   encode_heap_oop  R29, R24	#@encodeHeapOop
138 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
13c +   li R18, #7	# int, #@loadConI
140 +   sw  R29, [R22, #24]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.next
144 +   beq  R28, zr, B14	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

148     B13: #	out( B82 B14 ) &lt;- in( B12 )  Freq: 0.120454
148 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
14c +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
158 +   add R10, R28, R7	# ptr, #@addP_reg_reg
15c +   lb  R28, [R10]	# byte, #@loadB
160 +   li R7, #4	# int, #@loadConI
164 +   bne  R28, R7, B82	#@cmpI_branch  P=0.001000 C=-1.000000

168     B14: #	out( B39 B15 ) &lt;- in( B84 B85 B82 B13 B12 )  Freq: 0.120575
168 +   blt  R21, R18, B39	#@cmpI_branch  P=1.000000 C=648.000000

16c     B15: #	out( N1360 ) &lt;- in( B14 )  Freq: 5.74946e-08
16c +   spill [sp, #0] -&gt; R8	# spill size = 64
170 +   spill [sp, #28] -&gt; R28	# spill size = 32
174 +   spill [sp, #24] -&gt; R7	# spill size = 32
178 +   li R11, #-187	# int, #@loadConI
17c     spill R20 -&gt; [sp, #0]	# spill size = 32
180 +   spill R19 -&gt; [sp, #8]	# spill size = 64
184 +   spill R28 -&gt; [sp, #4]	# spill size = 32
188 +   spill R7 -&gt; [sp, #16]	# spill size = 32
18c +   spill R9 -&gt; [sp, #24]	# spill size = 64
190 +   spill R21 -&gt; [sp, #20]	# spill size = 32
194     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:162 (line 641) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=sp + #8 L[4]=sp + #4 L[5]=sp + #16 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=_ STK[0]=sp + #20 STK[1]=#7
        # OopMap {fp=Oop [8]=Oop [24]=Oop off=408/0x198}
198     #@ShouldNotReachHere

1a4     B16: #	out( B17 ) &lt;- in( B7 )  Freq: 0.168735
1a4 +   li R21, #0	# int, #@loadConI

1a8     B17: #	out( B20 B18 ) &lt;- in( B16 B19 ) Loop( B17-B19 inner ) Freq: 0.196865
1a8 +   lw  R11, [R22, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
1ac +   beq  R11, R20, B20	#@cmpI_branch  P=0.769594 C=1059.000000

1b0     B18: #	out( B9 B19 ) &lt;- in( B17 )  Freq: 0.0453588
1b0 +   addiw  R21, R21, #1	#@addI_reg_imm
1b4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b4     ld  R29, [R23, #920]	# ptr, #@loadP
1b8 +   lwu zr, [R29]	# Safepoint: poll for GC, #@safePoint        # java.util.HashMap::putVal @ bci:219 (line 638) L[0]=sp + #0 L[1]=R20 L[2]=R28 L[3]=R19 L[4]=sp + #28 L[5]=sp + #24 L[6]=R9 L[7]=R22 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=R21
        # OopMap {x28=Oop x30=NarrowOop x9=Oop x18=NarrowOop x19=Oop xbcp=Oop [0]=Oop off=440/0x1b8}
1bc +   lwu  R29, [R22, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
1c0 +   decode_heap_oop  R29, R29	#@decodeHeapOop
1c4 +   beq   R29, zr, B9	#@cmpP_imm0_branch  P=0.379836 C=244.000000

1c8     B19: #	out( B17 ) &lt;- in( B18 )  Freq: 0.0281299
1c8 +   spill R29 -&gt; R22	# spill size = 64
1cc +   j  B17	#@branch

1d0     B20: #	out( B107 B21 ) &lt;- in( B17 )  Freq: 0.151506
1d0 +   lwu  R29, [R22, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
1d4 +   decode_heap_oop  R10, R29	#@decodeHeapOop
1d8 +   beq  R10, R28, B107	#@cmpP_branch  P=0.000000 C=815.000000

1dc     B21: #	out( B116 B22 ) &lt;- in( B20 )  Freq: 0.151506
1dc     lwu  R30, [R28, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
1e0     NullCheck R28

1e0     B22: #	out( B102 B23 ) &lt;- in( B21 )  Freq: 0.151506
1e0 +   mv  R29, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1f0 +   bne  R30, R29, B102	#@cmpN_branch  P=0.000001 C=-1.000000

1f4     B23: #	out( B53 B24 ) &lt;- in( B22 )  Freq: 0.151506
1f4 +   spill R28 -&gt; R12	# spill size = 64
1f8 +   # checkcastPP of R12, #@checkCastPP
1f8     beq  R12, R10, B53	#@cmpP_branch  P=0.064818 C=5338.000000

1fc     B24: #	out( B114 B25 ) &lt;- in( B23 )  Freq: 0.141685
1fc     lwu  R29, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
200     NullCheck R10

200     B25: #	out( B110 B26 ) &lt;- in( B24 )  Freq: 0.141685
200 +   mv  R31, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
210 +   lwu  R28, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
214 +   lb  R30, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
218 +   bne  R29, R31, B110	#@cmpN_branch  P=0.000000 C=-1.000000

21c     B26: #	out( B108 B27 ) &lt;- in( B25 )  Freq: 0.141685
21c +   # checkcastPP of R10, #@checkCastPP
21c     lb  R8, [R10, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
220 +   lwu  R29, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
224 +   decode_heap_oop  R28, R28	#@decodeHeapOop
228 +   bne  R30, R8, B108	#@cmpI_branch  P=0.000000 C=4992.000000

22c     B27: #	out( B103 B28 ) &lt;- in( B26 )  Freq: 0.141685
22c +   beq   R28, zr, B103	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

230     B28: #	out( B104 B29 ) &lt;- in( B27 )  Freq: 0.141685
230 +   decode_heap_oop  R29, R29	#@decodeHeapOop
234 +   lwu  R14, [R28, #12]	# range, #@loadRange
238 +   beq   R29, zr, B104	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

23c     B29: #	out( B32 B30 ) &lt;- in( B28 )  Freq: 0.141685
23c +   lwu  R30, [R29, #12]	# range, #@loadRange
240 +   bne  R14, R30, B32	#@cmpI_branch  P=0.000001 C=-1.000000

244     B30: #	out( B53 B31 ) &lt;- in( B29 )  Freq: 0.141685
244 +   addi  R13, R29, #16	# ptr, #@addP_reg_imm
248 +   addi  R11, R28, #16	# ptr, #@addP_reg_imm
24c     String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
2dc +   bne  R10, zr, B53	#@cmpI_reg_imm0_branch  P=1.000000 C=815.000000

2e0     B31: #	out( B32 ) &lt;- in( B30 )  Freq: 6.75605e-08
2e0 +   spill R10 -&gt; R7	# spill size = 32

2e4     B32: #	out( N1360 ) &lt;- in( B31 B29 )  Freq: 2.09245e-07
2e4 +   spill [sp, #0] -&gt; R8	# spill size = 64
2e8 +   spill [sp, #28] -&gt; R28	# spill size = 32
2ec +   spill [sp, #24] -&gt; R29	# spill size = 32
2f0 +   li R11, #-187	# int, #@loadConI
2f4     spill R20 -&gt; [sp, #0]	# spill size = 32
2f8 +   spill R19 -&gt; [sp, #8]	# spill size = 64
2fc +   spill R28 -&gt; [sp, #4]	# spill size = 32
300 +   spill R29 -&gt; [sp, #16]	# spill size = 32
304 +   spill R9 -&gt; [sp, #24]	# spill size = 64
308 +   spill R22 -&gt; [sp, #32]	# spill size = 64
30c +   spill R7 -&gt; [sp, #20]	# spill size = 32
310 +   spill R12 -&gt; [sp, #40]	# spill size = 64
314 +   spill R21 -&gt; [sp, #48]	# spill size = 32
318     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:206 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #40 L[3]=sp + #8 L[4]=sp + #4 L[5]=sp + #16 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #32 L[11]=_ L[12]=sp + #48 STK[0]=sp + #20
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop off=796/0x31c}
31c     #@ShouldNotReachHere

328     B33: #	out( B86 B34 ) &lt;- in( B4 )  Freq: 0.511067
328 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
328     ld  R21, [R23, #288]	# ptr, #@loadP
32c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
32c     ld  R7, [R23, #304]	# ptr, #@loadP
330 +   addi  R29, R21, #32	# ptr, #@addP_reg_imm
334 +   bgeu  R29, R7, B86	#@cmpP_branch  P=0.000100 C=-1.000000

338     B34: #	out( B35 ) &lt;- in( B33 )  Freq: 0.511016
338 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
338     sd  R29, [R23, #288]	# ptr, #@storeP
33c +   sd  R31, [R21]	# long, #@storeL
340 +   sw  R10, [R21, #8]	# compressed klass ptr, #@storeNKlass
344 +   sd  zr, [R21, #24]	# long, #@storeimmL0

348     B35: #	out( B91 B36 ) &lt;- in( B87 B34 )  Freq: 0.511067
348 +   sw  R20, [R21, #12]	# int, #@storeI
34c +   sw  R30, [R21, #16]	# compressed ptr, #@storeN
350 +   sw  R18, [R21, #20]	# compressed ptr, #@storeN
354     
354 +   #@membar_release
	fence iorw ow
358 +   lwu  R7, [R9, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
35c +   mv  R29, narrowklass: precise klass [Ljava/util/HashMap$Node;: 0x00000040d06abf60:Constant:exact *	# compressed klass ptr, #@loadConNKlass
36c +   # checkcastPP of R21, #@checkCastPP
36c     bne  R7, R29, B91	#@cmpN_branch  P=0.000001 C=-1.000000

370     B36: #	out( B65 B37 ) &lt;- in( B35 )  Freq: 0.511067
370 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
370     lb  R7, [R23, #56]	# byte, #@loadB
374 +   bne  R7, zr, B65	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

378     B37: #	out( B39 B38 ) &lt;- in( B94 B67 B65 B36 )  Freq: 0.511067
378 +   mv  R7, R8	# ptr -&gt; long, #@castP2X
37c +   mv  R28, R21	# ptr -&gt; long, #@castP2X
380 +   xorr  R28, R28, R7	#@xorL_reg_reg
384 +   encode_heap_oop  R30, R21	#@encodeHeapOop
388 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
38c +   sw  R30, [R8]	# compressed ptr, #@storeN
390 +   beq  R28, zr, B39	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

394     B38: #	out( B68 B39 ) &lt;- in( B37 )  Freq: 0.510556
394 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
398 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
3a4 +   add R10, R28, R7	# ptr, #@addP_reg_reg
3a8 +   lb  R7, [R10]	# byte, #@loadB
3ac +   li R29, #4	# int, #@loadConI
3b0 +   bne  R7, R29, B68	#@cmpI_branch  P=0.001000 C=-1.000000

3b4     B39: #	out( B63 B40 ) &lt;- in( B14 B70 B71 B68 B38 B37 )  Freq: 0.631642
3b4 +   spill [sp, #0] -&gt; R28	# spill size = 64
3b8 +   lw  R29, [R28, #24]	# int, #@loadI ! Field: java/util/HashMap.modCount
3bc     spill [sp, #0] -&gt; R7	# spill size = 64
3c0 +   lw  R7, [R7, #20]	# int, #@loadI ! Field: java/util/HashMap.size
3c4 +   addiw  R30, R29, #1	#@addI_reg_imm
3c8 +   addiw  R7, R7, #1	#@addI_reg_imm
3cc +   lw  R28, [R28, #28]	# int, #@loadI ! Field: java/util/HashMap.threshold
3d0     spill [sp, #0] -&gt; R29	# spill size = 64
3d4 +   sw  R30, [R29, #24]	# int, #@storeI ! Field: java/util/HashMap.modCount
3d8 +   sw  R7, [R29, #20]	# int, #@storeI ! Field: java/util/HashMap.size
3dc +   bgt  R7, R28, B63	#@cmpI_branch  P=0.039776 C=3394.000000

3e0     B40: #	out( B59 ) &lt;- in( B64 B39 )  Freq: 0.631641
3e0 +   mv  R10, NULL	# NULL ptr, #@loadConP0
3e4 +   j  B59	#@branch

3e8     B41: #	out( B105 B42 ) &lt;- in( B5 )  Freq: 0.216847
3e8 +   lwu  R31, [R29, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
3ec +   decode_heap_oop  R31, R31	#@decodeHeapOop
3f0 +   beq  R31, R28, B105	#@cmpP_branch  P=0.000000 C=1166.000000

3f4     B42: #	out( B115 B43 ) &lt;- in( B41 )  Freq: 0.216847
3f4     lwu  R30, [R28, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
3f8     NullCheck R28

3f8     B43: #	out( B95 B44 ) &lt;- in( B42 )  Freq: 0.216846
3f8 +   mv  R11, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
408 +   bne  R30, R11, B95	#@cmpN_branch  P=0.000001 C=-1.000000

40c     B44: #	out( B52 B45 ) &lt;- in( B43 )  Freq: 0.216846
40c +   spill R28 -&gt; R12	# spill size = 64
410 +   # checkcastPP of R12, #@checkCastPP
410     beq  R12, R31, B52	#@cmpP_branch  P=0.064818 C=5338.000000

414     B45: #	out( B112 B46 ) &lt;- in( B44 )  Freq: 0.202791
414     lwu  R28, [R31, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
418     NullCheck R31

418     B46: #	out( B111 B47 ) &lt;- in( B45 )  Freq: 0.20279
418 +   mv  R10, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
428 +   lwu  R11, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
42c +   lb  R30, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
430 +   bne  R28, R10, B111	#@cmpN_branch  P=0.000000 C=-1.000000

434     B47: #	out( B106 B48 ) &lt;- in( B46 )  Freq: 0.20279
434 +   # checkcastPP of R31, #@checkCastPP
434     lb  R28, [R31, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
438 +   lwu  R13, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
43c +   decode_heap_oop  R10, R11	#@decodeHeapOop
440 +   bne  R30, R28, B106	#@cmpI_branch  P=0.000000 C=4992.000000

444     B48: #	out( B96 B49 ) &lt;- in( B47 )  Freq: 0.20279
444 +   beq   R10, zr, B96	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

448     B49: #	out( B97 B50 ) &lt;- in( B48 )  Freq: 0.20279
448 +   decode_heap_oop  R28, R13	#@decodeHeapOop
44c +   lwu  R14, [R10, #12]	# range, #@loadRange
450 +   beq   R28, zr, B97	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

454     B50: #	out( B99 B51 ) &lt;- in( B49 )  Freq: 0.20279
454 +   lwu  R31, [R28, #12]	# range, #@loadRange
458 +   bne  R14, R31, B99	#@cmpI_branch  P=0.000001 C=-1.000000

45c     B51: #	out( B98 B52 ) &lt;- in( B50 )  Freq: 0.20279
45c +   addi  R13, R28, #16	# ptr, #@addP_reg_imm
460 +   addi  R11, R10, #16	# ptr, #@addP_reg_imm
464     String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
4f4 +   beq  R10, zr, B98	#@cmpI_reg_imm0_branch  P=0.000000 C=1166.000000

4f8     B52: #	out( B53 ) &lt;- in( B44 B51 )  Freq: 0.216845
4f8 +   spill R29 -&gt; R22	# spill size = 64

4fc     B53: #	out( B101 B54 ) &lt;- in( B52 B23 B30 )  Freq: 0.36835
4fc +   lwu  R28, [R22, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.value
500 +   decode_heap_oop  R9, R28	#@decodeHeapOop
504     spill [sp, #28] -&gt; R7	# spill size = 32
508 +   bne  R7, zr, B101	#@cmpI_reg_imm0_branch  P=0.000000 C=1980.000000

50c     B54: #	out( B72 B55 ) &lt;- in( B53 )  Freq: 0.36835
50c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
50c     lb  R7, [R23, #56]	# byte, #@loadB
510 +   bne  R7, zr, B72	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

514     B55: #	out( B58 B56 ) &lt;- in( B100 B74 B72 B54 )  Freq: 0.36835
514 +   mv  R7, R22	# ptr -&gt; long, #@castP2X
518 +   mv  R28, R19	# ptr -&gt; long, #@castP2X
51c +   xorr  R28, R28, R7	#@xorL_reg_reg
520 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
524 +   sw  R18, [R22, #20]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.value
528 +   beq  R28, zr, B58	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

52c     B56: #	out( B58 B57 ) &lt;- in( B55 )  Freq: 0.367982
52c +   beq   R19, zr, B58	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

530     B57: #	out( B75 B58 ) &lt;- in( B56 )  Freq: 0.367614
530 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
534 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
540 +   add R10, R28, R7	# ptr, #@addP_reg_reg
544 +   lb  R28, [R10]	# byte, #@loadB
548 +   li R29, #4	# int, #@loadConI
54c +   bne  R28, R29, B75	#@cmpI_branch  P=0.001000 C=-1.000000

550     B58: #	out( B59 ) &lt;- in( B77 B78 B75 B57 B56 B55 )  Freq: 0.36835
550 +   spill R9 -&gt; R10	# spill size = 64

554     B59: #	out( N1360 ) &lt;- in( B58 B40 )  Freq: 0.999991
554     # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
56c +   ret	// return register, #@Ret

570     B60: #	out( B120 B61 ) &lt;- in( B1 )  Freq: 0.174698
570     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:20 (line 627) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #16 L[3]=sp + #32 L[4]=sp + #28 L[5]=sp + #24 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {[0]=Oop [16]=Oop [32]=Oop off=1396/0x574}

574     B61: #	out( B113 B62 ) &lt;- in( B60 )  Freq: 0.174694
        # Block is sole successor of call
574 +   spill R10 -&gt; R9	# spill size = 64
578     lwu  R7, [R10, #12]	# range, #@loadRange
57c     NullCheck R10

57c     B62: #	out( B3 ) &lt;- in( B61 )  Freq: 0.174694
57c +   j  B3	#@branch

580     B63: #	out( B119 B64 ) &lt;- in( B39 )  Freq: 0.0251242
580 +   spill [sp, #0] -&gt; R11	# spill size = 64
584     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:288 (line 661) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=sp + #24 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {[0]=Oop off=1416/0x588}

588     B64: #	out( B40 ) &lt;- in( B63 )  Freq: 0.0251237
        # Block is sole successor of call
588 +   j  B40	#@branch

58c     B65: #	out( B37 B66 ) &lt;- in( B36 )  Freq: 0.00051106
58c +   lwu  R28, [R8]	# loadN, compressed ptr, #@loadN
590 +   decode_heap_oop  R10, R28	#@decodeHeapOop
594 +   beq   R10, zr, B37	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

598     B66: #	out( B94 B67 ) &lt;- in( B65 )  Freq: 0.00025553
598 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
598     ld  R7, [R23, #32]	# int, #@loadL
59c +   beq  R7, zr, B94	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

5a0     B67: #	out( B37 ) &lt;- in( B66 )  Freq: 0.000255275
5a0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5a0     ld  R28, [R23, #48]	# ptr, #@loadP
5a4 +   add R28, R28, R7	# ptr, #@addP_reg_reg
5a8 +   addi  R7, R7, #-8	#@addL_reg_imm
5ac +   sd  R10, [R28, #-8]	# ptr, #@storeP
5b0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5b0     sd  R7, [R23, #32]	# long, #@storeL
5b4 +   j  B37	#@branch

5b8     B68: #	out( B39 B69 ) &lt;- in( B38 )  Freq: 0.000510556
5b8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5b8     ld  R7, [R23, #64]	# int, #@loadL
5bc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5bc     ld  R28, [R23, #80]	# ptr, #@loadP
5c0 +   #@membar_volatile
	fence iorw iorw
5c4 +   lb  R30, [R10]	# byte, #@loadB
5c8 +   beq  R30, zr, B39	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

5cc     B69: #	out( B71 B70 ) &lt;- in( B68 )  Freq: 0.000255278
5cc +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
5d0 +   bne  R7, zr, B71	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

5d4     B70: #	out( B39 ) &lt;- in( B69 )  Freq: 0.000127639
5d4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5d4     spill R23 -&gt; R11	# spill size = 64
5d8 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
608 +   j  B39	#@branch

60c     B71: #	out( B39 ) &lt;- in( B69 )  Freq: 0.000127639
60c +   add R28, R28, R7	# ptr, #@addP_reg_reg
610 +   addi  R7, R7, #-8	#@addL_reg_imm
614 +   sd  R10, [R28, #-8]	# ptr, #@storeP
618 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
618     sd  R7, [R23, #64]	# long, #@storeL
61c +   j  B39	#@branch

620     B72: #	out( B55 B73 ) &lt;- in( B54 )  Freq: 0.000368345
620 +   lwu  R28, [R22, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.value
624 +   decode_heap_oop  R10, R28	#@decodeHeapOop
628 +   beq   R10, zr, B55	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

62c     B73: #	out( B100 B74 ) &lt;- in( B72 )  Freq: 0.000184173
62c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
62c     ld  R7, [R23, #32]	# int, #@loadL
630 +   beq  R7, zr, B100	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

634     B74: #	out( B55 ) &lt;- in( B73 )  Freq: 0.000183988
634 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
634     ld  R28, [R23, #48]	# ptr, #@loadP
638 +   add R28, R28, R7	# ptr, #@addP_reg_reg
63c +   addi  R7, R7, #-8	#@addL_reg_imm
640 +   sd  R10, [R28, #-8]	# ptr, #@storeP
644 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
644     sd  R7, [R23, #32]	# long, #@storeL
648 +   j  B55	#@branch

64c     B75: #	out( B58 B76 ) &lt;- in( B57 )  Freq: 0.000367614
64c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
64c     ld  R7, [R23, #64]	# int, #@loadL
650 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
650     ld  R28, [R23, #80]	# ptr, #@loadP
654 +   #@membar_volatile
	fence iorw iorw
658 +   lb  R29, [R10]	# byte, #@loadB
65c +   beq  R29, zr, B58	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

660     B76: #	out( B78 B77 ) &lt;- in( B75 )  Freq: 0.000183807
660 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
664 +   bne  R7, zr, B78	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

668     B77: #	out( B58 ) &lt;- in( B76 )  Freq: 9.19034e-05
668 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
668     spill R23 -&gt; R11	# spill size = 64
66c +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
69c +   j  B58	#@branch

6a0     B78: #	out( B58 ) &lt;- in( B76 )  Freq: 9.19034e-05
6a0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
6a4 +   addi  R7, R7, #-8	#@addL_reg_imm
6a8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
6ac +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6ac     sd  R7, [R23, #64]	# long, #@storeL
6b0 +   j  B58	#@branch

6b4     B79: #	out( B12 B80 ) &lt;- in( B11 )  Freq: 0.000120573
6b4 +   lwu  R7, [R22, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
6b8 +   decode_heap_oop  R10, R7	#@decodeHeapOop
6bc +   beq   R10, zr, B12	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

6c0     B80: #	out( B109 B81 ) &lt;- in( B79 )  Freq: 6.02867e-05
6c0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6c0     ld  R7, [R23, #32]	# int, #@loadL
6c4 +   beq  R7, zr, B109	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

6c8     B81: #	out( B12 ) &lt;- in( B80 )  Freq: 6.02264e-05
6c8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6c8     ld  R28, [R23, #48]	# ptr, #@loadP
6cc +   add R28, R28, R7	# ptr, #@addP_reg_reg
6d0 +   addi  R7, R7, #-8	#@addL_reg_imm
6d4 +   sd  R10, [R28, #-8]	# ptr, #@storeP
6d8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6d8     sd  R7, [R23, #32]	# long, #@storeL
6dc +   j  B12	#@branch

6e0     B82: #	out( B14 B83 ) &lt;- in( B13 )  Freq: 0.000120454
6e0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6e0     ld  R7, [R23, #64]	# int, #@loadL
6e4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6e4     ld  R28, [R23, #80]	# ptr, #@loadP
6e8 +   #@membar_volatile
	fence iorw iorw
6ec +   lb  R29, [R10]	# byte, #@loadB
6f0 +   beq  R29, zr, B14	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

6f4     B83: #	out( B85 B84 ) &lt;- in( B82 )  Freq: 6.02272e-05
6f4 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
6f8 +   bne  R7, zr, B85	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

6fc     B84: #	out( B14 ) &lt;- in( B83 )  Freq: 3.01136e-05
6fc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6fc     spill R23 -&gt; R11	# spill size = 64
700 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
730 +   j  B14	#@branch

734     B85: #	out( B14 ) &lt;- in( B83 )  Freq: 3.01136e-05
734 +   add R28, R28, R7	# ptr, #@addP_reg_reg
738 +   addi  R7, R7, #-8	#@addL_reg_imm
73c +   sd  R10, [R28, #-8]	# ptr, #@storeP
740 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
740     sd  R7, [R23, #64]	# long, #@storeL
744 +   j  B14	#@branch

748     B86: #	out( B118 B87 ) &lt;- in( B33 )  Freq: 5.11152e-05
748 +   spill [sp, #0] -&gt; [sp, #16]	# spill size = 64
750 +   spill R18 -&gt; [sp, #48]	# spill size = 32
754 +   spill R30 -&gt; [sp, #44]	# spill size = 32
758 +   spill R12 -&gt; [sp, #40]	# spill size = 32
75c +   spill R9 -&gt; [sp, #32]	# spill size = 64
760 +   spill R20 -&gt; [sp, #28]	# spill size = 32
764 +   mv  R11, precise klass java/util/HashMap$Node: 0x00000040d06a9190:Constant:exact *	# ptr, #@loadConP
77c     spill R28 -&gt; [sp, #0]	# spill size = 64
780 +   spill R19 -&gt; [sp, #8]	# spill size = 64
784     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #28 L[2]=sp + #0 L[3]=sp + #8 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:56 (line 629) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=sp + #24 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #32 STK[1]=sp + #40
        # OopMap {fp=Derived_oop_[32] [0]=Oop [8]=Oop [16]=Oop [32]=Oop [44]=NarrowOop [48]=NarrowOop off=1928/0x788}

788     B87: #	out( B35 ) &lt;- in( B86 )  Freq: 5.11142e-05
        # Block is sole successor of call
788 +   spill [sp, #16] -&gt; [sp, #0]	# spill size = 64
790 +   spill [sp, #28] -&gt; R20	# spill size = 32
794 +   spill [sp, #32] -&gt; R9	# spill size = 64
798 +   spill [sp, #40] -&gt; R12	# spill size = 32
79c +   spill [sp, #44] -&gt; R30	# spill size = 32
7a0 +   spill [sp, #48] -&gt; R18	# spill size = 32
7a4 +   spill R10 -&gt; R21	# spill size = 64
7a8 +   j  B35	#@branch

7ac     B88: #	out( B117 B89 ) &lt;- in( B9 )  Freq: 1.20595e-05
7ac +   spill R21 -&gt; [sp, #44]	# spill size = 32
7b0 +   spill R22 -&gt; [sp, #48]	# spill size = 64
7b4 +   spill R18 -&gt; [sp, #40]	# spill size = 32
7b8 +   spill R30 -&gt; [sp, #12]	# spill size = 32
7bc +   spill R9 -&gt; [sp, #32]	# spill size = 64
7c0 +   spill R19 -&gt; [sp, #16]	# spill size = 64
7c4 +   spill R20 -&gt; [sp, #8]	# spill size = 32
7c8 +   mv  R11, precise klass java/util/HashMap$Node: 0x00000040d06a9190:Constant:exact *	# ptr, #@loadConP
7e0     spill R28 -&gt; R8	# spill size = 64
7e4     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #8 L[2]=R8 L[3]=sp + #16 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:152 (line 640) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=sp + #16 L[4]=sp + #28 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=sp + #44 STK[0]=sp + #48
        # OopMap {fp=Oop [0]=Oop [12]=NarrowOop [16]=Oop [32]=Oop [40]=NarrowOop [48]=Oop off=2024/0x7e8}

7e8     B89: #	out( B11 ) &lt;- in( B88 )  Freq: 1.20593e-05
        # Block is sole successor of call
7e8 +   spill [sp, #8] -&gt; R20	# spill size = 32
7ec +   spill [sp, #16] -&gt; R19	# spill size = 64
7f0 +   spill [sp, #32] -&gt; R9	# spill size = 64
7f4 +   spill [sp, #12] -&gt; R30	# spill size = 32
7f8 +   spill [sp, #40] -&gt; R18	# spill size = 32
7fc +   spill [sp, #48] -&gt; R22	# spill size = 64
800 +   spill [sp, #44] -&gt; R21	# spill size = 32
804 +   spill R10 -&gt; R24	# spill size = 64
808 +   j  B11	#@branch

80c     B90: #	out( N1360 ) &lt;- in( B3 )  Freq: 9.99996e-07
80c +   spill [sp, #0] -&gt; R8	# spill size = 64
810 +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
818 +   spill [sp, #28] -&gt; R28	# spill size = 32
81c +   li R11, #-28	# int, #@loadConI
820     spill R20 -&gt; [sp, #0]	# spill size = 32
824 +   spill [sp, #32] -&gt; [sp, #16]	# spill size = 64
82c +   spill R28 -&gt; [sp, #4]	# spill size = 32
830 +   spill R9 -&gt; [sp, #40]	# spill size = 64
834 +   spill R12 -&gt; [sp, #48]	# spill size = 32
838     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.HashMap::putVal @ bci:40 (line 628) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #40 L[7]=_ L[8]=_ L[9]=sp + #48 L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #40 STK[1]=sp + #48
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop off=2108/0x83c}
83c     #@ShouldNotReachHere

848     B91: #	out( N1360 ) &lt;- in( B35 )  Freq: 5.11067e-07
848 +   spill [sp, #0] -&gt; R8	# spill size = 64
84c +   li R11, #-42	# int, #@loadConI
850     spill R9 -&gt; [sp, #8]	# spill size = 64
854 +   spill R12 -&gt; [sp, #4]	# spill size = 32
858 +   spill R21 -&gt; [sp, #16]	# spill size = 64
85c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;array_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:59 (line 629) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=sp + #24 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #8 STK[1]=sp + #4 STK[2]=sp + #16
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=2144/0x860}
860     #@ShouldNotReachHere

86c     B92: #	out( N1360 ) &lt;- in( B2 )  Freq: 3.93535e-07
86c +   spill [sp, #0] -&gt; R8	# spill size = 64
870 +   li R11, #-187	# int, #@loadConI
874     spill R12 -&gt; [sp, #0]	# spill size = 32
878 +   spill R13 -&gt; [sp, #8]	# spill size = 64
87c +   spill R14 -&gt; [sp, #16]	# spill size = 64
880 +   spill R15 -&gt; [sp, #4]	# spill size = 32
884 +   spill R9 -&gt; [sp, #32]	# spill size = 64
888 +   spill R7 -&gt; [sp, #40]	# spill size = 32
88c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:16 (line 626) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=sp + #40 L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #40
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop off=2192/0x890}
890     #@ShouldNotReachHere

89c     B93: #	out( N1360 ) &lt;- in( B6 )  Freq: 2.75694e-07
89c +   spill [sp, #0] -&gt; R8	# spill size = 64
8a0 +   li R11, #-187	# int, #@loadConI
8a4     spill R20 -&gt; [sp, #0]	# spill size = 32
8a8 +   spill R28 -&gt; [sp, #8]	# spill size = 64
8ac +   spill R19 -&gt; [sp, #16]	# spill size = 64
8b0 +   spill R9 -&gt; [sp, #32]	# spill size = 64
8b4 +   spill R29 -&gt; [sp, #40]	# spill size = 64
8b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:109 (line 635) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #28 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#1
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop off=2236/0x8bc}
8bc     #@ShouldNotReachHere

8c8     B94: #	out( B37 ) &lt;- in( B66 )  Freq: 2.55527e-07
8c8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8c8     spill R23 -&gt; R11	# spill size = 64
8cc +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
8fc +   j  B37	#@branch

900     B95: #	out( N1360 ) &lt;- in( B43 )  Freq: 2.16846e-07
900 +   spill [sp, #0] -&gt; R8	# spill size = 64
904 +   li R11, #-34	# int, #@loadConI
908     spill R20 -&gt; [sp, #0]	# spill size = 32
90c +   spill R19 -&gt; [sp, #16]	# spill size = 64
910 +   spill R9 -&gt; [sp, #32]	# spill size = 64
914 +   spill R29 -&gt; [sp, #40]	# spill size = 64
918 +   spill R28 -&gt; [sp, #48]	# spill size = 64
91c +   spill R31 -&gt; [sp, #56]	# spill size = 64
920     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #28 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #48 STK[1]=sp + #56
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=2340/0x924}
924     #@ShouldNotReachHere

930     B96: #	out( N1360 ) &lt;- in( B48 )  Freq: 2.05483e-07
930     #@ShouldNotReachHere

93c     B97: #	out( N1360 ) &lt;- in( B49 )  Freq: 2.05483e-07
93c     #@ShouldNotReachHere

948     B98: #	out( B99 ) &lt;- in( B51 )  Freq: 9.66977e-08
948 +   spill R10 -&gt; R7	# spill size = 32

94c     B99: #	out( N1360 ) &lt;- in( B98 B50 )  Freq: 2.99488e-07
94c +   spill [sp, #0] -&gt; R8	# spill size = 64
950 +   spill [sp, #28] -&gt; R30	# spill size = 32
954 +   li R11, #-187	# int, #@loadConI
958     spill R20 -&gt; [sp, #0]	# spill size = 32
95c +   spill R12 -&gt; [sp, #8]	# spill size = 64
960 +   spill R19 -&gt; [sp, #16]	# spill size = 64
964 +   spill R30 -&gt; [sp, #4]	# spill size = 32
968 +   spill R9 -&gt; [sp, #32]	# spill size = 64
96c +   spill R29 -&gt; [sp, #40]	# spill size = 64
970 +   spill R7 -&gt; [sp, #28]	# spill size = 32
974     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:94 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #28
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop off=2424/0x978}
978     #@ShouldNotReachHere

984     B100: #	out( B55 ) &lt;- in( B73 )  Freq: 1.8417e-07
984 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
984     spill R23 -&gt; R11	# spill size = 64
988 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
9b8 +   j  B55	#@branch

9bc     B101: #	out( N1360 ) &lt;- in( B53 )  Freq: 1.75643e-07
9bc +   spill [sp, #0] -&gt; R8	# spill size = 64
9c0 +   li R11, #-187	# int, #@loadConI
9c4     spill R19 -&gt; [sp, #0]	# spill size = 64
9c8 +   spill R22 -&gt; [sp, #8]	# spill size = 64
9cc +   spill R9 -&gt; [sp, #16]	# spill size = 64
9d0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:236 (line 653) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #8 L[11]=_ L[12]=sp + #16 STK[0]=sp + #28
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=2516/0x9d4}
9d4     #@ShouldNotReachHere

9e0     B102: #	out( N1360 ) &lt;- in( B22 )  Freq: 1.51506e-07
9e0 +   spill [sp, #0] -&gt; R8	# spill size = 64
9e4 +   spill [sp, #28] -&gt; R29	# spill size = 32
9e8 +   li R11, #-34	# int, #@loadConI
9ec     spill R20 -&gt; [sp, #0]	# spill size = 32
9f0 +   spill R19 -&gt; [sp, #16]	# spill size = 64
9f4 +   spill R29 -&gt; [sp, #4]	# spill size = 32
9f8 +   spill R9 -&gt; [sp, #32]	# spill size = 64
9fc +   spill R22 -&gt; [sp, #40]	# spill size = 64
a00 +   spill R28 -&gt; [sp, #48]	# spill size = 64
a04 +   spill R21 -&gt; [sp, #28]	# spill size = 32
a08 +   spill R10 -&gt; [sp, #56]	# spill size = 64
a0c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=_ L[12]=sp + #28 STK[0]=sp + #48 STK[1]=sp + #56
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=2576/0xa10}
a10     #@ShouldNotReachHere

a1c     B103: #	out( N1360 ) &lt;- in( B27 )  Freq: 1.43566e-07
a1c     #@ShouldNotReachHere

a28     B104: #	out( N1360 ) &lt;- in( B28 )  Freq: 1.43566e-07
a28     #@ShouldNotReachHere

a34     B105: #	out( N1360 ) &lt;- in( B41 )  Freq: 1.03401e-07
a34 +   spill [sp, #0] -&gt; R8	# spill size = 64
a38 +   li R11, #-187	# int, #@loadConI
a3c     spill R20 -&gt; [sp, #0]	# spill size = 32
a40 +   spill R19 -&gt; [sp, #16]	# spill size = 64
a44 +   spill R9 -&gt; [sp, #32]	# spill size = 64
a48 +   spill R29 -&gt; [sp, #40]	# spill size = 64
a4c +   spill R31 -&gt; [sp, #56]	# spill size = 64
a50 +   spill R28 -&gt; [sp, #64]	# spill size = 64
a54     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:81 (line 632) L[0]=R8 L[1]=sp + #0 L[2]=sp + #64 L[3]=sp + #16 L[4]=sp + #28 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=sp + #56 L[12]=_ STK[0]=sp + #56 STK[1]=sp + #64
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=2648/0xa58}
a58     #@ShouldNotReachHere

a64     B106: #	out( N1360 ) &lt;- in( B47 )  Freq: 1.01395e-07
a64 +   spill [sp, #0] -&gt; R8	# spill size = 64
a68 +   spill [sp, #28] -&gt; R7	# spill size = 32
a6c +   li R11, #-187	# int, #@loadConI
a70     spill R20 -&gt; [sp, #0]	# spill size = 32
a74 +   spill R19 -&gt; [sp, #16]	# spill size = 64
a78 +   spill R7 -&gt; [sp, #4]	# spill size = 32
a7c +   spill R9 -&gt; [sp, #32]	# spill size = 64
a80 +   spill R29 -&gt; [sp, #40]	# spill size = 64
a84 +   spill R12 -&gt; [sp, #48]	# spill size = 64
a88 +   spill R31 -&gt; [sp, #56]	# spill size = 64
a8c +   spill R30 -&gt; [sp, #28]	# spill size = 32
a90 +   spill R28 -&gt; [sp, #64]	# spill size = 32
a94     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #48 L[1]=_ L[2]=sp + #56 STK[0]=sp + #28 STK[1]=sp + #64
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=2712/0xa98}
a98     #@ShouldNotReachHere

aa4     B107: #	out( N1360 ) &lt;- in( B20 )  Freq: 7.22436e-08
aa4 +   spill [sp, #0] -&gt; R8	# spill size = 64
aa8 +   spill [sp, #28] -&gt; R29	# spill size = 32
aac +   li R11, #-187	# int, #@loadConI
ab0     spill R20 -&gt; [sp, #0]	# spill size = 32
ab4 +   spill R19 -&gt; [sp, #16]	# spill size = 64
ab8 +   spill R29 -&gt; [sp, #4]	# spill size = 32
abc +   spill R9 -&gt; [sp, #32]	# spill size = 64
ac0 +   spill R22 -&gt; [sp, #40]	# spill size = 64
ac4 +   spill R28 -&gt; [sp, #48]	# spill size = 64
ac8 +   spill R21 -&gt; [sp, #28]	# spill size = 32
acc +   spill R10 -&gt; [sp, #64]	# spill size = 64
ad0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:193 (line 645) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=sp + #64 L[12]=sp + #28 STK[0]=sp + #64 STK[1]=sp + #48
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [64]=Oop off=2772/0xad4}
ad4     #@ShouldNotReachHere

ae0     B108: #	out( N1360 ) &lt;- in( B26 )  Freq: 7.08426e-08
ae0 +   spill [sp, #28] -&gt; R28	# spill size = 32
ae4 +   li R11, #-187	# int, #@loadConI
ae8     spill R20 -&gt; [sp, #8]	# spill size = 32
aec +   spill R19 -&gt; [sp, #16]	# spill size = 64
af0 +   spill R28 -&gt; [sp, #12]	# spill size = 32
af4 +   spill R9 -&gt; [sp, #32]	# spill size = 64
af8 +   spill R22 -&gt; [sp, #40]	# spill size = 64
afc +   spill R21 -&gt; [sp, #28]	# spill size = 32
b00 +   spill R12 -&gt; [sp, #56]	# spill size = 64
b04 +   spill R10 -&gt; [sp, #64]	# spill size = 64
b08 +   spill R30 -&gt; [sp, #72]	# spill size = 32
b0c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #56 L[1]=_ L[2]=sp + #64 STK[0]=sp + #72 STK[1]=R8
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #56 L[3]=sp + #16 L[4]=sp + #12 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=_ L[12]=sp + #28
        # OopMap {[0]=Oop [16]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=2832/0xb10}
b10     #@ShouldNotReachHere

b1c     B109: #	out( B12 ) &lt;- in( B80 )  Freq: 6.02859e-08
b1c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
b1c     spill R23 -&gt; R11	# spill size = 64
b20 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
b50 +   j  B12	#@branch

b54     B110: #	out( N1360 ) &lt;- in( B25 )  Freq: 1e-35
b54 +   spill [sp, #0] -&gt; R8	# spill size = 64
b58 +   spill [sp, #28] -&gt; R7	# spill size = 32
b5c +   spill [sp, #24] -&gt; R28	# spill size = 32
b60 +   li R11, #-34	# int, #@loadConI
b64     spill R20 -&gt; [sp, #0]	# spill size = 32
b68 +   spill R19 -&gt; [sp, #8]	# spill size = 64
b6c +   spill R7 -&gt; [sp, #4]	# spill size = 32
b70 +   spill R28 -&gt; [sp, #16]	# spill size = 32
b74 +   spill R9 -&gt; [sp, #24]	# spill size = 64
b78 +   spill R22 -&gt; [sp, #32]	# spill size = 64
b7c +   spill R21 -&gt; [sp, #20]	# spill size = 32
b80 +   spill R12 -&gt; [sp, #48]	# spill size = 64
b84 +   spill R10 -&gt; [sp, #64]	# spill size = 64
b88     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=sp + #64 L[2]=_ STK[0]=sp + #64
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #8 L[4]=sp + #4 L[5]=sp + #16 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #32 L[11]=_ L[12]=sp + #20
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [64]=Oop off=2956/0xb8c}
b8c     #@ShouldNotReachHere

b98     B111: #	out( N1360 ) &lt;- in( B46 )  Freq: 1e-35
b98 +   spill [sp, #0] -&gt; R8	# spill size = 64
b9c +   li R11, #-34	# int, #@loadConI
ba0     spill R20 -&gt; [sp, #0]	# spill size = 32
ba4 +   spill R19 -&gt; [sp, #16]	# spill size = 64
ba8 +   spill R9 -&gt; [sp, #32]	# spill size = 64
bac +   spill R29 -&gt; [sp, #40]	# spill size = 64
bb0 +   spill R12 -&gt; [sp, #48]	# spill size = 64
bb4 +   spill R31 -&gt; [sp, #64]	# spill size = 64
bb8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=sp + #64 L[2]=_ STK[0]=sp + #64
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #28 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [64]=Oop off=3004/0xbbc}
bbc     #@ShouldNotReachHere

bc8     B112: #	out( N1360 ) &lt;- in( B45 )  Freq: 2.05483e-07
bc8 +   spill [sp, #0] -&gt; R8	# spill size = 64
bcc +   li R11, #-12	# int, #@loadConI
bd0     spill R20 -&gt; [sp, #0]	# spill size = 32
bd4 +   spill R19 -&gt; [sp, #16]	# spill size = 64
bd8 +   spill R9 -&gt; [sp, #32]	# spill size = 64
bdc +   spill R29 -&gt; [sp, #40]	# spill size = 64
be0 +   spill R12 -&gt; [sp, #48]	# spill size = 64
be4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #28 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop off=3048/0xbe8}
be8     #@ShouldNotReachHere

bf4     B113: #	out( N1360 ) &lt;- in( B61 )  Freq: 1.77014e-07
bf4 +   li R11, #-10	# int, #@loadConI
bf8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:26 (line 627) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#NULL
        # OopMap {off=3068/0xbfc}
bfc     #@ShouldNotReachHere

c08     B114: #	out( N1360 ) &lt;- in( B24 )  Freq: 1.43567e-07
c08 +   spill [sp, #0] -&gt; R8	# spill size = 64
c0c +   spill [sp, #28] -&gt; R28	# spill size = 32
c10 +   spill [sp, #24] -&gt; R7	# spill size = 32
c14 +   li R11, #-12	# int, #@loadConI
c18     spill R20 -&gt; [sp, #0]	# spill size = 32
c1c +   spill R19 -&gt; [sp, #8]	# spill size = 64
c20 +   spill R28 -&gt; [sp, #4]	# spill size = 32
c24 +   spill R7 -&gt; [sp, #16]	# spill size = 32
c28 +   spill R9 -&gt; [sp, #24]	# spill size = 64
c2c +   spill R22 -&gt; [sp, #32]	# spill size = 64
c30 +   spill R21 -&gt; [sp, #20]	# spill size = 32
c34 +   spill R12 -&gt; [sp, #48]	# spill size = 64
c38     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #8 L[4]=sp + #4 L[5]=sp + #16 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #32 L[11]=_ L[12]=sp + #20
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop off=3132/0xc3c}
c3c     #@ShouldNotReachHere

c48     B115: #	out( N1360 ) &lt;- in( B42 )  Freq: 1.034e-07
c48 +   spill [sp, #0] -&gt; R8	# spill size = 64
c4c +   li R11, #-187	# int, #@loadConI
c50     spill R20 -&gt; [sp, #0]	# spill size = 32
c54 +   spill R19 -&gt; [sp, #16]	# spill size = 64
c58 +   spill R9 -&gt; [sp, #32]	# spill size = 64
c5c +   spill R29 -&gt; [sp, #40]	# spill size = 64
c60 +   spill R31 -&gt; [sp, #48]	# spill size = 64
c64 +   spill R28 -&gt; [sp, #56]	# spill size = 64
c68     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:85 (line 632) L[0]=R8 L[1]=sp + #0 L[2]=sp + #56 L[3]=sp + #16 L[4]=sp + #28 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=sp + #48 L[12]=_ STK[0]=sp + #56
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=3180/0xc6c}
c6c     #@ShouldNotReachHere

c78     B116: #	out( N1360 ) &lt;- in( B21 )  Freq: 7.22436e-08
c78 +   spill [sp, #0] -&gt; R8	# spill size = 64
c7c +   spill [sp, #28] -&gt; R7	# spill size = 32
c80 +   li R11, #-187	# int, #@loadConI
c84     spill R20 -&gt; [sp, #0]	# spill size = 32
c88 +   spill R19 -&gt; [sp, #16]	# spill size = 64
c8c +   spill R7 -&gt; [sp, #4]	# spill size = 32
c90 +   spill R9 -&gt; [sp, #32]	# spill size = 64
c94 +   spill R22 -&gt; [sp, #40]	# spill size = 64
c98 +   spill R28 -&gt; [sp, #48]	# spill size = 64
c9c +   spill R10 -&gt; [sp, #56]	# spill size = 64
ca0 +   spill R21 -&gt; [sp, #28]	# spill size = 32
ca4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:197 (line 645) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=sp + #56 L[12]=sp + #28 STK[0]=sp + #48
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=3240/0xca8}
ca8     #@ShouldNotReachHere

cb4     B117: #	out( B121 ) &lt;- in( B88 )  Freq: 1.20595e-10
cb4      -- 	// exception oop; no code emitted, #@CreateException
cb4 +   spill R10 -&gt; R11	# spill size = 64
cb8 +   j  B121	#@branch

cbc     B118: #	out( B121 ) &lt;- in( B86 )  Freq: 5.11152e-10
cbc      -- 	// exception oop; no code emitted, #@CreateException
cbc +   spill R10 -&gt; R11	# spill size = 64
cc0 +   j  B121	#@branch

cc4     B119: #	out( B121 ) &lt;- in( B63 )  Freq: 2.51242e-07
cc4      -- 	// exception oop; no code emitted, #@CreateException
cc4 +   spill R10 -&gt; R11	# spill size = 64
cc8 +   j  B121	#@branch

ccc     B120: #	out( B121 ) &lt;- in( B60 )  Freq: 1.74698e-06
ccc      -- 	// exception oop; no code emitted, #@CreateException
ccc +   spill R10 -&gt; R11	# spill size = 64

cd0     B121: #	out( N1360 ) &lt;- in( B120 B118 B117 B119 )  Freq: 1.99885e-06
cd0     # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
cdc +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='473'>
----------------------- MetaData before Compile_id = 473 ------------------------
{method}
 - this oop:          0x00000040961a1ad8
 - method holder:     &apos;java/util/HashMap&apos;
 - constants:         0x000000409619f4e0 constant pool [610] {0x000000409619f4e0} for &apos;java/util/HashMap&apos; cache=0x00000040961a4fd8
 - access:            0x81000001  public 
 - name:              &apos;put&apos;
 - signature:         &apos;(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;&apos;
 - max stack:         7
 - max locals:        3
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      7
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008317290: 0xbbb i2c: 0x0000004013944dc0 c2i: 0x0000004013944e0c c2iUV: 0x0000004013944dd8
 - compiled entry     0x000000400c506840
 - code size:         13
 - code start:        0x00000040961a1a98
 - code end (excl):   0x00000040961a1aa5
 - method data:       0x0000004096487118
 - checked ex length: 0
 - linenumber start:  0x00000040961a1aa5
 - localvar length:   3
 - localvar start:    0x00000040961a1ab0
 - compiled code: nmethod  19755  176       3       java.util.HashMap::put (13 bytes)

------------------------ OptoAssembly for Compile_id = 473 -----------------------
#
#  java/lang/Object * ( java/util/HashMap:NotNull *, java/lang/Object *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/HashMap:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
#r016 c_rarg3:c_rarg3   : parm 2: java/lang/Object *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N121: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B9 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     spill R11 -&gt; [sp, #8]	# spill size = 64
040 +   spill R13 -&gt; [sp, #0]	# spill size = 64
044 +   spill R12 -&gt; R8	# spill size = 64
048     lwu  R28, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
04c     NullCheck R12

04c     B2: #	out( B7 B3 ) &lt;- in( B1 )  Freq: 1
04c +   decode_klass_not_null  R28, R28	#@decodeKlass_not_null
058 +   ld  R28, [R28, #504]	# ptr, #@loadP
05c +   mv  R7, metadataptr:Constant0x00000040d09f7280	# ptr, #@loadConP
074 +   bne  R28, R7, B7	#@cmpP_branch  P=0.001000 C=-1.000000

078     B3: #	out( B7 B4 ) &lt;- in( B2 )  Freq: 0.999
078 +   ld  R7, [R12]	# int, #@loadL
07c +   li R29, #1	# long, #@loadConL
080 +   andi  R28, R7, #7	#@andL_reg_imm
084 +   bne  R28, R29, B7	#@cmpL_branch  P=0.001000 C=-1.000000

088     B4: #	out( B7 B5 ) &lt;- in( B3 )  Freq: 0.998001
088 +   srli  R7, R7, (#8 &amp; 0x3f)	#@urShiftL_reg_imm
08c +   li R29, #2147483647	# int, #@loadConI
094 +   addw  R7, R7, zr	#@convL2I_reg
098 +   andr  R10, R7, R29	#@andI_reg_reg
09c +   beq  R10, zr, B7	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0a0     B5: #	out( B11 B6 ) &lt;- in( B8 B4 )  Freq: 0.999999
0a0 +   srliw  R7, R10, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
0a4 +   xorr  R12, R7, R10	#@xorI_reg_reg
0a8 +   li R15, #0	# int, #@loadConI
0ac +   li R16, #1	# int, #@loadConI
0b0     spill [sp, #8] -&gt; R11	# spill size = 64
0b4 +   spill R8 -&gt; R13	# spill size = 64
0b8 +   spill [sp, #0] -&gt; R14	# spill size = 64
0bc     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::putVal
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {off=192/0xc0}

0c0     B6: #	out( N121 ) &lt;- in( B5 )  Freq: 0.999979
        # Block is sole successor of call
0c0     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0d8 +   ret	// return register, #@Ret

0dc     B7: #	out( B10 B8 ) &lt;- in( B2 B3 B4 )  Freq: 0.00299699
0dc +   spill R12 -&gt; R11	# spill size = 64
0e0     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=R8 L[2]=sp + #0 STK[0]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=252/0xfc}

0fc     B8: #	out( B5 ) &lt;- in( B7 )  Freq: 0.00299693
        # Block is sole successor of call
0fc +   j  B5	#@branch

100     B9: #	out( N121 ) &lt;- in( B1 )  Freq: 4.76837e-07
100 +   li R11, #-187	# int, #@loadConI
104     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::hash @ bci:1 (line 338) L[0]=R8 L[1]=_ STK[0]=R8
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=R8 L[2]=sp + #0 STK[0]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=264/0x108}
108     #@ShouldNotReachHere

114     B10: #	out( B12 ) &lt;- in( B7 )  Freq: 2.99699e-08
114      -- 	// exception oop; no code emitted, #@CreateException
114 +   spill R10 -&gt; R11	# spill size = 64
118 +   j  B12	#@branch

11c     B11: #	out( B12 ) &lt;- in( B5 )  Freq: 9.99999e-06
11c      -- 	// exception oop; no code emitted, #@CreateException
11c +   spill R10 -&gt; R11	# spill size = 64

120     B12: #	out( N121 ) &lt;- in( B10 B11 )  Freq: 1.003e-05
120     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
12c +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='476'>
----------------------- MetaData before Compile_id = 476 ------------------------
{method}
 - this oop:          0x0000004096291480
 - method holder:     &apos;java/util/HashSet&apos;
 - constants:         0x00000040962901e0 constant pool [285] {0x00000040962901e0} for &apos;java/util/HashSet&apos; cache=0x0000004096291e18
 - access:            0x81000001  public 
 - name:              &apos;add&apos;
 - signature:         &apos;(Ljava/lang/Object;)Z&apos;
 - max stack:         4
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      5
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bd00: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c5186c0
 - code size:         20
 - code start:        0x0000004096291448
 - code end (excl):   0x000000409629145c
 - method data:       0x000000409648dd90
 - checked ex length: 0
 - linenumber start:  0x000000409629145c
 - localvar length:   2
 - localvar start:    0x0000004096291464
 - compiled code: nmethod  19836  212       3       java.util.HashSet::add (20 bytes)

------------------------ OptoAssembly for Compile_id = 476 -----------------------
#
#  bool ( java/util/HashSet:NotNull *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/HashSet:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N144: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B10 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lwu  R7, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashSet.map
040 +   decode_heap_oop  R7, R7	#@decodeHeapOop
044     spill R7 -&gt; [sp, #0]	# spill size = 64
048 +   beq   R7, zr, B10	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

04c     B2: #	out( B11 B3 ) &lt;- in( B1 )  Freq: 0.999999
04c +   spill R12 -&gt; R8	# spill size = 64
050     lwu  R28, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
054     NullCheck R12

054     B3: #	out( B8 B4 ) &lt;- in( B2 )  Freq: 0.999999
054 +   decode_klass_not_null  R28, R28	#@decodeKlass_not_null
060 +   ld  R28, [R28, #504]	# ptr, #@loadP
064 +   mv  R7, metadataptr:Constant0x00000040d02550a0	# ptr, #@loadConP
07c +   bne  R28, R7, B8	#@cmpP_branch  P=0.001000 C=-1.000000

080     B4: #	out( B8 B5 ) &lt;- in( B3 )  Freq: 0.998999
080 +   ld  R7, [R12]	# int, #@loadL
084 +   li R29, #1	# long, #@loadConL
088 +   andi  R28, R7, #7	#@andL_reg_imm
08c +   bne  R28, R29, B8	#@cmpL_branch  P=0.001000 C=-1.000000

090     B5: #	out( B8 B6 ) &lt;- in( B4 )  Freq: 0.998
090 +   srli  R7, R7, (#8 &amp; 0x3f)	#@urShiftL_reg_imm
094 +   li R29, #2147483647	# int, #@loadConI
09c +   addw  R7, R7, zr	#@convL2I_reg
0a0 +   andr  R10, R7, R29	#@andI_reg_reg
0a4 +   beq  R10, zr, B8	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0a8     B6: #	out( B13 B7 ) &lt;- in( B9 B5 )  Freq: 0.999998
0a8 +   srliw  R7, R10, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
0ac +   xorr  R12, R7, R10	#@xorI_reg_reg
0b0 +   mv  R14, java/lang/Object:exact *	# ptr, #@loadConP
0c8 +   li R15, #0	# int, #@loadConI
0cc +   li R16, #1	# int, #@loadConI
0d0     spill [sp, #0] -&gt; R11	# spill size = 64
0d4 +   spill R8 -&gt; R13	# spill size = 64
0d8     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::putVal
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {off=220/0xdc}

0dc     B7: #	out( N144 ) &lt;- in( B6 )  Freq: 0.999978
        # Block is sole successor of call
0dc +   snez  R7, R10	#@convP2Bool
0e0 +   xori  R10, R7, #1	#@xorI_reg_imm
0e4     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0fc +   ret	// return register, #@Ret

100     B8: #	out( B12 B9 ) &lt;- in( B3 B4 B5 )  Freq: 0.00299698
100 +   spill R12 -&gt; R11	# spill size = 64
104     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=R8 L[2]=#Ptr0x00000040d09f6e30 STK[0]=sp + #0
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=288/0x120}

120     B9: #	out( B6 ) &lt;- in( B8 )  Freq: 0.00299692
        # Block is sole successor of call
120 +   j  B6	#@branch

124     B10: #	out( N144 ) &lt;- in( B1 )  Freq: 1.01328e-06
124 +   li R11, #-10	# int, #@loadConI
128     spill R12 -&gt; R8	# spill size = 64
12c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8 STK[2]=#Ptr0x00000040d09f6e30
        # OopMap {fp=Oop off=304/0x130}
130     #@ShouldNotReachHere

13c     B11: #	out( N144 ) &lt;- in( B2 )  Freq: 4.76837e-07
13c +   li R11, #-187	# int, #@loadConI
140     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::hash @ bci:1 (line 338) L[0]=R8 L[1]=_ STK[0]=R8
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=R8 L[2]=#Ptr0x00000040d09f6e30 STK[0]=sp + #0
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=324/0x144}
144     #@ShouldNotReachHere

150     B12: #	out( B14 ) &lt;- in( B8 )  Freq: 2.99698e-08
150      -- 	// exception oop; no code emitted, #@CreateException
150 +   spill R10 -&gt; R11	# spill size = 64
154 +   j  B14	#@branch

158     B13: #	out( B14 ) &lt;- in( B6 )  Freq: 9.99998e-06
158      -- 	// exception oop; no code emitted, #@CreateException
158 +   spill R10 -&gt; R11	# spill size = 64

15c     B14: #	out( N144 ) &lt;- in( B12 B13 )  Freq: 1.003e-05
15c     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
168 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='478'>
----------------------- MetaData before Compile_id = 478 ------------------------
{method}
 - this oop:          0x000000409600fdc8
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000008  static 
 - name:              &apos;checkIndex&apos;
 - signature:         &apos;(II)V&apos;
 - max stack:         5
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x00000040083176f0: 0xaa i2c: 0x0000004013945f40 c2i: 0x0000004013945f88 c2iUV: 0x0000004013945f54
 - compiled entry     0x000000400c56cb00
 - code size:         48
 - code start:        0x000000409600fd70
 - code end (excl):   0x000000409600fda0
 - method data:       0x000000409658b428
 - checked ex length: 0
 - linenumber start:  0x000000409600fda0
 - localvar length:   2
 - localvar start:    0x000000409600fdae
 - compiled code: nmethod  19887  293       3       java.lang.String::checkIndex (48 bytes)

------------------------ OptoAssembly for Compile_id = 478 -----------------------
#
#  void ( int, int )
#
#r012 c_rarg1   : parm 0: int
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B4 B5 B3 )  Freq: 1

000     B1: #	out( B4 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     blt  R11, zr, B4	#@cmpI_reg_imm0_branch  P=0.000000 C=5139.000000

020     B2: #	out( B5 B3 ) &lt;- in( B1 )  Freq: 1
020 +   bge  R11, R12, B5	#@cmpI_branch  P=0.000000 C=5139.000000

024     B3: #	out( N1 ) &lt;- in( B2 )  Freq: 0.999999
024     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
03c +   ret	// return register, #@Ret

040     B4: #	out( N1 ) &lt;- in( B1 )  Freq: 5e-07
040 +   spill R11 -&gt; [sp, #4]	# spill size = 32
044 +   spill R12 -&gt; [sp, #0]	# spill size = 32
048 +   li R11, #-187	# int, #@loadConI
04c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkIndex @ bci:1 (line 4557) L[0]=sp + #4 L[1]=sp + #0 STK[0]=sp + #4
        # OopMap {off=80/0x50}
050     #@ShouldNotReachHere

05c     B5: #	out( N1 ) &lt;- in( B2 )  Freq: 4.76837e-07
05c +   spill R11 -&gt; [sp, #4]	# spill size = 32
060 +   spill R12 -&gt; [sp, #8]	# spill size = 32
064 +   li R11, #-187	# int, #@loadConI
068     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkIndex @ bci:6 (line 4557) L[0]=sp + #4 L[1]=sp + #8 STK[0]=sp + #4 STK[1]=sp + #8
        # OopMap {off=108/0x6c}
06c +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='479'>
----------------------- MetaData before Compile_id = 479 ------------------------
{method}
 - this oop:          0x00000040960b7f20
 - method holder:     &apos;java/lang/AbstractStringBuilder&apos;
 - constants:         0x00000040960b5e28 constant pool [547]/operands[14] {0x00000040960b5e28} for &apos;java/lang/AbstractStringBuilder&apos; cache=0x0000004096285bb8
 - access:            0x81000002  private 
 - name:              &apos;ensureCapacityInternal&apos;
 - signature:         &apos;(I)V&apos;
 - max stack:         5
 - max locals:        3
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bb30: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c4b4e40
 - code size:         39
 - code start:        0x00000040960b7ec0
 - code end (excl):   0x00000040960b7ee7
 - method data:       0x00000040963f4810
 - checked ex length: 0
 - linenumber start:  0x00000040960b7ee7
 - localvar length:   3
 - localvar start:    0x00000040960b7efa
 - compiled code: nmethod  19948   33       3       java.lang.AbstractStringBuilder::ensureCapacityInternal (39 bytes)

------------------------ OptoAssembly for Compile_id = 479 -----------------------
#
#  void ( java/lang/AbstractStringBuilder:NotNull *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/AbstractStringBuilder:NotNull *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N411: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B34 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/AbstractStringBuilder.value
040 +   lb  R29, [R11, #16]	# byte, #@loadB ! Field: java/lang/AbstractStringBuilder.coder
044     spill R11 -&gt; [sp, #0]	# spill size = 64
048 +   decode_heap_oop  R31, R7	#@decodeHeapOop
04c     lwu  R8, [R31, #12]	# range, #@loadRange
050     NullCheck R31

050     B2: #	out( B4 B3 ) &lt;- in( B1 )  Freq: 0.999999
050 +   sraw  R7, R8, R29	#@rShiftI_reg_reg
054 +   subw  R28, R12, R7	#@subI_reg_reg
058 +   bgt  R28, zr, B4	#@cmpI_reg_imm0_branch  P=0.055256 C=5375.000000

05c     B3: #	out( N411 ) &lt;- in( B22 B23 B20 B19 B18 B2 )  Freq: 0.999998
05c     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
074 +   ret	// return register, #@Ret

078     B4: #	out( B7 B5 ) &lt;- in( B2 )  Freq: 0.0552558
078 +   li R7, #2	# int, #@loadConI
07c +   sllw  R30, R12, R29	#@lShiftI_reg_reg
080 +   sllw  R28, R7, R29	#@lShiftI_reg_reg
084 +   subw  R12, R30, R8	#@subI_reg_reg
088 +   addw  R28, R28, R8	#@addI_reg_reg
08c     spill R12 -&gt; R7	# spill size = 32
090 +   CMove R7, (R12 lt R28), R7, R28	#@cmovI_cmpI
	
098 +   addw  R10, R7, R8	#@addI_reg_reg
09c +   li R7, #2147483639	# int, #@loadConI
0a4 +   addiw  R28, R10, #-1	#@addI_reg_imm
0a8 +   bltu  R28, R7, B7	#@cmpU_branch  P=0.500000 C=-1.000000

0ac     B5: #	out( B36 B6 ) &lt;- in( B4 )  Freq: 0.0276279
0ac +   spill R31 -&gt; [sp, #24]	# spill size = 64
0b0 +   spill R8 -&gt; R11	# spill size = 32
0b4     CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect jdk.internal.util.ArraysSupport::hugeLength
        # jdk.internal.util.ArraysSupport::newLength @ bci:23 (line 642) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.lang.AbstractStringBuilder::newCapacity @ bci:29 (line 257) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # java.lang.AbstractStringBuilder::ensureCapacityInternal @ bci:24 (line 229) L[0]=sp + #0 L[1]=_ L[2]=_ STK[0]=sp + #0 STK[1]=sp + #24
        # OopMap {[0]=Oop [24]=Oop off=184/0xb8}

0b8     B6: #	out( B7 ) &lt;- in( B5 )  Freq: 0.0276273
        # Block is sole successor of call
0b8 +   spill [sp, #24] -&gt; R31	# spill size = 64

0bc     B7: #	out( B30 B8 ) &lt;- in( B4 B6 )  Freq: 0.0552552
0bc +   spill [sp, #0] -&gt; R7	# spill size = 64
0c0 +   lb  R28, [R7, #16]	# byte, #@loadB ! Field: java/lang/AbstractStringBuilder.coder
0c4 +   sraw  R7, R10, R28	#@rShiftI_reg_reg
0c8 +   sllw  R7, R7, R28	#@lShiftI_reg_reg
0cc +   li R29, #2147483647	# int, #@loadConI
0d4     spill R7 -&gt; R28	# spill size = 32
0d8 +   li R30, #1048576	# int, #@loadConI
0dc +   CMove R28, (R8 lt R7), R28, R8	#@cmovI_cmpI
	
0e4     beq  R10, R29, B30	#@cmpI_branch  P=0.000001 C=-1.000000

0e8     B8: #	out( B9 B9 ) &lt;- in( B7 )  Freq: 0.0552552
0e8 +   addw  R29, R7, zr	#@convI2L_reg_reg
0ec +   bleu  R7, R30, B9	#@cmpU_branch  P=0.999999 C=-1.000000

0f0     B9: #	out( B32 B10 ) &lt;- in( B8 B8 )  Freq: 0.0552552
0f0 +   addi  R10, R29, #23	#@addL_reg_imm
0f4 +   bltu  R8, R28, B32	#@cmpU_branch  P=0.000001 C=-1.000000

0f8     B10: #	out( B32 B11 ) &lt;- in( B9 )  Freq: 0.0552551
0f8 +   bltu  R7, R28, B32	#@cmpU_branch  P=0.000001 C=-1.000000

0fc     B11: #	out( B28 B12 ) &lt;- in( B10 )  Freq: 0.0552551
0fc +   andi  R8, R10, #-8	#@andL_reg_imm
100 +   bgtu  R7, R30, B28	#@cmpU_branch  P=0.000001 C=-1.000000

104     B12: #	out( B28 B13 ) &lt;- in( B11 )  Freq: 0.055255
104 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
104     ld  R9, [R23, #288]	# ptr, #@loadP
108 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
108     ld  R30, [R23, #304]	# ptr, #@loadP
10c +   add R29, R9, R8	# ptr, #@addP_reg_reg
110 +   bgeu  R29, R30, B28	#@cmpP_branch  P=0.000100 C=-1.000000

114     B13: #	out( B14 ) &lt;- in( B12 )  Freq: 0.0552495
114 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
114     sd  R29, [R23, #288]	# ptr, #@storeP
118 +   li R29, #1	# long, #@loadConL
11c +   mv  R30, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
12c +   sd  R29, [R9]	# long, #@storeL
130 +   sw  R30, [R9, #8]	# compressed klass ptr, #@storeNKlass
134 +   sw  R7, [R9, #12]	# int, #@storeI

138     B14: #	out( B31 B15 ) &lt;- in( B29 B13 )  Freq: 0.0552551
138     
138 +   srli  R29, R10, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
13c +   # checkcastPP of R9, #@checkCastPP
13c     addi  R11, R9, #16	# ptr, #@addP_reg_imm
140 +   encode_heap_oop  R18, R9	#@encodeHeapOop
144 +   beq  R28, zr, B31	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

148     B15: #	out( B24 B16 ) &lt;- in( B14 )  Freq: 0.055255
148 +   addi  R10, R31, #16	# ptr, #@addP_reg_imm
14c +   blt  R28, R7, B24	#@cmpI_branch  P=0.001000 C=-1.000000

150     B16: #	out( B17 ) &lt;- in( B15 )  Freq: 0.0551997
150 +   addi  R7, R8, #-16	#@addL_reg_imm
154 +   srli  R12, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
158 +   CALL, runtime leaf nofp 0x000000401396d840	#@CallLeafNoFPDirect jlong_disjoint_arraycopy
        No JVM State Info
        # 

15c     B17: #	out( B25 B18 ) &lt;- in( B24 B16 B31 )  Freq: 0.0552551
15c     MEMBAR-store-store	#@membar_storestore
160 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
160     lb  R7, [R23, #56]	# byte, #@loadB
164 +   bne  R7, zr, B25	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

168     B18: #	out( B3 B19 ) &lt;- in( B33 B27 B25 B17 )  Freq: 0.0552551
168 +   spill [sp, #0] -&gt; R7	# spill size = 64
16c +   mv  R7, R7	# ptr -&gt; long, #@castP2X
16c +   mv  R28, R9	# ptr -&gt; long, #@castP2X
170 +   xorr  R28, R28, R7	#@xorL_reg_reg
174 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
178     spill [sp, #0] -&gt; R29	# spill size = 64
17c +   sw  R18, [R29, #20]	# compressed ptr, #@storeN ! Field: java/lang/AbstractStringBuilder.value
180 +   beq  R28, zr, B3	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

184     B19: #	out( B3 B20 ) &lt;- in( B18 )  Freq: 0.0551998
184 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
188 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
194 +   add R10, R28, R7	# ptr, #@addP_reg_reg
198 +   lb  R28, [R10]	# byte, #@loadB
19c +   li R7, #4	# int, #@loadConI
1a0 +   beq  R28, R7, B3	#@cmpI_branch  P=0.999000 C=-1.000000

1a4     B20: #	out( B3 B21 ) &lt;- in( B19 )  Freq: 5.51998e-05
1a4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a4     ld  R7, [R23, #64]	# int, #@loadL
1a8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a8     ld  R28, [R23, #80]	# ptr, #@loadP
1ac +   #@membar_volatile
	fence iorw iorw
1b0 +   lb  R30, [R10]	# byte, #@loadB
1b4 +   beq  R30, zr, B3	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1b8     B21: #	out( B23 B22 ) &lt;- in( B20 )  Freq: 2.75999e-05
1b8 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1bc +   bne  R7, zr, B23	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1c0     B22: #	out( B3 ) &lt;- in( B21 )  Freq: 1.38e-05
1c0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1c0     spill R23 -&gt; R11	# spill size = 64
1c4 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1f4 +   j  B3	#@branch

1f8     B23: #	out( B3 ) &lt;- in( B21 )  Freq: 1.38e-05
1f8 +   add R28, R28, R7	# ptr, #@addP_reg_reg
1fc +   addi  R7, R7, #-8	#@addL_reg_imm
200 +   sd  R10, [R28, #-8]	# ptr, #@storeP
204 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
204     sd  R7, [R23, #64]	# long, #@storeL
208 +   j  B3	#@branch

20c     B24: #	out( B17 ) &lt;- in( B15 )  Freq: 5.5255e-05
20c +   addw  R12, R28, zr	#@convI2L_reg_reg
210 +   addi  R7, R12, #16	#@addL_reg_imm
214 +   srli  R30, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
218 +   andi  R7, R7, #-8	#@andL_reg_imm
21c +   add R28, R9, R7	# ptr, #@addP_reg_reg
220 +   sub  R29, R29, R30	#@subL_reg_reg
224     ClearArray R29, R28	#@clearArray_reg_reg
27c +   CALL, runtime leaf nofp 0x000000401396cf00	#@CallLeafNoFPDirect arrayof_jbyte_disjoint_arraycopy
        No JVM State Info
        # 
280 +   j  B17	#@branch

284     B25: #	out( B18 B26 ) &lt;- in( B17 )  Freq: 5.52543e-05
284 +   spill [sp, #0] -&gt; R7	# spill size = 64
288 +   lwu  R28, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/AbstractStringBuilder.value
28c +   decode_heap_oop  R10, R28	#@decodeHeapOop
290 +   beq   R10, zr, B18	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

294     B26: #	out( B33 B27 ) &lt;- in( B25 )  Freq: 2.76272e-05
294 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
294     ld  R7, [R23, #32]	# int, #@loadL
298 +   beq  R7, zr, B33	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

29c     B27: #	out( B18 ) &lt;- in( B26 )  Freq: 2.75995e-05
29c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
29c     ld  R28, [R23, #48]	# ptr, #@loadP
2a0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
2a4 +   addi  R7, R7, #-8	#@addL_reg_imm
2a8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
2ac +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2ac     sd  R7, [R23, #32]	# long, #@storeL
2b0 +   j  B18	#@branch

2b4     B28: #	out( B35 B29 ) &lt;- in( B11 B12 )  Freq: 5.58241e-06
2b4 +   spill R10 -&gt; [sp, #24]	# spill size = 64
2b8 +   spill R28 -&gt; [sp, #12]	# spill size = 32
2bc +   spill R31 -&gt; [sp, #16]	# spill size = 64
2c0 +   spill R7 -&gt; [sp, #8]	# spill size = 32
2c4 +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
2dc     spill R7 -&gt; R12	# spill size = 32
2e0     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # java.util.Arrays::copyOf @ bci:1 (line 3537) L[0]=sp + #16 L[1]=sp + #8 L[2]=_
        # java.lang.AbstractStringBuilder::ensureCapacityInternal @ bci:32 (line 228) L[0]=_ L[1]=_ L[2]=_ STK[0]=sp + #0
        # OopMap {[0]=Oop [16]=Oop off=740/0x2e4}

2e4     B29: #	out( B14 ) &lt;- in( B28 )  Freq: 5.58229e-06
        # Block is sole successor of call
2e4 +   spill R10 -&gt; R9	# spill size = 64
2e8 +   spill [sp, #8] -&gt; R7	# spill size = 32
2ec +   spill [sp, #16] -&gt; R31	# spill size = 64
2f0 +   spill [sp, #12] -&gt; R28	# spill size = 32
2f4 +   spill [sp, #24] -&gt; R10	# spill size = 64
2f8 +   j  B14	#@branch

2fc     B30: #	out( N411 ) &lt;- in( B7 )  Freq: 5.5989e-08
2fc +   li R11, #117	# int, #@loadConI
300     spill [sp, #0] -&gt; R8	# spill size = 64
304 +   spill R31 -&gt; [sp, #8]	# spill size = 64
308     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos; index=&apos;117&apos;)
        # java.lang.AbstractStringBuilder::newCapacity @ bci:41 (line 259) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # java.lang.AbstractStringBuilder::ensureCapacityInternal @ bci:24 (line 229) L[0]=R8 L[1]=_ L[2]=_ STK[0]=R8 STK[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=780/0x30c}
30c     #@ShouldNotReachHere

318     B31: #	out( B17 ) &lt;- in( B14 )  Freq: 5.59888e-08
318 +   spill R11 -&gt; R28	# spill size = 64
31c +   addi  R29, R29, #-2	#@addL_reg_imm
320     ClearArray R29, R28	#@clearArray_reg_reg
378     
378 +   j  B17	#@branch

37c     B32: #	out( N411 ) &lt;- in( B9 B10 )  Freq: 1.1051e-07
37c +   spill [sp, #0] -&gt; R8	# spill size = 64
380 +   li R11, #-52	# int, #@loadConI
384     spill R31 -&gt; [sp, #0]	# spill size = 64
388 +   spill R7 -&gt; [sp, #12]	# spill size = 32
38c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # java.util.Arrays::copyOf @ bci:1 (line 3537) L[0]=sp + #0 L[1]=sp + #12 L[2]=_ STK[0]=sp + #12
        # java.lang.AbstractStringBuilder::ensureCapacityInternal @ bci:32 (line 228) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8
        # OopMap {fp=Oop [0]=Oop off=912/0x390}
390     #@ShouldNotReachHere

39c     B33: #	out( B18 ) &lt;- in( B26 )  Freq: 2.76268e-08
39c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
39c     spill R23 -&gt; R11	# spill size = 64
3a0 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
3d0 +   j  B18	#@branch

3d4     B34: #	out( N411 ) &lt;- in( B1 )  Freq: 1.01328e-06
3d4 +   li R11, #-10	# int, #@loadConI
3d8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.AbstractStringBuilder::ensureCapacityInternal @ bci:4 (line 226) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # OopMap {off=988/0x3dc}
3dc     #@ShouldNotReachHere

3e8     B35: #	out( B37 ) &lt;- in( B28 )  Freq: 5.58241e-11
3e8      -- 	// exception oop; no code emitted, #@CreateException
3e8 +   spill R10 -&gt; R11	# spill size = 64
3ec +   j  B37	#@branch

3f0     B36: #	out( B37 ) &lt;- in( B5 )  Freq: 2.76279e-07
3f0      -- 	// exception oop; no code emitted, #@CreateException
3f0 +   spill R10 -&gt; R11	# spill size = 64

3f4     B37: #	out( N411 ) &lt;- in( B36 B35 )  Freq: 2.76335e-07
3f4     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
400 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='480'>
----------------------- MetaData before Compile_id = 480 ------------------------
{method}
 - this oop:          0x000000409600b7b0
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;indexOf&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         4
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bb30: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c504d40
 - code size:         7
 - code start:        0x000000409600b788
 - code end (excl):   0x000000409600b78f
 - method data:       0x00000040964867d8
 - checked ex length: 0
 - linenumber start:  0x000000409600b78f
 - localvar length:   2
 - localvar start:    0x000000409600b796
 - compiled code: nmethod  20027  173       3       java.lang.String::indexOf (7 bytes)

------------------------ OptoAssembly for Compile_id = 480 -----------------------
#
#  int ( java/lang/String:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N96: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B6 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
040 +   lb  R29, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
044 +   decode_heap_oop  R7, R7	#@decodeHeapOop
048 +   srliw  R28, R12, (#8 &amp; 0x1f)	#@urShiftI_reg_imm
04c     spill R12 -&gt; R13	# spill size = 32
050 +   bne  R29, zr, B6	#@cmpI_reg_imm0_branch  P=0.000000 C=102022.000000

054     B2: #	out( B7 B3 ) &lt;- in( B1 )  Freq: 1
054 +   bne  R28, zr, B7	#@cmpI_reg_imm0_branch  P=0.000000 C=12924.000000

058     B3: #	out( B9 B4 ) &lt;- in( B2 )  Freq: 0.999999
058     lwu  R12, [R7, #12]	# range, #@loadRange
05c     NullCheck R7

05c     B4: #	out( B8 B5 ) &lt;- in( B3 )  Freq: 0.999998
05c +   bleu  R12, zr, B8	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=5375.000000

060     B5: #	out( N96 ) &lt;- in( B4 )  Freq: 0.999998
060 +   addi  R11, R7, #16	# ptr, #@addP_reg_imm
064 +   StringUTF16 IndexOf char[] R11,R12,R13 -&gt; R10
308 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
320 +   ret	// return register, #@Ret

324     B6: #	out( N96 ) &lt;- in( B1 )  Freq: 5e-07
324 +   spill R11 -&gt; R8	# spill size = 64
328 +   spill R12 -&gt; [sp, #0]	# spill size = 32
32c +   spill R29 -&gt; [sp, #4]	# spill size = 32
330 +   li R11, #-187	# int, #@loadConI
334     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #4
        # java.lang.String::indexOf @ bci:1 (line 2416) L[0]=R8 L[1]=sp + #0 L[2]=#0
        # java.lang.String::indexOf @ bci:3 (line 2373) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=824/0x338}
338     #@ShouldNotReachHere

344     B7: #	out( N96 ) &lt;- in( B2 )  Freq: 5e-07
344 +   li R11, #-187	# int, #@loadConI
348     spill R7 -&gt; R8	# spill size = 64
34c +   spill R12 -&gt; [sp, #0]	# spill size = 32
350 +   spill R28 -&gt; [sp, #4]	# spill size = 32
354     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::canEncode @ bci:4 (line 54) L[0]=_ STK[0]=sp + #4
        # java.lang.StringLatin1::indexOf @ bci:1 (line 203) L[0]=R8 L[1]=sp + #0 L[2]=#0 L[3]=_
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # java.lang.String::indexOf @ bci:3 (line 2373) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=856/0x358}
358     #@ShouldNotReachHere

364     B8: #	out( N96 ) &lt;- in( B4 )  Freq: 4.76836e-07
364 +   li R11, #-187	# int, #@loadConI
368     spill R7 -&gt; R8	# spill size = 64
36c +   spill R13 -&gt; [sp, #0]	# spill size = 32
370 +   spill R12 -&gt; [sp, #8]	# spill size = 32
374     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::indexOf @ bci:23 (line 209) L[0]=R8 L[1]=sp + #0 L[2]=#0 L[3]=sp + #8 STK[0]=#0 STK[1]=sp + #8
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # java.lang.String::indexOf @ bci:3 (line 2373) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=888/0x378}
378     #@ShouldNotReachHere

384     B9: #	out( N96 ) &lt;- in( B3 )  Freq: 1.01328e-06
384 +   li R11, #-10	# int, #@loadConI
388     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::indexOf @ bci:10 (line 206) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # java.lang.String::indexOf @ bci:3 (line 2373) L[0]=_ L[1]=_
        # OopMap {off=908/0x38c}
38c +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='484'>
----------------------- MetaData before Compile_id = 484 ------------------------
{method}
 - this oop:          0x00000040960be5d0
 - method holder:     &apos;java/lang/StringBuilder&apos;
 - constants:         0x00000040960bca60 constant pool [409] {0x00000040960bca60} for &apos;java/lang/StringBuilder&apos; cache=0x00000040962869e0
 - access:            0x81000001  public 
 - name:              &apos;append&apos;
 - signature:         &apos;(C)Ljava/lang/StringBuilder;&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    2
 - method size:       13
 - intrinsic id:      324 _StringBuilder_append_char
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bb30: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c4e0b00
 - code size:         8
 - code start:        0x00000040960be5a0
 - code end (excl):   0x00000040960be5a8
 - method data:       0x000000409658bd48
 - checked ex length: 0
 - linenumber start:  0x00000040960be5a8
 - localvar length:   2
 - localvar start:    0x00000040960be5ae
 - compiled code: nmethod  20117   93       3       java.lang.StringBuilder::append (8 bytes)

------------------------ OptoAssembly for Compile_id = 484 -----------------------
#
#  java/lang/StringBuilder:exact * ( java/lang/StringBuilder:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/StringBuilder:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N131: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B10 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lw  R7, [R11, #12]	# int, #@loadI ! Field: java/lang/AbstractStringBuilder.count
040 +   spill R12 -&gt; [sp, #16]	# spill size = 32
044 +   addiw  R12, R7, #1	#@addI_reg_imm
048     spill [sp, #16] -&gt; R7	# spill size = 32
04c +   spill R11 -&gt; [sp, #0]	# spill size = 64
050 +   srliw  R8, R7, (#8 &amp; 0x1f)	#@urShiftI_reg_imm
054     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.AbstractStringBuilder::ensureCapacityInternal
        # java.lang.AbstractStringBuilder::append @ bci:7 (line 802) L[0]=sp + #0 L[1]=sp + #16
        # java.lang.StringBuilder::append @ bci:2 (line 246) L[0]=sp + #0 L[1]=_
        # OopMap {[0]=Oop off=88/0x58}

058     B2: #	out( B8 B3 ) &lt;- in( B1 )  Freq: 0.99998
        # Block is sole successor of call
058 +   spill [sp, #0] -&gt; R7	# spill size = 64
05c +   lwu  R28, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/AbstractStringBuilder.value
060 +   lw  R29, [R7, #12]	# int, #@loadI ! Field: java/lang/AbstractStringBuilder.count
064 +   lb  R7, [R7, #16]	# byte, #@loadB ! Field: java/lang/AbstractStringBuilder.coder
068 +   decode_heap_oop  R30, R28	#@decodeHeapOop
06c +   bne  R7, zr, B8	#@cmpI_reg_imm0_branch  P=0.000000 C=5759.000000

070     B3: #	out( B9 B4 ) &lt;- in( B2 )  Freq: 0.999979
070 +   bne  R8, zr, B9	#@cmpI_reg_imm0_branch  P=0.000000 C=13237.000000

074     B4: #	out( B11 B5 ) &lt;- in( B3 )  Freq: 0.999979
074 +   spill [sp, #16] -&gt; R28	# spill size = 32
078 +   sext.b  R8, R28	# b2i, #@convB2I_reg_reg_b
07c +   addiw  R7, R29, #1	#@addI_reg_imm
080     spill [sp, #0] -&gt; R28	# spill size = 64
084 +   sw  R7, [R28, #12]	# int, #@storeI ! Field: java/lang/AbstractStringBuilder.count
088     lwu  R28, [R30, #12]	# range, #@loadRange
08c     NullCheck R30

08c     B5: #	out( B7 B6 ) &lt;- in( B4 )  Freq: 0.999978
08c +   bgeu  R29, R28, B7	#@cmpU_branch  P=0.000001 C=-1.000000

090     B6: #	out( N131 ) &lt;- in( B5 )  Freq: 0.999977
090 +   addw  R7, R29, zr	#@convI2L_reg_reg
094 +   add R7, R30, R7	# ptr, #@addP_reg_reg
098     spill [sp, #16] -&gt; R28	# spill size = 32
09c +   sb  R28, [R7, #16]	# byte, #@storeB
0a0     spill [sp, #0] -&gt; R10	# spill size = 64
0a4 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0bc +   ret	// return register, #@Ret

0c0     B7: #	out( N131 ) &lt;- in( B5 )  Freq: 1.01326e-06
0c0 +   li R11, #-28	# int, #@loadConI
0c4     spill R30 -&gt; [sp, #16]	# spill size = 64
0c8 +   spill R29 -&gt; [sp, #24]	# spill size = 32
0cc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.AbstractStringBuilder::append @ bci:41 (line 804) L[0]=sp + #0 L[1]=_ STK[0]=sp + #16 STK[1]=sp + #24 STK[2]=R8
        # java.lang.StringBuilder::append @ bci:2 (line 246) L[0]=sp + #0 L[1]=_
        # OopMap {[0]=Oop [16]=Oop off=208/0xd0}
0d0     #@ShouldNotReachHere

0dc     B8: #	out( N131 ) &lt;- in( B2 )  Freq: 4.9999e-07
0dc +   li R11, #-187	# int, #@loadConI
0e0     spill [sp, #0] -&gt; R8	# spill size = 64
0e4 +   spill R7 -&gt; [sp, #12]	# spill size = 32
0e8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.AbstractStringBuilder::isLatin1 @ bci:10 (line 1677) L[0]=_ STK[0]=sp + #12
        # java.lang.AbstractStringBuilder::append @ bci:11 (line 803) L[0]=R8 L[1]=sp + #16
        # java.lang.StringBuilder::append @ bci:2 (line 246) L[0]=R8 L[1]=_
        # OopMap {fp=Oop off=236/0xec}
0ec     #@ShouldNotReachHere

0f8     B9: #	out( N131 ) &lt;- in( B3 )  Freq: 4.9999e-07
0f8 +   li R11, #-187	# int, #@loadConI
0fc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::canEncode @ bci:4 (line 54) L[0]=_ STK[0]=R8
        # java.lang.AbstractStringBuilder::append @ bci:18 (line 803) L[0]=sp + #0 L[1]=sp + #16
        # java.lang.StringBuilder::append @ bci:2 (line 246) L[0]=sp + #0 L[1]=_
        # OopMap {[0]=Oop off=256/0x100}
100     #@ShouldNotReachHere

10c     B10: #	out( N131 ) &lt;- in( B1 )  Freq: 1e-05
10c      -- 	// exception oop; no code emitted, #@CreateException
10c +   spill R10 -&gt; R11	# spill size = 64
110 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
11c +   j rethrow_stub	#@RethrowException

124     B11: #	out( N131 ) &lt;- in( B4 )  Freq: 1.01326e-06
124 +   li R11, #-10	# int, #@loadConI
128     spill R29 -&gt; [sp, #0]	# spill size = 32
12c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.AbstractStringBuilder::append @ bci:41 (line 804) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=sp + #0 STK[2]=R8
        # java.lang.StringBuilder::append @ bci:2 (line 246) L[0]=_ L[1]=_
        # OopMap {off=304/0x130}
130 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='485'>
----------------------- MetaData before Compile_id = 485 ------------------------
{method}
 - this oop:          0x00000040960b9540
 - method holder:     &apos;java/lang/AbstractStringBuilder&apos;
 - constants:         0x00000040960b5e28 constant pool [547]/operands[14] {0x00000040960b5e28} for &apos;java/lang/AbstractStringBuilder&apos; cache=0x0000004096285bb8
 - access:            0x81000001  public 
 - name:              &apos;append&apos;
 - signature:         &apos;(C)Ljava/lang/AbstractStringBuilder;&apos;
 - max stack:         6
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      17
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bb30: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c4e1040
 - code size:         77
 - code start:        0x00000040960b94c8
 - code end (excl):   0x00000040960b9515
 - method data:       0x000000409658beb8
 - checked ex length: 0
 - linenumber start:  0x00000040960b9515
 - localvar length:   2
 - localvar start:    0x00000040960b9526
 - compiled code: nmethod  20143   94       3       java.lang.AbstractStringBuilder::append (77 bytes)

------------------------ OptoAssembly for Compile_id = 485 -----------------------
#
#  java/lang/AbstractStringBuilder * ( java/lang/AbstractStringBuilder:NotNull *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/AbstractStringBuilder:NotNull *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N127: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B10 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lw  R7, [R11, #12]	# int, #@loadI ! Field: java/lang/AbstractStringBuilder.count
040 +   spill R12 -&gt; [sp, #8]	# spill size = 32
044 +   addiw  R12, R7, #1	#@addI_reg_imm
048     spill [sp, #8] -&gt; R7	# spill size = 32
04c +   spill R11 -&gt; [sp, #0]	# spill size = 64
050 +   srliw  R8, R7, (#8 &amp; 0x1f)	#@urShiftI_reg_imm
054     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.AbstractStringBuilder::ensureCapacityInternal
        # java.lang.AbstractStringBuilder::append @ bci:7 (line 802) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop off=88/0x58}

058     B2: #	out( B8 B3 ) &lt;- in( B1 )  Freq: 0.99998
        # Block is sole successor of call
058 +   spill [sp, #0] -&gt; R7	# spill size = 64
05c +   lwu  R28, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/AbstractStringBuilder.value
060 +   lw  R29, [R7, #12]	# int, #@loadI ! Field: java/lang/AbstractStringBuilder.count
064 +   lb  R7, [R7, #16]	# byte, #@loadB ! Field: java/lang/AbstractStringBuilder.coder
068 +   decode_heap_oop  R30, R28	#@decodeHeapOop
06c +   bne  R7, zr, B8	#@cmpI_reg_imm0_branch  P=0.000000 C=5759.000000

070     B3: #	out( B9 B4 ) &lt;- in( B2 )  Freq: 0.999979
070 +   bne  R8, zr, B9	#@cmpI_reg_imm0_branch  P=0.000000 C=13237.000000

074     B4: #	out( B11 B5 ) &lt;- in( B3 )  Freq: 0.999979
074 +   spill [sp, #8] -&gt; R28	# spill size = 32
078 +   sext.b  R8, R28	# b2i, #@convB2I_reg_reg_b
07c +   addiw  R7, R29, #1	#@addI_reg_imm
080     spill [sp, #0] -&gt; R28	# spill size = 64
084 +   sw  R7, [R28, #12]	# int, #@storeI ! Field: java/lang/AbstractStringBuilder.count
088     lwu  R28, [R30, #12]	# range, #@loadRange
08c     NullCheck R30

08c     B5: #	out( B7 B6 ) &lt;- in( B4 )  Freq: 0.999978
08c +   bgeu  R29, R28, B7	#@cmpU_branch  P=0.000001 C=-1.000000

090     B6: #	out( N127 ) &lt;- in( B5 )  Freq: 0.999977
090 +   addw  R7, R29, zr	#@convI2L_reg_reg
094 +   add R7, R30, R7	# ptr, #@addP_reg_reg
098     spill [sp, #8] -&gt; R28	# spill size = 32
09c +   sb  R28, [R7, #16]	# byte, #@storeB
0a0     spill [sp, #0] -&gt; R10	# spill size = 64
0a4 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0bc +   ret	// return register, #@Ret

0c0     B7: #	out( N127 ) &lt;- in( B5 )  Freq: 1.01326e-06
0c0 +   li R11, #-28	# int, #@loadConI
0c4     spill R30 -&gt; [sp, #8]	# spill size = 64
0c8 +   spill R29 -&gt; [sp, #16]	# spill size = 32
0cc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.AbstractStringBuilder::append @ bci:41 (line 804) L[0]=sp + #0 L[1]=_ STK[0]=sp + #8 STK[1]=sp + #16 STK[2]=R8
        # OopMap {[0]=Oop [8]=Oop off=208/0xd0}
0d0     #@ShouldNotReachHere

0dc     B8: #	out( N127 ) &lt;- in( B2 )  Freq: 4.9999e-07
0dc +   spill [sp, #0] -&gt; R8	# spill size = 64
0e0 +   li R11, #-187	# int, #@loadConI
0e4     spill R7 -&gt; [sp, #4]	# spill size = 32
0e8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.AbstractStringBuilder::isLatin1 @ bci:10 (line 1677) L[0]=_ STK[0]=sp + #4
        # java.lang.AbstractStringBuilder::append @ bci:11 (line 803) L[0]=R8 L[1]=sp + #8
        # OopMap {fp=Oop off=236/0xec}
0ec     #@ShouldNotReachHere

0f8     B9: #	out( N127 ) &lt;- in( B3 )  Freq: 4.9999e-07
0f8 +   li R11, #-187	# int, #@loadConI
0fc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::canEncode @ bci:4 (line 54) L[0]=_ STK[0]=R8
        # java.lang.AbstractStringBuilder::append @ bci:18 (line 803) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop off=256/0x100}
100     #@ShouldNotReachHere

10c     B10: #	out( N127 ) &lt;- in( B1 )  Freq: 1e-05
10c      -- 	// exception oop; no code emitted, #@CreateException
10c +   spill R10 -&gt; R11	# spill size = 64
110 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
11c +   j rethrow_stub	#@RethrowException

124     B11: #	out( N127 ) &lt;- in( B4 )  Freq: 1.01326e-06
124 +   li R11, #-10	# int, #@loadConI
128     spill R29 -&gt; [sp, #0]	# spill size = 32
12c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.AbstractStringBuilder::append @ bci:41 (line 804) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=sp + #0 STK[2]=R8
        # OopMap {off=304/0x130}
130 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='486'>
----------------------- MetaData before Compile_id = 486 ------------------------
{method}
 - this oop:          0x0000004096009fe8
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;codePointAt&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         4
 - max locals:        3
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bb30: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c56be80
 - code size:         50
 - code start:        0x0000004096009f80
 - code end (excl):   0x0000004096009fb2
 - method data:       0x00000040964a2ff0
 - checked ex length: 0
 - linenumber start:  0x0000004096009fb2
 - localvar length:   3
 - localvar start:    0x0000004096009fc2
 - compiled code: nmethod  20165  292       3       java.lang.String::codePointAt (50 bytes)

------------------------ OptoAssembly for Compile_id = 486 -----------------------
#
#  int ( java/lang/String:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N66: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B5 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lwu  R28, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
040 +   lb  R7, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
044 +   decode_heap_oop  R28, R28	#@decodeHeapOop
048 +   bne  R7, zr, B5	#@cmpI_reg_imm0_branch  P=0.000000 C=103238.000000

04c     B2: #	out( B7 B3 ) &lt;- in( B1 )  Freq: 1
04c     lwu  R8, [R28, #12]	# range, #@loadRange
050     NullCheck R28

050     B3: #	out( B6 B4 ) &lt;- in( B2 )  Freq: 0.999999
050 +   bgeu  R12, R8, B6	#@cmpU_branch  P=0.000000 C=5140.000000

054     B4: #	out( N66 ) &lt;- in( B3 )  Freq: 0.999998
054 +   addw  R7, R12, zr	#@convI2L_reg_reg
058 +   add R7, R28, R7	# ptr, #@addP_reg_reg
05c +   lbu  R10, [R7, #16]	# byte, #@loadUB
060     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
078 +   ret	// return register, #@Ret

07c     B5: #	out( N66 ) &lt;- in( B1 )  Freq: 5e-07
07c +   spill R11 -&gt; R8	# spill size = 64
080 +   spill R12 -&gt; [sp, #0]	# spill size = 32
084 +   spill R7 -&gt; [sp, #4]	# spill size = 32
088 +   li R11, #-187	# int, #@loadConI
08c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #4
        # java.lang.String::codePointAt @ bci:1 (line 1539) L[0]=R8 L[1]=sp + #0 L[2]=_
        # OopMap {fp=Oop off=144/0x90}
090     #@ShouldNotReachHere

09c     B6: #	out( N66 ) &lt;- in( B3 )  Freq: 4.76836e-07
09c +   spill R11 -&gt; [sp, #0]	# spill size = 64
0a0 +   spill R12 -&gt; [sp, #12]	# spill size = 32
0a4 +   spill R12 -&gt; [sp, #16]	# spill size = 32
0a8 +   li R11, #-27	# int, #@loadConI
0ac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkIndex @ bci:1 (line 4557) L[0]=sp + #16 L[1]=R8 STK[0]=sp + #12
        # java.lang.String::codePointAt @ bci:13 (line 1540) L[0]=sp + #0 L[1]=sp + #12 L[2]=_
        # OopMap {[0]=Oop off=176/0xb0}
0b0     #@ShouldNotReachHere

0bc     B7: #	out( N66 ) &lt;- in( B2 )  Freq: 1.01328e-06
0bc +   li R11, #-10	# int, #@loadConI
0c0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::codePointAt @ bci:12 (line 1540) L[0]=_ L[1]=_ L[2]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=196/0xc4}
0c4 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='491'>
----------------------- MetaData before Compile_id = 491 ------------------------
{method}
 - this oop:          0x0000004096508178
 - method holder:     &apos;java/util/concurrent/locks/AbstractQueuedSynchronizer&apos;
 - constants:         0x0000004096505498 constant pool [349] {0x0000004096505498} for &apos;java/util/concurrent/locks/AbstractQueuedSynchronizer&apos; cache=0x0000004096508bb8
 - access:            0x81000011  public final 
 - name:              &apos;hasQueuedPredecessors&apos;
 - signature:         &apos;()Z&apos;
 - max stack:         3
 - max locals:        4
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c5096c0
 - code size:         58
 - code start:        0x0000004096508100
 - code end (excl):   0x000000409650813a
 - method data:       0x0000004096487dc8
 - checked ex length: 0
 - linenumber start:  0x000000409650813a
 - localvar length:   4
 - localvar start:    0x0000004096508146
 - compiled code: nmethod  20220  184       3       java.util.concurrent.locks.AbstractQueuedSynchronizer::hasQueuedPredecessors (58 bytes)

------------------------ OptoAssembly for Compile_id = 491 -----------------------
#
#  bool ( java/util/concurrent/locks/ReentrantReadWriteLock$FairSync:NotNull:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/concurrent/locks/ReentrantReadWriteLock$FairSync:NotNull:exact *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N36: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B3 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.head
040 +   #@membar_acquire
	fence ir iorw
044 +   decode_heap_oop  R7, R7	#@decodeHeapOop
048 +   bne   R7, zr, B3	#@cmpP_imm0_branch  P=0.000000 C=5375.000000

04c     B2: #	out( N36 ) &lt;- in( B1 )  Freq: 1
04c +   li R10, #0	# int, #@loadConI
050     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
068 +   ret	// return register, #@Ret

06c     B3: #	out( N36 ) &lt;- in( B1 )  Freq: 4.76837e-07
06c +   spill R11 -&gt; R8	# spill size = 64
070 +   spill R7 -&gt; [sp, #8]	# spill size = 64
074 +   li R11, #-187	# int, #@loadConI
078     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::hasQueuedPredecessors @ bci:8 (line 1234) L[0]=R8 L[1]=#NULL L[2]=sp + #8 L[3]=_ STK[0]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=124/0x7c}
07c +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='493'>
----------------------- MetaData before Compile_id = 493 ------------------------
{method}
 - this oop:          0x000000409629d2e0
 - method holder:     &apos;java/net/URI&apos;
 - constants:         0x0000004096296c30 constant pool [731] {0x0000004096296c30} for &apos;java/net/URI&apos; cache=0x000000409629e0a8
 - access:            0x8100000a  private static 
 - name:              &apos;match&apos;
 - signature:         &apos;(CJJ)Z&apos;
 - max stack:         5
 - max locals:        5
 - size of params:    5
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x00000040083a6200: 0xabebe i2c: 0x00000040139144c0 c2i: 0x000000401391450c c2iUV: 0x00000040139144d8
 - compiled entry     0x000000400c519380
 - code size:         56
 - code start:        0x000000409629d270
 - code end (excl):   0x000000409629d2a8
 - method data:       0x000000409648e1e8
 - checked ex length: 0
 - linenumber start:  0x000000409629d2a8
 - localvar length:   3
 - localvar start:    0x000000409629d2ba
 - compiled code: nmethod  20239  214       3       java.net.URI::match (56 bytes)

------------------------ OptoAssembly for Compile_id = 493 -----------------------
#
#  bool ( int, long, half, long, half )
#
#r012 c_rarg1   : parm 0: int
#r014 c_rarg2:c_rarg2   : parm 1: long
#r016 c_rarg3:c_rarg3   : parm 3: long
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B8 B7 B9 B10 B5 )  Freq: 1

000     B1: #	out( B8 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
01c     li R7, #1	# long, #@loadConL
020 +   li R28, #0	# long, #@loadConL
024 +   li R30, #64	# int, #@loadConI
028 +   beq  R11, zr, B8	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

02c     B2: #	out( B6 B3 ) &lt;- in( B1 )  Freq: 1
02c +   blt  R11, R30, B6	#@cmpI_branch  P=0.186977 C=5375.000000

030     B3: #	out( B9 B4 ) &lt;- in( B2 )  Freq: 0.813023
030 +   addiw  R29, R11, #-64	#@addI_reg_imm
034 +   sll  R7, R7, R29	#@lShiftL_reg_reg
038 +   li R30, #128	# int, #@loadConI
03c +   andr  R7, R7, R13	#@andL_reg_reg
040 +   bge  R11, R30, B9	#@cmpI_branch  P=0.000000 C=4370.000000

044     B4: #	out( B10 B5 ) &lt;- in( B3 )  Freq: 0.813022
044 +   beq  R7, zr, B10	#@cmpL_reg_imm0_branch  P=0.000000 C=4370.000000

048     B5: #	out( N1 ) &lt;- in( B6 B4 )  Freq: 0.999999
048 +   li R10, #1	# int, #@loadConI
04c     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

068     B6: #	out( B5 B7 ) &lt;- in( B2 )  Freq: 0.186977
068 +   sll  R7, R7, R11	#@lShiftL_reg_reg
06c +   andr  R7, R7, R12	#@andL_reg_reg
070 +   bne  R7, zr, B5	#@cmpL_reg_imm0_branch  P=1.000000 C=1005.000000

074     B7: #	out( N1 ) &lt;- in( B6 )  Freq: 8.91574e-08
074 +   slt   R8, R28, R7	#@cmpL3_reg_reg
	bnez  R8, done
	slt  R8, R7, R28
	neg   R8, R8	#@cmpL3_reg_reg
088     li R11, #-187	# int, #@loadConI
08c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.net.URI::match @ bci:19 (line 2642) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # OopMap {off=144/0x90}
090     #@ShouldNotReachHere

09c     B8: #	out( N1 ) &lt;- in( B1 )  Freq: 4.76837e-07
09c +   spill R11 -&gt; [sp, #16]	# spill size = 32
0a0 +   spill R12 -&gt; [sp, #0]	# spill size = 64
0a4 +   spill R13 -&gt; [sp, #8]	# spill size = 64
0a8 +   li R11, #-187	# int, #@loadConI
0ac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.net.URI::match @ bci:1 (line 2639) L[0]=sp + #16 L[1]=sp + #0 L[2]=_ L[3]=sp + #8 L[4]=_ STK[0]=sp + #16
        # OopMap {off=176/0xb0}
0b0     #@ShouldNotReachHere

0bc     B9: #	out( N1 ) &lt;- in( B3 )  Freq: 3.8768e-07
0bc +   spill R11 -&gt; [sp, #8]	# spill size = 32
0c0 +   spill R13 -&gt; [sp, #0]	# spill size = 64
0c4 +   li R11, #-187	# int, #@loadConI
0c8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.net.URI::match @ bci:32 (line 2643) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=_ STK[0]=sp + #8 STK[1]=#128
        # OopMap {off=204/0xcc}
0cc     #@ShouldNotReachHere

0d8     B10: #	out( N1 ) &lt;- in( B4 )  Freq: 3.87679e-07
0d8 +   slt   R8, R28, R7	#@cmpL3_reg_reg
	bnez  R8, done
	slt  R8, R7, R28
	neg   R8, R8	#@cmpL3_reg_reg
0ec     li R11, #-187	# int, #@loadConI
0f0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.net.URI::match @ bci:45 (line 2644) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # OopMap {off=244/0xf4}
0f4     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='495'>
----------------------- MetaData before Compile_id = 495 ------------------------
{method}
 - this oop:          0x00000040965f5868
 - method holder:     &apos;sun/nio/fs/UnixUriUtils&apos;
 - constants:         0x00000040965f4218 constant pool [305] {0x00000040965f4218} for &apos;sun/nio/fs/UnixUriUtils&apos; cache=0x00000040965f5b18
 - access:            0x8100000a  private static 
 - name:              &apos;match&apos;
 - signature:         &apos;(CJJ)Z&apos;
 - max stack:         5
 - max locals:        5
 - size of params:    5
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x00000040083a6200: 0xabebe i2c: 0x00000040139144c0 c2i: 0x000000401391450c c2iUV: 0x00000040139144d8
 - compiled entry     0x000000400c518c80
 - code size:         50
 - code start:        0x00000040965f5800
 - code end (excl):   0x00000040965f5832
 - method data:       0x000000409648dfc0
 - checked ex length: 0
 - linenumber start:  0x00000040965f5832
 - localvar length:   3
 - localvar start:    0x00000040965f5842
 - compiled code: nmethod  20388  213       3       sun.nio.fs.UnixUriUtils::match (50 bytes)

------------------------ OptoAssembly for Compile_id = 495 -----------------------
#
#  bool ( int, long, half, long, half )
#
#r012 c_rarg1   : parm 0: int
#r014 c_rarg2:c_rarg2   : parm 1: long
#r016 c_rarg3:c_rarg3   : parm 3: long
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B6 B7 B8 B4 )  Freq: 1

000     B1: #	out( B5 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     li R29, #64	# int, #@loadConI
020 +   li R7, #1	# long, #@loadConL
024 +   li R28, #0	# long, #@loadConL
028 +   blt  R11, R29, B5	#@cmpI_branch  P=0.177860 C=5375.000000

02c     B2: #	out( B7 B3 ) &lt;- in( B1 )  Freq: 0.82214
02c +   addiw  R30, R11, #-64	#@addI_reg_imm
030 +   sll  R7, R7, R30	#@lShiftL_reg_reg
034 +   li R29, #128	# int, #@loadConI
038 +   andr  R7, R7, R13	#@andL_reg_reg
03c +   bge  R11, R29, B7	#@cmpI_branch  P=0.000000 C=4419.000000

040     B3: #	out( B8 B4 ) &lt;- in( B2 )  Freq: 0.822139
040 +   beq  R7, zr, B8	#@cmpL_reg_imm0_branch  P=0.000000 C=4419.000000

044     B4: #	out( N1 ) &lt;- in( B5 B3 )  Freq: 0.999999
044 +   li R10, #1	# int, #@loadConI
048     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
060 +   ret	// return register, #@Ret

064     B5: #	out( B4 B6 ) &lt;- in( B1 )  Freq: 0.17786
064 +   sll  R7, R7, R11	#@lShiftL_reg_reg
068 +   andr  R7, R12, R7	#@andL_reg_reg
06c +   bne  R7, zr, B4	#@cmpL_reg_imm0_branch  P=1.000000 C=956.000000

070     B6: #	out( N1 ) &lt;- in( B5 )  Freq: 8.48105e-08
070 +   slt   R8, R28, R7	#@cmpL3_reg_reg
	bnez  R8, done
	slt  R8, R7, R28
	neg   R8, R8	#@cmpL3_reg_reg
084     li R11, #-187	# int, #@loadConI
088     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixUriUtils::match @ bci:13 (line 185) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # OopMap {off=140/0x8c}
08c     #@ShouldNotReachHere

098     B7: #	out( N1 ) &lt;- in( B2 )  Freq: 3.92027e-07
098 +   spill R11 -&gt; [sp, #8]	# spill size = 32
09c +   spill R13 -&gt; [sp, #0]	# spill size = 64
0a0 +   li R11, #-187	# int, #@loadConI
0a4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixUriUtils::match @ bci:26 (line 186) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=_ STK[0]=sp + #8 STK[1]=#128
        # OopMap {off=168/0xa8}
0a8     #@ShouldNotReachHere

0b4     B8: #	out( N1 ) &lt;- in( B3 )  Freq: 3.92027e-07
0b4 +   slt   R8, R28, R7	#@cmpL3_reg_reg
	bnez  R8, done
	slt  R8, R7, R28
	neg   R8, R8	#@cmpL3_reg_reg
0c8     li R11, #-187	# int, #@loadConI
0cc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixUriUtils::match @ bci:39 (line 187) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # OopMap {off=208/0xd0}
0d0     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='498'>
----------------------- MetaData before Compile_id = 498 ------------------------
{method}
 - this oop:          0x00000040963eb040
 - method holder:     &apos;java/lang/StringUTF16&apos;
 - constants:         0x00000040963e8a18 constant pool [598] {0x00000040963e8a18} for &apos;java/lang/StringUTF16&apos; cache=0x00000040963f0d90
 - access:            0xc1000009  public static 
 - name:              &apos;compress&apos;
 - signature:         &apos;([CI[BII)I&apos;
 - max stack:         4
 - max locals:        7
 - size of params:    5
 - method size:       13
 - intrinsic id:      89 _compressStringC
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008317550: 0xbabaa i2c: 0x0000004013945840 c2i: 0x0000004013945894 c2iUV: 0x0000004013945860
 - compiled entry     0x000000400c564bc0
 - code size:         50
 - code start:        0x00000040963eaf98
 - code end (excl):   0x00000040963eafca
 - method data:       0x00000040964a1db8
 - checked ex length: 0
 - linenumber start:  0x00000040963eafca
 - localvar length:   7
 - localvar start:    0x00000040963eafe2
 - compiled code: nmethod  20791  285       3       java.lang.StringUTF16::compress (50 bytes)

------------------------ OptoAssembly for Compile_id = 498 -----------------------
#
#  int ( char[int:&gt;=0]:exact *, int, byte[int:&gt;=0]:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: char[int:&gt;=0]:exact *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3:c_rarg3   : parm 2: byte[int:&gt;=0]:exact *
#r018 c_rarg4   : parm 3: int
#r020 c_rarg5   : parm 4: int
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B51 B60 B61 B41 B43 B50 B52 B58 B53 B57 B62 B63 B59 B54 B55 B56 )  Freq: 1

000     B1: #	out( B41 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
01c     spill R15 -&gt; R19	# spill size = 32
020 +   ble  R15, zr, B41	#@cmpI_reg_imm0_branch  P=0.047239 C=21656.000000

024     B2: #	out( B51 B3 ) &lt;- in( B1 )  Freq: 0.952761
024 +   li R18, #-2147483648	# int, #@loadConI
028 +   addiw  R30, R15, #-1	#@addI_reg_imm
02c     CMove R30, (R15 lt R30), R30, R18	#@cmovI_cmpI
	
034 +   addiw  R29, R12, #2	#@addI_reg_imm
038 +   addiw  R7, R12, #1	#@addI_reg_imm
03c +   addw  R31, R29, zr	#@convI2L_reg_reg
040 +   addw  R10, R7, zr	#@convI2L_reg_reg
044 +   sub  R29, x0, R10	# long, #@negL_reg
048 +   sub  R7, x0, R31	# long, #@negL_reg
04c +   li R28, #2147483647	# long, #@loadConL
054     spill R29 -&gt; R17	# spill size = 64
058 +   spill R7 -&gt; R15	# spill size = 64
05c +   CMove R17, (R29 gt R28), R17, R28	#@cmovL_cmpL
	
064     CMove R15, (R7 gt R28), R15, R28	#@cmovL_cmpL
	
06c +   addw  R28, R15, zr	#@convL2I_reg
070 +   li R16, #1	# int, #@loadConI
074 +   addw  R17, R17, zr	#@convL2I_reg
078 +   li R15, #1	# long, #@loadConL
07c     CMove R17, (R29 le R15), R17, R16	#@cmovI_cmpL
	
084 +   min  R29, R17, R19	#@minI_reg_reg_b
088 +   addw  R15, R29, zr	#@convI2L_reg_reg
08c     CMove R29, (R15 lt R7), R29, R28	#@cmovI_cmpL
	
094     lwu  R17, [R11, #12]	# range, #@loadRange
098     NullCheck R11

098     B3: #	out( B51 B4 ) &lt;- in( B2 )  Freq: 0.95276
098     lwu  R7, [R13, #12]	# range, #@loadRange
09c     NullCheck R13

09c     B4: #	out( B51 B5 ) &lt;- in( B3 )  Freq: 0.952759
09c +   addw  R9, R14, zr	#@convI2L_reg_reg
0a0 +   addw  R28, R19, zr	#@convI2L_reg_reg
0a4 +   add  R28, R28, R9	#@addL_reg_reg
0a8 +   addw  R25, R7, zr	#@convI2L_reg_reg
0ac +   addi  R28, R28, #-1	#@addL_reg_imm
0b0 +   bgeu  R14, R7, B51	#@cmpU_branch  P=0.000001 C=-1.000000

0b4     B5: #	out( B51 B6 ) &lt;- in( B4 )  Freq: 0.952758
0b4 +   bgeu  R28, R25, B51	#@cmpUL_branch  P=0.000001 C=-1.000000

0b8     B6: #	out( B7 ) &lt;- in( B5 )  Freq: 0.952757
0b8 +   min  R15, R29, R19	#@minI_reg_reg_b
0bc +   li R16, #255	# int, #@loadConI
0c0 +   li R7, #0	# int, #@loadConI
0c4 +   li R29, #0	# int, #@loadConI

0c8     B7: #	out( B43 B8 ) &lt;- in( B6 B10 ) Loop( B7-B10 inner pre of N217) Freq: 1.90551
0c8 +   addw  R28, R7, R12	#@addI_reg_reg
0cc +   addw  R7, R28, zr	#@convI2L_reg_reg
0d0 +   slli  R7, R7, (#1 &amp; 0x3f)	#@lShiftL_reg_imm
0d4 +   add R7, R11, R7	# ptr, #@addP_reg_reg
0d8 +   addw  R21, R29, R14	#@addI_reg_reg
0dc +   bgeu  R28, R17, B43	#@cmpU_branch  P=0.000001 C=-1.000000

0e0     B8: #	out( B50 B9 ) &lt;- in( B7 )  Freq: 1.90551
0e0 +   lhu  R20, [R7, #16]	# short, #@loadUS
0e4 +   bgt  R20, R16, B50	#@cmpI_branch  P=0.000000 C=20633.000000

0e8     B9: #	out( B11 B10 ) &lt;- in( B8 )  Freq: 1.90551
0e8 +   addw  R21, R29, zr	#@convI2L_reg_reg
0ec +   add  R22, R9, R21	#@addL_reg_reg
0f0 +   add R7, R13, R22	# ptr, #@addP_reg_reg
0f4 +   sb  R20, [R7, #16]	# byte, #@storeB
0f8 +   addiw  R7, R29, #1	#@addI_reg_imm
0fc +   bge  R7, R15, B11	#@cmpI_loop  P=0.500000 C=20633.000000

100     B10: #	out( B7 ) &lt;- in( B9 )  Freq: 0.952755
100 +   spill R7 -&gt; R29	# spill size = 32
104 +   j  B7	#@branch

108     B11: #	out( B34 B12 ) &lt;- in( B9 )  Freq: 0.952755
108 +   addw  R20, R17, zr	#@convI2L_reg_reg
10c +   sub  R28, R20, R10	#@subL_reg_reg
110 +   addw  R15, R28, zr	#@convL2I_reg
114 +   addw  R29, R30, zr	#@convI2L_reg_reg
118     CMove R30, (R29 gt R28), R30, R15	#@cmovI_cmpL
	
120 +   addiw  R29, R30, #-2	#@addI_reg_imm
124     CMove R29, (R30 lt R29), R29, R18	#@cmovI_cmpI
	
12c +   sub  R30, R20, R31	#@subL_reg_reg
130 +   addw  R28, R30, zr	#@convL2I_reg
134 +   addw  R15, R29, zr	#@convI2L_reg_reg
138     CMove R29, (R15 gt R30), R29, R28	#@cmovI_cmpL
	
140 +   bge  R7, R29, B34	#@cmpI_branch  P=0.000001 C=-1.000000

144     B12: #	out( B52 B13 ) &lt;- in( B11 )  Freq: 0.952754
144 +   spill R29 -&gt; [sp, #4]	# spill size = 32
148 +   spill R7 -&gt; R29	# spill size = 32
14c +   # castII of R29, #@castII
14c     addiw  R30, R29, #2	#@addI_reg_imm
150 +   addiw  R18, R30, #-2	#@addI_reg_imm
154     spill R25 -&gt; [sp, #8]	# spill size = 64
158 +   addiw  R28, R29, #4	#@addI_reg_imm
15c +   # castII of R18, #@castII
15c     addw  R25, R18, zr	#@convI2L_reg_reg
160 +   addiw  R30, R28, #-4	#@addI_reg_imm
164     spill R19 -&gt; [sp, #0]	# spill size = 32
168 +   add  R19, R10, R21	#@addL_reg_reg
16c +   addw  R24, R29, zr	#@convI2L_reg_reg
170 +   # castII of R30, #@castII
170     addw  R18, R30, zr	#@convI2L_reg_reg
174 +   add  R21, R24, R31	#@addL_reg_reg
178     spill R29 -&gt; R30	# spill size = 32
17c +   add  R31, R18, R31	#@addL_reg_reg
180 +   # castII of R30, #@castII
180     addw  R28, R30, zr	#@convI2L_reg_reg
184 +   addw  R26, R7, zr	#@convI2L_reg_reg
188 +   addi  R18, R19, #3	#@addL_reg_imm
18c +   add  R8, R10, R24	#@addL_reg_reg
190 +   add  R30, R26, R10	#@addL_reg_reg
194 +   addi  R19, R22, #4	#@addL_reg_imm
198 +   add  R28, R28, R9	#@addL_reg_reg
19c +   addw  R15, R12, zr	#@convI2L_reg_reg
1a0 +   add  R24, R9, R24	#@addL_reg_reg
1a4 +   add  R26, R9, R26	#@addL_reg_reg
1a8 +   add  R10, R25, R10	#@addL_reg_reg
1ac     spill [sp, #8] -&gt; R22	# spill size = 64
1b0 +   bgeu  R28, R22, B52	#@cmpUL_branch  P=0.000001 C=-1.000000

1b4     B13: #	out( B53 B14 ) &lt;- in( B12 )  Freq: 0.952753
1b4 +   spill R22 -&gt; R25	# spill size = 64
1b8 +   bgeu  R24, R25, B53	#@cmpUL_branch  P=0.000001 C=-1.000000

1bc     B14: #	out( B54 B15 ) &lt;- in( B13 )  Freq: 0.952752
1bc +   bgeu  R8, R20, B54	#@cmpUL_branch  P=0.000001 C=-1.000000

1c0     B15: #	out( B55 B16 ) &lt;- in( B14 )  Freq: 0.952751
1c0 +   bgeu  R10, R20, B55	#@cmpUL_branch  P=0.000001 C=-1.000000

1c4     B16: #	out( B56 B17 ) &lt;- in( B15 )  Freq: 0.95275
1c4 +   bgeu  R18, R20, B56	#@cmpUL_branch  P=0.000001 C=-1.000000

1c8     B17: #	out( B57 B18 ) &lt;- in( B16 )  Freq: 0.952749
1c8 +   bgeu  R30, R20, B57	#@cmpUL_branch  P=0.000001 C=-1.000000

1cc     B18: #	out( B58 B19 ) &lt;- in( B17 )  Freq: 0.952748
1cc +   bgeu  R26, R25, B58	#@cmpUL_branch  P=0.000001 C=-1.000000

1d0     B19: #	out( B59 B20 ) &lt;- in( B18 )  Freq: 0.952747
1d0 +   bgeu  R19, R25, B59	#@cmpUL_branch  P=0.000001 C=-1.000000

1d4     B20: #	out( B60 B21 ) &lt;- in( B19 )  Freq: 0.952746
1d4 +   bgeu  R21, R20, B60	#@cmpUL_branch  P=0.000001 C=-1.000000

1d8     B21: #	out( B61 B22 ) &lt;- in( B20 )  Freq: 0.952745
1d8 +   bgeu  R31, R20, B61	#@cmpUL_branch  P=0.000001 C=-1.000000

1dc     B22: #	out( B32 ) &lt;- in( B21 )  Freq: 0.952744
1dc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1dc     j  B32	#@branch

1e0     B23: #	out( B24 ) &lt;- in( B29 ) top-of-loop Freq: 406.254
1e0 +   spill R7 -&gt; R29	# spill size = 32

1e4     B24: #	out( B42 B25 ) &lt;- in( B32 B23 ) Loop( B24-B23 inner main of N186 strip mined) Freq: 426.397
1e4 +   addw  R28, R7, R12	#@addI_reg_reg
1e8 +   addw  R7, R28, zr	#@convI2L_reg_reg
1ec +   addw  R18, R29, zr	#@convI2L_reg_reg
1f0 +   slli  R7, R7, (#1 &amp; 0x3f)	#@lShiftL_reg_imm
1f4 +   add  R30, R15, R18	#@addL_reg_reg
1f8 +   addw  R31, R29, R12	#@addI_reg_reg
1fc +   add R7, R11, R7	# ptr, #@addP_reg_reg
200 +   slli  R30, R30, (#1 &amp; 0x3f)	#@lShiftL_reg_imm
204 +   addw  R20, R31, zr	#@convI2L_reg_reg
208 +   addw  R21, R29, R14	#@addI_reg_reg
20c +   bgeu  R28, R17, B42	#@cmpU_branch  P=0.000001 C=-1.000000

210     B25: #	out( B44 B26 ) &lt;- in( B24 )  Freq: 426.397
210 +   slli  R20, R20, (#1 &amp; 0x3f)	#@lShiftL_reg_imm
214 +   add  R18, R9, R18	#@addL_reg_reg
218 +   add R30, R11, R30	# ptr, #@addP_reg_reg
21c +   add R22, R11, R20	# ptr, #@addP_reg_reg
220 +   lhu  R7, [R7, #16]	# short, #@loadUS
224 +   add R24, R13, R18	# ptr, #@addP_reg_reg
228 +   lhu  R30, [R30, #18]	# short, #@loadUS
22c +   lhu  R20, [R22, #22]	# short, #@loadUS
230 +   lhu  R18, [R22, #20]	# short, #@loadUS
234 +   bgt  R7, R16, B44	#@cmpI_branch  P=0.000000 C=20633.000000

238     B26: #	out( B47 B27 ) &lt;- in( B25 )  Freq: 426.397
238 +   sb  R7, [R24, #16]	# byte, #@storeB
23c +   addw  R7, R21, zr	#@convI2L_reg_reg
240 +   bgt  R30, R16, B47	#@cmpI_branch  P=0.000000 C=20633.000000

244     B27: #	out( B45 B28 ) &lt;- in( B26 )  Freq: 426.397
244 +   add R7, R13, R7	# ptr, #@addP_reg_reg
248 +   sb  R30, [R24, #17]	# byte, #@storeB
24c +   bgt  R18, R16, B45	#@cmpI_branch  P=0.000000 C=20633.000000

250     B28: #	out( B48 B29 ) &lt;- in( B27 )  Freq: 426.396
250 +   sb  R18, [R7, #18]	# byte, #@storeB
254 +   bgt  R20, R16, B48	#@cmpI_branch  P=0.000000 C=20633.000000

258     B29: #	out( B23 B30 ) &lt;- in( B28 )  Freq: 426.396
258 +   sb  R20, [R7, #19]	# byte, #@storeB
25c +   addiw  R7, R29, #4	#@addI_reg_imm
260 +   blt  R7, R19, B23	#@cmpI_loop  P=0.952761 C=20633.000000

264     B30: #	out( B33 B31 ) &lt;- in( B29 )  Freq: 20.1424
264 +   addiw  R29, R31, #4	#@addI_reg_imm
268 +   addiw  R31, R21, #4	#@addI_reg_imm
26c +   ld  R28, [R23, #920]	# ptr, #@loadP
270 +   lwu zr, [R28]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringUTF16::compress @ bci:44 (line 179) L[0]=R11 L[1]=R29 L[2]=R13 L[3]=R31 L[4]=sp + #0 L[5]=R7 L[6]=_
        # OopMap {c_rarg1=Oop c_rarg3=Oop off=624/0x270}
274 +   bge  R7, R10, B33	#@cmpI_branch  P=0.047239 C=20633.000000

278     B31: #	out( B32 ) &lt;- in( B30 )  Freq: 19.1909
278 +   spill R7 -&gt; R29	# spill size = 32
27c +   spill R10 -&gt; [sp, #4]	# spill size = 32

280     B32: #	out( B24 ) &lt;- in( B22 B31 ) Loop( B32-B31 ) Freq: 20.1436
280 +   spill [sp, #4] -&gt; R10	# spill size = 32
284 +   li R31, #0	# int, #@loadConI
288 +   subw  R30, R10, R29	#@subI_reg_reg
28c     CMove R30, (R10 lt R29), R30, R31	#@cmovI_cmpI
	
294 +   li R18, #4000	# int, #@loadConI
29c +   li R28, #4000	# int, #@loadConI
2a4     CMove R30, (R30 gtu R28), R30, R18	#@cmovI_cmpU
	
2ac +   addw  R19, R30, R29	#@addI_reg_reg
2b0 +   j  B24	#@branch

2b4     B33: #	out( B34 ) &lt;- in( B30 )  Freq: 0.951499
2b4 +   spill [sp, #0] -&gt; R19	# spill size = 32

2b8     B34: #	out( B41 B35 ) &lt;- in( B11 B33 )  Freq: 0.9515
2b8 +   bge  R7, R19, B41	#@cmpI_branch  P=0.500000 C=-1.000000

2bc     B35: #	out( B62 B36 ) &lt;- in( B34 )  Freq: 0.47575
2bc +   spill R7 -&gt; R29	# spill size = 32
2c0 +   # castII of R29, #@castII
2c0     spill R29 -&gt; R30	# spill size = 32
2c4 +   addw  R28, R29, zr	#@convI2L_reg_reg
2c8 +   # castII of R30, #@castII
2c8     addw  R30, R30, zr	#@convI2L_reg_reg
2cc +   add  R28, R28, R9	#@addL_reg_reg
2d0 +   add  R30, R30, R9	#@addL_reg_reg
2d4 +   bgeu  R28, R25, B62	#@cmpUL_branch  P=0.000001 C=-1.000000

2d8     B36: #	out( B63 B37 ) &lt;- in( B35 )  Freq: 0.475749
2d8 +   bgeu  R30, R25, B63	#@cmpUL_branch  P=0.000001 C=-1.000000

2dc     B37: #	out( B43 B38 ) &lt;- in( B36 B40 ) Loop( B37-B40 inner post of N217) Freq: 0.951496
2dc +   addw  R28, R7, R12	#@addI_reg_reg
2e0 +   addw  R7, R28, zr	#@convI2L_reg_reg
2e4 +   slli  R7, R7, (#1 &amp; 0x3f)	#@lShiftL_reg_imm
2e8 +   add R7, R11, R7	# ptr, #@addP_reg_reg
2ec +   addw  R21, R29, R14	#@addI_reg_reg
2f0 +   bgeu  R28, R17, B43	#@cmpU_branch  P=0.000001 C=-1.000000

2f4     B38: #	out( B50 B39 ) &lt;- in( B37 )  Freq: 0.951495
2f4 +   lhu  R20, [R7, #16]	# short, #@loadUS
2f8 +   addw  R7, R29, zr	#@convI2L_reg_reg
2fc +   add  R7, R7, R9	#@addL_reg_reg
300 +   add R7, R13, R7	# ptr, #@addP_reg_reg
304 +   bgt  R20, R16, B50	#@cmpI_branch  P=0.000000 C=20633.000000

308     B39: #	out( B41 B40 ) &lt;- in( B38 )  Freq: 0.951495
308 +   sb  R20, [R7, #16]	# byte, #@storeB
30c +   addiw  R7, R29, #1	#@addI_reg_imm
310 +   bge  R7, R19, B41	#@cmpI_loop  P=0.500000 C=20633.000000

314     B40: #	out( B37 ) &lt;- in( B39 )  Freq: 0.475747
314 +   spill R7 -&gt; R29	# spill size = 32
318 +   j  B37	#@branch

31c     B41: #	out( N1 ) &lt;- in( B1 B39 B34 )  Freq: 0.998736
31c +   spill R19 -&gt; R10	# spill size = 32
320 +   # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
338 +   ret	// return register, #@Ret

33c     B42: #	out( B43 ) &lt;- in( B24 )  Freq: 0.00043206
33c +   spill [sp, #0] -&gt; R19	# spill size = 32

340     B43: #	out( N1 ) &lt;- in( B37 B7 B42 )  Freq: 0.000434954
340 +   spill R11 -&gt; [sp, #24]	# spill size = 64
344 +   spill R13 -&gt; [sp, #8]	# spill size = 64
348 +   spill R21 -&gt; [sp, #4]	# spill size = 32
34c +   spill R19 -&gt; [sp, #16]	# spill size = 32
350 +   spill R29 -&gt; [sp, #20]	# spill size = 32
354 +   spill R28 -&gt; [sp, #32]	# spill size = 32
358 +   li R11, #-28	# int, #@loadConI
35c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.StringUTF16::compress @ bci:12 (line 180) L[0]=sp + #24 L[1]=sp + #32 L[2]=sp + #8 L[3]=sp + #4 L[4]=sp + #16 L[5]=sp + #20 L[6]=_ STK[0]=sp + #24 STK[1]=sp + #32
        # OopMap {[8]=Oop [24]=Oop off=864/0x360}
360     #@ShouldNotReachHere

36c     B44: #	out( B46 ) &lt;- in( B25 )  Freq: 0.000203322
36c +   spill R7 -&gt; R18	# spill size = 32
370 +   j  B46	#@branch

374     B45: #	out( B46 ) &lt;- in( B27 )  Freq: 0.000203322
374 +   addiw  R28, R31, #2	#@addI_reg_imm
378 +   # castII of R29, #@castII
378     addiw  R29, R29, #2	#@addI_reg_imm
37c +   addiw  R21, R21, #2	#@addI_reg_imm

380     B46: #	out( B49 ) &lt;- in( B44 B45 )  Freq: 0.000406644
380     spill R18 -&gt; R20	# spill size = 32
384 +   j  B49	#@branch

388     B47: #	out( B49 ) &lt;- in( B26 )  Freq: 0.000203322
388 +   addiw  R29, R29, #1	#@addI_reg_imm
38c +   addiw  R28, R31, #1	#@addI_reg_imm
390 +   addiw  R21, R21, #1	#@addI_reg_imm
394     spill R30 -&gt; R20	# spill size = 32
398 +   j  B49	#@branch

39c     B48: #	out( B49 ) &lt;- in( B28 )  Freq: 0.000203322
39c +   addiw  R29, R29, #3	#@addI_reg_imm
3a0 +   addiw  R28, R31, #3	#@addI_reg_imm
3a4 +   addiw  R21, R21, #3	#@addI_reg_imm

3a8     B49: #	out( B50 ) &lt;- in( B46 B47 B48 )  Freq: 0.000813287
3a8     spill [sp, #0] -&gt; R19	# spill size = 32

3ac     B50: #	out( N1 ) &lt;- in( B38 B8 B49 )  Freq: 0.000814649
3ac +   spill R11 -&gt; R8	# spill size = 64
3b0 +   spill R28 -&gt; [sp, #0]	# spill size = 32
3b4 +   spill R13 -&gt; [sp, #8]	# spill size = 64
3b8 +   spill R21 -&gt; [sp, #4]	# spill size = 32
3bc +   spill R19 -&gt; [sp, #16]	# spill size = 32
3c0 +   spill R29 -&gt; [sp, #20]	# spill size = 32
3c4 +   spill R20 -&gt; [sp, #28]	# spill size = 32
3c8 +   li R11, #-187	# int, #@loadConI
3cc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringUTF16::compress @ bci:20 (line 181) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #4 L[4]=sp + #16 L[5]=sp + #20 L[6]=sp + #28 STK[0]=sp + #28 STK[1]=#255
        # OopMap {fp=Oop [8]=Oop off=976/0x3d0}
3d0     #@ShouldNotReachHere

3dc     B51: #	out( N1 ) &lt;- in( B5 B2 B3 B4 )  Freq: 3.86165e-06
3dc +   spill R11 -&gt; R8	# spill size = 64
3e0 +   spill R12 -&gt; [sp, #0]	# spill size = 32
3e4 +   spill R13 -&gt; [sp, #8]	# spill size = 64
3e8 +   spill R14 -&gt; [sp, #4]	# spill size = 32
3ec +   spill R19 -&gt; [sp, #20]	# spill size = 32
3f0 +   li R11, #-138	# int, #@loadConI
3f4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringUTF16::compress @ bci:7 (line 179) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #4 L[4]=sp + #20 L[5]=#0 L[6]=_ STK[0]=#0 STK[1]=sp + #20
        # OopMap {fp=Oop [8]=Oop off=1016/0x3f8}
3f8     #@ShouldNotReachHere

404     B52: #	out( N1 ) &lt;- in( B12 )  Freq: 9.65405e-07
404     #@ShouldNotReachHere

410     B53: #	out( N1 ) &lt;- in( B13 )  Freq: 9.65404e-07
410     #@ShouldNotReachHere

41c     B54: #	out( N1 ) &lt;- in( B14 )  Freq: 9.65403e-07
41c     #@ShouldNotReachHere

428     B55: #	out( N1 ) &lt;- in( B15 )  Freq: 9.65402e-07
428     #@ShouldNotReachHere

434     B56: #	out( N1 ) &lt;- in( B16 )  Freq: 9.65401e-07
434     #@ShouldNotReachHere

440     B57: #	out( N1 ) &lt;- in( B17 )  Freq: 9.654e-07
440     #@ShouldNotReachHere

44c     B58: #	out( N1 ) &lt;- in( B18 )  Freq: 9.65399e-07
44c     #@ShouldNotReachHere

458     B59: #	out( N1 ) &lt;- in( B19 )  Freq: 9.65398e-07
458     #@ShouldNotReachHere

464     B60: #	out( N1 ) &lt;- in( B20 )  Freq: 9.65397e-07
464     #@ShouldNotReachHere

470     B61: #	out( N1 ) &lt;- in( B21 )  Freq: 9.65396e-07
470     #@ShouldNotReachHere

47c     B62: #	out( N1 ) &lt;- in( B35 )  Freq: 4.82067e-07
47c     #@ShouldNotReachHere

488     B63: #	out( N1 ) &lt;- in( B36 )  Freq: 4.82067e-07
488     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='499'>
----------------------- MetaData before Compile_id = 499 ------------------------
{method}
 - this oop:          0x0000004096534930
 - method holder:     &apos;jdk/internal/module/ModuleInfo$CountingDataInput&apos;
 - constants:         0x0000004096533c18 constant pool [122] {0x0000004096533c18} for &apos;jdk/internal/module/ModuleInfo$CountingDataInput&apos; cache=0x0000004096534f58
 - access:            0x81000001  public 
 - name:              &apos;readUnsignedShort&apos;
 - signature:         &apos;()I&apos;
 - max stack:         6
 - max locals:        2
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      12
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c563d00
 - code size:         24
 - code start:        0x00000040965348f0
 - code end (excl):   0x0000004096534908
 - method data:       0x00000040964a19f8
 - checked ex length: 1
 - checked ex start:  0x000000409653492c
 - linenumber start:  0x0000004096534908
 - localvar length:   2
 - localvar start:    0x0000004096534912
 - compiled code: nmethod  20837  283       3       jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort (24 bytes)

------------------------ OptoAssembly for Compile_id = 499 -----------------------
#
#  int ( jdk/internal/module/ModuleInfo$CountingDataInput:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: jdk/internal/module/ModuleInfo$CountingDataInput:NotNull *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N185: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B18 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R28, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/module/ModuleInfo$CountingDataInput.delegate
040 +   spill R11 -&gt; [sp, #0]	# spill size = 64
044 +   decode_heap_oop  R8, R28	#@decodeHeapOop
048     lwu  R7, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
04c     NullCheck R8

04c     B2: #	out( B11 B3 ) &lt;- in( B1 )  Freq: 0.999999
04c +   mv  R29, narrowklass: precise klass java/io/DataInputStream: 0x00000040d09cc610:Constant:exact *	# compressed klass ptr, #@loadConNKlass
05c +   bne  R7, R29, B11	#@cmpN_branch  P=0.000001 C=-1.000000

060     B3: #	out( B19 B4 ) &lt;- in( B2 )  Freq: 0.999998
060 +   # checkcastPP of R8, #@checkCastPP
060     lwu  R7, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: volatile java/io/FilterInputStream.in
064 +   #@membar_acquire
	fence ir iorw
068 +   decode_heap_oop  R29, R7	#@decodeHeapOop
06c     lwu  R28, [R29, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
070     NullCheck R29

070     B4: #	out( B12 B5 ) &lt;- in( B3 )  Freq: 0.999997
070 +   mv  R7, narrowklass: precise klass java/io/BufferedInputStream: 0x00000040d09d03a0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
080 +   bne  R28, R7, B12	#@cmpN_branch  P=0.000001 C=-1.000000

084     B5: #	out( B15 B6 ) &lt;- in( B4 )  Freq: 0.999996
084 +   # checkcastPP of R29, #@checkCastPP
084     spill R29 -&gt; R11	# spill size = 64
088     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.io.BufferedInputStream::read
        # java.io.DataInputStream::readUnsignedShort @ bci:4 (line 343) L[0]=R8 L[1]=_ L[2]=_
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=sp + #0 L[1]=_
        # OopMap {fp=Oop [0]=Oop off=140/0x8c}

08c     B6: #	out( B20 B7 ) &lt;- in( B5 )  Freq: 0.999976
        # Block is sole successor of call
08c +   lwu  R28, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: volatile java/io/FilterInputStream.in
090 +   #@membar_acquire
	fence ir iorw
094     spill R10 -&gt; [sp, #8]	# spill size = 32
098 +   decode_heap_oop  R28, R28	#@decodeHeapOop
09c     lwu  R7, [R28, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0a0     NullCheck R28

0a0     B7: #	out( B13 B8 ) &lt;- in( B6 )  Freq: 0.999975
0a0 +   mv  R29, narrowklass: precise klass java/io/BufferedInputStream: 0x00000040d09d03a0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0b0 +   bne  R7, R29, B13	#@cmpN_branch  P=0.000001 C=-1.000000

0b4     B8: #	out( B16 B9 ) &lt;- in( B7 )  Freq: 0.999974
0b4 +   # checkcastPP of R28, #@checkCastPP
0b4     spill R28 -&gt; R11	# spill size = 64
0b8     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.io.BufferedInputStream::read
        # java.io.DataInputStream::readUnsignedShort @ bci:12 (line 344) L[0]=_ L[1]=sp + #8 L[2]=_
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=sp + #0 L[1]=_
        # OopMap {[0]=Oop off=188/0xbc}

0bc     B9: #	out( B14 B10 ) &lt;- in( B8 )  Freq: 0.999954
        # Block is sole successor of call
0bc +   spill [sp, #8] -&gt; R29	# spill size = 32
0c0 +   orr  R8, R29, R10	#@orI_reg_reg
0c4 +   blt  R8, zr, B14	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

0c8     B10: #	out( N185 ) &lt;- in( B9 )  Freq: 0.999953
0c8 +   spill [sp, #0] -&gt; R7	# spill size = 64
0cc +   ld  R7, [R7, #16]	# int, #@loadL ! Field: jdk/internal/module/ModuleInfo$CountingDataInput.count
0d0 +   slliw  R28, R29, (#8 &amp; 0x1f)	#@lShiftI_reg_imm
0d4 +   addw  R10, R28, R10	#@addI_reg_reg
0d8 +   addi  R7, R7, #2	#@addL_reg_imm
0dc     spill [sp, #0] -&gt; R28	# spill size = 64
0e0 +   sd  R7, [R28, #16]	# long, #@storeL ! Field: jdk/internal/module/ModuleInfo$CountingDataInput.count
0e4     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0fc +   ret	// return register, #@Ret

100     B11: #	out( N185 ) &lt;- in( B2 )  Freq: 9.99999e-07
100 +   li R11, #-34	# int, #@loadConI
104     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=sp + #0 L[1]=_ STK[0]=R8
        # OopMap {fp=Oop [0]=Oop off=264/0x108}
108     #@ShouldNotReachHere

114     B12: #	out( N185 ) &lt;- in( B4 )  Freq: 9.99997e-07
114 +   li R11, #-34	# int, #@loadConI
118     spill R29 -&gt; [sp, #8]	# spill size = 64
11c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:4 (line 343) L[0]=R8 L[1]=_ L[2]=_ STK[0]=sp + #8
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=sp + #0 L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=288/0x120}
120     #@ShouldNotReachHere

12c     B13: #	out( N185 ) &lt;- in( B7 )  Freq: 9.99975e-07
12c +   spill [sp, #0] -&gt; R8	# spill size = 64
130 +   li R11, #-34	# int, #@loadConI
134     spill R28 -&gt; [sp, #0]	# spill size = 64
138     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:12 (line 344) L[0]=_ L[1]=sp + #8 L[2]=_ STK[0]=sp + #0
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=R8 L[1]=_
        # OopMap {fp=Oop [0]=Oop off=316/0x13c}
13c     #@ShouldNotReachHere

148     B14: #	out( N185 ) &lt;- in( B9 )  Freq: 4.76815e-07
148 +   li R11, #-187	# int, #@loadConI
14c     spill R10 -&gt; [sp, #12]	# spill size = 32
150     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:19 (line 345) L[0]=_ L[1]=sp + #8 L[2]=sp + #12 STK[0]=R8
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=sp + #0 L[1]=_
        # OopMap {[0]=Oop off=340/0x154}
154     #@ShouldNotReachHere

160     B15: #	out( B17 ) &lt;- in( B5 )  Freq: 9.99996e-06
160      -- 	// exception oop; no code emitted, #@CreateException
160 +   spill R10 -&gt; R11	# spill size = 64
164 +   j  B17	#@branch

168     B16: #	out( B17 ) &lt;- in( B8 )  Freq: 9.99974e-06
168      -- 	// exception oop; no code emitted, #@CreateException
168 +   spill R10 -&gt; R11	# spill size = 64

16c     B17: #	out( N185 ) &lt;- in( B15 B16 )  Freq: 1.99997e-05
16c     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
178 +   j rethrow_stub	#@RethrowException

180     B18: #	out( N185 ) &lt;- in( B1 )  Freq: 1.01328e-06
180 +   li R11, #-10	# int, #@loadConI
184     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=_ L[1]=_ STK[0]=#NULL
        # OopMap {off=392/0x188}
188     #@ShouldNotReachHere

194     B19: #	out( N185 ) &lt;- in( B3 )  Freq: 1.01328e-06
194 +   li R11, #-10	# int, #@loadConI
198     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:4 (line 343) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=_ L[1]=_
        # OopMap {off=412/0x19c}
19c     #@ShouldNotReachHere

1a8     B20: #	out( N185 ) &lt;- in( B6 )  Freq: 1.01325e-06
1a8 +   li R11, #-10	# int, #@loadConI
1ac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:12 (line 344) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=_ L[1]=_
        # OopMap {off=432/0x1b0}
1b0 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='500'>
----------------------- MetaData before Compile_id = 500 ------------------------
{method}
 - this oop:          0x0000004096532bc8
 - method holder:     &apos;java/io/DataInputStream&apos;
 - constants:         0x0000004096530ee8 constant pool [187] {0x0000004096530ee8} for &apos;java/io/DataInputStream&apos; cache=0x0000004096533738
 - access:            0x81000011  public final 
 - name:              &apos;readUnsignedShort&apos;
 - signature:         &apos;()I&apos;
 - max stack:         4
 - max locals:        3
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c564340
 - code size:         39
 - code start:        0x0000004096532b68
 - code end (excl):   0x0000004096532b8f
 - method data:       0x00000040964a1ba8
 - checked ex length: 1
 - checked ex start:  0x0000004096532bc4
 - linenumber start:  0x0000004096532b8f
 - localvar length:   3
 - localvar start:    0x0000004096532b9e
 - compiled code: nmethod  20863  284       3       java.io.DataInputStream::readUnsignedShort (39 bytes)

------------------------ OptoAssembly for Compile_id = 500 -----------------------
#
#  int ( java/io/DataInputStream:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/io/DataInputStream:NotNull *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N143: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B15 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: volatile java/io/FilterInputStream.in
040 +   #@membar_acquire
	fence ir iorw
044     spill R11 -&gt; R8	# spill size = 64
048 +   decode_heap_oop  R11, R7	#@decodeHeapOop
04c     lwu  R28, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
050     NullCheck R11

050     B2: #	out( B9 B3 ) &lt;- in( B1 )  Freq: 0.999999
050 +   mv  R7, narrowklass: precise klass java/io/BufferedInputStream: 0x00000040d07d1fd0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
060 +   bne  R28, R7, B9	#@cmpN_branch  P=0.000001 C=-1.000000

064     B3: #	out( B12 B4 ) &lt;- in( B2 )  Freq: 0.999998
064 +   # checkcastPP of R11, #@checkCastPP
064     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.io.BufferedInputStream::read
        # java.io.DataInputStream::readUnsignedShort @ bci:4 (line 343) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop off=104/0x68}

068     B4: #	out( B16 B5 ) &lt;- in( B3 )  Freq: 0.999978
        # Block is sole successor of call
068 +   lwu  R28, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: volatile java/io/FilterInputStream.in
06c +   #@membar_acquire
	fence ir iorw
070     spill R10 -&gt; [sp, #0]	# spill size = 32
074 +   decode_heap_oop  R28, R28	#@decodeHeapOop
078     lwu  R7, [R28, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
07c     NullCheck R28

07c     B5: #	out( B10 B6 ) &lt;- in( B4 )  Freq: 0.999977
07c +   mv  R29, narrowklass: precise klass java/io/BufferedInputStream: 0x00000040d07d1fd0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
08c +   bne  R7, R29, B10	#@cmpN_branch  P=0.000001 C=-1.000000

090     B6: #	out( B13 B7 ) &lt;- in( B5 )  Freq: 0.999976
090 +   # checkcastPP of R28, #@checkCastPP
090     spill R28 -&gt; R11	# spill size = 64
094     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.io.BufferedInputStream::read
        # java.io.DataInputStream::readUnsignedShort @ bci:12 (line 344) L[0]=_ L[1]=sp + #0 L[2]=_
        # OopMap {off=152/0x98}

098     B7: #	out( B11 B8 ) &lt;- in( B6 )  Freq: 0.999956
        # Block is sole successor of call
098 +   spill [sp, #0] -&gt; R28	# spill size = 32
09c +   orr  R8, R28, R10	#@orI_reg_reg
0a0 +   blt  R8, zr, B11	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

0a4     B8: #	out( N143 ) &lt;- in( B7 )  Freq: 0.999955
0a4 +   slliw  R7, R28, (#8 &amp; 0x1f)	#@lShiftI_reg_imm
0a8 +   addw  R10, R7, R10	#@addI_reg_reg
0ac     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0c4 +   ret	// return register, #@Ret

0c8     B9: #	out( N143 ) &lt;- in( B2 )  Freq: 9.99999e-07
0c8 +   spill R11 -&gt; [sp, #0]	# spill size = 64
0cc +   li R11, #-34	# int, #@loadConI
0d0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:4 (line 343) L[0]=R8 L[1]=_ L[2]=_ STK[0]=sp + #0
        # OopMap {fp=Oop [0]=Oop off=212/0xd4}
0d4     #@ShouldNotReachHere

0e0     B10: #	out( N143 ) &lt;- in( B5 )  Freq: 9.99977e-07
0e0 +   li R11, #-34	# int, #@loadConI
0e4     spill R28 -&gt; R8	# spill size = 64
0e8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:12 (line 344) L[0]=_ L[1]=sp + #0 L[2]=_ STK[0]=R8
        # OopMap {fp=Oop off=236/0xec}
0ec     #@ShouldNotReachHere

0f8     B11: #	out( N143 ) &lt;- in( B7 )  Freq: 4.76816e-07
0f8 +   li R11, #-187	# int, #@loadConI
0fc     spill R10 -&gt; [sp, #4]	# spill size = 32
100     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:19 (line 345) L[0]=_ L[1]=sp + #0 L[2]=sp + #4 STK[0]=R8
        # OopMap {off=260/0x104}
104     #@ShouldNotReachHere

110     B12: #	out( B14 ) &lt;- in( B3 )  Freq: 9.99998e-06
110      -- 	// exception oop; no code emitted, #@CreateException
110 +   spill R10 -&gt; R11	# spill size = 64
114 +   j  B14	#@branch

118     B13: #	out( B14 ) &lt;- in( B6 )  Freq: 9.99976e-06
118      -- 	// exception oop; no code emitted, #@CreateException
118 +   spill R10 -&gt; R11	# spill size = 64

11c     B14: #	out( N143 ) &lt;- in( B12 B13 )  Freq: 1.99997e-05
11c     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
128 +   j rethrow_stub	#@RethrowException

130     B15: #	out( N143 ) &lt;- in( B1 )  Freq: 1.01328e-06
130 +   li R11, #-10	# int, #@loadConI
134     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:4 (line 343) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # OopMap {off=312/0x138}
138     #@ShouldNotReachHere

144     B16: #	out( N143 ) &lt;- in( B4 )  Freq: 1.01326e-06
144 +   li R11, #-10	# int, #@loadConI
148     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:12 (line 344) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # OopMap {off=332/0x14c}
14c +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='501'>
----------------------- MetaData before Compile_id = 501 ------------------------
{method}
 - this oop:          0x0000004096533688
 - method holder:     &apos;java/io/DataInputStream&apos;
 - constants:         0x0000004096530ee8 constant pool [187] {0x0000004096530ee8} for &apos;java/io/DataInputStream&apos; cache=0x0000004096533738
 - access:            0xc1000019  public static final 
 - name:              &apos;readUTF&apos;
 - signature:         &apos;(Ljava/io/DataInput;)Ljava/lang/String;&apos;
 - max stack:         6
 - max locals:        9
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c5656c0
 - code size:         501
 - code start:        0x00000040965333c8
 - code end (excl):   0x00000040965335bd
 - method data:       0x00000040964a1fa0
 - checked ex length: 1
 - checked ex start:  0x0000004096533684
 - linenumber start:  0x00000040965335bd
 - localvar length:   12
 - localvar start:    0x00000040965335f2
 - compiled code: nmethod  21091  286       3       java.io.DataInputStream::readUTF (501 bytes)

------------------------ OptoAssembly for Compile_id = 501 -----------------------
#
#  java/lang/String:exact * ( java/io/DataInput * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/io/DataInput *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B103 B89 B104 B90 B105 B91 B106 B92 B97 B118 B98 B54 B93 B95 B96 B100 B73 B94 )  Freq: 1

000     B1: #	out( B103 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
01c     spill R11 -&gt; R29	# spill size = 64
020     lwu  R28, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
024     NullCheck R11

024     B2: #	out( B89 B3 ) &lt;- in( B1 )  Freq: 0.999999
024 +   mv  R7, narrowklass: precise klass jdk/internal/module/ModuleInfo$CountingDataInput: 0x00000040d0729530:Constant:exact *	# compressed klass ptr, #@loadConNKlass
034 +   bne  R28, R7, B89	#@cmpN_branch  P=0.000001 C=-1.000000

038     B3: #	out( B104 B4 ) &lt;- in( B2 )  Freq: 0.999998
038 +   # checkcastPP of R29, #@checkCastPP
038     lwu  R28, [R29, #12]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/module/ModuleInfo$CountingDataInput.delegate
03c +   spill R29 -&gt; [sp, #0]	# spill size = 64
040 +   decode_heap_oop  R8, R28	#@decodeHeapOop
044     lwu  R7, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
048     NullCheck R8

048     B4: #	out( B90 B5 ) &lt;- in( B3 )  Freq: 0.999997
048 +   mv  R29, narrowklass: precise klass java/io/DataInputStream: 0x00000040d07282c0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
058 +   bne  R7, R29, B90	#@cmpN_branch  P=0.000001 C=-1.000000

05c     B5: #	out( B105 B6 ) &lt;- in( B4 )  Freq: 0.999996
05c +   # checkcastPP of R8, #@checkCastPP
05c     lwu  R7, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: volatile java/io/FilterInputStream.in
060 +   #@membar_acquire
	fence ir iorw
064 +   decode_heap_oop  R29, R7	#@decodeHeapOop
068     lwu  R28, [R29, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
06c     NullCheck R29

06c     B6: #	out( B91 B7 ) &lt;- in( B5 )  Freq: 0.999995
06c +   mv  R7, narrowklass: precise klass java/io/BufferedInputStream: 0x00000040d0166630:Constant:exact *	# compressed klass ptr, #@loadConNKlass
07c +   bne  R28, R7, B91	#@cmpN_branch  P=0.000001 C=-1.000000

080     B7: #	out( B113 B8 ) &lt;- in( B6 )  Freq: 0.999994
080 +   # checkcastPP of R29, #@checkCastPP
080     spill R29 -&gt; R11	# spill size = 64
084     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.io.BufferedInputStream::read
        # java.io.DataInputStream::readUnsignedShort @ bci:4 (line 343) L[0]=R8 L[1]=_ L[2]=_
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=sp + #0 L[1]=_
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {fp=Oop [0]=Oop off=136/0x88}

088     B8: #	out( B106 B9 ) &lt;- in( B7 )  Freq: 0.999974
        # Block is sole successor of call
088 +   lwu  R28, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: volatile java/io/FilterInputStream.in
08c +   #@membar_acquire
	fence ir iorw
090     spill R10 -&gt; [sp, #8]	# spill size = 32
094 +   decode_heap_oop  R28, R28	#@decodeHeapOop
098     lwu  R7, [R28, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
09c     NullCheck R28

09c     B9: #	out( B92 B10 ) &lt;- in( B8 )  Freq: 0.999973
09c +   mv  R29, narrowklass: precise klass java/io/BufferedInputStream: 0x00000040d0166630:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0ac +   bne  R7, R29, B92	#@cmpN_branch  P=0.000001 C=-1.000000

0b0     B10: #	out( B114 B11 ) &lt;- in( B9 )  Freq: 0.999972
0b0 +   slliw  R29, R10, (#8 &amp; 0x1f)	#@lShiftI_reg_imm
0b4     # checkcastPP of R28, #@checkCastPP
0b4     spill R29 -&gt; [sp, #12]	# spill size = 32
0b8 +   spill R28 -&gt; R11	# spill size = 64
0bc +   spill [sp, #0] -&gt; R8	# spill size = 64
0c0     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.io.BufferedInputStream::read
        # java.io.DataInputStream::readUnsignedShort @ bci:12 (line 344) L[0]=_ L[1]=sp + #8 L[2]=_
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=R8 L[1]=_
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {fp=Oop [0]=Oop off=196/0xc4}

0c4     B11: #	out( B97 B12 ) &lt;- in( B10 )  Freq: 0.999952
        # Block is sole successor of call
0c4 +   ld  R7, [R8, #16]	# int, #@loadL ! Field: jdk/internal/module/ModuleInfo$CountingDataInput.count
0c8     spill [sp, #8] -&gt; R28	# spill size = 32
0cc +   orr  R8, R28, R10	#@orI_reg_reg
0d0     spill [sp, #12] -&gt; R29	# spill size = 32
0d4 +   addw  R30, R29, R10	#@addI_reg_reg
0d8 +   addi  R7, R7, #2	#@addL_reg_imm
0dc +   blt  R8, zr, B97	#@cmpI_reg_imm0_branch  P=0.000000 C=5376.000000

0e0     B12: #	out( B13 B13 ) &lt;- in( B11 )  Freq: 0.999951
0e0 +   li R31, #1048576	# int, #@loadConI
0e4 +   addw  R28, R30, zr	#@convI2L_reg_reg
0e8 +   bleu  R30, R31, B13	#@cmpU_branch  P=0.999999 C=-1.000000

0ec     B13: #	out( B74 B14 ) &lt;- in( B12 B12 )  Freq: 0.999951
0ec +   spill [sp, #0] -&gt; R29	# spill size = 64
0f0 +   sd  R7, [R29, #16]	# long, #@storeL ! Field: jdk/internal/module/ModuleInfo$CountingDataInput.count
0f4 +   li R7, #1048576	# int, #@loadConI
0f8 +   bgtu  R30, R7, B74	#@cmpU_branch  P=0.000001 C=-1.000000

0fc     B14: #	out( B74 B15 ) &lt;- in( B13 )  Freq: 0.99995
0fc +   addi  R7, R28, #23	#@addL_reg_imm
100 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
100     ld  R10, [R23, #288]	# ptr, #@loadP
104 +   andi  R28, R7, #-8	#@andL_reg_imm
108 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
108     ld  R29, [R23, #304]	# ptr, #@loadP
10c +   add R28, R10, R28	# ptr, #@addP_reg_reg
110 +   bgeu  R28, R29, B74	#@cmpP_branch  P=0.000100 C=-1.000000

114     B15: #	out( B16 ) &lt;- in( B14 )  Freq: 0.99985
114 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
114     sd  R28, [R23, #288]	# ptr, #@storeP
118 +   li R28, #1	# long, #@loadConL
11c +   sd  R28, [R10]	# long, #@storeL
120 +   mv  R28, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
130 +   sw  R28, [R10, #8]	# compressed klass ptr, #@storeNKlass
134 +   srli  R7, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
138 +   addi  R28, R10, #16	# ptr, #@addP_reg_imm
13c +   addi  R29, R7, #-2	#@addL_reg_imm
140 +   sw  R30, [R10, #12]	# int, #@storeI
144 +   ClearArray R29, R28	#@clearArray_reg_reg

19c     B16: #	out( B76 B17 ) &lt;- in( B75 B15 )  Freq: 0.999951
19c     
19c     MEMBAR-store-store	#@membar_storestore
1a0 +   spill R30 -&gt; R7	# spill size = 32
1a4 +   # castII of R7, #@castII
1a4     li R28, #524288	# int, #@loadConI
1a8     spill R10 -&gt; R31	# spill size = 64
1ac +   addw  R8, R7, zr	#@convI2L_reg_reg
1b0 +   # checkcastPP of R31, #@checkCastPP
1b0     bgtu  R7, R28, B76	#@cmpU_branch  P=0.000001 C=-1.000000

1b4     B17: #	out( B76 B18 ) &lt;- in( B16 )  Freq: 0.99995
1b4 +   slli  R28, R8, (#1 &amp; 0x3f)	#@lShiftL_reg_imm
1b8 +   addi  R28, R28, #23	#@addL_reg_imm
1bc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1bc     ld  R10, [R23, #288]	# ptr, #@loadP
1c0 +   andi  R29, R28, #-8	#@andL_reg_imm
1c4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1c4     ld  R30, [R23, #304]	# ptr, #@loadP
1c8 +   add R29, R10, R29	# ptr, #@addP_reg_reg
1cc +   bgeu  R29, R30, B76	#@cmpP_branch  P=0.000100 C=-1.000000

1d0     B18: #	out( B19 ) &lt;- in( B17 )  Freq: 0.99985
1d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1d0     sd  R29, [R23, #288]	# ptr, #@storeP
1d4 +   li R29, #1	# long, #@loadConL
1d8 +   sd  R29, [R10]	# long, #@storeL
1dc +   mv  R30, narrowklass: precise klass [C: 0x00000040d001b5f0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1ec +   srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
1f0 +   sw  R30, [R10, #8]	# compressed klass ptr, #@storeNKlass
1f4 +   addi  R28, R10, #16	# ptr, #@addP_reg_imm
1f8 +   addi  R29, R29, #-2	#@addL_reg_imm
1fc +   sw  R7, [R10, #12]	# int, #@storeI
200     ClearArray R29, R28	#@clearArray_reg_reg
258     spill R31 -&gt; [sp, #8]	# spill size = 64
25c +   spill R7 -&gt; [sp, #16]	# spill size = 32

260     B19: #	out( B116 B20 ) &lt;- in( B77 B18 )  Freq: 0.999951
260     
260 +   MEMBAR-store-store	#@membar_storestore
264 +   spill [sp, #0] -&gt; R7	# spill size = 64
268 +   lwu  R7, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/module/ModuleInfo$CountingDataInput.delegate
26c +   # checkcastPP of R10, #@checkCastPP
26c     spill R10 -&gt; [sp, #24]	# spill size = 64
270 +   decode_heap_oop  R11, R7	#@decodeHeapOop
274     spill [sp, #8] -&gt; R12	# spill size = 64
278 +   li R13, #0	# int, #@loadConI
27c     spill [sp, #16] -&gt; R14	# spill size = 32
280     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.io.DataInput::readFully
        # jdk.internal.module.ModuleInfo$CountingDataInput::readFully @ bci:7 (line 1115) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=sp + #16
        # java.io.DataInputStream::readUTF @ bci:87 (line 614) L[0]=_ L[1]=sp + #16 L[2]=sp + #8 L[3]=sp + #24 L[4]=_ L[5]=_ L[6]=_ L[7]=#0 L[8]=#0
        # OopMap {[0]=Oop [8]=Oop [24]=Oop off=668/0x29c}

29c     B20: #	out( B60 B21 ) &lt;- in( B19 )  Freq: 0.999931
        # Block is sole successor of call
29c +   spill [sp, #0] -&gt; R28	# spill size = 64
2a0 +   ld  R7, [R28, #16]	# int, #@loadL ! Field: jdk/internal/module/ModuleInfo$CountingDataInput.count
2a4 +   add  R7, R7, R8	#@addL_reg_reg
2a8 +   sd  R7, [R28, #16]	# long, #@storeL ! Field: jdk/internal/module/ModuleInfo$CountingDataInput.count
2ac     spill [sp, #16] -&gt; R29	# spill size = 32
2b0 +   ble  R29, zr, B60	#@cmpI_reg_imm0_branch  P=0.048037 C=21296.000000

2b4     B21: #	out( B93 B22 ) &lt;- in( B20 )  Freq: 0.951897
2b4 +   addiw  R7, R29, #-1	#@addI_reg_imm
2b8 +   beq  R29, zr, B93	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

2bc     B22: #	out( B93 B23 ) &lt;- in( B21 )  Freq: 0.951896
2bc +   bgeu  R7, R29, B93	#@cmpU_branch  P=0.000001 C=-1.000000

2c0     B23: #	out( B99 B24 ) &lt;- in( B22 )  Freq: 0.951896
2c0 +   spill [sp, #8] -&gt; R16	# spill size = 64
2c4 +   lbu  R28, [R16, #16]	# byte, #@loadUB
2c8 +   li R11, #127	# int, #@loadConI
2cc +   bgt  R28, R11, B99	#@cmpI_branch  P=0.000000 C=20273.000000

2d0     B24: #	out( B34 B25 ) &lt;- in( B23 )  Freq: 0.951895
2d0 +   li R31, #-2147483648	# int, #@loadConI
2d4 +   addiw  R15, R29, #-3	#@addI_reg_imm
2d8     CMove R15, (R7 lt R15), R15, R31	#@cmovI_cmpI
	
2e0 +   li R12, #1	# int, #@loadConI
2e4 +   li R13, #4000	# int, #@loadConI
2ec     spill [sp, #24] -&gt; R14	# spill size = 64
2f0 +   sh  R28, [R14, #16]	# short, #@storeC
2f4 +   ble  R15, R12, B34	#@cmpI_branch  P=0.000001 C=-1.000000

2f8     B25: #	out( B94 B26 ) &lt;- in( B24 )  Freq: 0.951894
2f8 +   bleu  R29, R12, B94	#@cmpU_branch  P=0.000001 C=-1.000000

2fc     B26: #	out( B95 B27 ) &lt;- in( B25 )  Freq: 0.951893
2fc +   li R28, #4	# int, #@loadConI
300 +   bleu  R29, R28, B95	#@cmpU_branch  P=0.000001 C=-1.000000

304     B27: #	out( B28 ) &lt;- in( B26 B33 ) Loop( B27-B33 ) Freq: 19.8002
304 +   li R30, #0	# int, #@loadConI
308 +   subw  R7, R15, R12	#@subI_reg_reg
30c     CMove R7, (R15 lt R12), R7, R30	#@cmovI_cmpI
	
314 +   CMove R7, (R7 gtu R13), R7, R13	#@cmovI_cmpU
	
31c +   addw  R30, R7, R12	#@addI_reg_reg

320     B28: #	out( B68 B29 ) &lt;- in( B27 B32 ) Loop( B28-B32 inner main of N311 strip mined) Freq: 412.169
320 +   addw  R7, R12, zr	#@convI2L_reg_reg
324 +   add R28, R16, R7	# ptr, #@addP_reg_reg
328 +   slli  R7, R7, (#1 &amp; 0x3f)	#@lShiftL_reg_imm
32c +   lbu  R31, [R28, #16]	# byte, #@loadUB
330 +   lbu  R10, [R28, #17]	# byte, #@loadUB
334 +   lbu  R17, [R28, #18]	# byte, #@loadUB
338 +   add R7, R14, R7	# ptr, #@addP_reg_reg
33c +   lbu  R28, [R28, #19]	# byte, #@loadUB
340 +   bgt  R31, R11, B68	#@cmpI_branch  P=0.000000 C=20273.000000

344     B29: #	out( B71 B30 ) &lt;- in( B28 )  Freq: 412.168
344 +   sh  R31, [R7, #16]	# short, #@storeC
348 +   bgt  R10, R11, B71	#@cmpI_branch  P=0.000000 C=20273.000000

34c     B30: #	out( B69 B31 ) &lt;- in( B29 )  Freq: 412.168
34c +   sh  R10, [R7, #18]	# short, #@storeC
350 +   bgt  R17, R11, B69	#@cmpI_branch  P=0.000000 C=20273.000000

354     B31: #	out( B72 B32 ) &lt;- in( B30 )  Freq: 412.168
354 +   sh  R17, [R7, #20]	# short, #@storeC
358 +   bgt  R28, R11, B72	#@cmpI_branch  P=0.000000 C=20273.000000

35c     B32: #	out( B28 B33 ) &lt;- in( B31 )  Freq: 412.168
35c +   addiw  R12, R12, #4	#@addI_reg_imm
360 +   sh  R28, [R7, #22]	# short, #@storeC
364 +   blt  R12, R30, B28	#@cmpI_loop  P=0.951963 C=20273.000000

368     B33: #	out( B27 B34 ) &lt;- in( B32 )  Freq: 19.7994
368 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
368     ld  R30, [R23, #920]	# ptr, #@loadP
36c +   lwu zr, [R30]	# Safepoint: poll for GC, #@safePoint        # java.io.DataInputStream::readUTF @ bci:131 (line 620) L[0]=_ L[1]=R29 L[2]=R16 L[3]=R14 L[4]=_ L[5]=_ L[6]=_ L[7]=R12 L[8]=R12
        # OopMap {c_rarg4=Oop c_rarg6=Oop off=876/0x36c}
370 +   blt  R12, R15, B27	#@cmpI_branch  P=0.951963 C=20273.000000

374     B34: #	out( B38 B35 ) &lt;- in( B24 B33 )  Freq: 0.951107
374 +   bge  R12, R29, B38	#@cmpI_branch  P=0.500000 C=-1.000000

378     B35: #	out( B96 B36 ) &lt;- in( B34 )  Freq: 0.475553
378 +   # castII of R12, #@castII
378     bgeu  R12, R29, B96	#@cmpU_branch  P=0.000001 C=-1.000000

37c     B36: #	out( B73 B37 ) &lt;- in( B35 B37 ) Loop( B36-B37 inner post of N1224) Freq: 0.951106
37c +   addw  R7, R12, zr	#@convI2L_reg_reg
380 +   add R28, R16, R7	# ptr, #@addP_reg_reg
384 +   lbu  R28, [R28, #16]	# byte, #@loadUB
388 +   slli  R7, R7, (#1 &amp; 0x3f)	#@lShiftL_reg_imm
38c +   add R7, R14, R7	# ptr, #@addP_reg_reg
390 +   bgt  R28, R11, B73	#@cmpI_branch  P=0.000000 C=20273.000000

394     B37: #	out( B36 B38 ) &lt;- in( B36 )  Freq: 0.951105
394 +   addiw  R12, R12, #1	#@addI_reg_imm
398 +   sh  R28, [R7, #16]	# short, #@storeC
39c +   blt  R12, R29, B36	#@cmpI_loop  P=0.500000 C=20273.000000

3a0     B38: #	out( B39 ) &lt;- in( B37 B34 )  Freq: 0.951106
3a0 +   spill R12 -&gt; R7	# spill size = 32

3a4     B39: #	out( B98 B40 ) &lt;- in( B60 B38 )  Freq: 0.99914
3a4 +   blt  R7, R29, B98	#@cmpI_branch  P=0.000000 C=1023.000000

3a8     B40: #	out( B78 B41 ) &lt;- in( B39 )  Freq: 0.999139
3a8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3a8     ld  R10, [R23, #288]	# ptr, #@loadP
3ac +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3ac     ld  R28, [R23, #304]	# ptr, #@loadP
3b0 +   addi  R30, R10, #24	# ptr, #@addP_reg_imm
3b4 +   bgeu  R30, R28, B78	#@cmpP_branch  P=0.000100 C=-1.000000

3b8     B41: #	out( B42 ) &lt;- in( B40 )  Freq: 0.99904
3b8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3b8     sd  R30, [R23, #288]	# ptr, #@storeP
3bc +   li R28, #1	# long, #@loadConL
3c0 +   mv  R30, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
3d0 +   sd  R28, [R10]	# long, #@storeL
3d4 +   sw  R30, [R10, #8]	# compressed klass ptr, #@storeNKlass
3d8 +   sw  zr, [R10, #12]	# int, #@storeimmI0
3dc +   sd  zr, [R10, #16]	# long, #@storeimmL0
3e0     spill R29 -&gt; R8	# spill size = 32
3e4 +   spill R14 -&gt; [sp, #0]	# spill size = 64
3e8 +   spill R7 -&gt; [sp, #8]	# spill size = 32

3ec     B42: #	out( B117 B43 ) &lt;- in( B79 B41 )  Freq: 0.999139
3ec     
3ec +   # checkcastPP of R10, #@checkCastPP
3ec     spill R10 -&gt; [sp, #16]	# spill size = 64
3f0 +   li R11, #0	# int, #@loadConI
3f4     spill [sp, #8] -&gt; R12	# spill size = 32
3f8 +   spill R8 -&gt; R13	# spill size = 32
3fc     CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.String::checkBoundsOffCount
        # java.lang.String::rangeCheck @ bci:4 (line 304) L[0]=_ L[1]=_ L[2]=_
        # java.lang.String::&lt;init&gt; @ bci:7 (line 300) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #16 STK[1]=sp + #0 STK[2]=#0 STK[3]=sp + #8
        # java.io.DataInputStream::readUTF @ bci:497 (line 666) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ STK[0]=sp + #16
        # OopMap {[0]=Oop [16]=Oop off=1024/0x400}

400     B43: #	out( B55 B44 ) &lt;- in( B42 )  Freq: 0.999119
        # Block is sole successor of call
400 +   spill [sp, #8] -&gt; R7	# spill size = 32
404 +   beq  R7, zr, B55	#@cmpI_reg_imm0_branch  P=0.100000 C=-1.000000

408     B44: #	out( B87 B45 ) &lt;- in( B43 )  Freq: 0.899207
408 +   li R28, #1048576	# int, #@loadConI
40c +   bgtu  R7, R28, B87	#@cmpU_branch  P=0.000001 C=-1.000000

410     B45: #	out( B87 B46 ) &lt;- in( B44 )  Freq: 0.899207
410 +   addw  R7, R7, zr	#@convI2L_reg_reg
414 +   addi  R7, R7, #23	#@addL_reg_imm
418 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
418     ld  R10, [R23, #288]	# ptr, #@loadP
41c +   andi  R28, R7, #-8	#@andL_reg_imm
420 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
420     ld  R29, [R23, #304]	# ptr, #@loadP
424 +   add R28, R10, R28	# ptr, #@addP_reg_reg
428 +   bgeu  R28, R29, B87	#@cmpP_branch  P=0.000100 C=-1.000000

42c     B46: #	out( B47 ) &lt;- in( B45 )  Freq: 0.899117
42c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
42c     sd  R28, [R23, #288]	# ptr, #@storeP
430 +   li R28, #1	# long, #@loadConL
434 +   mv  R29, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
444 +   sd  R28, [R10]	# long, #@storeL
448 +   sw  R29, [R10, #8]	# compressed klass ptr, #@storeNKlass
44c     spill [sp, #8] -&gt; R28	# spill size = 32
450 +   sw  R28, [R10, #12]	# int, #@storeI
454 +   srli  R7, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
458 +   addi  R28, R10, #16	# ptr, #@addP_reg_imm
45c +   addi  R29, R7, #-2	#@addL_reg_imm
460 +   ClearArray R29, R28	#@clearArray_reg_reg

4b8     B47: #	out( B111 B48 ) &lt;- in( B88 B46 )  Freq: 0.899207
4b8     
4b8     MEMBAR-store-store	#@membar_storestore
4bc +   spill R10 -&gt; R8	# spill size = 64
4c0 +   # checkcastPP of R8, #@checkCastPP
4c0     spill [sp, #0] -&gt; R11	# spill size = 64
4c4 +   li R12, #0	# int, #@loadConI
4c8     spill R8 -&gt; R13	# spill size = 64
4cc +   li R14, #0	# int, #@loadConI
4d0     spill [sp, #8] -&gt; R15	# spill size = 32
4d4     CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringUTF16::compress
        # java.lang.StringUTF16::compress @ bci:9 (line 162) L[0]=_ L[1]=_ L[2]=sp + #8 L[3]=R8
        # java.lang.String::&lt;init&gt; @ bci:36 (line 4494) L[0]=sp + #16 L[1]=sp + #0 L[2]=#0 L[3]=sp + #8 L[4]=_ L[5]=_
        # java.lang.String::&lt;init&gt; @ bci:10 (line 300) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.io.DataInputStream::readUTF @ bci:497 (line 666) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ STK[0]=sp + #16
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=1240/0x4d8}

4d8     B48: #	out( B100 B49 ) &lt;- in( B47 )  Freq: 0.899189
        # Block is sole successor of call
4d8 +   spill [sp, #8] -&gt; R7	# spill size = 32
4dc +   bne  R10, R7, B100	#@cmpI_branch  P=0.000000 C=1166.000000

4e0     B49: #	out( B61 B50 ) &lt;- in( B48 )  Freq: 0.899189
4e0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
4e0     lb  R7, [R23, #56]	# byte, #@loadB
4e4 +   bne  R7, zr, B61	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

4e8     B50: #	out( B51 ) &lt;- in( B49 )  Freq: 0.89829
4e8 +   spill [sp, #16] -&gt; R9	# spill size = 64

4ec     B51: #	out( B53 B52 ) &lt;- in( B101 B63 B61 B50 )  Freq: 0.899189
4ec +   mv  R7, R9	# ptr -&gt; long, #@castP2X
4f0 +   mv  R28, R8	# ptr -&gt; long, #@castP2X
4f4 +   xorr  R28, R28, R7	#@xorL_reg_reg
4f8 +   encode_heap_oop  R30, R8	#@encodeHeapOop
4fc +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
500 +   sw  R30, [R9, #20]	# compressed ptr, #@storeN ! Field: java/lang/String.value (constant)
504 +   beq  R28, zr, B53	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

508     B52: #	out( B64 B53 ) &lt;- in( B51 )  Freq: 0.89829
508 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
50c +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
518 +   add R10, R28, R7	# ptr, #@addP_reg_reg
51c +   lb  R7, [R10]	# byte, #@loadB
520 +   li R29, #4	# int, #@loadConI
524 +   bne  R7, R29, B64	#@cmpI_branch  P=0.001000 C=-1.000000

528     B53: #	out( B54 ) &lt;- in( B66 B67 B64 B52 B51 )  Freq: 0.899189
528 +   sb zr, [R9, #16]	# byte, #@storeimmB0 ! Field: java/lang/String.coder (constant)

52c     B54: #	out( N1 ) &lt;- in( B59 B53 )  Freq: 0.999101
52c +   #@membar_release
	fence iorw ow
530 +   #@membar_release
	fence iorw ow
530 +   spill R9 -&gt; R10	# spill size = 64
534 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
54c +   ret	// return register, #@Ret

550     B55: #	out( B80 B56 ) &lt;- in( B43 )  Freq: 0.099912
550 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
550     lb  R7, [R23, #56]	# byte, #@loadB
554 +   bne  R7, zr, B80	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

558     B56: #	out( B57 ) &lt;- in( B55 )  Freq: 0.0998121
558 +   spill [sp, #16] -&gt; R9	# spill size = 64

55c     B57: #	out( B59 B58 ) &lt;- in( B102 B82 B80 B56 )  Freq: 0.099912
55c +   mv  R7, stable:byte[int:0]&lt;ciTypeArray length=0 type=&lt;ciTypeArrayKlass name=[B loaded=true ident=1142 address=0x00000040d001b710&gt; ident=1186 address=0x00000040d0885170&gt; *	# ptr, #@loadConP
574 +   mv  R28, R9	# ptr -&gt; long, #@castP2X
578 +   mv  R7, R7	# ptr -&gt; long, #@castP2X
578 +   xorr  R7, R7, R28	#@xorL_reg_reg
57c +   mv  R30, narrowoop: stable:byte[int:0]&lt;ciTypeArray length=0 type=&lt;ciTypeArrayKlass name=[B loaded=true ident=1142 address=0x00000040d001b710&gt; ident=1186 address=0x00000040d0885170&gt; *	# compressed ptr, #@loadConN
58c +   srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
590 +   sw  R30, [R9, #20]	# compressed ptr, #@storeN ! Field: java/lang/String.value (constant)
594 +   beq  R7, zr, B59	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

598     B58: #	out( B83 B59 ) &lt;- in( B57 )  Freq: 0.0998121
598 +   srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
59c +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
5a8 +   add R10, R28, R7	# ptr, #@addP_reg_reg
5ac +   lb  R7, [R10]	# byte, #@loadB
5b0 +   li R28, #4	# int, #@loadConI
5b4 +   bne  R7, R28, B83	#@cmpI_branch  P=0.001000 C=-1.000000

5b8     B59: #	out( B54 ) &lt;- in( B85 B86 B83 B58 B57 )  Freq: 0.099912
5b8 +   sb zr, [R9, #16]	# byte, #@storeimmB0 ! Field: java/lang/String.coder (constant)
5bc +   j  B54	#@branch

5c0     B60: #	out( B39 ) &lt;- in( B20 )  Freq: 0.0480339
5c0 +   li R7, #0	# int, #@loadConI
5c4     spill [sp, #8] -&gt; R16	# spill size = 64
5c8 +   spill [sp, #24] -&gt; R14	# spill size = 64
5cc +   j  B39	#@branch

5d0     B61: #	out( B51 B62 ) &lt;- in( B49 )  Freq: 0.000899177
5d0 +   spill [sp, #16] -&gt; R9	# spill size = 64
5d4 +   lwu  R28, [R9, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
5d8 +   decode_heap_oop  R10, R28	#@decodeHeapOop
5dc +   beq   R10, zr, B51	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

5e0     B62: #	out( B101 B63 ) &lt;- in( B61 )  Freq: 0.000449589
5e0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5e0     ld  R7, [R23, #32]	# int, #@loadL
5e4 +   beq  R7, zr, B101	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

5e8     B63: #	out( B51 ) &lt;- in( B62 )  Freq: 0.000449139
5e8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5e8     ld  R28, [R23, #48]	# ptr, #@loadP
5ec +   add R28, R28, R7	# ptr, #@addP_reg_reg
5f0 +   addi  R7, R7, #-8	#@addL_reg_imm
5f4 +   sd  R10, [R28, #-8]	# ptr, #@storeP
5f8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5f8     sd  R7, [R23, #32]	# long, #@storeL
5fc +   j  B51	#@branch

600     B64: #	out( B53 B65 ) &lt;- in( B52 )  Freq: 0.00089829
600 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
600     ld  R7, [R23, #64]	# int, #@loadL
604 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
604     ld  R28, [R23, #80]	# ptr, #@loadP
608 +   #@membar_volatile
	fence iorw iorw
60c +   lb  R30, [R10]	# byte, #@loadB
610 +   beq  R30, zr, B53	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

614     B65: #	out( B67 B66 ) &lt;- in( B64 )  Freq: 0.000449145
614 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
618 +   bne  R7, zr, B67	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

61c     B66: #	out( B53 ) &lt;- in( B65 )  Freq: 0.000224572
61c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
61c     spill R23 -&gt; R11	# spill size = 64
620 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
650 +   j  B53	#@branch

654     B67: #	out( B53 ) &lt;- in( B65 )  Freq: 0.000224572
654 +   add R28, R28, R7	# ptr, #@addP_reg_reg
658 +   addi  R7, R7, #-8	#@addL_reg_imm
65c +   sd  R10, [R28, #-8]	# ptr, #@storeP
660 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
660     sd  R7, [R23, #64]	# long, #@storeL
664 +   j  B53	#@branch

668     B68: #	out( B70 ) &lt;- in( B28 )  Freq: 0.000196537
668 +   spill R31 -&gt; R17	# spill size = 32
66c +   j  B70	#@branch

670     B69: #	out( B70 ) &lt;- in( B30 )  Freq: 0.000196537
670 +   addiw  R12, R12, #2	#@addI_reg_imm

674     B70: #	out( B73 ) &lt;- in( B68 B69 )  Freq: 0.000393074
674     spill R17 -&gt; R28	# spill size = 32
678 +   j  B73	#@branch

67c     B71: #	out( B73 ) &lt;- in( B29 )  Freq: 0.000196537
67c +   addiw  R12, R12, #1	#@addI_reg_imm
680     spill R10 -&gt; R28	# spill size = 32
684 +   j  B73	#@branch

688     B72: #	out( B73 ) &lt;- in( B31 )  Freq: 0.000196537
688 +   addiw  R12, R12, #3	#@addI_reg_imm

68c     B73: #	out( N1 ) &lt;- in( B36 B99 B70 B71 B72 )  Freq: 0.000787056
68c +   li R11, #-187	# int, #@loadConI
690     spill R16 -&gt; R8	# spill size = 64
694 +   spill R14 -&gt; [sp, #0]	# spill size = 64
698 +   spill R12 -&gt; [sp, #16]	# spill size = 32
69c +   spill R28 -&gt; [sp, #20]	# spill size = 32
6a0 +   spill R29 -&gt; [sp, #24]	# spill size = 32
6a4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.io.DataInputStream::readUTF @ bci:112 (line 618) L[0]=_ L[1]=sp + #24 L[2]=R8 L[3]=sp + #0 L[4]=sp + #20 L[5]=_ L[6]=_ L[7]=sp + #16 L[8]=sp + #16 STK[0]=sp + #20 STK[1]=#127
        # OopMap {fp=Oop [0]=Oop off=1704/0x6a8}
6a8     #@ShouldNotReachHere

6b4     B74: #	out( B109 B75 ) &lt;- in( B13 B14 )  Freq: 0.000101025
6b4 +   spill R30 -&gt; [sp, #8]	# spill size = 32
6b8 +   spill [sp, #0] -&gt; R8	# spill size = 64
6bc +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
6d4     spill R30 -&gt; R12	# spill size = 32
6d8     CALL,static 0x000000401390d640	#@CallStaticJavaDirect wrapper for: _new_array_Java
        # java.io.DataInputStream::readUTF @ bci:70 (line 606) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {fp=Oop [0]=Oop off=1756/0x6dc}

6dc     B75: #	out( B16 ) &lt;- in( B74 )  Freq: 0.000101023
        # Block is sole successor of call
6dc +   spill [sp, #8] -&gt; R30	# spill size = 32
6e0 +   j  B16	#@branch

6e4     B76: #	out( B110 B77 ) &lt;- in( B16 B17 )  Freq: 0.000101025
6e4 +   spill R7 -&gt; [sp, #16]	# spill size = 32
6e8 +   spill R31 -&gt; [sp, #8]	# spill size = 64
6ec +   mv  R11, precise klass [C: 0x00000040d001b5f0:Constant:exact *	# ptr, #@loadConP
704     spill R7 -&gt; R12	# spill size = 32
708     CALL,static 0x000000401390d640	#@CallStaticJavaDirect wrapper for: _new_array_Java
        # java.io.DataInputStream::readUTF @ bci:74 (line 607) L[0]=sp + #0 L[1]=sp + #16 L[2]=sp + #8 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {[0]=Oop [8]=Oop off=1804/0x70c}

70c     B77: #	out( B19 ) &lt;- in( B76 )  Freq: 0.000101023
        # Block is sole successor of call
70c +   j  B19	#@branch

710     B78: #	out( B108 B79 ) &lt;- in( B40 )  Freq: 9.99305e-05
710 +   spill R7 -&gt; [sp, #8]	# spill size = 32
714 +   spill R14 -&gt; [sp, #0]	# spill size = 64
718 +   spill R29 -&gt; R8	# spill size = 32
71c +   mv  R11, precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# ptr, #@loadConP
734     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.io.DataInputStream::readUTF @ bci:489 (line 666) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=sp + #8
        # OopMap {[0]=Oop off=1848/0x738}

738     B79: #	out( B42 ) &lt;- in( B78 )  Freq: 9.99285e-05
        # Block is sole successor of call
738 +   j  B42	#@branch

73c     B80: #	out( B57 B81 ) &lt;- in( B55 )  Freq: 9.99107e-05
73c +   spill [sp, #16] -&gt; R9	# spill size = 64
740 +   lwu  R28, [R9, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
744 +   decode_heap_oop  R10, R28	#@decodeHeapOop
748 +   beq   R10, zr, B57	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

74c     B81: #	out( B102 B82 ) &lt;- in( B80 )  Freq: 4.99553e-05
74c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
74c     ld  R7, [R23, #32]	# int, #@loadL
750 +   beq  R7, zr, B102	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

754     B82: #	out( B57 ) &lt;- in( B81 )  Freq: 4.99054e-05
754 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
754     ld  R28, [R23, #48]	# ptr, #@loadP
758 +   add R28, R28, R7	# ptr, #@addP_reg_reg
75c +   addi  R7, R7, #-8	#@addL_reg_imm
760 +   sd  R10, [R28, #-8]	# ptr, #@storeP
764 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
764     sd  R7, [R23, #32]	# long, #@storeL
768 +   j  B57	#@branch

76c     B83: #	out( B59 B84 ) &lt;- in( B58 )  Freq: 9.98121e-05
76c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
76c     ld  R7, [R23, #64]	# int, #@loadL
770 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
770     ld  R28, [R23, #80]	# ptr, #@loadP
774 +   #@membar_volatile
	fence iorw iorw
778 +   lb  R30, [R10]	# byte, #@loadB
77c +   beq  R30, zr, B59	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

780     B84: #	out( B86 B85 ) &lt;- in( B83 )  Freq: 4.9906e-05
780 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
784 +   bne  R7, zr, B86	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

788     B85: #	out( B59 ) &lt;- in( B84 )  Freq: 2.4953e-05
788 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
788     spill R23 -&gt; R11	# spill size = 64
78c +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
7bc +   j  B59	#@branch

7c0     B86: #	out( B59 ) &lt;- in( B84 )  Freq: 2.4953e-05
7c0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
7c4 +   addi  R7, R7, #-8	#@addL_reg_imm
7c8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
7cc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7cc     sd  R7, [R23, #64]	# long, #@storeL
7d0 +   j  B59	#@branch

7d4     B87: #	out( B107 B88 ) &lt;- in( B44 B45 )  Freq: 9.08467e-05
7d4 +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
7ec     spill [sp, #8] -&gt; R12	# spill size = 32
7f0     CALL,static 0x000000401390d640	#@CallStaticJavaDirect wrapper for: _new_array_Java
        # java.lang.StringUTF16::compress @ bci:1 (line 161) L[0]=sp + #0 L[1]=#0 L[2]=sp + #8 L[3]=_
        # java.lang.String::&lt;init&gt; @ bci:36 (line 4494) L[0]=sp + #16 L[1]=sp + #0 L[2]=#0 L[3]=sp + #8 L[4]=_ L[5]=_
        # java.lang.String::&lt;init&gt; @ bci:10 (line 300) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.io.DataInputStream::readUTF @ bci:497 (line 666) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ STK[0]=sp + #16
        # OopMap {[0]=Oop [16]=Oop off=2036/0x7f4}

7f4     B88: #	out( B47 ) &lt;- in( B87 )  Freq: 9.08449e-05
        # Block is sole successor of call
7f4 +   j  B47	#@branch

7f8     B89: #	out( N1 ) &lt;- in( B2 )  Freq: 9.99999e-07
7f8 +   li R11, #-34	# int, #@loadConI
7fc     spill R29 -&gt; [sp, #0]	# spill size = 64
800     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ STK[0]=sp + #0
        # OopMap {[0]=Oop off=2052/0x804}
804     #@ShouldNotReachHere

810     B90: #	out( N1 ) &lt;- in( B4 )  Freq: 9.99997e-07
810 +   li R11, #-34	# int, #@loadConI
814     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=sp + #0 L[1]=_ STK[0]=R8
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {fp=Oop [0]=Oop off=2072/0x818}
818     #@ShouldNotReachHere

824     B91: #	out( N1 ) &lt;- in( B6 )  Freq: 9.99995e-07
824 +   li R11, #-34	# int, #@loadConI
828     spill R29 -&gt; [sp, #16]	# spill size = 64
82c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:4 (line 343) L[0]=R8 L[1]=_ L[2]=_ STK[0]=sp + #16
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=sp + #0 L[1]=_
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=2096/0x830}
830     #@ShouldNotReachHere

83c     B92: #	out( N1 ) &lt;- in( B9 )  Freq: 9.99973e-07
83c +   li R11, #-34	# int, #@loadConI
840     spill [sp, #0] -&gt; R8	# spill size = 64
844 +   spill R28 -&gt; [sp, #16]	# spill size = 64
848     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:12 (line 344) L[0]=_ L[1]=sp + #8 L[2]=_ STK[0]=sp + #16
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=R8 L[1]=_
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {fp=Oop [16]=Oop off=2124/0x84c}
84c     #@ShouldNotReachHere

858     B93: #	out( N1 ) &lt;- in( B22 B21 )  Freq: 1.92907e-06
858 +   li R11, #-138	# int, #@loadConI
85c     spill [sp, #8] -&gt; R8	# spill size = 64
860     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUTF @ bci:95 (line 616) L[0]=_ L[1]=sp + #16 L[2]=R8 L[3]=sp + #24 L[4]=_ L[5]=_ L[6]=_ L[7]=#0 L[8]=#0 STK[0]=#0 STK[1]=sp + #16
        # OopMap {fp=Oop [24]=Oop off=2148/0x864}
864     #@ShouldNotReachHere

870     B94: #	out( N1 ) &lt;- in( B25 )  Freq: 9.51894e-07
870     #@ShouldNotReachHere

87c     B95: #	out( N1 ) &lt;- in( B26 )  Freq: 9.51893e-07
87c     #@ShouldNotReachHere

888     B96: #	out( N1 ) &lt;- in( B35 )  Freq: 4.81868e-07
888     #@ShouldNotReachHere

894     B97: #	out( N1 ) &lt;- in( B11 )  Freq: 4.76814e-07
894 +   li R11, #-187	# int, #@loadConI
898     spill R10 -&gt; [sp, #12]	# spill size = 32
89c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:19 (line 345) L[0]=_ L[1]=sp + #8 L[2]=sp + #12 STK[0]=R8
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=sp + #0 L[1]=_
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {[0]=Oop off=2208/0x8a0}
8a0     #@ShouldNotReachHere

8ac     B98: #	out( N1 ) &lt;- in( B39 )  Freq: 4.76427e-07
8ac +   li R11, #-187	# int, #@loadConI
8b0     spill R16 -&gt; R8	# spill size = 64
8b4 +   spill R14 -&gt; [sp, #0]	# spill size = 64
8b8 +   spill R7 -&gt; [sp, #16]	# spill size = 32
8bc +   spill R7 -&gt; [sp, #20]	# spill size = 32
8c0 +   spill R29 -&gt; [sp, #24]	# spill size = 32
8c4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.io.DataInputStream::readUTF @ bci:137 (line 623) L[0]=_ L[1]=sp + #24 L[2]=R8 L[3]=sp + #0 L[4]=_ L[5]=_ L[6]=_ L[7]=sp + #16 L[8]=sp + #20 STK[0]=sp + #16 STK[1]=sp + #24
        # OopMap {fp=Oop [0]=Oop off=2248/0x8c8}
8c8     #@ShouldNotReachHere

8d4     B99: #	out( B73 ) &lt;- in( B23 )  Freq: 4.53899e-07
8d4 +   li R12, #0	# int, #@loadConI
8d8     spill [sp, #24] -&gt; R14	# spill size = 64
8dc +   j  B73	#@branch

8e0     B100: #	out( N1 ) &lt;- in( B48 )  Freq: 4.49595e-07
8e0 +   li R11, #-187	# int, #@loadConI
8e4     spill R10 -&gt; [sp, #12]	# spill size = 32
8e8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringUTF16::compress @ bci:13 (line 162) L[0]=_ L[1]=_ L[2]=_ L[3]=R8 STK[0]=sp + #12 STK[1]=sp + #8
        # java.lang.String::&lt;init&gt; @ bci:36 (line 4494) L[0]=sp + #16 L[1]=sp + #0 L[2]=#0 L[3]=sp + #8 L[4]=_ L[5]=_
        # java.lang.String::&lt;init&gt; @ bci:10 (line 300) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.io.DataInputStream::readUTF @ bci:497 (line 666) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ STK[0]=sp + #16
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=2284/0x8ec}
8ec     #@ShouldNotReachHere

8f8     B101: #	out( B51 ) &lt;- in( B62 )  Freq: 4.49583e-07
8f8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8f8     spill R23 -&gt; R11	# spill size = 64
8fc +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
92c +   j  B51	#@branch

930     B102: #	out( B57 ) &lt;- in( B81 )  Freq: 4.99547e-08
930 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
930     spill R23 -&gt; R11	# spill size = 64
934 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
964 +   j  B57	#@branch

968     B103: #	out( N1 ) &lt;- in( B1 )  Freq: 1.01328e-06
968 +   li R11, #-10	# int, #@loadConI
96c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ STK[0]=#NULL
        # OopMap {off=2416/0x970}
970     #@ShouldNotReachHere

97c     B104: #	out( N1 ) &lt;- in( B3 )  Freq: 1.01328e-06
97c +   li R11, #-10	# int, #@loadConI
980     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=_ L[1]=_ STK[0]=#NULL
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {off=2436/0x984}
984     #@ShouldNotReachHere

990     B105: #	out( N1 ) &lt;- in( B5 )  Freq: 1.01327e-06
990 +   li R11, #-10	# int, #@loadConI
994     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:4 (line 343) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=_ L[1]=_
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {off=2456/0x998}
998     #@ShouldNotReachHere

9a4     B106: #	out( N1 ) &lt;- in( B8 )  Freq: 1.01325e-06
9a4 +   li R11, #-10	# int, #@loadConI
9a8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:12 (line 344) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=_ L[1]=_
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {off=2476/0x9ac}
9ac     #@ShouldNotReachHere

9b8     B107: #	out( B112 ) &lt;- in( B87 )  Freq: 9.08467e-10
9b8      -- 	// exception oop; no code emitted, #@CreateException
9b8 +   j  B112	#@branch

9bc     B108: #	out( B118 ) &lt;- in( B78 )  Freq: 9.99305e-10
9bc      -- 	// exception oop; no code emitted, #@CreateException
9bc +   spill R10 -&gt; R11	# spill size = 64
9c0 +   j  B118	#@branch

9c4     B109: #	out( B118 ) &lt;- in( B74 )  Freq: 1.01025e-09
9c4      -- 	// exception oop; no code emitted, #@CreateException
9c4 +   spill R10 -&gt; R11	# spill size = 64
9c8 +   j  B118	#@branch

9cc     B110: #	out( B118 ) &lt;- in( B76 )  Freq: 1.01025e-09
9cc      -- 	// exception oop; no code emitted, #@CreateException
9cc +   spill R10 -&gt; R11	# spill size = 64
9d0 +   j  B118	#@branch

9d4     B111: #	out( B112 ) &lt;- in( B47 )  Freq: 8.99207e-06
9d4      -- 	// exception oop; no code emitted, #@CreateException

9d4     B112: #	out( B118 ) &lt;- in( B107 B111 )  Freq: 8.99298e-06
9d4 +   spill R10 -&gt; R11	# spill size = 64
9d8 +   j  B118	#@branch

9dc     B113: #	out( B115 ) &lt;- in( B7 )  Freq: 9.99994e-06
9dc      -- 	// exception oop; no code emitted, #@CreateException
9dc +   j  B115	#@branch

9e0     B114: #	out( B115 ) &lt;- in( B10 )  Freq: 9.99972e-06
9e0      -- 	// exception oop; no code emitted, #@CreateException

9e0     B115: #	out( B118 ) &lt;- in( B113 B114 )  Freq: 1.99997e-05
9e0 +   spill R10 -&gt; R11	# spill size = 64
9e4 +   j  B118	#@branch

9e8     B116: #	out( B118 ) &lt;- in( B19 )  Freq: 9.99951e-06
9e8      -- 	// exception oop; no code emitted, #@CreateException
9e8 +   spill R10 -&gt; R11	# spill size = 64
9ec +   j  B118	#@branch

9f0     B117: #	out( B118 ) &lt;- in( B42 )  Freq: 9.99139e-06
9f0      -- 	// exception oop; no code emitted, #@CreateException
9f0 +   spill R10 -&gt; R11	# spill size = 64

9f4     B118: #	out( N1 ) &lt;- in( B115 B109 B110 B116 B108 B117 B112 )  Freq: 4.89866e-05
9f4     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
a00 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='512'>
----------------------- MetaData before Compile_id = 512 ------------------------
{method}
 - this oop:          0x00000040961efd58
 - method holder:     &apos;java/util/HashMap$HashIterator&apos;
 - constants:         0x00000040961ef810 constant pool [90] {0x00000040961ef810} for &apos;java/util/HashMap$HashIterator&apos; cache=0x00000040961f0040
 - access:            0x81000011  public final 
 - name:              &apos;hasNext&apos;
 - signature:         &apos;()Z&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c56b100
 - code size:         13
 - code start:        0x00000040961efd38
 - code end (excl):   0x00000040961efd45
 - method data:       0x00000040964a2db8
 - checked ex length: 0
 - linenumber start:  0x00000040961efd45
 - localvar length:   1
 - localvar start:    0x00000040961efd4a
 - compiled code: nmethod  21232  290       3       java.util.HashMap$HashIterator::hasNext (13 bytes)

------------------------ OptoAssembly for Compile_id = 512 -----------------------
#
#  bool ( java/util/HashMap$HashIterator:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/HashMap$HashIterator:NotNull *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N17: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N17 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     lwu  R28, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$HashIterator.next
040 +   decode_heap_oop  R7, R28	#@decodeHeapOop
044 +   snez  R10, R7	#@convP2Bool
048     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
060 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='516'>
----------------------- MetaData before Compile_id = 516 ------------------------
{method}
 - this oop:          0x0000004096041f28
 - method holder:     &apos;java/lang/ref/Reference&apos;
 - constants:         0x00000040960410d0 constant pool [195] {0x00000040960410d0} for &apos;java/lang/ref/Reference&apos; cache=0x000000409613f5d0
 - access:            0x81000011  public final 
 - name:              &apos;refersTo&apos;
 - signature:         &apos;(Ljava/lang/Object;)Z&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bd00: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c4fa380
 - code size:         6
 - code start:        0x0000004096041f00
 - code end (excl):   0x0000004096041f06
 - method data:       0x0000004096481ba8
 - checked ex length: 0
 - linenumber start:  0x0000004096041f06
 - localvar length:   2
 - localvar start:    0x0000004096041f0c
 - compiled code: nmethod  21430  148       3       java.lang.ref.Reference::refersTo (6 bytes)

------------------------ OptoAssembly for Compile_id = 516 -----------------------
#
#  bool ( java/lang/ref/Reference:NotNull *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/ref/Reference:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N76: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B5 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R28, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
040 +   mv  R7, narrowklass: precise klass java/lang/ThreadLocal$ThreadLocalMap$Entry: 0x00000040d089d110:Constant:exact *	# compressed klass ptr, #@loadConNKlass
050 +   li R10, #1	# int, #@loadConI
054 +   bne  R28, R7, B5	#@cmpN_branch  P=0.000391 C=-1.000000

058     B2: #	out( B4 B3 ) &lt;- in( B1 )  Freq: 0.999609
058 +   # checkcastPP of R11, #@checkCastPP
058     lwu  R28, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
05c +   decode_heap_oop  R7, R28	#@decodeHeapOop
060     
060 +   beq  R7, R12, B4	#@cmpP_branch  P=0.500000 C=-1.000000

064     B3: #	out( B4 ) &lt;- in( B2 )  Freq: 0.499805
064 +   li R10, #0	# int, #@loadConI

068     B4: #	out( N76 ) &lt;- in( B2 B3 B6 B7 )  Freq: 1
068     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
080 +   ret	// return register, #@Ret

084     B5: #	out( B8 B6 ) &lt;- in( B1 )  Freq: 0.000390708
084 +   mv  R7, narrowklass: precise klass java/util/WeakHashMap$Entry: 0x00000040d089d9e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
094 +   bne  R28, R7, B8	#@cmpN_branch  P=0.000001 C=-1.000000

098     B6: #	out( B4 B7 ) &lt;- in( B5 )  Freq: 0.000390708
098 +   # checkcastPP of R11, #@checkCastPP
098     lwu  R28, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
09c +   decode_heap_oop  R7, R28	#@decodeHeapOop
0a0     
0a0 +   beq  R7, R12, B4	#@cmpP_branch  P=0.500000 C=-1.000000

0a4     B7: #	out( B4 ) &lt;- in( B6 )  Freq: 0.000195354
0a4 +   li R10, #0	# int, #@loadConI
0a8 +   j  B4	#@branch

0ac     B8: #	out( N76 ) &lt;- in( B5 )  Freq: 3.90708e-10
0ac +   spill R11 -&gt; R8	# spill size = 64
0b0 +   spill R12 -&gt; [sp, #0]	# spill size = 64
0b4 +   li R11, #-58	# int, #@loadConI
0b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;bimorphic&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ref.Reference::refersTo @ bci:2 (line 366) L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop off=188/0xbc}
0bc     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='517'>
----------------------- MetaData before Compile_id = 517 ------------------------
{method}
 - this oop:          0x0000004096041fe8
 - method holder:     &apos;java/lang/ref/Reference&apos;
 - constants:         0x00000040960410d0 constant pool [195] {0x00000040960410d0} for &apos;java/lang/ref/Reference&apos; cache=0x000000409613f5d0
 - access:            0x81000000  
 - name:              &apos;refersToImpl&apos;
 - signature:         &apos;(Ljava/lang/Object;)Z&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      8
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bd00: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c4fa880
 - code size:         6
 - code start:        0x0000004096041fc0
 - code end (excl):   0x0000004096041fc6
 - method data:       0x0000004096481d60
 - checked ex length: 0
 - linenumber start:  0x0000004096041fc6
 - localvar length:   2
 - localvar start:    0x0000004096041fcc
 - compiled code: nmethod  21439  149       3       java.lang.ref.Reference::refersToImpl (6 bytes)

------------------------ OptoAssembly for Compile_id = 517 -----------------------
#
#  bool ( java/lang/ref/Reference:NotNull *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/ref/Reference:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N31: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B4 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     lwu  R28, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
040 +   decode_heap_oop  R7, R28	#@decodeHeapOop
044     
044 +   bne  R7, R12, B4	#@cmpP_branch  P=0.500000 C=-1.000000

048     B2: #	out( B3 ) &lt;- in( B1 )  Freq: 0.5
048 +   li R10, #1	# int, #@loadConI

04c     B3: #	out( N31 ) &lt;- in( B2 B4 )  Freq: 1
04c     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

068     B4: #	out( B3 ) &lt;- in( B1 )  Freq: 0.5
068 +   li R10, #0	# int, #@loadConI
06c +   j  B3	#@branch

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='518'>
----------------------- MetaData before Compile_id = 518 ------------------------
{method}
 - this oop:          0x000000409602bb68
 - method holder:     &apos;java/lang/System&apos;
 - constants:         0x0000004096028fd8 constant pool [803]/operands[14] {0x0000004096028fd8} for &apos;java/lang/System&apos; cache=0x000000409614bb90
 - access:            0x81000009  public static 
 - name:              &apos;getSecurityManager&apos;
 - signature:         &apos;()Ljava/lang/SecurityManager;&apos;
 - max stack:         2
 - max locals:        0
 - size of params:    0
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b5c0: 0x i2c: 0x00000040139d1a40 c2i: 0x00000040139d1a80 c2iUV: 0x00000040139d1a4c
 - compiled entry     0x000000400c4f2100
 - code size:         12
 - code start:        0x000000409602bb48
 - code end (excl):   0x000000409602bb54
 - method data:       0x000000409658e908
 - checked ex length: 0
 - linenumber start:  0x000000409602bb54
 - localvar length:   0
 - compiled code: nmethod  21455  124       3       java.lang.System::getSecurityManager (12 bytes)

------------------------ OptoAssembly for Compile_id = 518 -----------------------
#
#  java/lang/SecurityManager * (  )
#
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N1: #	out( B1 ) &lt;- in( B3 B2 )  Freq: 1

000     B1: #	out( B3 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
01c     mv  R7, java/lang/Class:exact *	# ptr, #@loadConP
034 +   lw  R29, [R7, #156]	# int, #@loadI ! Field: java/lang/System.allowSecurityManager (constant)
038 +   li R28, #1	# int, #@loadConI
03c +   beq  R29, R28, B3	#@cmpI_branch  P=0.000000 C=10396.000000

040     B2: #	out( N1 ) &lt;- in( B1 )  Freq: 1
040 +   lwu  R28, [R7, #124]	# loadN, compressed ptr, #@loadN ! Field: volatile java/lang/System.security
044 +   #@membar_acquire
	fence ir iorw
048 +   decode_heap_oop  R10, R28	#@decodeHeapOop
04c     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

068     B3: #	out( N1 ) &lt;- in( B1 )  Freq: 4.76837e-07
068 +   li R11, #-187	# int, #@loadConI
06c     spill R29 -&gt; R8	# spill size = 32
070     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.System::allowSecurityManager @ bci:4 (line 193) STK[0]=R8 STK[1]=#1
        # java.lang.System::getSecurityManager @ bci:0 (line 483)
        # OopMap {off=116/0x74}
074 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>
<writer thread='3870970'/>
<dependency_failed type='unique_concrete_method_4' ctxk='java/util/function/Predicate' x='java.nio.file.Files$$Lambda$6/0x00000008000180e8 test (Ljava/lang/Object;)Z' x2='java/util/function/Predicate' x3='java.util.function.Predicate test (Ljava/lang/Object;)Z' witness='java/util/function/Predicate' stamp='21.838'/>
<dependency_failed type='unique_implementor' ctxk='java/util/function/Predicate' x='java/nio/file/Files$$Lambda$6+0x00000008000180e8' witness='java/util/function/Predicate' stamp='21.838'/>
<writer thread='3870982'/>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='555'>
----------------------- MetaData before Compile_id = 555 ------------------------
{method}
 - this oop:          0x00000040965e6108
 - method holder:     &apos;java/util/stream/ReferencePipeline$2$1&apos;
 - constants:         0x00000040965e5c18 constant pool [69] {0x00000040965e5c18} for &apos;java/util/stream/ReferencePipeline$2$1&apos; cache=0x00000040965e61d8
 - access:            0x81000001  public 
 - name:              &apos;accept&apos;
 - signature:         &apos;(Ljava/lang/Object;)V&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     4
 - vtable index:      7
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bd00: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x00000040139d7c88
 - code size:         27
 - code start:        0x00000040965e60c8
 - code end (excl):   0x00000040965e60e3
 - method data:       0x0000004096492570
 - checked ex length: 0
 - linenumber start:  0x00000040965e60e3
 - localvar length:   2
 - localvar start:    0x00000040965e60ec

------------------------ OptoAssembly for Compile_id = 555 -----------------------
#
#  void ( java/util/stream/ReferencePipeline$2$1:NotNull *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/stream/ReferencePipeline$2$1:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 96 --
#r263 sp+92: in_preserve
#r262 sp+88: return address
#r261 sp+84: in_preserve
#r260 sp+80: saved fp register
#r259 sp+76: pad2, stack alignment
#r258 sp+72: pad2, stack alignment
#r257 sp+68: Fixed slot 1
#r256 sp+64: Fixed slot 0
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N832: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B66 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=96
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #96
	
03c     lwu  R7, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$2$1.this$1
040 +   spill R12 -&gt; [sp, #8]	# spill size = 64
044 +   spill R11 -&gt; [sp, #0]	# spill size = 64
048 +   decode_heap_oop  R7, R7	#@decodeHeapOop
04c     lwu  R28, [R7, #52]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$2.val$predicate
050     NullCheck R7

050     B2: #	out( B67 B3 ) &lt;- in( B1 )  Freq: 0.999999
050 +   decode_heap_oop  R11, R28	#@decodeHeapOop
054     lwu  R7, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
058     NullCheck R11

058     B3: #	out( B45 B4 ) &lt;- in( B2 )  Freq: 0.999998
058 +   mv  R29, narrowklass: precise klass java/nio/file/Files$$Lambda$6+0x00000008000180e8: 0x00000040d8278c80:Constant:exact *	# compressed klass ptr, #@loadConNKlass
068 +   bne  R7, R29, B45	#@cmpN_branch  P=0.024948 C=-1.000000

06c     B4: #	out( B68 B5 ) &lt;- in( B3 )  Freq: 0.97505
06c +   # checkcastPP of R11, #@checkCastPP
06c     lwu  R7, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/Files$$Lambda$6+0x00000008000180e8.arg$1 (constant)
070 +   decode_heap_oop  R30, R7	#@decodeHeapOop
074     lwu  R28, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
078     NullCheck R12

078     B5: #	out( B63 B6 ) &lt;- in( B4 )  Freq: 0.975049
078 +   mv  R7, narrowklass: precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d827df10:Constant:exact *	# compressed klass ptr, #@loadConNKlass
088 +   bne  R28, R7, B63	#@cmpN_branch  P=0.000000 C=-1.000000

08c     B6: #	out( B69 B7 ) &lt;- in( B5 )  Freq: 0.975049
08c +   spill R12 -&gt; R7	# spill size = 64
090 +   # checkcastPP of R7, #@checkCastPP
090     lwu  R29, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.file
094 +   lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.attrs
098 +   decode_heap_oop  R31, R29	#@decodeHeapOop
09c +   decode_heap_oop  R29, R7	#@decodeHeapOop
0a0     lwu  R28, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0a4     NullCheck R30

0a4     B7: #	out( B52 B8 ) &lt;- in( B6 )  Freq: 0.975048
0a4 +   mv  R7, narrowklass: precise klass jdk/internal/module/ModulePath$$Lambda$4+0x000000080003fd28: 0x00000040d095e5b0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0b4 +   bne  R28, R7, B52	#@cmpN_branch  P=0.000001 C=-1.000000

0b8     B8: #	out( B70 B9 ) &lt;- in( B7 )  Freq: 0.975047
0b8 +   # checkcastPP of R30, #@checkCastPP
0b8     lwu  R28, [R30, #12]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/module/ModulePath$$Lambda$4+0x000000080003fd28.arg$1 (constant)
0bc +   decode_heap_oop  R28, R28	#@decodeHeapOop
0c0     lwu  R7, [R31, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0c4     NullCheck R31

0c4     B9: #	out( B64 B10 ) &lt;- in( B8 )  Freq: 0.975046
0c4 +   mv  R30, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d0962310:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0d4 +   bne  R7, R30, B64	#@cmpN_branch  P=0.000000 C=-1.000000

0d8     B10: #	out( B71 B11 ) &lt;- in( B9 )  Freq: 0.975046
0d8 +   # checkcastPP of R31, #@checkCastPP
0d8     spill R31 -&gt; [sp, #16]	# spill size = 64
0dc     lwu  R7, [R29, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0e0     NullCheck R29

0e0     B11: #	out( B65 B12 ) &lt;- in( B10 )  Freq: 0.975045
0e0 +   mv  R30, narrowklass: precise klass sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes: 0x00000040d09623e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0f0 +   bne  R7, R30, B65	#@cmpN_branch  P=0.000000 C=-1.000000

0f4     B12: #	out( B51 B13 ) &lt;- in( B11 )  Freq: 0.975045
0f4 +   # checkcastPP of R29, #@checkCastPP
0f4     lwu  R7, [R29, #12]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes.attrs
0f8 +   decode_heap_oop  R7, R7	#@decodeHeapOop
0fc +   beq   R28, zr, B51	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

100     B13: #	out( B72 B14 ) &lt;- in( B12 )  Freq: 0.975044
100     lw  R28, [R7, #12]	# int, #@loadI ! Field: sun/nio/fs/UnixFileAttributes.st_mode
104     NullCheck R7

104     B14: #	out( B44 B15 ) &lt;- in( B13 )  Freq: 0.975043
104 +   li R7, #61440	# int, #@loadConI
108 +   andr  R28, R28, R7	#@andI_reg_reg
10c +   li R7, #32768	# int, #@loadConI
110 +   bne  R28, R7, B44	#@cmpI_branch  P=0.030134 C=5376.000000

114     B15: #	out( B75 B16 ) &lt;- in( B14 )  Freq: 0.945662
114 +   lwu  R28, [R31, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
118 +   mv  R7, java/lang/Class:exact *	# ptr, #@loadConP
130 +   lw  R8, [R7, #156]	# int, #@loadI ! Field: java/lang/System.allowSecurityManager (constant)
134 +   decode_heap_oop  R28, R28	#@decodeHeapOop
138     lwu  R28, [R28, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileSystem.provider
13c     NullCheck R28

13c     B16: #	out( B53 B17 ) &lt;- in( B15 )  Freq: 0.945661
13c +   beq   R28, zr, B53	#@cmpP_narrowOop_imm0_branch  P=0.000001 C=-1.000000

140     B17: #	out( B57 B18 ) &lt;- in( B16 )  Freq: 0.94566
140 +   li R29, #1	# int, #@loadConI
144 +   beq  R8, R29, B57	#@cmpI_branch  P=0.000000 C=10397.000000

148     B18: #	out( B58 B19 ) &lt;- in( B17 )  Freq: 0.945659
148 +   lwu  R28, [R7, #124]	# loadN, compressed ptr, #@loadN ! Field: volatile java/lang/System.security
14c +   #@membar_acquire
	fence ir iorw
150 +   decode_heap_oop  R8, R28	#@decodeHeapOop
154 +   bne   R8, zr, B58	#@cmpP_imm0_branch  P=0.000000 C=10136.000000

158     B19: #	out( B82 B20 ) &lt;- in( B18 )  Freq: 0.945659
158 +   spill R31 -&gt; R11	# spill size = 64
15c     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getFileName @ bci:1 (line 255) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=352/0x160}

160     B20: #	out( B76 B21 ) &lt;- in( B19 )  Freq: 0.94564
        # Block is sole successor of call
160 +   spill [sp, #16] -&gt; R7	# spill size = 64
164 +   lwu  R7, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
168 +   #@membar_acquire
	fence ir iorw
16c +   decode_heap_oop  R7, R7	#@decodeHeapOop
170     lwu  R7, [R7, #12]	# range, #@loadRange
174     NullCheck R7

174     B21: #	out( B59 B22 ) &lt;- in( B20 )  Freq: 0.945639
174 +   bleu  R7, zr, B59	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=5193.000000

178     B22: #	out( B60 B23 ) &lt;- in( B21 )  Freq: 0.945638
178 +   li R28, #1	# int, #@loadConI
17c +   beq  R7, R28, B60	#@cmpI_branch  P=0.000000 C=5193.000000

180     B23: #	out( B77 B24 ) &lt;- in( B22 )  Freq: 0.945638
180 +   spill [sp, #16] -&gt; R28	# spill size = 64
184 +   lwu  R29, [R28, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
188 +   #@membar_acquire
	fence ir iorw
18c +   decode_heap_oop  R31, R29	#@decodeHeapOop
190 +   addw  R30, R7, zr	#@convI2L_reg_reg
194 +   lwu  R28, [R28, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
198 +   slli  R29, R30, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
19c +   addiw  R8, R7, #-1	#@addI_reg_imm
1a0     lwu  R30, [R31, #12]	# range, #@loadRange
1a4     NullCheck R31

1a4     B24: #	out( B54 B25 ) &lt;- in( B23 )  Freq: 0.945637
1a4 +   add R7, R31, R29	# ptr, #@addP_reg_reg
1a8 +   decode_heap_oop  R29, R28	#@decodeHeapOop
1ac +   bgeu  R8, R30, B54	#@cmpU_branch  P=0.000001 C=-1.000000

1b0     B25: #	out( B78 B26 ) &lt;- in( B24 )  Freq: 0.945636
1b0     lwu  R19, [R29, #12]	# range, #@loadRange
1b4     NullCheck R29

1b4     B26: #	out( B55 B27 ) &lt;- in( B25 )  Freq: 0.945635
1b4 +   lw  R8, [R7, #12]	# int, #@loadI
1b8 +   subw  R9, R19, R8	#@subI_reg_reg
1bc +   li R7, #1048576	# int, #@loadConI
1c0 +   addw  R30, R8, zr	#@convI2L_reg_reg
1c4 +   addw  R12, R9, zr	#@convI2L_reg_reg
1c8 +   bgtu  R9, R7, B55	#@cmpU_branch  P=0.000001 C=-1.000000

1cc     B27: #	out( B28 ) &lt;- in( B26 )  Freq: 0.945634
1cc +   addw  R28, R19, zr	#@convI2L_reg_reg
1d0 +   sub  R28, R28, R30	#@subL_reg_reg

1d4     B28: #	out( B56 B29 ) &lt;- in( B27 B55 )  Freq: 0.945635
1d4 +   blt  R8, zr, B56	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

1d8     B29: #	out( B49 B30 ) &lt;- in( B28 )  Freq: 0.945634
1d8 +   bgtu  R9, R7, B49	#@cmpU_branch  P=0.000001 C=-1.000000

1dc     B30: #	out( B49 B31 ) &lt;- in( B29 )  Freq: 0.945633
1dc +   addi  R7, R28, #23	#@addL_reg_imm
1e0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1e0     ld  R18, [R23, #288]	# ptr, #@loadP
1e4 +   andi  R7, R7, #-8	#@andL_reg_imm
1e8 +   ld  R28, [R23, #304]	# ptr, #@loadP
1ec +   add R7, R18, R7	# ptr, #@addP_reg_reg
1f0 +   bgeu  R7, R28, B49	#@cmpP_branch  P=0.000100 C=-1.000000

1f4     B31: #	out( B32 ) &lt;- in( B30 )  Freq: 0.945539
1f4 +   sd  R7, [R23, #288]	# ptr, #@storeP
1f8 +   li R7, #1	# long, #@loadConL
1fc +   sd  R7, [R18]	# long, #@storeL
200 +   mv  R7, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
210 +   sw  R7, [R18, #8]	# compressed klass ptr, #@storeNKlass
214 +   sw  R9, [R18, #12]	# int, #@storeI

218     B32: #	out( B34 B33 ) &lt;- in( B50 B31 )  Freq: 0.945634
218     
218 +   # checkcastPP of R18, #@checkCastPP
218     addi  R20, R18, #16	# ptr, #@addP_reg_imm
21c +   beq  R19, R8, B34	#@cmpI_branch  P=0.000001 C=-1.000000

220     B33: #	out( B34 ) &lt;- in( B32 )  Freq: 0.945633
220 +   add R7, R29, R30	# ptr, #@addP_reg_reg
224     spill R20 -&gt; R11	# spill size = 64
228 +   addi  R10, R7, #16	# ptr, #@addP_reg_imm
22c +   CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

230     B34: #	out( B61 B35 ) &lt;- in( B33 B32 )  Freq: 0.945634
230     
230     beq  R19, R8, B61	#@cmpI_branch  P=0.000000 C=14917.000000

234     B35: #	out( B62 B36 ) &lt;- in( B34 )  Freq: 0.945634
234 +   lb  R8, [R20]	# byte, #@loadB
238 +   li R7, #46	# int, #@loadConI
23c +   beq  R8, R7, B62	#@cmpI_branch  P=0.000000 C=5193.000000

240     B36: #	out( B37 ) &lt;- in( B35 B83 )  Freq: 0.945642
240 +   li R28, #1	# int, #@loadConI

244     B37: #	out( B43 B38 ) &lt;- in( B44 B36 B46 )  Freq: 0.999971
244 +   beq  R28, zr, B43	#@cmpI_reg_imm0_branch  P=0.039230 C=5506.000000

248     B38: #	out( B73 B39 ) &lt;- in( B37 )  Freq: 0.960742
248 +   spill [sp, #0] -&gt; R7	# spill size = 64
24c +   lwu  R7, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/Sink$ChainedReference.downstream
250 +   decode_heap_oop  R11, R7	#@decodeHeapOop
254     lwu  R28, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
258     NullCheck R11

258     B39: #	out( B47 B40 ) &lt;- in( B38 )  Freq: 0.960741
258 +   mv  R7, narrowklass: precise klass java/util/stream/ReferencePipeline$3$1: 0x00000040d8278e20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
268 +   bne  R28, R7, B47	#@cmpN_branch  P=0.003965 C=-1.000000

26c     B40: #	out( B74 B41 ) &lt;- in( B39 )  Freq: 0.956932
26c +   # checkcastPP of R11, #@checkCastPP
26c     lwu  R28, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$3$1.this$1
270 +   decode_heap_oop  R7, R28	#@decodeHeapOop
274     lwu  R7, [R7, #52]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$3.val$mapper
278     NullCheck R7

278     B41: #	out( B85 B42 ) &lt;- in( B40 )  Freq: 0.956931
278 +   lwu  R29, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/Sink$ChainedReference.downstream
27c +   decode_heap_oop  R11, R7	#@decodeHeapOop
280 +   decode_heap_oop  R8, R29	#@decodeHeapOop
284     spill [sp, #8] -&gt; R12	# spill size = 64
288     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.function.Function::apply
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:12 (line 197) L[0]=_ L[1]=_ STK[0]=R8
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:21 (line 179) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=676/0x2a4}

2a4     B42: #	out( B86 B43 ) &lt;- in( B41 )  Freq: 0.956911
        # Block is sole successor of call
2a4 +   spill R8 -&gt; R11	# spill size = 64
2a8 +   spill R10 -&gt; R12	# spill size = 64
2ac     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.stream.Sink::accept
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:21 (line 179) L[0]=_ L[1]=_
        # OopMap {off=712/0x2c8}

2c8     B43: #	out( N832 ) &lt;- in( B42 B48 B37 )  Freq: 0.99993
2c8     # pop frame 96
	add  sp, sp, #96
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
2e0 +   ret	// return register, #@Ret

2e4     B44: #	out( B37 ) &lt;- in( B14 )  Freq: 0.0293819
2e4 +   li R28, #0	# int, #@loadConI
2e8 +   j  B37	#@branch

2ec     B45: #	out( B81 B46 ) &lt;- in( B3 )  Freq: 0.0249476
2ec     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.function.Predicate::test
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop off=776/0x308}

308     B46: #	out( B37 ) &lt;- in( B45 )  Freq: 0.0249471
        # Block is sole successor of call
308 +   spill R10 -&gt; R28	# spill size = 32
30c +   j  B37	#@branch

310     B47: #	out( B80 B48 ) &lt;- in( B39 )  Freq: 0.00380941
310 +   spill [sp, #8] -&gt; R12	# spill size = 64
314     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.stream.Sink::accept
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:21 (line 179) L[0]=_ L[1]=_
        # OopMap {off=816/0x330}

330     B48: #	out( B43 ) &lt;- in( B47 )  Freq: 0.00380934
        # Block is sole successor of call
330 +   j  B43	#@branch

334     B49: #	out( B79 B50 ) &lt;- in( B29 B30 )  Freq: 9.55372e-05
334 +   spill R12 -&gt; [sp, #32]	# spill size = 64
338 +   spill R30 -&gt; [sp, #48]	# spill size = 64
33c +   spill R29 -&gt; [sp, #40]	# spill size = 64
340 +   spill R9 -&gt; [sp, #28]	# spill size = 32
344 +   spill R19 -&gt; [sp, #24]	# spill size = 32
348 +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
360     spill R9 -&gt; R12	# spill size = 32
364     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getFileName @ bci:60 (line 269) L[0]=sp + #16 L[1]=_ L[2]=R8 L[3]=sp + #28 L[4]=_
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [40]=Oop off=872/0x368}

368     B50: #	out( B32 ) &lt;- in( B49 )  Freq: 9.55353e-05
        # Block is sole successor of call
368 +   spill [sp, #24] -&gt; R19	# spill size = 32
36c +   spill [sp, #28] -&gt; R9	# spill size = 32
370 +   spill [sp, #32] -&gt; R12	# spill size = 64
374 +   spill R10 -&gt; R18	# spill size = 64
378 +   spill [sp, #40] -&gt; R29	# spill size = 64
37c +   spill [sp, #48] -&gt; R30	# spill size = 64
380 +   j  B32	#@branch

384     B51: #	out( N832 ) &lt;- in( B12 )  Freq: 9.87993e-07
384 +   li R11, #-10	# int, #@loadConI
388     spill R31 -&gt; R8	# spill size = 64
38c +   spill R29 -&gt; [sp, #0]	# spill size = 64
390     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL STK[1]=R8 STK[2]=sp + #0
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=916/0x394}
394     #@ShouldNotReachHere

3a0     B52: #	out( N832 ) &lt;- in( B7 )  Freq: 9.75048e-07
3a0 +   spill [sp, #0] -&gt; R8	# spill size = 64
3a4 +   li R11, #-34	# int, #@loadConI
3a8     spill R12 -&gt; [sp, #0]	# spill size = 64
3ac +   spill R30 -&gt; [sp, #8]	# spill size = 64
3b0 +   spill R31 -&gt; [sp, #16]	# spill size = 64
3b4 +   spill R29 -&gt; [sp, #24]	# spill size = 64
3b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_ STK[0]=sp + #8 STK[1]=sp + #16 STK[2]=sp + #24
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=956/0x3bc}
3bc     #@ShouldNotReachHere

3c8     B53: #	out( N832 ) &lt;- in( B16 )  Freq: 9.58218e-07
3c8 +   spill [sp, #0] -&gt; R8	# spill size = 64
3cc +   li R11, #-10	# int, #@loadConI
3d0     spill R12 -&gt; [sp, #0]	# spill size = 64
3d4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_ STK[0]=#NULL STK[1]=sp + #16
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=984/0x3d8}
3d8     #@ShouldNotReachHere

3e4     B54: #	out( N832 ) &lt;- in( B24 )  Freq: 9.58194e-07
3e4 +   li R11, #-28	# int, #@loadConI
3e8     spill R31 -&gt; [sp, #24]	# spill size = 64
3ec     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:49 (line 267) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #24 STK[1]=R8
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop off=1008/0x3f0}
3f0     #@ShouldNotReachHere

3fc     B55: #	out( B28 ) &lt;- in( B26 )  Freq: 9.58192e-07
3fc +   spill R12 -&gt; R28	# spill size = 64
400 +   j  B28	#@branch

404     B56: #	out( N832 ) &lt;- in( B28 )  Freq: 9.45635e-07
404 +   li R11, #-52	# int, #@loadConI
408     spill R9 -&gt; [sp, #28]	# spill size = 32
40c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:60 (line 269) L[0]=sp + #16 L[1]=_ L[2]=R8 L[3]=sp + #28 L[4]=_ STK[0]=sp + #28
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=1040/0x410}
410     #@ShouldNotReachHere

41c     B57: #	out( N832 ) &lt;- in( B17 )  Freq: 4.50926e-07
41c +   li R11, #-187	# int, #@loadConI
420     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.System::allowSecurityManager @ bci:4 (line 193) STK[0]=R8 STK[1]=#1
        # java.lang.System::getSecurityManager @ bci:0 (line 483)
        # sun.nio.fs.UnixPath::checkRead @ bci:0 (line 778) L[0]=sp + #16 L[1]=_
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:6 (line 352) L[0]=_ L[1]=_ L[2]=sp + #16 L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=1060/0x424}
424     #@ShouldNotReachHere

430     B58: #	out( N832 ) &lt;- in( B18 )  Freq: 4.50925e-07
430 +   li R11, #-187	# int, #@loadConI
434     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::checkRead @ bci:5 (line 779) L[0]=sp + #16 L[1]=R8 STK[0]=R8
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:6 (line 352) L[0]=_ L[1]=_ L[2]=sp + #16 L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=1080/0x438}
438     #@ShouldNotReachHere

444     B59: #	out( N832 ) &lt;- in( B21 )  Freq: 4.50916e-07
444 +   spill [sp, #0] -&gt; R8	# spill size = 64
448 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
450 +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
458 +   li R11, #-187	# int, #@loadConI
45c     spill R7 -&gt; [sp, #20]	# spill size = 32
460     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:11 (line 260) L[0]=sp + #8 L[1]=sp + #20 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #20
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=1124/0x464}
464     #@ShouldNotReachHere

470     B60: #	out( N832 ) &lt;- in( B22 )  Freq: 4.50916e-07
470 +   spill [sp, #0] -&gt; R8	# spill size = 64
474 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
47c +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
484 +   li R11, #-187	# int, #@loadConI
488     spill R7 -&gt; [sp, #20]	# spill size = 32
48c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:18 (line 264) L[0]=sp + #8 L[1]=sp + #20 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #20 STK[1]=#1
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=1168/0x490}
490     #@ShouldNotReachHere

49c     B61: #	out( N832 ) &lt;- in( B34 )  Freq: 4.50913e-07
49c +   spill [sp, #16] -&gt; R7	# spill size = 64
4a0 +   lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
4a4 +   decode_heap_oop  R8, R7	#@decodeHeapOop
4a8 +   li R11, #-187	# int, #@loadConI
4ac     spill R9 -&gt; [sp, #16]	# spill size = 32
4b0 +   spill R18 -&gt; [sp, #24]	# spill size = 64
4b4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::isEmpty @ bci:5 (line 216) L[0]=_ STK[0]=sp + #16
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:21 (line 358) L[0]=_ L[1]=_ L[2]=_ L[3]=#ScObj0 L[4]=_
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=R8, [path :2]=sp + #24, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop off=1208/0x4b8}
4b8     #@ShouldNotReachHere

4c4     B62: #	out( N832 ) &lt;- in( B35 )  Freq: 4.50913e-07
4c4 +   li R11, #-187	# int, #@loadConI
4c8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:51 (line 363) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=R8 STK[1]=#46
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop off=1228/0x4cc}
4cc     #@ShouldNotReachHere

4d8     B63: #	out( N832 ) &lt;- in( B5 )  Freq: 1e-35
4d8 +   li R11, #-34	# int, #@loadConI
4dc     spill [sp, #0] -&gt; R8	# spill size = 64
4e0 +   spill R30 -&gt; [sp, #16]	# spill size = 64
4e4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:5 L[0]=_ L[1]=_ STK[0]=sp + #16 STK[1]=sp + #8
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=1256/0x4e8}
4e8     #@ShouldNotReachHere

4f4     B64: #	out( N832 ) &lt;- in( B9 )  Freq: 1e-35
4f4 +   spill [sp, #0] -&gt; R8	# spill size = 64
4f8 +   li R11, #-34	# int, #@loadConI
4fc     spill R12 -&gt; [sp, #0]	# spill size = 64
500 +   spill R29 -&gt; [sp, #8]	# spill size = 64
504 +   spill R28 -&gt; [sp, #16]	# spill size = 64
508 +   spill R31 -&gt; [sp, #24]	# spill size = 64
50c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:5 L[0]=_ L[1]=_ L[2]=sp + #8 STK[0]=sp + #16 STK[1]=sp + #24
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=1296/0x510}
510     #@ShouldNotReachHere

51c     B65: #	out( N832 ) &lt;- in( B11 )  Freq: 1e-35
51c +   spill [sp, #0] -&gt; R8	# spill size = 64
520 +   li R11, #-34	# int, #@loadConI
524     spill R12 -&gt; [sp, #0]	# spill size = 64
528 +   spill R28 -&gt; [sp, #8]	# spill size = 64
52c +   spill R29 -&gt; [sp, #24]	# spill size = 64
530     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:9 L[0]=_ L[1]=_ L[2]=_ STK[0]=sp + #8 STK[1]=sp + #16 STK[2]=sp + #24
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=1332/0x534}
534     #@ShouldNotReachHere

540     B66: #	out( N832 ) &lt;- in( B1 )  Freq: 1.01328e-06
540 +   li R11, #-10	# int, #@loadConI
544     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:4 (line 178) L[0]=_ L[1]=_ STK[0]=#NULL
        # OopMap {off=1352/0x548}
548     #@ShouldNotReachHere

554     B67: #	out( N832 ) &lt;- in( B2 )  Freq: 1.01328e-06
554 +   li R11, #-10	# int, #@loadConI
558     spill R12 -&gt; R8	# spill size = 64
55c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8
        # OopMap {fp=Oop off=1376/0x560}
560     #@ShouldNotReachHere

56c     B68: #	out( N832 ) &lt;- in( B4 )  Freq: 9.87998e-07
56c +   spill [sp, #0] -&gt; R8	# spill size = 64
570 +   li R11, #-12	# int, #@loadConI
574     spill R12 -&gt; [sp, #0]	# spill size = 64
578 +   spill R30 -&gt; [sp, #8]	# spill size = 64
57c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:5 L[0]=_ L[1]=_ STK[0]=sp + #8 STK[1]=#NULL
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=1408/0x580}
580     #@ShouldNotReachHere

58c     B69: #	out( N832 ) &lt;- in( B6 )  Freq: 9.87997e-07
58c +   li R11, #-10	# int, #@loadConI
590     spill R31 -&gt; R8	# spill size = 64
594 +   spill R29 -&gt; [sp, #0]	# spill size = 64
598     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8 STK[2]=sp + #0
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=1436/0x59c}
59c     #@ShouldNotReachHere

5a8     B70: #	out( N832 ) &lt;- in( B8 )  Freq: 9.87995e-07
5a8 +   spill [sp, #0] -&gt; R8	# spill size = 64
5ac +   li R11, #-12	# int, #@loadConI
5b0     spill R12 -&gt; [sp, #0]	# spill size = 64
5b4 +   spill R29 -&gt; [sp, #8]	# spill size = 64
5b8 +   spill R28 -&gt; [sp, #16]	# spill size = 64
5bc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:5 L[0]=_ L[1]=_ L[2]=sp + #8 STK[0]=sp + #16 STK[1]=#NULL
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=1472/0x5c0}
5c0     #@ShouldNotReachHere

5cc     B71: #	out( N832 ) &lt;- in( B10 )  Freq: 9.87994e-07
5cc +   spill [sp, #0] -&gt; R8	# spill size = 64
5d0 +   li R11, #-12	# int, #@loadConI
5d4     spill R12 -&gt; [sp, #0]	# spill size = 64
5d8 +   spill R28 -&gt; [sp, #8]	# spill size = 64
5dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:9 L[0]=_ L[1]=_ L[2]=_ STK[0]=sp + #8 STK[1]=sp + #16 STK[2]=#NULL
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=1504/0x5e0}
5e0     #@ShouldNotReachHere

5ec     B72: #	out( N832 ) &lt;- in( B13 )  Freq: 9.87992e-07
5ec +   li R11, #-10	# int, #@loadConI
5f0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes::isRegularFile @ bci:4 (line 295) L[0]=_ STK[0]=#NULL
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:1 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=_ L[1]=_
        # OopMap {off=1524/0x5f4}
5f4     #@ShouldNotReachHere

600     B73: #	out( N832 ) &lt;- in( B38 )  Freq: 9.735e-07
600 +   li R11, #-10	# int, #@loadConI
604     spill [sp, #8] -&gt; R8	# spill size = 64
608     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:21 (line 179) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8
        # OopMap {fp=Oop off=1548/0x60c}
60c     #@ShouldNotReachHere

618     B74: #	out( N832 ) &lt;- in( B40 )  Freq: 9.69639e-07
618 +   li R11, #-10	# int, #@loadConI
61c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:8 (line 197) L[0]=_ L[1]=_ STK[0]=_ STK[1]=#NULL
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:21 (line 179) L[0]=_ L[1]=_
        # OopMap {off=1568/0x620}
620     #@ShouldNotReachHere

62c     B75: #	out( N832 ) &lt;- in( B15 )  Freq: 9.58219e-07
62c +   li R11, #-10	# int, #@loadConI
630     spill [sp, #0] -&gt; R8	# spill size = 64
634     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::provider @ bci:6 (line 105) L[0]=_ STK[0]=#NULL
        # java.nio.file.Files::isHidden @ bci:1 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=1592/0x638}
638     #@ShouldNotReachHere

644     B76: #	out( N832 ) &lt;- in( B20 )  Freq: 9.58197e-07
644 +   li R11, #-10	# int, #@loadConI
648     spill [sp, #0] -&gt; R8	# spill size = 64
64c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:8 (line 257) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=1616/0x650}
650     #@ShouldNotReachHere

65c     B77: #	out( N832 ) &lt;- in( B23 )  Freq: 9.58195e-07
65c +   li R11, #-10	# int, #@loadConI
660     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:49 (line 267) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop off=1636/0x664}
664     #@ShouldNotReachHere

670     B78: #	out( N832 ) &lt;- in( B25 )  Freq: 9.58193e-07
670 +   li R11, #-10	# int, #@loadConI
674     spill [sp, #0] -&gt; R8	# spill size = 64
678     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:55 (line 268) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=1660/0x67c}
67c     #@ShouldNotReachHere

688     B79: #	out( B83 ) &lt;- in( B49 )  Freq: 9.55372e-10
688      -- 	// exception oop; no code emitted, #@CreateException
688 +   lwu  R7, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
68c +   j  B83	#@branch

690     B80: #	out( B88 ) &lt;- in( B47 )  Freq: 3.80941e-08
690      -- 	// exception oop; no code emitted, #@CreateException
690 +   spill R10 -&gt; R11	# spill size = 64
694 +   j  B88	#@branch

698     B81: #	out( B88 ) &lt;- in( B45 )  Freq: 2.49476e-07
698      -- 	// exception oop; no code emitted, #@CreateException
698 +   spill R10 -&gt; R11	# spill size = 64
69c +   j  B88	#@branch

6a0     B82: #	out( B83 ) &lt;- in( B19 )  Freq: 9.45659e-06
6a0      -- 	// exception oop; no code emitted, #@CreateException
6a0 +   lwu  R7, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass

6a4     B83: #	out( B36 B84 ) &lt;- in( B82 B79 )  Freq: 9.45754e-06
6a4 +   mv  R29, narrowklass: precise klass java/io/IOException: 0x00000040d06fde30:Constant:exact *	# compressed klass ptr, #@loadConNKlass
6b4 +   beq  R7, R29, B36	#@cmpN_branch  P=0.900000 C=-1.000000

6b8     B84: #	out( B88 ) &lt;- in( B83 )  Freq: 9.45755e-07
6b8 +   spill R10 -&gt; R11	# spill size = 64
6bc +   j  B88	#@branch

6c0     B85: #	out( B87 ) &lt;- in( B41 )  Freq: 9.56931e-06
6c0      -- 	// exception oop; no code emitted, #@CreateException
6c0 +   j  B87	#@branch

6c4     B86: #	out( B87 ) &lt;- in( B42 )  Freq: 9.56911e-06
6c4      -- 	// exception oop; no code emitted, #@CreateException

6c4     B87: #	out( B88 ) &lt;- in( B85 B86 )  Freq: 1.91384e-05
6c4 +   spill R10 -&gt; R11	# spill size = 64

6c8     B88: #	out( N832 ) &lt;- in( B81 B84 B80 B87 )  Freq: 2.03717e-05
6c8     # pop frame 96
	add  sp, sp, #96
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
6d4 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>
<writer thread='3870970'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashSet' witness='java/util/LinkedHashSet' stamp='22.471'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashSet' witness='java/util/LinkedHashSet' stamp='22.471'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashSet' witness='java/util/LinkedHashSet' stamp='22.471'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashSet' witness='java/util/LinkedHashSet' stamp='22.471'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashSet' witness='java/util/LinkedHashSet' stamp='22.471'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashSet' witness='java/util/LinkedHashSet' stamp='22.471'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.482'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.482'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.482'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.482'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.482'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.482'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.482'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.482'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.482'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.482'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.482'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.483'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.483'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.483'/>
<writer thread='3870982'/>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='572'>
----------------------- MetaData before Compile_id = 572 ------------------------
{method}
 - this oop:          0x0000004096291480
 - method holder:     &apos;java/util/HashSet&apos;
 - constants:         0x00000040962901e0 constant pool [285] {0x00000040962901e0} for &apos;java/util/HashSet&apos; cache=0x0000004096291e18
 - access:            0x81000001  public 
 - name:              &apos;add&apos;
 - signature:         &apos;(Ljava/lang/Object;)Z&apos;
 - max stack:         4
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     4
 - vtable index:      5
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bd00: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x00000040139d7c88
 - code size:         20
 - code start:        0x0000004096291448
 - code end (excl):   0x000000409629145c
 - method data:       0x000000409648dd90
 - checked ex length: 0
 - linenumber start:  0x000000409629145c
 - localvar length:   2
 - localvar start:    0x0000004096291464

------------------------ OptoAssembly for Compile_id = 572 -----------------------
#
#  bool ( java/util/HashSet:NotNull *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/HashSet:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 96 --
#r263 sp+92: in_preserve
#r262 sp+88: return address
#r261 sp+84: in_preserve
#r260 sp+80: saved fp register
#r259 sp+76: pad2, stack alignment
#r258 sp+72: pad2, stack alignment
#r257 sp+68: Fixed slot 1
#r256 sp+64: Fixed slot 0
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1592: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B127 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=96
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #96
	
03c     lwu  R28, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashSet.map
040 +   decode_heap_oop  R7, R28	#@decodeHeapOop
044     spill R7 -&gt; [sp, #0]	# spill size = 64
048     lwu  R28, [R7, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
04c     NullCheck R7

04c     B2: #	out( B128 B3 ) &lt;- in( B1 )  Freq: 0.999999
04c +   spill R28 -&gt; [sp, #8]	# spill size = 32
050     lwu  R29, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
054     NullCheck R12

054     B3: #	out( B77 B4 ) &lt;- in( B2 )  Freq: 0.999999
054 +   decode_klass_not_null  R28, R29	#@decodeKlass_not_null
060 +   ld  R28, [R28, #504]	# ptr, #@loadP
064 +   mv  R7, metadataptr:Constant0x00000040d0923720	# ptr, #@loadConP
07c +   bne  R28, R7, B77	#@cmpP_branch  P=0.001000 C=-1.000000

080     B4: #	out( B77 B5 ) &lt;- in( B3 )  Freq: 0.998999
080 +   ld  R7, [R12]	# int, #@loadL
084 +   li R30, #1	# long, #@loadConL
088 +   andi  R28, R7, #7	#@andL_reg_imm
08c +   bne  R28, R30, B77	#@cmpL_branch  P=0.001000 C=-1.000000

090     B5: #	out( B77 B6 ) &lt;- in( B4 )  Freq: 0.998
090 +   srli  R7, R7, (#8 &amp; 0x3f)	#@urShiftL_reg_imm
094 +   li R30, #2147483647	# int, #@loadConI
09c +   addw  R7, R7, zr	#@convL2I_reg
0a0 +   andr  R10, R7, R30	#@andI_reg_reg
0a4 +   beq  R10, zr, B77	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0a8     B6: #	out( B68 B7 ) &lt;- in( B78 B5 )  Freq: 0.999998
0a8 +   spill [sp, #0] -&gt; R7	# spill size = 64
0ac +   lwu  R28, [R7, #36]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap.table
0b0 +   srliw  R7, R10, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
0b4 +   decode_heap_oop  R18, R28	#@decodeHeapOop
0b8 +   xorr  R19, R7, R10	#@xorI_reg_reg
0bc +   beq   R18, zr, B68	#@cmpP_imm0_branch  P=0.172414 C=5452.000000

0c0     B7: #	out( B108 B8 ) &lt;- in( B6 )  Freq: 0.827585
0c0 +   lwu  R7, [R18, #12]	# range, #@loadRange
0c4 +   bleu  R7, zr, B108	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=4512.000000

0c8     B8: #	out( B106 B9 ) &lt;- in( B70 B7 )  Freq: 0.999994
0c8 +   addiw  R30, R7, #-1	#@addI_reg_imm
0cc +   andr  R28, R30, R19	#@andI_reg_reg
0d0 +   addw  R30, R28, zr	#@convI2L_reg_reg
0d4 +   slli  R30, R30, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0d8 +   add R30, R18, R30	# ptr, #@addP_reg_reg
0dc +   addi  R9, R30, #16	# ptr, #@addP_reg_imm
0e0 +   ble  R7, zr, B106	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0e4     B9: #	out( B39 B10 ) &lt;- in( B8 )  Freq: 0.999993
0e4 +   lwu  R7, [R9]	# loadN, compressed ptr, #@loadN
0e8 +   decode_heap_oop  R7, R7	#@decodeHeapOop
0ec +   encode_heap_oop  R31, R12	#@encodeHeapOop
0f0 +   mv  R15, NULL	# NULL ptr, #@loadConP0
0f4 +   mv  R30, narrowklass: precise klass java/util/HashMap$Node: 0x00000040d0926900:Constant:exact *	# compressed klass ptr, #@loadConNKlass
104 +   beq   R7, zr, B39	#@cmpP_imm0_branch  P=0.514857 C=5452.000000

108     B10: #	out( B51 B11 ) &lt;- in( B9 )  Freq: 0.48514
108 +   lw  R13, [R7, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
10c +   mv  R11, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
11c +   li R10, #0	# int, #@loadConI
120 +   beq  R13, R19, B51	#@cmpI_branch  P=0.440832 C=2645.000000

124     B11: #	out( B110 B12 ) &lt;- in( B10 )  Freq: 0.271275
124 +   lwu  R28, [R7, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
128 +   lwu  R14, [R7, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
12c +   decode_heap_oop  R21, R28	#@decodeHeapOop
130 +   mv  R28, narrowklass: precise klass java/util/HashMap$TreeNode: 0x00000040d0928210:Constant:exact *	# compressed klass ptr, #@loadConNKlass
140 +   beq  R14, R28, B110	#@cmpN_branch  P=0.000001 C=-1.000000

144     B12: #	out( B24 B13 ) &lt;- in( B11 )  Freq: 0.271275
144 +   bne   R21, zr, B24	#@cmpP_imm0_branch  P=0.615385 C=1729.000000

148     B13: #	out( B14 ) &lt;- in( B12 )  Freq: 0.104336
148 +   li R20, #0	# int, #@loadConI
14c     spill R7 -&gt; R21	# spill size = 64

150     B14: #	out( B79 B15 ) &lt;- in( B26 B13 )  Freq: 0.121973
150 +   mv  R28, narrowklass: precise klass java/util/HashMap: 0x00000040d0215ca0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
160     spill [sp, #8] -&gt; R7	# spill size = 32
164 +   bne  R7, R28, B79	#@cmpN_branch  P=0.004732 C=-1.000000

168     B15: #	out( B104 B16 ) &lt;- in( B14 )  Freq: 0.121395
168 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
168     ld  R22, [R23, #288]	# ptr, #@loadP
16c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
16c     ld  R7, [R23, #304]	# ptr, #@loadP
170 +   addi  R28, R22, #32	# ptr, #@addP_reg_imm
174 +   bgeu  R28, R7, B104	#@cmpP_branch  P=0.000100 C=-1.000000

178     B16: #	out( B17 ) &lt;- in( B15 )  Freq: 0.121383
178 +   li R7, #1	# long, #@loadConL
17c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
17c     sd  R28, [R23, #288]	# ptr, #@storeP
180 +   sd  R7, [R22]	# long, #@storeL
184 +   sw  R30, [R22, #8]	# compressed klass ptr, #@storeNKlass
188 +   sw  zr, [R22, #12]	# int, #@storeimmI0
18c +   sw  zr, [R22, #16]	# int, #@storeimmI0
190 +   sd  zr, [R22, #24]	# long, #@storeimmL0

194     B17: #	out( B18 ) &lt;- in( B105 B16 )  Freq: 0.121395
194 +   mv  R7, narrowoop: java/lang/Object:exact *	# compressed ptr, #@loadConN
1a4 +   sw  R7, [R22, #20]	# compressed ptr, #@storeN
1a8     
1a8 +   # checkcastPP of R22, #@checkCastPP
1a8     sw  R31, [R22, #16]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.key
1ac +   sw  R19, [R22, #12]	# int, #@storeI ! Field: java/util/HashMap$Node.hash
1b0 +   #@membar_release
	fence iorw ow

1b4     B18: #	out( B95 B19 ) &lt;- in( B17 B80 )  Freq: 0.121973
1b4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b4     lb  R28, [R23, #56]	# byte, #@loadB
1b8 +   bne  R28, zr, B95	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1bc     B19: #	out( B22 B20 ) &lt;- in( B124 B97 B95 B18 )  Freq: 0.121973
1bc +   mv  R28, R21	# ptr -&gt; long, #@castP2X
1c0 +   mv  R7, R22	# ptr -&gt; long, #@castP2X
1c4 +   xorr  R7, R7, R28	#@xorL_reg_reg
1c8 +   encode_heap_oop  R29, R22	#@encodeHeapOop
1cc +   srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
1d0 +   li R9, #7	# int, #@loadConI
1d4 +   sw  R29, [R21, #24]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.next
1d8 +   beq  R7, zr, B22	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1dc     B20: #	out( B22 B21 ) &lt;- in( B19 )  Freq: 0.121851
1dc +   beq   R22, zr, B22	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

1e0     B21: #	out( B98 B22 ) &lt;- in( B20 )  Freq: 0.121729
1e0 +   srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1e4 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1f0 +   add R10, R28, R7	# ptr, #@addP_reg_reg
1f4 +   lb  R28, [R10]	# byte, #@loadB
1f8 +   li R7, #4	# int, #@loadConI
1fc +   bne  R28, R7, B98	#@cmpI_branch  P=0.001000 C=-1.000000

200     B22: #	out( B48 B23 ) &lt;- in( B100 B101 B98 B21 B20 B19 )  Freq: 0.121973
200 +   blt  R20, R9, B48	#@cmpI_branch  P=1.000000 C=665.000000

204     B23: #	out( N1592 ) &lt;- in( B22 )  Freq: 5.81611e-08
204 +   spill [sp, #0] -&gt; R8	# spill size = 64
208 +   li R11, #-187	# int, #@loadConI
20c     spill R19 -&gt; [sp, #0]	# spill size = 32
210 +   spill R18 -&gt; [sp, #8]	# spill size = 64
214 +   spill R20 -&gt; [sp, #4]	# spill size = 32
218     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:162 (line 641) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=#Ptr0x00000040d02184e0 L[4]=#0 L[5]=#1 L[6]=sp + #8 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=_ STK[0]=sp + #4 STK[1]=#7
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop off=540/0x21c}
21c     #@ShouldNotReachHere

228     B24: #	out( B25 ) &lt;- in( B12 )  Freq: 0.166938
228 +   li R20, #0	# int, #@loadConI

22c     B25: #	out( B28 B26 ) &lt;- in( B24 B27 ) Loop( B25-B27 inner ) Freq: 0.195156
22c +   lw  R28, [R21, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
230 +   beq  R28, R19, B28	#@cmpI_branch  P=0.765038 C=1064.000000

234     B26: #	out( B14 B27 ) &lt;- in( B25 )  Freq: 0.0458544
234 +   addiw  R20, R20, #1	#@addI_reg_imm
238 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
238     ld  R7, [R23, #920]	# ptr, #@loadP
23c +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.util.HashMap::putVal @ bci:219 (line 638) L[0]=sp + #0 L[1]=R19 L[2]=R12 L[3]=#Ptr0x00000040d02184e0 L[4]=#0 L[5]=#1 L[6]=R18 L[7]=R21 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=R20
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {xmethod=NarrowOop c_rarg2=Oop x18=Oop xdispatch=Oop [0]=Oop off=572/0x23c}
240 +   lwu  R28, [R21, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
244 +   decode_heap_oop  R7, R28	#@decodeHeapOop
248 +   beq   R7, zr, B14	#@cmpP_imm0_branch  P=0.384615 C=250.000000

24c     B27: #	out( B25 ) &lt;- in( B26 )  Freq: 0.0282181
24c +   spill R7 -&gt; R21	# spill size = 64
250 +   j  B25	#@branch

254     B28: #	out( B122 B29 ) &lt;- in( B25 )  Freq: 0.149302
254 +   lwu  R7, [R21, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
258 +   decode_heap_oop  R31, R7	#@decodeHeapOop
25c +   beq  R31, R12, B122	#@cmpP_branch  P=0.000000 C=814.000000

260     B29: #	out( B117 B30 ) &lt;- in( B28 )  Freq: 0.149302
260 +   bne  R29, R11, B117	#@cmpN_branch  P=0.000001 C=-1.000000

264     B30: #	out( B62 B31 ) &lt;- in( B29 )  Freq: 0.149302
264 +   # checkcastPP of R12, #@checkCastPP
264     beq  R12, R31, B62	#@cmpP_branch  P=0.064818 C=5338.000000

268     B31: #	out( B131 B32 ) &lt;- in( B30 )  Freq: 0.139624
268     lwu  R28, [R31, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
26c     NullCheck R31

26c     B32: #	out( B125 B33 ) &lt;- in( B31 )  Freq: 0.139624
26c +   mv  R30, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
27c +   lwu  R7, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
280 +   lb  R29, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
284 +   bne  R28, R30, B125	#@cmpN_branch  P=0.000000 C=-1.000000

288     B33: #	out( B123 B34 ) &lt;- in( B32 )  Freq: 0.139624
288 +   # checkcastPP of R31, #@checkCastPP
288     lb  R8, [R31, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
28c +   lwu  R28, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
290 +   decode_heap_oop  R7, R7	#@decodeHeapOop
294 +   bne  R29, R8, B123	#@cmpI_branch  P=0.000000 C=4992.000000

298     B34: #	out( B118 B35 ) &lt;- in( B33 )  Freq: 0.139624
298 +   beq   R7, zr, B118	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

29c     B35: #	out( B119 B36 ) &lt;- in( B34 )  Freq: 0.139624
29c +   decode_heap_oop  R28, R28	#@decodeHeapOop
2a0 +   lwu  R14, [R7, #12]	# range, #@loadRange
2a4 +   beq   R28, zr, B119	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

2a8     B36: #	out( B38 B37 ) &lt;- in( B35 )  Freq: 0.139624
2a8 +   lwu  R29, [R28, #12]	# range, #@loadRange
2ac +   bne  R14, R29, B38	#@cmpI_branch  P=0.000001 C=-1.000000

2b0     B37: #	out( B62 B38 ) &lt;- in( B36 )  Freq: 0.139624
2b0 +   addi  R13, R28, #16	# ptr, #@addP_reg_imm
2b4 +   addi  R11, R7, #16	# ptr, #@addP_reg_imm
2b8     String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
348 +   bne  R10, zr, B62	#@cmpI_reg_imm0_branch  P=1.000000 C=814.000000

34c     B38: #	out( N1592 ) &lt;- in( B37 B36 )  Freq: 2.06201e-07
34c +   spill [sp, #0] -&gt; R8	# spill size = 64
350 +   li R11, #-187	# int, #@loadConI
354     spill R19 -&gt; [sp, #0]	# spill size = 32
358 +   spill R18 -&gt; [sp, #8]	# spill size = 64
35c +   spill R21 -&gt; [sp, #16]	# spill size = 64
360 +   spill R20 -&gt; [sp, #4]	# spill size = 32
364 +   spill R10 -&gt; [sp, #24]	# spill size = 32
368 +   spill R12 -&gt; [sp, #32]	# spill size = 64
36c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:206 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #32 L[3]=#Ptr0x00000040d02184e0 L[4]=#0 L[5]=#1 L[6]=sp + #8 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #16 L[11]=_ L[12]=sp + #4 STK[0]=sp + #24
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop off=880/0x370}
370     #@ShouldNotReachHere

37c     B39: #	out( B75 B40 ) &lt;- in( B9 )  Freq: 0.514854
37c +   mv  R29, narrowklass: precise klass java/util/HashMap: 0x00000040d0215ca0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
38c     spill [sp, #8] -&gt; R10	# spill size = 32
390 +   bne  R10, R29, B75	#@cmpN_branch  P=0.013084 C=-1.000000

394     B40: #	out( B102 B41 ) &lt;- in( B39 )  Freq: 0.508117
394 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
394     ld  R20, [R23, #288]	# ptr, #@loadP
398 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
398     ld  R7, [R23, #304]	# ptr, #@loadP
39c +   addi  R29, R20, #32	# ptr, #@addP_reg_imm
3a0 +   bgeu  R29, R7, B102	#@cmpP_branch  P=0.000100 C=-1.000000

3a4     B41: #	out( B42 ) &lt;- in( B40 )  Freq: 0.508066
3a4 +   li R7, #1	# long, #@loadConL
3a8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3a8     sd  R29, [R23, #288]	# ptr, #@storeP
3ac +   sd  R7, [R20]	# long, #@storeL
3b0 +   sw  R30, [R20, #8]	# compressed klass ptr, #@storeNKlass
3b4 +   sw  zr, [R20, #12]	# int, #@storeimmI0
3b8 +   sw  zr, [R20, #16]	# int, #@storeimmI0
3bc +   sd  zr, [R20, #24]	# long, #@storeimmL0

3c0     B42: #	out( B43 ) &lt;- in( B103 B41 )  Freq: 0.508117
3c0 +   mv  R7, narrowoop: java/lang/Object:exact *	# compressed ptr, #@loadConN
3d0 +   sw  R7, [R20, #20]	# compressed ptr, #@storeN
3d4     
3d4 +   # checkcastPP of R20, #@checkCastPP
3d4     sw  R31, [R20, #16]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.key
3d8 +   sw  R19, [R20, #12]	# int, #@storeI ! Field: java/util/HashMap$Node.hash
3dc +   #@membar_release
	fence iorw ow

3e0     B43: #	out( B107 B44 ) &lt;- in( B42 B76 )  Freq: 0.514853
3e0 +   lwu  R7, [R18, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
3e4 +   mv  R30, narrowklass: precise klass [Ljava/util/HashMap$Node;: 0x00000040d09269d0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
3f4 +   bne  R7, R30, B107	#@cmpN_branch  P=0.000001 C=-1.000000

3f8     B44: #	out( B81 B45 ) &lt;- in( B43 )  Freq: 0.514853
3f8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3f8     lb  R7, [R23, #56]	# byte, #@loadB
3fc +   bne  R7, zr, B81	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

400     B45: #	out( B48 B46 ) &lt;- in( B111 B83 B81 B44 )  Freq: 0.514853
400 +   mv  R28, R9	# ptr -&gt; long, #@castP2X
404 +   mv  R7, R20	# ptr -&gt; long, #@castP2X
408 +   xorr  R7, R7, R28	#@xorL_reg_reg
40c +   encode_heap_oop  R30, R20	#@encodeHeapOop
410 +   srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
414 +   sw  R30, [R9]	# compressed ptr, #@storeN
418 +   beq  R7, zr, B48	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

41c     B46: #	out( B48 B47 ) &lt;- in( B45 )  Freq: 0.514338
41c +   beq   R20, zr, B48	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

420     B47: #	out( B84 B48 ) &lt;- in( B46 )  Freq: 0.513824
420 +   srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
424 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
430 +   add R10, R28, R7	# ptr, #@addP_reg_reg
434 +   lb  R7, [R10]	# byte, #@loadB
438 +   li R28, #4	# int, #@loadConI
43c +   bne  R7, R28, B84	#@cmpI_branch  P=0.001000 C=-1.000000

440     B48: #	out( B71 B49 ) &lt;- in( B22 B86 B87 B84 B47 B46 B45 )  Freq: 0.636825
440 +   spill [sp, #0] -&gt; R28	# spill size = 64
444 +   lw  R29, [R28, #24]	# int, #@loadI ! Field: java/util/HashMap.modCount
448     spill [sp, #0] -&gt; R7	# spill size = 64
44c +   lw  R7, [R7, #20]	# int, #@loadI ! Field: java/util/HashMap.size
450 +   addiw  R30, R29, #1	#@addI_reg_imm
454 +   addiw  R7, R7, #1	#@addI_reg_imm
458 +   lw  R28, [R28, #28]	# int, #@loadI ! Field: java/util/HashMap.threshold
45c     spill [sp, #0] -&gt; R29	# spill size = 64
460 +   sw  R30, [R29, #24]	# int, #@storeI ! Field: java/util/HashMap.modCount
464 +   sw  R7, [R29, #20]	# int, #@storeI ! Field: java/util/HashMap.size
468 +   bgt  R7, R28, B71	#@cmpI_branch  P=0.039459 C=3472.000000

46c     B49: #	out( B73 B50 ) &lt;- in( B72 B48 )  Freq: 0.636825
46c +   mv  R7, narrowklass: precise klass java/util/HashMap: 0x00000040d0215ca0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
47c +   li R12, #1	# int, #@loadConI
480     spill [sp, #8] -&gt; R29	# spill size = 32
484 +   bne  R29, R7, B73	#@cmpN_branch  P=0.011484 C=-1.000000

488     B50: #	out( B67 ) &lt;- in( B49 B74 )  Freq: 0.636825
488 +   li R10, #1	# int, #@loadConI
48c +   j  B67	#@branch

490     B51: #	out( B120 B52 ) &lt;- in( B10 )  Freq: 0.213865
490 +   lwu  R30, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
494 +   decode_heap_oop  R30, R30	#@decodeHeapOop
498 +   beq  R30, R12, B120	#@cmpP_branch  P=0.000000 C=1166.000000

49c     B52: #	out( B112 B53 ) &lt;- in( B51 )  Freq: 0.213865
49c +   bne  R29, R11, B112	#@cmpN_branch  P=0.000001 C=-1.000000

4a0     B53: #	out( B61 B54 ) &lt;- in( B52 )  Freq: 0.213865
4a0 +   spill R12 -&gt; R28	# spill size = 64
4a4 +   # checkcastPP of R28, #@checkCastPP
4a4     beq  R28, R30, B61	#@cmpP_branch  P=0.064818 C=5338.000000

4a8     B54: #	out( B129 B55 ) &lt;- in( B53 )  Freq: 0.200002
4a8     lwu  R29, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
4ac     NullCheck R30

4ac     B55: #	out( B126 B56 ) &lt;- in( B54 )  Freq: 0.200002
4ac +   lwu  R12, [R28, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
4b0 +   lb  R31, [R28, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
4b4 +   bne  R29, R11, B126	#@cmpN_branch  P=0.000000 C=-1.000000

4b8     B56: #	out( B121 B57 ) &lt;- in( B55 )  Freq: 0.200002
4b8 +   # checkcastPP of R30, #@checkCastPP
4b8     lb  R29, [R30, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
4bc +   lwu  R13, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
4c0 +   decode_heap_oop  R11, R12	#@decodeHeapOop
4c4 +   bne  R31, R29, B121	#@cmpI_branch  P=0.000000 C=4992.000000

4c8     B57: #	out( B113 B58 ) &lt;- in( B56 )  Freq: 0.200002
4c8 +   beq   R11, zr, B113	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

4cc     B58: #	out( B114 B59 ) &lt;- in( B57 )  Freq: 0.200002
4cc +   decode_heap_oop  R29, R13	#@decodeHeapOop
4d0 +   lwu  R14, [R11, #12]	# range, #@loadRange
4d4 +   beq   R29, zr, B114	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

4d8     B59: #	out( B115 B60 ) &lt;- in( B58 )  Freq: 0.200002
4d8 +   lwu  R31, [R29, #12]	# range, #@loadRange
4dc +   bne  R14, R31, B115	#@cmpI_branch  P=0.000001 C=-1.000000

4e0     B60: #	out( B115 B61 ) &lt;- in( B59 )  Freq: 0.200002
4e0 +   addi  R13, R29, #16	# ptr, #@addP_reg_imm
4e4 +   addi  R11, R11, #16	# ptr, #@addP_reg_imm
4e8     String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
578 +   beq  R10, zr, B115	#@cmpI_reg_imm0_branch  P=0.000000 C=1166.000000

57c     B61: #	out( B62 ) &lt;- in( B53 B60 )  Freq: 0.213864
57c +   spill R7 -&gt; R21	# spill size = 64

580     B62: #	out( B88 B63 ) &lt;- in( B61 B30 B37 )  Freq: 0.363165
580 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
580     lb  R7, [R23, #56]	# byte, #@loadB
584 +   bne  R7, zr, B88	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

588     B63: #	out( B65 B64 ) &lt;- in( B116 B90 B88 B62 )  Freq: 0.363165
588 +   mv  R29, java/lang/Object:exact *	# ptr, #@loadConP
5a0 +   mv  R7, R21	# ptr -&gt; long, #@castP2X
5a4 +   mv  R29, R29	# ptr -&gt; long, #@castP2X
5a4 +   lwu  R28, [R21, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.value
5a8 +   xorr  R29, R29, R7	#@xorL_reg_reg
5ac +   mv  R30, narrowoop: java/lang/Object:exact *	# compressed ptr, #@loadConN
5bc +   srli  R29, R29, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
5c0 +   decode_heap_oop  R9, R28	#@decodeHeapOop
5c4 +   sw  R30, [R21, #20]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.value
5c8 +   beq  R29, zr, B65	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

5cc     B64: #	out( B91 B65 ) &lt;- in( B63 )  Freq: 0.362802
5cc +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
5d0 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
5dc +   add R10, R28, R7	# ptr, #@addP_reg_reg
5e0 +   lb  R7, [R10]	# byte, #@loadB
5e4 +   li R28, #4	# int, #@loadConI
5e8 +   bne  R7, R28, B91	#@cmpI_branch  P=0.001000 C=-1.000000

5ec     B65: #	out( B109 B66 ) &lt;- in( B93 B94 B91 B64 B63 )  Freq: 0.363165
5ec +   mv  R28, narrowklass: precise klass java/util/HashMap: 0x00000040d0215ca0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
5fc     spill [sp, #8] -&gt; R7	# spill size = 32
600 +   bne  R7, R28, B109	#@cmpN_branch  P=0.000001 C=-1.000000

604     B66: #	out( B67 ) &lt;- in( B65 )  Freq: 0.363164
604 +   snez  R28, R9	#@convP2Bool
608 +   xori  R10, R28, #1	#@xorI_reg_imm

60c     B67: #	out( N1592 ) &lt;- in( B66 B50 )  Freq: 0.999989
60c     # pop frame 96
	add  sp, sp, #96
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
624 +   ret	// return register, #@Ret

628     B68: #	out( B139 B69 ) &lt;- in( B6 )  Freq: 0.172414
628 +   spill R19 -&gt; [sp, #16]	# spill size = 32
62c +   spill R29 -&gt; [sp, #12]	# spill size = 32
630 +   spill R12 -&gt; R8	# spill size = 64
634 +   spill [sp, #0] -&gt; R11	# spill size = 64
638     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:20 (line 627) L[0]=sp + #0 L[1]=sp + #16 L[2]=R8 L[3]=#Ptr0x00000040d02184e0 L[4]=#0 L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=1596/0x63c}

63c     B69: #	out( B130 B70 ) &lt;- in( B68 )  Freq: 0.17241
        # Block is sole successor of call
63c     lwu  R7, [R10, #12]	# range, #@loadRange
640     NullCheck R10

640     B70: #	out( B8 ) &lt;- in( B69 )  Freq: 0.17241
640 +   spill R8 -&gt; R12	# spill size = 64
644 +   spill [sp, #12] -&gt; R29	# spill size = 32
648 +   spill R10 -&gt; R18	# spill size = 64
64c +   spill [sp, #16] -&gt; R19	# spill size = 32
650 +   j  B8	#@branch

654     B71: #	out( B138 B72 ) &lt;- in( B48 )  Freq: 0.0251282
654 +   spill [sp, #0] -&gt; R11	# spill size = 64
658     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:288 (line 661) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {[0]=Oop off=1628/0x65c}

65c     B72: #	out( B49 ) &lt;- in( B71 )  Freq: 0.0251277
        # Block is sole successor of call
65c +   j  B49	#@branch

660     B73: #	out( B137 B74 ) &lt;- in( B49 )  Freq: 0.0073132
660 +   spill [sp, #0] -&gt; R11	# spill size = 64
664     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.HashMap::afterNodeInsertion
        # java.util.HashMap::putVal @ bci:295 (line 662) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {off=1664/0x680}

680     B74: #	out( B50 ) &lt;- in( B73 )  Freq: 0.00731305
        # Block is sole successor of call
680 +   j  B50	#@branch

684     B75: #	out( B136 B76 ) &lt;- in( B39 )  Freq: 0.0067364
684 +   spill [sp, #0] -&gt; R8	# spill size = 64
688 +   spill R12 -&gt; R7	# spill size = 64
68c +   spill R9 -&gt; [sp, #24]	# spill size = 64
690 +   spill R28 -&gt; [sp, #12]	# spill size = 32
694 +   spill R18 -&gt; [sp, #16]	# spill size = 64
698 +   spill R8 -&gt; R11	# spill size = 64
69c +   spill R19 -&gt; R12	# spill size = 32
6a0 +   spill R7 -&gt; R13	# spill size = 64
6a4 +   mv  R14, java/lang/Object:exact *	# ptr, #@loadConP
6bc     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.HashMap::newNode
        # java.util.HashMap::putVal @ bci:56 (line 629) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #16 STK[1]=sp + #12
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Derived_oop_[16] off=1752/0x6d8}

6d8     B76: #	out( B43 ) &lt;- in( B75 )  Freq: 0.00673627
        # Block is sole successor of call
6d8 +   spill [sp, #16] -&gt; R18	# spill size = 64
6dc +   spill [sp, #12] -&gt; R28	# spill size = 32
6e0 +   spill [sp, #24] -&gt; R9	# spill size = 64
6e4 +   spill R10 -&gt; R20	# spill size = 64
6e8 +   j  B43	#@branch

6ec     B77: #	out( B135 B78 ) &lt;- in( B3 B4 B5 )  Freq: 0.00299698
6ec +   spill R29 -&gt; [sp, #12]	# spill size = 32
6f0 +   spill R12 -&gt; R8	# spill size = 64
6f4 +   spill R12 -&gt; R11	# spill size = 64
6f8     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=R8 L[2]=#Ptr0x00000040d02184e0 STK[0]=sp + #0
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=1812/0x714}

714     B78: #	out( B6 ) &lt;- in( B77 )  Freq: 0.00299692
        # Block is sole successor of call
714 +   spill R8 -&gt; R12	# spill size = 64
718 +   spill [sp, #12] -&gt; R29	# spill size = 32
71c +   j  B6	#@branch

720     B79: #	out( B134 B80 ) &lt;- in( B14 )  Freq: 0.000577154
720 +   spill [sp, #0] -&gt; R8	# spill size = 64
724 +   spill R12 -&gt; R7	# spill size = 64
728 +   spill R20 -&gt; [sp, #32]	# spill size = 32
72c +   spill R21 -&gt; [sp, #24]	# spill size = 64
730 +   spill R19 -&gt; [sp, #12]	# spill size = 32
734 +   spill R18 -&gt; [sp, #16]	# spill size = 64
738 +   spill R8 -&gt; R11	# spill size = 64
73c +   spill R19 -&gt; R12	# spill size = 32
740 +   spill R7 -&gt; R13	# spill size = 64
744 +   mv  R14, java/lang/Object:exact *	# ptr, #@loadConP
75c     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.HashMap::newNode
        # java.util.HashMap::putVal @ bci:152 (line 640) L[0]=R8 L[1]=sp + #12 L[2]=_ L[3]=#Ptr0x00000040d02184e0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=sp + #32 STK[0]=sp + #24
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=1912/0x778}

778     B80: #	out( B18 ) &lt;- in( B79 )  Freq: 0.000577143
        # Block is sole successor of call
778 +   spill [sp, #16] -&gt; R18	# spill size = 64
77c +   spill [sp, #12] -&gt; R19	# spill size = 32
780 +   spill [sp, #24] -&gt; R21	# spill size = 64
784 +   spill [sp, #32] -&gt; R20	# spill size = 32
788 +   spill R10 -&gt; R22	# spill size = 64
78c +   j  B18	#@branch

790     B81: #	out( B45 B82 ) &lt;- in( B44 )  Freq: 0.000514846
790 +   lwu  R28, [R9]	# loadN, compressed ptr, #@loadN
794 +   decode_heap_oop  R10, R28	#@decodeHeapOop
798 +   beq   R10, zr, B45	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

79c     B82: #	out( B111 B83 ) &lt;- in( B81 )  Freq: 0.000257423
79c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
79c     ld  R7, [R23, #32]	# int, #@loadL
7a0 +   beq  R7, zr, B111	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

7a4     B83: #	out( B45 ) &lt;- in( B82 )  Freq: 0.000257166
7a4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7a4     ld  R28, [R23, #48]	# ptr, #@loadP
7a8 +   add R28, R28, R7	# ptr, #@addP_reg_reg
7ac +   addi  R7, R7, #-8	#@addL_reg_imm
7b0 +   sd  R10, [R28, #-8]	# ptr, #@storeP
7b4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7b4     sd  R7, [R23, #32]	# long, #@storeL
7b8 +   j  B45	#@branch

7bc     B84: #	out( B48 B85 ) &lt;- in( B47 )  Freq: 0.000513824
7bc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7bc     ld  R7, [R23, #64]	# int, #@loadL
7c0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7c0     ld  R28, [R23, #80]	# ptr, #@loadP
7c4 +   #@membar_volatile
	fence iorw iorw
7c8 +   lb  R30, [R10]	# byte, #@loadB
7cc +   beq  R30, zr, B48	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

7d0     B85: #	out( B87 B86 ) &lt;- in( B84 )  Freq: 0.000256912
7d0 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
7d4 +   bne  R7, zr, B87	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

7d8     B86: #	out( B48 ) &lt;- in( B85 )  Freq: 0.000128456
7d8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7d8     spill R23 -&gt; R11	# spill size = 64
7dc +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
80c +   j  B48	#@branch

810     B87: #	out( B48 ) &lt;- in( B85 )  Freq: 0.000128456
810 +   add R28, R28, R7	# ptr, #@addP_reg_reg
814 +   addi  R7, R7, #-8	#@addL_reg_imm
818 +   sd  R10, [R28, #-8]	# ptr, #@storeP
81c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
81c     sd  R7, [R23, #64]	# long, #@storeL
820 +   j  B48	#@branch

824     B88: #	out( B63 B89 ) &lt;- in( B62 )  Freq: 0.00036316
824 +   lwu  R28, [R21, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.value
828 +   decode_heap_oop  R10, R28	#@decodeHeapOop
82c +   beq   R10, zr, B63	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

830     B89: #	out( B116 B90 ) &lt;- in( B88 )  Freq: 0.00018158
830 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
830     ld  R7, [R23, #32]	# int, #@loadL
834 +   beq  R7, zr, B116	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

838     B90: #	out( B63 ) &lt;- in( B89 )  Freq: 0.000181398
838 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
838     ld  R28, [R23, #48]	# ptr, #@loadP
83c +   add R28, R28, R7	# ptr, #@addP_reg_reg
840 +   addi  R7, R7, #-8	#@addL_reg_imm
844 +   sd  R10, [R28, #-8]	# ptr, #@storeP
848 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
848     sd  R7, [R23, #32]	# long, #@storeL
84c +   j  B63	#@branch

850     B91: #	out( B65 B92 ) &lt;- in( B64 )  Freq: 0.000362802
850 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
850     ld  R7, [R23, #64]	# int, #@loadL
854 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
854     ld  R28, [R23, #80]	# ptr, #@loadP
858 +   #@membar_volatile
	fence iorw iorw
85c +   lb  R30, [R10]	# byte, #@loadB
860 +   beq  R30, zr, B65	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

864     B92: #	out( B94 B93 ) &lt;- in( B91 )  Freq: 0.000181401
864 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
868 +   bne  R7, zr, B94	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

86c     B93: #	out( B65 ) &lt;- in( B92 )  Freq: 9.07004e-05
86c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
86c     spill R23 -&gt; R11	# spill size = 64
870 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
8a0 +   j  B65	#@branch

8a4     B94: #	out( B65 ) &lt;- in( B92 )  Freq: 9.07004e-05
8a4 +   add R28, R28, R7	# ptr, #@addP_reg_reg
8a8 +   addi  R7, R7, #-8	#@addL_reg_imm
8ac +   sd  R10, [R28, #-8]	# ptr, #@storeP
8b0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8b0     sd  R7, [R23, #64]	# long, #@storeL
8b4 +   j  B65	#@branch

8b8     B95: #	out( B19 B96 ) &lt;- in( B18 )  Freq: 0.000121971
8b8 +   lwu  R7, [R21, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
8bc +   decode_heap_oop  R10, R7	#@decodeHeapOop
8c0 +   beq   R10, zr, B19	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

8c4     B96: #	out( B124 B97 ) &lt;- in( B95 )  Freq: 6.09855e-05
8c4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8c4     ld  R7, [R23, #32]	# int, #@loadL
8c8 +   beq  R7, zr, B124	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

8cc     B97: #	out( B19 ) &lt;- in( B96 )  Freq: 6.09246e-05
8cc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8cc     ld  R28, [R23, #48]	# ptr, #@loadP
8d0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
8d4 +   addi  R7, R7, #-8	#@addL_reg_imm
8d8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
8dc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8dc     sd  R7, [R23, #32]	# long, #@storeL
8e0 +   j  B19	#@branch

8e4     B98: #	out( B22 B99 ) &lt;- in( B21 )  Freq: 0.000121729
8e4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8e4     ld  R7, [R23, #64]	# int, #@loadL
8e8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8e8     ld  R28, [R23, #80]	# ptr, #@loadP
8ec +   #@membar_volatile
	fence iorw iorw
8f0 +   lb  R29, [R10]	# byte, #@loadB
8f4 +   beq  R29, zr, B22	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

8f8     B99: #	out( B101 B100 ) &lt;- in( B98 )  Freq: 6.08644e-05
8f8 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
8fc +   bne  R7, zr, B101	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

900     B100: #	out( B22 ) &lt;- in( B99 )  Freq: 3.04322e-05
900 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
900     spill R23 -&gt; R11	# spill size = 64
904 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
934 +   j  B22	#@branch

938     B101: #	out( B22 ) &lt;- in( B99 )  Freq: 3.04322e-05
938 +   add R28, R28, R7	# ptr, #@addP_reg_reg
93c +   addi  R7, R7, #-8	#@addL_reg_imm
940 +   sd  R10, [R28, #-8]	# ptr, #@storeP
944 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
944     sd  R7, [R23, #64]	# long, #@storeL
948 +   j  B22	#@branch

94c     B102: #	out( B133 B103 ) &lt;- in( B40 )  Freq: 5.08201e-05
94c +   spill [sp, #0] -&gt; R8	# spill size = 64
950 +   spill R8 -&gt; [sp, #8]	# spill size = 64
954 +   spill R31 -&gt; [sp, #36]	# spill size = 32
958 +   spill R9 -&gt; [sp, #40]	# spill size = 64
95c +   spill R28 -&gt; [sp, #32]	# spill size = 32
960 +   spill R19 -&gt; [sp, #20]	# spill size = 32
964 +   spill R18 -&gt; [sp, #24]	# spill size = 64
968 +   spill R10 -&gt; [sp, #16]	# spill size = 32
96c +   # checkcastPP of R8, #@checkCastPP
96c     mv  R11, precise klass java/util/HashMap$Node: 0x00000040d0926900:Constant:exact *	# ptr, #@loadConP
984     spill R12 -&gt; [sp, #0]	# spill size = 64
988     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #20 L[2]=sp + #0 L[3]=#Ptr0x00000040d02184e0 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:56 (line 629) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #24 STK[1]=sp + #32
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [36]=NarrowOop [40]=Derived_oop_[24] off=2444/0x98c}

98c     B103: #	out( B42 ) &lt;- in( B102 )  Freq: 5.08191e-05
        # Block is sole successor of call
98c +   spill [sp, #8] -&gt; R29	# spill size = 64
990 +   spill [sp, #16] -&gt; R30	# spill size = 32
994 +   spill R30 -&gt; [sp, #8]	# spill size = 32
998 +   spill [sp, #24] -&gt; R18	# spill size = 64
99c +   spill [sp, #20] -&gt; R19	# spill size = 32
9a0 +   spill [sp, #32] -&gt; R28	# spill size = 32
9a4 +   spill [sp, #40] -&gt; R9	# spill size = 64
9a8 +   spill [sp, #36] -&gt; R31	# spill size = 32
9ac +   spill R10 -&gt; R20	# spill size = 64
9b0 +   spill R29 -&gt; [sp, #0]	# spill size = 64
9b4 +   j  B42	#@branch

9b8     B104: #	out( B132 B105 ) &lt;- in( B15 )  Freq: 1.21416e-05
9b8 +   spill [sp, #8] -&gt; R7	# spill size = 32
9bc +   spill [sp, #0] -&gt; R8	# spill size = 64
9c0 +   spill R8 -&gt; [sp, #8]	# spill size = 64
9c4 +   spill R20 -&gt; [sp, #36]	# spill size = 32
9c8 +   spill R21 -&gt; [sp, #40]	# spill size = 64
9cc +   spill R31 -&gt; [sp, #32]	# spill size = 32
9d0 +   spill R19 -&gt; [sp, #20]	# spill size = 32
9d4 +   spill R18 -&gt; [sp, #24]	# spill size = 64
9d8 +   spill R7 -&gt; [sp, #16]	# spill size = 32
9dc +   # checkcastPP of R8, #@checkCastPP
9dc     mv  R11, precise klass java/util/HashMap$Node: 0x00000040d0926900:Constant:exact *	# ptr, #@loadConP
9f4     spill R12 -&gt; [sp, #0]	# spill size = 64
9f8     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #20 L[2]=sp + #0 L[3]=#Ptr0x00000040d02184e0 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:152 (line 640) L[0]=R8 L[1]=sp + #20 L[2]=_ L[3]=#Ptr0x00000040d02184e0 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=sp + #36 STK[0]=sp + #40
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=NarrowOop [40]=Oop off=2556/0x9fc}

9fc     B105: #	out( B17 ) &lt;- in( B104 )  Freq: 1.21413e-05
        # Block is sole successor of call
9fc +   spill [sp, #8] -&gt; R28	# spill size = 64
a00 +   spill [sp, #16] -&gt; R30	# spill size = 32
a04 +   spill R30 -&gt; [sp, #8]	# spill size = 32
a08 +   spill [sp, #24] -&gt; R18	# spill size = 64
a0c +   spill [sp, #20] -&gt; R19	# spill size = 32
a10 +   spill [sp, #32] -&gt; R31	# spill size = 32
a14 +   spill [sp, #40] -&gt; R21	# spill size = 64
a18 +   spill [sp, #36] -&gt; R20	# spill size = 32
a1c +   spill R10 -&gt; R22	# spill size = 64
a20 +   spill R28 -&gt; [sp, #0]	# spill size = 64
a24 +   j  B17	#@branch

a28     B106: #	out( N1592 ) &lt;- in( B8 )  Freq: 9.99994e-07
a28 +   spill [sp, #0] -&gt; R8	# spill size = 64
a2c +   li R11, #-28	# int, #@loadConI
a30     spill R19 -&gt; [sp, #0]	# spill size = 32
a34 +   spill R12 -&gt; [sp, #8]	# spill size = 64
a38 +   spill R18 -&gt; [sp, #24]	# spill size = 64
a3c +   spill R28 -&gt; [sp, #32]	# spill size = 32
a40     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.HashMap::putVal @ bci:40 (line 628) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=#Ptr0x00000040d02184e0 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=sp + #32 L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #24 STK[1]=sp + #32
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop off=2628/0xa44}
a44     #@ShouldNotReachHere

a50     B107: #	out( N1592 ) &lt;- in( B43 )  Freq: 5.14853e-07
a50 +   spill [sp, #0] -&gt; R8	# spill size = 64
a54 +   li R11, #-42	# int, #@loadConI
a58     spill R18 -&gt; [sp, #0]	# spill size = 64
a5c +   spill R28 -&gt; [sp, #8]	# spill size = 32
a60 +   spill R20 -&gt; [sp, #16]	# spill size = 64
a64     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;array_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:59 (line 629) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #0 STK[1]=sp + #8 STK[2]=sp + #16
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=2664/0xa68}
a68     #@ShouldNotReachHere

a74     B108: #	out( N1592 ) &lt;- in( B7 )  Freq: 3.94623e-07
a74 +   spill [sp, #0] -&gt; R8	# spill size = 64
a78 +   li R11, #-187	# int, #@loadConI
a7c     spill R19 -&gt; [sp, #0]	# spill size = 32
a80 +   spill R12 -&gt; [sp, #8]	# spill size = 64
a84 +   spill R18 -&gt; [sp, #16]	# spill size = 64
a88 +   spill R7 -&gt; [sp, #24]	# spill size = 32
a8c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:16 (line 626) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=#Ptr0x00000040d02184e0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=_ L[8]=sp + #24 L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #24
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=2704/0xa90}
a90     #@ShouldNotReachHere

a9c     B109: #	out( N1592 ) &lt;- in( B65 )  Freq: 3.63165e-07
a9c +   li R11, #-34	# int, #@loadConI
aa0     spill R9 -&gt; R8	# spill size = 64
aa4 +   spill R21 -&gt; [sp, #8]	# spill size = 64
aa8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:253 (line 655) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=R8 STK[0]=sp + #0 STK[1]=sp + #8
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=2732/0xaac}
aac     #@ShouldNotReachHere

ab8     B110: #	out( N1592 ) &lt;- in( B11 )  Freq: 2.74877e-07
ab8 +   spill [sp, #0] -&gt; R8	# spill size = 64
abc +   li R11, #-187	# int, #@loadConI
ac0     spill R19 -&gt; [sp, #0]	# spill size = 32
ac4 +   spill R12 -&gt; [sp, #8]	# spill size = 64
ac8 +   spill R18 -&gt; [sp, #16]	# spill size = 64
acc +   spill R7 -&gt; [sp, #24]	# spill size = 64
ad0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:109 (line 635) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=#Ptr0x00000040d02184e0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=sp + #24 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#1
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop off=2772/0xad4}
ad4     #@ShouldNotReachHere

ae0     B111: #	out( B45 ) &lt;- in( B82 )  Freq: 2.5742e-07
ae0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
ae0     spill R23 -&gt; R11	# spill size = 64
ae4 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
b14 +   j  B45	#@branch

b18     B112: #	out( N1592 ) &lt;- in( B52 )  Freq: 2.13865e-07
b18 +   spill [sp, #0] -&gt; R8	# spill size = 64
b1c +   li R11, #-34	# int, #@loadConI
b20     spill R19 -&gt; [sp, #0]	# spill size = 32
b24 +   spill R18 -&gt; [sp, #16]	# spill size = 64
b28 +   spill R7 -&gt; [sp, #24]	# spill size = 64
b2c +   spill R12 -&gt; [sp, #32]	# spill size = 64
b30 +   spill R30 -&gt; [sp, #40]	# spill size = 64
b34     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #32 L[3]=#Ptr0x00000040d02184e0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=sp + #24 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #32 STK[1]=sp + #40
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=2872/0xb38}
b38     #@ShouldNotReachHere

b44     B113: #	out( N1592 ) &lt;- in( B57 )  Freq: 2.02658e-07
b44     #@ShouldNotReachHere

b50     B114: #	out( N1592 ) &lt;- in( B58 )  Freq: 2.02658e-07
b50     #@ShouldNotReachHere

b5c     B115: #	out( N1592 ) &lt;- in( B60 B59 )  Freq: 2.9537e-07
b5c +   spill [sp, #0] -&gt; R8	# spill size = 64
b60 +   li R11, #-187	# int, #@loadConI
b64     spill R19 -&gt; [sp, #0]	# spill size = 32
b68 +   spill R28 -&gt; [sp, #8]	# spill size = 64
b6c +   spill R18 -&gt; [sp, #16]	# spill size = 64
b70 +   spill R7 -&gt; [sp, #24]	# spill size = 64
b74 +   spill R10 -&gt; [sp, #4]	# spill size = 32
b78     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:94 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=#Ptr0x00000040d02184e0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=sp + #24 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #4
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop off=2940/0xb7c}
b7c     #@ShouldNotReachHere

b88     B116: #	out( B63 ) &lt;- in( B89 )  Freq: 1.81578e-07
b88 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
b88     spill R23 -&gt; R11	# spill size = 64
b8c +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
bbc +   j  B63	#@branch

bc0     B117: #	out( N1592 ) &lt;- in( B29 )  Freq: 1.49302e-07
bc0 +   spill [sp, #0] -&gt; R8	# spill size = 64
bc4 +   li R11, #-34	# int, #@loadConI
bc8     spill R19 -&gt; [sp, #0]	# spill size = 32
bcc +   spill R18 -&gt; [sp, #16]	# spill size = 64
bd0 +   spill R21 -&gt; [sp, #24]	# spill size = 64
bd4 +   spill R20 -&gt; [sp, #4]	# spill size = 32
bd8 +   spill R12 -&gt; [sp, #32]	# spill size = 64
bdc +   spill R31 -&gt; [sp, #40]	# spill size = 64
be0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #32 L[3]=#Ptr0x00000040d02184e0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #24 L[11]=_ L[12]=sp + #4 STK[0]=sp + #32 STK[1]=sp + #40
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=3044/0xbe4}
be4     #@ShouldNotReachHere

bf0     B118: #	out( N1592 ) &lt;- in( B34 )  Freq: 1.41478e-07
bf0     #@ShouldNotReachHere

bfc     B119: #	out( N1592 ) &lt;- in( B35 )  Freq: 1.41478e-07
bfc     #@ShouldNotReachHere

c08     B120: #	out( N1592 ) &lt;- in( B51 )  Freq: 1.01979e-07
c08 +   spill [sp, #0] -&gt; R8	# spill size = 64
c0c +   li R11, #-187	# int, #@loadConI
c10     spill R19 -&gt; [sp, #0]	# spill size = 32
c14 +   spill R18 -&gt; [sp, #16]	# spill size = 64
c18 +   spill R7 -&gt; [sp, #24]	# spill size = 64
c1c +   spill R30 -&gt; [sp, #40]	# spill size = 64
c20 +   spill R12 -&gt; [sp, #48]	# spill size = 64
c24     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:81 (line 632) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=#Ptr0x00000040d02184e0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=sp + #24 L[8]=_ L[9]=_ L[10]=_ L[11]=sp + #40 L[12]=_ STK[0]=sp + #40 STK[1]=sp + #48
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop off=3112/0xc28}
c28     #@ShouldNotReachHere

c34     B121: #	out( N1592 ) &lt;- in( B56 )  Freq: 1.00001e-07
c34 +   spill [sp, #0] -&gt; R8	# spill size = 64
c38 +   li R11, #-187	# int, #@loadConI
c3c     spill R19 -&gt; [sp, #0]	# spill size = 32
c40 +   spill R18 -&gt; [sp, #16]	# spill size = 64
c44 +   spill R7 -&gt; [sp, #24]	# spill size = 64
c48 +   spill R28 -&gt; [sp, #32]	# spill size = 64
c4c +   spill R30 -&gt; [sp, #40]	# spill size = 64
c50 +   spill R31 -&gt; [sp, #4]	# spill size = 32
c54 +   spill R29 -&gt; [sp, #48]	# spill size = 32
c58     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #32 L[1]=_ L[2]=sp + #40 STK[0]=sp + #4 STK[1]=sp + #48
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #32 L[3]=#Ptr0x00000040d02184e0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=sp + #24 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=3164/0xc5c}
c5c     #@ShouldNotReachHere

c68     B122: #	out( N1592 ) &lt;- in( B28 )  Freq: 7.11927e-08
c68 +   spill [sp, #0] -&gt; R8	# spill size = 64
c6c +   li R11, #-187	# int, #@loadConI
c70     spill R19 -&gt; [sp, #0]	# spill size = 32
c74 +   spill R18 -&gt; [sp, #16]	# spill size = 64
c78 +   spill R21 -&gt; [sp, #24]	# spill size = 64
c7c +   spill R20 -&gt; [sp, #4]	# spill size = 32
c80 +   spill R12 -&gt; [sp, #32]	# spill size = 64
c84 +   spill R31 -&gt; [sp, #48]	# spill size = 64
c88     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:193 (line 645) L[0]=R8 L[1]=sp + #0 L[2]=sp + #32 L[3]=#Ptr0x00000040d02184e0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #24 L[11]=sp + #48 L[12]=sp + #4 STK[0]=sp + #48 STK[1]=sp + #32
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [48]=Oop off=3212/0xc8c}
c8c     #@ShouldNotReachHere

c98     B123: #	out( N1592 ) &lt;- in( B33 )  Freq: 6.9812e-08
c98 +   li R11, #-187	# int, #@loadConI
c9c     spill R19 -&gt; [sp, #8]	# spill size = 32
ca0 +   spill R18 -&gt; [sp, #16]	# spill size = 64
ca4 +   spill R21 -&gt; [sp, #24]	# spill size = 64
ca8 +   spill R20 -&gt; [sp, #12]	# spill size = 32
cac +   spill R12 -&gt; [sp, #40]	# spill size = 64
cb0 +   spill R31 -&gt; [sp, #48]	# spill size = 64
cb4 +   spill R29 -&gt; [sp, #56]	# spill size = 32
cb8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #40 L[1]=_ L[2]=sp + #48 STK[0]=sp + #56 STK[1]=R8
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #40 L[3]=#Ptr0x00000040d02184e0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #24 L[11]=_ L[12]=sp + #12
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop off=3260/0xcbc}
cbc     #@ShouldNotReachHere

cc8     B124: #	out( B19 ) &lt;- in( B96 )  Freq: 6.09847e-08
cc8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
cc8     spill R23 -&gt; R11	# spill size = 64
ccc +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
cfc +   j  B19	#@branch

d00     B125: #	out( N1592 ) &lt;- in( B32 )  Freq: 1e-35
d00 +   spill [sp, #0] -&gt; R8	# spill size = 64
d04 +   li R11, #-34	# int, #@loadConI
d08     spill R19 -&gt; [sp, #0]	# spill size = 32
d0c +   spill R18 -&gt; [sp, #8]	# spill size = 64
d10 +   spill R21 -&gt; [sp, #16]	# spill size = 64
d14 +   spill R20 -&gt; [sp, #4]	# spill size = 32
d18 +   spill R12 -&gt; [sp, #32]	# spill size = 64
d1c +   spill R31 -&gt; [sp, #48]	# spill size = 64
d20     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #32 L[1]=sp + #48 L[2]=_ STK[0]=sp + #48
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #32 L[3]=#Ptr0x00000040d02184e0 L[4]=#0 L[5]=#1 L[6]=sp + #8 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #16 L[11]=_ L[12]=sp + #4
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop [48]=Oop off=3364/0xd24}
d24     #@ShouldNotReachHere

d30     B126: #	out( N1592 ) &lt;- in( B55 )  Freq: 1e-35
d30 +   spill [sp, #0] -&gt; R8	# spill size = 64
d34 +   li R11, #-34	# int, #@loadConI
d38     spill R19 -&gt; [sp, #0]	# spill size = 32
d3c +   spill R18 -&gt; [sp, #16]	# spill size = 64
d40 +   spill R7 -&gt; [sp, #24]	# spill size = 64
d44 +   spill R28 -&gt; [sp, #32]	# spill size = 64
d48 +   spill R30 -&gt; [sp, #48]	# spill size = 64
d4c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #32 L[1]=sp + #48 L[2]=_ STK[0]=sp + #48
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #32 L[3]=#Ptr0x00000040d02184e0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=sp + #24 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [48]=Oop off=3408/0xd50}
d50     #@ShouldNotReachHere

d5c     B127: #	out( N1592 ) &lt;- in( B1 )  Freq: 1.01328e-06
d5c +   li R11, #-10	# int, #@loadConI
d60     spill R12 -&gt; R8	# spill size = 64
d64     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8 STK[2]=#Ptr0x00000040d02184e0
        # OopMap {fp=Oop off=3432/0xd68}
d68     #@ShouldNotReachHere

d74     B128: #	out( N1592 ) &lt;- in( B2 )  Freq: 4.76837e-07
d74 +   li R11, #-187	# int, #@loadConI
d78     spill R12 -&gt; [sp, #8]	# spill size = 64
d7c +   spill R12 -&gt; [sp, #16]	# spill size = 64
d80     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::hash @ bci:1 (line 338) L[0]=sp + #16 L[1]=_ STK[0]=sp + #8
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #8 L[2]=#Ptr0x00000040d02184e0 STK[0]=sp + #0
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=3460/0xd84}
d84     #@ShouldNotReachHere

d90     B129: #	out( N1592 ) &lt;- in( B54 )  Freq: 2.02658e-07
d90 +   spill [sp, #0] -&gt; R8	# spill size = 64
d94 +   li R11, #-12	# int, #@loadConI
d98     spill R19 -&gt; [sp, #0]	# spill size = 32
d9c +   spill R18 -&gt; [sp, #16]	# spill size = 64
da0 +   spill R7 -&gt; [sp, #24]	# spill size = 64
da4 +   spill R28 -&gt; [sp, #32]	# spill size = 64
da8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #32 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #32 L[3]=#Ptr0x00000040d02184e0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=sp + #24 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop off=3500/0xdac}
dac     #@ShouldNotReachHere

db8     B130: #	out( N1592 ) &lt;- in( B69 )  Freq: 1.747e-07
db8 +   li R11, #-10	# int, #@loadConI
dbc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:26 (line 627) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#NULL
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {off=3520/0xdc0}
dc0     #@ShouldNotReachHere

dcc     B131: #	out( N1592 ) &lt;- in( B31 )  Freq: 1.41478e-07
dcc +   spill [sp, #0] -&gt; R8	# spill size = 64
dd0 +   li R11, #-12	# int, #@loadConI
dd4     spill R19 -&gt; [sp, #0]	# spill size = 32
dd8 +   spill R18 -&gt; [sp, #8]	# spill size = 64
ddc +   spill R21 -&gt; [sp, #16]	# spill size = 64
de0 +   spill R20 -&gt; [sp, #4]	# spill size = 32
de4 +   spill R12 -&gt; [sp, #32]	# spill size = 64
de8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #32 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #32 L[3]=#Ptr0x00000040d02184e0 L[4]=#0 L[5]=#1 L[6]=sp + #8 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #16 L[11]=_ L[12]=sp + #4
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop off=3564/0xdec}
dec     #@ShouldNotReachHere

df8     B132: #	out( B140 ) &lt;- in( B104 )  Freq: 1.21416e-10
df8      -- 	// exception oop; no code emitted, #@CreateException
df8 +   j  B140	#@branch

dfc     B133: #	out( B140 ) &lt;- in( B102 )  Freq: 5.08201e-10
dfc      -- 	// exception oop; no code emitted, #@CreateException
dfc +   j  B140	#@branch

e00     B134: #	out( B140 ) &lt;- in( B79 )  Freq: 5.77154e-09
e00      -- 	// exception oop; no code emitted, #@CreateException
e00 +   j  B140	#@branch

e04     B135: #	out( B141 ) &lt;- in( B77 )  Freq: 2.99698e-08
e04      -- 	// exception oop; no code emitted, #@CreateException
e04 +   spill R10 -&gt; R11	# spill size = 64
e08 +   j  B141	#@branch

e0c     B136: #	out( B140 ) &lt;- in( B75 )  Freq: 6.7364e-08
e0c      -- 	// exception oop; no code emitted, #@CreateException
e0c +   j  B140	#@branch

e10     B137: #	out( B140 ) &lt;- in( B73 )  Freq: 7.3132e-08
e10      -- 	// exception oop; no code emitted, #@CreateException
e10 +   j  B140	#@branch

e14     B138: #	out( B140 ) &lt;- in( B71 )  Freq: 2.51282e-07
e14      -- 	// exception oop; no code emitted, #@CreateException
e14 +   j  B140	#@branch

e18     B139: #	out( B140 ) &lt;- in( B68 )  Freq: 1.72414e-06
e18      -- 	// exception oop; no code emitted, #@CreateException

e18     B140: #	out( B141 ) &lt;- in( B139 B136 B133 B134 B132 B138 B137 )  Freq: 2.12231e-06
e18 +   spill R10 -&gt; R11	# spill size = 64

e1c     B141: #	out( N1592 ) &lt;- in( B135 B140 )  Freq: 2.15228e-06
e1c     # pop frame 96
	add  sp, sp, #96
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
e28 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='573'>
----------------------- MetaData before Compile_id = 573 ------------------------
{method}
 - this oop:          0x00000040961a0cd8
 - method holder:     &apos;java/util/HashMap&apos;
 - constants:         0x000000409619f4e0 constant pool [610] {0x000000409619f4e0} for &apos;java/util/HashMap&apos; cache=0x00000040961a4fd8
 - access:            0x81000018  static final 
 - name:              &apos;hash&apos;
 - signature:         &apos;(Ljava/lang/Object;)I&apos;
 - max stack:         4
 - max locals:        2
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4f9040
 - code size:         20
 - code start:        0x00000040961a0ca0
 - code end (excl):   0x00000040961a0cb4
 - method data:       0x00000040964810c0
 - checked ex length: 0
 - linenumber start:  0x00000040961a0cb4
 - localvar length:   2
 - localvar start:    0x00000040961a0cbe
 - compiled code: nmethod  22836  145       3       java.util.HashMap::hash (20 bytes)

------------------------ OptoAssembly for Compile_id = 573 -----------------------
#
#  int ( java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/Object *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B8 B5 B9 )  Freq: 1

000     B1: #	out( B8 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     lwu  R28, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
020     NullCheck R11

020     B2: #	out( B6 B3 ) &lt;- in( B1 )  Freq: 1
020 +   decode_klass_not_null  R28, R28	#@decodeKlass_not_null
02c +   ld  R28, [R28, #504]	# ptr, #@loadP
030 +   mv  R7, metadataptr:Constant0x00000040d0a1e310	# ptr, #@loadConP
048 +   bne  R28, R7, B6	#@cmpP_branch  P=0.001000 C=-1.000000

04c     B3: #	out( B6 B4 ) &lt;- in( B2 )  Freq: 0.999
04c +   ld  R7, [R11]	# int, #@loadL
050 +   li R29, #1	# long, #@loadConL
054 +   andi  R28, R7, #7	#@andL_reg_imm
058 +   bne  R28, R29, B6	#@cmpL_branch  P=0.001000 C=-1.000000

05c     B4: #	out( B6 B5 ) &lt;- in( B3 )  Freq: 0.998001
05c +   srli  R7, R7, (#8 &amp; 0x3f)	#@urShiftL_reg_imm
060 +   li R29, #2147483647	# int, #@loadConI
068 +   addw  R7, R7, zr	#@convL2I_reg
06c +   andr  R10, R7, R29	#@andI_reg_reg
070 +   beq  R10, zr, B6	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

074     B5: #	out( N1 ) &lt;- in( B7 B4 )  Freq: 0.999999
074 +   srliw  R7, R10, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
078 +   xorr  R10, R7, R10	#@xorI_reg_reg
07c     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
094 +   ret	// return register, #@Ret

098     B6: #	out( B9 B7 ) &lt;- in( B2 B3 B4 )  Freq: 0.00299699
098     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # OopMap {off=180/0xb4}

0b4     B7: #	out( B5 ) &lt;- in( B6 )  Freq: 0.00299693
        # Block is sole successor of call
0b4 +   j  B5	#@branch

0b8     B8: #	out( N1 ) &lt;- in( B1 )  Freq: 4.76837e-07
0b8 +   spill R11 -&gt; [sp, #0]	# spill size = 64
0bc +   li R11, #-187	# int, #@loadConI
0c0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::hash @ bci:1 (line 338) L[0]=sp + #0 L[1]=_ STK[0]=sp + #0
        # OopMap {[0]=Oop off=196/0xc4}
0c4     #@ShouldNotReachHere

0d0     B9: #	out( N1 ) &lt;- in( B6 )  Freq: 2.99699e-08
0d0      -- 	// exception oop; no code emitted, #@CreateException
0d0 +   spill R10 -&gt; R11	# spill size = 64
0d4 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
0e0 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='579'>
----------------------- MetaData before Compile_id = 579 ------------------------
{method}
 - this oop:          0x00000040961a1ad8
 - method holder:     &apos;java/util/HashMap&apos;
 - constants:         0x000000409619f4e0 constant pool [610] {0x000000409619f4e0} for &apos;java/util/HashMap&apos; cache=0x00000040961a4fd8
 - access:            0x81000001  public 
 - name:              &apos;put&apos;
 - signature:         &apos;(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;&apos;
 - max stack:         7
 - max locals:        3
 - size of params:    3
 - method size:       13
 - highest level:     4
 - vtable index:      7
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008317290: 0xbbb i2c: 0x0000004013944dc0 c2i: 0x0000004013944e0c c2iUV: 0x0000004013944dd8
 - compiled entry     0x0000004013944e0c
 - code size:         13
 - code start:        0x00000040961a1a98
 - code end (excl):   0x00000040961a1aa5
 - method data:       0x0000004096487118
 - checked ex length: 0
 - linenumber start:  0x00000040961a1aa5
 - localvar length:   3
 - localvar start:    0x00000040961a1ab0

------------------------ OptoAssembly for Compile_id = 579 -----------------------
#
#  java/lang/Object * ( java/util/HashMap:NotNull *, java/lang/Object *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/HashMap:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
#r016 c_rarg3:c_rarg3   : parm 2: java/lang/Object *
# -- Old sp -- Framesize: 112 --
#r263 sp+108: in_preserve
#r262 sp+104: return address
#r261 sp+100: in_preserve
#r260 sp+96: saved fp register
#r259 sp+92: pad2, stack alignment
#r258 sp+88: pad2, stack alignment
#r257 sp+84: Fixed slot 1
#r256 sp+80: Fixed slot 0
#r283 sp+76: spill
#r282 sp+72: spill
#r281 sp+68: spill
#r280 sp+64: spill
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1560: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B126 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=112
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #112
	
03c     spill R11 -&gt; [sp, #8]	# spill size = 64
040 +   spill R13 -&gt; [sp, #16]	# spill size = 64
044 +   spill R12 -&gt; [sp, #56]	# spill size = 64
048     lwu  R8, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
04c     NullCheck R12

04c     B2: #	out( B77 B3 ) &lt;- in( B1 )  Freq: 1
04c +   decode_klass_not_null  R28, R8	#@decodeKlass_not_null
058 +   ld  R28, [R28, #504]	# ptr, #@loadP
05c +   mv  R7, metadataptr:Constant0x00000040d09b7180	# ptr, #@loadConP
074 +   bne  R28, R7, B77	#@cmpP_branch  P=0.001000 C=-1.000000

078     B3: #	out( B77 B4 ) &lt;- in( B2 )  Freq: 0.999
078 +   ld  R7, [R12]	# int, #@loadL
07c +   li R29, #1	# long, #@loadConL
080 +   andi  R28, R7, #7	#@andL_reg_imm
084 +   bne  R28, R29, B77	#@cmpL_branch  P=0.001000 C=-1.000000

088     B4: #	out( B77 B5 ) &lt;- in( B3 )  Freq: 0.998001
088 +   srli  R7, R7, (#8 &amp; 0x3f)	#@urShiftL_reg_imm
08c +   addw  R28, R7, zr	#@convL2I_reg
090 +   li R7, #2147483647	# int, #@loadConI
098 +   andr  R10, R28, R7	#@andI_reg_reg
09c +   beq  R10, zr, B77	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0a0     B5: #	out( B68 B6 ) &lt;- in( B78 B4 )  Freq: 0.999999
0a0 +   spill [sp, #8] -&gt; R7	# spill size = 64
0a4 +   lwu  R7, [R7, #36]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap.table
0a8 +   srliw  R29, R10, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
0ac +   decode_heap_oop  R18, R7	#@decodeHeapOop
0b0 +   xorr  R19, R29, R10	#@xorI_reg_reg
0b4 +   beq   R18, zr, B68	#@cmpP_imm0_branch  P=0.171361 C=5503.000000

0b8     B6: #	out( B108 B7 ) &lt;- in( B5 )  Freq: 0.828638
0b8 +   lwu  R7, [R18, #12]	# range, #@loadRange
0bc +   bleu  R7, zr, B108	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=4560.000000

0c0     B7: #	out( B106 B8 ) &lt;- in( B70 B6 )  Freq: 0.999995
0c0 +   addiw  R28, R7, #-1	#@addI_reg_imm
0c4 +   andr  R28, R28, R19	#@andI_reg_reg
0c8 +   addw  R29, R28, zr	#@convI2L_reg_reg
0cc +   slli  R29, R29, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0d0 +   add R29, R18, R29	# ptr, #@addP_reg_reg
0d4 +   addi  R20, R29, #16	# ptr, #@addP_reg_imm
0d8 +   ble  R7, zr, B106	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0dc     B8: #	out( B55 B9 ) &lt;- in( B7 )  Freq: 0.999994
0dc +   lwu  R29, [R20]	# loadN, compressed ptr, #@loadN
0e0     spill [sp, #8] -&gt; R7	# spill size = 64
0e4 +   lwu  R31, [R7, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0e8     spill [sp, #56] -&gt; R7	# spill size = 64
0ec +   encode_heap_oop  R30, R7	#@encodeHeapOop
0f0 +   decode_heap_oop  R29, R29	#@decodeHeapOop
0f4     spill [sp, #16] -&gt; R21	# spill size = 64
0f8 +   encode_heap_oop  R9, R21	#@encodeHeapOop
0fc +   mv  R15, NULL	# NULL ptr, #@loadConP0
100 +   mv  R7, narrowklass: precise klass java/util/HashMap$Node: 0x00000040d09ba360:Constant:exact *	# compressed klass ptr, #@loadConNKlass
110 +   mv  R12, narrowklass: precise klass java/util/HashMap: 0x00000040d09b3a20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
120 +   beq   R29, zr, B55	#@cmpP_imm0_branch  P=0.519171 C=5503.000000

124     B9: #	out( B27 B10 ) &lt;- in( B8 )  Freq: 0.480826
124 +   lw  R11, [R29, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
128 +   mv  R28, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
138 +   li R10, #0	# int, #@loadConI
13c +   bne  R11, R19, B27	#@cmpI_branch  P=0.559713 C=2646.000000

140     B10: #	out( B119 B11 ) &lt;- in( B9 )  Freq: 0.211702
140 +   lwu  R30, [R29, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
144 +   decode_heap_oop  R30, R30	#@decodeHeapOop
148     spill [sp, #56] -&gt; R7	# spill size = 64
14c +   beq  R30, R7, B119	#@cmpP_branch  P=0.000000 C=1165.000000

150     B11: #	out( B111 B12 ) &lt;- in( B10 )  Freq: 0.211701
150 +   bne  R8, R28, B111	#@cmpN_branch  P=0.000001 C=-1.000000

154     B12: #	out( B20 B13 ) &lt;- in( B11 )  Freq: 0.211701
154 +   spill R7 -&gt; R31	# spill size = 64
158 +   # checkcastPP of R31, #@checkCastPP
158     beq  R31, R30, B20	#@cmpP_branch  P=0.064818 C=5338.000000

15c     B13: #	out( B127 B14 ) &lt;- in( B12 )  Freq: 0.197979
15c     lwu  R28, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
160     NullCheck R30

160     B14: #	out( B125 B15 ) &lt;- in( B13 )  Freq: 0.197979
160 +   mv  R11, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
170 +   lwu  R12, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
174 +   lb  R7, [R31, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
178 +   bne  R28, R11, B125	#@cmpN_branch  P=0.000000 C=-1.000000

17c     B15: #	out( B120 B16 ) &lt;- in( B14 )  Freq: 0.197979
17c +   # checkcastPP of R30, #@checkCastPP
17c     lb  R28, [R30, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
180 +   lwu  R13, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
184 +   decode_heap_oop  R11, R12	#@decodeHeapOop
188 +   bne  R7, R28, B120	#@cmpI_branch  P=0.000000 C=4992.000000

18c     B16: #	out( B112 B17 ) &lt;- in( B15 )  Freq: 0.197979
18c +   beq   R11, zr, B112	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

190     B17: #	out( B113 B18 ) &lt;- in( B16 )  Freq: 0.197979
190 +   decode_heap_oop  R7, R13	#@decodeHeapOop
194 +   lwu  R14, [R11, #12]	# range, #@loadRange
198 +   beq   R7, zr, B113	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

19c     B18: #	out( B114 B19 ) &lt;- in( B17 )  Freq: 0.197978
19c +   lwu  R30, [R7, #12]	# range, #@loadRange
1a0 +   bne  R14, R30, B114	#@cmpI_branch  P=0.000001 C=-1.000000

1a4     B19: #	out( B114 B20 ) &lt;- in( B18 )  Freq: 0.197978
1a4 +   addi  R13, R7, #16	# ptr, #@addP_reg_imm
1a8 +   addi  R11, R11, #16	# ptr, #@addP_reg_imm
1ac     String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
23c +   beq  R10, zr, B114	#@cmpI_reg_imm0_branch  P=0.000000 C=1165.000000

240     B20: #	out( B21 ) &lt;- in( B12 B19 )  Freq: 0.2117
240 +   spill R29 -&gt; R22	# spill size = 64

244     B21: #	out( B88 B22 ) &lt;- in( B20 B46 B53 )  Freq: 0.359555
244 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
244     lb  R7, [R23, #56]	# byte, #@loadB
248 +   bne  R7, zr, B88	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

24c     B22: #	out( B25 B23 ) &lt;- in( B115 B90 B88 B21 )  Freq: 0.359555
24c +   mv  R7, R22	# ptr -&gt; long, #@castP2X
250 +   mv  R29, R21	# ptr -&gt; long, #@castP2X
254 +   xorr  R29, R29, R7	#@xorL_reg_reg
258 +   lwu  R28, [R22, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.value
25c +   srli  R29, R29, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
260     spill [sp, #8] -&gt; R30	# spill size = 64
264 +   lwu  R18, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
268 +   decode_heap_oop  R20, R28	#@decodeHeapOop
26c +   mv  R19, narrowklass: precise klass java/util/HashMap: 0x00000040d09b3a20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
27c +   sw  R9, [R22, #20]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.value
280 +   beq  R29, zr, B25	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

284     B23: #	out( B25 B24 ) &lt;- in( B22 )  Freq: 0.359195
284 +   beq   R21, zr, B25	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

288     B24: #	out( B91 B25 ) &lt;- in( B23 )  Freq: 0.358836
288 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
28c +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
298 +   add R10, R28, R7	# ptr, #@addP_reg_reg
29c +   lb  R28, [R10]	# byte, #@loadB
2a0 +   li R7, #4	# int, #@loadConI
2a4 +   bne  R28, R7, B91	#@cmpI_branch  P=0.001000 C=-1.000000

2a8     B25: #	out( B67 B26 ) &lt;- in( B93 B94 B91 B24 B23 B22 )  Freq: 0.359555
2a8 +   beq  R18, R19, B67	#@cmpN_branch  P=0.999999 C=-1.000000

2ac     B26: #	out( N1560 ) &lt;- in( B25 )  Freq: 3.59555e-07
2ac +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
2b4 +   li R11, #-34	# int, #@loadConI
2b8     spill R20 -&gt; R8	# spill size = 64
2bc +   spill R22 -&gt; [sp, #8]	# spill size = 64
2c0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:253 (line 655) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=R8 STK[0]=sp + #0 STK[1]=sp + #8
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=708/0x2c4}
2c4     #@ShouldNotReachHere

2d0     B27: #	out( B109 B28 ) &lt;- in( B9 )  Freq: 0.269124
2d0 +   lwu  R13, [R29, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
2d4 +   lwu  R11, [R29, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
2d8 +   mv  R14, narrowklass: precise klass java/util/HashMap$TreeNode: 0x00000040d021d3d0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
2e8 +   decode_heap_oop  R22, R13	#@decodeHeapOop
2ec +   beq  R11, R14, B109	#@cmpN_branch  P=0.000001 C=-1.000000

2f0     B28: #	out( B40 B29 ) &lt;- in( B27 )  Freq: 0.269124
2f0 +   bne   R22, zr, B40	#@cmpP_imm0_branch  P=0.614451 C=1730.000000

2f4     B29: #	out( B30 ) &lt;- in( B28 )  Freq: 0.103761
2f4 +   li R20, #0	# int, #@loadConI
2f8     spill R29 -&gt; R22	# spill size = 64

2fc     B30: #	out( B79 B31 ) &lt;- in( B42 B29 )  Freq: 0.121268
2fc +   bne  R31, R12, B79	#@cmpN_branch  P=0.004717 C=-1.000000

300     B31: #	out( B104 B32 ) &lt;- in( B30 )  Freq: 0.120696
300 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
300     ld  R24, [R23, #288]	# ptr, #@loadP
304 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
304     ld  R28, [R23, #304]	# ptr, #@loadP
308 +   addi  R29, R24, #32	# ptr, #@addP_reg_imm
30c +   bgeu  R29, R28, B104	#@cmpP_branch  P=0.000100 C=-1.000000

310     B32: #	out( B33 ) &lt;- in( B31 )  Freq: 0.120684
310 +   li R28, #1	# long, #@loadConL
314 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
314     sd  R29, [R23, #288]	# ptr, #@storeP
318 +   sd  R28, [R24]	# long, #@storeL
31c +   sw  R7, [R24, #8]	# compressed klass ptr, #@storeNKlass
320 +   sw  zr, [R24, #12]	# int, #@storeimmI0
324 +   sw  zr, [R24, #16]	# int, #@storeimmI0
328 +   sd  zr, [R24, #24]	# long, #@storeimmL0

32c     B33: #	out( B34 ) &lt;- in( B105 B32 )  Freq: 0.120696
32c +   sw  R9, [R24, #20]	# compressed ptr, #@storeN
330     
330 +   # checkcastPP of R24, #@checkCastPP
330     sw  R30, [R24, #16]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.key
334 +   sw  R19, [R24, #12]	# int, #@storeI ! Field: java/util/HashMap$Node.hash
338 +   #@membar_release
	fence iorw ow

33c     B34: #	out( B95 B35 ) &lt;- in( B33 B80 )  Freq: 0.121268
33c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
33c     lb  R7, [R23, #56]	# byte, #@loadB
340 +   bne  R7, zr, B95	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

344     B35: #	out( B38 B36 ) &lt;- in( B123 B97 B95 B34 )  Freq: 0.121268
344 +   mv  R28, R22	# ptr -&gt; long, #@castP2X
348 +   mv  R7, R24	# ptr -&gt; long, #@castP2X
34c +   xorr  R7, R7, R28	#@xorL_reg_reg
350 +   encode_heap_oop  R30, R24	#@encodeHeapOop
354 +   srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
358 +   li R9, #7	# int, #@loadConI
35c +   sw  R30, [R22, #24]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.next
360 +   beq  R7, zr, B38	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

364     B36: #	out( B38 B37 ) &lt;- in( B35 )  Freq: 0.121147
364 +   beq   R24, zr, B38	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

368     B37: #	out( B98 B38 ) &lt;- in( B36 )  Freq: 0.121026
368 +   srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
36c +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
378 +   add R10, R28, R7	# ptr, #@addP_reg_reg
37c +   lb  R7, [R10]	# byte, #@loadB
380 +   li R29, #4	# int, #@loadConI
384 +   bne  R7, R29, B98	#@cmpI_branch  P=0.001000 C=-1.000000

388     B38: #	out( B64 B39 ) &lt;- in( B100 B101 B98 B37 B36 B35 )  Freq: 0.121268
388 +   blt  R20, R9, B64	#@cmpI_branch  P=1.000000 C=667.000000

38c     B39: #	out( N1560 ) &lt;- in( B38 )  Freq: 5.78253e-08
38c +   spill [sp, #8] -&gt; R8	# spill size = 64
390 +   li R11, #-187	# int, #@loadConI
394     spill R19 -&gt; [sp, #0]	# spill size = 32
398 +   spill R21 -&gt; [sp, #8]	# spill size = 64
39c +   spill R18 -&gt; [sp, #16]	# spill size = 64
3a0 +   spill R20 -&gt; [sp, #4]	# spill size = 32
3a4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:162 (line 641) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=sp + #8 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=_ STK[0]=sp + #4 STK[1]=#7
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=936/0x3a8}
3a8     #@ShouldNotReachHere

3b4     B40: #	out( B41 ) &lt;- in( B28 )  Freq: 0.165364
3b4 +   li R20, #0	# int, #@loadConI

3b8     B41: #	out( B44 B42 ) &lt;- in( B40 B43 ) Loop( B41-B43 inner ) Freq: 0.193266
3b8 +   lw  R29, [R22, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
3bc +   beq  R29, R19, B44	#@cmpI_branch  P=0.765038 C=1064.000000

3c0     B42: #	out( B30 B43 ) &lt;- in( B41 )  Freq: 0.0454102
3c0 +   addiw  R20, R20, #1	#@addI_reg_imm
3c4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3c4     ld  R29, [R23, #920]	# ptr, #@loadP
3c8 +   lwu zr, [R29]	# Safepoint: poll for GC, #@safePoint        # java.util.HashMap::putVal @ bci:219 (line 638) L[0]=sp + #8 L[1]=R19 L[2]=sp + #56 L[3]=R21 L[4]=#0 L[5]=#1 L[6]=R18 L[7]=R22 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=R20
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {x30=NarrowOop x9=NarrowOop x18=Oop xdispatch=Oop xbcp=Oop [8]=Oop [56]=Oop off=968/0x3c8}
3cc +   lwu  R29, [R22, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
3d0 +   decode_heap_oop  R29, R29	#@decodeHeapOop
3d4 +   beq   R29, zr, B30	#@cmpP_imm0_branch  P=0.385549 C=250.000000

3d8     B43: #	out( B41 ) &lt;- in( B42 )  Freq: 0.0279024
3d8 +   spill R29 -&gt; R22	# spill size = 64
3dc +   j  B41	#@branch

3e0     B44: #	out( B121 B45 ) &lt;- in( B41 )  Freq: 0.147856
3e0 +   lwu  R29, [R22, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
3e4 +   decode_heap_oop  R30, R29	#@decodeHeapOop
3e8     spill [sp, #56] -&gt; R7	# spill size = 64
3ec +   beq  R30, R7, B121	#@cmpP_branch  P=0.000000 C=814.000000

3f0     B45: #	out( B116 B46 ) &lt;- in( B44 )  Freq: 0.147856
3f0 +   bne  R8, R28, B116	#@cmpN_branch  P=0.000001 C=-1.000000

3f4     B46: #	out( B21 B47 ) &lt;- in( B45 )  Freq: 0.147855
3f4 +   spill R7 -&gt; R31	# spill size = 64
3f8 +   # checkcastPP of R31, #@checkCastPP
3f8     beq  R31, R30, B21	#@cmpP_branch  P=0.064818 C=5338.000000

3fc     B47: #	out( B129 B48 ) &lt;- in( B46 )  Freq: 0.138272
3fc     lwu  R7, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
400     NullCheck R30

400     B48: #	out( B124 B49 ) &lt;- in( B47 )  Freq: 0.138272
400 +   lwu  R29, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
404 +   lb  R13, [R31, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
408 +   bne  R7, R28, B124	#@cmpN_branch  P=0.000000 C=-1.000000

40c     B49: #	out( B122 B50 ) &lt;- in( B48 )  Freq: 0.138272
40c +   # checkcastPP of R30, #@checkCastPP
40c     lb  R8, [R30, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
410 +   lwu  R28, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
414 +   decode_heap_oop  R7, R29	#@decodeHeapOop
418 +   bne  R13, R8, B122	#@cmpI_branch  P=0.000000 C=4992.000000

41c     B50: #	out( B117 B51 ) &lt;- in( B49 )  Freq: 0.138272
41c +   beq   R7, zr, B117	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

420     B51: #	out( B118 B52 ) &lt;- in( B50 )  Freq: 0.138271
420 +   decode_heap_oop  R28, R28	#@decodeHeapOop
424 +   lwu  R14, [R7, #12]	# range, #@loadRange
428 +   beq   R28, zr, B118	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

42c     B52: #	out( B54 B53 ) &lt;- in( B51 )  Freq: 0.138271
42c +   lwu  R30, [R28, #12]	# range, #@loadRange
430 +   bne  R14, R30, B54	#@cmpI_branch  P=0.000001 C=-1.000000

434     B53: #	out( B21 B54 ) &lt;- in( B52 )  Freq: 0.138271
434 +   addi  R13, R28, #16	# ptr, #@addP_reg_imm
438 +   addi  R11, R7, #16	# ptr, #@addP_reg_imm
43c     String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
4cc +   bne  R10, zr, B21	#@cmpI_reg_imm0_branch  P=1.000000 C=814.000000

4d0     B54: #	out( N1560 ) &lt;- in( B53 B52 )  Freq: 2.04204e-07
4d0 +   spill [sp, #8] -&gt; R8	# spill size = 64
4d4 +   li R11, #-187	# int, #@loadConI
4d8     spill R19 -&gt; [sp, #0]	# spill size = 32
4dc +   spill R21 -&gt; [sp, #8]	# spill size = 64
4e0 +   spill R18 -&gt; [sp, #16]	# spill size = 64
4e4 +   spill R22 -&gt; [sp, #24]	# spill size = 64
4e8 +   spill R20 -&gt; [sp, #4]	# spill size = 32
4ec +   spill R10 -&gt; [sp, #32]	# spill size = 32
4f0 +   spill R31 -&gt; [sp, #40]	# spill size = 64
4f4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:206 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #40 L[3]=sp + #8 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #24 L[11]=_ L[12]=sp + #4 STK[0]=sp + #32
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop off=1272/0x4f8}
4f8     #@ShouldNotReachHere

504     B55: #	out( B75 B56 ) &lt;- in( B8 )  Freq: 0.519168
504 +   bne  R31, R12, B75	#@cmpN_branch  P=0.013216 C=-1.000000

508     B56: #	out( B102 B57 ) &lt;- in( B55 )  Freq: 0.512307
508 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
508     ld  R22, [R23, #288]	# ptr, #@loadP
50c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
50c     ld  R29, [R23, #304]	# ptr, #@loadP
510 +   addi  R31, R22, #32	# ptr, #@addP_reg_imm
514 +   bgeu  R31, R29, B102	#@cmpP_branch  P=0.000100 C=-1.000000

518     B57: #	out( B58 ) &lt;- in( B56 )  Freq: 0.512256
518 +   li R29, #1	# long, #@loadConL
51c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
51c     sd  R31, [R23, #288]	# ptr, #@storeP
520 +   sd  R29, [R22]	# long, #@storeL
524 +   sw  R7, [R22, #8]	# compressed klass ptr, #@storeNKlass
528 +   sw  zr, [R22, #12]	# int, #@storeimmI0
52c +   sw  zr, [R22, #16]	# int, #@storeimmI0
530 +   sd  zr, [R22, #24]	# long, #@storeimmL0

534     B58: #	out( B59 ) &lt;- in( B103 B57 )  Freq: 0.512307
534 +   sw  R9, [R22, #20]	# compressed ptr, #@storeN
538     
538 +   # checkcastPP of R22, #@checkCastPP
538     sw  R30, [R22, #16]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.key
53c +   sw  R19, [R22, #12]	# int, #@storeI ! Field: java/util/HashMap$Node.hash
540 +   #@membar_release
	fence iorw ow

544     B59: #	out( B107 B60 ) &lt;- in( B58 B76 )  Freq: 0.519168
544 +   lwu  R29, [R18, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
548 +   mv  R7, narrowklass: precise klass [Ljava/util/HashMap$Node;: 0x00000040d09ba430:Constant:exact *	# compressed klass ptr, #@loadConNKlass
558 +   bne  R29, R7, B107	#@cmpN_branch  P=0.000001 C=-1.000000

55c     B60: #	out( B81 B61 ) &lt;- in( B59 )  Freq: 0.519168
55c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
55c     lb  R28, [R23, #56]	# byte, #@loadB
560 +   bne  R28, zr, B81	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

564     B61: #	out( B64 B62 ) &lt;- in( B110 B83 B81 B60 )  Freq: 0.519168
564 +   mv  R7, R20	# ptr -&gt; long, #@castP2X
568 +   mv  R28, R22	# ptr -&gt; long, #@castP2X
56c +   xorr  R28, R28, R7	#@xorL_reg_reg
570 +   encode_heap_oop  R29, R22	#@encodeHeapOop
574 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
578 +   sw  R29, [R20]	# compressed ptr, #@storeN
57c +   beq  R28, zr, B64	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

580     B62: #	out( B64 B63 ) &lt;- in( B61 )  Freq: 0.518649
580 +   beq   R22, zr, B64	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

584     B63: #	out( B84 B64 ) &lt;- in( B62 )  Freq: 0.51813
584 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
588 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
594 +   add R10, R28, R7	# ptr, #@addP_reg_reg
598 +   lb  R28, [R10]	# byte, #@loadB
59c +   li R29, #4	# int, #@loadConI
5a0 +   bne  R28, R29, B84	#@cmpI_branch  P=0.001000 C=-1.000000

5a4     B64: #	out( B71 B65 ) &lt;- in( B38 B86 B87 B84 B63 B62 B61 )  Freq: 0.640436
5a4 +   spill [sp, #8] -&gt; R7	# spill size = 64
5a8 +   lw  R28, [R7, #24]	# int, #@loadI ! Field: java/util/HashMap.modCount
5ac +   lw  R7, [R7, #20]	# int, #@loadI ! Field: java/util/HashMap.size
5b0 +   spill [sp, #8] -&gt; R29	# spill size = 64
5b4 +   lw  R30, [R29, #28]	# int, #@loadI ! Field: java/util/HashMap.threshold
5b8 +   addiw  R29, R7, #1	#@addI_reg_imm
5bc +   addiw  R28, R28, #1	#@addI_reg_imm
5c0     spill [sp, #8] -&gt; R7	# spill size = 64
5c4 +   sw  R28, [R7, #24]	# int, #@storeI ! Field: java/util/HashMap.modCount
5c8 +   sw  R29, [R7, #20]	# int, #@storeI ! Field: java/util/HashMap.size
5cc +   bgt  R29, R30, B71	#@cmpI_branch  P=0.038876 C=3524.000000

5d0     B65: #	out( B73 B66 ) &lt;- in( B72 B64 )  Freq: 0.640436
5d0 +   spill [sp, #8] -&gt; R7	# spill size = 64
5d4 +   lwu  R7, [R7, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
5d8 +   mv  R29, narrowklass: precise klass java/util/HashMap: 0x00000040d09b3a20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
5e8 +   bne  R7, R29, B73	#@cmpN_branch  P=0.011607 C=-1.000000

5ec     B66: #	out( B67 ) &lt;- in( B65 B74 )  Freq: 0.640436
5ec +   mv  R20, NULL	# NULL ptr, #@loadConP0

5f0     B67: #	out( N1560 ) &lt;- in( B25 B66 )  Freq: 0.99999
5f0     spill R20 -&gt; R10	# spill size = 64
5f4 +   # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
60c +   ret	// return register, #@Ret

610     B68: #	out( B137 B69 ) &lt;- in( B5 )  Freq: 0.171361
610 +   spill [sp, #8] -&gt; R11	# spill size = 64
614 +   spill R19 -&gt; [sp, #4]	# spill size = 32
618     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:20 (line 627) L[0]=sp + #8 L[1]=sp + #4 L[2]=sp + #56 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [56]=Oop off=1564/0x61c}

61c     B69: #	out( B128 B70 ) &lt;- in( B68 )  Freq: 0.171358
        # Block is sole successor of call
61c     lwu  R7, [R10, #12]	# range, #@loadRange
620     NullCheck R10

620     B70: #	out( B7 ) &lt;- in( B69 )  Freq: 0.171357
620 +   spill R10 -&gt; R18	# spill size = 64
624 +   spill [sp, #4] -&gt; R19	# spill size = 32
628 +   j  B7	#@branch

62c     B71: #	out( B136 B72 ) &lt;- in( B64 )  Freq: 0.0248978
62c +   spill [sp, #8] -&gt; R11	# spill size = 64
630     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:288 (line 661) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {[8]=Oop off=1588/0x634}

634     B72: #	out( B65 ) &lt;- in( B71 )  Freq: 0.0248973
        # Block is sole successor of call
634 +   j  B65	#@branch

638     B73: #	out( B135 B74 ) &lt;- in( B65 )  Freq: 0.00743365
638 +   li R12, #1	# int, #@loadConI
63c     spill [sp, #8] -&gt; R11	# spill size = 64
640     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.HashMap::afterNodeInsertion
        # java.util.HashMap::putVal @ bci:295 (line 662) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {off=1628/0x65c}

65c     B74: #	out( B66 ) &lt;- in( B73 )  Freq: 0.0074335
        # Block is sole successor of call
65c +   j  B66	#@branch

660     B75: #	out( B134 B76 ) &lt;- in( B55 )  Freq: 0.00686125
660 +   spill [sp, #8] -&gt; R8	# spill size = 64
664 +   spill [sp, #56] -&gt; R7	# spill size = 64
668 +   spill R20 -&gt; [sp, #24]	# spill size = 64
66c +   spill R28 -&gt; [sp, #16]	# spill size = 32
670 +   spill R18 -&gt; [sp, #0]	# spill size = 64
674 +   spill R8 -&gt; R11	# spill size = 64
678 +   spill R19 -&gt; R12	# spill size = 32
67c +   spill R7 -&gt; R13	# spill size = 64
680 +   spill R21 -&gt; R14	# spill size = 64
684     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.HashMap::newNode
        # java.util.HashMap::putVal @ bci:56 (line 629) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #0 STK[1]=sp + #16
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Derived_oop_[0] off=1696/0x6a0}

6a0     B76: #	out( B59 ) &lt;- in( B75 )  Freq: 0.00686111
        # Block is sole successor of call
6a0 +   spill [sp, #0] -&gt; R18	# spill size = 64
6a4 +   spill [sp, #16] -&gt; R28	# spill size = 32
6a8 +   spill [sp, #24] -&gt; R20	# spill size = 64
6ac +   spill R10 -&gt; R22	# spill size = 64
6b0 +   j  B59	#@branch

6b4     B77: #	out( B133 B78 ) &lt;- in( B2 B3 B4 )  Freq: 0.00299699
6b4 +   spill R12 -&gt; R11	# spill size = 64
6b8     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #56 L[2]=sp + #16 STK[0]=sp + #8
        # OopMap {[8]=Oop [16]=Oop [56]=Oop off=1748/0x6d4}

6d4     B78: #	out( B5 ) &lt;- in( B77 )  Freq: 0.00299693
        # Block is sole successor of call
6d4 +   j  B5	#@branch

6d8     B79: #	out( B132 B80 ) &lt;- in( B30 )  Freq: 0.000572022
6d8 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
6e0 +   spill [sp, #56] -&gt; R7	# spill size = 64
6e4 +   spill R20 -&gt; [sp, #28]	# spill size = 32
6e8 +   spill R22 -&gt; [sp, #32]	# spill size = 64
6ec +   spill R19 -&gt; [sp, #24]	# spill size = 32
6f0 +   spill R18 -&gt; [sp, #16]	# spill size = 64
6f4 +   spill R21 -&gt; R8	# spill size = 64
6f8 +   spill [sp, #0] -&gt; R11	# spill size = 64
6fc +   spill R19 -&gt; R12	# spill size = 32
700 +   spill R7 -&gt; R13	# spill size = 64
704 +   spill R21 -&gt; R14	# spill size = 64
708     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.HashMap::newNode
        # java.util.HashMap::putVal @ bci:152 (line 640) L[0]=sp + #0 L[1]=sp + #24 L[2]=_ L[3]=R8 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=sp + #28 STK[0]=sp + #32
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [32]=Oop off=1828/0x724}

724     B80: #	out( B34 ) &lt;- in( B79 )  Freq: 0.000572011
        # Block is sole successor of call
724 +   spill [sp, #24] -&gt; R28	# spill size = 32
728 +   spill R8 -&gt; R21	# spill size = 64
72c +   spill [sp, #16] -&gt; R18	# spill size = 64
730 +   spill [sp, #32] -&gt; R22	# spill size = 64
734 +   spill [sp, #28] -&gt; R20	# spill size = 32
738 +   spill R10 -&gt; R24	# spill size = 64
73c +   spill R28 -&gt; R19	# spill size = 32
740 +   j  B34	#@branch

744     B81: #	out( B61 B82 ) &lt;- in( B60 )  Freq: 0.000519161
744 +   lwu  R7, [R20]	# loadN, compressed ptr, #@loadN
748 +   decode_heap_oop  R10, R7	#@decodeHeapOop
74c +   beq   R10, zr, B61	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

750     B82: #	out( B110 B83 ) &lt;- in( B81 )  Freq: 0.000259581
750 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
750     ld  R7, [R23, #32]	# int, #@loadL
754 +   beq  R7, zr, B110	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

758     B83: #	out( B61 ) &lt;- in( B82 )  Freq: 0.000259321
758 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
758     ld  R28, [R23, #48]	# ptr, #@loadP
75c +   add R28, R28, R7	# ptr, #@addP_reg_reg
760 +   addi  R7, R7, #-8	#@addL_reg_imm
764 +   sd  R10, [R28, #-8]	# ptr, #@storeP
768 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
768     sd  R7, [R23, #32]	# long, #@storeL
76c +   j  B61	#@branch

770     B84: #	out( B64 B85 ) &lt;- in( B63 )  Freq: 0.00051813
770 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
770     ld  R7, [R23, #64]	# int, #@loadL
774 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
774     ld  R28, [R23, #80]	# ptr, #@loadP
778 +   #@membar_volatile
	fence iorw iorw
77c +   lb  R29, [R10]	# byte, #@loadB
780 +   beq  R29, zr, B64	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

784     B85: #	out( B87 B86 ) &lt;- in( B84 )  Freq: 0.000259065
784 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
788 +   bne  R7, zr, B87	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

78c     B86: #	out( B64 ) &lt;- in( B85 )  Freq: 0.000129533
78c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
78c     spill R23 -&gt; R11	# spill size = 64
790 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
7c0 +   j  B64	#@branch

7c4     B87: #	out( B64 ) &lt;- in( B85 )  Freq: 0.000129533
7c4 +   add R28, R28, R7	# ptr, #@addP_reg_reg
7c8 +   addi  R7, R7, #-8	#@addL_reg_imm
7cc +   sd  R10, [R28, #-8]	# ptr, #@storeP
7d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7d0     sd  R7, [R23, #64]	# long, #@storeL
7d4 +   j  B64	#@branch

7d8     B88: #	out( B22 B89 ) &lt;- in( B21 )  Freq: 0.00035955
7d8 +   lwu  R28, [R22, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.value
7dc +   decode_heap_oop  R10, R28	#@decodeHeapOop
7e0 +   beq   R10, zr, B22	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

7e4     B89: #	out( B115 B90 ) &lt;- in( B88 )  Freq: 0.000179775
7e4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7e4     ld  R7, [R23, #32]	# int, #@loadL
7e8 +   beq  R7, zr, B115	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

7ec     B90: #	out( B22 ) &lt;- in( B89 )  Freq: 0.000179595
7ec +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7ec     ld  R28, [R23, #48]	# ptr, #@loadP
7f0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
7f4 +   addi  R7, R7, #-8	#@addL_reg_imm
7f8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
7fc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7fc     sd  R7, [R23, #32]	# long, #@storeL
800 +   j  B22	#@branch

804     B91: #	out( B25 B92 ) &lt;- in( B24 )  Freq: 0.000358836
804 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
804     ld  R7, [R23, #64]	# int, #@loadL
808 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
808     ld  R28, [R23, #80]	# ptr, #@loadP
80c +   #@membar_volatile
	fence iorw iorw
810 +   lb  R29, [R10]	# byte, #@loadB
814 +   beq  R29, zr, B25	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

818     B92: #	out( B94 B93 ) &lt;- in( B91 )  Freq: 0.000179418
818 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
81c +   bne  R7, zr, B94	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

820     B93: #	out( B25 ) &lt;- in( B92 )  Freq: 8.97091e-05
820 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
820     spill R23 -&gt; R11	# spill size = 64
824 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
854 +   j  B25	#@branch

858     B94: #	out( B25 ) &lt;- in( B92 )  Freq: 8.97091e-05
858 +   add R28, R28, R7	# ptr, #@addP_reg_reg
85c +   addi  R7, R7, #-8	#@addL_reg_imm
860 +   sd  R10, [R28, #-8]	# ptr, #@storeP
864 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
864     sd  R7, [R23, #64]	# long, #@storeL
868 +   j  B25	#@branch

86c     B95: #	out( B35 B96 ) &lt;- in( B34 )  Freq: 0.000121267
86c +   lwu  R28, [R22, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
870 +   decode_heap_oop  R10, R28	#@decodeHeapOop
874 +   beq   R10, zr, B35	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

878     B96: #	out( B123 B97 ) &lt;- in( B95 )  Freq: 6.06334e-05
878 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
878     ld  R7, [R23, #32]	# int, #@loadL
87c +   beq  R7, zr, B123	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

880     B97: #	out( B35 ) &lt;- in( B96 )  Freq: 6.05728e-05
880 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
880     ld  R28, [R23, #48]	# ptr, #@loadP
884 +   add R28, R28, R7	# ptr, #@addP_reg_reg
888 +   addi  R7, R7, #-8	#@addL_reg_imm
88c +   sd  R10, [R28, #-8]	# ptr, #@storeP
890 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
890     sd  R7, [R23, #32]	# long, #@storeL
894 +   j  B35	#@branch

898     B98: #	out( B38 B99 ) &lt;- in( B37 )  Freq: 0.000121026
898 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
898     ld  R7, [R23, #64]	# int, #@loadL
89c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
89c     ld  R28, [R23, #80]	# ptr, #@loadP
8a0 +   #@membar_volatile
	fence iorw iorw
8a4 +   lb  R30, [R10]	# byte, #@loadB
8a8 +   beq  R30, zr, B38	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

8ac     B99: #	out( B101 B100 ) &lt;- in( B98 )  Freq: 6.0513e-05
8ac +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
8b0 +   bne  R7, zr, B101	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

8b4     B100: #	out( B38 ) &lt;- in( B99 )  Freq: 3.02565e-05
8b4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8b4     spill R23 -&gt; R11	# spill size = 64
8b8 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
8e8 +   j  B38	#@branch

8ec     B101: #	out( B38 ) &lt;- in( B99 )  Freq: 3.02565e-05
8ec +   add R28, R28, R7	# ptr, #@addP_reg_reg
8f0 +   addi  R7, R7, #-8	#@addL_reg_imm
8f4 +   sd  R10, [R28, #-8]	# ptr, #@storeP
8f8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8f8     sd  R7, [R23, #64]	# long, #@storeL
8fc +   j  B38	#@branch

900     B102: #	out( B131 B103 ) &lt;- in( B56 )  Freq: 5.12392e-05
900 +   spill [sp, #8] -&gt; R8	# spill size = 64
904 +   spill [sp, #8] -&gt; [sp, #16]	# spill size = 64
90c +   spill R9 -&gt; [sp, #52]	# spill size = 32
910 +   spill R30 -&gt; [sp, #48]	# spill size = 32
914 +   spill R20 -&gt; [sp, #40]	# spill size = 64
918 +   spill R28 -&gt; [sp, #36]	# spill size = 32
91c +   spill R19 -&gt; [sp, #32]	# spill size = 32
920 +   spill R18 -&gt; [sp, #24]	# spill size = 64
924 +   # checkcastPP of R8, #@checkCastPP
924     mv  R11, precise klass java/util/HashMap$Node: 0x00000040d09ba360:Constant:exact *	# ptr, #@loadConP
93c     spill R21 -&gt; [sp, #8]	# spill size = 64
940     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #32 L[2]=sp + #56 L[3]=sp + #8 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:56 (line 629) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #24 STK[1]=sp + #36
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Derived_oop_[24] [48]=NarrowOop [52]=NarrowOop [56]=Oop off=2372/0x944}

944     B103: #	out( B58 ) &lt;- in( B102 )  Freq: 5.12382e-05
        # Block is sole successor of call
944 +   spill [sp, #32] -&gt; R29	# spill size = 32
948 +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
950 +   spill [sp, #24] -&gt; R18	# spill size = 64
954 +   spill [sp, #36] -&gt; R28	# spill size = 32
958 +   spill [sp, #40] -&gt; R20	# spill size = 64
95c +   spill [sp, #48] -&gt; R30	# spill size = 32
960 +   spill [sp, #52] -&gt; R9	# spill size = 32
964 +   spill R10 -&gt; R22	# spill size = 64
968 +   spill R29 -&gt; R19	# spill size = 32
96c +   j  B58	#@branch

970     B104: #	out( B130 B105 ) &lt;- in( B31 )  Freq: 1.20716e-05
970 +   spill [sp, #8] -&gt; R8	# spill size = 64
974 +   spill R20 -&gt; [sp, #44]	# spill size = 32
978 +   spill R22 -&gt; [sp, #48]	# spill size = 64
97c +   spill R9 -&gt; [sp, #40]	# spill size = 32
980 +   spill R30 -&gt; [sp, #36]	# spill size = 32
984 +   spill R19 -&gt; [sp, #32]	# spill size = 32
988 +   spill R18 -&gt; [sp, #24]	# spill size = 64
98c +   spill R21 -&gt; [sp, #16]	# spill size = 64
990 +   # checkcastPP of R8, #@checkCastPP
990     mv  R11, precise klass java/util/HashMap$Node: 0x00000040d09ba360:Constant:exact *	# ptr, #@loadConP
9a8     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #32 L[2]=sp + #56 L[3]=sp + #16 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:152 (line 640) L[0]=R8 L[1]=sp + #32 L[2]=_ L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=sp + #44 STK[0]=sp + #48
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [36]=NarrowOop [40]=NarrowOop [48]=Oop [56]=Oop off=2476/0x9ac}

9ac     B105: #	out( B33 ) &lt;- in( B104 )  Freq: 1.20714e-05
        # Block is sole successor of call
9ac +   spill [sp, #32] -&gt; R29	# spill size = 32
9b0 +   spill [sp, #16] -&gt; R21	# spill size = 64
9b4 +   spill [sp, #24] -&gt; R18	# spill size = 64
9b8 +   spill [sp, #36] -&gt; R30	# spill size = 32
9bc +   spill [sp, #40] -&gt; R9	# spill size = 32
9c0 +   spill [sp, #48] -&gt; R22	# spill size = 64
9c4 +   spill [sp, #44] -&gt; R20	# spill size = 32
9c8 +   spill R10 -&gt; R24	# spill size = 64
9cc +   spill R29 -&gt; R19	# spill size = 32
9d0 +   j  B33	#@branch

9d4     B106: #	out( N1560 ) &lt;- in( B7 )  Freq: 9.99995e-07
9d4 +   li R11, #-28	# int, #@loadConI
9d8     spill [sp, #8] -&gt; R8	# spill size = 64
9dc +   spill R19 -&gt; [sp, #0]	# spill size = 32
9e0 +   spill R18 -&gt; [sp, #32]	# spill size = 64
9e4 +   spill R28 -&gt; [sp, #40]	# spill size = 32
9e8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.HashMap::putVal @ bci:40 (line 628) L[0]=R8 L[1]=sp + #0 L[2]=sp + #56 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=sp + #40 L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #32 STK[1]=sp + #40
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [32]=Oop [56]=Oop off=2540/0x9ec}
9ec     #@ShouldNotReachHere

9f8     B107: #	out( N1560 ) &lt;- in( B59 )  Freq: 5.19168e-07
9f8 +   spill [sp, #8] -&gt; R8	# spill size = 64
9fc +   li R11, #-42	# int, #@loadConI
a00     spill R18 -&gt; [sp, #0]	# spill size = 64
a04 +   spill R28 -&gt; [sp, #8]	# spill size = 32
a08 +   spill R22 -&gt; [sp, #16]	# spill size = 64
a0c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;array_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:59 (line 629) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #0 STK[1]=sp + #8 STK[2]=sp + #16
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=2576/0xa10}
a10     #@ShouldNotReachHere

a1c     B108: #	out( N1560 ) &lt;- in( B6 )  Freq: 3.95126e-07
a1c +   li R11, #-187	# int, #@loadConI
a20     spill [sp, #8] -&gt; R8	# spill size = 64
a24 +   spill R19 -&gt; [sp, #0]	# spill size = 32
a28 +   spill R18 -&gt; [sp, #24]	# spill size = 64
a2c +   spill R7 -&gt; [sp, #32]	# spill size = 32
a30     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:16 (line 626) L[0]=R8 L[1]=sp + #0 L[2]=sp + #56 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=_ L[8]=sp + #32 L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #32
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [56]=Oop off=2612/0xa34}
a34     #@ShouldNotReachHere

a40     B109: #	out( N1560 ) &lt;- in( B27 )  Freq: 2.72698e-07
a40 +   li R11, #-187	# int, #@loadConI
a44     spill [sp, #8] -&gt; R8	# spill size = 64
a48 +   spill R19 -&gt; [sp, #0]	# spill size = 32
a4c +   spill R18 -&gt; [sp, #24]	# spill size = 64
a50 +   spill R29 -&gt; [sp, #32]	# spill size = 64
a54     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:109 (line 635) L[0]=R8 L[1]=sp + #0 L[2]=sp + #56 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=sp + #32 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#1
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [56]=Oop off=2648/0xa58}
a58     #@ShouldNotReachHere

a64     B110: #	out( B61 ) &lt;- in( B82 )  Freq: 2.59577e-07
a64 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
a64     spill R23 -&gt; R11	# spill size = 64
a68 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
a98 +   j  B61	#@branch

a9c     B111: #	out( N1560 ) &lt;- in( B11 )  Freq: 2.11701e-07
a9c +   li R11, #-34	# int, #@loadConI
aa0     spill [sp, #8] -&gt; R8	# spill size = 64
aa4 +   spill R19 -&gt; [sp, #0]	# spill size = 32
aa8 +   spill R18 -&gt; [sp, #24]	# spill size = 64
aac +   spill R29 -&gt; [sp, #32]	# spill size = 64
ab0 +   spill R7 -&gt; [sp, #40]	# spill size = 64
ab4 +   spill R30 -&gt; [sp, #48]	# spill size = 64
ab8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #40 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=sp + #32 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #56 STK[1]=sp + #48
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=2748/0xabc}
abc     #@ShouldNotReachHere

ac8     B112: #	out( N1560 ) &lt;- in( B16 )  Freq: 2.00608e-07
ac8     #@ShouldNotReachHere

ad4     B113: #	out( N1560 ) &lt;- in( B17 )  Freq: 2.00608e-07
ad4     #@ShouldNotReachHere

ae0     B114: #	out( N1560 ) &lt;- in( B19 B18 )  Freq: 2.92382e-07
ae0 +   spill [sp, #8] -&gt; R8	# spill size = 64
ae4 +   li R11, #-187	# int, #@loadConI
ae8     spill R19 -&gt; [sp, #0]	# spill size = 32
aec +   spill R31 -&gt; [sp, #8]	# spill size = 64
af0 +   spill R18 -&gt; [sp, #24]	# spill size = 64
af4 +   spill R29 -&gt; [sp, #32]	# spill size = 64
af8 +   spill R10 -&gt; [sp, #4]	# spill size = 32
afc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:94 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=sp + #32 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #4
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop off=2816/0xb00}
b00     #@ShouldNotReachHere

b0c     B115: #	out( B22 ) &lt;- in( B89 )  Freq: 1.79773e-07
b0c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
b0c     spill R23 -&gt; R11	# spill size = 64
b10 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
b40 +   j  B22	#@branch

b44     B116: #	out( N1560 ) &lt;- in( B45 )  Freq: 1.47856e-07
b44 +   li R11, #-34	# int, #@loadConI
b48     spill [sp, #8] -&gt; R8	# spill size = 64
b4c +   spill R19 -&gt; [sp, #0]	# spill size = 32
b50 +   spill R21 -&gt; [sp, #16]	# spill size = 64
b54 +   spill R18 -&gt; [sp, #24]	# spill size = 64
b58 +   spill R22 -&gt; [sp, #32]	# spill size = 64
b5c +   spill R20 -&gt; [sp, #4]	# spill size = 32
b60 +   spill R7 -&gt; [sp, #40]	# spill size = 64
b64 +   spill R30 -&gt; [sp, #48]	# spill size = 64
b68     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #40 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #32 L[11]=_ L[12]=sp + #4 STK[0]=sp + #56 STK[1]=sp + #48
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=2924/0xb6c}
b6c     #@ShouldNotReachHere

b78     B117: #	out( N1560 ) &lt;- in( B50 )  Freq: 1.40108e-07
b78     #@ShouldNotReachHere

b84     B118: #	out( N1560 ) &lt;- in( B51 )  Freq: 1.40108e-07
b84     #@ShouldNotReachHere

b90     B119: #	out( N1560 ) &lt;- in( B10 )  Freq: 1.00947e-07
b90 +   li R11, #-187	# int, #@loadConI
b94     spill [sp, #8] -&gt; R8	# spill size = 64
b98 +   spill R19 -&gt; [sp, #0]	# spill size = 32
b9c +   spill R18 -&gt; [sp, #24]	# spill size = 64
ba0 +   spill R29 -&gt; [sp, #32]	# spill size = 64
ba4 +   spill R30 -&gt; [sp, #48]	# spill size = 64
ba8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:81 (line 632) L[0]=R8 L[1]=sp + #0 L[2]=sp + #56 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=sp + #32 L[8]=_ L[9]=_ L[10]=_ L[11]=sp + #48 L[12]=_ STK[0]=sp + #48 STK[1]=sp + #56
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop off=2988/0xbac}
bac     #@ShouldNotReachHere

bb8     B120: #	out( N1560 ) &lt;- in( B15 )  Freq: 9.89895e-08
bb8 +   li R11, #-187	# int, #@loadConI
bbc     spill [sp, #8] -&gt; R8	# spill size = 64
bc0 +   spill R19 -&gt; [sp, #0]	# spill size = 32
bc4 +   spill R18 -&gt; [sp, #24]	# spill size = 64
bc8 +   spill R29 -&gt; [sp, #32]	# spill size = 64
bcc +   spill R31 -&gt; [sp, #40]	# spill size = 64
bd0 +   spill R30 -&gt; [sp, #48]	# spill size = 64
bd4 +   spill R7 -&gt; [sp, #4]	# spill size = 32
bd8 +   spill R28 -&gt; [sp, #56]	# spill size = 32
bdc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #40 L[1]=_ L[2]=sp + #48 STK[0]=sp + #4 STK[1]=sp + #56
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #40 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=sp + #32 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop off=3040/0xbe0}
be0     #@ShouldNotReachHere

bec     B121: #	out( N1560 ) &lt;- in( B44 )  Freq: 7.05031e-08
bec +   li R11, #-187	# int, #@loadConI
bf0     spill [sp, #8] -&gt; R8	# spill size = 64
bf4 +   spill R19 -&gt; [sp, #0]	# spill size = 32
bf8 +   spill R21 -&gt; [sp, #16]	# spill size = 64
bfc +   spill R18 -&gt; [sp, #24]	# spill size = 64
c00 +   spill R22 -&gt; [sp, #32]	# spill size = 64
c04 +   spill R20 -&gt; [sp, #4]	# spill size = 32
c08 +   spill R7 -&gt; [sp, #40]	# spill size = 64
c0c +   spill R30 -&gt; [sp, #56]	# spill size = 64
c10     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:193 (line 645) L[0]=R8 L[1]=sp + #0 L[2]=sp + #40 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #32 L[11]=sp + #56 L[12]=sp + #4 STK[0]=sp + #56 STK[1]=sp + #40
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop off=3092/0xc14}
c14     #@ShouldNotReachHere

c20     B122: #	out( N1560 ) &lt;- in( B49 )  Freq: 6.91358e-08
c20 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
c28 +   li R11, #-187	# int, #@loadConI
c2c     spill R19 -&gt; [sp, #8]	# spill size = 32
c30 +   spill R21 -&gt; [sp, #16]	# spill size = 64
c34 +   spill R18 -&gt; [sp, #24]	# spill size = 64
c38 +   spill R22 -&gt; [sp, #32]	# spill size = 64
c3c +   spill R20 -&gt; [sp, #12]	# spill size = 32
c40 +   spill R31 -&gt; [sp, #48]	# spill size = 64
c44 +   spill R30 -&gt; [sp, #56]	# spill size = 64
c48 +   spill R13 -&gt; [sp, #64]	# spill size = 32
c4c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #48 L[1]=_ L[2]=sp + #56 STK[0]=sp + #64 STK[1]=R8
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #48 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #32 L[11]=_ L[12]=sp + #12
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop off=3152/0xc50}
c50     #@ShouldNotReachHere

c5c     B123: #	out( B35 ) &lt;- in( B96 )  Freq: 6.06327e-08
c5c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
c5c     spill R23 -&gt; R11	# spill size = 64
c60 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
c90 +   j  B35	#@branch

c94     B124: #	out( N1560 ) &lt;- in( B48 )  Freq: 1e-35
c94 +   spill [sp, #8] -&gt; R8	# spill size = 64
c98 +   li R11, #-34	# int, #@loadConI
c9c     spill R19 -&gt; [sp, #0]	# spill size = 32
ca0 +   spill R21 -&gt; [sp, #8]	# spill size = 64
ca4 +   spill R18 -&gt; [sp, #16]	# spill size = 64
ca8 +   spill R22 -&gt; [sp, #24]	# spill size = 64
cac +   spill R20 -&gt; [sp, #4]	# spill size = 32
cb0 +   spill R31 -&gt; [sp, #40]	# spill size = 64
cb4 +   spill R30 -&gt; [sp, #56]	# spill size = 64
cb8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #40 L[1]=sp + #56 L[2]=_ STK[0]=sp + #56
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #40 L[3]=sp + #8 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #24 L[11]=_ L[12]=sp + #4
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop off=3260/0xcbc}
cbc     #@ShouldNotReachHere

cc8     B125: #	out( N1560 ) &lt;- in( B14 )  Freq: 1e-35
cc8 +   li R11, #-34	# int, #@loadConI
ccc     spill [sp, #8] -&gt; R8	# spill size = 64
cd0 +   spill R19 -&gt; [sp, #0]	# spill size = 32
cd4 +   spill R18 -&gt; [sp, #24]	# spill size = 64
cd8 +   spill R29 -&gt; [sp, #32]	# spill size = 64
cdc +   spill R31 -&gt; [sp, #40]	# spill size = 64
ce0 +   spill R30 -&gt; [sp, #56]	# spill size = 64
ce4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #40 L[1]=sp + #56 L[2]=_ STK[0]=sp + #56
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #40 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=sp + #32 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop off=3304/0xce8}
ce8     #@ShouldNotReachHere

cf4     B126: #	out( N1560 ) &lt;- in( B1 )  Freq: 4.76837e-07
cf4 +   li R11, #-187	# int, #@loadConI
cf8     spill R13 -&gt; [sp, #0]	# spill size = 64
cfc +   spill R12 -&gt; [sp, #16]	# spill size = 64
d00 +   spill R12 -&gt; [sp, #24]	# spill size = 64
d04     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::hash @ bci:1 (line 338) L[0]=sp + #24 L[1]=_ STK[0]=sp + #16
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #16 L[2]=sp + #0 STK[0]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop off=3336/0xd08}
d08     #@ShouldNotReachHere

d14     B127: #	out( N1560 ) &lt;- in( B13 )  Freq: 2.00608e-07
d14 +   li R11, #-12	# int, #@loadConI
d18     spill [sp, #8] -&gt; R8	# spill size = 64
d1c +   spill R19 -&gt; [sp, #0]	# spill size = 32
d20 +   spill R18 -&gt; [sp, #24]	# spill size = 64
d24 +   spill R29 -&gt; [sp, #32]	# spill size = 64
d28 +   spill R31 -&gt; [sp, #40]	# spill size = 64
d2c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #40 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #40 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=sp + #32 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=3376/0xd30}
d30     #@ShouldNotReachHere

d3c     B128: #	out( N1560 ) &lt;- in( B69 )  Freq: 1.73633e-07
d3c +   li R11, #-10	# int, #@loadConI
d40     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:26 (line 627) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#NULL
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {off=3396/0xd44}
d44     #@ShouldNotReachHere

d50     B129: #	out( N1560 ) &lt;- in( B47 )  Freq: 1.40108e-07
d50 +   spill [sp, #8] -&gt; R8	# spill size = 64
d54 +   li R11, #-12	# int, #@loadConI
d58     spill R19 -&gt; [sp, #0]	# spill size = 32
d5c +   spill R21 -&gt; [sp, #8]	# spill size = 64
d60 +   spill R18 -&gt; [sp, #16]	# spill size = 64
d64 +   spill R22 -&gt; [sp, #24]	# spill size = 64
d68 +   spill R20 -&gt; [sp, #4]	# spill size = 32
d6c +   spill R31 -&gt; [sp, #40]	# spill size = 64
d70     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #40 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #40 L[3]=sp + #8 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #24 L[11]=_ L[12]=sp + #4
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop off=3444/0xd74}
d74     #@ShouldNotReachHere

d80     B130: #	out( B138 ) &lt;- in( B104 )  Freq: 1.20716e-10
d80      -- 	// exception oop; no code emitted, #@CreateException
d80 +   j  B138	#@branch

d84     B131: #	out( B138 ) &lt;- in( B102 )  Freq: 5.12392e-10
d84      -- 	// exception oop; no code emitted, #@CreateException
d84 +   j  B138	#@branch

d88     B132: #	out( B138 ) &lt;- in( B79 )  Freq: 5.72022e-09
d88      -- 	// exception oop; no code emitted, #@CreateException
d88 +   j  B138	#@branch

d8c     B133: #	out( B139 ) &lt;- in( B77 )  Freq: 2.99699e-08
d8c      -- 	// exception oop; no code emitted, #@CreateException
d8c +   spill R10 -&gt; R11	# spill size = 64
d90 +   j  B139	#@branch

d94     B134: #	out( B138 ) &lt;- in( B75 )  Freq: 6.86125e-08
d94      -- 	// exception oop; no code emitted, #@CreateException
d94 +   j  B138	#@branch

d98     B135: #	out( B138 ) &lt;- in( B73 )  Freq: 7.43365e-08
d98      -- 	// exception oop; no code emitted, #@CreateException
d98 +   j  B138	#@branch

d9c     B136: #	out( B138 ) &lt;- in( B71 )  Freq: 2.48978e-07
d9c      -- 	// exception oop; no code emitted, #@CreateException
d9c +   j  B138	#@branch

da0     B137: #	out( B138 ) &lt;- in( B68 )  Freq: 1.71361e-06
da0      -- 	// exception oop; no code emitted, #@CreateException

da0     B138: #	out( B139 ) &lt;- in( B137 B134 B131 B132 B130 B136 B135 )  Freq: 2.11189e-06
da0 +   spill R10 -&gt; R11	# spill size = 64

da4     B139: #	out( N1560 ) &lt;- in( B133 B138 )  Freq: 2.14186e-06
da4     # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
db0 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='580'>
----------------------- MetaData before Compile_id = 580 ------------------------
{method}
 - this oop:          0x00000040961a1da0
 - method holder:     &apos;java/util/HashMap&apos;
 - constants:         0x000000409619f4e0 constant pool [610] {0x000000409619f4e0} for &apos;java/util/HashMap&apos; cache=0x00000040961a4fd8
 - access:            0xc1000010  final 
 - name:              &apos;putVal&apos;
 - signature:         &apos;(ILjava/lang/Object;Ljava/lang/Object;ZZ)Ljava/lang/Object;&apos;
 - max stack:         8
 - max locals:        13
 - size of params:    6
 - method size:       13
 - highest level:     4
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400832ef00: 0xbabbaa i2c: 0x0000004013930340 c2i: 0x0000004013930398 c2iUV: 0x0000004013930364
 - compiled entry     0x0000004013930398
 - code size:         300
 - code start:        0x00000040961a1b70
 - code end (excl):   0x00000040961a1c9c
 - method data:       0x0000004096485328
 - checked ex length: 0
 - linenumber start:  0x00000040961a1c9c
 - localvar length:   18
 - localvar start:    0x00000040961a1cc4

------------------------ OptoAssembly for Compile_id = 580 -----------------------
#
#  java/lang/Object * ( java/util/HashMap:NotNull *, int, java/lang/Object *, java/lang/Object *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/HashMap:NotNull *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3:c_rarg3   : parm 2: java/lang/Object *
#r018 c_rarg4:c_rarg4   : parm 3: java/lang/Object *
#r020 c_rarg5   : parm 4: int
#r022 c_rarg6   : parm 5: int
# -- Old sp -- Framesize: 112 --
#r263 sp+108: in_preserve
#r262 sp+104: return address
#r261 sp+100: in_preserve
#r260 sp+96: saved fp register
#r259 sp+92: pad2, stack alignment
#r258 sp+88: pad2, stack alignment
#r257 sp+84: Fixed slot 1
#r256 sp+80: Fixed slot 0
#r283 sp+76: spill
#r282 sp+72: spill
#r281 sp+68: spill
#r280 sp+64: spill
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1567: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B68 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=112
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #112
	
03c     lwu  R28, [R11, #36]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap.table
040 +   decode_heap_oop  R18, R28	#@decodeHeapOop
044     spill R16 -&gt; [sp, #28]	# spill size = 32
048 +   spill R15 -&gt; [sp, #24]	# spill size = 32
04c +   spill R14 -&gt; [sp, #16]	# spill size = 64
050 +   spill R13 -&gt; [sp, #8]	# spill size = 64
054 +   spill R12 -&gt; [sp, #0]	# spill size = 32
058 +   spill R11 -&gt; [sp, #32]	# spill size = 64
05c +   beq   R18, zr, B68	#@cmpP_imm0_branch  P=0.171361 C=5503.000000

060     B2: #	out( B106 B3 ) &lt;- in( B1 )  Freq: 0.828639
060 +   lwu  R7, [R18, #12]	# range, #@loadRange
064 +   bleu  R7, zr, B106	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=4560.000000

068     B3: #	out( B104 B4 ) &lt;- in( B70 B2 )  Freq: 0.999996
068 +   addiw  R28, R7, #-1	#@addI_reg_imm
06c     spill [sp, #0] -&gt; R9	# spill size = 32
070 +   andr  R10, R28, R9	#@andI_reg_reg
074 +   addw  R28, R10, zr	#@convI2L_reg_reg
078 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
07c +   add R28, R18, R28	# ptr, #@addP_reg_reg
080 +   addi  R21, R28, #16	# ptr, #@addP_reg_imm
084 +   ble  R7, zr, B104	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

088     B4: #	out( B55 B5 ) &lt;- in( B3 )  Freq: 0.999995
088 +   lwu  R28, [R21]	# loadN, compressed ptr, #@loadN
08c +   decode_heap_oop  R16, R28	#@decodeHeapOop
090     spill [sp, #32] -&gt; R7	# spill size = 64
094 +   lwu  R11, [R7, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
098     spill [sp, #8] -&gt; R30	# spill size = 64
09c +   encode_heap_oop  R31, R30	#@encodeHeapOop
0a0     spill [sp, #16] -&gt; R20	# spill size = 64
0a4 +   encode_heap_oop  R19, R20	#@encodeHeapOop
0a8 +   mv  R15, NULL	# NULL ptr, #@loadConP0
0ac +   mv  R14, narrowklass: precise klass java/util/HashMap: 0x00000040d014cb70:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0bc +   li R13, #1	# long, #@loadConL
0c0 +   mv  R28, narrowklass: precise klass java/util/HashMap$Node: 0x00000040d014dd30:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0d0 +   beq   R16, zr, B55	#@cmpP_imm0_branch  P=0.519171 C=5503.000000

0d4     B5: #	out( B25 B6 ) &lt;- in( B4 )  Freq: 0.480826
0d4 +   lw  R7, [R16, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
0d8 +   li R12, #0	# int, #@loadConI
0dc +   bne  R7, R9, B25	#@cmpI_branch  P=0.559713 C=2646.000000

0e0     B6: #	out( B119 B7 ) &lt;- in( B5 )  Freq: 0.211702
0e0 +   lwu  R28, [R16, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
0e4 +   decode_heap_oop  R29, R28	#@decodeHeapOop
0e8 +   beq  R29, R30, B119	#@cmpP_branch  P=0.000000 C=1165.000000

0ec     B7: #	out( B129 B8 ) &lt;- in( B6 )  Freq: 0.211702
0ec     lwu  R7, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0f0     NullCheck R30

0f0     B8: #	out( B109 B9 ) &lt;- in( B7 )  Freq: 0.211701
0f0 +   mv  R31, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
100 +   bne  R7, R31, B109	#@cmpN_branch  P=0.000001 C=-1.000000

104     B9: #	out( B17 B10 ) &lt;- in( B8 )  Freq: 0.211701
104 +   # checkcastPP of R30, #@checkCastPP
104     beq  R30, R29, B17	#@cmpP_branch  P=0.064818 C=5338.000000

108     B10: #	out( B126 B11 ) &lt;- in( B9 )  Freq: 0.197979
108     lwu  R7, [R29, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
10c     NullCheck R29

10c     B11: #	out( B125 B12 ) &lt;- in( B10 )  Freq: 0.197979
10c +   lwu  R10, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
110 +   lb  R28, [R30, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
114 +   bne  R7, R31, B125	#@cmpN_branch  P=0.000000 C=-1.000000

118     B12: #	out( B120 B13 ) &lt;- in( B11 )  Freq: 0.197979
118 +   # checkcastPP of R29, #@checkCastPP
118     lb  R7, [R29, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
11c +   lwu  R11, [R29, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
120 +   decode_heap_oop  R31, R10	#@decodeHeapOop
124 +   bne  R28, R7, B120	#@cmpI_branch  P=0.000000 C=4992.000000

128     B13: #	out( B110 B14 ) &lt;- in( B12 )  Freq: 0.197979
128 +   beq   R31, zr, B110	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

12c     B14: #	out( B111 B15 ) &lt;- in( B13 )  Freq: 0.197979
12c +   decode_heap_oop  R7, R11	#@decodeHeapOop
130 +   lwu  R14, [R31, #12]	# range, #@loadRange
134 +   beq   R7, zr, B111	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

138     B15: #	out( B113 B16 ) &lt;- in( B14 )  Freq: 0.197978
138 +   lwu  R29, [R7, #12]	# range, #@loadRange
13c +   bne  R14, R29, B113	#@cmpI_branch  P=0.000001 C=-1.000000

140     B16: #	out( B112 B17 ) &lt;- in( B15 )  Freq: 0.197978
140 +   addi  R13, R7, #16	# ptr, #@addP_reg_imm
144 +   addi  R11, R31, #16	# ptr, #@addP_reg_imm
148     String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
1d8 +   beq  R10, zr, B112	#@cmpI_reg_imm0_branch  P=0.000000 C=1165.000000

1dc     B17: #	out( B18 ) &lt;- in( B9 B16 )  Freq: 0.2117
1dc +   spill R16 -&gt; R22	# spill size = 64

1e0     B18: #	out( B115 B19 ) &lt;- in( B17 B45 B52 )  Freq: 0.359555
1e0 +   lwu  R28, [R22, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.value
1e4 +   decode_heap_oop  R18, R28	#@decodeHeapOop
1e8     spill [sp, #24] -&gt; R7	# spill size = 32
1ec +   bne  R7, zr, B115	#@cmpI_reg_imm0_branch  P=0.000000 C=1979.000000

1f0     B19: #	out( B86 B20 ) &lt;- in( B18 )  Freq: 0.359555
1f0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1f0     lb  R7, [R23, #56]	# byte, #@loadB
1f4 +   bne  R7, zr, B86	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1f8     B20: #	out( B23 B21 ) &lt;- in( B114 B88 B86 B19 )  Freq: 0.359555
1f8 +   mv  R7, R22	# ptr -&gt; long, #@castP2X
1fc +   mv  R28, R20	# ptr -&gt; long, #@castP2X
200 +   xorr  R28, R28, R7	#@xorL_reg_reg
204 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
208     spill [sp, #32] -&gt; R29	# spill size = 64
20c +   lwu  R9, [R29, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
210 +   mv  R21, narrowklass: precise klass java/util/HashMap: 0x00000040d014cb70:Constant:exact *	# compressed klass ptr, #@loadConNKlass
220 +   sw  R19, [R22, #20]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.value
224 +   beq  R28, zr, B23	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

228     B21: #	out( B23 B22 ) &lt;- in( B20 )  Freq: 0.359195
228 +   beq   R20, zr, B23	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

22c     B22: #	out( B89 B23 ) &lt;- in( B21 )  Freq: 0.358836
22c +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
230 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
23c +   add R10, R28, R7	# ptr, #@addP_reg_reg
240 +   lb  R28, [R10]	# byte, #@loadB
244 +   li R29, #4	# int, #@loadConI
248 +   bne  R28, R29, B89	#@cmpI_branch  P=0.001000 C=-1.000000

24c     B23: #	out( B67 B24 ) &lt;- in( B91 B92 B89 B22 B21 B20 )  Freq: 0.359555
24c +   beq  R9, R21, B67	#@cmpN_branch  P=0.999999 C=-1.000000

250     B24: #	out( N1567 ) &lt;- in( B23 )  Freq: 3.59555e-07
250 +   li R11, #-34	# int, #@loadConI
254     spill R18 -&gt; R8	# spill size = 64
258 +   spill R22 -&gt; [sp, #8]	# spill size = 64
25c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:253 (line 655) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=R8 STK[0]=sp + #32 STK[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop [32]=Oop off=608/0x260}
260     #@ShouldNotReachHere

26c     B25: #	out( B107 B26 ) &lt;- in( B5 )  Freq: 0.269125
26c +   lwu  R10, [R16, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
270 +   lwu  R7, [R16, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
274 +   mv  R29, narrowklass: precise klass java/util/HashMap$TreeNode: 0x00000040d0152410:Constant:exact *	# compressed klass ptr, #@loadConNKlass
284 +   decode_heap_oop  R22, R10	#@decodeHeapOop
288 +   beq  R7, R29, B107	#@cmpN_branch  P=0.000001 C=-1.000000

28c     B26: #	out( B38 B27 ) &lt;- in( B25 )  Freq: 0.269124
28c +   bne   R22, zr, B38	#@cmpP_imm0_branch  P=0.614451 C=1730.000000

290     B27: #	out( B28 ) &lt;- in( B26 )  Freq: 0.103761
290 +   li R21, #0	# int, #@loadConI
294     spill R16 -&gt; R22	# spill size = 64

298     B28: #	out( B77 B29 ) &lt;- in( B40 B27 )  Freq: 0.121269
298 +   bne  R11, R14, B77	#@cmpN_branch  P=0.004717 C=-1.000000

29c     B29: #	out( B102 B30 ) &lt;- in( B28 )  Freq: 0.120697
29c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
29c     ld  R25, [R23, #288]	# ptr, #@loadP
2a0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2a0     ld  R7, [R23, #304]	# ptr, #@loadP
2a4 +   addi  R29, R25, #32	# ptr, #@addP_reg_imm
2a8 +   bgeu  R29, R7, B102	#@cmpP_branch  P=0.000100 C=-1.000000

2ac     B30: #	out( B31 ) &lt;- in( B29 )  Freq: 0.120684
2ac +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2ac     sd  R29, [R23, #288]	# ptr, #@storeP
2b0 +   sd  R13, [R25]	# long, #@storeL
2b4 +   sw  R28, [R25, #8]	# compressed klass ptr, #@storeNKlass
2b8 +   sd  zr, [R25, #24]	# long, #@storeimmL0

2bc     B31: #	out( B32 ) &lt;- in( B103 B30 )  Freq: 0.120697
2bc +   sw  R9, [R25, #12]	# int, #@storeI
2c0 +   sw  R31, [R25, #16]	# compressed ptr, #@storeN
2c4 +   sw  R19, [R25, #20]	# compressed ptr, #@storeN
2c8     
2c8 +   # checkcastPP of R25, #@checkCastPP
2c8     #@membar_release
	fence iorw ow

2cc     B32: #	out( B93 B33 ) &lt;- in( B31 B78 )  Freq: 0.121269
2cc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2cc     lb  R7, [R23, #56]	# byte, #@loadB
2d0 +   bne  R7, zr, B93	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

2d4     B33: #	out( B36 B34 ) &lt;- in( B123 B95 B93 B32 )  Freq: 0.121269
2d4 +   mv  R28, R22	# ptr -&gt; long, #@castP2X
2d8 +   mv  R7, R25	# ptr -&gt; long, #@castP2X
2dc +   xorr  R7, R7, R28	#@xorL_reg_reg
2e0 +   encode_heap_oop  R30, R25	#@encodeHeapOop
2e4 +   srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
2e8 +   li R24, #7	# int, #@loadConI
2ec +   sw  R30, [R22, #24]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.next
2f0 +   beq  R7, zr, B36	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

2f4     B34: #	out( B36 B35 ) &lt;- in( B33 )  Freq: 0.121147
2f4 +   beq   R25, zr, B36	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

2f8     B35: #	out( B96 B36 ) &lt;- in( B34 )  Freq: 0.121026
2f8 +   srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
2fc +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
308 +   add R10, R28, R7	# ptr, #@addP_reg_reg
30c +   lb  R7, [R10]	# byte, #@loadB
310 +   li R29, #4	# int, #@loadConI
314 +   bne  R7, R29, B96	#@cmpI_branch  P=0.001000 C=-1.000000

318     B36: #	out( B64 B37 ) &lt;- in( B98 B99 B96 B35 B34 B33 )  Freq: 0.121269
318 +   blt  R21, R24, B64	#@cmpI_branch  P=1.000000 C=667.000000

31c     B37: #	out( N1567 ) &lt;- in( B36 )  Freq: 5.78253e-08
31c +   spill [sp, #24] -&gt; R7	# spill size = 32
320 +   spill [sp, #28] -&gt; R28	# spill size = 32
324 +   li R11, #-187	# int, #@loadConI
328     spill [sp, #32] -&gt; R8	# spill size = 64
32c +   spill R9 -&gt; [sp, #0]	# spill size = 32
330 +   spill R20 -&gt; [sp, #8]	# spill size = 64
334 +   spill R7 -&gt; [sp, #4]	# spill size = 32
338 +   spill R28 -&gt; [sp, #16]	# spill size = 32
33c +   spill R18 -&gt; [sp, #24]	# spill size = 64
340 +   spill R21 -&gt; [sp, #20]	# spill size = 32
344     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:162 (line 641) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=sp + #8 L[4]=sp + #4 L[5]=sp + #16 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=_ STK[0]=sp + #20 STK[1]=#7
        # OopMap {fp=Oop [8]=Oop [24]=Oop off=840/0x348}
348     #@ShouldNotReachHere

354     B38: #	out( B39 ) &lt;- in( B26 )  Freq: 0.165364
354 +   li R21, #0	# int, #@loadConI

358     B39: #	out( B42 B40 ) &lt;- in( B38 B41 ) Loop( B39-B41 inner ) Freq: 0.193266
358 +   lw  R7, [R22, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
35c +   beq  R7, R9, B42	#@cmpI_branch  P=0.765038 C=1064.000000

360     B40: #	out( B28 B41 ) &lt;- in( B39 )  Freq: 0.0454103
360 +   addiw  R21, R21, #1	#@addI_reg_imm
364 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
364     ld  R7, [R23, #920]	# ptr, #@loadP
368 +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.util.HashMap::putVal @ bci:219 (line 638) L[0]=sp + #32 L[1]=R9 L[2]=R30 L[3]=R20 L[4]=sp + #24 L[5]=sp + #28 L[6]=R18 L[7]=R22 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=R21
        # OopMap {x30=Oop xmethod=NarrowOop x18=Oop x19=NarrowOop esp=Oop xbcp=Oop [32]=Oop off=872/0x368}
36c +   lwu  R7, [R22, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
370 +   decode_heap_oop  R7, R7	#@decodeHeapOop
374 +   beq   R7, zr, B28	#@cmpP_imm0_branch  P=0.385549 C=250.000000

378     B41: #	out( B39 ) &lt;- in( B40 )  Freq: 0.0279024
378 +   spill R7 -&gt; R22	# spill size = 64
37c +   j  B39	#@branch

380     B42: #	out( B121 B43 ) &lt;- in( B39 )  Freq: 0.147856
380 +   lwu  R28, [R22, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
384 +   decode_heap_oop  R31, R28	#@decodeHeapOop
388 +   beq  R31, R30, B121	#@cmpP_branch  P=0.000000 C=814.000000

38c     B43: #	out( B130 B44 ) &lt;- in( B42 )  Freq: 0.147856
38c     lwu  R7, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
390     NullCheck R30

390     B44: #	out( B116 B45 ) &lt;- in( B43 )  Freq: 0.147856
390 +   mv  R29, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
3a0 +   bne  R7, R29, B116	#@cmpN_branch  P=0.000001 C=-1.000000

3a4     B45: #	out( B18 B46 ) &lt;- in( B44 )  Freq: 0.147855
3a4 +   spill R30 -&gt; R15	# spill size = 64
3a8 +   # checkcastPP of R15, #@checkCastPP
3a8     beq  R15, R31, B18	#@cmpP_branch  P=0.064818 C=5338.000000

3ac     B46: #	out( B128 B47 ) &lt;- in( B45 )  Freq: 0.138272
3ac     lwu  R7, [R31, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
3b0     NullCheck R31

3b0     B47: #	out( B124 B48 ) &lt;- in( B46 )  Freq: 0.138272
3b0 +   lwu  R30, [R15, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
3b4 +   lb  R28, [R15, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
3b8 +   bne  R7, R29, B124	#@cmpN_branch  P=0.000000 C=-1.000000

3bc     B48: #	out( B122 B49 ) &lt;- in( B47 )  Freq: 0.138272
3bc +   # checkcastPP of R31, #@checkCastPP
3bc     lb  R8, [R31, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
3c0 +   lwu  R29, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
3c4 +   decode_heap_oop  R7, R30	#@decodeHeapOop
3c8 +   bne  R28, R8, B122	#@cmpI_branch  P=0.000000 C=4992.000000

3cc     B49: #	out( B117 B50 ) &lt;- in( B48 )  Freq: 0.138272
3cc +   beq   R7, zr, B117	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

3d0     B50: #	out( B118 B51 ) &lt;- in( B49 )  Freq: 0.138271
3d0 +   decode_heap_oop  R28, R29	#@decodeHeapOop
3d4 +   lwu  R14, [R7, #12]	# range, #@loadRange
3d8 +   beq   R28, zr, B118	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

3dc     B51: #	out( B54 B52 ) &lt;- in( B50 )  Freq: 0.138271
3dc +   lwu  R29, [R28, #12]	# range, #@loadRange
3e0 +   bne  R14, R29, B54	#@cmpI_branch  P=0.000001 C=-1.000000

3e4     B52: #	out( B18 B53 ) &lt;- in( B51 )  Freq: 0.138271
3e4 +   addi  R13, R28, #16	# ptr, #@addP_reg_imm
3e8 +   addi  R11, R7, #16	# ptr, #@addP_reg_imm
3ec     String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
47c +   bne  R10, zr, B18	#@cmpI_reg_imm0_branch  P=1.000000 C=814.000000

480     B53: #	out( B54 ) &lt;- in( B52 )  Freq: 6.59328e-08
480 +   spill R10 -&gt; R12	# spill size = 32

484     B54: #	out( N1567 ) &lt;- in( B53 B51 )  Freq: 2.04204e-07
484 +   spill [sp, #24] -&gt; R7	# spill size = 32
488 +   spill [sp, #28] -&gt; R28	# spill size = 32
48c +   spill [sp, #32] -&gt; R8	# spill size = 64
490 +   li R11, #-187	# int, #@loadConI
494     spill R9 -&gt; [sp, #0]	# spill size = 32
498 +   spill R20 -&gt; [sp, #8]	# spill size = 64
49c +   spill R7 -&gt; [sp, #4]	# spill size = 32
4a0 +   spill R28 -&gt; [sp, #16]	# spill size = 32
4a4 +   spill R18 -&gt; [sp, #24]	# spill size = 64
4a8 +   spill R22 -&gt; [sp, #32]	# spill size = 64
4ac +   spill R21 -&gt; [sp, #20]	# spill size = 32
4b0 +   spill R12 -&gt; [sp, #40]	# spill size = 32
4b4 +   spill R15 -&gt; [sp, #48]	# spill size = 64
4b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:206 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #8 L[4]=sp + #4 L[5]=sp + #16 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #32 L[11]=_ L[12]=sp + #20 STK[0]=sp + #40
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop off=1212/0x4bc}
4bc     #@ShouldNotReachHere

4c8     B55: #	out( B75 B56 ) &lt;- in( B4 )  Freq: 0.519169
4c8 +   bne  R11, R14, B75	#@cmpN_branch  P=0.013216 C=-1.000000

4cc     B56: #	out( B100 B57 ) &lt;- in( B55 )  Freq: 0.512308
4cc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
4cc     ld  R22, [R23, #288]	# ptr, #@loadP
4d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
4d0     ld  R7, [R23, #304]	# ptr, #@loadP
4d4 +   addi  R29, R22, #32	# ptr, #@addP_reg_imm
4d8 +   bgeu  R29, R7, B100	#@cmpP_branch  P=0.000100 C=-1.000000

4dc     B57: #	out( B58 ) &lt;- in( B56 )  Freq: 0.512256
4dc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
4dc     sd  R29, [R23, #288]	# ptr, #@storeP
4e0 +   sd  R13, [R22]	# long, #@storeL
4e4 +   sw  R28, [R22, #8]	# compressed klass ptr, #@storeNKlass
4e8 +   sd  zr, [R22, #24]	# long, #@storeimmL0

4ec     B58: #	out( B59 ) &lt;- in( B101 B57 )  Freq: 0.512308
4ec +   sw  R9, [R22, #12]	# int, #@storeI
4f0 +   sw  R31, [R22, #16]	# compressed ptr, #@storeN
4f4 +   sw  R19, [R22, #20]	# compressed ptr, #@storeN
4f8     
4f8 +   #@membar_release
	fence iorw ow
4fc +   # checkcastPP of R22, #@checkCastPP

4fc     B59: #	out( B105 B60 ) &lt;- in( B58 B76 )  Freq: 0.519169
4fc     lwu  R28, [R18, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
500 +   mv  R7, narrowklass: precise klass [Ljava/util/HashMap$Node;: 0x00000040d0150bd0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
510 +   bne  R28, R7, B105	#@cmpN_branch  P=0.000001 C=-1.000000

514     B60: #	out( B79 B61 ) &lt;- in( B59 )  Freq: 0.519168
514 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
514     lb  R28, [R23, #56]	# byte, #@loadB
518 +   bne  R28, zr, B79	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

51c     B61: #	out( B64 B62 ) &lt;- in( B108 B81 B79 B60 )  Freq: 0.519168
51c +   mv  R7, R21	# ptr -&gt; long, #@castP2X
520 +   mv  R28, R22	# ptr -&gt; long, #@castP2X
524 +   xorr  R28, R28, R7	#@xorL_reg_reg
528 +   encode_heap_oop  R29, R22	#@encodeHeapOop
52c +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
530 +   sw  R29, [R21]	# compressed ptr, #@storeN
534 +   beq  R28, zr, B64	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

538     B62: #	out( B64 B63 ) &lt;- in( B61 )  Freq: 0.518649
538 +   beq   R22, zr, B64	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

53c     B63: #	out( B82 B64 ) &lt;- in( B62 )  Freq: 0.51813
53c +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
540 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
54c +   add R10, R28, R7	# ptr, #@addP_reg_reg
550 +   lb  R28, [R10]	# byte, #@loadB
554 +   li R29, #4	# int, #@loadConI
558 +   bne  R28, R29, B82	#@cmpI_branch  P=0.001000 C=-1.000000

55c     B64: #	out( B71 B65 ) &lt;- in( B36 B84 B85 B82 B63 B62 B61 )  Freq: 0.640437
55c +   spill [sp, #32] -&gt; R7	# spill size = 64
560 +   lw  R28, [R7, #24]	# int, #@loadI ! Field: java/util/HashMap.modCount
564 +   lw  R7, [R7, #20]	# int, #@loadI ! Field: java/util/HashMap.size
568 +   spill [sp, #32] -&gt; R29	# spill size = 64
56c +   lw  R30, [R29, #28]	# int, #@loadI ! Field: java/util/HashMap.threshold
570 +   addiw  R29, R7, #1	#@addI_reg_imm
574 +   addiw  R28, R28, #1	#@addI_reg_imm
578     spill [sp, #32] -&gt; R7	# spill size = 64
57c +   sw  R28, [R7, #24]	# int, #@storeI ! Field: java/util/HashMap.modCount
580 +   sw  R29, [R7, #20]	# int, #@storeI ! Field: java/util/HashMap.size
584 +   bgt  R29, R30, B71	#@cmpI_branch  P=0.038876 C=3524.000000

588     B65: #	out( B73 B66 ) &lt;- in( B72 B64 )  Freq: 0.640436
588 +   spill [sp, #32] -&gt; R7	# spill size = 64
58c +   lwu  R7, [R7, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
590 +   mv  R29, narrowklass: precise klass java/util/HashMap: 0x00000040d014cb70:Constant:exact *	# compressed klass ptr, #@loadConNKlass
5a0 +   bne  R7, R29, B73	#@cmpN_branch  P=0.011607 C=-1.000000

5a4     B66: #	out( B67 ) &lt;- in( B65 B74 )  Freq: 0.640436
5a4 +   mv  R18, NULL	# NULL ptr, #@loadConP0

5a8     B67: #	out( N1567 ) &lt;- in( B23 B66 )  Freq: 0.99999
5a8     spill R18 -&gt; R10	# spill size = 64
5ac +   # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
5c4 +   ret	// return register, #@Ret

5c8     B68: #	out( B137 B69 ) &lt;- in( B1 )  Freq: 0.171361
5c8     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:20 (line 627) L[0]=sp + #32 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #24 L[5]=sp + #28 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {[8]=Oop [16]=Oop [32]=Oop off=1484/0x5cc}

5cc     B69: #	out( B127 B70 ) &lt;- in( B68 )  Freq: 0.171358
        # Block is sole successor of call
5cc     lwu  R7, [R10, #12]	# range, #@loadRange
5d0     NullCheck R10

5d0     B70: #	out( B3 ) &lt;- in( B69 )  Freq: 0.171357
5d0 +   spill R10 -&gt; R18	# spill size = 64
5d4 +   j  B3	#@branch

5d8     B71: #	out( B136 B72 ) &lt;- in( B64 )  Freq: 0.0248978
5d8 +   spill R7 -&gt; R11	# spill size = 64
5dc     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:288 (line 661) L[0]=sp + #32 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=sp + #28 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {[32]=Oop off=1504/0x5e0}

5e0     B72: #	out( B65 ) &lt;- in( B71 )  Freq: 0.0248973
        # Block is sole successor of call
5e0 +   j  B65	#@branch

5e4     B73: #	out( B135 B74 ) &lt;- in( B65 )  Freq: 0.00743365
5e4 +   spill [sp, #32] -&gt; R11	# spill size = 64
5e8 +   spill [sp, #28] -&gt; R12	# spill size = 32
5ec     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.HashMap::afterNodeInsertion
        # java.util.HashMap::putVal @ bci:295 (line 662) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {off=1544/0x608}

608     B74: #	out( B66 ) &lt;- in( B73 )  Freq: 0.0074335
        # Block is sole successor of call
608 +   j  B66	#@branch

60c     B75: #	out( B134 B76 ) &lt;- in( B55 )  Freq: 0.00686125
60c +   spill [sp, #32] -&gt; R8	# spill size = 64
610 +   spill R21 -&gt; [sp, #16]	# spill size = 64
614 +   spill R10 -&gt; [sp, #8]	# spill size = 32
618 +   spill R18 -&gt; [sp, #0]	# spill size = 64
61c +   spill R8 -&gt; R11	# spill size = 64
620 +   spill R9 -&gt; R12	# spill size = 32
624 +   spill R30 -&gt; R13	# spill size = 64
628 +   spill R20 -&gt; R14	# spill size = 64
62c     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.HashMap::newNode
        # java.util.HashMap::putVal @ bci:56 (line 629) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=sp + #28 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #0 STK[1]=sp + #8
        # OopMap {fp=Oop [0]=Oop [16]=Derived_oop_[0] [32]=Oop off=1608/0x648}

648     B76: #	out( B59 ) &lt;- in( B75 )  Freq: 0.00686111
        # Block is sole successor of call
648 +   spill R10 -&gt; R7	# spill size = 64
64c +   spill [sp, #0] -&gt; R18	# spill size = 64
650 +   spill [sp, #8] -&gt; R10	# spill size = 32
654 +   spill [sp, #16] -&gt; R21	# spill size = 64
658 +   spill R7 -&gt; R22	# spill size = 64
65c +   j  B59	#@branch

660     B77: #	out( B133 B78 ) &lt;- in( B28 )  Freq: 0.000572023
660 +   spill [sp, #32] -&gt; R8	# spill size = 64
664 +   spill R21 -&gt; [sp, #4]	# spill size = 32
668 +   spill R22 -&gt; [sp, #40]	# spill size = 64
66c +   spill R18 -&gt; [sp, #16]	# spill size = 64
670 +   spill R20 -&gt; [sp, #8]	# spill size = 64
674 +   spill R9 -&gt; [sp, #0]	# spill size = 32
678 +   spill R8 -&gt; R11	# spill size = 64
67c +   spill R9 -&gt; R12	# spill size = 32
680 +   spill R30 -&gt; R13	# spill size = 64
684 +   spill R20 -&gt; R14	# spill size = 64
688     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.HashMap::newNode
        # java.util.HashMap::putVal @ bci:152 (line 640) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=sp + #8 L[4]=sp + #24 L[5]=sp + #28 L[6]=sp + #16 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=sp + #4 STK[0]=sp + #40
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop off=1700/0x6a4}

6a4     B78: #	out( B32 ) &lt;- in( B77 )  Freq: 0.000572011
        # Block is sole successor of call
6a4 +   spill [sp, #0] -&gt; R9	# spill size = 32
6a8 +   spill [sp, #8] -&gt; R20	# spill size = 64
6ac +   spill [sp, #16] -&gt; R18	# spill size = 64
6b0 +   spill [sp, #40] -&gt; R22	# spill size = 64
6b4 +   spill [sp, #4] -&gt; R21	# spill size = 32
6b8 +   spill R10 -&gt; R25	# spill size = 64
6bc +   j  B32	#@branch

6c0     B79: #	out( B61 B80 ) &lt;- in( B60 )  Freq: 0.000519161
6c0 +   lwu  R7, [R21]	# loadN, compressed ptr, #@loadN
6c4 +   decode_heap_oop  R10, R7	#@decodeHeapOop
6c8 +   beq   R10, zr, B61	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

6cc     B80: #	out( B108 B81 ) &lt;- in( B79 )  Freq: 0.000259581
6cc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6cc     ld  R7, [R23, #32]	# int, #@loadL
6d0 +   beq  R7, zr, B108	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

6d4     B81: #	out( B61 ) &lt;- in( B80 )  Freq: 0.000259321
6d4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6d4     ld  R28, [R23, #48]	# ptr, #@loadP
6d8 +   add R28, R28, R7	# ptr, #@addP_reg_reg
6dc +   addi  R7, R7, #-8	#@addL_reg_imm
6e0 +   sd  R10, [R28, #-8]	# ptr, #@storeP
6e4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6e4     sd  R7, [R23, #32]	# long, #@storeL
6e8 +   j  B61	#@branch

6ec     B82: #	out( B64 B83 ) &lt;- in( B63 )  Freq: 0.00051813
6ec +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6ec     ld  R7, [R23, #64]	# int, #@loadL
6f0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6f0     ld  R28, [R23, #80]	# ptr, #@loadP
6f4 +   #@membar_volatile
	fence iorw iorw
6f8 +   lb  R29, [R10]	# byte, #@loadB
6fc +   beq  R29, zr, B64	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

700     B83: #	out( B85 B84 ) &lt;- in( B82 )  Freq: 0.000259065
700 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
704 +   bne  R7, zr, B85	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

708     B84: #	out( B64 ) &lt;- in( B83 )  Freq: 0.000129533
708 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
708     spill R23 -&gt; R11	# spill size = 64
70c +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
73c +   j  B64	#@branch

740     B85: #	out( B64 ) &lt;- in( B83 )  Freq: 0.000129533
740 +   add R28, R28, R7	# ptr, #@addP_reg_reg
744 +   addi  R7, R7, #-8	#@addL_reg_imm
748 +   sd  R10, [R28, #-8]	# ptr, #@storeP
74c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
74c     sd  R7, [R23, #64]	# long, #@storeL
750 +   j  B64	#@branch

754     B86: #	out( B20 B87 ) &lt;- in( B19 )  Freq: 0.00035955
754 +   lwu  R28, [R22, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.value
758 +   decode_heap_oop  R10, R28	#@decodeHeapOop
75c +   beq   R10, zr, B20	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

760     B87: #	out( B114 B88 ) &lt;- in( B86 )  Freq: 0.000179775
760 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
760     ld  R7, [R23, #32]	# int, #@loadL
764 +   beq  R7, zr, B114	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

768     B88: #	out( B20 ) &lt;- in( B87 )  Freq: 0.000179595
768 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
768     ld  R28, [R23, #48]	# ptr, #@loadP
76c +   add R28, R28, R7	# ptr, #@addP_reg_reg
770 +   addi  R7, R7, #-8	#@addL_reg_imm
774 +   sd  R10, [R28, #-8]	# ptr, #@storeP
778 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
778     sd  R7, [R23, #32]	# long, #@storeL
77c +   j  B20	#@branch

780     B89: #	out( B23 B90 ) &lt;- in( B22 )  Freq: 0.000358836
780 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
780     ld  R7, [R23, #64]	# int, #@loadL
784 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
784     ld  R28, [R23, #80]	# ptr, #@loadP
788 +   #@membar_volatile
	fence iorw iorw
78c +   lb  R29, [R10]	# byte, #@loadB
790 +   beq  R29, zr, B23	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

794     B90: #	out( B92 B91 ) &lt;- in( B89 )  Freq: 0.000179418
794 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
798 +   bne  R7, zr, B92	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

79c     B91: #	out( B23 ) &lt;- in( B90 )  Freq: 8.9709e-05
79c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
79c     spill R23 -&gt; R11	# spill size = 64
7a0 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
7d0 +   j  B23	#@branch

7d4     B92: #	out( B23 ) &lt;- in( B90 )  Freq: 8.9709e-05
7d4 +   add R28, R28, R7	# ptr, #@addP_reg_reg
7d8 +   addi  R7, R7, #-8	#@addL_reg_imm
7dc +   sd  R10, [R28, #-8]	# ptr, #@storeP
7e0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7e0     sd  R7, [R23, #64]	# long, #@storeL
7e4 +   j  B23	#@branch

7e8     B93: #	out( B33 B94 ) &lt;- in( B32 )  Freq: 0.000121267
7e8 +   lwu  R28, [R22, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
7ec +   decode_heap_oop  R10, R28	#@decodeHeapOop
7f0 +   beq   R10, zr, B33	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

7f4     B94: #	out( B123 B95 ) &lt;- in( B93 )  Freq: 6.06335e-05
7f4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7f4     ld  R7, [R23, #32]	# int, #@loadL
7f8 +   beq  R7, zr, B123	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

7fc     B95: #	out( B33 ) &lt;- in( B94 )  Freq: 6.05728e-05
7fc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7fc     ld  R28, [R23, #48]	# ptr, #@loadP
800 +   add R28, R28, R7	# ptr, #@addP_reg_reg
804 +   addi  R7, R7, #-8	#@addL_reg_imm
808 +   sd  R10, [R28, #-8]	# ptr, #@storeP
80c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
80c     sd  R7, [R23, #32]	# long, #@storeL
810 +   j  B33	#@branch

814     B96: #	out( B36 B97 ) &lt;- in( B35 )  Freq: 0.000121026
814 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
814     ld  R7, [R23, #64]	# int, #@loadL
818 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
818     ld  R28, [R23, #80]	# ptr, #@loadP
81c +   #@membar_volatile
	fence iorw iorw
820 +   lb  R30, [R10]	# byte, #@loadB
824 +   beq  R30, zr, B36	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

828     B97: #	out( B99 B98 ) &lt;- in( B96 )  Freq: 6.05131e-05
828 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
82c +   bne  R7, zr, B99	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

830     B98: #	out( B36 ) &lt;- in( B97 )  Freq: 3.02565e-05
830 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
830     spill R23 -&gt; R11	# spill size = 64
834 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
864 +   j  B36	#@branch

868     B99: #	out( B36 ) &lt;- in( B97 )  Freq: 3.02565e-05
868 +   add R28, R28, R7	# ptr, #@addP_reg_reg
86c +   addi  R7, R7, #-8	#@addL_reg_imm
870 +   sd  R10, [R28, #-8]	# ptr, #@storeP
874 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
874     sd  R7, [R23, #64]	# long, #@storeL
878 +   j  B36	#@branch

87c     B100: #	out( B132 B101 ) &lt;- in( B56 )  Freq: 5.12393e-05
87c +   spill [sp, #32] -&gt; [sp, #16]	# spill size = 64
884 +   spill [sp, #16] -&gt; R8	# spill size = 64
888 +   spill R19 -&gt; [sp, #64]	# spill size = 32
88c +   spill R31 -&gt; [sp, #52]	# spill size = 32
890 +   spill R21 -&gt; [sp, #56]	# spill size = 64
894 +   spill R10 -&gt; [sp, #48]	# spill size = 32
898 +   spill R18 -&gt; [sp, #40]	# spill size = 64
89c +   spill R9 -&gt; [sp, #24]	# spill size = 32
8a0 +   # checkcastPP of R8, #@checkCastPP
8a0     mv  R11, precise klass java/util/HashMap$Node: 0x00000040d014dd30:Constant:exact *	# ptr, #@loadConP
8b8     spill R30 -&gt; [sp, #0]	# spill size = 64
8bc +   spill R20 -&gt; [sp, #8]	# spill size = 64
8c0     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #24 L[2]=sp + #0 L[3]=sp + #8 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:56 (line 629) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=sp + #28 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #40 STK[1]=sp + #48
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [52]=NarrowOop [56]=Derived_oop_[40] [64]=NarrowOop off=2244/0x8c4}

8c4     B101: #	out( B58 ) &lt;- in( B100 )  Freq: 5.12382e-05
        # Block is sole successor of call
8c4 +   spill R10 -&gt; R7	# spill size = 64
8c8 +   spill [sp, #24] -&gt; R9	# spill size = 32
8cc +   spill [sp, #40] -&gt; R18	# spill size = 64
8d0 +   spill [sp, #48] -&gt; R10	# spill size = 32
8d4 +   spill [sp, #56] -&gt; R21	# spill size = 64
8d8 +   spill [sp, #52] -&gt; R31	# spill size = 32
8dc +   spill [sp, #64] -&gt; R19	# spill size = 32
8e0 +   spill R7 -&gt; R22	# spill size = 64
8e4 +   j  B58	#@branch

8e8     B102: #	out( B131 B103 ) &lt;- in( B29 )  Freq: 1.20717e-05
8e8 +   spill [sp, #32] -&gt; R8	# spill size = 64
8ec +   spill R21 -&gt; [sp, #60]	# spill size = 32
8f0 +   spill R22 -&gt; [sp, #64]	# spill size = 64
8f4 +   spill R19 -&gt; [sp, #56]	# spill size = 32
8f8 +   spill R31 -&gt; [sp, #20]	# spill size = 32
8fc +   spill R18 -&gt; [sp, #48]	# spill size = 64
900 +   spill R20 -&gt; [sp, #40]	# spill size = 64
904 +   spill R9 -&gt; [sp, #16]	# spill size = 32
908 +   # checkcastPP of R8, #@checkCastPP
908     mv  R11, precise klass java/util/HashMap$Node: 0x00000040d014dd30:Constant:exact *	# ptr, #@loadConP
920     spill R30 -&gt; [sp, #0]	# spill size = 64
924     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #16 L[2]=sp + #0 L[3]=sp + #40 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:152 (line 640) L[0]=R8 L[1]=sp + #16 L[2]=_ L[3]=sp + #40 L[4]=sp + #24 L[5]=sp + #28 L[6]=sp + #48 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=sp + #60 STK[0]=sp + #64
        # OopMap {fp=Oop [0]=Oop [20]=NarrowOop [32]=Oop [40]=Oop [48]=Oop [56]=NarrowOop [64]=Oop off=2344/0x928}

928     B103: #	out( B31 ) &lt;- in( B102 )  Freq: 1.20714e-05
        # Block is sole successor of call
928 +   spill [sp, #16] -&gt; R9	# spill size = 32
92c +   spill [sp, #40] -&gt; R20	# spill size = 64
930 +   spill [sp, #48] -&gt; R18	# spill size = 64
934 +   spill [sp, #20] -&gt; R31	# spill size = 32
938 +   spill [sp, #56] -&gt; R19	# spill size = 32
93c +   spill [sp, #64] -&gt; R22	# spill size = 64
940 +   spill [sp, #60] -&gt; R21	# spill size = 32
944 +   spill R10 -&gt; R25	# spill size = 64
948 +   j  B31	#@branch

94c     B104: #	out( N1567 ) &lt;- in( B3 )  Freq: 9.99996e-07
94c +   spill [sp, #24] -&gt; R28	# spill size = 32
950 +   spill [sp, #28] -&gt; R7	# spill size = 32
954 +   li R11, #-28	# int, #@loadConI
958     spill [sp, #32] -&gt; R8	# spill size = 64
95c +   spill R28 -&gt; [sp, #4]	# spill size = 32
960 +   spill R7 -&gt; [sp, #24]	# spill size = 32
964 +   spill R18 -&gt; [sp, #40]	# spill size = 64
968 +   spill R10 -&gt; [sp, #48]	# spill size = 32
96c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.HashMap::putVal @ bci:40 (line 628) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #40 L[7]=_ L[8]=_ L[9]=sp + #48 L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #40 STK[1]=sp + #48
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop off=2416/0x970}
970     #@ShouldNotReachHere

97c     B105: #	out( N1567 ) &lt;- in( B59 )  Freq: 5.19169e-07
97c +   li R11, #-42	# int, #@loadConI
980     spill [sp, #32] -&gt; R8	# spill size = 64
984 +   spill R18 -&gt; [sp, #8]	# spill size = 64
988 +   spill R10 -&gt; [sp, #4]	# spill size = 32
98c +   spill R22 -&gt; [sp, #16]	# spill size = 64
990     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;array_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:59 (line 629) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=sp + #28 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #8 STK[1]=sp + #4 STK[2]=sp + #16
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=2452/0x994}
994     #@ShouldNotReachHere

9a0     B106: #	out( N1567 ) &lt;- in( B2 )  Freq: 3.95126e-07
9a0 +   spill [sp, #32] -&gt; R8	# spill size = 64
9a4 +   li R11, #-187	# int, #@loadConI
9a8     spill R15 -&gt; [sp, #4]	# spill size = 32
9ac +   spill R16 -&gt; [sp, #24]	# spill size = 32
9b0 +   spill R18 -&gt; [sp, #32]	# spill size = 64
9b4 +   spill R7 -&gt; [sp, #40]	# spill size = 32
9b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:16 (line 626) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=sp + #40 L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #40
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop off=2492/0x9bc}
9bc     #@ShouldNotReachHere

9c8     B107: #	out( N1567 ) &lt;- in( B25 )  Freq: 2.72698e-07
9c8 +   spill [sp, #24] -&gt; R7	# spill size = 32
9cc +   spill [sp, #32] -&gt; R8	# spill size = 64
9d0 +   li R11, #-187	# int, #@loadConI
9d4     spill R7 -&gt; [sp, #4]	# spill size = 32
9d8 +   spill R18 -&gt; [sp, #32]	# spill size = 64
9dc +   spill R16 -&gt; [sp, #40]	# spill size = 64
9e0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:109 (line 635) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#1
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop off=2532/0x9e4}
9e4     #@ShouldNotReachHere

9f0     B108: #	out( B61 ) &lt;- in( B80 )  Freq: 2.59577e-07
9f0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
9f0     spill R23 -&gt; R11	# spill size = 64
9f4 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
a24 +   j  B61	#@branch

a28     B109: #	out( N1567 ) &lt;- in( B8 )  Freq: 2.11701e-07
a28 +   spill [sp, #24] -&gt; R28	# spill size = 32
a2c +   spill [sp, #32] -&gt; R8	# spill size = 64
a30 +   li R11, #-34	# int, #@loadConI
a34     spill R28 -&gt; [sp, #4]	# spill size = 32
a38 +   spill R18 -&gt; [sp, #32]	# spill size = 64
a3c +   spill R16 -&gt; [sp, #40]	# spill size = 64
a40 +   spill R29 -&gt; [sp, #56]	# spill size = 64
a44     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #8 STK[1]=sp + #56
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop [56]=Oop off=2632/0xa48}
a48     #@ShouldNotReachHere

a54     B110: #	out( N1567 ) &lt;- in( B13 )  Freq: 2.00608e-07
a54     #@ShouldNotReachHere

a60     B111: #	out( N1567 ) &lt;- in( B14 )  Freq: 2.00608e-07
a60     #@ShouldNotReachHere

a6c     B112: #	out( B113 ) &lt;- in( B16 )  Freq: 9.44034e-08
a6c +   spill R10 -&gt; R12	# spill size = 32

a70     B113: #	out( N1567 ) &lt;- in( B112 B15 )  Freq: 2.92382e-07
a70 +   spill [sp, #24] -&gt; R7	# spill size = 32
a74 +   spill [sp, #28] -&gt; R28	# spill size = 32
a78 +   spill [sp, #32] -&gt; R8	# spill size = 64
a7c +   li R11, #-187	# int, #@loadConI
a80     spill R30 -&gt; [sp, #8]	# spill size = 64
a84 +   spill R7 -&gt; [sp, #4]	# spill size = 32
a88 +   spill R28 -&gt; [sp, #24]	# spill size = 32
a8c +   spill R18 -&gt; [sp, #32]	# spill size = 64
a90 +   spill R16 -&gt; [sp, #40]	# spill size = 64
a94 +   spill R12 -&gt; [sp, #28]	# spill size = 32
a98     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:94 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #28
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop off=2716/0xa9c}
a9c     #@ShouldNotReachHere

aa8     B114: #	out( B20 ) &lt;- in( B87 )  Freq: 1.79773e-07
aa8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
aa8     spill R23 -&gt; R11	# spill size = 64
aac +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
adc +   j  B20	#@branch

ae0     B115: #	out( N1567 ) &lt;- in( B18 )  Freq: 1.71449e-07
ae0 +   li R11, #-187	# int, #@loadConI
ae4     spill [sp, #32] -&gt; R8	# spill size = 64
ae8 +   spill R20 -&gt; [sp, #0]	# spill size = 64
aec +   spill R22 -&gt; [sp, #8]	# spill size = 64
af0 +   spill R18 -&gt; [sp, #16]	# spill size = 64
af4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:236 (line 653) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #8 L[11]=_ L[12]=sp + #16 STK[0]=sp + #24
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=2808/0xaf8}
af8     #@ShouldNotReachHere

b04     B116: #	out( N1567 ) &lt;- in( B44 )  Freq: 1.47856e-07
b04 +   spill [sp, #24] -&gt; R28	# spill size = 32
b08 +   spill [sp, #28] -&gt; R7	# spill size = 32
b0c +   spill [sp, #32] -&gt; R8	# spill size = 64
b10 +   li R11, #-34	# int, #@loadConI
b14     spill R9 -&gt; [sp, #0]	# spill size = 32
b18 +   spill R20 -&gt; [sp, #16]	# spill size = 64
b1c +   spill R28 -&gt; [sp, #4]	# spill size = 32
b20 +   spill R7 -&gt; [sp, #24]	# spill size = 32
b24 +   spill R18 -&gt; [sp, #32]	# spill size = 64
b28 +   spill R22 -&gt; [sp, #40]	# spill size = 64
b2c +   spill R21 -&gt; [sp, #28]	# spill size = 32
b30 +   spill R30 -&gt; [sp, #48]	# spill size = 64
b34 +   spill R31 -&gt; [sp, #56]	# spill size = 64
b38     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=_ L[12]=sp + #28 STK[0]=sp + #48 STK[1]=sp + #56
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=2876/0xb3c}
b3c     #@ShouldNotReachHere

b48     B117: #	out( N1567 ) &lt;- in( B49 )  Freq: 1.40108e-07
b48     #@ShouldNotReachHere

b54     B118: #	out( N1567 ) &lt;- in( B50 )  Freq: 1.40108e-07
b54     #@ShouldNotReachHere

b60     B119: #	out( N1567 ) &lt;- in( B6 )  Freq: 1.00947e-07
b60 +   spill [sp, #24] -&gt; R28	# spill size = 32
b64 +   spill [sp, #32] -&gt; R8	# spill size = 64
b68 +   li R11, #-187	# int, #@loadConI
b6c     spill R28 -&gt; [sp, #4]	# spill size = 32
b70 +   spill R18 -&gt; [sp, #32]	# spill size = 64
b74 +   spill R16 -&gt; [sp, #40]	# spill size = 64
b78 +   spill R29 -&gt; [sp, #56]	# spill size = 64
b7c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:81 (line 632) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=sp + #56 L[12]=_ STK[0]=sp + #56 STK[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop [56]=Oop off=2944/0xb80}
b80     #@ShouldNotReachHere

b8c     B120: #	out( N1567 ) &lt;- in( B12 )  Freq: 9.89895e-08
b8c +   spill [sp, #24] -&gt; R31	# spill size = 32
b90 +   spill [sp, #28] -&gt; R10	# spill size = 32
b94 +   spill [sp, #32] -&gt; R8	# spill size = 64
b98 +   li R11, #-187	# int, #@loadConI
b9c     spill R31 -&gt; [sp, #4]	# spill size = 32
ba0 +   spill R10 -&gt; [sp, #24]	# spill size = 32
ba4 +   spill R18 -&gt; [sp, #32]	# spill size = 64
ba8 +   spill R16 -&gt; [sp, #40]	# spill size = 64
bac +   spill R30 -&gt; [sp, #48]	# spill size = 64
bb0 +   spill R29 -&gt; [sp, #56]	# spill size = 64
bb4 +   spill R28 -&gt; [sp, #28]	# spill size = 32
bb8 +   spill R7 -&gt; [sp, #64]	# spill size = 32
bbc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #48 L[1]=_ L[2]=sp + #56 STK[0]=sp + #28 STK[1]=sp + #64
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=3008/0xbc0}
bc0     #@ShouldNotReachHere

bcc     B121: #	out( N1567 ) &lt;- in( B42 )  Freq: 7.05031e-08
bcc +   spill [sp, #24] -&gt; R28	# spill size = 32
bd0 +   spill [sp, #28] -&gt; R7	# spill size = 32
bd4 +   spill [sp, #32] -&gt; R8	# spill size = 64
bd8 +   li R11, #-187	# int, #@loadConI
bdc     spill R9 -&gt; [sp, #0]	# spill size = 32
be0 +   spill R20 -&gt; [sp, #16]	# spill size = 64
be4 +   spill R28 -&gt; [sp, #4]	# spill size = 32
be8 +   spill R7 -&gt; [sp, #24]	# spill size = 32
bec +   spill R18 -&gt; [sp, #32]	# spill size = 64
bf0 +   spill R22 -&gt; [sp, #40]	# spill size = 64
bf4 +   spill R21 -&gt; [sp, #28]	# spill size = 32
bf8 +   spill R30 -&gt; [sp, #48]	# spill size = 64
bfc +   spill R31 -&gt; [sp, #64]	# spill size = 64
c00     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:193 (line 645) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=sp + #64 L[12]=sp + #28 STK[0]=sp + #64 STK[1]=sp + #48
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [64]=Oop off=3076/0xc04}
c04     #@ShouldNotReachHere

c10     B122: #	out( N1567 ) &lt;- in( B48 )  Freq: 6.91358e-08
c10 +   spill [sp, #24] -&gt; R7	# spill size = 32
c14 +   spill [sp, #28] -&gt; R29	# spill size = 32
c18 +   spill [sp, #32] -&gt; [sp, #0]	# spill size = 64
c20 +   li R11, #-187	# int, #@loadConI
c24     spill R9 -&gt; [sp, #8]	# spill size = 32
c28 +   spill R20 -&gt; [sp, #16]	# spill size = 64
c2c +   spill R7 -&gt; [sp, #12]	# spill size = 32
c30 +   spill R29 -&gt; [sp, #24]	# spill size = 32
c34 +   spill R18 -&gt; [sp, #32]	# spill size = 64
c38 +   spill R22 -&gt; [sp, #40]	# spill size = 64
c3c +   spill R21 -&gt; [sp, #28]	# spill size = 32
c40 +   spill R15 -&gt; [sp, #56]	# spill size = 64
c44 +   spill R31 -&gt; [sp, #64]	# spill size = 64
c48 +   spill R28 -&gt; [sp, #72]	# spill size = 32
c4c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #56 L[1]=_ L[2]=sp + #64 STK[0]=sp + #72 STK[1]=R8
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #56 L[3]=sp + #16 L[4]=sp + #12 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=_ L[12]=sp + #28
        # OopMap {[0]=Oop [16]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=3152/0xc50}
c50     #@ShouldNotReachHere

c5c     B123: #	out( B33 ) &lt;- in( B94 )  Freq: 6.06327e-08
c5c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
c5c     spill R23 -&gt; R11	# spill size = 64
c60 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
c90 +   j  B33	#@branch

c94     B124: #	out( N1567 ) &lt;- in( B47 )  Freq: 1e-35
c94 +   spill [sp, #24] -&gt; R7	# spill size = 32
c98 +   spill [sp, #28] -&gt; R28	# spill size = 32
c9c +   spill [sp, #32] -&gt; R8	# spill size = 64
ca0 +   li R11, #-34	# int, #@loadConI
ca4     spill R9 -&gt; [sp, #0]	# spill size = 32
ca8 +   spill R20 -&gt; [sp, #8]	# spill size = 64
cac +   spill R7 -&gt; [sp, #4]	# spill size = 32
cb0 +   spill R28 -&gt; [sp, #16]	# spill size = 32
cb4 +   spill R18 -&gt; [sp, #24]	# spill size = 64
cb8 +   spill R22 -&gt; [sp, #32]	# spill size = 64
cbc +   spill R21 -&gt; [sp, #20]	# spill size = 32
cc0 +   spill R15 -&gt; [sp, #48]	# spill size = 64
cc4 +   spill R31 -&gt; [sp, #64]	# spill size = 64
cc8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=sp + #64 L[2]=_ STK[0]=sp + #64
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #8 L[4]=sp + #4 L[5]=sp + #16 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #32 L[11]=_ L[12]=sp + #20
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [64]=Oop off=3276/0xccc}
ccc     #@ShouldNotReachHere

cd8     B125: #	out( N1567 ) &lt;- in( B11 )  Freq: 1e-35
cd8 +   spill [sp, #24] -&gt; R7	# spill size = 32
cdc +   spill [sp, #32] -&gt; R8	# spill size = 64
ce0 +   li R11, #-34	# int, #@loadConI
ce4     spill R7 -&gt; [sp, #4]	# spill size = 32
ce8 +   spill R18 -&gt; [sp, #32]	# spill size = 64
cec +   spill R16 -&gt; [sp, #40]	# spill size = 64
cf0 +   spill R30 -&gt; [sp, #48]	# spill size = 64
cf4 +   spill R29 -&gt; [sp, #64]	# spill size = 64
cf8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=sp + #64 L[2]=_ STK[0]=sp + #64
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [64]=Oop off=3324/0xcfc}
cfc     #@ShouldNotReachHere

d08     B126: #	out( N1567 ) &lt;- in( B10 )  Freq: 2.00608e-07
d08 +   spill [sp, #24] -&gt; R28	# spill size = 32
d0c +   spill [sp, #32] -&gt; R8	# spill size = 64
d10 +   li R11, #-12	# int, #@loadConI
d14     spill R28 -&gt; [sp, #4]	# spill size = 32
d18 +   spill R18 -&gt; [sp, #32]	# spill size = 64
d1c +   spill R16 -&gt; [sp, #40]	# spill size = 64
d20 +   spill R30 -&gt; [sp, #48]	# spill size = 64
d24     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop off=3368/0xd28}
d28     #@ShouldNotReachHere

d34     B127: #	out( N1567 ) &lt;- in( B69 )  Freq: 1.73633e-07
d34 +   li R11, #-10	# int, #@loadConI
d38     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:26 (line 627) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#NULL
        # OopMap {off=3388/0xd3c}
d3c     #@ShouldNotReachHere

d48     B128: #	out( N1567 ) &lt;- in( B46 )  Freq: 1.40108e-07
d48 +   spill [sp, #24] -&gt; R28	# spill size = 32
d4c +   spill [sp, #28] -&gt; R7	# spill size = 32
d50 +   spill [sp, #32] -&gt; R8	# spill size = 64
d54 +   li R11, #-12	# int, #@loadConI
d58     spill R9 -&gt; [sp, #0]	# spill size = 32
d5c +   spill R20 -&gt; [sp, #8]	# spill size = 64
d60 +   spill R28 -&gt; [sp, #4]	# spill size = 32
d64 +   spill R7 -&gt; [sp, #16]	# spill size = 32
d68 +   spill R18 -&gt; [sp, #24]	# spill size = 64
d6c +   spill R22 -&gt; [sp, #32]	# spill size = 64
d70 +   spill R21 -&gt; [sp, #20]	# spill size = 32
d74 +   spill R15 -&gt; [sp, #48]	# spill size = 64
d78     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #8 L[4]=sp + #4 L[5]=sp + #16 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #32 L[11]=_ L[12]=sp + #20
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop off=3452/0xd7c}
d7c     #@ShouldNotReachHere

d88     B129: #	out( N1567 ) &lt;- in( B7 )  Freq: 1.00947e-07
d88 +   spill [sp, #24] -&gt; R28	# spill size = 32
d8c +   spill [sp, #32] -&gt; R8	# spill size = 64
d90 +   li R11, #-187	# int, #@loadConI
d94     spill R28 -&gt; [sp, #4]	# spill size = 32
d98 +   spill R18 -&gt; [sp, #32]	# spill size = 64
d9c +   spill R16 -&gt; [sp, #40]	# spill size = 64
da0 +   spill R29 -&gt; [sp, #48]	# spill size = 64
da4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:85 (line 632) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=sp + #48 L[12]=_ STK[0]=sp + #8
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop off=3496/0xda8}
da8     #@ShouldNotReachHere

db4     B130: #	out( N1567 ) &lt;- in( B43 )  Freq: 7.05031e-08
db4 +   spill [sp, #24] -&gt; R28	# spill size = 32
db8 +   spill [sp, #28] -&gt; R7	# spill size = 32
dbc +   spill [sp, #32] -&gt; R8	# spill size = 64
dc0 +   li R11, #-187	# int, #@loadConI
dc4     spill R9 -&gt; [sp, #0]	# spill size = 32
dc8 +   spill R20 -&gt; [sp, #16]	# spill size = 64
dcc +   spill R28 -&gt; [sp, #4]	# spill size = 32
dd0 +   spill R7 -&gt; [sp, #24]	# spill size = 32
dd4 +   spill R18 -&gt; [sp, #32]	# spill size = 64
dd8 +   spill R22 -&gt; [sp, #40]	# spill size = 64
ddc +   spill R21 -&gt; [sp, #28]	# spill size = 32
de0 +   spill R30 -&gt; [sp, #48]	# spill size = 64
de4 +   spill R31 -&gt; [sp, #56]	# spill size = 64
de8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:197 (line 645) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=sp + #56 L[12]=sp + #28 STK[0]=sp + #48
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=3564/0xdec}
dec     #@ShouldNotReachHere

df8     B131: #	out( B138 ) &lt;- in( B102 )  Freq: 1.20717e-10
df8      -- 	// exception oop; no code emitted, #@CreateException
df8 +   spill R10 -&gt; R11	# spill size = 64
dfc +   j  B138	#@branch

e00     B132: #	out( B138 ) &lt;- in( B100 )  Freq: 5.12393e-10
e00      -- 	// exception oop; no code emitted, #@CreateException
e00 +   spill R10 -&gt; R11	# spill size = 64
e04 +   j  B138	#@branch

e08     B133: #	out( B138 ) &lt;- in( B77 )  Freq: 5.72023e-09
e08      -- 	// exception oop; no code emitted, #@CreateException
e08 +   spill R10 -&gt; R11	# spill size = 64
e0c +   j  B138	#@branch

e10     B134: #	out( B138 ) &lt;- in( B75 )  Freq: 6.86125e-08
e10      -- 	// exception oop; no code emitted, #@CreateException
e10 +   spill R10 -&gt; R11	# spill size = 64
e14 +   j  B138	#@branch

e18     B135: #	out( B138 ) &lt;- in( B73 )  Freq: 7.43365e-08
e18      -- 	// exception oop; no code emitted, #@CreateException
e18 +   spill R10 -&gt; R11	# spill size = 64
e1c +   j  B138	#@branch

e20     B136: #	out( B138 ) &lt;- in( B71 )  Freq: 2.48978e-07
e20      -- 	// exception oop; no code emitted, #@CreateException
e20 +   spill R10 -&gt; R11	# spill size = 64
e24 +   j  B138	#@branch

e28     B137: #	out( B138 ) &lt;- in( B68 )  Freq: 1.71361e-06
e28      -- 	// exception oop; no code emitted, #@CreateException
e28 +   spill R10 -&gt; R11	# spill size = 64

e2c     B138: #	out( N1567 ) &lt;- in( B137 B134 B132 B133 B131 B136 B135 )  Freq: 2.11189e-06
e2c     # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
e38 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='599'>
----------------------- MetaData before Compile_id = 599 ------------------------
{method}
 - this oop:          0x00000040963b8c98
 - method holder:     &apos;java/util/ImmutableCollections$SetN$SetNIterator&apos;
 - constants:         0x00000040963b8858 constant pool [70] {0x00000040963b8858} for &apos;java/util/ImmutableCollections$SetN$SetNIterator&apos; cache=0x00000040963b8e80
 - access:            0x81000001  public 
 - name:              &apos;hasNext&apos;
 - signature:         &apos;()Z&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c5e7300
 - code size:         13
 - code start:        0x00000040963b8c78
 - code end (excl):   0x00000040963b8c85
 - method data:       0x00000040964eea88
 - checked ex length: 0
 - linenumber start:  0x00000040963b8c85
 - localvar length:   1
 - localvar start:    0x00000040963b8c8a
 - compiled code: nmethod  23548  558       3       java.util.ImmutableCollections$SetN$SetNIterator::hasNext (13 bytes)

------------------------ OptoAssembly for Compile_id = 599 -----------------------
#
#  bool ( java/util/ImmutableCollections$SetN$SetNIterator:NotNull:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/ImmutableCollections$SetN$SetNIterator:NotNull:exact *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N26: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B4 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     lw  R28, [R11, #12]	# int, #@loadI ! Field: java/util/ImmutableCollections$SetN$SetNIterator.remaining
040 +   ble  R28, zr, B4	#@cmpI_reg_imm0_branch  P=0.038698 C=5375.000000

044     B2: #	out( B3 ) &lt;- in( B1 )  Freq: 0.961302
044 +   li R10, #1	# int, #@loadConI

048     B3: #	out( N26 ) &lt;- in( B4 B2 )  Freq: 1
048     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
060 +   ret	// return register, #@Ret

064     B4: #	out( B3 ) &lt;- in( B1 )  Freq: 0.0386977
064 +   li R10, #0	# int, #@loadConI
068 +   j  B3	#@branch

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='600'>
----------------------- MetaData before Compile_id = 600 ------------------------
{method}
 - this oop:          0x00000040963b8dd0
 - method holder:     &apos;java/util/ImmutableCollections$SetN$SetNIterator&apos;
 - constants:         0x00000040963b8858 constant pool [70] {0x00000040963b8858} for &apos;java/util/ImmutableCollections$SetN$SetNIterator&apos; cache=0x00000040963b8e80
 - access:            0xc1000001  public 
 - name:              &apos;next&apos;
 - signature:         &apos;()Ljava/lang/Object;&apos;
 - max stack:         4
 - max locals:        4
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c5d25c0
 - code size:         90
 - code start:        0x00000040963b8d30
 - code end (excl):   0x00000040963b8d8a
 - method data:       0x00000040964dd4e8
 - checked ex length: 0
 - linenumber start:  0x00000040963b8d8a
 - localvar length:   4
 - localvar start:    0x00000040963b8d9c
 - compiled code: nmethod  23575  525       3       java.util.ImmutableCollections$SetN$SetNIterator::next (90 bytes)

------------------------ OptoAssembly for Compile_id = 600 -----------------------
#
#  java/lang/Object * ( java/util/ImmutableCollections$SetN$SetNIterator:NotNull:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/ImmutableCollections$SetN$SetNIterator:NotNull:exact *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N112: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B11 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lwu  R28, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$SetN$SetNIterator.this$0
040 +   lw  R13, [R11, #12]	# int, #@loadI ! Field: java/util/ImmutableCollections$SetN$SetNIterator.remaining
044 +   decode_heap_oop  R7, R28	#@decodeHeapOop
048     spill R11 -&gt; R31	# spill size = 64
04c +   ble  R13, zr, B11	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

050     B2: #	out( B12 B3 ) &lt;- in( B1 )  Freq: 1
050     lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$SetN.elements (constant)
054     NullCheck R7

054     B3: #	out( B13 B4 ) &lt;- in( B2 )  Freq: 0.999999
054 +   decode_heap_oop  R8, R7	#@decodeHeapOop
058     lwu  R7, [R8, #12]	# range, #@loadRange
05c     NullCheck R8

05c     B4: #	out( B5 ) &lt;- in( B3 )  Freq: 0.999997
05c +   lw  R29, [R11, #16]	# int, #@loadI ! Field: java/util/ImmutableCollections$SetN$SetNIterator.idx
060 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP

060     B5: #	out( B9 B6 ) &lt;- in( B4 B7 ) Loop( B5-B7 inner ) Freq: 1.97302
060     addiw  R29, R29, #-1	#@addI_reg_imm
064 +   blt  R29, zr, B9	#@cmpI_reg_imm0_branch  P=0.017256 C=10605.000000

068     B6: #	out( B10 B7 ) &lt;- in( B5 B9 )  Freq: 1.97302
068 +   bgeu  R29, R7, B10	#@cmpU_branch  P=0.000001 C=-1.000000

06c     B7: #	out( B5 B8 ) &lt;- in( B6 )  Freq: 1.97301
06c +   addw  R28, R29, zr	#@convI2L_reg_reg
070 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
074 +   add R28, R8, R28	# ptr, #@addP_reg_reg
078 +   lwu  R28, [R28, #16]	# loadN, compressed ptr, #@loadN
07c +   decode_heap_oop  R10, R28	#@decodeHeapOop
080 +   ld  R30, [R23, #920]	# ptr, #@loadP
084 +   lwu zr, [R30]	# Safepoint: poll for GC, #@safePoint        # java.util.ImmutableCollections$SetN$SetNIterator::next @ bci:62 (line 976) L[0]=R31 L[1]=R10 L[2]=R29 L[3]=R7 STK[0]=R10
        # OopMap {xmethod=Oop c_rarg0=Oop fp=Oop off=132/0x84}
088 +   beq   R10, zr, B5	#@cmpP_imm0_branch  P=0.493164 C=10605.000000

08c     B8: #	out( N112 ) &lt;- in( B7 )  Freq: 0.999995
08c +   addiw  R28, R13, #-1	#@addI_reg_imm
090 +   sw  R29, [R31, #16]	# int, #@storeI ! Field: java/util/ImmutableCollections$SetN$SetNIterator.idx
094 +   sw  R28, [R31, #12]	# int, #@storeI ! Field: java/util/ImmutableCollections$SetN$SetNIterator.remaining
098     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0b0 +   ret	// return register, #@Ret

0b4     B9: #	out( B6 ) &lt;- in( B5 )  Freq: 0.0340464
0b4 +   addiw  R29, R7, #-1	#@addI_reg_imm
0b8 +   j  B6	#@branch

0bc     B10: #	out( N112 ) &lt;- in( B6 )  Freq: 1.99922e-06
0bc +   li R11, #-28	# int, #@loadConI
0c0     spill R7 -&gt; [sp, #4]	# spill size = 32
0c4 +   spill R29 -&gt; [sp, #8]	# spill size = 32
0c8 +   spill R31 -&gt; [sp, #16]	# spill size = 64
0cc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ImmutableCollections$SetN$SetNIterator::next @ bci:59 (line 976) L[0]=sp + #16 L[1]=_ L[2]=sp + #8 L[3]=sp + #4 STK[0]=R8 STK[1]=sp + #8
        # OopMap {fp=Oop [16]=Oop off=208/0xd0}
0d0     #@ShouldNotReachHere

0dc     B11: #	out( N112 ) &lt;- in( B1 )  Freq: 5e-07
0dc +   li R11, #-187	# int, #@loadConI
0e0     spill R31 -&gt; R8	# spill size = 64
0e4 +   spill R13 -&gt; [sp, #0]	# spill size = 32
0e8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN$SetNIterator::next @ bci:4 (line 961) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #0
        # OopMap {fp=Oop off=236/0xec}
0ec     #@ShouldNotReachHere

0f8     B12: #	out( N112 ) &lt;- in( B2 )  Freq: 1.01328e-06
0f8 +   li R11, #-10	# int, #@loadConI
0fc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN$SetNIterator::next @ bci:16 (line 964) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # OopMap {off=256/0x100}
100     #@ShouldNotReachHere

10c     B13: #	out( N112 ) &lt;- in( B3 )  Freq: 1.01328e-06
10c +   li R11, #-10	# int, #@loadConI
110     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN$SetNIterator::next @ bci:19 (line 964) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # OopMap {off=276/0x114}
114     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='602'>
----------------------- MetaData before Compile_id = 602 ------------------------
{method}
 - this oop:          0x0000004096547f08
 - method holder:     &apos;java/lang/module/ModuleDescriptor$Exports&apos;
 - constants:         0x00000040965476a8 constant pool [132] {0x00000040965476a8} for &apos;java/lang/module/ModuleDescriptor$Exports&apos; cache=0x00000040965485c0
 - access:            0x81000001  public 
 - name:              &apos;isQualified&apos;
 - signature:         &apos;()Z&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c5f1f00
 - code size:         18
 - code start:        0x0000004096547ee0
 - code end (excl):   0x0000004096547ef2
 - method data:       0x0000004096443fd8
 - checked ex length: 0
 - linenumber start:  0x0000004096547ef2
 - localvar length:   1
 - localvar start:    0x0000004096547efa
 - compiled code: nmethod  23598  588       3       java.lang.module.ModuleDescriptor$Exports::isQualified (18 bytes)

------------------------ OptoAssembly for Compile_id = 602 -----------------------
#
#  bool ( java/lang/module/ModuleDescriptor$Exports:NotNull:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/module/ModuleDescriptor$Exports:NotNull:exact *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N57: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B8 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     lwu  R28, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/module/ModuleDescriptor$Exports.targets
040 +   decode_heap_oop  R7, R28	#@decodeHeapOop
044     lwu  R29, [R7, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
048     NullCheck R7

048     B2: #	out( B5 B3 ) &lt;- in( B1 )  Freq: 0.999999
048 +   mv  R28, narrowklass: precise klass java/util/ImmutableCollections$SetN: 0x00000040d07ba010:Constant:exact *	# compressed klass ptr, #@loadConNKlass
058 +   beq  R29, R28, B5	#@cmpN_branch  P=0.633718 C=-1.000000

05c     B3: #	out( B7 B4 ) &lt;- in( B2 )  Freq: 0.366282
05c +   mv  R30, narrowklass: precise klass java/util/ImmutableCollections$Set12: 0x00000040d07b9f40:Constant:exact *	# compressed klass ptr, #@loadConNKlass
06c +   bne  R29, R30, B7	#@cmpN_branch  P=0.000001 C=-1.000000

070     B4: #	out( B6 ) &lt;- in( B3 )  Freq: 0.366282
070 +   li R10, #1	# int, #@loadConI
074 +   j  B6	#@branch

078     B5: #	out( B6 ) &lt;- in( B2 )  Freq: 0.633717
078 +   # checkcastPP of R7, #@checkCastPP
078     lw  R28, [R7, #12]	# int, #@loadI ! Field: java/util/ImmutableCollections$SetN.size (constant)
07c +   snez  R10, R28	#@convI2Bool

080     B6: #	out( N57 ) &lt;- in( B5 B4 )  Freq: 0.999999
080     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
098 +   ret	// return register, #@Ret

09c     B7: #	out( N57 ) &lt;- in( B3 )  Freq: 3.66282e-07
09c +   li R11, #-58	# int, #@loadConI
0a0     spill R7 -&gt; R8	# spill size = 64
0a4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;bimorphic&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.module.ModuleDescriptor$Exports::isQualified @ bci:4 (line 426) L[0]=_ STK[0]=R8
        # OopMap {fp=Oop off=168/0xa8}
0a8     #@ShouldNotReachHere

0b4     B8: #	out( N57 ) &lt;- in( B1 )  Freq: 1.01328e-06
0b4 +   li R11, #-10	# int, #@loadConI
0b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.module.ModuleDescriptor$Exports::isQualified @ bci:4 (line 426) L[0]=_ STK[0]=#NULL
        # OopMap {off=188/0xbc}
0bc +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='604'>
----------------------- MetaData before Compile_id = 604 ------------------------
{method}
 - this oop:          0x0000004096164410
 - method holder:     &apos;java/util/ImmutableCollections$SetN&apos;
 - constants:         0x00000040961639e8 constant pool [168] {0x00000040961639e8} for &apos;java/util/ImmutableCollections$SetN&apos; cache=0x0000004096164c20
 - access:            0x81000001  public 
 - name:              &apos;contains&apos;
 - signature:         &apos;(Ljava/lang/Object;)Z&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      13
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bd00: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c4fb4c0
 - code size:         26
 - code start:        0x00000040961643d0
 - code end (excl):   0x00000040961643ea
 - method data:       0x0000004096482100
 - checked ex length: 0
 - linenumber start:  0x00000040961643ea
 - localvar length:   2
 - localvar start:    0x00000040961643f6
 - compiled code: nmethod  23943  155       3       java.util.ImmutableCollections$SetN::contains (26 bytes)

------------------------ OptoAssembly for Compile_id = 604 -----------------------
#
#  bool ( java/util/ImmutableCollections$SetN:NotNull:exact *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/ImmutableCollections$SetN:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 96 --
#r263 sp+92: in_preserve
#r262 sp+88: return address
#r261 sp+84: in_preserve
#r260 sp+80: saved fp register
#r259 sp+76: pad2, stack alignment
#r258 sp+72: pad2, stack alignment
#r257 sp+68: Fixed slot 1
#r256 sp+64: Fixed slot 0
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1895: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B171 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=96
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #96
	
03c     spill R11 -&gt; [sp, #0]	# spill size = 64
040 +   spill R12 -&gt; [sp, #48]	# spill size = 64
044     lwu  R29, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
048     NullCheck R12

048     B2: #	out( B52 B3 ) &lt;- in( B1 )  Freq: 1
048 +   lw  R7, [R11, #12]	# int, #@loadI ! Field: java/util/ImmutableCollections$SetN.size (constant)
04c +   ble  R7, zr, B52	#@cmpI_reg_imm0_branch  P=0.009503 C=9471.000000

050     B3: #	out( B66 B4 ) &lt;- in( B2 )  Freq: 0.990497
050 +   mv  R28, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
060 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
060     bne  R29, R28, B66	#@cmpN_branch  P=0.000451 C=-1.000000

064     B4: #	out( B23 B5 ) &lt;- in( B3 )  Freq: 0.99005
064 +   spill R12 -&gt; R10	# spill size = 64
068 +   # checkcastPP of R10, #@checkCastPP
068     lw  R30, [R10, #12]	# int, #@loadI ! Field: java/lang/String.hash
06c +   bne  R30, zr, B23	#@cmpI_reg_imm0_branch  P=0.474144 C=5376.000000

070     B5: #	out( B60 B6 ) &lt;- in( B4 )  Freq: 0.520624
070 +   lbu  R28, [R10, #17]	# byte, #@loadUB ! Field: java/lang/String.hashIsZero
074 +   bne  R28, zr, B60	#@cmpI_reg_imm0_branch  P=0.001062 C=2826.000000

078     B6: #	out( B147 B7 ) &lt;- in( B5 )  Freq: 0.520071
078 +   lwu  R7, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
07c +   lb  R8, [R10, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
080 +   decode_heap_oop  R13, R7	#@decodeHeapOop
084 +   bne  R8, zr, B147	#@cmpI_reg_imm0_branch  P=0.000000 C=115940.000000

088     B7: #	out( B170 B8 ) &lt;- in( B6 )  Freq: 0.520071
088     lwu  R12, [R13, #12]	# range, #@loadRange
08c     NullCheck R13

08c     B8: #	out( B56 B9 ) &lt;- in( B7 )  Freq: 0.52007
08c +   bleu  R12, zr, B56	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.056079 C=18260.000000

090     B9: #	out( B142 B10 ) &lt;- in( B8 )  Freq: 0.490905
090 +   addiw  R28, R12, #-1	#@addI_reg_imm
094 +   bgeu  R28, R12, B142	#@cmpU_branch  P=0.000001 C=-1.000000

098     B10: #	out( B143 B11 ) &lt;- in( B9 )  Freq: 0.490905
098 +   li R7, #1	# int, #@loadConI
09c +   addiw  R14, R12, #-3	#@addI_reg_imm
0a0 +   lbu  R30, [R13, #16]	# byte, #@loadUB
0a4 +   ble  R14, R7, B143	#@cmpI_branch  P=0.000001 C=-1.000000

0a8     B11: #	out( B144 B12 ) &lt;- in( B10 )  Freq: 0.490904
0a8 +   slliw  R7, R30, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0ac +   li R28, #1	# int, #@loadConI
0b0 +   subw  R31, R7, R30	#@subI_reg_reg
0b4 +   bleu  R12, R28, B144	#@cmpU_branch  P=0.000001 C=-1.000000

0b8     B12: #	out( B145 B13 ) &lt;- in( B11 )  Freq: 0.490904
0b8 +   li R28, #4	# int, #@loadConI
0bc +   bleu  R12, R28, B145	#@cmpU_branch  P=0.000001 C=-1.000000

0c0     B13: #	out( B14 ) &lt;- in( B12 )  Freq: 0.490903
0c0 +   li R28, #1	# int, #@loadConI
0c4 +   li R16, #1	# int, #@loadConI
0c8     spill R28 -&gt; [sp, #12]	# spill size = 32

0cc     B14: #	out( B15 ) &lt;- in( B13 B16 ) Loop( B14-B16 ) Freq: 8.7538
0cc +   subw  R28, R12, R16	#@subI_reg_reg
0d0 +   addiw  R7, R28, #-3	#@addI_reg_imm
0d4 +   li R28, #0	# int, #@loadConI
0d8     CMove R7, (R14 lt R16), R7, R28	#@cmovI_cmpI
	
0e0 +   li R28, #4000	# int, #@loadConI
0e8 +   li R30, #4000	# int, #@loadConI
0f0     CMove R7, (R7 gtu R30), R7, R28	#@cmovI_cmpU
	
0f8 +   addw  R17, R7, R16	#@addI_reg_reg
        nop 	# 2 bytes pad for loops and calls

100     B15: #	out( B15 B16 ) &lt;- in( B14 B15 ) Loop( B15-B15 inner main of N157 strip mined) Freq: 156.098
100 +   addw  R7, R16, zr	#@convI2L_reg_reg
104 +   add R7, R13, R7	# ptr, #@addP_reg_reg
108 +   lbu  R30, [R7, #16]	# byte, #@loadUB
10c +   addw  R31, R31, R30	#@addI_reg_reg
110 +   lbu  R28, [R7, #17]	# byte, #@loadUB
114 +   slliw  R30, R31, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
118 +   subw  R31, R30, R31	#@subI_reg_reg
11c +   addw  R31, R31, R28	#@addI_reg_reg
120 +   lbu  R30, [R7, #18]	# byte, #@loadUB
124 +   slliw  R11, R31, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
128 +   subw  R28, R11, R31	#@subI_reg_reg
12c +   addw  R30, R28, R30	#@addI_reg_reg
130 +   lbu  R7, [R7, #19]	# byte, #@loadUB
134 +   slliw  R28, R30, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
138 +   subw  R30, R28, R30	#@subI_reg_reg
13c +   addw  R30, R30, R7	#@addI_reg_reg
140 +   slliw  R7, R30, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
144 +   addiw  R16, R16, #4	#@addI_reg_imm
148 +   subw  R31, R7, R30	#@subI_reg_reg
14c +   blt  R16, R17, B15	#@cmpI_loop  P=0.943921 C=17236.000000

150     B16: #	out( B14 B17 ) &lt;- in( B15 )  Freq: 8.7538
150 +   ld  R7, [R23, #920]	# ptr, #@loadP
154 +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::hashCode @ bci:37 (line 196) L[0]=_ L[1]=R30 L[2]=R13 L[3]=R12 L[4]=R16 L[5]=_
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=R10 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #0 L[1]=R10 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {c_rarg0=Oop c_rarg3=Oop [0]=Oop [48]=Oop off=340/0x154}
158 +   blt  R16, R14, B14	#@cmpI_branch  P=0.943921 C=17236.000000

15c     B17: #	out( B21 B18 ) &lt;- in( B143 B16 )  Freq: 0.490904
15c +   bge  R16, R12, B21	#@cmpI_branch  P=0.500000 C=-1.000000

160     B18: #	out( B149 B19 ) &lt;- in( B17 )  Freq: 0.245452
160 +   # castII of R16, #@castII
160     bgeu  R16, R12, B149	#@cmpU_branch  P=0.000001 C=-1.000000

164     B19: #	out( B150 B20 ) &lt;- in( B18 )  Freq: 0.245452
164 +   spill R16 -&gt; R28	# spill size = 32
168 +   # castII of R28, #@castII
168     bgeu  R28, R12, B150	#@cmpU_branch  P=0.000001 C=-1.000000

16c     B20: #	out( B20 B21 ) &lt;- in( B19 B20 ) Loop( B20-B20 inner post of N1959) Freq: 0.490903
16c +   addw  R7, R16, zr	#@convI2L_reg_reg
170 +   add R7, R13, R7	# ptr, #@addP_reg_reg
174 +   slliw  R31, R30, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
178 +   lbu  R7, [R7, #16]	# byte, #@loadUB
17c +   subw  R28, R31, R30	#@subI_reg_reg
180 +   addiw  R16, R16, #1	#@addI_reg_imm
184 +   addw  R30, R28, R7	#@addI_reg_reg
188 +   blt  R16, R12, B20	#@cmpI_loop  P=0.500000 C=17236.000000

18c     B21: #	out( B57 B22 ) &lt;- in( B20 B17 )  Freq: 0.490903
18c +   beq  R30, zr, B57	#@cmpI_reg_imm0_branch  P=0.000354 C=2823.000000

190     B22: #	out( B24 ) &lt;- in( B21 )  Freq: 0.490729
190 +   sw  R30, [R10, #12]	# int, #@storeI ! Field: java/lang/String.hash
194 +   j  B24	#@branch

198     B23: #	out( B24 ) &lt;- in( B4 )  Freq: 0.469427
198 +   li R28, #1	# int, #@loadConI
19c     spill R28 -&gt; [sp, #12]	# spill size = 32

1a0     B24: #	out( B169 B25 ) &lt;- in( B22 B57 B60 B23 B106 )  Freq: 0.990494
1a0 +   spill [sp, #0] -&gt; R7	# spill size = 64
1a4 +   lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$SetN.elements (constant)
1a8 +   decode_heap_oop  R31, R7	#@decodeHeapOop
1ac     lwu  R28, [R31, #12]	# range, #@loadRange
1b0     NullCheck R31

1b0     B25: #	out( B138 B26 ) &lt;- in( B24 )  Freq: 0.990493
1b0 +   bleu  R28, zr, B138	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

1b4     B26: #	out( B54 B27 ) &lt;- in( B25 )  Freq: 0.990492
1b4 +   remw  R7, R30, R28	#@modI
1b8 +   xorr  R30, R7, R28	#@xorI_reg_reg
1bc     spill R7 -&gt; [sp, #8]	# spill size = 32
1c0 +   blt  R30, zr, B54	#@cmpI_reg_imm0_branch  P=0.099772 C=11386.000000

1c4     B27: #	out( B137 B28 ) &lt;- in( B26 B55 )  Freq: 0.990492
1c4 +   spill [sp, #8] -&gt; R7	# spill size = 32
1c8 +   addw  R7, R7, zr	#@convI2L_reg_reg
1cc +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
1d0 +   add R7, R31, R7	# ptr, #@addP_reg_reg
1d4     spill [sp, #8] -&gt; R10	# spill size = 32
1d8 +   bgeu  R10, R28, B137	#@cmpU_branch  P=0.000001 C=-1.000000

1dc     B28: #	out( B50 B29 ) &lt;- in( B27 )  Freq: 0.990491
1dc +   lwu  R30, [R7, #16]	# loadN, compressed ptr, #@loadN
1e0 +   decode_heap_oop  R10, R30	#@decodeHeapOop
1e4 +   beq   R10, zr, B50	#@cmpP_imm0_branch  P=0.440484 C=24968.000000

1e8     B29: #	out( B127 B30 ) &lt;- in( B28 )  Freq: 0.554196
1e8 +   mv  R30, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1f8 +   bne  R29, R30, B127	#@cmpN_branch  P=0.000143 C=-1.000000

1fc     B30: #	out( B51 B31 ) &lt;- in( B29 )  Freq: 0.554116
1fc +   spill [sp, #48] -&gt; R15	# spill size = 64
200 +   # checkcastPP of R15, #@checkCastPP
200     beq  R15, R10, B51	#@cmpP_branch  P=0.064818 C=5338.000000

204     B31: #	out( B168 B32 ) &lt;- in( B30 )  Freq: 0.5182
204 +   lwu  R7, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
208 +   lb  R12, [R15, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
20c +   bne  R7, R30, B168	#@cmpN_branch  P=0.000000 C=-1.000000

210     B32: #	out( B146 B33 ) &lt;- in( B31 )  Freq: 0.5182
210 +   # checkcastPP of R10, #@checkCastPP
210     lb  R8, [R10, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
214 +   bne  R12, R8, B146	#@cmpI_branch  P=0.000000 C=4992.000000

218     B33: #	out( B141 B34 ) &lt;- in( B32 )  Freq: 0.518199
218 +   lwu  R7, [R15, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
21c +   decode_heap_oop  R17, R7	#@decodeHeapOop
220 +   lwu  R30, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
224 +   beq   R17, zr, B141	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

228     B34: #	out( B139 B35 ) &lt;- in( B33 )  Freq: 0.518199
228 +   decode_heap_oop  R7, R30	#@decodeHeapOop
22c +   lwu  R16, [R17, #12]	# range, #@loadRange
230 +   beq   R7, zr, B139	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

234     B35: #	out( B37 B36 ) &lt;- in( B34 )  Freq: 0.518198
234 +   lwu  R29, [R7, #12]	# range, #@loadRange
238 +   addi  R9, R17, #16	# ptr, #@addP_reg_imm
23c +   bne  R16, R29, B37	#@cmpI_branch  P=0.001000 C=-1.000000

240     B36: #	out( B51 B37 ) &lt;- in( B35 )  Freq: 0.51768
240 +   spill R16 -&gt; R14	# spill size = 32
244 +   addi  R13, R7, #16	# ptr, #@addP_reg_imm
248     spill R9 -&gt; R11	# spill size = 64
24c +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
2dc +   bne  R10, zr, B51	#@cmpI_reg_imm0_branch  P=0.007015 C=13971.000000

2e0     B37: #	out( B59 B38 ) &lt;- in( B35 B36 )  Freq: 0.514567
2e0 +   spill [sp, #8] -&gt; R7	# spill size = 32
2e4 +   addiw  R29, R7, #1	#@addI_reg_imm
2e8     spill R29 -&gt; [sp, #8]	# spill size = 32
2ec +   beq  R29, R28, B59	#@cmpI_branch  P=0.008361 C=13874.000000

2f0     B38: #	out( B140 B39 ) &lt;- in( B59 B37 )  Freq: 0.514567
2f0 +   spill [sp, #8] -&gt; R7	# spill size = 32
2f4 +   addw  R7, R7, zr	#@convI2L_reg_reg
2f8 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
2fc +   add R7, R31, R7	# ptr, #@addP_reg_reg
300     spill [sp, #8] -&gt; R30	# spill size = 32
304 +   bgeu  R30, R28, B140	#@cmpU_branch  P=0.000001 C=-1.000000

308     B39: #	out( B50 B40 ) &lt;- in( B38 )  Freq: 0.514566
308 +   lwu  R29, [R7, #16]	# loadN, compressed ptr, #@loadN
30c +   decode_heap_oop  R10, R29	#@decodeHeapOop
310 +   beq   R10, zr, B50	#@cmpP_imm0_branch  P=0.440484 C=13874.000000

314     B40: #	out( B41 ) &lt;- in( B39 )  Freq: 0.287908
314 +   mv  R18, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
        nop 	# 6 bytes pad for loops and calls

330     B41: #	out( B51 B42 ) &lt;- in( B40 B49 ) Loop( B41-B49 inner ) Freq: 0.599286
330 +   beq  R15, R10, B51	#@cmpP_branch  P=0.064818 C=5338.000000

334     B42: #	out( B168 B43 ) &lt;- in( B41 )  Freq: 0.560441
334 +   lwu  R7, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
338 +   bne  R7, R18, B168	#@cmpN_branch  P=0.000000 C=-1.000000

33c     B43: #	out( B146 B44 ) &lt;- in( B42 )  Freq: 0.560441
33c +   # checkcastPP of R10, #@checkCastPP
33c     lwu  R7, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
340 +   lb  R8, [R10, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
344 +   decode_heap_oop  R7, R7	#@decodeHeapOop
348 +   bne  R12, R8, B146	#@cmpI_branch  P=0.000000 C=4992.000000

34c     B44: #	out( B139 B45 ) &lt;- in( B43 )  Freq: 0.560441
34c +   beq   R7, zr, B139	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

350     B45: #	out( B47 B46 ) &lt;- in( B44 )  Freq: 0.560441
350 +   lwu  R30, [R7, #12]	# range, #@loadRange
354 +   bne  R16, R30, B47	#@cmpI_branch  P=0.001000 C=-1.000000

358     B46: #	out( B51 B47 ) &lt;- in( B45 )  Freq: 0.55988
358 +   spill R16 -&gt; R14	# spill size = 32
35c +   addi  R13, R7, #16	# ptr, #@addP_reg_imm
360     spill R9 -&gt; R11	# spill size = 64
364 +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
3f4 +   bne  R10, zr, B51	#@cmpI_reg_imm0_branch  P=0.007015 C=13971.000000

3f8     B47: #	out( B58 B48 ) &lt;- in( B45 B46 )  Freq: 0.556513
3f8 +   spill [sp, #8] -&gt; R7	# spill size = 32
3fc +   addiw  R7, R7, #1	#@addI_reg_imm
400     spill R7 -&gt; [sp, #8]	# spill size = 32
404 +   beq  R7, R28, B58	#@cmpI_branch  P=0.008361 C=13874.000000

408     B48: #	out( B140 B49 ) &lt;- in( B58 B47 )  Freq: 0.556513
408 +   ld  R7, [R23, #920]	# ptr, #@loadP
40c +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.util.ImmutableCollections$SetN::probe @ bci:53 (line 1017) L[0]=sp + #0 L[1]=sp + #48 L[2]=sp + #8 L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {xmethod=Oop c_rarg5=Oop c_rarg7=Oop x9=Derived_oop_c_rarg7 [0]=Oop [48]=Oop off=1036/0x40c}
410 +   spill [sp, #8] -&gt; R7	# spill size = 32
414 +   addw  R7, R7, zr	#@convI2L_reg_reg
418 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
41c +   add R7, R31, R7	# ptr, #@addP_reg_reg
420     spill [sp, #8] -&gt; R30	# spill size = 32
424 +   bgeu  R30, R28, B140	#@cmpU_branch  P=0.000001 C=-1.000000

428     B49: #	out( B41 B50 ) &lt;- in( B48 )  Freq: 0.556513
428 +   lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN
42c +   decode_heap_oop  R10, R7	#@decodeHeapOop
430 +   bne   R10, zr, B41	#@cmpP_imm0_branch  P=0.559516 C=13874.000000

434     B50: #	out( B51 ) &lt;- in( B39 B49 B134 B28 )  Freq: 0.908166
434 +   li R7, #-1	# int, #@loadConI
438     spill [sp, #8] -&gt; R28	# spill size = 32
43c +   subw  R7, R7, R28	#@subI_reg_reg
440     spill R7 -&gt; [sp, #8]	# spill size = 32

444     B51: #	out( B53 B52 ) &lt;- in( B30 B41 B36 B46 B129 B50 )  Freq: 0.990488
444 +   spill [sp, #8] -&gt; R28	# spill size = 32
448 +   bge  R28, zr, B53	#@cmpI_reg_imm0_branch  P=0.010766 C=9381.000000

44c     B52: #	out( B53 ) &lt;- in( B51 B2 )  Freq: 0.989326
44c +   li R28, #0	# int, #@loadConI
450     spill R28 -&gt; [sp, #12]	# spill size = 32

454     B53: #	out( N1895 ) &lt;- in( B52 B51 )  Freq: 0.99999
454 +   spill [sp, #12] -&gt; R10	# spill size = 32
458 +   # pop frame 96
	add  sp, sp, #96
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
470 +   ret	// return register, #@Ret

474     B54: #	out( B155 B55 ) &lt;- in( B26 )  Freq: 0.0988231
474 +   addw  R7, R7, R28	#@addI_reg_reg
478     spill [sp, #8] -&gt; R10	# spill size = 32
47c +   beq  R10, zr, B155	#@cmpI_reg_imm0_branch  P=0.000000 C=1136.000000

480     B55: #	out( B27 ) &lt;- in( B54 )  Freq: 0.098823
480 +   spill R7 -&gt; [sp, #8]	# spill size = 32
484 +   j  B27	#@branch

488     B56: #	out( B57 ) &lt;- in( B8 )  Freq: 0.0291649
488 +   li R28, #1	# int, #@loadConI
48c     spill R28 -&gt; [sp, #12]	# spill size = 32

490     B57: #	out( B24 ) &lt;- in( B21 B56 )  Freq: 0.0293388
490 +   spill [sp, #12] -&gt; R28	# spill size = 32
494 +   sb  R28, [R10, #17]	# byte, #@storeB ! Field: java/lang/String.hashIsZero
498 +   li R30, #0	# int, #@loadConI
49c +   j  B24	#@branch

4a0     B58: #	out( B48 ) &lt;- in( B47 )  Freq: 0.004653
4a0 +   li R29, #0	# int, #@loadConI
4a4     spill R29 -&gt; [sp, #8]	# spill size = 32
4a8 +   j  B48	#@branch

4ac     B59: #	out( B38 ) &lt;- in( B37 )  Freq: 0.00430229
4ac +   li R7, #0	# int, #@loadConI
4b0     spill R7 -&gt; [sp, #8]	# spill size = 32
4b4 +   j  B38	#@branch

4b8     B60: #	out( B24 ) &lt;- in( B5 )  Freq: 0.000552679
4b8 +   li R7, #1	# int, #@loadConI
4bc +   li R30, #0	# int, #@loadConI
4c0     spill R7 -&gt; [sp, #12]	# spill size = 32
4c4 +   j  B24	#@branch

4c8     B61: #	out( B185 B62 ) &lt;- in( B114 B115 B116 ) top-of-loop Freq: 9.27684e-07
4c8 +   spill R14 -&gt; [sp, #40]	# spill size = 32
4cc +   spill R12 -&gt; [sp, #36]	# spill size = 32
4d0 +   spill R28 -&gt; [sp, #32]	# spill size = 32
4d4 +   spill R31 -&gt; [sp, #24]	# spill size = 64
4d8 +   spill R15 -&gt; [sp, #16]	# spill size = 64
4dc +   spill R29 -&gt; [sp, #8]	# spill size = 32
4e0     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.ImmutableCollections$SetN::hashCode @ bci:33 (line 996) L[0]=_ L[1]=_ L[2]=sp + #24 L[3]=sp + #32 L[4]=sp + #36 L[5]=_ STK[0]=sp + #40
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:4 (line 508) L[0]=sp + #16 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [48]=Oop off=1276/0x4fc}

4fc     B62: #	out( B63 ) &lt;- in( B61 )  Freq: 9.27665e-07
        # Block is sole successor of call
4fc +   spill [sp, #8] -&gt; R29	# spill size = 32
500 +   spill [sp, #16] -&gt; R15	# spill size = 64
504 +   spill [sp, #24] -&gt; R31	# spill size = 64
508 +   spill [sp, #32] -&gt; R28	# spill size = 32
50c +   spill [sp, #36] -&gt; R12	# spill size = 32
510 +   spill [sp, #40] -&gt; R14	# spill size = 32

514     B63: #	out( B64 ) &lt;- in( B62 B117 ) top-of-loop Freq: 0.000309539
514 +   addw  R14, R10, R14	#@addI_reg_reg
        nop 	# 4 bytes pad for loops and calls

520     B64: #	out( B113 B65 ) &lt;- in( B63 B113 ) top-of-loop Freq: 0.000619077
520 +   addiw  R12, R12, #1	#@addI_reg_imm
524 +   blt  R12, R28, B113	#@cmpI_loop  P=0.581041 C=3696.000000

528     B65: #	out( B72 ) &lt;- in( B64 )  Freq: 0.000259368
528 +   j  B72	#@branch

52c     B66: #	out( B156 B67 ) &lt;- in( B3 )  Freq: 0.000446388
52c +   mv  R7, narrowklass: precise klass java/lang/module/ModuleDescriptor$Exports: 0x00000040d0924140:Constant:exact *	# compressed klass ptr, #@loadConNKlass
53c +   bne  R29, R7, B156	#@cmpN_branch  P=0.000001 C=-1.000000

540     B67: #	out( B172 B68 ) &lt;- in( B66 )  Freq: 0.000446387
540 +   spill R12 -&gt; R15	# spill size = 64
544 +   # checkcastPP of R15, #@checkCastPP
544     lwu  R28, [R15, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/module/ModuleDescriptor$Exports.mods
548 +   decode_heap_oop  R8, R28	#@decodeHeapOop
54c     lwu  R7, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
550     NullCheck R8

550     B68: #	out( B157 B69 ) &lt;- in( B67 )  Freq: 0.000446387
550 +   mv  R30, narrowklass: precise klass java/util/ImmutableCollections$SetN: 0x00000040d04fa7a0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
560 +   bne  R7, R30, B157	#@cmpN_branch  P=0.000001 C=-1.000000

564     B69: #	out( B173 B70 ) &lt;- in( B68 )  Freq: 0.000446387
564 +   # checkcastPP of R8, #@checkCastPP
564     lwu  R7, [R8, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$SetN.elements (constant)
568 +   decode_heap_oop  R31, R7	#@decodeHeapOop
56c     lwu  R28, [R31, #12]	# range, #@loadRange
570     NullCheck R31

570     B70: #	out( B111 B71 ) &lt;- in( B69 )  Freq: 0.000446386
570 +   bgtu  R28, zr, B111	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.581041 C=6361.000000

574     B71: #	out( B72 ) &lt;- in( B70 )  Freq: 0.000187018
574 +   li R28, #1	# int, #@loadConI
578 +   li R14, #0	# int, #@loadConI
57c     spill R28 -&gt; [sp, #12]	# spill size = 32

580     B72: #	out( B174 B73 ) &lt;- in( B65 B71 )  Freq: 0.000446386
580 +   lwu  R7, [R15, #16]	# loadN, compressed ptr, #@loadN ! Field: java/lang/module/ModuleDescriptor$Exports.source
584 +   lwu  R30, [R15, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/module/ModuleDescriptor$Exports.targets
588 +   decode_heap_oop  R13, R7	#@decodeHeapOop
58c     lw  R9, [R13, #12]	# int, #@loadI ! Field: java/lang/String.hash
590     NullCheck R13

590     B73: #	out( B92 B74 ) &lt;- in( B72 )  Freq: 0.000446385
590 +   li R17, #43	# int, #@loadConI
594 +   decode_heap_oop  R18, R30	#@decodeHeapOop
598 +   mulw  R16, R14, R17	#@mulI
59c +   bne  R9, zr, B92	#@cmpI_reg_imm0_branch  P=0.474144 C=5376.000000

5a0     B74: #	out( B148 B75 ) &lt;- in( B73 )  Freq: 0.000234734
5a0 +   lbu  R7, [R13, #17]	# byte, #@loadUB ! Field: java/lang/String.hashIsZero
5a4 +   bne  R7, zr, B148	#@cmpI_reg_imm0_branch  P=0.001062 C=2826.000000

5a8     B75: #	out( B165 B76 ) &lt;- in( B74 )  Freq: 0.000234485
5a8 +   lwu  R7, [R13, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
5ac +   lb  R28, [R13, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
5b0 +   decode_heap_oop  R14, R7	#@decodeHeapOop
5b4 +   bne  R28, zr, B165	#@cmpI_reg_imm0_branch  P=0.000000 C=115940.000000

5b8     B76: #	out( B177 B77 ) &lt;- in( B75 )  Freq: 0.000234485
5b8     lwu  R8, [R14, #12]	# range, #@loadRange
5bc     NullCheck R14

5bc     B77: #	out( B135 B78 ) &lt;- in( B76 )  Freq: 0.000234485
5bc +   bleu  R8, zr, B135	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.056079 C=18260.000000

5c0     B78: #	out( B159 B79 ) &lt;- in( B77 )  Freq: 0.000221335
5c0 +   addiw  R28, R8, #-1	#@addI_reg_imm
5c4 +   bgeu  R28, R8, B159	#@cmpU_branch  P=0.000001 C=-1.000000

5c8     B79: #	out( B160 B80 ) &lt;- in( B78 )  Freq: 0.000221335
5c8 +   addiw  R7, R8, #-3	#@addI_reg_imm
5cc +   lbu  R9, [R14, #16]	# byte, #@loadUB
5d0     spill [sp, #12] -&gt; R28	# spill size = 32
5d4 +   ble  R7, R28, B160	#@cmpI_branch  P=0.000001 C=-1.000000

5d8     B80: #	out( B161 B81 ) &lt;- in( B79 )  Freq: 0.000221335
5d8 +   slliw  R28, R9, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
5dc +   subw  R28, R28, R9	#@subI_reg_reg
5e0     spill [sp, #12] -&gt; R31	# spill size = 32
5e4 +   bleu  R8, R31, B161	#@cmpU_branch  P=0.000001 C=-1.000000

5e8     B81: #	out( B162 B82 ) &lt;- in( B80 )  Freq: 0.000221334
5e8 +   li R30, #4	# int, #@loadConI
5ec +   bleu  R8, R30, B162	#@cmpU_branch  P=0.000001 C=-1.000000

5f0     B82: #	out( B83 ) &lt;- in( B81 )  Freq: 0.000221334
5f0 +   li R30, #1	# int, #@loadConI

5f4     B83: #	out( B84 ) &lt;- in( B82 B85 ) Loop( B83-B85 ) Freq: 0.00394684
5f4 +   subw  R10, R8, R30	#@subI_reg_reg
5f8 +   li R11, #0	# int, #@loadConI
5fc +   addiw  R31, R10, #-3	#@addI_reg_imm
600     CMove R31, (R7 lt R30), R31, R11	#@cmovI_cmpI
	
608 +   li R12, #4000	# int, #@loadConI
610 +   li R10, #4000	# int, #@loadConI
618     CMove R31, (R31 gtu R10), R31, R12	#@cmovI_cmpU
	
620 +   addw  R10, R31, R30	#@addI_reg_reg
        nop 	# 6 bytes pad for loops and calls

630     B84: #	out( B84 B85 ) &lt;- in( B83 B84 ) Loop( B84-B84 inner main of N359 strip mined) Freq: 0.0703802
630 +   addw  R31, R30, zr	#@convI2L_reg_reg
634 +   add R31, R14, R31	# ptr, #@addP_reg_reg
638 +   lbu  R11, [R31, #16]	# byte, #@loadUB
63c +   addw  R11, R28, R11	#@addI_reg_reg
640 +   lbu  R9, [R31, #17]	# byte, #@loadUB
644 +   slliw  R28, R11, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
648 +   subw  R28, R28, R11	#@subI_reg_reg
64c +   addw  R11, R28, R9	#@addI_reg_reg
650 +   lbu  R19, [R31, #18]	# byte, #@loadUB
654 +   slliw  R28, R11, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
658 +   subw  R28, R28, R11	#@subI_reg_reg
65c +   addw  R28, R28, R19	#@addI_reg_reg
660 +   lbu  R11, [R31, #19]	# byte, #@loadUB
664 +   slliw  R12, R28, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
668 +   subw  R28, R12, R28	#@subI_reg_reg
66c +   addw  R9, R28, R11	#@addI_reg_reg
670 +   slliw  R31, R9, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
674 +   addiw  R30, R30, #4	#@addI_reg_imm
678 +   subw  R28, R31, R9	#@subI_reg_reg
67c +   blt  R30, R10, B84	#@cmpI_loop  P=0.943921 C=17236.000000

680     B85: #	out( B83 B86 ) &lt;- in( B84 )  Freq: 0.00394684
680 +   ld  R19, [R23, #920]	# ptr, #@loadP
684 +   lwu zr, [R19]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::hashCode @ bci:37 (line 196) L[0]=_ L[1]=R9 L[2]=R14 L[3]=R8 L[4]=R30 L[5]=_
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=R13 L[1]=_
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:18 (line 509) L[0]=R15 L[1]=_ STK[0]=R16
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #0 L[1]=R15 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {c_rarg3=Oop c_rarg4=Oop c_rarg5=Oop x18=Oop [0]=Oop [48]=Oop off=1668/0x684}
688 +   blt  R30, R7, B83	#@cmpI_branch  P=0.943921 C=17236.000000

68c     B86: #	out( B90 B87 ) &lt;- in( B160 B85 )  Freq: 0.000221334
68c +   bge  R30, R8, B90	#@cmpI_branch  P=0.500000 C=-1.000000

690     B87: #	out( B166 B88 ) &lt;- in( B86 )  Freq: 0.000110667
690 +   # castII of R30, #@castII
690     bgeu  R30, R8, B166	#@cmpU_branch  P=0.000001 C=-1.000000

694     B88: #	out( B167 B89 ) &lt;- in( B87 )  Freq: 0.000110667
694 +   spill R30 -&gt; R7	# spill size = 32
698 +   # castII of R7, #@castII
698     bgeu  R7, R8, B167	#@cmpU_branch  P=0.000001 C=-1.000000

69c     B89: #	out( B89 B90 ) &lt;- in( B88 B89 ) Loop( B89-B89 inner post of N1943) Freq: 0.000221334
69c +   addw  R7, R30, zr	#@convI2L_reg_reg
6a0 +   add R7, R14, R7	# ptr, #@addP_reg_reg
6a4 +   lbu  R28, [R7, #16]	# byte, #@loadUB
6a8 +   slliw  R7, R9, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
6ac +   subw  R31, R7, R9	#@subI_reg_reg
6b0 +   addiw  R30, R30, #1	#@addI_reg_imm
6b4 +   addw  R9, R31, R28	#@addI_reg_reg
6b8 +   blt  R30, R8, B89	#@cmpI_loop  P=0.500000 C=17236.000000

6bc     B90: #	out( B135 B91 ) &lt;- in( B89 B86 )  Freq: 0.000221334
6bc +   beq  R9, zr, B135	#@cmpI_reg_imm0_branch  P=0.000354 C=2823.000000

6c0     B91: #	out( B92 ) &lt;- in( B90 )  Freq: 0.000221256
6c0 +   sw  R9, [R13, #12]	# int, #@storeI ! Field: java/lang/String.hash

6c4     B92: #	out( B175 B93 ) &lt;- in( B91 B135 B148 B73 )  Freq: 0.000446384
6c4     lwu  R28, [R18, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
6c8     NullCheck R18

6c8     B93: #	out( B107 B94 ) &lt;- in( B92 )  Freq: 0.000446384
6c8 +   addw  R7, R9, R16	#@addI_reg_reg
6cc +   mv  R10, narrowklass: precise klass java/util/ImmutableCollections$SetN: 0x00000040d04fa7a0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
6dc +   mulw  R30, R7, R17	#@mulI
6e0 +   beq  R28, R10, B107	#@cmpN_branch  P=0.672696 C=-1.000000

6e4     B94: #	out( B164 B95 ) &lt;- in( B93 )  Freq: 0.000146103
6e4 +   mv  R31, narrowklass: precise klass java/util/ImmutableCollections$Set12: 0x00000040d0929720:Constant:exact *	# compressed klass ptr, #@loadConNKlass
6f4 +   bne  R28, R31, B164	#@cmpN_branch  P=0.000001 C=-1.000000

6f8     B95: #	out( B179 B96 ) &lt;- in( B94 )  Freq: 0.000146103
6f8 +   # checkcastPP of R18, #@checkCastPP
6f8     lwu  R7, [R18, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$Set12.e0 (constant)
6fc +   decode_heap_oop  R11, R7	#@decodeHeapOop
700     lwu  R28, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
704     NullCheck R11

704     B96: #	out( B151 B97 ) &lt;- in( B95 )  Freq: 0.000146103
704 +   decode_klass_not_null  R7, R28	#@decodeKlass_not_null
710 +   ld  R7, [R7, #504]	# ptr, #@loadP
714 +   mv  R28, metadataptr:Constant0x00000040d0500d90	# ptr, #@loadConP
72c +   bne  R7, R28, B151	#@cmpP_branch  P=0.001000 C=-1.000000

730     B97: #	out( B151 B98 ) &lt;- in( B96 )  Freq: 0.000145957
730 +   ld  R7, [R11]	# int, #@loadL
734 +   li R31, #1	# long, #@loadConL
738 +   andi  R28, R7, #7	#@andL_reg_imm
73c +   bne  R28, R31, B151	#@cmpL_branch  P=0.001000 C=-1.000000

740     B98: #	out( B151 B99 ) &lt;- in( B97 )  Freq: 0.000145811
740 +   srli  R7, R7, (#8 &amp; 0x3f)	#@urShiftL_reg_imm
744 +   li R31, #2147483647	# int, #@loadConI
74c +   addw  R7, R7, zr	#@convL2I_reg
750 +   andr  R13, R7, R31	#@andI_reg_reg
754 +   beq  R13, zr, B151	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

758     B99: #	out( B106 B100 ) &lt;- in( B152 B98 )  Freq: 0.000146103
758 +   lwu  R28, [R18, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$Set12.e1 (constant)
75c +   mv  R7, narrowoop: java/lang/Object:exact *	# compressed ptr, #@loadConN
76c +   beq  R28, R7, B106	#@cmpN_branch  P=0.100000 C=-1.000000

770     B100: #	out( B180 B101 ) &lt;- in( B99 )  Freq: 0.000131493
770 +   decode_heap_oop  R11, R28	#@decodeHeapOop
774     lwu  R28, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
778     NullCheck R11

778     B101: #	out( B153 B102 ) &lt;- in( B100 )  Freq: 0.000131492
778 +   decode_klass_not_null  R7, R28	#@decodeKlass_not_null
784 +   ld  R7, [R7, #504]	# ptr, #@loadP
788 +   mv  R28, metadataptr:Constant0x00000040d0500d90	# ptr, #@loadConP
7a0 +   bne  R7, R28, B153	#@cmpP_branch  P=0.001000 C=-1.000000

7a4     B102: #	out( B153 B103 ) &lt;- in( B101 )  Freq: 0.000131361
7a4 +   ld  R7, [R11]	# int, #@loadL
7a8 +   li R31, #1	# long, #@loadConL
7ac +   andi  R28, R7, #7	#@andL_reg_imm
7b0 +   bne  R28, R31, B153	#@cmpL_branch  P=0.001000 C=-1.000000

7b4     B103: #	out( B153 B104 ) &lt;- in( B102 )  Freq: 0.00013123
7b4 +   srli  R7, R7, (#8 &amp; 0x3f)	#@urShiftL_reg_imm
7b8 +   li R28, #2147483647	# int, #@loadConI
7c0 +   addw  R7, R7, zr	#@convL2I_reg
7c4 +   andr  R10, R7, R28	#@andI_reg_reg
7c8 +   beq  R10, zr, B153	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

7cc     B104: #	out( B106 ) &lt;- in( B154 B103 )  Freq: 0.000131492
7cc +   addw  R13, R10, R13	#@addI_reg_reg
7d0 +   j  B106	#@branch

7d4     B105: #	out( B106 ) &lt;- in( B108 )  Freq: 0.000125805
7d4 +   li R13, #0	# int, #@loadConI

7d8     B106: #	out( B24 ) &lt;- in( B121 B105 B104 B99 )  Freq: 0.000446383
7d8 +   addw  R30, R13, R30	#@addI_reg_reg
7dc +   j  B24	#@branch

7e0     B107: #	out( B176 B108 ) &lt;- in( B93 )  Freq: 0.00030028
7e0 +   # checkcastPP of R18, #@checkCastPP
7e0     lwu  R7, [R18, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$SetN.elements (constant)
7e4 +   decode_heap_oop  R12, R7	#@decodeHeapOop
7e8     lwu  R7, [R12, #12]	# range, #@loadRange
7ec     NullCheck R12

7ec     B108: #	out( B105 B109 ) &lt;- in( B107 )  Freq: 0.00030028
7ec +   bleu  R7, zr, B105	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.418959 C=6361.000000

7f0     B109: #	out( B163 B110 ) &lt;- in( B108 )  Freq: 0.000174475
7f0 +   addiw  R31, R7, #-1	#@addI_reg_imm
7f4 +   bgeu  R31, R7, B163	#@cmpU_branch  P=0.000001 C=-1.000000

7f8     B110: #	out( B122 ) &lt;- in( B109 )  Freq: 0.000174475
7f8 +   li R16, #0	# int, #@loadConI
7fc +   li R13, #0	# int, #@loadConI
800 +   j  B122	#@branch

804     B111: #	out( B158 B112 ) &lt;- in( B70 )  Freq: 0.000259369
804 +   addiw  R30, R28, #-1	#@addI_reg_imm
808 +   bgeu  R30, R28, B158	#@cmpU_branch  P=0.000001 C=-1.000000

80c     B112: #	out( B113 ) &lt;- in( B111 )  Freq: 0.000259368
80c +   li R7, #1	# int, #@loadConI
810 +   li R12, #0	# int, #@loadConI
814 +   li R14, #0	# int, #@loadConI
818     spill R7 -&gt; [sp, #12]	# spill size = 32

81c     B113: #	out( B64 B114 ) &lt;- in( B112 B64 ) Loop( B113-B64 inner ) Freq: 0.000619077
81c +   addw  R7, R12, zr	#@convI2L_reg_reg
820 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
824 +   add R7, R31, R7	# ptr, #@addP_reg_reg
828 +   lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN
82c +   decode_heap_oop  R11, R7	#@decodeHeapOop
830 +   beq   R11, zr, B64	#@cmpP_imm0_branch  P=0.500000 C=3696.000000

834     B114: #	out( B61 B115 ) &lt;- in( B113 )  Freq: 0.000309539
834 +   lwu  R30, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
838 +   decode_klass_not_null  R7, R30	#@decodeKlass_not_null
844 +   ld  R7, [R7, #504]	# ptr, #@loadP
848 +   mv  R30, metadataptr:Constant0x00000040d0500d90	# ptr, #@loadConP
860 +   bne  R7, R30, B61	#@cmpP_branch  P=0.001000 C=-1.000000

864     B115: #	out( B61 B116 ) &lt;- in( B114 )  Freq: 0.000309229
864 +   ld  R7, [R11]	# int, #@loadL
868 +   li R10, #1	# long, #@loadConL
86c +   andi  R30, R7, #7	#@andL_reg_imm
870 +   bne  R30, R10, B61	#@cmpL_branch  P=0.001000 C=-1.000000

874     B116: #	out( B61 B117 ) &lt;- in( B115 )  Freq: 0.00030892
874 +   srli  R7, R7, (#8 &amp; 0x3f)	#@urShiftL_reg_imm
878 +   li R10, #2147483647	# int, #@loadConI
880 +   addw  R7, R7, zr	#@convL2I_reg
884 +   andr  R10, R7, R10	#@andI_reg_reg
888 +   beq  R10, zr, B61	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

88c     B117: #	out( B63 ) &lt;- in( B116 )  Freq: 0.000308611
88c +   j  B63	#@branch

890     B118: #	out( B181 B119 ) &lt;- in( B123 B124 B125 ) top-of-loop Freq: 6.24045e-07
890 +   spill R13 -&gt; [sp, #44]	# spill size = 32
894 +   spill R16 -&gt; [sp, #40]	# spill size = 32
898 +   spill R7 -&gt; [sp, #28]	# spill size = 32
89c +   spill R12 -&gt; [sp, #32]	# spill size = 64
8a0 +   spill R30 -&gt; [sp, #24]	# spill size = 32
8a4 +   spill R15 -&gt; [sp, #16]	# spill size = 64
8a8 +   spill R29 -&gt; [sp, #8]	# spill size = 32
8ac     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.ImmutableCollections$SetN::hashCode @ bci:33 (line 996) L[0]=_ L[1]=_ L[2]=sp + #32 L[3]=sp + #28 L[4]=sp + #40 L[5]=_ STK[0]=sp + #44
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:31 (line 510) L[0]=_ L[1]=_ STK[0]=sp + #24
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [16]=Oop [32]=Oop [48]=Oop off=2248/0x8c8}

8c8     B119: #	out( B120 ) &lt;- in( B118 )  Freq: 6.24033e-07
        # Block is sole successor of call
8c8 +   spill [sp, #8] -&gt; R29	# spill size = 32
8cc +   spill [sp, #16] -&gt; R15	# spill size = 64
8d0 +   spill [sp, #24] -&gt; R30	# spill size = 32
8d4 +   spill [sp, #32] -&gt; R12	# spill size = 64
8d8 +   spill [sp, #28] -&gt; R7	# spill size = 32
8dc +   spill [sp, #40] -&gt; R16	# spill size = 32
8e0 +   spill [sp, #44] -&gt; R13	# spill size = 32

8e4     B120: #	out( B121 ) &lt;- in( B119 B126 ) top-of-loop Freq: 0.000208224
8e4 +   addw  R13, R10, R13	#@addI_reg_reg
        nop 	# 4 bytes pad for loops and calls

8f0     B121: #	out( B106 B122 ) &lt;- in( B120 B122 ) top-of-loop Freq: 0.000416448
8f0 +   addiw  R16, R16, #1	#@addI_reg_imm
8f4 +   bge  R16, R7, B106	#@cmpI_loop  P=0.418959 C=3696.000000

8f8     B122: #	out( B121 B123 ) &lt;- in( B110 B121 ) Loop( B122-B121 inner ) Freq: 0.000416448
8f8 +   addw  R28, R16, zr	#@convI2L_reg_reg
8fc +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
900 +   add R28, R12, R28	# ptr, #@addP_reg_reg
904 +   lwu  R28, [R28, #16]	# loadN, compressed ptr, #@loadN
908 +   decode_heap_oop  R11, R28	#@decodeHeapOop
90c +   beq   R11, zr, B121	#@cmpP_imm0_branch  P=0.500000 C=3696.000000

910     B123: #	out( B118 B124 ) &lt;- in( B122 )  Freq: 0.000208224
910 +   lwu  R31, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
914 +   decode_klass_not_null  R28, R31	#@decodeKlass_not_null
920 +   ld  R28, [R28, #504]	# ptr, #@loadP
924 +   mv  R31, metadataptr:Constant0x00000040d0500d90	# ptr, #@loadConP
93c +   bne  R28, R31, B118	#@cmpP_branch  P=0.001000 C=-1.000000

940     B124: #	out( B118 B125 ) &lt;- in( B123 )  Freq: 0.000208016
940 +   ld  R28, [R11]	# int, #@loadL
944 +   li R10, #1	# long, #@loadConL
948 +   andi  R31, R28, #7	#@andL_reg_imm
94c +   bne  R31, R10, B118	#@cmpL_branch  P=0.001000 C=-1.000000

950     B125: #	out( B118 B126 ) &lt;- in( B124 )  Freq: 0.000207808
950 +   srli  R28, R28, (#8 &amp; 0x3f)	#@urShiftL_reg_imm
954 +   li R31, #2147483647	# int, #@loadConI
95c +   addw  R28, R28, zr	#@convL2I_reg
960 +   andr  R10, R28, R31	#@andI_reg_reg
964 +   beq  R10, zr, B118	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

968     B126: #	out( B120 ) &lt;- in( B125 )  Freq: 0.0002076
968 +   j  B120	#@branch

96c     B127: #	out( B128 ) &lt;- in( B29 )  Freq: 7.93444e-05
96c +   spill R10 -&gt; R12	# spill size = 64

970     B128: #	out( B186 B129 ) &lt;- in( B127 B133 ) Loop( B128-B133 inner ) Freq: 0.000178538
970 +   spill [sp, #48] -&gt; R11	# spill size = 64
974     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::equals
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=sp + #0 L[1]=sp + #48 L[2]=sp + #8 L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [48]=Oop off=2448/0x990}

990     B129: #	out( B51 B130 ) &lt;- in( B128 )  Freq: 0.000178535
        # Block is sole successor of call
990 +   bne  R10, zr, B51	#@cmpI_reg_imm0_branch  P=0.007015 C=13971.000000

994     B130: #	out( B178 B131 ) &lt;- in( B129 )  Freq: 0.000177283
994 +   spill [sp, #0] -&gt; R7	# spill size = 64
998 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$SetN.elements (constant)
99c +   decode_heap_oop  R31, R28	#@decodeHeapOop
9a0     lwu  R29, [R31, #12]	# range, #@loadRange
9a4     NullCheck R31

9a4     B131: #	out( B136 B132 ) &lt;- in( B130 )  Freq: 0.000177282
9a4 +   spill [sp, #8] -&gt; R7	# spill size = 32
9a8 +   addiw  R28, R7, #1	#@addI_reg_imm
9ac     spill R28 -&gt; [sp, #8]	# spill size = 32
9b0 +   beq  R28, R29, B136	#@cmpI_branch  P=0.008361 C=13874.000000

9b4     B132: #	out( B140 B133 ) &lt;- in( B136 B131 )  Freq: 0.000177282
9b4 +   ld  R10, [R23, #920]	# ptr, #@loadP
9b8 +   lwu zr, [R10]	# Safepoint: poll for GC, #@safePoint        # java.util.ImmutableCollections$SetN::probe @ bci:53 (line 1017) L[0]=sp + #0 L[1]=sp + #48 L[2]=sp + #8 L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {xmethod=Oop [0]=Oop [48]=Oop off=2488/0x9b8}
9bc +   spill [sp, #8] -&gt; R7	# spill size = 32
9c0 +   bgeu  R7, R29, B140	#@cmpU_branch  P=0.000001 C=-1.000000

9c4     B133: #	out( B128 B134 ) &lt;- in( B132 )  Freq: 0.000177282
9c4 +   addw  R7, R7, zr	#@convI2L_reg_reg
9c8 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
9cc +   add R7, R31, R7	# ptr, #@addP_reg_reg
9d0 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN
9d4 +   decode_heap_oop  R12, R28	#@decodeHeapOop
9d8 +   bne   R12, zr, B128	#@cmpP_imm0_branch  P=0.559516 C=13874.000000

9dc     B134: #	out( B50 ) &lt;- in( B133 )  Freq: 7.80899e-05
9dc +   j  B50	#@branch

9e0     B135: #	out( B92 ) &lt;- in( B90 B77 )  Freq: 1.3228e-05
9e0 +   spill [sp, #12] -&gt; R7	# spill size = 32
9e4 +   sb  R7, [R13, #17]	# byte, #@storeB ! Field: java/lang/String.hashIsZero
9e8 +   li R9, #0	# int, #@loadConI
9ec +   j  B92	#@branch

9f0     B136: #	out( B132 ) &lt;- in( B131 )  Freq: 1.48225e-06
9f0 +   li R7, #0	# int, #@loadConI
9f4     spill R7 -&gt; [sp, #8]	# spill size = 32
9f8 +   j  B132	#@branch

9fc     B137: #	out( N1895 ) &lt;- in( B27 )  Freq: 1.00364e-06
9fc +   li R11, #-28	# int, #@loadConI
a00     spill [sp, #0] -&gt; R8	# spill size = 64
a04 +   spill R31 -&gt; [sp, #16]	# spill size = 64
a08     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:18 (line 1009) L[0]=R8 L[1]=sp + #48 L[2]=sp + #8 L[3]=_ STK[0]=sp + #16 STK[1]=sp + #8
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [16]=Oop [48]=Oop off=2572/0xa0c}
a0c     #@ShouldNotReachHere

a18     B138: #	out( N1895 ) &lt;- in( B25 )  Freq: 9.90493e-07
a18 +   li R11, #-122	# int, #@loadConI
a1c     spill R30 -&gt; R8	# spill size = 32
a20     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;div0_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.Math::floorMod @ bci:2 (line 1342) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8 STK[1]=#0
        # java.util.ImmutableCollections$SetN::probe @ bci:9 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=2596/0xa24}
a24     #@ShouldNotReachHere

a30     B139: #	out( N1895 ) &lt;- in( B34 B44 )  Freq: 1.09296e-06
a30     #@ShouldNotReachHere

a3c     B140: #	out( N1895 ) &lt;- in( B38 B48 B132 )  Freq: 1.08548e-06
a3c +   li R11, #-28	# int, #@loadConI
a40     spill [sp, #0] -&gt; R8	# spill size = 64
a44 +   spill R31 -&gt; [sp, #16]	# spill size = 64
a48     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:18 (line 1009) L[0]=R8 L[1]=sp + #48 L[2]=sp + #8 L[3]=_ STK[0]=sp + #16 STK[1]=sp + #8
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [16]=Oop [48]=Oop off=2636/0xa4c}
a4c     #@ShouldNotReachHere

a58     B141: #	out( N1895 ) &lt;- in( B33 )  Freq: 5.2508e-07
a58     #@ShouldNotReachHere

a64     B142: #	out( N1895 ) &lt;- in( B9 )  Freq: 4.97424e-07
a64 +   li R11, #-138	# int, #@loadConI
a68     spill [sp, #0] -&gt; R8	# spill size = 64
a6c +   spill R10 -&gt; [sp, #8]	# spill size = 64
a70 +   spill R13 -&gt; [sp, #16]	# spill size = 64
a74 +   spill R12 -&gt; [sp, #28]	# spill size = 32
a78     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:13 (line 196) L[0]=_ L[1]=#0 L[2]=sp + #16 L[3]=sp + #28 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=sp + #28
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=sp + #8 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=2684/0xa7c}
a7c     #@ShouldNotReachHere

a88     B143: #	out( B17 ) &lt;- in( B10 )  Freq: 4.97423e-07
a88 +   li R16, #1	# int, #@loadConI
a8c     spill R7 -&gt; [sp, #12]	# spill size = 32
a90 +   j  B17	#@branch

a94     B144: #	out( N1895 ) &lt;- in( B11 )  Freq: 4.90904e-07
a94     #@ShouldNotReachHere

aa0     B145: #	out( N1895 ) &lt;- in( B12 )  Freq: 4.90904e-07
aa0     #@ShouldNotReachHere

aac     B146: #	out( N1895 ) &lt;- in( B32 B43 )  Freq: 5.39321e-07
aac +   li R11, #-187	# int, #@loadConI
ab0     spill R15 -&gt; [sp, #24]	# spill size = 64
ab4 +   spill R10 -&gt; [sp, #32]	# spill size = 64
ab8 +   spill R12 -&gt; [sp, #12]	# spill size = 32
abc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #24 L[1]=_ L[2]=sp + #32 STK[0]=sp + #12 STK[1]=R8
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=sp + #0 L[1]=sp + #24 L[2]=sp + #8 L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [24]=Oop [32]=Oop off=2752/0xac0}
ac0     #@ShouldNotReachHere

acc     B147: #	out( N1895 ) &lt;- in( B6 )  Freq: 2.60035e-07
acc +   li R11, #-187	# int, #@loadConI
ad0     spill R10 -&gt; [sp, #16]	# spill size = 64
ad4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=R8
        # java.lang.String::hashCode @ bci:17 (line 2337) L[0]=sp + #16 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [16]=Oop off=2776/0xad8}
ad8     #@ShouldNotReachHere

ae4     B148: #	out( B92 ) &lt;- in( B74 )  Freq: 2.49187e-07
ae4 +   li R9, #0	# int, #@loadConI
ae8 +   j  B92	#@branch

aec     B149: #	out( N1895 ) &lt;- in( B18 )  Freq: 2.48711e-07
aec     #@ShouldNotReachHere

af8     B150: #	out( N1895 ) &lt;- in( B19 )  Freq: 2.48711e-07
af8     #@ShouldNotReachHere

b04     B151: #	out( B182 B152 ) &lt;- in( B96 B97 B98 )  Freq: 4.37869e-07
b04 +   spill R30 -&gt; [sp, #32]	# spill size = 32
b08 +   spill R18 -&gt; [sp, #24]	# spill size = 64
b0c +   spill R15 -&gt; [sp, #16]	# spill size = 64
b10 +   spill R29 -&gt; [sp, #8]	# spill size = 32
b14     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.ImmutableCollections$Set12::hashCode @ bci:4 (line 815) L[0]=sp + #24
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:31 (line 510) L[0]=_ L[1]=_ STK[0]=sp + #32
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [48]=Oop off=2864/0xb30}

b30     B152: #	out( B99 ) &lt;- in( B151 )  Freq: 4.3786e-07
        # Block is sole successor of call
b30 +   spill [sp, #8] -&gt; R29	# spill size = 32
b34 +   spill [sp, #16] -&gt; R15	# spill size = 64
b38 +   spill [sp, #24] -&gt; R18	# spill size = 64
b3c +   spill [sp, #32] -&gt; R30	# spill size = 32
b40 +   spill R10 -&gt; R13	# spill size = 32
b44 +   j  B99	#@branch

b48     B153: #	out( B183 B154 ) &lt;- in( B101 B102 B103 )  Freq: 3.94081e-07
b48 +   spill R13 -&gt; [sp, #28]	# spill size = 32
b4c +   spill R30 -&gt; [sp, #24]	# spill size = 32
b50 +   spill R15 -&gt; [sp, #16]	# spill size = 64
b54 +   spill R29 -&gt; [sp, #8]	# spill size = 32
b58     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.ImmutableCollections$Set12::hashCode @ bci:25 (line 815) L[0]=_ STK[0]=sp + #28
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:31 (line 510) L[0]=_ L[1]=_ STK[0]=sp + #24
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [16]=Oop [48]=Oop off=2932/0xb74}

b74     B154: #	out( B104 ) &lt;- in( B153 )  Freq: 3.94074e-07
        # Block is sole successor of call
b74 +   spill [sp, #8] -&gt; R29	# spill size = 32
b78 +   spill [sp, #24] -&gt; R30	# spill size = 32
b7c +   spill [sp, #28] -&gt; R13	# spill size = 32
b80 +   j  B104	#@branch

b84     B155: #	out( N1895 ) &lt;- in( B54 )  Freq: 4.71225e-08
b84 +   li R11, #-187	# int, #@loadConI
b88     spill [sp, #0] -&gt; R8	# spill size = 64
b8c +   spill R28 -&gt; [sp, #12]	# spill size = 32
b90     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.Math::floorMod @ bci:11 (line 1344) L[0]=_ L[1]=sp + #12 L[2]=sp + #8 STK[0]=sp + #8
        # java.util.ImmutableCollections$SetN::probe @ bci:9 (line 1007) L[0]=R8 L[1]=sp + #48 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [48]=Oop off=2964/0xb94}
b94     #@ShouldNotReachHere

ba0     B156: #	out( N1895 ) &lt;- in( B66 )  Freq: 4.46388e-10
ba0 +   li R11, #-58	# int, #@loadConI
ba4     spill [sp, #0] -&gt; R8	# spill size = 64
ba8 +   spill R12 -&gt; [sp, #8]	# spill size = 64
bac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;bimorphic&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_ STK[0]=sp + #48
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [48]=Oop off=2992/0xbb0}
bb0     #@ShouldNotReachHere

bbc     B157: #	out( N1895 ) &lt;- in( B68 )  Freq: 4.46387e-10
bbc +   li R11, #-34	# int, #@loadConI
bc0     spill R15 -&gt; [sp, #16]	# spill size = 64
bc4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:4 (line 508) L[0]=sp + #16 L[1]=_ STK[0]=R8
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=3016/0xbc8}
bc8     #@ShouldNotReachHere

bd4     B158: #	out( N1895 ) &lt;- in( B111 )  Freq: 2.62813e-10
bd4 +   li R11, #-138	# int, #@loadConI
bd8     spill [sp, #0] -&gt; R8	# spill size = 64
bdc +   spill R15 -&gt; [sp, #8]	# spill size = 64
be0 +   spill R31 -&gt; [sp, #16]	# spill size = 64
be4 +   spill R28 -&gt; [sp, #28]	# spill size = 32
be8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::hashCode @ bci:16 (line 994) L[0]=_ L[1]=#0 L[2]=sp + #16 L[3]=sp + #28 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=sp + #28
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:4 (line 508) L[0]=sp + #8 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=3052/0xbec}
bec     #@ShouldNotReachHere

bf8     B159: #	out( N1895 ) &lt;- in( B78 )  Freq: 2.24274e-10
bf8 +   li R11, #-138	# int, #@loadConI
bfc     spill R15 -&gt; [sp, #16]	# spill size = 64
c00 +   spill R16 -&gt; [sp, #24]	# spill size = 32
c04 +   spill R13 -&gt; [sp, #32]	# spill size = 64
c08 +   spill R14 -&gt; [sp, #40]	# spill size = 64
c0c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:13 (line 196) L[0]=_ L[1]=#0 L[2]=sp + #40 L[3]=R8 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=R8
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=sp + #32 L[1]=_
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:18 (line 509) L[0]=sp + #16 L[1]=_ STK[0]=sp + #24
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [16]=Oop [32]=Oop [40]=Oop off=3088/0xc10}
c10     #@ShouldNotReachHere

c1c     B160: #	out( B86 ) &lt;- in( B79 )  Freq: 2.24274e-10
c1c +   li R30, #1	# int, #@loadConI
c20 +   j  B86	#@branch

c24     B161: #	out( N1895 ) &lt;- in( B80 )  Freq: 2.21335e-10
c24     #@ShouldNotReachHere

c30     B162: #	out( N1895 ) &lt;- in( B81 )  Freq: 2.21334e-10
c30     #@ShouldNotReachHere

c3c     B163: #	out( N1895 ) &lt;- in( B109 )  Freq: 1.76792e-10
c3c +   spill [sp, #0] -&gt; R8	# spill size = 64
c40 +   li R11, #-138	# int, #@loadConI
c44     spill R15 -&gt; [sp, #0]	# spill size = 64
c48 +   spill R30 -&gt; [sp, #8]	# spill size = 32
c4c +   spill R12 -&gt; [sp, #16]	# spill size = 64
c50 +   spill R7 -&gt; [sp, #24]	# spill size = 32
c54     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::hashCode @ bci:16 (line 994) L[0]=_ L[1]=#0 L[2]=sp + #16 L[3]=sp + #24 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=sp + #24
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:31 (line 510) L[0]=_ L[1]=_ STK[0]=sp + #8
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=3160/0xc58}
c58     #@ShouldNotReachHere

c64     B164: #	out( N1895 ) &lt;- in( B94 )  Freq: 1.46103e-10
c64 +   spill [sp, #0] -&gt; R8	# spill size = 64
c68 +   li R11, #-58	# int, #@loadConI
c6c     spill R15 -&gt; [sp, #0]	# spill size = 64
c70 +   spill R30 -&gt; [sp, #8]	# spill size = 32
c74 +   spill R18 -&gt; [sp, #16]	# spill size = 64
c78     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;bimorphic&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:31 (line 510) L[0]=_ L[1]=_ STK[0]=sp + #8 STK[1]=sp + #16
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=3196/0xc7c}
c7c     #@ShouldNotReachHere

c88     B165: #	out( N1895 ) &lt;- in( B75 )  Freq: 1.17243e-10
c88 +   li R11, #-187	# int, #@loadConI
c8c     spill [sp, #0] -&gt; R8	# spill size = 64
c90 +   spill R15 -&gt; [sp, #8]	# spill size = 64
c94 +   spill R16 -&gt; [sp, #16]	# spill size = 32
c98 +   spill R13 -&gt; [sp, #24]	# spill size = 64
c9c +   spill R28 -&gt; [sp, #20]	# spill size = 32
ca0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #20
        # java.lang.String::hashCode @ bci:17 (line 2337) L[0]=sp + #24 L[1]=_
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:18 (line 509) L[0]=sp + #8 L[1]=_ STK[0]=sp + #16
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop off=3236/0xca4}
ca4     #@ShouldNotReachHere

cb0     B166: #	out( N1895 ) &lt;- in( B87 )  Freq: 1.12137e-10
cb0     #@ShouldNotReachHere

cbc     B167: #	out( N1895 ) &lt;- in( B88 )  Freq: 1.12137e-10
cbc     #@ShouldNotReachHere

cc8     B168: #	out( N1895 ) &lt;- in( B31 B42 )  Freq: 1e-35
cc8 +   li R11, #-34	# int, #@loadConI
ccc     spill [sp, #0] -&gt; R8	# spill size = 64
cd0 +   spill R15 -&gt; [sp, #16]	# spill size = 64
cd4 +   spill R10 -&gt; [sp, #32]	# spill size = 64
cd8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #16 L[1]=sp + #32 L[2]=_ STK[0]=sp + #32
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=R8 L[1]=sp + #16 L[2]=sp + #8 L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [16]=Oop [32]=Oop off=3292/0xcdc}
cdc     #@ShouldNotReachHere

ce8     B169: #	out( N1895 ) &lt;- in( B24 )  Freq: 1.00365e-06
ce8 +   li R11, #-10	# int, #@loadConI
cec     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:8 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3312/0xcf0}
cf0     #@ShouldNotReachHere

cfc     B170: #	out( N1895 ) &lt;- in( B7 )  Freq: 5.26977e-07
cfc +   li R11, #-10	# int, #@loadConI
d00     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:5 (line 196) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=_ L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3332/0xd04}
d04     #@ShouldNotReachHere

d10     B171: #	out( N1895 ) &lt;- in( B1 )  Freq: 4.76837e-07
d10 +   li R11, #-187	# int, #@loadConI
d14     spill [sp, #0] -&gt; R8	# spill size = 64
d18 +   spill R12 -&gt; [sp, #8]	# spill size = 64
d1c +   spill R12 -&gt; [sp, #16]	# spill size = 64
d20     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.Objects::requireNonNull @ bci:1 (line 208) L[0]=sp + #16 STK[0]=sp + #8
        # java.util.ImmutableCollections$SetN::contains @ bci:1 (line 937) L[0]=R8 L[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=3364/0xd24}
d24     #@ShouldNotReachHere

d30     B172: #	out( N1895 ) &lt;- in( B67 )  Freq: 4.52315e-10
d30 +   li R11, #-10	# int, #@loadConI
d34     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:4 (line 508) L[0]=_ L[1]=_ STK[0]=#NULL
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3384/0xd38}
d38     #@ShouldNotReachHere

d44     B173: #	out( N1895 ) &lt;- in( B69 )  Freq: 4.52314e-10
d44 +   li R11, #-10	# int, #@loadConI
d48     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::hashCode @ bci:8 (line 994) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:4 (line 508) L[0]=_ L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3404/0xd4c}
d4c     #@ShouldNotReachHere

d58     B174: #	out( N1895 ) &lt;- in( B72 )  Freq: 4.52313e-10
d58 +   li R11, #-10	# int, #@loadConI
d5c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:18 (line 509) L[0]=_ L[1]=_ STK[0]=_ STK[1]=#NULL
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3424/0xd60}
d60     #@ShouldNotReachHere

d6c     B175: #	out( N1895 ) &lt;- in( B92 )  Freq: 4.52312e-10
d6c +   li R11, #-10	# int, #@loadConI
d70     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:31 (line 510) L[0]=_ L[1]=_ STK[0]=_ STK[1]=#NULL
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3444/0xd74}
d74     #@ShouldNotReachHere

d80     B176: #	out( N1895 ) &lt;- in( B107 )  Freq: 3.04268e-10
d80 +   li R11, #-10	# int, #@loadConI
d84     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::hashCode @ bci:8 (line 994) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:31 (line 510) L[0]=_ L[1]=_ STK[0]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3464/0xd88}
d88     #@ShouldNotReachHere

d94     B177: #	out( N1895 ) &lt;- in( B76 )  Freq: 2.37599e-10
d94 +   li R11, #-10	# int, #@loadConI
d98     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:5 (line 196) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=_ L[1]=_
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:18 (line 509) L[0]=_ L[1]=_ STK[0]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3484/0xd9c}
d9c     #@ShouldNotReachHere

da8     B178: #	out( N1895 ) &lt;- in( B130 )  Freq: 1.79637e-10
da8 +   li R11, #-10	# int, #@loadConI
dac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:47 (line 1014) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3504/0xdb0}
db0     #@ShouldNotReachHere

dbc     B179: #	out( N1895 ) &lt;- in( B95 )  Freq: 1.48043e-10
dbc +   li R11, #-10	# int, #@loadConI
dc0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$Set12::hashCode @ bci:4 (line 815) L[0]=_ STK[0]=#NULL
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:31 (line 510) L[0]=_ L[1]=_ STK[0]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3524/0xdc4}
dc4     #@ShouldNotReachHere

dd0     B180: #	out( N1895 ) &lt;- in( B100 )  Freq: 1.33239e-10
dd0 +   li R11, #-10	# int, #@loadConI
dd4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$Set12::hashCode @ bci:25 (line 815) L[0]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:31 (line 510) L[0]=_ L[1]=_ STK[0]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3544/0xdd8}
dd8     #@ShouldNotReachHere

de4     B181: #	out( B187 ) &lt;- in( B118 )  Freq: 6.24045e-12
de4      -- 	// exception oop; no code emitted, #@CreateException
de4 +   spill R10 -&gt; R11	# spill size = 64
de8 +   j  B187	#@branch

dec     B182: #	out( B184 ) &lt;- in( B151 )  Freq: 4.37869e-12
dec      -- 	// exception oop; no code emitted, #@CreateException
dec +   j  B184	#@branch

df0     B183: #	out( B184 ) &lt;- in( B153 )  Freq: 3.94081e-12
df0      -- 	// exception oop; no code emitted, #@CreateException

df0     B184: #	out( B187 ) &lt;- in( B182 B183 )  Freq: 8.3195e-12
df0 +   spill R10 -&gt; R11	# spill size = 64
df4 +   j  B187	#@branch

df8     B185: #	out( B187 ) &lt;- in( B61 )  Freq: 9.27684e-12
df8      -- 	// exception oop; no code emitted, #@CreateException
df8 +   spill R10 -&gt; R11	# spill size = 64
dfc +   j  B187	#@branch

e00     B186: #	out( B187 ) &lt;- in( B128 )  Freq: 1.78538e-09
e00      -- 	// exception oop; no code emitted, #@CreateException
e00 +   spill R10 -&gt; R11	# spill size = 64

e04     B187: #	out( N1895 ) &lt;- in( B185 B184 B181 B186 )  Freq: 1.80922e-09
e04     # pop frame 96
	add  sp, sp, #96
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
e10 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='605'>
----------------------- MetaData before Compile_id = 605 ------------------------
{method}
 - this oop:          0x00000040961a20a8
 - method holder:     &apos;java/util/HashMap&apos;
 - constants:         0x000000409619f4e0 constant pool [610] {0x000000409619f4e0} for &apos;java/util/HashMap&apos; cache=0x00000040961a4fd8
 - access:            0xc1000010  final 
 - name:              &apos;resize&apos;
 - signature:         &apos;()[Ljava/util/HashMap$Node;&apos;
 - max stack:         6
 - max locals:        14
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c58a900
 - code size:         356
 - code start:        0x00000040961a1e38
 - code end (excl):   0x00000040961a1f9c
 - method data:       0x0000004096485a10
 - checked ex length: 0
 - linenumber start:  0x00000040961a1f9c
 - localvar length:   17
 - localvar start:    0x00000040961a1fd8
 - compiled code: nmethod  24278  387       3       java.util.HashMap::resize (356 bytes)

------------------------ OptoAssembly for Compile_id = 605 -----------------------
#
#  narrowoop: java/util/HashMap$Node *[int:&gt;=0] * ( java/util/HashMap:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/HashMap:NotNull *
# -- Old sp -- Framesize: 112 --
#r263 sp+108: in_preserve
#r262 sp+104: return address
#r261 sp+100: in_preserve
#r260 sp+96: saved fp register
#r259 sp+92: pad2, stack alignment
#r258 sp+88: pad2, stack alignment
#r257 sp+84: Fixed slot 1
#r256 sp+80: Fixed slot 0
#r283 sp+76: spill
#r282 sp+72: spill
#r281 sp+68: spill
#r280 sp+64: spill
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N2090: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B24 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=112
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #112
	
03c     lwu  R7, [R11, #36]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap.table
040 +   decode_heap_oop  R7, R7	#@decodeHeapOop
044     spill R7 -&gt; [sp, #48]	# spill size = 64
048 +   lw  R7, [R11, #28]	# int, #@loadI ! Field: java/util/HashMap.threshold
04c     spill R7 -&gt; [sp, #24]	# spill size = 32
050 +   spill [sp, #48] -&gt; R7	# spill size = 64
054 +   li R28, #16	# int, #@loadConI
058     spill R11 -&gt; [sp, #40]	# spill size = 64
05c +   bne   R7, zr, B24	#@cmpP_imm0_branch  P=0.192477 C=2047.000000

060     B2: #	out( B3 ) &lt;- in( B1 )  Freq: 0.807523
060 +   mv  R7, NULL	# NULL ptr, #@loadConP0
064 +   li R29, #0	# int, #@loadConI
068     spill R7 -&gt; [sp, #48]	# spill size = 64
06c +   spill R29 -&gt; [sp, #56]	# spill size = 32

070     B3: #	out( B19 B4 ) &lt;- in( B24 B2 )  Freq: 1
070 +   li R31, #262144	# int, #@loadConI
074 +   li R7, #1073741824	# int, #@loadConI
078     spill [sp, #56] -&gt; R29	# spill size = 32
07c +   bgt  R29, zr, B19	#@cmpI_reg_imm0_branch  P=0.192477 C=2047.000000

080     B4: #	out( B6 B5 ) &lt;- in( B3 )  Freq: 0.807523
080 +   spill [sp, #24] -&gt; R29	# spill size = 32
084 +   ble  R29, zr, B6	#@cmpI_reg_imm0_branch  P=0.435572 C=1653.000000

088     B5: #	out( B7 ) &lt;- in( B4 )  Freq: 0.455789
088 +   li R29, #0	# int, #@loadConI
08c +   j  B7	#@branch

090     B6: #	out( B7 ) &lt;- in( B4 )  Freq: 0.351734
090 +   li R30, #16	# int, #@loadConI
094 +   li R29, #12	# int, #@loadConI
098     spill R30 -&gt; [sp, #24]	# spill size = 32

09c     B7: #	out( B10 B8 ) &lt;- in( B22 B6 B5 B23 )  Freq: 1
09c +   bne  R29, zr, B10	#@cmpI_reg_imm0_branch  P=0.484612 C=2047.000000

0a0     B8: #	out( B131 B9 ) &lt;- in( B7 )  Freq: 0.515388
0a0 +   spill [sp, #24] -&gt; R28	# spill size = 32
0a4 +   fcvt.s.w  F0, R28	#@convI2F_reg_reg
0a8 +   flw  F2, [R11, #32]	# float, #@loadF ! Field: java/util/HashMap.loadFactor
0ac +   fmul.s  F2, F0, F2	#@mulF_reg_reg
0b0 +   fcvt.w.s  R29, F2	#@convF2I_reg_reg
0d0     spill [sp, #24] -&gt; R30	# spill size = 32
0d4 +   bge  R30, R7, B131	#@cmpI_branch  P=0.000000 C=1055.000000

0d8     B9: #	out( B130 B10 ) &lt;- in( B8 )  Freq: 0.515388
0d8     -- 	// MachConstantBaseNode (empty encoding)
0d8 +   flw F0, [constant table base + #0]	# load from constant table: float=#1073741824.000000, #@loadConF
0e0     float_ble F0, F2, B130 	#@cmpF_branch  P=0.000000 C=1055.000000

0e8     B10: #	out( B11 B11 ) &lt;- in( B9 B7 )  Freq: 0.999999
0e8 +   spill [sp, #24] -&gt; R28	# spill size = 32
0ec +   addw  R7, R28, zr	#@convI2L_reg_reg
0f0 +   bleu  R28, R31, B11	#@cmpU_branch  P=0.999999 C=-1.000000

0f4     B11: #	out( B118 B12 ) &lt;- in( B10 B10 )  Freq: 0.999999
0f4 +   sw  R29, [R11, #28]	# int, #@storeI ! Field: java/util/HashMap.threshold
0f8     spill [sp, #24] -&gt; R29	# spill size = 32
0fc +   bgtu  R29, R31, B118	#@cmpU_branch  P=0.000001 C=-1.000000

100     B12: #	out( B118 B13 ) &lt;- in( B11 )  Freq: 0.999998
100 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
104 +   addi  R7, R7, #23	#@addL_reg_imm
108 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
108     ld  R21, [R23, #288]	# ptr, #@loadP
10c +   andi  R28, R7, #-8	#@andL_reg_imm
110 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
110     ld  R29, [R23, #304]	# ptr, #@loadP
114 +   add R28, R21, R28	# ptr, #@addP_reg_reg
118 +   bgeu  R28, R29, B118	#@cmpP_branch  P=0.000100 C=-1.000000

11c     B13: #	out( B14 ) &lt;- in( B12 )  Freq: 0.999898
11c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
11c     sd  R28, [R23, #288]	# ptr, #@storeP
120 +   li R28, #1	# long, #@loadConL
124 +   sd  R28, [R21]	# long, #@storeL
128 +   mv  R28, narrowklass: precise klass [Ljava/util/HashMap$Node;: 0x00000040d03fa720:Constant:exact *	# compressed klass ptr, #@loadConNKlass
138 +   sw  R28, [R21, #8]	# compressed klass ptr, #@storeNKlass
13c     spill [sp, #24] -&gt; R28	# spill size = 32
140 +   sw  R28, [R21, #12]	# int, #@storeI
144 +   srli  R7, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
148 +   addi  R28, R21, #16	# ptr, #@addP_reg_imm
14c +   addi  R29, R7, #-2	#@addL_reg_imm
150 +   ClearArray R29, R28	#@clearArray_reg_reg

1a8     B14: #	out( B85 B15 ) &lt;- in( B119 B13 )  Freq: 0.999999
1a8     
1a8     MEMBAR-store-store	#@membar_storestore
1ac +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ac     lb  R28, [R23, #56]	# byte, #@loadB
1b0 +   # checkcastPP of R21, #@checkCastPP
1b0     bne  R28, zr, B85	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1b4     B15: #	out( B17 B16 ) &lt;- in( B125 B87 B85 B14 )  Freq: 0.999999
1b4 +   spill [sp, #40] -&gt; R28	# spill size = 64
1b8 +   mv  R28, R28	# ptr -&gt; long, #@castP2X
1b8 +   mv  R7, R21	# ptr -&gt; long, #@castP2X
1bc +   xorr  R7, R7, R28	#@xorL_reg_reg
1c0 +   encode_heap_oop  R29, R21	#@encodeHeapOop
1c4 +   srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
1c8     spill [sp, #40] -&gt; R30	# spill size = 64
1cc +   sw  R29, [R30, #36]	# compressed ptr, #@storeN ! Field: java/util/HashMap.table
1d0 +   beq  R7, zr, B17	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1d4     B16: #	out( B88 B17 ) &lt;- in( B15 )  Freq: 0.998999
1d4 +   srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1d8 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1e4 +   add R10, R28, R7	# ptr, #@addP_reg_reg
1e8 +   lb  R28, [R10]	# byte, #@loadB
1ec +   li R29, #4	# int, #@loadConI
1f0 +   bne  R28, R29, B88	#@cmpI_branch  P=0.001000 C=-1.000000

1f4     B17: #	out( B25 B18 ) &lt;- in( B90 B91 B88 B16 B15 )  Freq: 0.999999
1f4 +   spill [sp, #48] -&gt; R7	# spill size = 64
1f8 +   bne   R7, zr, B25	#@cmpP_imm0_branch  P=0.192477 C=2047.000000

1fc     B18: #	out( N2090 ) &lt;- in( B55 B25 B17 )  Freq: 0.999996
1fc +   spill R21 -&gt; R10	# spill size = 64
200 +   # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
218 +   ret	// return register, #@Ret

21c     B19: #	out( B136 B20 ) &lt;- in( B3 )  Freq: 0.192477
21c +   slliw  R8, R29, (#1 &amp; 0x1f)	#@lShiftI_reg_imm
220 +   bge  R29, R7, B136	#@cmpI_branch  P=0.000000 C=394.000000

224     B20: #	out( B137 B21 ) &lt;- in( B19 )  Freq: 0.192477
224 +   bge  R8, R7, B137	#@cmpI_branch  P=0.000000 C=394.000000

228     B21: #	out( B23 B22 ) &lt;- in( B20 )  Freq: 0.192477
228 +   bge  R29, R28, B23	#@cmpI_branch  P=0.690355 C=394.000000

22c     B22: #	out( B7 ) &lt;- in( B21 )  Freq: 0.0595994
22c +   li R29, #0	# int, #@loadConI
230     spill R8 -&gt; [sp, #24]	# spill size = 32
234 +   j  B7	#@branch

238     B23: #	out( B7 ) &lt;- in( B21 )  Freq: 0.132877
238 +   spill [sp, #24] -&gt; R29	# spill size = 32
23c +   slliw  R29, R29, (#1 &amp; 0x1f)	#@lShiftI_reg_imm
240     spill R8 -&gt; [sp, #24]	# spill size = 32
244 +   j  B7	#@branch

248     B24: #	out( B3 ) &lt;- in( B1 )  Freq: 0.192477
248 +   lwu  R29, [R7, #12]	# range, #@loadRange
24c     spill R29 -&gt; [sp, #56]	# spill size = 32
250 +   j  B3	#@branch

254     B25: #	out( B18 B26 ) &lt;- in( B17 )  Freq: 0.192477
254 +   spill [sp, #56] -&gt; R7	# spill size = 32
258 +   ble  R7, zr, B18	#@cmpI_reg_imm0_branch  P=0.032540 C=12108.000000

25c     B26: #	out( B133 B27 ) &lt;- in( B25 )  Freq: 0.186213
25c +   spill [sp, #48] -&gt; R7	# spill size = 64
260 +   spill [sp, #24] -&gt; R28	# spill size = 32
264 +   spill [sp, #56] -&gt; R29	# spill size = 32
268 +   lwu  R7, [R7, #12]	# range, #@loadRange
26c +   # castII of R28, #@castII
26c     addiw  R29, R29, #-1	#@addI_reg_imm
270     spill R28 -&gt; [sp, #60]	# spill size = 32
274 +   bleu  R7, zr, B133	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

278     B27: #	out( B133 B28 ) &lt;- in( B26 )  Freq: 0.186213
278 +   bgeu  R29, R7, B133	#@cmpU_branch  P=0.000001 C=-1.000000

27c     B28: #	out( B134 B29 ) &lt;- in( B27 )  Freq: 0.186213
27c +   ble  R28, zr, B134	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

280     B29: #	out( B56 ) &lt;- in( B28 )  Freq: 0.186213
280 +   addiw  R28, R28, #-1	#@addI_reg_imm
284     spill R28 -&gt; [sp, #64]	# spill size = 32
288 +   spill [sp, #56] -&gt; R28	# spill size = 32
28c +   addw  R7, R28, zr	#@convI2L_reg_reg
290 +   li R9, #0	# int, #@loadConI
294     spill R7 -&gt; [sp, #72]	# spill size = 64
298 +   j  B56	#@branch

29c     B30: #	out( B38 B31 ) &lt;- in( B69 )  Freq: 1.10599
29c +   beq   R22, zr, B38	#@cmpP_imm0_branch  P=0.713339 C=2264.000000

2a0     B31: #	out( B115 B32 ) &lt;- in( B30 )  Freq: 0.317044
2a0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2a0     lb  R7, [R23, #56]	# byte, #@loadB
2a4 +   bne  R7, zr, B115	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

2a8     B32: #	out( B39 B33 ) &lt;- in( B135 B117 B115 B31 )  Freq: 0.317044
2a8 +   mv  R28, R22	# ptr -&gt; long, #@castP2X
2ac +   mv  R7, R26	# ptr -&gt; long, #@castP2X
2b0 +   xorr  R7, R7, R28	#@xorL_reg_reg
2b4 +   srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
2b8 +   sw  R24, [R22, #24]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.next
2bc +   beq  R7, zr, B39	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

2c0     B33: #	out( B39 B34 ) &lt;- in( B32 )  Freq: 0.316727
2c0 +   srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
2c4 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
2d0 +   add R10, R28, R7	# ptr, #@addP_reg_reg
2d4 +   lb  R7, [R10]	# byte, #@loadB
2d8 +   li R30, #4	# int, #@loadConI
2dc +   beq  R7, R30, B39	#@cmpI_branch  P=0.999000 C=-1.000000

2e0     B34: #	out( B39 B35 ) &lt;- in( B33 )  Freq: 0.000316727
2e0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2e0     ld  R28, [R23, #64]	# int, #@loadL
2e4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2e4     ld  R30, [R23, #80]	# ptr, #@loadP
2e8 +   #@membar_volatile
	fence iorw iorw
2ec +   lb  R7, [R10]	# byte, #@loadB
2f0 +   beq  R7, zr, B39	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

2f4     B35: #	out( B37 B36 ) &lt;- in( B34 )  Freq: 0.000158363
2f4 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
2f8 +   bne  R28, zr, B37	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

2fc     B36: #	out( B39 ) &lt;- in( B35 )  Freq: 7.91817e-05
2fc +   spill R29 -&gt; [sp, #8]	# spill size = 64
300     
300     
300 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
300     spill R23 -&gt; R11	# spill size = 64
304 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
334 +   spill R26 -&gt; [sp, #0]	# spill size = 64
338 +   spill R25 -&gt; [sp, #16]	# spill size = 64
33c +   spill R21 -&gt; R26	# spill size = 64
340 +   spill R9 -&gt; R25	# spill size = 32
344 +   spill R26 -&gt; R21	# spill size = 64
348 +   spill R25 -&gt; R9	# spill size = 32
34c +   spill [sp, #0] -&gt; R26	# spill size = 64
350 +   spill [sp, #8] -&gt; R29	# spill size = 64
354 +   spill [sp, #16] -&gt; R25	# spill size = 64
358 +   j  B39	#@branch

35c     B37: #	out( B39 ) &lt;- in( B35 )  Freq: 7.91817e-05
35c +   add R7, R30, R28	# ptr, #@addP_reg_reg
360 +   sd  R10, [R7, #-8]	# ptr, #@storeP
364 +   addi  R7, R28, #-8	#@addL_reg_imm
368 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
368     sd  R7, [R23, #64]	# long, #@storeL
36c +   j  B39	#@branch

370     B38: #	out( B39 ) &lt;- in( B30 )  Freq: 0.788945
370 +   spill R26 -&gt; R25	# spill size = 64

374     B39: #	out( B40 ) &lt;- in( B36 B37 B34 B33 B32 B38 )  Freq: 1.10599
374 +   spill R26 -&gt; R22	# spill size = 64
378 +   spill R8 -&gt; R26	# spill size = 64

37c     B40: #	out( B68 B41 ) &lt;- in( B39 B76 B77 B74 B73 B72 B78 )  Freq: 2.35413
37c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
37c     ld  R7, [R23, #920]	# ptr, #@loadP
380 +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.util.HashMap::resize @ bci:306 (line 733) L[0]=sp + #40 L[1]=sp + #48 L[2]=sp + #56 L[3]=_ L[4]=sp + #60 L[5]=_ L[6]=R21 L[7]=R9 L[8]=R20 L[9]=R29 L[10]=R26 L[11]=R25 L[12]=R22 L[13]=_ STK[0]=R20
        # OopMap {x29=Oop esp=Oop xdispatch=Oop xbcp=Oop xmonitors=Oop xcpool=Oop [40]=Oop [48]=Oop off=896/0x380}
384 +   bne   R20, zr, B68	#@cmpP_imm0_branch  P=0.554679 C=4819.000000

388     B41: #	out( B48 B42 ) &lt;- in( B40 )  Freq: 1.04834
388 +   beq   R26, zr, B48	#@cmpP_imm0_branch  P=0.209692 C=2146.000000

38c     B42: #	out( B92 B43 ) &lt;- in( B41 )  Freq: 0.828515
38c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
38c     lb  R28, [R23, #56]	# byte, #@loadB
390 +   bne  R28, zr, B92	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

394     B43: #	out( B123 B44 ) &lt;- in( B126 B94 B92 B42 )  Freq: 0.828515
394 +   add R7, R21, R19	# ptr, #@addP_reg_reg
398 +   sw  rheapbase, [R26, #24]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/util/HashMap$Node.next
39c     spill [sp, #60] -&gt; R28	# spill size = 32
3a0 +   bgeu  R9, R28, B123	#@cmpU_branch  P=0.000001 C=-1.000000

3a4     B44: #	out( B95 B45 ) &lt;- in( B43 )  Freq: 0.828514
3a4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3a4     lb  R28, [R23, #56]	# byte, #@loadB
3a8 +   addi  R20, R7, #16	# ptr, #@addP_reg_imm
3ac +   bne  R28, zr, B95	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

3b0     B45: #	out( B48 B46 ) &lt;- in( B127 B97 B95 B44 )  Freq: 0.828514
3b0 +   mv  R28, R20	# ptr -&gt; long, #@castP2X
3b4 +   mv  R7, R29	# ptr -&gt; long, #@castP2X
3b8 +   xorr  R7, R7, R28	#@xorL_reg_reg
3bc +   encode_heap_oop  R31, R29	#@encodeHeapOop
3c0 +   srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
3c4 +   sw  R31, [R20]	# compressed ptr, #@storeN
3c8 +   beq  R7, zr, B48	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

3cc     B46: #	out( B48 B47 ) &lt;- in( B45 )  Freq: 0.827685
3cc +   beq   R29, zr, B48	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

3d0     B47: #	out( B98 B48 ) &lt;- in( B46 )  Freq: 0.826858
3d0 +   srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
3d4 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
3e0 +   add R10, R28, R7	# ptr, #@addP_reg_reg
3e4 +   lb  R7, [R10]	# byte, #@loadB
3e8 +   li R29, #4	# int, #@loadConI
3ec +   bne  R7, R29, B98	#@cmpI_branch  P=0.001000 C=-1.000000

3f0     B48: #	out( B55 B49 ) &lt;- in( B100 B101 B98 B47 B46 B45 B41 )  Freq: 1.04834
3f0 +   beq   R22, zr, B55	#@cmpP_imm0_branch  P=0.247437 C=2146.000000

3f4     B49: #	out( B102 B50 ) &lt;- in( B48 )  Freq: 0.788945
3f4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3f4     lb  R28, [R23, #56]	# byte, #@loadB
3f8 +   bne  R28, zr, B102	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

3fc     B50: #	out( B124 B51 ) &lt;- in( B128 B104 B102 B49 )  Freq: 0.788945
3fc +   spill [sp, #72] -&gt; R7	# spill size = 64
400 +   add  R7, R7, R18	#@addL_reg_reg
404 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
408     spill [sp, #56] -&gt; R28	# spill size = 32
40c +   addw  R8, R9, R28	#@addI_reg_reg
410 +   add R7, R21, R7	# ptr, #@addP_reg_reg
414 +   sw  rheapbase, [R22, #24]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/util/HashMap$Node.next
418     spill [sp, #60] -&gt; R29	# spill size = 32
41c +   bgeu  R8, R29, B124	#@cmpU_branch  P=0.000001 C=-1.000000

420     B51: #	out( B105 B52 ) &lt;- in( B50 )  Freq: 0.788944
420 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
420     lb  R28, [R23, #56]	# byte, #@loadB
424 +   addi  R20, R7, #16	# ptr, #@addP_reg_imm
428 +   bne  R28, zr, B105	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

42c     B52: #	out( B55 B53 ) &lt;- in( B129 B107 B105 B51 )  Freq: 0.788944
42c +   mv  R28, R20	# ptr -&gt; long, #@castP2X
430 +   mv  R7, R25	# ptr -&gt; long, #@castP2X
434 +   xorr  R7, R7, R28	#@xorL_reg_reg
438 +   encode_heap_oop  R30, R25	#@encodeHeapOop
43c +   srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
440 +   sw  R30, [R20]	# compressed ptr, #@storeN
444 +   beq  R7, zr, B55	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

448     B53: #	out( B55 B54 ) &lt;- in( B52 )  Freq: 0.788155
448 +   beq   R25, zr, B55	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

44c     B54: #	out( B108 B55 ) &lt;- in( B53 )  Freq: 0.787367
44c +   srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
450 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
45c +   add R10, R28, R7	# ptr, #@addP_reg_reg
460 +   lb  R7, [R10]	# byte, #@loadB
464 +   li R28, #4	# int, #@loadConI
468 +   bne  R7, R28, B108	#@cmpI_branch  P=0.001000 C=-1.000000

46c     B55: #	out( B18 B56 ) &lt;- in( B56 B110 B111 B108 B54 B53 B52 B48 B66 B67 B64 B63 B62 ) top-of-loop Freq: 5.72242
46c +   addiw  R9, R9, #1	#@addI_reg_imm
470 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
470     ld  R7, [R23, #920]	# ptr, #@loadP
474 +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.util.HashMap::resize @ bci:350 (line 705) L[0]=sp + #40 L[1]=sp + #48 L[2]=sp + #56 L[3]=_ L[4]=sp + #60 L[5]=_ L[6]=R21 L[7]=R9 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_
        # OopMap {xdispatch=Oop [40]=Oop [48]=Oop off=1140/0x474}
478 +   spill [sp, #56] -&gt; R28	# spill size = 32
47c +   bge  R9, R28, B18	#@cmpI_loop  P=0.032540 C=11714.000000

480     B56: #	out( B55 B57 ) &lt;- in( B29 B55 ) Loop( B56-B55 ) Freq: 5.72242
480 +   addw  R18, R9, zr	#@convI2L_reg_reg
484 +   slli  R19, R18, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
488     spill [sp, #48] -&gt; R7	# spill size = 64
48c +   add R25, R7, R19	# ptr, #@addP_reg_reg
490 +   lwu  R24, [R25, #16]	# loadN, compressed ptr, #@loadN
494 +   decode_heap_oop  R26, R24	#@decodeHeapOop
498 +   beq   R26, zr, B55	#@cmpP_imm0_branch  P=0.451340 C=11714.000000

49c     B57: #	out( B79 B58 ) &lt;- in( B56 )  Freq: 3.13966
49c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
49c     lb  R7, [R23, #56]	# byte, #@loadB
4a0 +   bne  R7, zr, B79	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

4a4     B58: #	out( B61 B59 ) &lt;- in( B120 B81 B79 B57 )  Freq: 3.13966
4a4 +   lwu  R28, [R26, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
4a8 +   lw  R7, [R26, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
4ac +   sw  rheapbase, [R25, #16]	# compressed ptr (rheapbase==0), #@storeImmN0
4b0 +   beq   R28, zr, B61	#@cmpP_narrowOop_imm0_branch  P=0.666096 C=6427.000000

4b4     B59: #	out( B121 B60 ) &lt;- in( B58 )  Freq: 1.04835
4b4 +   lwu  R29, [R26, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
4b8 +   mv  R31, narrowklass: precise klass java/util/HashMap$TreeNode: 0x00000040d07780b0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
4c8 +   beq  R29, R31, B121	#@cmpN_branch  P=0.000001 C=-1.000000

4cc     B60: #	out( B69 ) &lt;- in( B59 )  Freq: 1.04834
4cc +   mv  R8, NULL	# NULL ptr, #@loadConP0
4d0 +   mv  R22, NULL	# NULL ptr, #@loadConP0
4d4 +   mv  R29, NULL	# NULL ptr, #@loadConP0
4d8 +   mv  R25, NULL	# NULL ptr, #@loadConP0
4dc +   j  B69	#@branch

4e0     B61: #	out( B82 B62 ) &lt;- in( B58 )  Freq: 2.09132
4e0 +   spill [sp, #64] -&gt; R29	# spill size = 32
4e4 +   andr  R28, R29, R7	#@andI_reg_reg
4e8 +   addw  R7, R28, zr	#@convI2L_reg_reg
4ec +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
4f0 +   add R7, R21, R7	# ptr, #@addP_reg_reg
4f4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
4f4     lb  R28, [R23, #56]	# byte, #@loadB
4f8 +   addi  R20, R7, #16	# ptr, #@addP_reg_imm
4fc +   bne  R28, zr, B82	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

500     B62: #	out( B55 B63 ) &lt;- in( B122 B84 B82 B61 )  Freq: 2.09132
500 +   mv  R7, R20	# ptr -&gt; long, #@castP2X
504 +   mv  R28, R26	# ptr -&gt; long, #@castP2X
508 +   xorr  R28, R28, R7	#@xorL_reg_reg
50c +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
510 +   sw  R24, [R20]	# compressed ptr, #@storeN
514 +   beq  R28, zr, B55	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

518     B63: #	out( B55 B64 ) &lt;- in( B62 )  Freq: 2.08923
518 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
51c +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
528 +   add R10, R28, R7	# ptr, #@addP_reg_reg
52c +   lb  R28, [R10]	# byte, #@loadB
530 +   li R7, #4	# int, #@loadConI
534 +   beq  R28, R7, B55	#@cmpI_branch  P=0.999000 C=-1.000000

538     B64: #	out( B55 B65 ) &lt;- in( B63 )  Freq: 0.00208923
538 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
538     ld  R7, [R23, #64]	# int, #@loadL
53c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
53c     ld  R28, [R23, #80]	# ptr, #@loadP
540 +   #@membar_volatile
	fence iorw iorw
544 +   lb  R29, [R10]	# byte, #@loadB
548 +   beq  R29, zr, B55	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

54c     B65: #	out( B67 B66 ) &lt;- in( B64 )  Freq: 0.00104461
54c +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
550 +   bne  R7, zr, B67	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

554     B66: #	out( B55 ) &lt;- in( B65 )  Freq: 0.000522307
554 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
554     spill R23 -&gt; R11	# spill size = 64
558 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
588 +   j  B55	#@branch

58c     B67: #	out( B55 ) &lt;- in( B65 )  Freq: 0.000522307
58c +   add R28, R28, R7	# ptr, #@addP_reg_reg
590 +   addi  R7, R7, #-8	#@addL_reg_imm
594 +   sd  R10, [R28, #-8]	# ptr, #@storeP
598 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
598     sd  R7, [R23, #64]	# long, #@storeL
59c +   j  B55	#@branch

5a0     B68: #	out( B69 ) &lt;- in( B40 )  Freq: 1.30579
5a0 +   lw  R7, [R20, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
5a4 +   lwu  R28, [R20, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
5a8     spill R26 -&gt; R8	# spill size = 64
5ac +   encode_heap_oop  R24, R20	#@encodeHeapOop
5b0     spill R20 -&gt; R26	# spill size = 64

5b4     B69: #	out( B30 B70 ) &lt;- in( B60 B68 ) Loop( B69-B68 inner ) Freq: 2.35413
5b4 +   spill [sp, #56] -&gt; R31	# spill size = 32
5b8 +   andr  R30, R7, R31	#@andI_reg_reg
5bc +   decode_heap_oop  R20, R28	#@decodeHeapOop
5c0 +   bne  R30, zr, B30	#@cmpI_reg_imm0_branch  P=0.469807 C=4819.000000

5c4     B70: #	out( B78 B71 ) &lt;- in( B69 )  Freq: 1.24815
5c4 +   beq   R8, zr, B78	#@cmpP_imm0_branch  P=0.663796 C=2555.000000

5c8     B71: #	out( B112 B72 ) &lt;- in( B70 )  Freq: 0.419631
5c8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5c8     lb  R28, [R23, #56]	# byte, #@loadB
5cc +   bne  R28, zr, B112	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

5d0     B72: #	out( B40 B73 ) &lt;- in( B132 B114 B112 B71 )  Freq: 0.419631
5d0 +   mv  R7, R8	# ptr -&gt; long, #@castP2X
5d4 +   mv  R28, R26	# ptr -&gt; long, #@castP2X
5d8 +   xorr  R28, R28, R7	#@xorL_reg_reg
5dc +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
5e0 +   sw  R24, [R8, #24]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.next
5e4 +   beq  R28, zr, B40	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

5e8     B73: #	out( B40 B74 ) &lt;- in( B72 )  Freq: 0.419211
5e8 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
5ec +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
5f8 +   add R10, R28, R7	# ptr, #@addP_reg_reg
5fc +   lb  R28, [R10]	# byte, #@loadB
600 +   li R7, #4	# int, #@loadConI
604 +   beq  R28, R7, B40	#@cmpI_branch  P=0.999000 C=-1.000000

608     B74: #	out( B40 B75 ) &lt;- in( B73 )  Freq: 0.000419211
608 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
608     ld  R28, [R23, #64]	# int, #@loadL
60c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
60c     ld  R30, [R23, #80]	# ptr, #@loadP
610 +   #@membar_volatile
	fence iorw iorw
614 +   lb  R7, [R10]	# byte, #@loadB
618 +   beq  R7, zr, B40	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

61c     B75: #	out( B77 B76 ) &lt;- in( B74 )  Freq: 0.000209606
61c +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
620 +   bne  R28, zr, B77	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

624     B76: #	out( B40 ) &lt;- in( B75 )  Freq: 0.000104803
624 +   spill R29 -&gt; [sp, #8]	# spill size = 64
628     
628     
628 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
628     spill R23 -&gt; R11	# spill size = 64
62c +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
65c +   spill R26 -&gt; R8	# spill size = 64
660 +   spill R25 -&gt; [sp, #16]	# spill size = 64
664 +   spill R21 -&gt; R26	# spill size = 64
668 +   spill R9 -&gt; R25	# spill size = 32
66c +   spill R26 -&gt; R21	# spill size = 64
670 +   spill R22 -&gt; [sp, #0]	# spill size = 64
674 +   spill R25 -&gt; R9	# spill size = 32
678 +   spill R8 -&gt; R26	# spill size = 64
67c +   spill [sp, #0] -&gt; R22	# spill size = 64
680 +   spill [sp, #8] -&gt; R29	# spill size = 64
684 +   spill [sp, #16] -&gt; R25	# spill size = 64
688 +   j  B40	#@branch

68c     B77: #	out( B40 ) &lt;- in( B75 )  Freq: 0.000104803
68c +   add R7, R30, R28	# ptr, #@addP_reg_reg
690 +   sd  R10, [R7, #-8]	# ptr, #@storeP
694 +   addi  R7, R28, #-8	#@addL_reg_imm
698 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
698     sd  R7, [R23, #64]	# long, #@storeL
69c +   j  B40	#@branch

6a0     B78: #	out( B40 ) &lt;- in( B70 )  Freq: 0.828515
6a0 +   spill R26 -&gt; R29	# spill size = 64
6a4 +   j  B40	#@branch

6a8     B79: #	out( B58 B80 ) &lt;- in( B57 )  Freq: 0.00313962
6a8 +   lwu  R28, [R25, #16]	# loadN, compressed ptr, #@loadN
6ac +   decode_heap_oop  R10, R28	#@decodeHeapOop
6b0 +   beq   R10, zr, B58	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

6b4     B80: #	out( B120 B81 ) &lt;- in( B79 )  Freq: 0.00156981
6b4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6b4     ld  R7, [R23, #32]	# int, #@loadL
6b8 +   beq  R7, zr, B120	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

6bc     B81: #	out( B58 ) &lt;- in( B80 )  Freq: 0.00156824
6bc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6bc     ld  R28, [R23, #48]	# ptr, #@loadP
6c0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
6c4 +   addi  R7, R7, #-8	#@addL_reg_imm
6c8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
6cc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6cc     sd  R7, [R23, #32]	# long, #@storeL
6d0 +   j  B58	#@branch

6d4     B82: #	out( B62 B83 ) &lt;- in( B61 )  Freq: 0.00209129
6d4 +   lwu  R28, [R20]	# loadN, compressed ptr, #@loadN
6d8 +   decode_heap_oop  R10, R28	#@decodeHeapOop
6dc +   beq   R10, zr, B62	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

6e0     B83: #	out( B122 B84 ) &lt;- in( B82 )  Freq: 0.00104565
6e0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6e0     ld  R7, [R23, #32]	# int, #@loadL
6e4 +   beq  R7, zr, B122	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

6e8     B84: #	out( B62 ) &lt;- in( B83 )  Freq: 0.0010446
6e8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6e8     ld  R28, [R23, #48]	# ptr, #@loadP
6ec +   add R28, R28, R7	# ptr, #@addP_reg_reg
6f0 +   addi  R7, R7, #-8	#@addL_reg_imm
6f4 +   sd  R10, [R28, #-8]	# ptr, #@storeP
6f8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6f8     sd  R7, [R23, #32]	# long, #@storeL
6fc +   j  B62	#@branch

700     B85: #	out( B15 B86 ) &lt;- in( B14 )  Freq: 0.000999986
700 +   spill [sp, #40] -&gt; R7	# spill size = 64
704 +   lwu  R7, [R7, #36]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap.table
708 +   decode_heap_oop  R10, R7	#@decodeHeapOop
70c +   beq   R10, zr, B15	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

710     B86: #	out( B125 B87 ) &lt;- in( B85 )  Freq: 0.000499993
710 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
710     ld  R7, [R23, #32]	# int, #@loadL
714 +   beq  R7, zr, B125	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

718     B87: #	out( B15 ) &lt;- in( B86 )  Freq: 0.000499493
718 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
718     ld  R28, [R23, #48]	# ptr, #@loadP
71c +   add R28, R28, R7	# ptr, #@addP_reg_reg
720 +   addi  R7, R7, #-8	#@addL_reg_imm
724 +   sd  R10, [R28, #-8]	# ptr, #@storeP
728 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
728     sd  R7, [R23, #32]	# long, #@storeL
72c +   j  B15	#@branch

730     B88: #	out( B17 B89 ) &lt;- in( B16 )  Freq: 0.000998999
730 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
730     ld  R7, [R23, #64]	# int, #@loadL
734 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
734     ld  R28, [R23, #80]	# ptr, #@loadP
738 +   #@membar_volatile
	fence iorw iorw
73c +   lb  R29, [R10]	# byte, #@loadB
740 +   beq  R29, zr, B17	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

744     B89: #	out( B91 B90 ) &lt;- in( B88 )  Freq: 0.0004995
744 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
748 +   bne  R7, zr, B91	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

74c     B90: #	out( B17 ) &lt;- in( B89 )  Freq: 0.00024975
74c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
74c     spill R23 -&gt; R11	# spill size = 64
750 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
780 +   j  B17	#@branch

784     B91: #	out( B17 ) &lt;- in( B89 )  Freq: 0.00024975
784 +   add R28, R28, R7	# ptr, #@addP_reg_reg
788 +   addi  R7, R7, #-8	#@addL_reg_imm
78c +   sd  R10, [R28, #-8]	# ptr, #@storeP
790 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
790     sd  R7, [R23, #64]	# long, #@storeL
794 +   j  B17	#@branch

798     B92: #	out( B43 B93 ) &lt;- in( B42 )  Freq: 0.000828504
798 +   lwu  R7, [R26, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
79c +   decode_heap_oop  R10, R7	#@decodeHeapOop
7a0 +   beq   R10, zr, B43	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

7a4     B93: #	out( B126 B94 ) &lt;- in( B92 )  Freq: 0.000414252
7a4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7a4     ld  R7, [R23, #32]	# int, #@loadL
7a8 +   beq  R7, zr, B126	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

7ac     B94: #	out( B43 ) &lt;- in( B93 )  Freq: 0.000413838
7ac +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7ac     ld  R28, [R23, #48]	# ptr, #@loadP
7b0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
7b4 +   addi  R7, R7, #-8	#@addL_reg_imm
7b8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
7bc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7bc     sd  R7, [R23, #32]	# long, #@storeL
7c0 +   j  B43	#@branch

7c4     B95: #	out( B45 B96 ) &lt;- in( B44 )  Freq: 0.000828503
7c4 +   lwu  R28, [R20]	# loadN, compressed ptr, #@loadN
7c8 +   decode_heap_oop  R10, R28	#@decodeHeapOop
7cc +   beq   R10, zr, B45	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

7d0     B96: #	out( B127 B97 ) &lt;- in( B95 )  Freq: 0.000414252
7d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7d0     ld  R7, [R23, #32]	# int, #@loadL
7d4 +   beq  R7, zr, B127	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

7d8     B97: #	out( B45 ) &lt;- in( B96 )  Freq: 0.000413837
7d8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7d8     ld  R28, [R23, #48]	# ptr, #@loadP
7dc +   add R28, R28, R7	# ptr, #@addP_reg_reg
7e0 +   addi  R7, R7, #-8	#@addL_reg_imm
7e4 +   sd  R10, [R28, #-8]	# ptr, #@storeP
7e8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7e8     sd  R7, [R23, #32]	# long, #@storeL
7ec +   j  B45	#@branch

7f0     B98: #	out( B48 B99 ) &lt;- in( B47 )  Freq: 0.000826858
7f0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7f0     ld  R7, [R23, #64]	# int, #@loadL
7f4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7f4     ld  R28, [R23, #80]	# ptr, #@loadP
7f8 +   #@membar_volatile
	fence iorw iorw
7fc +   lb  R30, [R10]	# byte, #@loadB
800 +   beq  R30, zr, B48	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

804     B99: #	out( B101 B100 ) &lt;- in( B98 )  Freq: 0.000413429
804 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
808 +   bne  R7, zr, B101	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

80c     B100: #	out( B48 ) &lt;- in( B99 )  Freq: 0.000206714
80c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
80c     spill R23 -&gt; R11	# spill size = 64
810 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
840 +   j  B48	#@branch

844     B101: #	out( B48 ) &lt;- in( B99 )  Freq: 0.000206714
844 +   add R28, R28, R7	# ptr, #@addP_reg_reg
848 +   addi  R7, R7, #-8	#@addL_reg_imm
84c +   sd  R10, [R28, #-8]	# ptr, #@storeP
850 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
850     sd  R7, [R23, #64]	# long, #@storeL
854 +   j  B48	#@branch

858     B102: #	out( B50 B103 ) &lt;- in( B49 )  Freq: 0.000788935
858 +   lwu  R7, [R22, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
85c +   decode_heap_oop  R10, R7	#@decodeHeapOop
860 +   beq   R10, zr, B50	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

864     B103: #	out( B128 B104 ) &lt;- in( B102 )  Freq: 0.000394467
864 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
864     ld  R7, [R23, #32]	# int, #@loadL
868 +   beq  R7, zr, B128	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

86c     B104: #	out( B50 ) &lt;- in( B103 )  Freq: 0.000394073
86c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
86c     ld  R28, [R23, #48]	# ptr, #@loadP
870 +   add R28, R28, R7	# ptr, #@addP_reg_reg
874 +   addi  R7, R7, #-8	#@addL_reg_imm
878 +   sd  R10, [R28, #-8]	# ptr, #@storeP
87c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
87c     sd  R7, [R23, #32]	# long, #@storeL
880 +   j  B50	#@branch

884     B105: #	out( B52 B106 ) &lt;- in( B51 )  Freq: 0.000788934
884 +   lwu  R28, [R20]	# loadN, compressed ptr, #@loadN
888 +   decode_heap_oop  R10, R28	#@decodeHeapOop
88c +   beq   R10, zr, B52	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

890     B106: #	out( B129 B107 ) &lt;- in( B105 )  Freq: 0.000394467
890 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
890     ld  R7, [R23, #32]	# int, #@loadL
894 +   beq  R7, zr, B129	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

898     B107: #	out( B52 ) &lt;- in( B106 )  Freq: 0.000394072
898 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
898     ld  R28, [R23, #48]	# ptr, #@loadP
89c +   add R28, R28, R7	# ptr, #@addP_reg_reg
8a0 +   addi  R7, R7, #-8	#@addL_reg_imm
8a4 +   sd  R10, [R28, #-8]	# ptr, #@storeP
8a8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8a8     sd  R7, [R23, #32]	# long, #@storeL
8ac +   j  B52	#@branch

8b0     B108: #	out( B55 B109 ) &lt;- in( B54 )  Freq: 0.000787367
8b0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8b0     ld  R7, [R23, #64]	# int, #@loadL
8b4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8b4     ld  R28, [R23, #80]	# ptr, #@loadP
8b8 +   #@membar_volatile
	fence iorw iorw
8bc +   lb  R30, [R10]	# byte, #@loadB
8c0 +   beq  R30, zr, B55	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

8c4     B109: #	out( B111 B110 ) &lt;- in( B108 )  Freq: 0.000393683
8c4 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
8c8 +   bne  R7, zr, B111	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

8cc     B110: #	out( B55 ) &lt;- in( B109 )  Freq: 0.000196842
8cc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8cc     spill R23 -&gt; R11	# spill size = 64
8d0 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
900 +   j  B55	#@branch

904     B111: #	out( B55 ) &lt;- in( B109 )  Freq: 0.000196842
904 +   add R28, R28, R7	# ptr, #@addP_reg_reg
908 +   addi  R7, R7, #-8	#@addL_reg_imm
90c +   sd  R10, [R28, #-8]	# ptr, #@storeP
910 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
910     sd  R7, [R23, #64]	# long, #@storeL
914 +   j  B55	#@branch

918     B112: #	out( B72 B113 ) &lt;- in( B71 )  Freq: 0.000419626
918 +   lwu  R7, [R8, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
91c +   decode_heap_oop  R10, R7	#@decodeHeapOop
920 +   beq   R10, zr, B72	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

924     B113: #	out( B132 B114 ) &lt;- in( B112 )  Freq: 0.000209813
924 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
924     ld  R7, [R23, #32]	# int, #@loadL
928 +   beq  R7, zr, B132	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

92c     B114: #	out( B72 ) &lt;- in( B113 )  Freq: 0.000209603
92c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
92c     ld  R28, [R23, #48]	# ptr, #@loadP
930 +   add R28, R28, R7	# ptr, #@addP_reg_reg
934 +   addi  R7, R7, #-8	#@addL_reg_imm
938 +   sd  R10, [R28, #-8]	# ptr, #@storeP
93c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
93c     sd  R7, [R23, #32]	# long, #@storeL
940 +   j  B72	#@branch

944     B115: #	out( B32 B116 ) &lt;- in( B31 )  Freq: 0.00031704
944 +   lwu  R28, [R22, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
948 +   decode_heap_oop  R10, R28	#@decodeHeapOop
94c +   beq   R10, zr, B32	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

950     B116: #	out( B135 B117 ) &lt;- in( B115 )  Freq: 0.00015852
950 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
950     ld  R7, [R23, #32]	# int, #@loadL
954 +   beq  R7, zr, B135	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

958     B117: #	out( B32 ) &lt;- in( B116 )  Freq: 0.000158361
958 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
958     ld  R28, [R23, #48]	# ptr, #@loadP
95c +   add R28, R28, R7	# ptr, #@addP_reg_reg
960 +   addi  R7, R7, #-8	#@addL_reg_imm
964 +   sd  R10, [R28, #-8]	# ptr, #@storeP
968 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
968     sd  R7, [R23, #32]	# long, #@storeL
96c +   j  B32	#@branch

970     B118: #	out( B138 B119 ) &lt;- in( B11 B12 )  Freq: 0.00010103
970 +   mv  R11, precise klass [Ljava/util/HashMap$Node;: 0x00000040d03fa720:Constant:exact *	# ptr, #@loadConP
988     spill [sp, #24] -&gt; R12	# spill size = 32
98c +   spill [sp, #40] -&gt; R8	# spill size = 64
990     CALL,static 0x000000401390d640	#@CallStaticJavaDirect wrapper for: _new_array_Java
        # java.util.HashMap::resize @ bci:133 (line 702) L[0]=R8 L[1]=sp + #48 L[2]=sp + #56 L[3]=_ L[4]=sp + #24 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_
        # OopMap {fp=Oop [40]=Oop [48]=Oop off=2452/0x994}

994     B119: #	out( B14 ) &lt;- in( B118 )  Freq: 0.000101028
        # Block is sole successor of call
994 +   spill R10 -&gt; R21	# spill size = 64
998 +   j  B14	#@branch

99c     B120: #	out( B58 ) &lt;- in( B80 )  Freq: 1.56979e-06
99c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
99c     spill R23 -&gt; R11	# spill size = 64
9a0 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
9d0 +   spill R26 -&gt; [sp, #0]	# spill size = 64
9d4 +   spill R21 -&gt; R26	# spill size = 64
9d8 +   spill R9 -&gt; R21	# spill size = 32
9dc +   spill R21 -&gt; R9	# spill size = 32
9e0 +   spill R26 -&gt; R21	# spill size = 64
9e4 +   spill [sp, #0] -&gt; R26	# spill size = 64
9e8 +   j  B58	#@branch

9ec     B121: #	out( N2090 ) &lt;- in( B59 )  Freq: 1.06227e-06
9ec +   li R11, #-187	# int, #@loadConI
9f0     spill R21 -&gt; [sp, #16]	# spill size = 64
9f4 +   spill R9 -&gt; [sp, #24]	# spill size = 32
9f8 +   spill R26 -&gt; [sp, #32]	# spill size = 64
9fc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::resize @ bci:203 (line 711) L[0]=sp + #40 L[1]=sp + #48 L[2]=sp + #56 L[3]=_ L[4]=sp + #60 L[5]=_ L[6]=sp + #16 L[7]=sp + #24 L[8]=sp + #32 L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ STK[0]=#1
        # OopMap {[16]=Oop [32]=Oop [40]=Oop [48]=Oop off=2560/0xa00}
a00     #@ShouldNotReachHere

a0c     B122: #	out( B62 ) &lt;- in( B83 )  Freq: 1.04563e-06
a0c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
a0c     spill R23 -&gt; R11	# spill size = 64
a10 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
a40 +   j  B62	#@branch

a44     B123: #	out( N2090 ) &lt;- in( B43 )  Freq: 8.39517e-07
a44 +   spill [sp, #48] -&gt; R7	# spill size = 64
a48 +   spill R7 -&gt; [sp, #0]	# spill size = 64
a4c +   spill [sp, #56] -&gt; R28	# spill size = 32
a50 +   spill [sp, #60] -&gt; R7	# spill size = 32
a54 +   spill [sp, #40] -&gt; R8	# spill size = 64
a58 +   li R11, #-28	# int, #@loadConI
a5c     spill R28 -&gt; [sp, #8]	# spill size = 32
a60 +   spill R7 -&gt; [sp, #12]	# spill size = 32
a64 +   spill R25 -&gt; [sp, #32]	# spill size = 64
a68 +   spill R22 -&gt; [sp, #40]	# spill size = 64
a6c +   spill R21 -&gt; [sp, #48]	# spill size = 64
a70 +   spill R9 -&gt; [sp, #28]	# spill size = 32
a74 +   spill R29 -&gt; [sp, #56]	# spill size = 64
a78     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.HashMap::resize @ bci:326 (line 736) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=_ L[4]=sp + #12 L[5]=_ L[6]=sp + #48 L[7]=sp + #28 L[8]=_ L[9]=_ L[10]=_ L[11]=sp + #32 L[12]=sp + #40 L[13]=_ STK[0]=sp + #48 STK[1]=sp + #28 STK[2]=sp + #56
        # OopMap {fp=Oop [0]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=2684/0xa7c}
a7c     #@ShouldNotReachHere

a88     B124: #	out( N2090 ) &lt;- in( B50 )  Freq: 7.99421e-07
a88 +   spill [sp, #40] -&gt; R7	# spill size = 64
a8c +   spill R7 -&gt; [sp, #0]	# spill size = 64
a90 +   spill [sp, #48] -&gt; R7	# spill size = 64
a94 +   li R11, #-28	# int, #@loadConI
a98     spill R7 -&gt; [sp, #8]	# spill size = 64
a9c +   spill R9 -&gt; [sp, #32]	# spill size = 32
aa0 +   spill R21 -&gt; [sp, #40]	# spill size = 64
aa4 +   spill R25 -&gt; [sp, #48]	# spill size = 64
aa8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.HashMap::resize @ bci:346 (line 740) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #56 L[3]=_ L[4]=sp + #60 L[5]=_ L[6]=sp + #40 L[7]=sp + #32 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ STK[0]=sp + #40 STK[1]=R8 STK[2]=sp + #48
        # OopMap {[0]=Oop [8]=Oop [40]=Oop [48]=Oop off=2732/0xaac}
aac     #@ShouldNotReachHere

ab8     B125: #	out( B15 ) &lt;- in( B86 )  Freq: 4.99987e-07
ab8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
ab8     spill R23 -&gt; R11	# spill size = 64
abc +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
aec +   j  B15	#@branch

af0     B126: #	out( B43 ) &lt;- in( B93 )  Freq: 4.14247e-07
af0 +   spill R29 -&gt; [sp, #0]	# spill size = 64
af4     
af4     
af4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
af4     spill R23 -&gt; R11	# spill size = 64
af8 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
b28 +   spill R25 -&gt; [sp, #8]	# spill size = 64
b2c +   spill R21 -&gt; R25	# spill size = 64
b30 +   spill R9 -&gt; R24	# spill size = 32
b34 +   spill R22 -&gt; R8	# spill size = 64
b38 +   spill R25 -&gt; R21	# spill size = 64
b3c +   spill R24 -&gt; R9	# spill size = 32
b40 +   spill R8 -&gt; R22	# spill size = 64
b44 +   spill [sp, #0] -&gt; R29	# spill size = 64
b48 +   spill [sp, #8] -&gt; R25	# spill size = 64
b4c +   j  B43	#@branch

b50     B127: #	out( B45 ) &lt;- in( B96 )  Freq: 4.14246e-07
b50 +   spill R29 -&gt; R8	# spill size = 64
b54     
b54     
b54 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
b54     spill R23 -&gt; R11	# spill size = 64
b58 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
b88 +   spill R21 -&gt; R24	# spill size = 64
b8c +   spill R9 -&gt; R21	# spill size = 32
b90 +   spill R21 -&gt; R9	# spill size = 32
b94 +   spill R22 -&gt; R26	# spill size = 64
b98 +   spill R25 -&gt; [sp, #0]	# spill size = 64
b9c +   spill R24 -&gt; R21	# spill size = 64
ba0 +   spill R26 -&gt; R22	# spill size = 64
ba4 +   spill R8 -&gt; R29	# spill size = 64
ba8 +   spill [sp, #0] -&gt; R25	# spill size = 64
bac +   j  B45	#@branch

bb0     B128: #	out( B50 ) &lt;- in( B103 )  Freq: 3.94462e-07
bb0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
bb0     spill R23 -&gt; R11	# spill size = 64
bb4 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
be4 +   j  B50	#@branch

be8     B129: #	out( B52 ) &lt;- in( B106 )  Freq: 3.94462e-07
be8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
be8     spill R23 -&gt; R11	# spill size = 64
bec +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
c1c +   j  B52	#@branch

c20     B130: #	out( N2090 ) &lt;- in( B9 )  Freq: 2.57694e-07
c20 +   flt.s  R28, F2, F0	#@cmpF3_reg_reg
	bgtz   R28, done
	feq.s  R28, F0, F2
	addi   R28, R28, -1	#@cmpF3_reg_reg
c30 +   subw  R8, x0, R28	# int, #@negI_reg
c34     spill F2 -&gt; [sp, #0]	# spill size = 32
c38 +   li R11, #-187	# int, #@loadConI
c3c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::resize @ bci:112 (line 697) L[0]=sp + #40 L[1]=sp + #48 L[2]=sp + #56 L[3]=_ L[4]=sp + #24 L[5]=_ L[6]=sp + #0 L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ STK[0]=R8
        # OopMap {[40]=Oop [48]=Oop off=3136/0xc40}
c40     #@ShouldNotReachHere

c4c     B131: #	out( N2090 ) &lt;- in( B8 )  Freq: 2.45756e-07
c4c +   spill F2 -&gt; [sp, #0]	# spill size = 32
c50 +   li R11, #-187	# int, #@loadConI
c54     spill [sp, #40] -&gt; R8	# spill size = 64
c58     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::resize @ bci:104 (line 697) L[0]=R8 L[1]=sp + #48 L[2]=sp + #56 L[3]=_ L[4]=sp + #24 L[5]=_ L[6]=sp + #0 L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ STK[0]=sp + #24 STK[1]=#1073741824
        # OopMap {fp=Oop [48]=Oop off=3164/0xc5c}
c5c     #@ShouldNotReachHere

c68     B132: #	out( B72 ) &lt;- in( B113 )  Freq: 2.0981e-07
c68 +   spill R29 -&gt; [sp, #24]	# spill size = 64
c6c     
c6c     
c6c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
c6c     spill R23 -&gt; R11	# spill size = 64
c70 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
ca0 +   spill R22 -&gt; [sp, #16]	# spill size = 64
ca4 +   spill R9 -&gt; R22	# spill size = 32
ca8 +   spill R21 -&gt; [sp, #0]	# spill size = 64
cac +   spill R26 -&gt; [sp, #8]	# spill size = 64
cb0 +   spill R22 -&gt; R9	# spill size = 32
cb4 +   spill R25 -&gt; [sp, #32]	# spill size = 64
cb8 +   spill [sp, #0] -&gt; R21	# spill size = 64
cbc +   spill [sp, #8] -&gt; R26	# spill size = 64
cc0 +   spill [sp, #16] -&gt; R22	# spill size = 64
cc4 +   spill [sp, #24] -&gt; R29	# spill size = 64
cc8 +   spill [sp, #32] -&gt; R25	# spill size = 64
ccc +   j  B72	#@branch

cd0     B133: #	out( N2090 ) &lt;- in( B27 B26 )  Freq: 3.74899e-07
cd0 +   li R11, #-138	# int, #@loadConI
cd4     spill [sp, #40] -&gt; R8	# spill size = 64
cd8 +   spill R21 -&gt; [sp, #16]	# spill size = 64
cdc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::resize @ bci:154 (line 705) L[0]=R8 L[1]=sp + #48 L[2]=sp + #56 L[3]=_ L[4]=sp + #60 L[5]=_ L[6]=sp + #16 L[7]=#0 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ STK[0]=#0 STK[1]=sp + #56
        # OopMap {fp=Oop [16]=Oop [48]=Oop off=3296/0xce0}
ce0     #@ShouldNotReachHere

cec     B134: #	out( N2090 ) &lt;- in( B28 )  Freq: 1.86213e-07
cec +   li R11, #-66	# int, #@loadConI
cf0     spill [sp, #40] -&gt; R8	# spill size = 64
cf4 +   spill R21 -&gt; [sp, #16]	# spill size = 64
cf8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;profile_predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::resize @ bci:154 (line 705) L[0]=R8 L[1]=sp + #48 L[2]=sp + #56 L[3]=_ L[4]=sp + #60 L[5]=_ L[6]=sp + #16 L[7]=#0 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ STK[0]=#0 STK[1]=sp + #56
        # OopMap {fp=Oop [16]=Oop [48]=Oop off=3324/0xcfc}
cfc     #@ShouldNotReachHere

d08     B135: #	out( B32 ) &lt;- in( B116 )  Freq: 1.58518e-07
d08 +   spill R29 -&gt; [sp, #24]	# spill size = 64
d0c     
d0c     
d0c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
d0c     spill R23 -&gt; R11	# spill size = 64
d10 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
d40 +   spill R22 -&gt; [sp, #16]	# spill size = 64
d44 +   spill R9 -&gt; R22	# spill size = 32
d48 +   spill R21 -&gt; [sp, #0]	# spill size = 64
d4c +   spill R26 -&gt; [sp, #8]	# spill size = 64
d50 +   spill R22 -&gt; R9	# spill size = 32
d54 +   spill R25 -&gt; [sp, #32]	# spill size = 64
d58 +   spill [sp, #0] -&gt; R21	# spill size = 64
d5c +   spill [sp, #8] -&gt; R26	# spill size = 64
d60 +   spill [sp, #16] -&gt; R22	# spill size = 64
d64 +   spill [sp, #24] -&gt; R29	# spill size = 64
d68 +   spill [sp, #32] -&gt; R25	# spill size = 64
d6c +   j  B32	#@branch

d70     B136: #	out( N2090 ) &lt;- in( B19 )  Freq: 9.17801e-08
d70 +   li R11, #-187	# int, #@loadConI
d74     spill [sp, #40] -&gt; R8	# spill size = 64
d78     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::resize @ bci:31 (line 681) L[0]=R8 L[1]=sp + #48 L[2]=sp + #56 L[3]=sp + #24 L[4]=_ L[5]=#0 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ STK[0]=sp + #56 STK[1]=#1073741824
        # OopMap {fp=Oop [48]=Oop off=3452/0xd7c}
d7c     #@ShouldNotReachHere

d88     B137: #	out( N2090 ) &lt;- in( B20 )  Freq: 9.178e-08
d88 +   li R11, #-187	# int, #@loadConI
d8c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::resize @ bci:50 (line 685) L[0]=sp + #40 L[1]=sp + #48 L[2]=sp + #56 L[3]=sp + #24 L[4]=R8 L[5]=#0 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ STK[0]=R8 STK[1]=#1073741824
        # OopMap {[40]=Oop [48]=Oop off=3472/0xd90}
d90     #@ShouldNotReachHere

d9c     B138: #	out( N2090 ) &lt;- in( B118 )  Freq: 1.0103e-09
d9c      -- 	// exception oop; no code emitted, #@CreateException
d9c +   spill R10 -&gt; R11	# spill size = 64
da0 +   # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
dac +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='606'>
----------------------- MetaData before Compile_id = 606 ------------------------
{method}
 - this oop:          0x00000040961efe88
 - method holder:     &apos;java/util/HashMap$HashIterator&apos;
 - constants:         0x00000040961ef810 constant pool [90] {0x00000040961ef810} for &apos;java/util/HashMap$HashIterator&apos; cache=0x00000040961f0040
 - access:            0xc1000010  final 
 - name:              &apos;nextNode&apos;
 - signature:         &apos;()Ljava/util/HashMap$Node;&apos;
 - max stack:         7
 - max locals:        3
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c576780
 - code size:         100
 - code start:        0x00000040961efdf0
 - code end (excl):   0x00000040961efe54
 - method data:       0x00000040964a6460
 - checked ex length: 0
 - linenumber start:  0x00000040961efe54
 - localvar length:   3
 - localvar start:    0x00000040961efe60
 - compiled code: nmethod  24400  344       3       java.util.HashMap$HashIterator::nextNode (100 bytes)

------------------------ OptoAssembly for Compile_id = 606 -----------------------
#
#  java/util/HashMap$Node * ( java/util/HashMap$HashIterator:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/HashMap$HashIterator:NotNull *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N565: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B50 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lwu  R7, [R11, #28]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$HashIterator.this$0
040 +   lwu  R18, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$HashIterator.next
044     spill R11 -&gt; R21	# spill size = 64
048 +   decode_heap_oop  R7, R7	#@decodeHeapOop
04c     lw  R7, [R7, #24]	# int, #@loadI ! Field: java/util/HashMap.modCount
050     NullCheck R7

050     B2: #	out( B48 B3 ) &lt;- in( B1 )  Freq: 0.999999
050 +   lw  R8, [R11, #12]	# int, #@loadI ! Field: java/util/HashMap$HashIterator.expectedModCount
054 +   decode_heap_oop  R20, R18	#@decodeHeapOop
058 +   bne  R7, R8, B48	#@cmpI_branch  P=0.000000 C=5119.000000

05c     B3: #	out( B49 B4 ) &lt;- in( B2 )  Freq: 0.999999
05c +   beq   R20, zr, B49	#@cmpP_imm0_branch  P=0.000000 C=5119.000000

060     B4: #	out( B30 B5 ) &lt;- in( B3 )  Freq: 0.999998
060 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
060     lb  R28, [R23, #56]	# byte, #@loadB
064 +   bne  R28, zr, B30	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

068     B5: #	out( B7 B6 ) &lt;- in( B46 B32 B30 B4 )  Freq: 0.999998
068 +   mv  R7, R21	# ptr -&gt; long, #@castP2X
06c +   mv  R28, R20	# ptr -&gt; long, #@castP2X
070 +   xorr  R28, R28, R7	#@xorL_reg_reg
074 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
078 +   li R9, #4	# int, #@loadConI
07c +   mv  R22, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
088 +   sw  R18, [R21, #24]	# compressed ptr, #@storeN ! Field: java/util/HashMap$HashIterator.current
08c +   beq  R28, zr, B7	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

090     B6: #	out( B36 B7 ) &lt;- in( B5 )  Freq: 0.998998
090 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
094 +   add R10, R22, R7	# ptr, #@addP_reg_reg
098 +   lb  R7, [R10]	# byte, #@loadB
09c +   bne  R7, R9, B36	#@cmpI_branch  P=0.001000 C=-1.000000

0a0     B7: #	out( B33 B8 ) &lt;- in( B38 B39 B36 B6 B5 )  Freq: 0.999998
0a0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0a0     lb  R28, [R23, #56]	# byte, #@loadB
0a4 +   lwu  R19, [R20, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
0a8 +   bne  R28, zr, B33	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0ac     B8: #	out( B11 B9 ) &lt;- in( B47 B35 B33 B7 )  Freq: 0.999998
0ac +   decode_heap_oop  R18, R19	#@decodeHeapOop
0b0 +   mv  R7, R21	# ptr -&gt; long, #@castP2X
0b4 +   mv  R28, R18	# ptr -&gt; long, #@castP2X
0b8 +   xorr  R28, R28, R7	#@xorL_reg_reg
0bc +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0c0 +   sw  R19, [R21, #20]	# compressed ptr, #@storeN ! Field: java/util/HashMap$HashIterator.next
0c4 +   beq  R28, zr, B11	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0c8     B9: #	out( B11 B10 ) &lt;- in( B8 )  Freq: 0.998998
0c8 +   beq   R18, zr, B11	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

0cc     B10: #	out( B40 B11 ) &lt;- in( B9 )  Freq: 0.997999
0cc +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0d0 +   add R10, R22, R7	# ptr, #@addP_reg_reg
0d4 +   lb  R28, [R10]	# byte, #@loadB
0d8 +   bne  R28, R9, B40	#@cmpI_branch  P=0.001000 C=-1.000000

0dc     B11: #	out( B22 B12 ) &lt;- in( B42 B43 B40 B10 B9 B8 )  Freq: 0.999998
0dc +   bne   R18, zr, B22	#@cmpP_imm0_branch  P=0.153350 C=5119.000000

0e0     B12: #	out( B51 B13 ) &lt;- in( B11 )  Freq: 0.846648
0e0 +   lwu  R7, [R21, #28]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$HashIterator.this$0
0e4 +   decode_heap_oop  R7, R7	#@decodeHeapOop
0e8     lwu  R28, [R7, #36]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap.table
0ec     NullCheck R7

0ec     B13: #	out( B52 B14 ) &lt;- in( B12 )  Freq: 0.846647
0ec +   lw  R29, [R21, #16]	# int, #@loadI ! Field: java/util/HashMap$HashIterator.index
0f0 +   decode_heap_oop  R8, R28	#@decodeHeapOop
0f4     lwu  R19, [R8, #12]	# range, #@loadRange
0f8     NullCheck R8

0f8     B14: #	out( B22 B15 ) &lt;- in( B13 )  Freq: 0.846647
0f8 +   bge  R29, R19, B22	#@cmpI_branch  P=0.069047 C=16496.000000
        nop 	# 2 bytes pad for loops and calls

100     B15: #	out( B44 B16 ) &lt;- in( B14 B21 ) Loop( B15-B21 inner ) Freq: 2.99998
100 +   addw  R7, R29, zr	#@convI2L_reg_reg
104 +   addiw  R28, R29, #1	#@addI_reg_imm
108 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
10c +   sw  R28, [R21, #16]	# int, #@storeI ! Field: java/util/HashMap$HashIterator.index
110 +   bgeu  R29, R19, B44	#@cmpU_branch  P=0.000001 C=-1.000000

114     B16: #	out( B23 B17 ) &lt;- in( B15 )  Freq: 2.99998
114 +   add R7, R8, R7	# ptr, #@addP_reg_reg
118 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
118     lb  R29, [R23, #56]	# byte, #@loadB
11c +   lwu  R18, [R7, #16]	# loadN, compressed ptr, #@loadN
120 +   bne  R29, zr, B23	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

124     B17: #	out( B20 B18 ) &lt;- in( B45 B25 B23 B16 )  Freq: 2.99998
124 +   decode_heap_oop  R24, R18	#@decodeHeapOop
128 +   mv  R7, R21	# ptr -&gt; long, #@castP2X
12c +   mv  R28, R24	# ptr -&gt; long, #@castP2X
130 +   xorr  R28, R28, R7	#@xorL_reg_reg
134 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
138 +   sw  R18, [R21, #20]	# compressed ptr, #@storeN ! Field: java/util/HashMap$HashIterator.next
13c +   beq  R28, zr, B20	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

140     B18: #	out( B20 B19 ) &lt;- in( B17 )  Freq: 2.99698
140 +   beq   R24, zr, B20	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

144     B19: #	out( B26 B20 ) &lt;- in( B18 )  Freq: 2.99398
144 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
148 +   add R10, R22, R7	# ptr, #@addP_reg_reg
14c +   lb  R7, [R10]	# byte, #@loadB
150 +   bne  R7, R9, B26	#@cmpI_branch  P=0.001000 C=-1.000000

154     B20: #	out( B22 B21 ) &lt;- in( B28 B29 B26 B19 B18 B17 )  Freq: 2.99998
154 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
154     ld  R7, [R23, #920]	# ptr, #@loadP
158 +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.util.HashMap$HashIterator::nextNode @ bci:95 (line 1601) L[0]=R21 L[1]=R8 L[2]=R20 STK[0]=R24
        # OopMap {esp=Oop xdispatch=Oop xlocals=Oop fp=Oop off=344/0x158}
15c +   bne   R24, zr, B22	#@cmpP_imm0_branch  P=0.208048 C=15357.000000

160     B21: #	out( B15 B22 ) &lt;- in( B20 )  Freq: 2.37584
160 +   lw  R29, [R21, #16]	# int, #@loadI ! Field: java/util/HashMap$HashIterator.index
164 +   blt  R29, R19, B15	#@cmpI_branch  P=0.930953 C=16496.000000

168     B22: #	out( N565 ) &lt;- in( B11 B21 B20 B14 )  Freq: 0.999994
168 +   spill R20 -&gt; R10	# spill size = 64
16c +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
184 +   ret	// return register, #@Ret

188     B23: #	out( B17 B24 ) &lt;- in( B16 )  Freq: 0.00299994
188 +   lwu  R7, [R21, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$HashIterator.next
18c +   decode_heap_oop  R10, R7	#@decodeHeapOop
190 +   beq   R10, zr, B17	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

194     B24: #	out( B45 B25 ) &lt;- in( B23 )  Freq: 0.00149997
194 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
194     ld  R7, [R23, #32]	# int, #@loadL
198 +   beq  R7, zr, B45	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

19c     B25: #	out( B17 ) &lt;- in( B24 )  Freq: 0.00149847
19c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
19c     ld  R28, [R23, #48]	# ptr, #@loadP
1a0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
1a4 +   addi  R7, R7, #-8	#@addL_reg_imm
1a8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
1ac +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ac     sd  R7, [R23, #32]	# long, #@storeL
1b0 +   j  B17	#@branch

1b4     B26: #	out( B20 B27 ) &lt;- in( B19 )  Freq: 0.00299398
1b4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b4     ld  R7, [R23, #64]	# int, #@loadL
1b8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b8     ld  R28, [R23, #80]	# ptr, #@loadP
1bc +   #@membar_volatile
	fence iorw iorw
1c0 +   lb  R30, [R10]	# byte, #@loadB
1c4 +   beq  R30, zr, B20	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1c8     B27: #	out( B29 B28 ) &lt;- in( B26 )  Freq: 0.00149699
1c8 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1cc +   bne  R7, zr, B29	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1d0     B28: #	out( B20 ) &lt;- in( B27 )  Freq: 0.000748495
1d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1d0     spill R23 -&gt; R11	# spill size = 64
1d4 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
204 +   j  B20	#@branch

208     B29: #	out( B20 ) &lt;- in( B27 )  Freq: 0.000748495
208 +   add R28, R28, R7	# ptr, #@addP_reg_reg
20c +   addi  R7, R7, #-8	#@addL_reg_imm
210 +   sd  R10, [R28, #-8]	# ptr, #@storeP
214 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
214     sd  R7, [R23, #64]	# long, #@storeL
218 +   j  B20	#@branch

21c     B30: #	out( B5 B31 ) &lt;- in( B4 )  Freq: 0.000999985
21c +   lwu  R7, [R11, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$HashIterator.current
220 +   decode_heap_oop  R10, R7	#@decodeHeapOop
224 +   beq   R10, zr, B5	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

228     B31: #	out( B46 B32 ) &lt;- in( B30 )  Freq: 0.000499993
228 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
228     ld  R7, [R23, #32]	# int, #@loadL
22c +   beq  R7, zr, B46	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

230     B32: #	out( B5 ) &lt;- in( B31 )  Freq: 0.000499493
230 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
230     ld  R28, [R23, #48]	# ptr, #@loadP
234 +   add R28, R28, R7	# ptr, #@addP_reg_reg
238 +   addi  R7, R7, #-8	#@addL_reg_imm
23c +   sd  R10, [R28, #-8]	# ptr, #@storeP
240 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
240     sd  R7, [R23, #32]	# long, #@storeL
244 +   j  B5	#@branch

248     B33: #	out( B8 B34 ) &lt;- in( B7 )  Freq: 0.000999985
248 +   lwu  R7, [R21, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$HashIterator.next
24c +   decode_heap_oop  R10, R7	#@decodeHeapOop
250 +   beq   R10, zr, B8	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

254     B34: #	out( B47 B35 ) &lt;- in( B33 )  Freq: 0.000499993
254 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
254     ld  R7, [R23, #32]	# int, #@loadL
258 +   beq  R7, zr, B47	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

25c     B35: #	out( B8 ) &lt;- in( B34 )  Freq: 0.000499493
25c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
25c     ld  R28, [R23, #48]	# ptr, #@loadP
260 +   add R28, R28, R7	# ptr, #@addP_reg_reg
264 +   addi  R7, R7, #-8	#@addL_reg_imm
268 +   sd  R10, [R28, #-8]	# ptr, #@storeP
26c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
26c     sd  R7, [R23, #32]	# long, #@storeL
270 +   j  B8	#@branch

274     B36: #	out( B7 B37 ) &lt;- in( B6 )  Freq: 0.000998998
274 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
274     ld  R7, [R23, #64]	# int, #@loadL
278 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
278     ld  R28, [R23, #80]	# ptr, #@loadP
27c +   #@membar_volatile
	fence iorw iorw
280 +   lb  R30, [R10]	# byte, #@loadB
284 +   beq  R30, zr, B7	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

288     B37: #	out( B39 B38 ) &lt;- in( B36 )  Freq: 0.000499499
288 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
28c +   bne  R7, zr, B39	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

290     B38: #	out( B7 ) &lt;- in( B37 )  Freq: 0.00024975
290 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
290     spill R23 -&gt; R11	# spill size = 64
294 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
2c4 +   j  B7	#@branch

2c8     B39: #	out( B7 ) &lt;- in( B37 )  Freq: 0.00024975
2c8 +   add R28, R28, R7	# ptr, #@addP_reg_reg
2cc +   addi  R7, R7, #-8	#@addL_reg_imm
2d0 +   sd  R10, [R28, #-8]	# ptr, #@storeP
2d4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2d4     sd  R7, [R23, #64]	# long, #@storeL
2d8 +   j  B7	#@branch

2dc     B40: #	out( B11 B41 ) &lt;- in( B10 )  Freq: 0.000997999
2dc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2dc     ld  R7, [R23, #64]	# int, #@loadL
2e0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2e0     ld  R28, [R23, #80]	# ptr, #@loadP
2e4 +   #@membar_volatile
	fence iorw iorw
2e8 +   lb  R29, [R10]	# byte, #@loadB
2ec +   beq  R29, zr, B11	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

2f0     B41: #	out( B43 B42 ) &lt;- in( B40 )  Freq: 0.000499
2f0 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
2f4 +   bne  R7, zr, B43	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

2f8     B42: #	out( B11 ) &lt;- in( B41 )  Freq: 0.0002495
2f8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2f8     spill R23 -&gt; R11	# spill size = 64
2fc +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
32c +   j  B11	#@branch

330     B43: #	out( B11 ) &lt;- in( B41 )  Freq: 0.0002495
330 +   add R28, R28, R7	# ptr, #@addP_reg_reg
334 +   addi  R7, R7, #-8	#@addL_reg_imm
338 +   sd  R10, [R28, #-8]	# ptr, #@storeP
33c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
33c     sd  R7, [R23, #64]	# long, #@storeL
340 +   j  B11	#@branch

344     B44: #	out( N565 ) &lt;- in( B15 )  Freq: 3.03982e-06
344 +   li R11, #-28	# int, #@loadConI
348     spill R21 -&gt; [sp, #8]	# spill size = 64
34c +   spill R29 -&gt; [sp, #16]	# spill size = 32
350 +   spill R20 -&gt; [sp, #24]	# spill size = 64
354     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.HashMap$HashIterator::nextNode @ bci:90 (line 1601) L[0]=sp + #8 L[1]=R8 L[2]=sp + #24 STK[0]=sp + #8 STK[1]=R8 STK[2]=sp + #16
        # OopMap {fp=Oop [8]=Oop [24]=Oop off=856/0x358}
358     #@ShouldNotReachHere

364     B45: #	out( B17 ) &lt;- in( B24 )  Freq: 1.49995e-06
364 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
364     spill R23 -&gt; R11	# spill size = 64
368 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
398 +   j  B17	#@branch

39c     B46: #	out( B5 ) &lt;- in( B31 )  Freq: 4.99986e-07
39c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
39c     spill R23 -&gt; R11	# spill size = 64
3a0 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
3d0 +   j  B5	#@branch

3d4     B47: #	out( B8 ) &lt;- in( B34 )  Freq: 4.99986e-07
3d4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3d4     spill R23 -&gt; R11	# spill size = 64
3d8 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
408 +   j  B8	#@branch

40c     B48: #	out( N565 ) &lt;- in( B2 )  Freq: 4.76837e-07
40c +   li R11, #-187	# int, #@loadConI
410     spill R21 -&gt; [sp, #0]	# spill size = 64
414 +   spill R20 -&gt; [sp, #8]	# spill size = 64
418 +   spill R7 -&gt; [sp, #16]	# spill size = 32
41c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap$HashIterator::nextNode @ bci:16 (line 1596) L[0]=sp + #0 L[1]=_ L[2]=sp + #8 STK[0]=sp + #16 STK[1]=R8
        # OopMap {[0]=Oop [8]=Oop off=1056/0x420}
420     #@ShouldNotReachHere

42c     B49: #	out( N565 ) &lt;- in( B3 )  Freq: 4.76836e-07
42c +   li R11, #-187	# int, #@loadConI
430     spill R21 -&gt; R8	# spill size = 64
434 +   spill R20 -&gt; [sp, #8]	# spill size = 64
438     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap$HashIterator::nextNode @ bci:28 (line 1598) L[0]=R8 L[1]=_ L[2]=sp + #8 STK[0]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=1084/0x43c}
43c     #@ShouldNotReachHere

448     B50: #	out( N565 ) &lt;- in( B1 )  Freq: 1.01328e-06
448 +   li R11, #-10	# int, #@loadConI
44c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap$HashIterator::nextNode @ bci:9 (line 1596) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # OopMap {off=1104/0x450}
450     #@ShouldNotReachHere

45c     B51: #	out( N565 ) &lt;- in( B12 )  Freq: 8.57891e-07
45c +   li R11, #-10	# int, #@loadConI
460     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap$HashIterator::nextNode @ bci:60 (line 1600) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # OopMap {off=1124/0x464}
464     #@ShouldNotReachHere

470     B52: #	out( N565 ) &lt;- in( B13 )  Freq: 4.03713e-07
470 +   li R11, #-187	# int, #@loadConI
474     spill R21 -&gt; [sp, #0]	# spill size = 64
478 +   spill R20 -&gt; [sp, #8]	# spill size = 64
47c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap$HashIterator::nextNode @ bci:65 (line 1600) L[0]=sp + #0 L[1]=R8 L[2]=sp + #8 STK[0]=R8
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=1152/0x480}
480     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='629'>
----------------------- MetaData before Compile_id = 629 ------------------------
{method}
 - this oop:          0x00000040961a4ca8
 - method holder:     &apos;java/util/HashMap&apos;
 - constants:         0x000000409619f4e0 constant pool [610] {0x000000409619f4e0} for &apos;java/util/HashMap&apos; cache=0x00000040961a4fd8
 - access:            0x81000000  
 - name:              &apos;afterNodeInsertion&apos;
 - signature:         &apos;(Z)V&apos;
 - max stack:         1
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      30
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bb30: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c5f8700
 - code size:         1
 - code start:        0x00000040961a4c88
 - code end (excl):   0x00000040961a4c89
 - method data:       0x0000004096486678
 - checked ex length: 0
 - linenumber start:  0x00000040961a4c89
 - localvar length:   2
 - localvar start:    0x00000040961a4c8e
 - compiled code: nmethod  24656  617       3       java.util.HashMap::afterNodeInsertion (1 bytes)

------------------------ OptoAssembly for Compile_id = 629 -----------------------
#
#  void ( java/util/HashMap:NotNull *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/HashMap:NotNull *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N13: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N13 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
054 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='641'>
----------------------- MetaData before Compile_id = 641 ------------------------
{method}
 - this oop:          0x0000004096432ce8
 - method holder:     &apos;java/util/zip/ZipUtils&apos;
 - constants:         0x0000004096431118 constant pool [325] {0x0000004096431118} for &apos;java/util/zip/ZipUtils&apos; cache=0x0000004096435158
 - access:            0x81000018  static final 
 - name:              &apos;SH&apos;
 - signature:         &apos;([BI)I&apos;
 - max stack:         5
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008320110: 0xba i2c: 0x00000040139438c0 c2i: 0x0000004013943908 c2iUV: 0x00000040139438d4
 - compiled entry     0x000000400c606740
 - code size:         21
 - code start:        0x0000004096432cb0
 - code end (excl):   0x0000004096432cc5
 - method data:       0x0000004096435c10
 - checked ex length: 0
 - linenumber start:  0x0000004096432cc5
 - localvar length:   2
 - localvar start:    0x0000004096432cce
 - compiled code: nmethod  25154  638       3       java.util.zip.ZipUtils::SH (21 bytes)

------------------------ OptoAssembly for Compile_id = 641 -----------------------
#
#  int ( byte[int:&gt;=0]:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: byte[int:&gt;=0]:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B7 B5 B6 B4 )  Freq: 1

000     B1: #	out( B7 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     addw  R7, R12, zr	#@convI2L_reg_reg
020     lwu  R29, [R11, #12]	# range, #@loadRange
024     NullCheck R11

024     B2: #	out( B5 B3 ) &lt;- in( B1 )  Freq: 0.999999
024 +   add R7, R11, R7	# ptr, #@addP_reg_reg
028 +   addiw  R28, R12, #1	#@addI_reg_imm
02c +   bgeu  R12, R29, B5	#@cmpU_branch  P=0.000001 C=-1.000000

030     B3: #	out( B6 B4 ) &lt;- in( B2 )  Freq: 0.999998
030 +   lbu  R8, [R7, #16]	# byte, #@loadUB
034 +   bgeu  R28, R29, B6	#@cmpU_branch  P=0.000001 C=-1.000000

038     B4: #	out( N1 ) &lt;- in( B3 )  Freq: 0.999997
038 +   lbu  R7, [R7, #17]	# byte, #@loadUB
03c +   slliw  R28, R7, (#8 &amp; 0x1f)	#@lShiftI_reg_imm
040 +   orr  R10, R28, R8	#@orI_reg_reg
044     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
05c +   ret	// return register, #@Ret

060     B5: #	out( N1 ) &lt;- in( B2 )  Freq: 1.01328e-06
060 +   spill R11 -&gt; [sp, #8]	# spill size = 64
064 +   spill R12 -&gt; [sp, #4]	# spill size = 32
068 +   li R11, #-28	# int, #@loadConI
06c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.zip.ZipUtils::SH @ bci:2 (line 203) L[0]=sp + #8 L[1]=sp + #4 STK[0]=sp + #8 STK[1]=sp + #4
        # OopMap {[8]=Oop off=112/0x70}
070     #@ShouldNotReachHere

07c     B6: #	out( N1 ) &lt;- in( B3 )  Freq: 1.01328e-06
07c +   spill R11 -&gt; [sp, #0]	# spill size = 64
080 +   spill R28 -&gt; [sp, #8]	# spill size = 32
084 +   li R11, #-28	# int, #@loadConI
088     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.zip.ZipUtils::SH @ bci:11 (line 203) L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #0 STK[2]=sp + #8
        # OopMap {[0]=Oop off=140/0x8c}
08c     #@ShouldNotReachHere

098     B7: #	out( N1 ) &lt;- in( B1 )  Freq: 1.01328e-06
098 +   li R11, #-10	# int, #@loadConI
09c     spill R12 -&gt; R8	# spill size = 32
0a0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.zip.ZipUtils::SH @ bci:2 (line 203) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8
        # OopMap {off=164/0xa4}
0a4 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='647'>
----------------------- MetaData before Compile_id = 647 ------------------------
{method}
 - this oop:          0x0000004096423570
 - method holder:     &apos;java/util/zip/ZipCoder$UTF8ZipCoder&apos;
 - constants:         0x0000004096422ea0 constant pool [64] {0x0000004096422ea0} for &apos;java/util/zip/ZipCoder$UTF8ZipCoder&apos; cache=0x00000040964236c8
 - access:            0xc1000000  
 - name:              &apos;checkedHash&apos;
 - signature:         &apos;([BII)I&apos;
 - max stack:         5
 - max locals:        7
 - size of params:    4
 - method size:       13
 - highest level:     3
 - vtable index:      12
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008316910: 0xbbaa i2c: 0x0000004013944340 c2i: 0x0000004013944390 c2iUV: 0x000000401394435c
 - compiled entry     0x000000400c606c80
 - code size:         91
 - code start:        0x00000040964234a8
 - code end (excl):   0x0000004096423503
 - method data:       0x0000004096435df0
 - checked ex length: 1
 - checked ex start:  0x000000409642356c
 - linenumber start:  0x0000004096423503
 - localvar length:   7
 - localvar start:    0x0000004096423516
 - compiled code: nmethod  25293  640       3       java.util.zip.ZipCoder$UTF8ZipCoder::checkedHash (91 bytes)

------------------------ OptoAssembly for Compile_id = 647 -----------------------
#
#  int ( java/util/zip/ZipCoder$UTF8ZipCoder:NotNull:exact *, byte[int:&gt;=0]:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/zip/ZipCoder$UTF8ZipCoder:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: byte[int:&gt;=0]:exact *
#r016 c_rarg3   : parm 2: int
#r018 c_rarg4   : parm 3: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N350: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B45 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     addw  R31, R13, R14	#@addI_reg_reg
040 +   beq  R14, zr, B45	#@cmpI_reg_imm0_branch  P=0.000000 C=1023.000000

044     B2: #	out( B30 B3 ) &lt;- in( B1 )  Freq: 1
044 +   addw  R11, R31, zr	#@convI2L_reg_reg
048 +   li R7, #0	# int, #@loadConI
04c +   bge  R13, R31, B30	#@cmpI_branch  P=0.020098 C=50901.000000

050     B3: #	out( B37 B4 ) &lt;- in( B2 )  Freq: 0.979902
050     lwu  R28, [R12, #12]	# range, #@loadRange
054     NullCheck R12

054     B4: #	out( B37 B5 ) &lt;- in( B3 )  Freq: 0.979901
054 +   addi  R29, R11, #-1	#@addL_reg_imm
058 +   addw  R30, R28, zr	#@convI2L_reg_reg
05c +   bgeu  R13, R28, B37	#@cmpU_branch  P=0.000001 C=-1.000000

060     B5: #	out( B37 B6 ) &lt;- in( B4 )  Freq: 0.9799
060 +   bgeu  R29, R30, B37	#@cmpUL_branch  P=0.000001 C=-1.000000

064     B6: #	out( B7 ) &lt;- in( B5 )  Freq: 0.979899
064 +   addiw  R29, R13, #1	#@addI_reg_imm
068 +   li R16, #0	# int, #@loadConI

06c     B7: #	out( B42 B8 ) &lt;- in( B6 B9 ) Loop( B7-B9 inner pre of N242) Freq: 1.9598
06c +   addw  R30, R13, zr	#@convI2L_reg_reg
070 +   add R30, R12, R30	# ptr, #@addP_reg_reg
074 +   lb  R9, [R30, #16]	# byte, #@loadB
078 +   blt  R9, zr, B42	#@cmpI_reg_imm0_branch  P=0.000000 C=49878.000000

07c     B8: #	out( B10 B9 ) &lt;- in( B7 )  Freq: 1.9598
07c +   slliw  R10, R16, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
080 +   subw  R30, R10, R16	#@subI_reg_reg
084 +   addiw  R10, R13, #1	#@addI_reg_imm
088 +   addw  R16, R30, R9	#@addI_reg_reg
08c +   bge  R10, R29, B10	#@cmpI_loop  P=0.500000 C=49878.000000

090     B9: #	out( B7 ) &lt;- in( B8 )  Freq: 0.979898
090 +   spill R10 -&gt; R13	# spill size = 32
094 +   j  B7	#@branch

098     B10: #	out( B38 B11 ) &lt;- in( B8 )  Freq: 0.979898
098 +   li R29, #-2147483648	# int, #@loadConI
09c +   addiw  R17, R31, #-3	#@addI_reg_imm
0a0     CMove R17, (R31 lt R17), R17, R29	#@cmovI_cmpI
	
0a8 +   bge  R10, R17, B38	#@cmpI_branch  P=0.000001 C=-1.000000

0ac     B11: #	out( B39 B12 ) &lt;- in( B10 )  Freq: 0.979897
0ac +   li R19, #4000	# int, #@loadConI
0b4     spill R10 -&gt; R15	# spill size = 32
0b8 +   addiw  R30, R13, #4	#@addI_reg_imm
0bc +   # castII of R15, #@castII
0bc     bgeu  R15, R28, B39	#@cmpU_branch  P=0.000001 C=-1.000000

0c0     B12: #	out( B40 B13 ) &lt;- in( B11 )  Freq: 0.979896
0c0 +   bgeu  R10, R28, B40	#@cmpU_branch  P=0.000001 C=-1.000000

0c4     B13: #	out( B41 B14 ) &lt;- in( B12 )  Freq: 0.979895
0c4 +   bgeu  R30, R28, B41	#@cmpU_branch  P=0.000001 C=-1.000000

0c8     B14: #	out( B15 ) &lt;- in( B13 )  Freq: 0.979894
0c8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP

0c8     B15: #	out( B16 ) &lt;- in( B14 B21 ) Loop( B15-B21 ) Freq: 48.5207
0c8 +   subw  R29, R17, R15	#@subI_reg_reg
0cc     CMove R29, (R17 lt R15), R29, R7	#@cmovI_cmpI
	
0d4 +   CMove R29, (R29 gtu R19), R29, R19	#@cmovI_cmpU
	
0dc +   addw  R18, R29, R15	#@addI_reg_reg

0e0     B16: #	out( B31 B17 ) &lt;- in( B15 B20 ) Loop( B16-B20 inner main of N89 strip mined) Freq: 2413.99
0e0 +   addw  R29, R15, zr	#@convI2L_reg_reg
0e4 +   add R29, R12, R29	# ptr, #@addP_reg_reg
0e8 +   lb  R13, [R29, #16]	# byte, #@loadB
0ec +   slliw  R30, R16, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0f0 +   subw  R10, R30, R16	#@subI_reg_reg
0f4 +   addw  R22, R10, R13	#@addI_reg_reg
0f8 +   lb  R20, [R29, #17]	# byte, #@loadB
0fc +   slliw  R30, R22, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
100 +   subw  R10, R30, R22	#@subI_reg_reg
104 +   addw  R24, R10, R20	#@addI_reg_reg
108 +   lb  R21, [R29, #18]	# byte, #@loadB
10c +   slliw  R30, R24, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
110 +   subw  R30, R30, R24	#@subI_reg_reg
114 +   addw  R30, R30, R21	#@addI_reg_reg
118 +   lb  R9, [R29, #19]	# byte, #@loadB
11c +   slliw  R10, R30, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
120 +   subw  R29, R10, R30	#@subI_reg_reg
124 +   blt  R13, zr, B31	#@cmpI_reg_imm0_branch  P=0.000000 C=49878.000000

128     B17: #	out( B32 B18 ) &lt;- in( B16 )  Freq: 2413.99
128 +   blt  R20, zr, B32	#@cmpI_reg_imm0_branch  P=0.000000 C=49878.000000

12c     B18: #	out( B33 B19 ) &lt;- in( B17 )  Freq: 2413.99
12c +   blt  R21, zr, B33	#@cmpI_reg_imm0_branch  P=0.000000 C=49878.000000

130     B19: #	out( B34 B20 ) &lt;- in( B18 )  Freq: 2413.99
130 +   blt  R9, zr, B34	#@cmpI_reg_imm0_branch  P=0.000000 C=49878.000000

134     B20: #	out( B16 B21 ) &lt;- in( B19 )  Freq: 2413.99
134 +   addiw  R15, R15, #4	#@addI_reg_imm
138 +   addw  R16, R29, R9	#@addI_reg_reg
13c +   blt  R15, R18, B16	#@cmpI_loop  P=0.979902 C=49878.000000

140     B21: #	out( B15 B22 ) &lt;- in( B20 )  Freq: 48.5159
140 +   ld  R29, [R23, #920]	# ptr, #@loadP
144 +   lwu zr, [R29]	# Safepoint: poll for GC, #@safePoint        # java.util.zip.ZipCoder$UTF8ZipCoder::checkedHash @ bci:64 (line 229) L[0]=_ L[1]=R12 L[2]=R15 L[3]=R14 L[4]=R31 L[5]=R16 L[6]=_
        # OopMap {c_rarg2=Oop off=324/0x144}
148 +   blt  R15, R17, B15	#@cmpI_branch  P=0.979902 C=49878.000000

14c     B22: #	out( B26 B23 ) &lt;- in( B38 B21 )  Freq: 0.975067
14c +   bge  R15, R31, B26	#@cmpI_branch  P=0.500000 C=-1.000000

150     B23: #	out( B43 B24 ) &lt;- in( B22 )  Freq: 0.487533
150 +   # castII of R15, #@castII
150     bgeu  R15, R28, B43	#@cmpU_branch  P=0.000001 C=-1.000000

154     B24: #	out( B44 B25 ) &lt;- in( B23 B25 ) Loop( B24-B25 inner post of N242) Freq: 0.975065
154 +   addw  R7, R15, zr	#@convI2L_reg_reg
158 +   add R7, R12, R7	# ptr, #@addP_reg_reg
15c +   lb  R9, [R7, #16]	# byte, #@loadB
160 +   slliw  R28, R16, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
164 +   subw  R7, R28, R16	#@subI_reg_reg
168 +   blt  R9, zr, B44	#@cmpI_reg_imm0_branch  P=0.000000 C=49878.000000

16c     B25: #	out( B24 B26 ) &lt;- in( B24 )  Freq: 0.975065
16c +   addiw  R15, R15, #1	#@addI_reg_imm
170 +   addw  R16, R7, R9	#@addI_reg_reg
174 +   blt  R15, R31, B24	#@cmpI_loop  P=0.500000 C=49878.000000

178     B26: #	out( B47 B27 ) &lt;- in( B25 B22 B30 )  Freq: 0.995164
178 +   addiw  R8, R31, #-1	#@addI_reg_imm
17c     lwu  R28, [R12, #12]	# range, #@loadRange
180     NullCheck R12

180     B27: #	out( B36 B28 ) &lt;- in( B26 )  Freq: 0.995163
180 +   add R7, R12, R11	# ptr, #@addP_reg_reg
184 +   bgeu  R8, R28, B36	#@cmpU_branch  P=0.000001 C=-1.000000

188     B28: #	out( B46 B29 ) &lt;- in( B27 )  Freq: 0.995162
188 +   lb  R8, [R7, #15]	# byte, #@loadB
18c +   li R7, #47	# int, #@loadConI
190 +   beq  R8, R7, B46	#@cmpI_branch  P=0.000000 C=1023.000000

194     B29: #	out( N350 ) &lt;- in( B28 )  Freq: 0.995161
194 +   slliw  R28, R16, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
198 +   subw  R7, R28, R16	#@subI_reg_reg
19c +   addiw  R10, R7, #47	#@addI_reg_imm
1a0     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
1b8 +   ret	// return register, #@Ret

1bc     B30: #	out( B26 ) &lt;- in( B2 )  Freq: 0.0200978
1bc +   li R16, #0	# int, #@loadConI
1c0 +   j  B26	#@branch

1c4     B31: #	out( B35 ) &lt;- in( B16 )  Freq: 0.00120699
1c4 +   spill R13 -&gt; R9	# spill size = 32
1c8 +   spill R16 -&gt; R30	# spill size = 32
1cc +   j  B35	#@branch

1d0     B32: #	out( B35 ) &lt;- in( B17 )  Freq: 0.00120699
1d0 +   addiw  R15, R15, #1	#@addI_reg_imm
1d4     spill R20 -&gt; R9	# spill size = 32
1d8 +   spill R22 -&gt; R30	# spill size = 32
1dc +   j  B35	#@branch

1e0     B33: #	out( B35 ) &lt;- in( B18 )  Freq: 0.00120699
1e0 +   addiw  R15, R15, #2	#@addI_reg_imm
1e4     spill R21 -&gt; R9	# spill size = 32
1e8 +   spill R24 -&gt; R30	# spill size = 32
1ec +   j  B35	#@branch

1f0     B34: #	out( B35 ) &lt;- in( B19 )  Freq: 0.00120699
1f0 +   addiw  R15, R15, #3	#@addI_reg_imm

1f4     B35: #	out( N350 ) &lt;- in( B44 B42 B31 B33 B32 B34 )  Freq: 0.00482944
1f4 +   li R11, #-187	# int, #@loadConI
1f8     spill R12 -&gt; R8	# spill size = 64
1fc +   spill R15 -&gt; [sp, #0]	# spill size = 32
200 +   spill R14 -&gt; [sp, #4]	# spill size = 32
204 +   spill R31 -&gt; [sp, #8]	# spill size = 32
208 +   spill R30 -&gt; [sp, #12]	# spill size = 32
20c +   spill R9 -&gt; [sp, #20]	# spill size = 32
210     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.zip.ZipCoder$UTF8ZipCoder::checkedHash @ bci:27 (line 217) L[0]=_ L[1]=R8 L[2]=sp + #0 L[3]=sp + #4 L[4]=sp + #8 L[5]=sp + #12 L[6]=sp + #20 STK[0]=sp + #20
        # OopMap {fp=Oop off=532/0x214}
214     #@ShouldNotReachHere

220     B36: #	out( N350 ) &lt;- in( B27 )  Freq: 1.00838e-06
220 +   li R11, #-28	# int, #@loadConI
224     spill R16 -&gt; [sp, #0]	# spill size = 32
228 +   spill R12 -&gt; [sp, #8]	# spill size = 64
22c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.zip.ZipCoder$UTF8ZipCoder::checkedHash @ bci:72 (line 231) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=sp + #0 L[6]=_ STK[0]=sp + #8 STK[1]=R8
        # OopMap {[8]=Oop off=560/0x230}
230     #@ShouldNotReachHere

23c     B37: #	out( N350 ) &lt;- in( B5 B3 B4 )  Freq: 2.97874e-06
23c +   li R11, #-138	# int, #@loadConI
240     spill R12 -&gt; R8	# spill size = 64
244 +   spill R14 -&gt; [sp, #0]	# spill size = 32
248 +   spill R31 -&gt; [sp, #8]	# spill size = 32
24c +   spill R13 -&gt; [sp, #16]	# spill size = 32
250     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.util.zip.ZipCoder$UTF8ZipCoder::checkedHash @ bci:17 (line 215) L[0]=_ L[1]=R8 L[2]=sp + #16 L[3]=sp + #0 L[4]=sp + #8 L[5]=#0 L[6]=_ STK[0]=sp + #16 STK[1]=sp + #8
        # OopMap {fp=Oop off=596/0x254}
254     #@ShouldNotReachHere

260     B38: #	out( B22 ) &lt;- in( B10 )  Freq: 9.9291e-07
260 +   spill R10 -&gt; R15	# spill size = 32
264 +   j  B22	#@branch

268     B39: #	out( N350 ) &lt;- in( B11 )  Freq: 9.92909e-07
268     #@ShouldNotReachHere

274     B40: #	out( N350 ) &lt;- in( B12 )  Freq: 9.92908e-07
274     #@ShouldNotReachHere

280     B41: #	out( N350 ) &lt;- in( B13 )  Freq: 9.92907e-07
280     #@ShouldNotReachHere

28c     B42: #	out( B35 ) &lt;- in( B7 )  Freq: 9.79898e-07
28c +   spill R16 -&gt; R30	# spill size = 32
290 +   spill R13 -&gt; R15	# spill size = 32
294 +   j  B35	#@branch

298     B43: #	out( N350 ) &lt;- in( B23 )  Freq: 4.94007e-07
298     #@ShouldNotReachHere

2a4     B44: #	out( B35 ) &lt;- in( B24 )  Freq: 4.87533e-07
2a4 +   spill R16 -&gt; R30	# spill size = 32
2a8 +   j  B35	#@branch

2ac     B45: #	out( N350 ) &lt;- in( B1 )  Freq: 4.76837e-07
2ac +   li R11, #-187	# int, #@loadConI
2b0     spill R12 -&gt; R8	# spill size = 64
2b4 +   spill R14 -&gt; [sp, #4]	# spill size = 32
2b8 +   spill R13 -&gt; [sp, #8]	# spill size = 32
2bc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.zip.ZipCoder$UTF8ZipCoder::checkedHash @ bci:1 (line 209) L[0]=_ L[1]=R8 L[2]=sp + #8 L[3]=sp + #4 L[4]=_ L[5]=_ L[6]=_ STK[0]=sp + #4
        # OopMap {fp=Oop off=704/0x2c0}
2c0     #@ShouldNotReachHere

2cc     B46: #	out( N350 ) &lt;- in( B28 )  Freq: 4.7453e-07
2cc +   li R11, #-187	# int, #@loadConI
2d0     spill R16 -&gt; [sp, #0]	# spill size = 32
2d4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.zip.ZipCoder$UTF8ZipCoder::checkedHash @ bci:75 (line 231) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=sp + #0 L[6]=_ STK[0]=R8 STK[1]=#47
        # OopMap {off=728/0x2d8}
2d8     #@ShouldNotReachHere

2e4     B47: #	out( N350 ) &lt;- in( B26 )  Freq: 1.00838e-06
2e4 +   li R11, #-10	# int, #@loadConI
2e8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.zip.ZipCoder$UTF8ZipCoder::checkedHash @ bci:72 (line 231) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=#NULL STK[1]=R8
        # OopMap {off=748/0x2ec}
2ec     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='654'>
----------------------- MetaData before Compile_id = 654 ------------------------
{method}
 - this oop:          0x000000409600fb68
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000000  
 - name:              &apos;coder&apos;
 - signature:         &apos;()B&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824b790: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4ae100
 - code size:         15
 - code start:        0x000000409600fb40
 - code end (excl):   0x000000409600fb4f
 - method data:       0x000000409634cdf0
 - checked ex length: 0
 - linenumber start:  0x000000409600fb4f
 - localvar length:   1
 - localvar start:    0x000000409600fb5a
 - compiled code: nmethod  25869    5       3       java.lang.String::coder (15 bytes)

------------------------ OptoAssembly for Compile_id = 654 -----------------------
#
#  byte ( java/lang/String:NotNull:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N15: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N15 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     lb  R10, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
040     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
058 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='659'>
----------------------- MetaData before Compile_id = 659 ------------------------
{method}
 - this oop:          0x0000004096391948
 - method holder:     &apos;jdk/internal/org/objectweb/asm/ByteVector&apos;
 - constants:         0x00000040963907f0 constant pool [102] {0x00000040963907f0} for &apos;jdk/internal/org/objectweb/asm/ByteVector&apos; cache=0x0000004096391e78
 - access:            0xc1000001  public 
 - name:              &apos;putUTF8&apos;
 - signature:         &apos;(Ljava/lang/String;)Ljdk/internal/org/objectweb/asm/ByteVector;&apos;
 - max stack:         5
 - max locals:        7
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      10
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bd00: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c4b1300
 - code size:         144
 - code start:        0x0000004096391848
 - code end (excl):   0x00000040963918d8
 - method data:       0x00000040963d7818
 - checked ex length: 0
 - linenumber start:  0x00000040963918d8
 - localvar length:   7
 - localvar start:    0x00000040963918f2
 - compiled code: nmethod  26117   25       3       jdk.internal.org.objectweb.asm.ByteVector::putUTF8 (144 bytes)

------------------------ OptoAssembly for Compile_id = 659 -----------------------
#
#  jdk/internal/org/objectweb/asm/ByteVector * ( jdk/internal/org/objectweb/asm/ByteVector:NotNull *, java/lang/String:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: jdk/internal/org/objectweb/asm/ByteVector:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/String:exact *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N556: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B61 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
03c     spill R12 -&gt; R16	# spill size = 64
040     lwu  R7, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
044     NullCheck R12

044     B2: #	out( B62 B3 ) &lt;- in( B1 )  Freq: 0.999999
044 +   decode_heap_oop  R7, R7	#@decodeHeapOop
048     lwu  R28, [R7, #12]	# range, #@loadRange
04c     NullCheck R7

04c     B3: #	out( B57 B4 ) &lt;- in( B2 )  Freq: 0.999998
04c +   lb  R7, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
050 +   lw  R8, [R11, #12]	# int, #@loadI ! Field: jdk/internal/org/objectweb/asm/ByteVector.length
054 +   lwu  R30, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/org/objectweb/asm/ByteVector.data
058 +   sraw  R28, R28, R7	#@rShiftI_reg_reg
05c +   li R10, #65535	# int, #@loadConI
064 +   addw  R7, R28, R8	#@addI_reg_reg
068 +   decode_heap_oop  R29, R30	#@decodeHeapOop
06c     spill R11 -&gt; R17	# spill size = 64
070 +   bgt  R28, R10, B57	#@cmpI_branch  P=0.000000 C=1023.000000

074     B4: #	out( B63 B5 ) &lt;- in( B3 )  Freq: 0.999997
074     lwu  R29, [R29, #12]	# range, #@loadRange
078     NullCheck R29

078     B5: #	out( B38 B6 ) &lt;- in( B4 )  Freq: 0.999996
078 +   srliw  R11, R28, (#8 &amp; 0x1f)	#@urShiftI_reg_imm
07c +   addiw  R10, R7, #2	#@addI_reg_imm
080 +   sext.b  R31, R11	# b2i, #@convB2I_reg_reg_b
084 +   bgt  R10, R29, B38	#@cmpI_branch  P=0.139785 C=1023.000000

088     B6: #	out( B46 B7 ) &lt;- in( B40 B5 )  Freq: 0.999994
088 +   decode_heap_oop  R9, R30	#@decodeHeapOop
08c +   lwu  R29, [R9, #12]	# range, #@loadRange
090 +   addiw  R7, R8, #1	#@addI_reg_imm
094 +   addw  R30, R8, zr	#@convI2L_reg_reg
098 +   bgeu  R8, R29, B46	#@cmpU_branch  P=0.000001 C=-1.000000

09c     B7: #	out( B47 B8 ) &lt;- in( B6 )  Freq: 0.999993
09c +   add R19, R9, R30	# ptr, #@addP_reg_reg
0a0 +   addiw  R31, R8, #2	#@addI_reg_imm
0a4 +   sb  R11, [R19, #16]	# byte, #@storeB
0a8 +   bgeu  R7, R29, B47	#@cmpU_branch  P=0.000001 C=-1.000000

0ac     B8: #	out( B37 B9 ) &lt;- in( B7 )  Freq: 0.999992
0ac +   sb  R28, [R19, #17]	# byte, #@storeB
0b0 +   ble  R28, zr, B37	#@cmpI_reg_imm0_branch  P=0.042604 C=24012.000000

0b4     B9: #	out( B48 B10 ) &lt;- in( B8 )  Freq: 0.957388
0b4 +   lwu  R30, [R16, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0b8 +   lb  R7, [R16, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0bc +   decode_heap_oop  R18, R30	#@decodeHeapOop
0c0 +   bne  R7, zr, B48	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0c4     B10: #	out( B48 B11 ) &lt;- in( B9 )  Freq: 0.957387
0c4     lwu  R30, [R18, #12]	# range, #@loadRange
0c8     NullCheck R18

0c8     B11: #	out( B48 B12 ) &lt;- in( B10 )  Freq: 0.957386
0c8 +   addw  R7, R28, zr	#@convI2L_reg_reg
0cc +   addw  R10, R30, zr	#@convI2L_reg_reg
0d0 +   addi  R11, R7, #-1	#@addL_reg_imm
0d4 +   bleu  R30, zr, B48	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

0d8     B12: #	out( B48 B13 ) &lt;- in( B11 )  Freq: 0.957385
0d8 +   bgeu  R11, R10, B48	#@cmpUL_branch  P=0.000001 C=-1.000000

0dc     B13: #	out( B48 B14 ) &lt;- in( B12 )  Freq: 0.957384
0dc +   lb  R12, [R18, #16]	# byte, #@loadB
0e0 +   addw  R24, R31, zr	#@convI2L_reg_reg
0e4 +   add  R10, R7, R24	#@addL_reg_reg
0e8 +   andi  R15, R12, #255	#@andI_reg_imm
0ec +   addw  R22, R29, zr	#@convI2L_reg_reg
0f0 +   addiw  R7, R15, #-1	#@addI_reg_imm
0f4 +   addi  R10, R10, #-1	#@addL_reg_imm
0f8 +   li R11, #127	# int, #@loadConI
0fc +   bgeu  R31, R29, B48	#@cmpU_branch  P=0.000001 C=-1.000000

100     B14: #	out( B48 B15 ) &lt;- in( B13 )  Freq: 0.957383
100 +   bgeu  R10, R22, B48	#@cmpUL_branch  P=0.000001 C=-1.000000

104     B15: #	out( B58 B16 ) &lt;- in( B14 )  Freq: 0.957382
104 +   li R10, #0	# int, #@loadConI
108 +   bgeu  R7, R11, B58	#@cmpU_branch  P=0.000000 C=22989.000000

10c     B16: #	out( B29 B17 ) &lt;- in( B15 )  Freq: 0.957382
10c +   li R29, #-2147483648	# int, #@loadConI
110 +   addiw  R13, R28, #-3	#@addI_reg_imm
114     CMove R13, (R28 lt R13), R13, R29	#@cmovI_cmpI
	
11c +   li R14, #1	# int, #@loadConI
120 +   sb  R12, [R19, #18]	# byte, #@storeB
124 +   ble  R13, R14, B29	#@cmpI_branch  P=0.000001 C=-1.000000

128     B17: #	out( B49 B18 ) &lt;- in( B16 )  Freq: 0.957381
128 +   addi  R31, R24, #1	#@addL_reg_imm
12c +   addi  R7, R24, #4	#@addL_reg_imm
130 +   li R29, #4	# int, #@loadConI
134 +   bgeu  R31, R22, B49	#@cmpUL_branch  P=0.000001 C=-1.000000

138     B18: #	out( B51 B19 ) &lt;- in( B17 )  Freq: 0.95738
138 +   bleu  R30, R14, B51	#@cmpU_branch  P=0.000001 C=-1.000000

13c     B19: #	out( B52 B20 ) &lt;- in( B18 )  Freq: 0.957379
13c +   bleu  R30, R29, B52	#@cmpU_branch  P=0.000001 C=-1.000000

140     B20: #	out( B50 B21 ) &lt;- in( B19 )  Freq: 0.957378
140 +   bgeu  R7, R22, B50	#@cmpUL_branch  P=0.000001 C=-1.000000

144     B21: #	out( B22 ) &lt;- in( B20 )  Freq: 0.957377
144 +   li R12, #4000	# int, #@loadConI
14c      -- 	// R23=Thread::current(), empty, #@tlsLoadP

14c     B22: #	out( B23 ) &lt;- in( B21 B28 ) Loop( B22-B28 ) Freq: 22.4491
14c +   subw  R7, R13, R14	#@subI_reg_reg
150     CMove R7, (R13 lt R14), R7, R10	#@cmovI_cmpI
	
158 +   CMove R7, (R7 gtu R12), R7, R12	#@cmovI_cmpU
	
160 +   addw  R19, R7, R14	#@addI_reg_reg
        nop 	# 6 bytes pad for loops and calls

170     B23: #	out( B41 B24 ) &lt;- in( B22 B27 ) Loop( B23-B27 inner main of N196 strip mined) Freq: 526.907
170 +   addw  R7, R14, zr	#@convI2L_reg_reg
174 +   add R21, R18, R7	# ptr, #@addP_reg_reg
178 +   addw  R31, R14, R8	#@addI_reg_reg
17c +   lb  R7, [R21, #16]	# byte, #@loadB
180 +   addw  R29, R31, zr	#@convI2L_reg_reg
184 +   add R20, R9, R29	# ptr, #@addP_reg_reg
188 +   andi  R15, R7, #255	#@andI_reg_imm
18c +   addiw  R29, R15, #-1	#@addI_reg_imm
190 +   bgeu  R29, R11, B41	#@cmpU_branch  P=0.000000 C=22989.000000

194     B24: #	out( B42 B25 ) &lt;- in( B23 )  Freq: 526.906
194 +   sb  R7, [R20, #18]	# byte, #@storeB
198 +   lb  R7, [R21, #17]	# byte, #@loadB
19c +   andi  R15, R7, #255	#@andI_reg_imm
1a0 +   addiw  R29, R15, #-1	#@addI_reg_imm
1a4 +   bgeu  R29, R11, B42	#@cmpU_branch  P=0.000000 C=22989.000000

1a8     B25: #	out( B43 B26 ) &lt;- in( B24 )  Freq: 526.906
1a8 +   sb  R7, [R20, #19]	# byte, #@storeB
1ac +   lb  R7, [R21, #18]	# byte, #@loadB
1b0 +   andi  R15, R7, #255	#@andI_reg_imm
1b4 +   addiw  R29, R15, #-1	#@addI_reg_imm
1b8 +   bgeu  R29, R11, B43	#@cmpU_branch  P=0.000000 C=22989.000000

1bc     B26: #	out( B44 B27 ) &lt;- in( B25 )  Freq: 526.906
1bc +   sb  R7, [R20, #20]	# byte, #@storeB
1c0 +   lb  R7, [R21, #19]	# byte, #@loadB
1c4 +   andi  R15, R7, #255	#@andI_reg_imm
1c8 +   addiw  R29, R15, #-1	#@addI_reg_imm
1cc +   addiw  R31, R31, #5	#@addI_reg_imm
1d0 +   bgeu  R29, R11, B44	#@cmpU_branch  P=0.000000 C=22989.000000

1d4     B27: #	out( B23 B28 ) &lt;- in( B26 )  Freq: 526.906
1d4 +   addiw  R14, R14, #4	#@addI_reg_imm
1d8 +   sb  R7, [R20, #21]	# byte, #@storeB
1dc +   blt  R14, R19, B23	#@cmpI_loop  P=0.957396 C=22989.000000

1e0     B28: #	out( B22 B29 ) &lt;- in( B27 )  Freq: 22.4481
1e0 +   spill R31 -&gt; R7	# spill size = 32
1e4 +   # castII of R7, #@castII
1e4     addiw  R29, R7, #1	#@addI_reg_imm
1e8 +   ld  R15, [R23, #920]	# ptr, #@loadP
1ec +   lwu zr, [R15]	# Safepoint: poll for GC, #@safePoint        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:134 (line 290) L[0]=R17 L[1]=R16 L[2]=R28 L[3]=R29 L[4]=R9 L[5]=R14 L[6]=_
        # OopMap {c_rarg6=Oop c_rarg7=Oop x9=Oop x18=Oop off=492/0x1ec}
1f0 +   blt  R14, R13, B22	#@cmpI_branch  P=0.957396 C=22989.000000

1f4     B29: #	out( B36 B30 ) &lt;- in( B16 B28 )  Freq: 0.956373
1f4 +   bge  R14, R28, B36	#@cmpI_branch  P=0.500000 C=-1.000000

1f8     B30: #	out( B53 B31 ) &lt;- in( B29 )  Freq: 0.478187
1f8 +   # castII of R14, #@castII
1f8     spill R14 -&gt; R7	# spill size = 32
1fc +   addw  R29, R14, zr	#@convI2L_reg_reg
200 +   # castII of R7, #@castII
200     addw  R31, R7, zr	#@convI2L_reg_reg
204 +   add  R29, R29, R24	#@addL_reg_reg
208 +   add  R31, R31, R24	#@addL_reg_reg
20c +   bgeu  R14, R30, B53	#@cmpU_branch  P=0.000001 C=-1.000000

210     B31: #	out( B54 B32 ) &lt;- in( B30 )  Freq: 0.478186
210 +   bgeu  R7, R30, B54	#@cmpU_branch  P=0.000001 C=-1.000000

214     B32: #	out( B55 B33 ) &lt;- in( B31 )  Freq: 0.478186
214 +   bgeu  R29, R22, B55	#@cmpUL_branch  P=0.000001 C=-1.000000

218     B33: #	out( B56 B34 ) &lt;- in( B32 )  Freq: 0.478185
218 +   bgeu  R31, R22, B56	#@cmpUL_branch  P=0.000001 C=-1.000000

21c     B34: #	out( B45 B35 ) &lt;- in( B33 B35 ) Loop( B34-B35 inner post of N594) Freq: 0.956369
21c +   addw  R7, R14, zr	#@convI2L_reg_reg
220 +   add R7, R18, R7	# ptr, #@addP_reg_reg
224 +   lb  R29, [R7, #16]	# byte, #@loadB
228 +   addw  R7, R14, R8	#@addI_reg_reg
22c +   andi  R15, R29, #255	#@andI_reg_imm
230 +   addw  R30, R7, zr	#@convI2L_reg_reg
234 +   addiw  R12, R15, #-1	#@addI_reg_imm
238 +   add R30, R9, R30	# ptr, #@addP_reg_reg
23c +   addiw  R31, R7, #2	#@addI_reg_imm
240 +   bgeu  R12, R11, B45	#@cmpU_branch  P=0.000000 C=22989.000000

244     B35: #	out( B34 B36 ) &lt;- in( B34 )  Freq: 0.956368
244 +   addiw  R14, R14, #1	#@addI_reg_imm
248 +   sb  R29, [R30, #18]	# byte, #@storeB
24c +   blt  R14, R28, B34	#@cmpI_loop  P=0.500000 C=22989.000000

250     B36: #	out( B37 ) &lt;- in( B35 B29 )  Freq: 0.956371
250 +   # castII of R31, #@castII
250     addiw  R31, R31, #1	#@addI_reg_imm

254     B37: #	out( N556 ) &lt;- in( B36 B8 )  Freq: 0.998974
254 +   sw  R31, [R17, #12]	# int, #@storeI ! Field: jdk/internal/org/objectweb/asm/ByteVector.length
258     spill R17 -&gt; R10	# spill size = 64
25c +   # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
274 +   ret	// return register, #@Ret

278     B38: #	out( B60 B39 ) &lt;- in( B5 )  Freq: 0.139784
278 +   spill R8 -&gt; [sp, #8]	# spill size = 32
27c +   spill R12 -&gt; R8	# spill size = 64
280 +   spill R11 -&gt; [sp, #16]	# spill size = 32
284 +   spill R31 -&gt; [sp, #20]	# spill size = 32
288 +   spill R17 -&gt; [sp, #0]	# spill size = 64
28c +   addiw  R12, R28, #2	#@addI_reg_imm
290     spill R28 -&gt; [sp, #12]	# spill size = 32
294 +   spill R17 -&gt; R11	# spill size = 64
298     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect jdk.internal.org.objectweb.asm.ByteVector::enlarge
        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:43 (line 281) L[0]=sp + #0 L[1]=R8 L[2]=sp + #12 L[3]=sp + #8 L[4]=_ L[5]=_ L[6]=_
        # OopMap {fp=Oop [0]=Oop off=668/0x29c}

29c     B39: #	out( B59 B40 ) &lt;- in( B38 )  Freq: 0.139782
        # Block is sole successor of call
29c +   spill [sp, #0] -&gt; R17	# spill size = 64
2a0 +   lwu  R30, [R17, #16]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/org/objectweb/asm/ByteVector.data
2a4 +   beq   R30, zr, B59	#@cmpP_narrowOop_imm0_branch  P=0.000001 C=-1.000000

2a8     B40: #	out( B6 ) &lt;- in( B39 )  Freq: 0.139781
2a8 +   spill R8 -&gt; R16	# spill size = 64
2ac +   spill [sp, #8] -&gt; R8	# spill size = 32
2b0 +   spill [sp, #12] -&gt; R28	# spill size = 32
2b4 +   spill [sp, #16] -&gt; R11	# spill size = 32
2b8 +   spill [sp, #20] -&gt; R31	# spill size = 32
2bc +   j  B6	#@branch

2c0     B41: #	out( B45 ) &lt;- in( B23 )  Freq: 0.000251249
2c0 +   addiw  R31, R31, #2	#@addI_reg_imm
2c4 +   j  B45	#@branch

2c8     B42: #	out( B45 ) &lt;- in( B24 )  Freq: 0.000251249
2c8 +   addiw  R14, R14, #1	#@addI_reg_imm
2cc +   addiw  R31, R31, #3	#@addI_reg_imm
2d0 +   j  B45	#@branch

2d4     B43: #	out( B45 ) &lt;- in( B25 )  Freq: 0.000251248
2d4 +   addiw  R14, R14, #2	#@addI_reg_imm
2d8 +   addiw  R31, R31, #4	#@addI_reg_imm
2dc +   j  B45	#@branch

2e0     B44: #	out( B45 ) &lt;- in( B26 )  Freq: 0.000251248
2e0 +   addiw  R14, R14, #3	#@addI_reg_imm

2e4     B45: #	out( N556 ) &lt;- in( B34 B58 B41 B43 B42 B44 )  Freq: 0.00100591
2e4 +   li R11, #-195	# int, #@loadConI
2e8     spill R31 -&gt; R8	# spill size = 32
2ec +   spill R9 -&gt; [sp, #0]	# spill size = 64
2f0 +   spill R14 -&gt; [sp, #8]	# spill size = 32
2f4 +   spill R15 -&gt; [sp, #16]	# spill size = 32
2f8 +   spill R17 -&gt; [sp, #24]	# spill size = 64
2fc +   spill R16 -&gt; [sp, #32]	# spill size = 64
300 +   spill R28 -&gt; [sp, #20]	# spill size = 32
304     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_fused_if&apos; action=&apos;reinterpret&apos;)
        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:93 (line 292) L[0]=sp + #24 L[1]=sp + #32 L[2]=sp + #20 L[3]=R8 L[4]=sp + #0 L[5]=sp + #8 L[6]=sp + #16 STK[0]=sp + #16 STK[1]=#1
        # OopMap {[0]=Oop [24]=Oop [32]=Oop off=776/0x308}
308     #@ShouldNotReachHere

314     B46: #	out( N556 ) &lt;- in( B6 )  Freq: 1.01327e-06
314 +   li R11, #-28	# int, #@loadConI
318     spill R9 -&gt; [sp, #8]	# spill size = 64
31c +   spill R17 -&gt; [sp, #16]	# spill size = 64
320 +   spill R16 -&gt; [sp, #24]	# spill size = 64
324 +   spill R28 -&gt; [sp, #32]	# spill size = 32
328 +   spill R7 -&gt; [sp, #36]	# spill size = 32
32c +   spill R31 -&gt; [sp, #40]	# spill size = 32
330     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:63 (line 288) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #32 L[3]=sp + #36 L[4]=sp + #8 L[5]=_ L[6]=_ STK[0]=sp + #8 STK[1]=R8 STK[2]=sp + #40
        # OopMap {[8]=Oop [16]=Oop [24]=Oop off=820/0x334}
334     #@ShouldNotReachHere

340     B47: #	out( N556 ) &lt;- in( B7 )  Freq: 1.01327e-06
340 +   sext.b  R8, R28	# b2i, #@convB2I_reg_reg_b
344 +   li R11, #-28	# int, #@loadConI
348     spill R31 -&gt; [sp, #0]	# spill size = 32
34c +   spill R9 -&gt; [sp, #16]	# spill size = 64
350 +   spill R17 -&gt; [sp, #24]	# spill size = 64
354 +   spill R16 -&gt; [sp, #32]	# spill size = 64
358 +   spill R28 -&gt; [sp, #4]	# spill size = 32
35c +   spill R7 -&gt; [sp, #40]	# spill size = 32
360     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:72 (line 289) L[0]=sp + #24 L[1]=sp + #32 L[2]=sp + #4 L[3]=sp + #0 L[4]=sp + #16 L[5]=_ L[6]=_ STK[0]=sp + #16 STK[1]=sp + #40 STK[2]=R8
        # OopMap {[16]=Oop [24]=Oop [32]=Oop off=868/0x364}
364     #@ShouldNotReachHere

370     B48: #	out( N556 ) &lt;- in( B14 B9 B10 B11 B12 B13 )  Freq: 5.79517e-06
370 +   li R11, #-138	# int, #@loadConI
374     spill R31 -&gt; R8	# spill size = 32
378 +   spill R9 -&gt; [sp, #0]	# spill size = 64
37c +   spill R17 -&gt; [sp, #8]	# spill size = 64
380 +   spill R16 -&gt; [sp, #16]	# spill size = 64
384 +   spill R28 -&gt; [sp, #28]	# spill size = 32
388     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:79 (line 290) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #28 L[3]=R8 L[4]=sp + #0 L[5]=#0 L[6]=_ STK[0]=#0 STK[1]=sp + #28
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=908/0x38c}
38c     #@ShouldNotReachHere

398     B49: #	out( N556 ) &lt;- in( B17 )  Freq: 9.70094e-07
398     #@ShouldNotReachHere

3a4     B50: #	out( N556 ) &lt;- in( B20 )  Freq: 9.70091e-07
3a4     #@ShouldNotReachHere

3b0     B51: #	out( N556 ) &lt;- in( B18 )  Freq: 9.5738e-07
3b0     #@ShouldNotReachHere

3bc     B52: #	out( N556 ) &lt;- in( B19 )  Freq: 9.57379e-07
3bc     #@ShouldNotReachHere

3c8     B53: #	out( N556 ) &lt;- in( B30 )  Freq: 4.84536e-07
3c8     #@ShouldNotReachHere

3d4     B54: #	out( N556 ) &lt;- in( B31 )  Freq: 4.84536e-07
3d4     #@ShouldNotReachHere

3e0     B55: #	out( N556 ) &lt;- in( B32 )  Freq: 4.84535e-07
3e0     #@ShouldNotReachHere

3ec     B56: #	out( N556 ) &lt;- in( B33 )  Freq: 4.84535e-07
3ec     #@ShouldNotReachHere

3f8     B57: #	out( N556 ) &lt;- in( B3 )  Freq: 4.76836e-07
3f8 +   li R11, #-187	# int, #@loadConI
3fc     spill R17 -&gt; R8	# spill size = 64
400 +   spill R12 -&gt; [sp, #0]	# spill size = 64
404 +   spill R28 -&gt; [sp, #12]	# spill size = 32
408     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:8 (line 276) L[0]=R8 L[1]=sp + #0 L[2]=sp + #12 L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=sp + #12 STK[1]=#65535
        # OopMap {fp=Oop [0]=Oop off=1036/0x40c}
40c     #@ShouldNotReachHere

418     B58: #	out( B45 ) &lt;- in( B15 )  Freq: 4.56515e-07
418 +   li R14, #0	# int, #@loadConI
41c +   j  B45	#@branch

420     B59: #	out( N556 ) &lt;- in( B39 )  Freq: 1.41638e-07
420 +   li R11, #-10	# int, #@loadConI
424     spill [sp, #8] -&gt; R8	# spill size = 32
428     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:63 (line 288) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=#NULL STK[1]=R8 STK[2]=sp + #20
        # OopMap {off=1068/0x42c}
42c     #@ShouldNotReachHere

438     B60: #	out( N556 ) &lt;- in( B38 )  Freq: 1.39784e-06
438      -- 	// exception oop; no code emitted, #@CreateException
438 +   spill R10 -&gt; R11	# spill size = 64
43c +   # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
448 +   j rethrow_stub	#@RethrowException

450     B61: #	out( N556 ) &lt;- in( B1 )  Freq: 1.01328e-06
450 +   li R11, #-10	# int, #@loadConI
454     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:1 (line 275) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=#NULL
        # OopMap {off=1112/0x458}
458     #@ShouldNotReachHere

464     B62: #	out( N556 ) &lt;- in( B2 )  Freq: 1.01328e-06
464 +   li R11, #-10	# int, #@loadConI
468     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:1 (line 275) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # OopMap {off=1132/0x46c}
46c     #@ShouldNotReachHere

478     B63: #	out( N556 ) &lt;- in( B4 )  Freq: 1.01328e-06
478 +   li R11, #-10	# int, #@loadConI
47c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:35 (line 280) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=1152/0x480}
480     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='661'>
----------------------- MetaData before Compile_id = 661 ------------------------
{method}
 - this oop:          0x000000409600a890
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;equals&apos;
 - signature:         &apos;(Ljava/lang/Object;)Z&apos;
 - max stack:         3
 - max locals:        3
 - size of params:    2
 - method size:       13
 - highest level:     4
 - vtable index:      1
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bd00: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x00000040139d7c88
 - code size:         56
 - code start:        0x000000409600a820
 - code end (excl):   0x000000409600a858
 - method data:       0x00000040963f5748
 - checked ex length: 0
 - linenumber start:  0x000000409600a858
 - localvar length:   3
 - localvar start:    0x000000409600a86a

------------------------ OptoAssembly for Compile_id = 661 -----------------------
#
#  bool ( java/lang/String:NotNull:exact *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N113: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B12 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     beq  R11, R12, B12	#@cmpP_branch  P=0.065691 C=5465.000000

040     B2: #	out( B9 B3 ) &lt;- in( B1 )  Freq: 0.934309
040 +   beq   R12, zr, B9	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

044     B3: #	out( B16 B4 ) &lt;- in( B2 )  Freq: 0.933375
044 +   lwu  R7, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
048 +   mv  R29, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
058 +   lb  R28, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
05c +   bne  R7, R29, B16	#@cmpN_branch  P=0.000000 C=-1.000000

060     B4: #	out( B15 B5 ) &lt;- in( B3 )  Freq: 0.933375
060 +   # checkcastPP of R12, #@checkCastPP
060     lb  R8, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
064 +   bne  R28, R8, B15	#@cmpI_branch  P=0.000000 C=5105.000000

068     B5: #	out( B13 B6 ) &lt;- in( B4 )  Freq: 0.933375
068 +   lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
06c +   decode_heap_oop  R7, R7	#@decodeHeapOop
070 +   lwu  R29, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
074 +   beq   R7, zr, B13	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

078     B6: #	out( B14 B7 ) &lt;- in( B5 )  Freq: 0.933374
078 +   decode_heap_oop  R28, R29	#@decodeHeapOop
07c +   lwu  R14, [R7, #12]	# range, #@loadRange
080 +   beq   R28, zr, B14	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

084     B7: #	out( B9 B8 ) &lt;- in( B6 )  Freq: 0.933373
084 +   lwu  R30, [R28, #12]	# range, #@loadRange
088 +   bne  R14, R30, B9	#@cmpI_branch  P=0.001000 C=-1.000000

08c     B8: #	out( B11 B9 ) &lt;- in( B7 )  Freq: 0.932439
08c +   addi  R13, R28, #16	# ptr, #@addP_reg_imm
090 +   addi  R11, R7, #16	# ptr, #@addP_reg_imm
094     String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
124 +   bne  R10, zr, B11	#@cmpI_reg_imm0_branch  P=0.195299 C=5105.000000

128     B9: #	out( B10 ) &lt;- in( B2 B8 B7 )  Freq: 0.752203
128 +   li R10, #0	# int, #@loadConI

12c     B10: #	out( N113 ) &lt;- in( B12 B9 B11 )  Freq: 0.999998
12c     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
144 +   ret	// return register, #@Ret

148     B11: #	out( B10 ) &lt;- in( B8 )  Freq: 0.182104
148 +   li R10, #1	# int, #@loadConI
14c +   j  B10	#@branch

150     B12: #	out( B10 ) &lt;- in( B1 )  Freq: 0.0656908
150 +   li R10, #1	# int, #@loadConI
154 +   j  B10	#@branch

158     B13: #	out( N113 ) &lt;- in( B5 )  Freq: 9.45769e-07
158     #@ShouldNotReachHere

164     B14: #	out( N113 ) &lt;- in( B6 )  Freq: 9.45768e-07
164     #@ShouldNotReachHere

170     B15: #	out( N113 ) &lt;- in( B4 )  Freq: 4.66687e-07
170 +   spill R11 -&gt; [sp, #0]	# spill size = 64
174 +   spill R12 -&gt; [sp, #8]	# spill size = 64
178 +   spill R28 -&gt; [sp, #16]	# spill size = 32
17c +   li R11, #-187	# int, #@loadConI
180     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #0 L[1]=_ L[2]=sp + #8 STK[0]=sp + #16 STK[1]=R8
        # OopMap {[0]=Oop [8]=Oop off=388/0x184}
184     #@ShouldNotReachHere

190     B16: #	out( N113 ) &lt;- in( B3 )  Freq: 1e-35
190 +   spill R11 -&gt; R8	# spill size = 64
194 +   spill R12 -&gt; [sp, #8]	# spill size = 64
198 +   li R11, #-34	# int, #@loadConI
19c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=R8 L[1]=sp + #8 L[2]=_ STK[0]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=416/0x1a0}
1a0     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='714'>
----------------------- MetaData before Compile_id = 714 ------------------------
{method}
 - this oop:          0x0000004096707800
 - method holder:     &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$44+0x00000008000c2c00&apos;
 - constants:         0x0000004096705dc8 constant pool [20] {0x0000004096705dc8} for &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$44+0x00000008000c2c00&apos; cache=0x0000004096707890
 - access:            0x81000001  public 
 - name:              &apos;applyAsInt&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         2
 - max locals:        2
 - size of params:    2
 - method size:       13
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bb30: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x00000040139d7908
 - code size:         5
 - code start:        0x0000004096705fe8
 - code end (excl):   0x0000004096705fed
 - method data:       0x0000004096707e30
 - checked ex length: 0
 - localvar length:   0

------------------------ OptoAssembly for Compile_id = 714 -----------------------
#
#  int ( compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$44+0x00000008000c2c00:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$44+0x00000008000c2c00:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N17: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N17 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     li R7, #0	# int, #@loadConI
040     spill R12 -&gt; R10	# spill size = 32
044 +   CMove R10, (R12 ge R7), R10, R7	#@cmovI_cmpI
	
04c +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='718'>
----------------------- MetaData before Compile_id = 718 ------------------------
{method}
 - this oop:          0x000000409670cc40
 - method holder:     &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$50+0x00000008000c5a50&apos;
 - constants:         0x000000409670ca18 constant pool [20] {0x000000409670ca18} for &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$50+0x00000008000c5a50&apos; cache=0x000000409670ccd0
 - access:            0x81000001  public 
 - name:              &apos;applyAsInt&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         2
 - max locals:        2
 - size of params:    2
 - method size:       13
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bb30: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x00000040139d7908
 - code size:         5
 - code start:        0x000000409670cc38
 - code end (excl):   0x000000409670cc3d
 - method data:       0x0000004096710000
 - checked ex length: 0
 - localvar length:   0

------------------------ OptoAssembly for Compile_id = 718 -----------------------
#
#  int ( compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$50+0x00000008000c5a50:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$50+0x00000008000c5a50:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N17: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N17 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     li R7, #1	# int, #@loadConI
040     spill R12 -&gt; R10	# spill size = 32
044 +   CMove R10, (R12 ge R7), R10, R7	#@cmovI_cmpI
	
04c +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='728'>
----------------------- MetaData before Compile_id = 728 ------------------------
{method}
 - this oop:          0x0000004096710760
 - method holder:     &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$52+0x00000008000c6000&apos;
 - constants:         0x0000004096710538 constant pool [20] {0x0000004096710538} for &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$52+0x00000008000c6000&apos; cache=0x00000040967107f0
 - access:            0x81000001  public 
 - name:              &apos;applyAsInt&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         2
 - max locals:        2
 - size of params:    2
 - method size:       13
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bb30: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x00000040139d7908
 - code size:         5
 - code start:        0x0000004096710758
 - code end (excl):   0x000000409671075d
 - method data:       0x0000004096710998
 - checked ex length: 0
 - localvar length:   0

------------------------ OptoAssembly for Compile_id = 728 -----------------------
#
#  int ( compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$52+0x00000008000c6000:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$52+0x00000008000c6000:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N17: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N17 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     li R7, #-1	# int, #@loadConI
040     spill R12 -&gt; R10	# spill size = 32
044 +   CMove R10, (R12 ge R7), R10, R7	#@cmovI_cmpI
	
04c +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='731'>
----------------------- MetaData before Compile_id = 731 ------------------------
{method}
 - this oop:          0x00000040967110f8
 - method holder:     &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$54+0x00000008000c64a0&apos;
 - constants:         0x0000004096710ed0 constant pool [20] {0x0000004096710ed0} for &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$54+0x00000008000c64a0&apos; cache=0x0000004096711188
 - access:            0x81000001  public 
 - name:              &apos;applyAsInt&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         2
 - max locals:        2
 - size of params:    2
 - method size:       13
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bb30: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x00000040139d7908
 - code size:         5
 - code start:        0x00000040967110f0
 - code end (excl):   0x00000040967110f5
 - method data:       0x0000004096711330
 - checked ex length: 0
 - localvar length:   0

------------------------ OptoAssembly for Compile_id = 731 -----------------------
#
#  int ( compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$54+0x00000008000c64a0:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$54+0x00000008000c64a0:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N17: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N17 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     li R7, #0	# int, #@loadConI
040     spill R12 -&gt; R10	# spill size = 32
044 +   CMove R10, (R12 le R7), R10, R7	#@cmovI_cmpI
	
04c +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='734'>
----------------------- MetaData before Compile_id = 734 ------------------------
{method}
 - this oop:          0x0000004096711a90
 - method holder:     &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$56+0x00000008000c6940&apos;
 - constants:         0x0000004096711868 constant pool [20] {0x0000004096711868} for &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$56+0x00000008000c6940&apos; cache=0x0000004096711b20
 - access:            0x81000001  public 
 - name:              &apos;applyAsInt&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         2
 - max locals:        2
 - size of params:    2
 - method size:       13
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bb30: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x00000040139d7908
 - code size:         5
 - code start:        0x0000004096711a88
 - code end (excl):   0x0000004096711a8d
 - method data:       0x0000004096711cc8
 - checked ex length: 0
 - localvar length:   0

------------------------ OptoAssembly for Compile_id = 734 -----------------------
#
#  int ( compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$56+0x00000008000c6940:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$56+0x00000008000c6940:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N17: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N17 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     li R7, #1	# int, #@loadConI
040     spill R12 -&gt; R10	# spill size = 32
044 +   CMove R10, (R12 le R7), R10, R7	#@cmovI_cmpI
	
04c +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='738'>
----------------------- MetaData before Compile_id = 738 ------------------------
{method}
 - this oop:          0x0000004096712428
 - method holder:     &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$58+0x00000008000c6de0&apos;
 - constants:         0x0000004096712200 constant pool [20] {0x0000004096712200} for &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$58+0x00000008000c6de0&apos; cache=0x00000040967124b8
 - access:            0x81000001  public 
 - name:              &apos;applyAsInt&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         2
 - max locals:        2
 - size of params:    2
 - method size:       13
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bb30: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x00000040139d7908
 - code size:         5
 - code start:        0x0000004096712420
 - code end (excl):   0x0000004096712425
 - method data:       0x0000004096712660
 - checked ex length: 0
 - localvar length:   0

------------------------ OptoAssembly for Compile_id = 738 -----------------------
#
#  int ( compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$58+0x00000008000c6de0:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$58+0x00000008000c6de0:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N17: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N17 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     li R7, #-1	# int, #@loadConI
040     spill R12 -&gt; R10	# spill size = 32
044 +   CMove R10, (R12 le R7), R10, R7	#@cmovI_cmpI
	
04c +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='749'>
----------------------- MetaData before Compile_id = 749 ------------------------
{method}
 - this oop:          0x0000004096712d98
 - method holder:     &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$60+0x00000008000c7260&apos;
 - constants:         0x0000004096712b70 constant pool [20] {0x0000004096712b70} for &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$60+0x00000008000c7260&apos; cache=0x0000004096712e00
 - access:            0x81000001  public 
 - name:              &apos;applyAsInt&apos;
 - signature:         &apos;(II)I&apos;
 - max stack:         3
 - max locals:        3
 - size of params:    3
 - method size:       13
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008317620: 0xbaa i2c: 0x0000004013945bc0 c2i: 0x0000004013945c0c c2iUV: 0x0000004013945bd8
 - compiled entry     0x0000004013945c0c
 - code size:         6
 - code start:        0x0000004096712d90
 - code end (excl):   0x0000004096712d96
 - method data:       0x0000004096712fe8
 - checked ex length: 0
 - localvar length:   0

------------------------ OptoAssembly for Compile_id = 749 -----------------------
#
#  int ( compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$60+0x00000008000c7260:NotNull:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$60+0x00000008000c7260:NotNull:exact *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N17: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N17 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     spill R13 -&gt; R10	# spill size = 32
040 +   CMove R10, (R12 lt R13), R10, R12	#@cmovI_cmpI
	
048 +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
060 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='774'>
----------------------- MetaData before Compile_id = 774 ------------------------
{method}
 - this oop:          0x000000409600faa8
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000000  
 - name:              &apos;&lt;init&gt;&apos;
 - signature:         &apos;([BB)V&apos;
 - max stack:         3
 - max locals:        3
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008317360: 0xbba i2c: 0x0000004013945140 c2i: 0x000000401394518c c2iUV: 0x0000004013945158
 - compiled entry     0x000000400c4b5a80
 - code size:         15
 - code start:        0x000000409600fa68
 - code end (excl):   0x000000409600fa77
 - method data:       0x00000040963f4ef0
 - checked ex length: 0
 - linenumber start:  0x000000409600fa77
 - localvar length:   3
 - localvar start:    0x000000409600fa82
 - compiled code: nmethod  27938   35       3       java.lang.String::&lt;init&gt; (15 bytes)

------------------------ OptoAssembly for Compile_id = 774 -----------------------
#
#  void ( java/lang/String:NotNull:exact *, byte[int:&gt;=0]:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: byte[int:&gt;=0]:exact *
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N166: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B7 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c      -- 	// R23=Thread::current(), empty, #@tlsLoadP
03c     lb  R28, [R23, #56]	# byte, #@loadB
040     spill R13 -&gt; R18	# spill size = 32
044 +   spill R12 -&gt; R9	# spill size = 64
048 +   bne  R28, zr, B7	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

04c     B2: #	out( B3 ) &lt;- in( B1 )  Freq: 0.999
04c +   spill R11 -&gt; R19	# spill size = 64

050     B3: #	out( B6 B4 ) &lt;- in( B14 B9 B7 B2 )  Freq: 1
050 +   mv  R7, R19	# ptr -&gt; long, #@castP2X
054 +   mv  R28, R9	# ptr -&gt; long, #@castP2X
058 +   xorr  R28, R28, R7	#@xorL_reg_reg
05c +   encode_heap_oop  R29, R9	#@encodeHeapOop
060 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
064 +   sw  R29, [R19, #20]	# compressed ptr, #@storeN ! Field: java/lang/String.value (constant)
068 +   beq  R28, zr, B6	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

06c     B4: #	out( B6 B5 ) &lt;- in( B3 )  Freq: 0.999
06c +   beq   R9, zr, B6	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

070     B5: #	out( B10 B6 ) &lt;- in( B4 )  Freq: 0.998001
070 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
074 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
080 +   add R10, R28, R7	# ptr, #@addP_reg_reg
084 +   lb  R28, [R10]	# byte, #@loadB
088 +   li R7, #4	# int, #@loadConI
08c +   bne  R28, R7, B10	#@cmpI_branch  P=0.001000 C=-1.000000

090     B6: #	out( N166 ) &lt;- in( B12 B13 B10 B5 B4 B3 )  Freq: 1
090 +   sb  R18, [R19, #16]	# byte, #@storeB ! Field: java/lang/String.coder (constant)
094 +   #@membar_release
	fence iorw ow
098 +   #@membar_release
	fence iorw ow
098 +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0b0 +   ret	// return register, #@Ret

0b4     B7: #	out( B3 B8 ) &lt;- in( B1 )  Freq: 0.000999987
0b4 +   lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0b8 +   decode_heap_oop  R10, R7	#@decodeHeapOop
0bc     spill R11 -&gt; R19	# spill size = 64
0c0 +   beq   R10, zr, B3	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

0c4     B8: #	out( B14 B9 ) &lt;- in( B7 )  Freq: 0.000499994
0c4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c4     ld  R7, [R23, #32]	# int, #@loadL
0c8 +   beq  R7, zr, B14	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0cc     B9: #	out( B3 ) &lt;- in( B8 )  Freq: 0.000499494
0cc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0cc     ld  R28, [R23, #48]	# ptr, #@loadP
0d0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
0d4 +   addi  R7, R7, #-8	#@addL_reg_imm
0d8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
0dc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0dc     sd  R7, [R23, #32]	# long, #@storeL
0e0 +   j  B3	#@branch

0e4     B10: #	out( B6 B11 ) &lt;- in( B5 )  Freq: 0.000998001
0e4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e4     ld  R7, [R23, #64]	# int, #@loadL
0e8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e8     ld  R28, [R23, #80]	# ptr, #@loadP
0ec +   #@membar_volatile
	fence iorw iorw
0f0 +   lb  R30, [R10]	# byte, #@loadB
0f4 +   beq  R30, zr, B6	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

0f8     B11: #	out( B13 B12 ) &lt;- in( B10 )  Freq: 0.000499001
0f8 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
0fc +   bne  R7, zr, B13	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

100     B12: #	out( B6 ) &lt;- in( B11 )  Freq: 0.0002495
100 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
100     spill R23 -&gt; R11	# spill size = 64
104 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
134 +   j  B6	#@branch

138     B13: #	out( B6 ) &lt;- in( B11 )  Freq: 0.0002495
138 +   add R28, R28, R7	# ptr, #@addP_reg_reg
13c +   addi  R7, R7, #-8	#@addL_reg_imm
140 +   sd  R10, [R28, #-8]	# ptr, #@storeP
144 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
144     sd  R7, [R23, #64]	# long, #@storeL
148 +   j  B6	#@branch

14c     B14: #	out( B3 ) &lt;- in( B8 )  Freq: 4.99987e-07
14c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
14c     spill R23 -&gt; R11	# spill size = 64
150 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
180 +   j  B3	#@branch

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='775'>
----------------------- MetaData before Compile_id = 775 ------------------------
{method}
 - this oop:          0x0000004096713728
 - method holder:     &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$62+0x00000008000c76c0&apos;
 - constants:         0x0000004096713500 constant pool [20] {0x0000004096713500} for &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$62+0x00000008000c76c0&apos; cache=0x0000004096713790
 - access:            0x81000001  public 
 - name:              &apos;applyAsInt&apos;
 - signature:         &apos;(II)I&apos;
 - max stack:         3
 - max locals:        3
 - size of params:    3
 - method size:       13
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008317620: 0xbaa i2c: 0x0000004013945bc0 c2i: 0x0000004013945c0c c2iUV: 0x0000004013945bd8
 - compiled entry     0x0000004013945c0c
 - code size:         6
 - code start:        0x0000004096713720
 - code end (excl):   0x0000004096713726
 - method data:       0x0000004096713938
 - checked ex length: 0
 - localvar length:   0

------------------------ OptoAssembly for Compile_id = 775 -----------------------
#
#  int ( compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$62+0x00000008000c76c0:NotNull:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$62+0x00000008000c76c0:NotNull:exact *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N17: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N17 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     spill R12 -&gt; R10	# spill size = 32
040 +   CMove R10, (R12 lt R13), R10, R13	#@cmovI_cmpI
	
048 +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
060 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='787'>
----------------------- MetaData before Compile_id = 787 ------------------------
{method}
 - this oop:          0x0000004096704298
 - method holder:     &apos;compiler/intrinsics/math/TestMinMaxIntrinsics&apos;
 - constants:         0x0000004096703310 constant pool [240]/operands[112] {0x0000004096703310} for &apos;compiler/intrinsics/math/TestMinMaxIntrinsics&apos; cache=0x0000004096705228
 - access:            0x81000008  static 
 - name:              &apos;maxL2I&apos;
 - signature:         &apos;(JI)I&apos;
 - max stack:         3
 - max locals:        3
 - size of params:    3
 - method size:       13
 - vtable index:      -2
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x0000004008323ac0: 0xbea i2c: 0x0000004013937740 c2i: 0x0000004013937788 c2iUV: 0x0000004013937754
 - compiled entry     0x0000004013937788
 - code size:         7
 - code start:        0x0000004096704288
 - code end (excl):   0x000000409670428f
 - method data:       0x0000004096714018
 - checked ex length: 0
 - linenumber start:  0x000000409670428f
 - localvar length:   0

------------------------ OptoAssembly for Compile_id = 787 -----------------------
#
#  int ( long, half, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: long
#r014 c_rarg2   : parm 2: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N1: #	out( B1 ) &lt;- in( B1 )  Freq: 1

000     B1: #	out( N1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
01c     addw  R10, R11, zr	#@convL2I_reg
020     CMove R10, (R10 lt R12), R10, R12	#@cmovI_cmpI
	
028 +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
040 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='792'>
----------------------- MetaData before Compile_id = 792 ------------------------
{method}
 - this oop:          0x00000040961e8fd0
 - method holder:     &apos;java/lang/CharacterDataLatin1&apos;
 - constants:         0x00000040961e89b8 constant pool [130] {0x00000040961e89b8} for &apos;java/lang/CharacterDataLatin1&apos; cache=0x00000040961eb818
 - access:            0x81000000  
 - name:              &apos;getProperties&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         3
 - max locals:        4
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      35
 - i2i entry:         0x00000040138cca80
 - adapters:          AHE@0x000000400824bb30: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c4f0680
 - code size:         11
 - code start:        0x00000040961e8f88
 - code end (excl):   0x00000040961e8f93
 - method data:       0x00000040965ed348
 - checked ex length: 0
 - linenumber start:  0x00000040961e8f93
 - localvar length:   4
 - localvar start:    0x00000040961e8f9e
 - compiled code: nmethod  28272  117       3       java.lang.CharacterDataLatin1::getProperties (11 bytes)

------------------------ OptoAssembly for Compile_id = 792 -----------------------
#
#  int ( java/lang/CharacterDataLatin1:NotNull *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/CharacterDataLatin1:NotNull *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N34: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B3 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     li R29, #256	# int, #@loadConI
040 +   zext.h  R7, R12	# s2ui, #@convS2UI_reg_reg_b
044 +   bgeu  R7, R29, B3	#@cmpU_branch  P=0.000001 C=-1.000000

048     B2: #	out( N34 ) &lt;- in( B1 )  Freq: 0.999999
048 +   addw  R7, R7, zr	#@convI2L_reg_reg
04c +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
050 +   mv  R28, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1154 address=0x00000040d01bf240&gt; *	# ptr, #@loadConP
068 +   add R7, R28, R7	# ptr, #@addP_reg_reg
06c +   lw  R10, [R7, #16]	# int, #@loadI
070     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
088 +   ret	// return register, #@Ret

08c     B3: #	out( N34 ) &lt;- in( B1 )  Freq: 1.01328e-06
08c +   li R11, #-28	# int, #@loadConI
090     spill R7 -&gt; R8	# spill size = 32
094     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.CharacterDataLatin1::getProperties @ bci:7 (line 74) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#Ptr0x00000040d01bf240 STK[1]=R8
        # OopMap {off=152/0x98}
098 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>
<writer thread='3870970'/>
C1 Runtime statistics:
 _resolve_invoke_virtual_cnt:     147
 _resolve_invoke_opt_virtual_cnt: 458
 _resolve_invoke_static_cnt:      164
 _handle_wrong_method_cnt:        122
 _ic_miss_cnt:                    60
 _generic_arraycopystub_cnt:      0
 _byte_arraycopy_cnt:             0
 _short_arraycopy_cnt:            0
 _int_arraycopy_cnt:              0
 _long_arraycopy_cnt:             0
 _oop_arraycopy_cnt:              0
 _arraycopy_slowcase_cnt:         0
 _arraycopy_checkcast_cnt:        0
 _arraycopy_checkcast_attempt_cnt:0
 _new_type_array_slowcase_cnt:    2
 _new_object_array_slowcase_cnt:  2
 _new_instance_slowcase_cnt:      3
 _new_multi_array_slowcase_cnt:   0
 _monitorenter_slowcase_cnt:      8
 _monitorexit_slowcase_cnt:       8
 _patch_code_slowcase_cnt:        0
 _throw_range_check_exception_count:            0:
 _throw_index_exception_count:                  0:
 _throw_div0_exception_count:                   0:
 _throw_null_pointer_exception_count:           0:
 _throw_class_cast_exception_count:             0:
 _throw_incompatible_class_change_error_count:  0:
 _throw_count:                                  0:

<statistics type='deoptimization'>
Deoptimization traps recorded:
    23 (100.0%) total
    null_check/make_not_entrant/instanceof: 1 (4.3%)
              range_check/reinterpret/ifge: 1 (4.3%)
       range_check/make_not_entrant/baload: 1 (4.3%)
  class_check/maybe_recompile/invokeinterface: 4 (17.4%)
  bimorphic/maybe_recompile/invokeinterface: 4 (17.4%)
              unstable_if/reinterpret/ifeq: 2 (8.7%)
         unstable_if/reinterpret/if_icmpne: 2 (8.7%)
              unstable_if/reinterpret/ifne: 2 (8.7%)
               unstable_if/reinterpret/nop: 6 (26.1%)
</statistics>
<statistics type='SharedRuntime'>
   11 new instance requires GC
   30 new array requires GC
   60 inline cache miss in compiled
  122 wrong method
  164 unresolved static call site
  147 unresolved virtual call site
  458 unresolved opt virtual call site
28909 slow partial subtype
28877 unsafe array copies
AdapterHandlerTable: empty 112 longest 4 total 263 average 1.453039
AdapterHandlerTable: lookups 4919 buckets 5563 equals 4246 hits 4246 compact 4246
</statistics>
<statistics type='opto'>
--- Compiler Statistics ---
Methods seen: 1070  Methods parsed: 1070  Nodes created: 188348
Blocks parsed: 3035  Blocks seen: 4015
3447 original NULL checks - 2934 elided (85%); optimizer leaves 671,
363 made implicit (54%)
1 implicit null exceptions at runtime
CCP: 113  constants found: 0
Total frameslots = 816, Max frameslots = 36
Inserted 0 spill loads, 0 spill stores, 0 mem-mem moves and 0 copies.
Total load cost=      0, store cost =      0, mem-mem cost =  0.00, copy cost =     0.
Adjusted spill cost =       0.
Conservatively coalesced 326 copies, 0 pairs, 2784 post alloc.
Average allocation trips 1.732283
High Pressure Blocks = 0, Low Pressure Blocks = 0
Nops added 0 bytes to total of 137248 bytes, for 0.00%
Peephole: peephole rules applied: 0
PhaseIdealLoop=446, sum _unique=479245, long loops=0/0/0
</statistics>
<statistics type='intrinsic'>
Compiler intrinsic usage:
     9 ( 7.9%) _hashCode (worked,virtual)
     2 ( 1.8%) _getClass (worked)
    12 (10.5%) _min (worked)
     6 ( 5.3%) _max (worked)
    20 (17.5%) _arraycopy (worked)
    13 (11.4%) _currentThread (worked)
     2 ( 1.8%) _isArray (worked)
     3 ( 2.6%) _isPrimitive (worked)
     0 ( 0.0%) _compressStringC (disabled)
     6 ( 5.3%) _indexOfL_char (worked)
    18 (15.8%) _equalsL (worked)
     0 ( 0.0%) _hasNegatives (disabled)
    11 ( 9.6%) _Reference_refersTo0 (worked)
     1 ( 0.9%) _allocateUninitializedArray (worked)
     2 ( 1.8%) _copyMemory (worked)
     2 ( 1.8%) _putByte (worked)
     7 ( 6.1%) _compareAndSetInt (worked)
   114 (100.0%) total (worked,disabled,virtual)
</statistics>
<tty_done stamp='36.174'/>
</tty>
<hotspot_log_done stamp='36.174'/>
</hotspot_log>

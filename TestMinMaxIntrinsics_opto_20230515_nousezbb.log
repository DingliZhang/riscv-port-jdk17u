<?xml version='1.0' encoding='UTF-8'?>
<hotspot_log version='160 1' process='3869225' time_ms='1684143318748'>
<vm_version>
<name>
OpenJDK 64-Bit Server VM
</name>
<release>
17.0.8-internal+0-adhoc.zhangdingli.riscv-port-jdk17u
</release>
<info>
OpenJDK 64-Bit Server VM (fastdebug 17.0.8-internal+0-adhoc.zhangdingli.riscv-port-jdk17u) for linux-riscv64 JRE (17.0.8-internal+0-adhoc.zhangdingli.riscv-port-jdk17u), built on May 15 2023 09:09:03 by &quot;zhangdingli&quot; with gcc 9.2.0
</info>
</vm_version>
<vm_arguments>
<args>
-Dtest.vm.opts=-Djdk.lang.Process.launchMechanism=vfork -Dtest.tool.vm.opts=-J-Djdk.lang.Process.launchMechanism=vfork -Dtest.compiler.opts= -Dtest.java.opts=-XX:+PrintOptoAssembly -XX:LogFile=/home/zhangdingli/riscv-port-jdk17u/TestMinMaxIntrinsics_opto_20230515_nousezbb.log -Dtest.jdk=/home/zhangdingli/riscv-port-jdk17u/build/linux-riscv64-server-fastdebug/jdk -Dcompile.jdk=/home/zhangdingli/riscv-port-jdk17u/build/linux-x86_64-server-release/images/jdk -Dtest.timeout.factor=16.0 -Dtest.root=/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg -Dtest.name=compiler/intrinsics/math/TestMinMaxIntrinsics.java -Dtest.file=/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg/compiler/intrinsics/math/TestMinMaxIntrinsics.java -Dtest.src=/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg/compiler/intrinsics/math -Dtest.src.path=/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg/compiler/intrinsics/math:/home/zhangdingli/riscv-port-jdk17u/test/lib:/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg -Dtest.classes=/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0/compiler/intrinsics/math/TestMinMaxIntrinsics.d -Dtest.class.path=/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0/compiler/intrinsics/math/TestMinMaxIntrinsics.d:/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0/test/lib:/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0 -Dtest.modules=java.base/jdk.internal.misc --add-modules=java.base --add-exports=java.base/jdk.internal.misc=ALL-UNNAMED -Djdk.lang.Process.launchMechanism=vfork -XX:+PrintOptoAssembly -XX:LogFile=/home/zhangdingli/riscv-port-jdk17u/TestMinMaxIntrinsics_opto_20230515_nousezbb.log -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-BackgroundCompilation -XX:-UseOnStackReplacement </args>
<command>
com.sun.javatest.regtest.agent.MainWrapper /home/zhangdingli/riscv-port-jdk17u/JTwork/compiler/intrinsics/math/TestMinMaxIntrinsics.d/main.4.jta
</command>
<launcher>
SUN_STANDARD
</launcher>
<properties>
java.vm.specification.name=Java Virtual Machine Specification
java.vm.version=17.0.8-internal+0-adhoc.zhangdingli.riscv-port-jdk17u
java.vm.name=OpenJDK 64-Bit Server VM
jdk.debug=fastdebug
sun.boot.library.path=/home/zhangdingli/riscv-port-jdk17u/build/linux-riscv64-server-fastdebug/jdk/lib
java.library.path=/usr/java/packages/lib:/usr/lib64:/lib64:/lib:/usr/lib
java.home=/home/zhangdingli/riscv-port-jdk17u/build/linux-riscv64-server-fastdebug/jdk
java.class.path=/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0/compiler/intrinsics/math/TestMinMaxIntrinsics.d:/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg/compiler/intrinsics/math:/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0/test/lib:/home/zhangdingli/riscv-port-jdk17u/test/lib:/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0:/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg:/home/zhangdingli/jdk-tools/jtreg-6+1-riscv64fix/lib/javatest.jar:/home/zhangdingli/jdk-tools/jtreg-6+1-riscv64fix/lib/jtreg.jar
jdk.boot.class.path.append=:.
java.vm.info=mixed mode, sharing
java.vm.specification.vendor=Oracle Corporation
java.vm.specification.version=17
java.vm.vendor=Oracle Corporation
test.vm.opts=-Djdk.lang.Process.launchMechanism=vfork
test.tool.vm.opts=-J-Djdk.lang.Process.launchMechanism=vfork
test.compiler.opts=
test.java.opts=-XX:+PrintOptoAssembly -XX:LogFile=/home/zhangdingli/riscv-port-jdk17u/TestMinMaxIntrinsics_opto_20230515_nousezbb.log
test.jdk=/home/zhangdingli/riscv-port-jdk17u/build/linux-riscv64-server-fastdebug/jdk
compile.jdk=/home/zhangdingli/riscv-port-jdk17u/build/linux-x86_64-server-release/images/jdk
test.timeout.factor=16.0
test.root=/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg
test.name=compiler/intrinsics/math/TestMinMaxIntrinsics.java
test.file=/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg/compiler/intrinsics/math/TestMinMaxIntrinsics.java
test.src=/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg/compiler/intrinsics/math
test.src.path=/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg/compiler/intrinsics/math:/home/zhangdingli/riscv-port-jdk17u/test/lib:/home/zhangdingli/riscv-port-jdk17u/test/hotspot/jtreg
test.classes=/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0/compiler/intrinsics/math/TestMinMaxIntrinsics.d
test.class.path=/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0/compiler/intrinsics/math/TestMinMaxIntrinsics.d:/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0/test/lib:/home/zhangdingli/riscv-port-jdk17u/JTwork/classes/0
test.modules=java.base/jdk.internal.misc
jdk.lang.Process.launchMechanism=vfork
sun.java.command=com.sun.javatest.regtest.agent.MainWrapper /home/zhangdingli/riscv-port-jdk17u/JTwork/compiler/intrinsics/math/TestMinMaxIntrinsics.d/main.4.jta
sun.java.launcher=SUN_STANDARD
</properties>
</vm_arguments>
<tty>
<writer thread='3869227'/>
<blob name='MethodHandlesAdapterBlob' size='152448'>
<sect index='1' size='152448' free='150668'/>
</blob>
<writer thread='3869246'/>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='16'>
----------------------- MetaData before Compile_id = 16 ------------------------
{method}
 - this oop:          0x0000004096000518
 - method holder:     &apos;java/lang/Object&apos;
 - constants:         0x00000040960000d0 constant pool [92] {0x00000040960000d0} for &apos;java/lang/Object&apos; cache=0x000000409613ea08
 - access:            0x81000001  public 
 - name:              &apos;&lt;init&gt;&apos;
 - signature:         &apos;()V&apos;
 - max stack:         1
 - max locals:        1
 - size of params:    1
 - method size:       13
 - intrinsic id:      337 _Object_init
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4ac200
 - code size:         1
 - code start:        0x00000040960004f8
 - code end (excl):   0x00000040960004f9
 - method data:       0x00000040962523b8
 - checked ex length: 0
 - linenumber start:  0x00000040960004f9
 - localvar length:   1
 - localvar start:    0x0000004096000502
 - compiled code: nmethod   2058    1       3       java.lang.Object::&lt;init&gt; (1 bytes)

------------------------ OptoAssembly for Compile_id = 16 -----------------------
#
#  void ( java/lang/Object:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/Object:NotNull *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N13: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N13 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
054 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='66'>
----------------------- MetaData before Compile_id = 66 ------------------------
{method}
 - this oop:          0x0000004096009ee8
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;charAt&apos;
 - signature:         &apos;(I)C&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b960: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c4ad600
 - code size:         25
 - code start:        0x0000004096009ea8
 - code end (excl):   0x0000004096009ec1
 - method data:       0x000000409630c3c0
 - checked ex length: 0
 - linenumber start:  0x0000004096009ec1
 - localvar length:   2
 - localvar start:    0x0000004096009ece
 - compiled code: nmethod   3096    4       3       java.lang.String::charAt (25 bytes)

------------------------ OptoAssembly for Compile_id = 66 -----------------------
#
#  char ( java/lang/String:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N66: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B5 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
040 +   lb  R29, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
044 +   decode_heap_oop  R7, R7	#@decodeHeapOop
048 +   bne  R29, zr, B5	#@cmpI_reg_imm0_branch  P=0.000000 C=15897.000000

04c     B2: #	out( B7 B3 ) &lt;- in( B1 )  Freq: 1
04c     lwu  R28, [R7, #12]	# range, #@loadRange
050     NullCheck R7

050     B3: #	out( B6 B4 ) &lt;- in( B2 )  Freq: 0.999999
050 +   bgeu  R12, R28, B6	#@cmpU_branch  P=0.000000 C=14591.000000

054     B4: #	out( N66 ) &lt;- in( B3 )  Freq: 0.999998
054 +   addw  R28, R12, zr	#@convI2L_reg_reg
058 +   add R7, R7, R28	# ptr, #@addP_reg_reg
05c +   lbu  R10, [R7, #16]	# byte, #@loadUB
060     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
078 +   ret	// return register, #@Ret

07c     B5: #	out( N66 ) &lt;- in( B1 )  Freq: 5e-07
07c +   spill R11 -&gt; R8	# spill size = 64
080 +   spill R12 -&gt; [sp, #0]	# spill size = 32
084 +   spill R29 -&gt; [sp, #4]	# spill size = 32
088 +   li R11, #-187	# int, #@loadConI
08c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #4
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop off=144/0x90}
090     #@ShouldNotReachHere

09c     B6: #	out( N66 ) &lt;- in( B3 )  Freq: 4.76836e-07
09c +   li R11, #-27	# int, #@loadConI
0a0     spill R7 -&gt; R8	# spill size = 64
0a4 +   spill R12 -&gt; [sp, #4]	# spill size = 32
0a8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:1 (line 47) L[0]=R8 L[1]=sp + #4 STK[0]=sp + #4
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=172/0xac}
0ac     #@ShouldNotReachHere

0b8     B7: #	out( N66 ) &lt;- in( B2 )  Freq: 1.01328e-06
0b8 +   li R11, #-10	# int, #@loadConI
0bc     spill R7 -&gt; R8	# spill size = 64
0c0 +   spill R12 -&gt; [sp, #4]	# spill size = 32
0c4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::charAt @ bci:1 (line 47) L[0]=R8 L[1]=sp + #4 STK[0]=sp + #4
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=200/0xc8}
0c8 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>
<writer thread='3869227'/>
<dependency_failed type='unique_concrete_method_4' ctxk='java/util/concurrent/ConcurrentHashMap$Node' x='java.util.concurrent.ConcurrentHashMap$Node find (ILjava/lang/Object;)Ljava/util/concurrent/ConcurrentHashMap$Node;' x2='java/util/concurrent/ConcurrentHashMap$Node' x3='java.util.concurrent.ConcurrentHashMap$Node find (ILjava/lang/Object;)Ljava/util/concurrent/ConcurrentHashMap$Node;' witness='java/util/concurrent/ConcurrentHashMap$ReservationNode' stamp='3.265'/>
<writer thread='3869246'/>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='78'>
----------------------- MetaData before Compile_id = 78 ------------------------
{method}
 - this oop:          0x000000409638b398
 - method holder:     &apos;jdk/internal/org/objectweb/asm/SymbolTable&apos;
 - constants:         0x0000004096388ec8 constant pool [594] {0x0000004096388ec8} for &apos;jdk/internal/org/objectweb/asm/SymbolTable&apos; cache=0x000000409638e840
 - access:            0x81000002  private 
 - name:              &apos;get&apos;
 - signature:         &apos;(I)Ljdk/internal/org/objectweb/asm/SymbolTable$Entry;&apos;
 - max stack:         4
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b960: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c4afc80
 - code size:         13
 - code start:        0x000000409638b368
 - code end (excl):   0x000000409638b375
 - method data:       0x00000040963c5de0
 - checked ex length: 0
 - linenumber start:  0x000000409638b375
 - localvar length:   2
 - localvar start:    0x000000409638b37e
 - compiled code: nmethod   3307   20       3       jdk.internal.org.objectweb.asm.SymbolTable::get (13 bytes)

------------------------ OptoAssembly for Compile_id = 78 -----------------------
#
#  jdk/internal/org/objectweb/asm/SymbolTable$Entry * ( jdk/internal/org/objectweb/asm/SymbolTable:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: jdk/internal/org/objectweb/asm/SymbolTable:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N62: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B7 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #44]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/org/objectweb/asm/SymbolTable.entries
040 +   decode_heap_oop  R7, R7	#@decodeHeapOop
044     lwu  R28, [R7, #12]	# range, #@loadRange
048     NullCheck R7

048     B2: #	out( B6 B3 ) &lt;- in( B1 )  Freq: 0.999999
048 +   bleu  R28, zr, B6	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

04c     B3: #	out( B5 B4 ) &lt;- in( B2 )  Freq: 0.999998
04c +   remw  R8, R12, R28	#@modI
050 +   bgeu  R8, R28, B5	#@cmpU_branch  P=0.000001 C=-1.000000

054     B4: #	out( N62 ) &lt;- in( B3 )  Freq: 0.999997
054 +   addw  R28, R8, zr	#@convI2L_reg_reg
058 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
05c +   add R7, R7, R28	# ptr, #@addP_reg_reg
060 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN
064 +   decode_heap_oop  R10, R28	#@decodeHeapOop
068     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
080 +   ret	// return register, #@Ret

084     B5: #	out( N62 ) &lt;- in( B3 )  Freq: 1.01328e-06
084 +   li R11, #-28	# int, #@loadConI
088     spill R7 -&gt; [sp, #0]	# spill size = 64
08c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.org.objectweb.asm.SymbolTable::get @ bci:11 (line 425) L[0]=_ L[1]=_ STK[0]=sp + #0 STK[1]=R8
        # OopMap {[0]=Oop off=144/0x90}
090     #@ShouldNotReachHere

09c     B6: #	out( N62 ) &lt;- in( B2 )  Freq: 9.99999e-07
09c +   li R11, #-122	# int, #@loadConI
0a0     spill R12 -&gt; R8	# spill size = 32
0a4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;div0_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.org.objectweb.asm.SymbolTable::get @ bci:10 (line 425) L[0]=_ L[1]=_ STK[0]=_ STK[1]=R8 STK[2]=#0
        # OopMap {off=168/0xa8}
0a8     #@ShouldNotReachHere

0b4     B7: #	out( N62 ) &lt;- in( B1 )  Freq: 1.01328e-06
0b4 +   li R11, #-10	# int, #@loadConI
0b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.org.objectweb.asm.SymbolTable::get @ bci:9 (line 425) L[0]=_ L[1]=_ STK[0]=_ STK[1]=_ STK[2]=#NULL
        # OopMap {off=188/0xbc}
0bc +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='105'>
----------------------- MetaData before Compile_id = 105 ------------------------
{method}
 - this oop:          0x000000409600fcd8
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000000  
 - name:              &apos;isLatin1&apos;
 - signature:         &apos;()Z&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4ac600
 - code size:         19
 - code start:        0x000000409600fcb0
 - code end (excl):   0x000000409600fcc3
 - method data:       0x00000040962e09d0
 - checked ex length: 0
 - linenumber start:  0x000000409600fcc3
 - localvar length:   1
 - localvar start:    0x000000409600fcca
 - compiled code: nmethod   3679    2       3       java.lang.String::isLatin1 (19 bytes)

------------------------ OptoAssembly for Compile_id = 105 -----------------------
#
#  bool ( java/lang/String:NotNull:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N28: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B3 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     lb  R28, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
040 +   bne  R28, zr, B3	#@cmpI_reg_imm0_branch  P=0.000000 C=24831.000000

044     B2: #	out( N28 ) &lt;- in( B1 )  Freq: 1
044 +   li R10, #1	# int, #@loadConI
048     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
060 +   ret	// return register, #@Ret

064     B3: #	out( N28 ) &lt;- in( B1 )  Freq: 5e-07
064 +   li R11, #-187	# int, #@loadConI
068     spill R28 -&gt; R8	# spill size = 32
06c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=R8
        # OopMap {off=112/0x70}
070 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='129'>
----------------------- MetaData before Compile_id = 129 ------------------------
{method}
 - this oop:          0x00000040962b7238
 - method holder:     &apos;sun/nio/fs/UnixPath&apos;
 - constants:         0x00000040962b5440 constant pool [472] {0x00000040962b5440} for &apos;sun/nio/fs/UnixPath&apos; cache=0x00000040962ba1a0
 - access:            0xf1000002  private 
 - name:              &apos;initOffsets&apos;
 - signature:         &apos;()V&apos;
 - max stack:         4
 - max locals:        6
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4eac80
 - code size:         189
 - code start:        0x00000040962b70f8
 - code end (excl):   0x00000040962b71b5
 - method data:       0x00000040965eb628
 - checked ex length: 0
 - linenumber start:  0x00000040962b71b5
 - localvar length:   6
 - localvar start:    0x00000040962b71dc
 - compiled code: nmethod   4274  110   !   3       sun.nio.fs.UnixPath::initOffsets (189 bytes)

------------------------ OptoAssembly for Compile_id = 129 -----------------------
#
#  void ( sun/nio/fs/UnixPath:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixPath:NotNull *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: Fixed slot 3
#r258 sp+40: Fixed slot 2
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1045: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B3 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lwu  R28, [R11, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
040 +   #@membar_acquire
	fence ir iorw
044 +   spill R11 -&gt; [sp, #0]	# spill size = 64
048 +   beq   R28, zr, B3	#@cmpP_narrowOop_imm0_branch  P=0.045921 C=2047.000000

04c     B2: #	out( N1045 ) &lt;- in( B81 B80 B1 )  Freq: 0.999995
04c     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

068     B3: #	out( B113 B4 ) &lt;- in( B1 )  Freq: 0.0459208
068 +   lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
06c +   decode_heap_oop  R8, R7	#@decodeHeapOop
070     lwu  R30, [R8, #12]	# range, #@loadRange
074     NullCheck R8

074     B4: #	out( B107 B5 ) &lt;- in( B3 )  Freq: 0.0459208
074 +   addiw  R28, R30, #-1	#@addI_reg_imm
078 +   bleu  R30, zr, B107	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

07c     B5: #	out( B106 B6 ) &lt;- in( B4 )  Freq: 0.0459208
07c +   bgeu  R28, R30, B106	#@cmpU_branch  P=0.000001 C=-1.000000

080     B6: #	out( B13 ) &lt;- in( B5 )  Freq: 0.0459207
080 +   addiw  R10, R30, #-3	#@addI_reg_imm
084 +   li R13, #1	# int, #@loadConI
088 +   li R31, #0	# int, #@loadConI
08c +   li R7, #0	# int, #@loadConI
090 +   j  B13	#@branch

094     B7: #	out( B11 ) &lt;- in( B29 )  Freq: 0.0707626
094 +   addiw  R31, R31, #3	#@addI_reg_imm
098 +   j  B11	#@branch

09c     B8: #	out( B11 ) &lt;- in( B28 )  Freq: 0.0781676
09c +   addiw  R31, R31, #2	#@addI_reg_imm
0a0 +   j  B11	#@branch

0a4     B9: #	out( B11 ) &lt;- in( B27 )  Freq: 0.0863475
0a4 +   addiw  R31, R31, #1	#@addI_reg_imm
0a8 +   j  B11	#@branch

0ac     B10: #	out( B11 ) &lt;- in( B14 )  Freq: 0.380803
0ac +   spill R13 -&gt; R31	# spill size = 32

0b0     B11: #	out( B38 B12 ) &lt;- in( B36 B32 B34 B37 B26 B8 B9 B7 B82 B10 ) top-of-loop Freq: 0.785988
0b0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0b0     ld  R28, [R23, #920]	# ptr, #@loadP
0b4 +   lwu zr, [R28]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.UnixPath::initOffsets @ bci:77 (line 190) L[0]=sp + #0 L[1]=R7 L[2]=R31 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=180/0xb4}
0b8 +   bge  R31, R30, B38	#@cmpI_branch  P=0.058421 C=1515.000000

0bc     B12: #	out( B13 ) &lt;- in( B11 )  Freq: 0.74007
0bc +   addiw  R13, R31, #1	#@addI_reg_imm

0c0     B13: #	out( B93 B14 ) &lt;- in( B6 B12 ) Loop( B13-B12 ) Freq: 0.78599
0c0 +   addw  R28, R31, zr	#@convI2L_reg_reg
0c4 +   add R28, R8, R28	# ptr, #@addP_reg_reg
0c8 +   bgeu  R31, R30, B93	#@cmpU_branch  P=0.000001 C=-1.000000

0cc     B14: #	out( B10 B15 ) &lt;- in( B13 )  Freq: 0.785989
0cc +   lb  R28, [R28, #16]	# byte, #@loadB
0d0 +   li R31, #47	# int, #@loadConI
0d4 +   beq  R28, R31, B10	#@cmpI_branch  P=0.484488 C=1515.000000

0d8     B15: #	out( B82 B16 ) &lt;- in( B14 )  Freq: 0.405187
0d8 +   addiw  R7, R7, #1	#@addI_reg_imm
0dc +   bge  R13, R30, B82	#@cmpI_branch  P=0.012796 C=7346.000000

0e0     B16: #	out( B96 B17 ) &lt;- in( B15 )  Freq: 0.400002
0e0 +   bgeu  R13, R30, B96	#@cmpU_branch  P=0.000001 C=-1.000000

0e4     B17: #	out( B18 ) &lt;- in( B16 )  Freq: 0.400001
0e4 +   addiw  R29, R13, #1	#@addI_reg_imm

0e8     B18: #	out( B37 B19 ) &lt;- in( B17 B20 ) Loop( B18-B20 inner pre of N1028) Freq: 0.730775
0e8 +   addw  R28, R13, zr	#@convI2L_reg_reg
0ec +   add R28, R8, R28	# ptr, #@addP_reg_reg
0f0 +   lb  R28, [R28, #16]	# byte, #@loadB
0f4 +   li R31, #47	# int, #@loadConI
0f8 +   beq  R28, R31, B37	#@cmpI_branch  P=0.094732 C=7252.000000

0fc     B19: #	out( B21 B20 ) &lt;- in( B18 )  Freq: 0.661547
0fc +   addiw  R11, R13, #1	#@addI_reg_imm
100 +   bge  R11, R29, B21	#@cmpI_loop  P=0.500000 C=6565.000000

104     B20: #	out( B18 ) &lt;- in( B19 )  Freq: 0.330773
104 +   spill R11 -&gt; R13	# spill size = 32
108 +   j  B18	#@branch

10c     B21: #	out( B98 B22 ) &lt;- in( B19 )  Freq: 0.330773
10c +   bge  R11, R10, B98	#@cmpI_branch  P=0.000001 C=-1.000000

110     B22: #	out( B99 B23 ) &lt;- in( B21 )  Freq: 0.330773
110 +   spill R11 -&gt; R31	# spill size = 32
114 +   addiw  R28, R13, #4	#@addI_reg_imm
118 +   # castII of R31, #@castII
118     bgeu  R31, R30, B99	#@cmpU_branch  P=0.000001 C=-1.000000

11c     B23: #	out( B100 B24 ) &lt;- in( B22 )  Freq: 0.330773
11c +   bgeu  R11, R30, B100	#@cmpU_branch  P=0.000001 C=-1.000000

120     B24: #	out( B101 B25 ) &lt;- in( B23 )  Freq: 0.330772
120 +   bgeu  R28, R30, B101	#@cmpU_branch  P=0.000001 C=-1.000000

124     B25: #	out( B26 ) &lt;- in( B24 B31 ) Loop( B25-B31 ) Freq: 0.339314
124 +   subw  R29, R30, R31	#@subI_reg_reg
128 +   li R11, #0	# int, #@loadConI
12c +   addiw  R28, R29, #-3	#@addI_reg_imm
130     CMove R28, (R10 lt R31), R28, R11	#@cmovI_cmpI
	
138 +   li R12, #4000	# int, #@loadConI
140 +   li R29, #4000	# int, #@loadConI
148     CMove R28, (R28 gtu R29), R28, R12	#@cmovI_cmpU
	
150 +   addw  R29, R28, R31	#@addI_reg_reg
        nop 	# 6 bytes pad for loops and calls

160     B26: #	out( B11 B27 ) &lt;- in( B25 B30 ) Loop( B26-B30 inner main of N109 strip mined) Freq: 1.00687
160 +   addw  R28, R31, zr	#@convI2L_reg_reg
164 +   add R28, R8, R28	# ptr, #@addP_reg_reg
168 +   lb  R11, [R28, #16]	# byte, #@loadB
16c +   li R12, #47	# int, #@loadConI
170 +   beq  R11, R12, B11	#@cmpI_branch  P=0.094732 C=7252.000000

174     B27: #	out( B9 B28 ) &lt;- in( B26 )  Freq: 0.911488
174 +   lb  R12, [R28, #17]	# byte, #@loadB
178 +   li R13, #47	# int, #@loadConI
17c +   beq  R12, R13, B9	#@cmpI_branch  P=0.094732 C=7252.000000

180     B28: #	out( B8 B29 ) &lt;- in( B27 )  Freq: 0.825141
180 +   lb  R11, [R28, #18]	# byte, #@loadB
184 +   li R12, #47	# int, #@loadConI
188 +   beq  R11, R12, B8	#@cmpI_branch  P=0.094732 C=7252.000000

18c     B29: #	out( B7 B30 ) &lt;- in( B28 )  Freq: 0.746973
18c +   lb  R11, [R28, #19]	# byte, #@loadB
190 +   beq  R11, R12, B7	#@cmpI_branch  P=0.094732 C=7252.000000

194     B30: #	out( B26 B31 ) &lt;- in( B29 )  Freq: 0.676211
194 +   addiw  R31, R31, #4	#@addI_reg_imm
198 +   blt  R31, R29, B26	#@cmpI_loop  P=0.987204 C=6565.000000

19c     B31: #	out( B25 B32 ) &lt;- in( B30 )  Freq: 0.00865286
19c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
19c     ld  R11, [R23, #920]	# ptr, #@loadP
1a0 +   lwu zr, [R11]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.UnixPath::initOffsets @ bci:74 (line 188) L[0]=sp + #0 L[1]=R7 L[2]=R31 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=416/0x1a0}
1a4 +   blt  R31, R10, B25	#@cmpI_branch  P=0.987204 C=6565.000000

1a8     B32: #	out( B11 B33 ) &lt;- in( B98 B31 )  Freq: 0.000111058
1a8 +   bge  R31, R30, B11	#@cmpI_branch  P=0.500000 C=-1.000000

1ac     B33: #	out( B111 B34 ) &lt;- in( B32 )  Freq: 5.5529e-05
1ac +   # castII of R31, #@castII
1ac     bgeu  R31, R30, B111	#@cmpU_branch  P=0.000001 C=-1.000000

1b0     B34: #	out( B11 B35 ) &lt;- in( B33 B35 ) Loop( B34-B35 inner post of N1028) Freq: 0.000101448
1b0 +   addw  R28, R31, zr	#@convI2L_reg_reg
1b4 +   add R28, R8, R28	# ptr, #@addP_reg_reg
1b8 +   lb  R28, [R28, #16]	# byte, #@loadB
1bc +   li R29, #47	# int, #@loadConI
1c0 +   beq  R28, R29, B11	#@cmpI_branch  P=0.094732 C=7252.000000

1c4     B35: #	out( B34 B36 ) &lt;- in( B34 )  Freq: 9.18372e-05
1c4 +   addiw  R31, R31, #1	#@addI_reg_imm
1c8 +   blt  R31, R30, B34	#@cmpI_loop  P=0.500000 C=6565.000000

1cc     B36: #	out( B11 ) &lt;- in( B35 )  Freq: 4.59186e-05
1cc +   j  B11	#@branch

1d0     B37: #	out( B11 ) &lt;- in( B18 )  Freq: 0.0692281
1d0 +   spill R13 -&gt; R31	# spill size = 32
1d4 +   j  B11	#@branch

1d8     B38: #	out( B39 B39 ) &lt;- in( B11 )  Freq: 0.0459185
1d8 +   li R29, #262144	# int, #@loadConI
1dc +   addw  R28, R7, zr	#@convI2L_reg_reg
1e0 +   bleu  R7, R29, B39	#@cmpU_branch  P=0.999999 C=-1.000000

1e4     B39: #	out( B91 B40 ) &lt;- in( B38 B38 )  Freq: 0.0459185
1e4 +   bgtu  R7, R29, B91	#@cmpU_branch  P=0.000001 C=-1.000000

1e8     B40: #	out( B91 B41 ) &lt;- in( B39 )  Freq: 0.0459185
1e8 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
1ec +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ec     ld  R29, [R23, #288]	# ptr, #@loadP
1f0 +   addi  R28, R28, #23	#@addL_reg_imm
1f4     spill R29 -&gt; R31	# spill size = 64
1f8 +   andi  R29, R28, #-8	#@andL_reg_imm
1fc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1fc     ld  R11, [R23, #304]	# ptr, #@loadP
200 +   add R29, R31, R29	# ptr, #@addP_reg_reg
204 +   bgeu  R29, R11, B91	#@cmpP_branch  P=0.000100 C=-1.000000

208     B41: #	out( B42 ) &lt;- in( B40 )  Freq: 0.0459139
208 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
208     sd  R29, [R23, #288]	# ptr, #@storeP
20c +   li R29, #1	# long, #@loadConL
210 +   sd  R29, [R31]	# long, #@storeL
214 +   mv  R29, narrowklass: precise klass [I: 0x00000040d001b7c0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
224 +   sw  R29, [R31, #8]	# compressed klass ptr, #@storeNKlass
228 +   srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
22c     spill R31 -&gt; R28	# spill size = 64
230 +   addi  R28, R31, #16	# ptr, #@addP_reg_imm
234 +   addi  R29, R29, #-2	#@addL_reg_imm
238 +   sw  R7, [R31, #12]	# int, #@storeI
23c +   ClearArray R29, R28	#@clearArray_reg_reg

294     B42: #	out( B49 ) &lt;- in( B92 B41 )  Freq: 0.0459185
294     
294     MEMBAR-store-store	#@membar_storestore
298 +   spill R31 -&gt; R28	# spill size = 64
29c +   # checkcastPP of R28, #@checkCastPP
29c     li R12, #0	# int, #@loadConI
2a0     spill R28 -&gt; [sp, #24]	# spill size = 64
2a4 +   li R28, #0	# int, #@loadConI
2a8 +   # castII of R7, #@castII
2a8     j  B49	#@branch

2ac     B43: #	out( B47 ) &lt;- in( B66 )  Freq: 0.0707586
2ac +   addiw  R12, R12, #3	#@addI_reg_imm
2b0 +   j  B47	#@branch

2b4     B44: #	out( B47 ) &lt;- in( B65 )  Freq: 0.0781631
2b4 +   addiw  R12, R12, #2	#@addI_reg_imm
2b8 +   j  B47	#@branch

2bc     B45: #	out( B47 ) &lt;- in( B64 )  Freq: 0.0863426
2bc +   addiw  R12, R12, #1	#@addI_reg_imm
2c0 +   j  B47	#@branch

2c4     B46: #	out( B47 ) &lt;- in( B50 )  Freq: 0.380781
2c4 +   spill R31 -&gt; R12	# spill size = 32
2c8 +   spill R28 -&gt; R14	# spill size = 32

2cc     B47: #	out( B75 B48 ) &lt;- in( B73 B69 B71 B74 B63 B44 B45 B43 B83 B46 ) top-of-loop Freq: 0.785943
2cc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2cc     ld  R29, [R23, #920]	# ptr, #@loadP
2d0 +   lwu zr, [R29]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.UnixPath::initOffsets @ bci:154 (line 206) L[0]=sp + #0 L[1]=R14 L[2]=R12 L[3]=sp + #24 L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [24]=Oop off=720/0x2d0}
2d4 +   bge  R12, R30, B75	#@cmpI_branch  P=0.058421 C=1515.000000

2d8     B48: #	out( B49 ) &lt;- in( B47 )  Freq: 0.740027
2d8 +   spill R14 -&gt; R28	# spill size = 32

2dc     B49: #	out( B94 B50 ) &lt;- in( B42 B48 ) Loop( B49-B48 ) Freq: 0.785946
2dc +   addw  R29, R12, zr	#@convI2L_reg_reg
2e0 +   add R29, R8, R29	# ptr, #@addP_reg_reg
2e4 +   bgeu  R12, R30, B94	#@cmpU_branch  P=0.000001 C=-1.000000

2e8     B50: #	out( B46 B51 ) &lt;- in( B49 )  Freq: 0.785945
2e8 +   lb  R29, [R29, #16]	# byte, #@loadB
2ec +   li R13, #47	# int, #@loadConI
2f0 +   addiw  R31, R12, #1	#@addI_reg_imm
2f4 +   beq  R29, R13, B46	#@cmpI_branch  P=0.484488 C=1515.000000

2f8     B51: #	out( B95 B52 ) &lt;- in( B50 )  Freq: 0.405164
2f8 +   addw  R29, R28, zr	#@convI2L_reg_reg
2fc +   slli  R29, R29, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
300 +   addiw  R14, R28, #1	#@addI_reg_imm
304     spill [sp, #24] -&gt; R11	# spill size = 64
308 +   add R29, R11, R29	# ptr, #@addP_reg_reg
30c +   bgeu  R28, R7, B95	#@cmpU_branch  P=0.000001 C=-1.000000

310     B52: #	out( B83 B53 ) &lt;- in( B51 )  Freq: 0.405163
310 +   sw  R12, [R29, #16]	# int, #@storeI
314 +   bge  R31, R30, B83	#@cmpI_branch  P=0.012796 C=7346.000000

318     B53: #	out( B97 B54 ) &lt;- in( B52 )  Freq: 0.399979
318 +   bgeu  R31, R30, B97	#@cmpU_branch  P=0.000001 C=-1.000000

31c     B54: #	out( B55 ) &lt;- in( B53 )  Freq: 0.399978
31c +   addiw  R28, R12, #2	#@addI_reg_imm

320     B55: #	out( B74 B56 ) &lt;- in( B54 B57 ) Loop( B55-B57 inner pre of N1039) Freq: 0.730733
320 +   addw  R29, R31, zr	#@convI2L_reg_reg
324 +   add R29, R8, R29	# ptr, #@addP_reg_reg
328 +   lb  R11, [R29, #16]	# byte, #@loadB
32c +   li R29, #47	# int, #@loadConI
330 +   beq  R11, R29, B74	#@cmpI_branch  P=0.094732 C=7252.000000

334     B56: #	out( B58 B57 ) &lt;- in( B55 )  Freq: 0.661509
334 +   addiw  R29, R31, #1	#@addI_reg_imm
338 +   bge  R29, R28, B58	#@cmpI_loop  P=0.500000 C=6565.000000

33c     B57: #	out( B55 ) &lt;- in( B56 )  Freq: 0.330754
33c +   spill R29 -&gt; R31	# spill size = 32
340 +   j  B55	#@branch

344     B58: #	out( B102 B59 ) &lt;- in( B56 )  Freq: 0.330754
344 +   bge  R29, R10, B102	#@cmpI_branch  P=0.000001 C=-1.000000

348     B59: #	out( B103 B60 ) &lt;- in( B58 )  Freq: 0.330754
348 +   spill R29 -&gt; R12	# spill size = 32
34c +   addiw  R31, R31, #4	#@addI_reg_imm
350 +   # castII of R12, #@castII
350     bgeu  R12, R30, B103	#@cmpU_branch  P=0.000001 C=-1.000000

354     B60: #	out( B104 B61 ) &lt;- in( B59 )  Freq: 0.330754
354 +   bgeu  R29, R30, B104	#@cmpU_branch  P=0.000001 C=-1.000000

358     B61: #	out( B105 B62 ) &lt;- in( B60 )  Freq: 0.330753
358 +   bgeu  R31, R30, B105	#@cmpU_branch  P=0.000001 C=-1.000000

35c     B62: #	out( B63 ) &lt;- in( B61 B68 ) Loop( B62-B68 ) Freq: 0.339295
35c +   subw  R28, R30, R12	#@subI_reg_reg
360 +   li R31, #0	# int, #@loadConI
364 +   addiw  R29, R28, #-3	#@addI_reg_imm
368     CMove R29, (R10 lt R12), R29, R31	#@cmovI_cmpI
	
370 +   li R11, #4000	# int, #@loadConI
378 +   li R28, #4000	# int, #@loadConI
380     CMove R29, (R29 gtu R28), R29, R11	#@cmovI_cmpU
	
388 +   addw  R28, R29, R12	#@addI_reg_reg
        nop 	# 2 bytes pad for loops and calls

390     B63: #	out( B47 B64 ) &lt;- in( B62 B67 ) Loop( B63-B67 inner main of N286 strip mined) Freq: 1.00681
390 +   addw  R29, R12, zr	#@convI2L_reg_reg
394 +   add R29, R8, R29	# ptr, #@addP_reg_reg
398 +   lb  R11, [R29, #16]	# byte, #@loadB
39c +   li R31, #47	# int, #@loadConI
3a0 +   beq  R11, R31, B47	#@cmpI_branch  P=0.094732 C=7252.000000

3a4     B64: #	out( B45 B65 ) &lt;- in( B63 )  Freq: 0.911436
3a4 +   lb  R31, [R29, #17]	# byte, #@loadB
3a8 +   li R13, #47	# int, #@loadConI
3ac +   beq  R31, R13, B45	#@cmpI_branch  P=0.094732 C=7252.000000

3b0     B65: #	out( B44 B66 ) &lt;- in( B64 )  Freq: 0.825094
3b0 +   lb  R11, [R29, #18]	# byte, #@loadB
3b4 +   li R31, #47	# int, #@loadConI
3b8 +   beq  R11, R31, B44	#@cmpI_branch  P=0.094732 C=7252.000000

3bc     B66: #	out( B43 B67 ) &lt;- in( B65 )  Freq: 0.74693
3bc +   lb  R29, [R29, #19]	# byte, #@loadB
3c0 +   li R11, #47	# int, #@loadConI
3c4 +   beq  R29, R11, B43	#@cmpI_branch  P=0.094732 C=7252.000000

3c8     B67: #	out( B63 B68 ) &lt;- in( B66 )  Freq: 0.676172
3c8 +   addiw  R12, R12, #4	#@addI_reg_imm
3cc +   blt  R12, R28, B63	#@cmpI_loop  P=0.987204 C=6565.000000

3d0     B68: #	out( B62 B69 ) &lt;- in( B67 )  Freq: 0.00865237
3d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3d0     ld  R11, [R23, #920]	# ptr, #@loadP
3d4 +   lwu zr, [R11]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.UnixPath::initOffsets @ bci:151 (line 204) L[0]=sp + #0 L[1]=R14 L[2]=R12 L[3]=sp + #24 L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [24]=Oop off=980/0x3d4}
3d8 +   blt  R12, R10, B62	#@cmpI_branch  P=0.987204 C=6565.000000

3dc     B69: #	out( B47 B70 ) &lt;- in( B102 B68 )  Freq: 0.000111052
3dc +   bge  R12, R30, B47	#@cmpI_branch  P=0.500000 C=-1.000000

3e0     B70: #	out( B112 B71 ) &lt;- in( B69 )  Freq: 5.55259e-05
3e0 +   # castII of R12, #@castII
3e0     bgeu  R12, R30, B112	#@cmpU_branch  P=0.000001 C=-1.000000

3e4     B71: #	out( B47 B72 ) &lt;- in( B70 B72 ) Loop( B71-B72 inner post of N1039) Freq: 0.000101442
3e4 +   addw  R28, R12, zr	#@convI2L_reg_reg
3e8 +   add R28, R8, R28	# ptr, #@addP_reg_reg
3ec +   lb  R29, [R28, #16]	# byte, #@loadB
3f0 +   li R28, #47	# int, #@loadConI
3f4 +   beq  R29, R28, B47	#@cmpI_branch  P=0.094732 C=7252.000000

3f8     B72: #	out( B71 B73 ) &lt;- in( B71 )  Freq: 9.18319e-05
3f8 +   addiw  R12, R12, #1	#@addI_reg_imm
3fc +   blt  R12, R30, B71	#@cmpI_loop  P=0.500000 C=6565.000000

400     B73: #	out( B47 ) &lt;- in( B72 )  Freq: 4.5916e-05
400 +   j  B47	#@branch

404     B74: #	out( B47 ) &lt;- in( B55 )  Freq: 0.0692241
404 +   spill R31 -&gt; R12	# spill size = 32
408 +   j  B47	#@branch

40c     B75: #	out( B108 B76 ) &lt;- in( B47 )  Freq: 0.0459159
40c     add R29, sp, #32	# box lock
410 +   spill [sp, #0] -&gt; R30	# spill size = 64
414 +   fastlock R30,R29	! kills R28,R7, #@cmpFastLock
4a8 +   far_bne RFLAGS, zr, B108	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

4b0     B76: #	out( B109 B77 ) &lt;- in( B108 B75 )  Freq: 0.0459159
4b0 +   #@membar_acquire_lock (elided)
4b0 +   spill [sp, #0] -&gt; R7	# spill size = 64
4b4 +   lwu  R28, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
4b8 +   #@membar_acquire
	fence ir iorw
4bc +   decode_heap_oop  R8, R28	#@decodeHeapOop
4c0 +   bne   R8, zr, B109	#@cmpP_imm0_branch  P=0.000000 C=94.000000

4c4     B77: #	out( B84 B78 ) &lt;- in( B76 )  Freq: 0.0459159
4c4 +   #@membar_release
	fence iorw ow
4c8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
4c8     lb  R7, [R23, #56]	# byte, #@loadB
4cc +   bne  R7, zr, B84	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

4d0     B78: #	out( B80 B79 ) &lt;- in( B110 B86 B84 B77 )  Freq: 0.0459159
4d0 +   spill [sp, #0] -&gt; R7	# spill size = 64
4d4 +   mv  R7, R7	# ptr -&gt; long, #@castP2X
4d4     spill [sp, #24] -&gt; R28	# spill size = 64
4d8 +   mv  R28, R28	# ptr -&gt; long, #@castP2X
4d8 +   xorr  R28, R28, R7	#@xorL_reg_reg
4dc     spill [sp, #24] -&gt; R29	# spill size = 64
4e0 +   encode_heap_oop  R30, R29	#@encodeHeapOop
4e4 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
4e8     spill [sp, #0] -&gt; R29	# spill size = 64
4ec +   sw  R30, [R29, #28]	# compressed ptr, #@storeN ! Field: volatile sun/nio/fs/UnixPath.offsets
4f0 +   beq  R28, zr, B80	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

4f4     B79: #	out( B87 B80 ) &lt;- in( B78 )  Freq: 0.0458699
4f4 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
4f8 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
504 +   add R10, R28, R7	# ptr, #@addP_reg_reg
508 +   lb  R7, [R10]	# byte, #@loadB
50c +   li R29, #4	# int, #@loadConI
510 +   bne  R7, R29, B87	#@cmpI_branch  P=0.001000 C=-1.000000

514     B80: #	out( B2 B81 ) &lt;- in( B89 B90 B87 B79 B78 )  Freq: 0.0459159
514 +   #@membar_volatile
	fence iorw iorw
518 +   #@membar_release_lock (elided)
518     add R29, sp, #32	# box lock
51c +   spill [sp, #0] -&gt; R30	# spill size = 64
520 +   fastunlock R30,R29	! kills R7, R28, #@cmpFastUnlock
598 +   far_beq RFLAGS, zr, B2	#@far_cmpFlag_branch  P=0.999999 C=-1.000000

5a0     B81: #	out( B2 ) &lt;- in( B80 )  Freq: 4.59159e-08
5a0     add R11, sp, #32	# box lock
5a4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5a4     spill R23 -&gt; R12	# spill size = 64
5a8 +   spill [sp, #0] -&gt; R10	# spill size = 64
5ac +   CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
5dc +   j  B2	#@branch

5e0     B82: #	out( B11 ) &lt;- in( B15 )  Freq: 0.00518481
5e0 +   spill R13 -&gt; R31	# spill size = 32
5e4 +   j  B11	#@branch

5e8     B83: #	out( B47 ) &lt;- in( B52 )  Freq: 0.00518451
5e8 +   spill R31 -&gt; R12	# spill size = 32
5ec +   j  B47	#@branch

5f0     B84: #	out( B78 B85 ) &lt;- in( B77 )  Freq: 4.59153e-05
5f0 +   spill [sp, #0] -&gt; R7	# spill size = 64
5f4 +   lwu  R28, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
5f8 +   decode_heap_oop  R10, R28	#@decodeHeapOop
5fc +   beq   R10, zr, B78	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

600     B85: #	out( B110 B86 ) &lt;- in( B84 )  Freq: 2.29576e-05
600 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
600     ld  R7, [R23, #32]	# int, #@loadL
604 +   beq  R7, zr, B110	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

608     B86: #	out( B78 ) &lt;- in( B85 )  Freq: 2.29347e-05
608 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
608     ld  R28, [R23, #48]	# ptr, #@loadP
60c +   add R28, R28, R7	# ptr, #@addP_reg_reg
610 +   addi  R7, R7, #-8	#@addL_reg_imm
614 +   sd  R10, [R28, #-8]	# ptr, #@storeP
618 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
618     sd  R7, [R23, #32]	# long, #@storeL
61c +   j  B78	#@branch

620     B87: #	out( B80 B88 ) &lt;- in( B79 )  Freq: 4.587e-05
620 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
620     ld  R7, [R23, #64]	# int, #@loadL
624 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
624     ld  R28, [R23, #80]	# ptr, #@loadP
628 +   #@membar_volatile
	fence iorw iorw
62c +   lb  R29, [R10]	# byte, #@loadB
630 +   beq  R29, zr, B80	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

634     B88: #	out( B90 B89 ) &lt;- in( B87 )  Freq: 2.2935e-05
634 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
638 +   bne  R7, zr, B90	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

63c     B89: #	out( B80 ) &lt;- in( B88 )  Freq: 1.14675e-05
63c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
63c     spill R23 -&gt; R11	# spill size = 64
640 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
670 +   j  B80	#@branch

674     B90: #	out( B80 ) &lt;- in( B88 )  Freq: 1.14675e-05
674 +   add R28, R28, R7	# ptr, #@addP_reg_reg
678 +   addi  R7, R7, #-8	#@addL_reg_imm
67c +   sd  R10, [R28, #-8]	# ptr, #@storeP
680 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
680     sd  R7, [R23, #64]	# long, #@storeL
684 +   j  B80	#@branch

688     B91: #	out( B114 B92 ) &lt;- in( B39 B40 )  Freq: 4.63914e-06
688 +   spill R10 -&gt; [sp, #16]	# spill size = 32
68c +   spill R30 -&gt; [sp, #12]	# spill size = 32
690 +   spill R7 -&gt; [sp, #8]	# spill size = 32
694 +   mv  R11, precise klass [I: 0x00000040d001b7c0:Constant:exact *	# ptr, #@loadConP
6ac     spill R7 -&gt; R12	# spill size = 32
6b0     CALL,static 0x000000401390d640	#@CallStaticJavaDirect wrapper for: _new_array_Java
        # sun.nio.fs.UnixPath::initOffsets @ bci:81 (line 194) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=1716/0x6b4}

6b4     B92: #	out( B42 ) &lt;- in( B91 )  Freq: 4.63904e-06
        # Block is sole successor of call
6b4 +   spill R10 -&gt; R28	# spill size = 64
6b8 +   spill [sp, #8] -&gt; R7	# spill size = 32
6bc +   spill [sp, #12] -&gt; R30	# spill size = 32
6c0 +   spill [sp, #16] -&gt; R10	# spill size = 32
6c4 +   spill R28 -&gt; R31	# spill size = 64
6c8 +   j  B42	#@branch

6cc     B93: #	out( N1045 ) &lt;- in( B13 )  Freq: 7.96427e-07
6cc +   li R11, #-28	# int, #@loadConI
6d0     spill R7 -&gt; [sp, #8]	# spill size = 32
6d4 +   spill R13 -&gt; [sp, #12]	# spill size = 32
6d8 +   spill R31 -&gt; [sp, #16]	# spill size = 32
6dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::initOffsets @ bci:40 (line 184) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #12 L[3]=_ L[4]=_ L[5]=_ STK[0]=R8 STK[1]=sp + #16
        # OopMap {fp=Oop [0]=Oop off=1760/0x6e0}
6e0     #@ShouldNotReachHere

6ec     B94: #	out( N1045 ) &lt;- in( B49 )  Freq: 7.96382e-07
6ec +   li R11, #-28	# int, #@loadConI
6f0     spill R12 -&gt; [sp, #12]	# spill size = 32
6f4 +   spill R28 -&gt; [sp, #16]	# spill size = 32
6f8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::initOffsets @ bci:102 (line 198) L[0]=sp + #0 L[1]=sp + #16 L[2]=sp + #12 L[3]=sp + #24 L[4]=_ L[5]=_ STK[0]=R8 STK[1]=sp + #12
        # OopMap {fp=Oop [0]=Oop [24]=Oop off=1788/0x6fc}
6fc     #@ShouldNotReachHere

708     B95: #	out( N1045 ) &lt;- in( B51 )  Freq: 4.10544e-07
708 +   spill [sp, #0] -&gt; R8	# spill size = 64
70c +   li R11, #-28	# int, #@loadConI
710     spill R12 -&gt; [sp, #0]	# spill size = 32
714 +   spill R14 -&gt; [sp, #4]	# spill size = 32
718 +   spill R31 -&gt; [sp, #8]	# spill size = 32
71c +   spill R28 -&gt; [sp, #12]	# spill size = 32
720     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::initOffsets @ bci:127 (line 202) L[0]=R8 L[1]=sp + #4 L[2]=sp + #8 L[3]=sp + #24 L[4]=_ L[5]=_ STK[0]=sp + #24 STK[1]=sp + #12 STK[2]=sp + #0
        # OopMap {fp=Oop [24]=Oop off=1828/0x724}
724     #@ShouldNotReachHere

730     B96: #	out( N1045 ) &lt;- in( B16 )  Freq: 4.05313e-07
730 +   spill [sp, #0] -&gt; R8	# spill size = 64
734 +   li R11, #-138	# int, #@loadConI
738     spill R7 -&gt; [sp, #0]	# spill size = 32
73c +   spill R13 -&gt; [sp, #8]	# spill size = 32
740 +   spill R30 -&gt; [sp, #12]	# spill size = 32
744     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::initOffsets @ bci:57 (line 187) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #8 STK[1]=sp + #12
        # OopMap {fp=Oop off=1864/0x748}
748     #@ShouldNotReachHere

754     B97: #	out( N1045 ) &lt;- in( B53 )  Freq: 4.0529e-07
754 +   spill [sp, #0] -&gt; R8	# spill size = 64
758 +   li R11, #-138	# int, #@loadConI
75c     spill R30 -&gt; [sp, #0]	# spill size = 32
760 +   spill R14 -&gt; [sp, #4]	# spill size = 32
764 +   spill R31 -&gt; [sp, #12]	# spill size = 32
768     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::initOffsets @ bci:134 (line 203) L[0]=R8 L[1]=sp + #4 L[2]=sp + #12 L[3]=sp + #24 L[4]=_ L[5]=_ STK[0]=sp + #12 STK[1]=sp + #0
        # OopMap {fp=Oop [24]=Oop off=1900/0x76c}
76c     #@ShouldNotReachHere

778     B98: #	out( B32 ) &lt;- in( B21 )  Freq: 3.35166e-07
778 +   spill R11 -&gt; R31	# spill size = 32
77c +   j  B32	#@branch

780     B99: #	out( N1045 ) &lt;- in( B22 )  Freq: 3.35165e-07
780     #@ShouldNotReachHere

78c     B100: #	out( N1045 ) &lt;- in( B23 )  Freq: 3.35165e-07
78c     #@ShouldNotReachHere

798     B101: #	out( N1045 ) &lt;- in( B24 )  Freq: 3.35165e-07
798     #@ShouldNotReachHere

7a4     B102: #	out( B69 ) &lt;- in( B58 )  Freq: 3.35146e-07
7a4 +   spill R29 -&gt; R12	# spill size = 32
7a8 +   j  B69	#@branch

7ac     B103: #	out( N1045 ) &lt;- in( B59 )  Freq: 3.35146e-07
7ac     #@ShouldNotReachHere

7b8     B104: #	out( N1045 ) &lt;- in( B60 )  Freq: 3.35146e-07
7b8     #@ShouldNotReachHere

7c4     B105: #	out( N1045 ) &lt;- in( B61 )  Freq: 3.35145e-07
7c4     #@ShouldNotReachHere

7d0     B106: #	out( N1045 ) &lt;- in( B5 )  Freq: 4.65305e-08
7d0 +   spill [sp, #0] -&gt; R8	# spill size = 64
7d4 +   li R11, #-66	# int, #@loadConI
7d8     spill R30 -&gt; [sp, #0]	# spill size = 32
7dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;profile_predicate&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::initOffsets @ bci:29 (line 183) L[0]=R8 L[1]=#0 L[2]=#0 L[3]=_ L[4]=_ L[5]=_ STK[0]=#0 STK[1]=sp + #0
        # OopMap {fp=Oop off=2016/0x7e0}
7e0     #@ShouldNotReachHere

7ec     B107: #	out( N1045 ) &lt;- in( B4 )  Freq: 4.59208e-08
7ec +   li R11, #-187	# int, #@loadConI
7f0     spill [sp, #0] -&gt; R8	# spill size = 64
7f4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::initOffsets @ bci:15 (line 179) L[0]=R8 L[1]=#0 L[2]=#0 L[3]=_ L[4]=_ L[5]=_ STK[0]=#1
        # OopMap {fp=Oop off=2040/0x7f8}
7f8     #@ShouldNotReachHere

804     B108: #	out( B76 ) &lt;- in( B75 )  Freq: 4.59159e-08
804     add R12, sp, #32	# box lock
808 +   spill [sp, #0] -&gt; R11	# spill size = 64
80c +   CALL,static 0x000000401390c140	#@CallStaticJavaDirect wrapper for: _complete_monitor_locking_Java
        # sun.nio.fs.UnixPath::initOffsets @ bci:161 (line 207) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=sp + #24 L[4]=sp + #0 L[5]=_ MON-BOX0=sp+32 MON-OBJ[0]=sp + #0
        # OopMap {[0]=Oop [24]=Oop off=2064/0x810}
810 +   j  B76	#@branch

814     B109: #	out( N1045 ) &lt;- in( B76 )  Freq: 2.29579e-08
814 +   li R11, #-187	# int, #@loadConI
818     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::initOffsets @ bci:166 (line 208) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=sp + #24 L[4]=sp + #0 L[5]=_ STK[0]=R8 MON-BOX0=sp+32 MON-OBJ[0]=sp + #0
        # OopMap {fp=Oop [0]=Oop [24]=Oop off=2076/0x81c}
81c     #@ShouldNotReachHere

828     B110: #	out( B78 ) &lt;- in( B85 )  Freq: 2.29573e-08
828 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
828     spill R23 -&gt; R11	# spill size = 64
82c +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
85c +   j  B78	#@branch

860     B111: #	out( N1045 ) &lt;- in( B33 )  Freq: 5.62664e-11
860     #@ShouldNotReachHere

86c     B112: #	out( N1045 ) &lt;- in( B70 )  Freq: 5.62632e-11
86c     #@ShouldNotReachHere

878     B113: #	out( N1045 ) &lt;- in( B3 )  Freq: 4.65306e-08
878 +   li R11, #-10	# int, #@loadConI
87c     spill [sp, #0] -&gt; R8	# spill size = 64
880     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::isEmpty @ bci:4 (line 216) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::initOffsets @ bci:12 (line 179) L[0]=R8 L[1]=#0 L[2]=#0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop off=2180/0x884}
884     #@ShouldNotReachHere

890     B114: #	out( N1045 ) &lt;- in( B91 )  Freq: 4.63914e-11
890      -- 	// exception oop; no code emitted, #@CreateException
890 +   spill R10 -&gt; R11	# spill size = 64
894 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
8a0 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='167'>
----------------------- MetaData before Compile_id = 167 ------------------------
{method}
 - this oop:          0x0000004096187498
 - method holder:     &apos;java/lang/StringLatin1&apos;
 - constants:         0x0000004096185338 constant pool [380] {0x0000004096185338} for &apos;java/lang/StringLatin1&apos; cache=0x0000004096189c30
 - access:            0xc1000009  public static 
 - name:              &apos;hashCode&apos;
 - signature:         &apos;([B)I&apos;
 - max stack:         4
 - max locals:        6
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4af6c0
 - code size:         42
 - code start:        0x0000004096187438
 - code end (excl):   0x0000004096187462
 - method data:       0x0000004096300098
 - checked ex length: 0
 - linenumber start:  0x0000004096187462
 - localvar length:   3
 - localvar start:    0x0000004096187472
 - compiled code: nmethod   4643   19       3       java.lang.StringLatin1::hashCode (42 bytes)

------------------------ OptoAssembly for Compile_id = 167 -----------------------
#
#  int ( byte[int:&gt;=0]:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: byte[int:&gt;=0]:exact *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B22 B17 B20 B21 B15 B18 B19 )  Freq: 1

000     B1: #	out( B22 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     lwu  R12, [R11, #12]	# range, #@loadRange
020     NullCheck R11

020     B2: #	out( B16 B3 ) &lt;- in( B1 )  Freq: 0.999999
020 +   li R14, #0	# int, #@loadConI
024 +   bleu  R12, zr, B16	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.056043 C=18254.000000

028     B3: #	out( B17 B4 ) &lt;- in( B2 )  Freq: 0.943957
028 +   addiw  R7, R12, #-1	#@addI_reg_imm
02c +   bgeu  R7, R12, B17	#@cmpU_branch  P=0.000001 C=-1.000000

030     B4: #	out( B11 B5 ) &lt;- in( B3 )  Freq: 0.943956
030 +   li R29, #-2147483648	# int, #@loadConI
034 +   addiw  R13, R12, #-3	#@addI_reg_imm
038     CMove R13, (R7 lt R13), R13, R29	#@cmovI_cmpI
	
040 +   li R16, #1	# int, #@loadConI
044 +   li R15, #4000	# int, #@loadConI
04c +   lbu  R10, [R11, #16]	# byte, #@loadUB
050 +   ble  R13, R16, B11	#@cmpI_branch  P=0.000001 C=-1.000000

054     B5: #	out( B18 B6 ) &lt;- in( B4 )  Freq: 0.943955
054 +   slliw  R7, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
058 +   subw  R28, R7, R10	#@subI_reg_reg
05c +   li R7, #4	# int, #@loadConI
060 +   bleu  R12, R16, B18	#@cmpU_branch  P=0.000001 C=-1.000000

064     B6: #	out( B19 B7 ) &lt;- in( B5 )  Freq: 0.943954
064 +   bleu  R12, R7, B19	#@cmpU_branch  P=0.000001 C=-1.000000

068     B7: #	out( B8 ) &lt;- in( B6 )  Freq: 0.943953
068 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP

068     B8: #	out( B9 ) &lt;- in( B7 B10 ) Loop( B8-B10 ) Freq: 16.8435
068 +   subw  R29, R13, R16	#@subI_reg_reg
06c     CMove R29, (R13 lt R16), R29, R14	#@cmovI_cmpI
	
074 +   CMove R29, (R29 gtu R15), R29, R15	#@cmovI_cmpU
	
07c +   addw  R17, R29, R16	#@addI_reg_reg

080     B9: #	out( B9 B10 ) &lt;- in( B8 B9 ) Loop( B9-B9 inner main of N54 strip mined) Freq: 300.549
080 +   addw  R7, R16, zr	#@convI2L_reg_reg
084 +   add R7, R11, R7	# ptr, #@addP_reg_reg
088 +   lbu  R29, [R7, #16]	# byte, #@loadUB
08c +   addw  R28, R28, R29	#@addI_reg_reg
090 +   lbu  R31, [R7, #17]	# byte, #@loadUB
094 +   slliw  R30, R28, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
098 +   subw  R29, R30, R28	#@subI_reg_reg
09c +   addw  R30, R29, R31	#@addI_reg_reg
0a0 +   slliw  R29, R30, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0a4 +   lbu  R28, [R7, #18]	# byte, #@loadUB
0a8 +   subw  R30, R29, R30	#@subI_reg_reg
0ac +   lbu  R29, [R7, #19]	# byte, #@loadUB
0b0 +   addw  R7, R30, R28	#@addI_reg_reg
0b4 +   slliw  R30, R7, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0b8 +   subw  R7, R30, R7	#@subI_reg_reg
0bc +   addw  R10, R7, R29	#@addI_reg_reg
0c0 +   slliw  R28, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0c4 +   addiw  R16, R16, #4	#@addI_reg_imm
0c8 +   subw  R28, R28, R10	#@subI_reg_reg
0cc +   blt  R16, R17, B9	#@cmpI_loop  P=0.943958 C=17231.000000

0d0     B10: #	out( B8 B11 ) &lt;- in( B9 )  Freq: 16.8435
0d0 +   ld  R7, [R23, #920]	# ptr, #@loadP
0d4 +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::hashCode @ bci:37 (line 196) L[0]=_ L[1]=R10 L[2]=R11 L[3]=R12 L[4]=R16 L[5]=_
        # OopMap {c_rarg1=Oop off=212/0xd4}
0d8 +   blt  R16, R13, B8	#@cmpI_branch  P=0.943958 C=17231.000000

0dc     B11: #	out( B15 B12 ) &lt;- in( B4 B10 )  Freq: 0.943954
0dc +   bge  R16, R12, B15	#@cmpI_branch  P=0.500000 C=-1.000000

0e0     B12: #	out( B20 B13 ) &lt;- in( B11 )  Freq: 0.471977
0e0 +   # castII of R16, #@castII
0e0     bgeu  R16, R12, B20	#@cmpU_branch  P=0.000001 C=-1.000000

0e4     B13: #	out( B21 B14 ) &lt;- in( B12 )  Freq: 0.471976
0e4 +   spill R16 -&gt; R7	# spill size = 32
0e8 +   # castII of R7, #@castII
0e8     bgeu  R7, R12, B21	#@cmpU_branch  P=0.000001 C=-1.000000

0ec     B14: #	out( B14 B15 ) &lt;- in( B13 B14 ) Loop( B14-B14 inner post of N166) Freq: 0.943952
0ec +   addw  R7, R16, zr	#@convI2L_reg_reg
0f0 +   add R7, R11, R7	# ptr, #@addP_reg_reg
0f4 +   lbu  R28, [R7, #16]	# byte, #@loadUB
0f8 +   slliw  R7, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0fc +   subw  R29, R7, R10	#@subI_reg_reg
100 +   addiw  R16, R16, #1	#@addI_reg_imm
104 +   addw  R10, R29, R28	#@addI_reg_reg
108 +   blt  R16, R12, B14	#@cmpI_loop  P=0.500000 C=17231.000000

10c     B15: #	out( N1 ) &lt;- in( B14 B11 B16 )  Freq: 0.999995
10c     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
124 +   ret	// return register, #@Ret

128     B16: #	out( B15 ) &lt;- in( B2 )  Freq: 0.0560425
128 +   li R10, #0	# int, #@loadConI
12c +   j  B15	#@branch

130     B17: #	out( N1 ) &lt;- in( B3 )  Freq: 9.56491e-07
130 +   spill R11 -&gt; R8	# spill size = 64
134 +   spill R12 -&gt; [sp, #4]	# spill size = 32
138 +   li R11, #-138	# int, #@loadConI
13c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:13 (line 196) L[0]=_ L[1]=#0 L[2]=R8 L[3]=sp + #4 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=sp + #4
        # OopMap {fp=Oop off=320/0x140}
140     #@ShouldNotReachHere

14c     B18: #	out( N1 ) &lt;- in( B5 )  Freq: 9.43955e-07
14c     #@ShouldNotReachHere

158     B19: #	out( N1 ) &lt;- in( B6 )  Freq: 9.43954e-07
158     #@ShouldNotReachHere

164     B20: #	out( N1 ) &lt;- in( B12 )  Freq: 4.78244e-07
164     #@ShouldNotReachHere

170     B21: #	out( N1 ) &lt;- in( B13 )  Freq: 4.78244e-07
170     #@ShouldNotReachHere

17c     B22: #	out( N1 ) &lt;- in( B1 )  Freq: 1.01328e-06
17c +   li R11, #-10	# int, #@loadConI
180     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:5 (line 196) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # OopMap {off=388/0x184}
184     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='181'>
----------------------- MetaData before Compile_id = 181 ------------------------
{method}
 - this oop:          0x00000040962b8d20
 - method holder:     &apos;sun/nio/fs/UnixPath&apos;
 - constants:         0x00000040962b5440 constant pool [472] {0x00000040962b5440} for &apos;sun/nio/fs/UnixPath&apos; cache=0x00000040962ba1a0
 - access:            0xc1000001  public 
 - name:              &apos;compareTo&apos;
 - signature:         &apos;(Ljava/nio/file/Path;)I&apos;
 - max stack:         3
 - max locals:        10
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      6
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824bb30: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c4edbc0
 - code size:         92
 - code start:        0x00000040962b8c38
 - code end (excl):   0x00000040962b8c94
 - method data:       0x00000040965ec4c8
 - checked ex length: 0
 - linenumber start:  0x00000040962b8c94
 - localvar length:   10
 - localvar start:    0x00000040962b8ca6
 - compiled code: nmethod   4853  113       3       sun.nio.fs.UnixPath::compareTo (92 bytes)

------------------------ OptoAssembly for Compile_id = 181 -----------------------
#
#  int ( sun/nio/fs/UnixPath:NotNull *, java/nio/file/Path * )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixPath:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/nio/file/Path *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N362: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B49 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
03c     lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
040 +   spill R11 -&gt; R29	# spill size = 64
044 +   decode_heap_oop  R10, R7	#@decodeHeapOop
048     lwu  R30, [R10, #12]	# range, #@loadRange
04c     NullCheck R10

04c     B2: #	out( B50 B3 ) &lt;- in( B1 )  Freq: 0.999999
04c     lwu  R28, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
050     NullCheck R12

050     B3: #	out( B48 B4 ) &lt;- in( B2 )  Freq: 0.999998
050 +   mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d8257c60:Constant:exact *	# compressed klass ptr, #@loadConNKlass
060 +   bne  R28, R7, B48	#@cmpN_branch  P=0.000000 C=-1.000000

064     B4: #	out( B51 B5 ) &lt;- in( B3 )  Freq: 0.999998
064 +   # checkcastPP of R12, #@checkCastPP
064     lwu  R28, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
068 +   decode_heap_oop  R14, R28	#@decodeHeapOop
06c     lwu  R15, [R14, #12]	# range, #@loadRange
070     NullCheck R14

070     B5: #	out( B31 B6 ) &lt;- in( B4 )  Freq: 0.999997
070 +   spill R15 -&gt; R8	# spill size = 32
074 +   CMove R8, (R30 lt R15), R8, R30	#@cmovI_cmpI
	
07c +   ble  R8, zr, B31	#@cmpI_reg_imm0_branch  P=0.045860 C=22307.000000

080     B6: #	out( B38 B7 ) &lt;- in( B5 )  Freq: 0.954137
080 +   addiw  R7, R8, #-1	#@addI_reg_imm
084 +   bleu  R30, zr, B38	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

088     B7: #	out( B38 B8 ) &lt;- in( B6 )  Freq: 0.954136
088 +   bgeu  R7, R30, B38	#@cmpU_branch  P=0.000001 C=-1.000000

08c     B8: #	out( B38 B9 ) &lt;- in( B7 )  Freq: 0.954135
08c +   lbu  R12, [R10, #16]	# byte, #@loadUB
090 +   bleu  R15, zr, B38	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

094     B9: #	out( B38 B10 ) &lt;- in( B8 )  Freq: 0.954134
094 +   bgeu  R7, R15, B38	#@cmpU_branch  P=0.000001 C=-1.000000

098     B10: #	out( B47 B11 ) &lt;- in( B9 )  Freq: 0.954133
098 +   lbu  R16, [R14, #16]	# byte, #@loadUB
09c +   li R31, #0	# int, #@loadConI
0a0 +   bne  R12, R16, B47	#@cmpI_branch  P=0.000000 C=21284.000000

0a4     B11: #	out( B24 B12 ) &lt;- in( B10 )  Freq: 0.954133
0a4 +   li R29, #-2147483648	# int, #@loadConI
0a8 +   addiw  R11, R8, #-3	#@addI_reg_imm
0ac     CMove R11, (R7 lt R11), R11, R29	#@cmovI_cmpI
	
0b4 +   li R13, #1	# int, #@loadConI
0b8 +   li R7, #4000	# int, #@loadConI
0c0 +   ble  R11, R13, B24	#@cmpI_branch  P=0.000001 C=-1.000000

0c4     B12: #	out( B39 B13 ) &lt;- in( B11 )  Freq: 0.954132
0c4 +   li R28, #4	# int, #@loadConI
0c8 +   bleu  R15, R13, B39	#@cmpU_branch  P=0.000001 C=-1.000000

0cc     B13: #	out( B40 B14 ) &lt;- in( B12 )  Freq: 0.954131
0cc +   bleu  R30, R13, B40	#@cmpU_branch  P=0.000001 C=-1.000000

0d0     B14: #	out( B41 B15 ) &lt;- in( B13 )  Freq: 0.95413
0d0 +   bleu  R30, R28, B41	#@cmpU_branch  P=0.000001 C=-1.000000

0d4     B15: #	out( B42 B16 ) &lt;- in( B14 )  Freq: 0.954129
0d4 +   bleu  R15, R28, B42	#@cmpU_branch  P=0.000001 C=-1.000000

0d8     B16: #	out( B17 ) &lt;- in( B15 )  Freq: 0.954128
0d8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP

0d8     B17: #	out( B18 ) &lt;- in( B16 B23 ) Loop( B17-B23 ) Freq: 20.7872
0d8 +   subw  R29, R11, R13	#@subI_reg_reg
0dc     CMove R29, (R11 lt R13), R29, R31	#@cmovI_cmpI
	
0e4 +   CMove R29, (R29 gtu R7), R29, R7	#@cmovI_cmpU
	
0ec +   addw  R17, R29, R13	#@addI_reg_reg

0f0     B18: #	out( B32 B19 ) &lt;- in( B17 B22 ) Loop( B18-B22 inner main of N118 strip mined) Freq: 453.257
0f0 +   addw  R28, R13, zr	#@convI2L_reg_reg
0f4 +   add R29, R10, R28	# ptr, #@addP_reg_reg
0f8 +   lbu  R18, [R29, #16]	# byte, #@loadUB
0fc +   lbu  R12, [R29, #19]	# byte, #@loadUB
100 +   lbu  R9, [R29, #18]	# byte, #@loadUB
104 +   lbu  R19, [R29, #17]	# byte, #@loadUB
108 +   add R28, R14, R28	# ptr, #@addP_reg_reg
10c +   lbu  R29, [R28, #16]	# byte, #@loadUB
110 +   lbu  R16, [R28, #19]	# byte, #@loadUB
114 +   lbu  R20, [R28, #18]	# byte, #@loadUB
118 +   lbu  R21, [R28, #17]	# byte, #@loadUB
11c +   bne  R18, R29, B32	#@cmpI_branch  P=0.000000 C=21284.000000

120     B19: #	out( B35 B20 ) &lt;- in( B18 )  Freq: 453.257
120 +   bne  R19, R21, B35	#@cmpI_branch  P=0.000000 C=21284.000000

124     B20: #	out( B33 B21 ) &lt;- in( B19 )  Freq: 453.257
124 +   bne  R9, R20, B33	#@cmpI_branch  P=0.000000 C=21284.000000

128     B21: #	out( B36 B22 ) &lt;- in( B20 )  Freq: 453.256
128 +   bne  R12, R16, B36	#@cmpI_branch  P=0.000000 C=21284.000000

12c     B22: #	out( B18 B23 ) &lt;- in( B21 )  Freq: 453.256
12c +   addiw  R13, R13, #4	#@addI_reg_imm
130 +   blt  R13, R17, B18	#@cmpI_loop  P=0.954140 C=21284.000000

134     B23: #	out( B17 B24 ) &lt;- in( B22 )  Freq: 20.7864
134 +   ld  R12, [R23, #920]	# ptr, #@loadP
138 +   lwu zr, [R12]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.UnixPath::compareTo @ bci:85 (line 728) L[0]=_ L[1]=_ L[2]=R30 L[3]=R15 L[4]=R8 L[5]=R10 L[6]=R14 L[7]=R13 L[8]=_ L[9]=_
        # OopMap {c_rarg0=Oop c_rarg4=Oop off=312/0x138}
13c +   blt  R13, R11, B17	#@cmpI_branch  P=0.954140 C=21284.000000

140     B24: #	out( B31 B25 ) &lt;- in( B11 B23 )  Freq: 0.953264
140 +   bge  R13, R8, B31	#@cmpI_branch  P=0.500000 C=-1.000000

144     B25: #	out( B43 B26 ) &lt;- in( B24 )  Freq: 0.476632
144 +   # castII of R13, #@castII
144     bgeu  R13, R30, B43	#@cmpU_branch  P=0.000001 C=-1.000000

148     B26: #	out( B44 B27 ) &lt;- in( B25 )  Freq: 0.476632
148 +   spill R13 -&gt; R7	# spill size = 32
14c +   # castII of R7, #@castII
14c     bgeu  R7, R30, B44	#@cmpU_branch  P=0.000001 C=-1.000000

150     B27: #	out( B45 B28 ) &lt;- in( B26 )  Freq: 0.476631
150 +   bgeu  R13, R15, B45	#@cmpU_branch  P=0.000001 C=-1.000000

154     B28: #	out( B46 B29 ) &lt;- in( B27 )  Freq: 0.476631
154 +   bgeu  R7, R15, B46	#@cmpU_branch  P=0.000001 C=-1.000000

158     B29: #	out( B37 B30 ) &lt;- in( B28 B30 ) Loop( B29-B30 inner post of N290) Freq: 0.95326
158 +   addw  R7, R13, zr	#@convI2L_reg_reg
15c +   add R28, R10, R7	# ptr, #@addP_reg_reg
160 +   lbu  R12, [R28, #16]	# byte, #@loadUB
164 +   add R7, R14, R7	# ptr, #@addP_reg_reg
168 +   lbu  R16, [R7, #16]	# byte, #@loadUB
16c +   bne  R12, R16, B37	#@cmpI_branch  P=0.000000 C=21284.000000

170     B30: #	out( B29 B31 ) &lt;- in( B29 )  Freq: 0.95326
170 +   addiw  R13, R13, #1	#@addI_reg_imm
174 +   blt  R13, R8, B29	#@cmpI_loop  P=0.500000 C=21284.000000

178     B31: #	out( N362 ) &lt;- in( B24 B5 B30 )  Freq: 0.999122
178 +   subw  R10, R30, R15	#@subI_reg_reg
17c     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
194 +   ret	// return register, #@Ret

198     B32: #	out( B34 ) &lt;- in( B18 )  Freq: 0.00021613
198 +   spill R29 -&gt; R20	# spill size = 32
19c +   spill R18 -&gt; R9	# spill size = 32
1a0 +   j  B34	#@branch

1a4     B33: #	out( B34 ) &lt;- in( B20 )  Freq: 0.00021613
1a4 +   addiw  R13, R13, #2	#@addI_reg_imm

1a8     B34: #	out( B37 ) &lt;- in( B32 B33 )  Freq: 0.00043226
1a8     spill R20 -&gt; R16	# spill size = 32
1ac +   spill R9 -&gt; R12	# spill size = 32
1b0 +   j  B37	#@branch

1b4     B35: #	out( B37 ) &lt;- in( B19 )  Freq: 0.00021613
1b4 +   addiw  R13, R13, #1	#@addI_reg_imm
1b8     spill R21 -&gt; R16	# spill size = 32
1bc +   spill R19 -&gt; R12	# spill size = 32
1c0 +   j  B37	#@branch

1c4     B36: #	out( B37 ) &lt;- in( B21 )  Freq: 0.00021613
1c4 +   addiw  R13, R13, #3	#@addI_reg_imm

1c8     B37: #	out( N362 ) &lt;- in( B29 B47 B34 B35 B36 )  Freq: 0.000865428
1c8 +   li R11, #-187	# int, #@loadConI
1cc     spill R10 -&gt; [sp, #0]	# spill size = 64
1d0 +   spill R14 -&gt; [sp, #8]	# spill size = 64
1d4 +   spill R13 -&gt; [sp, #16]	# spill size = 32
1d8 +   spill R12 -&gt; [sp, #28]	# spill size = 32
1dc +   spill R16 -&gt; [sp, #32]	# spill size = 32
1e0 +   spill R30 -&gt; [sp, #36]	# spill size = 32
1e4 +   spill R15 -&gt; [sp, #40]	# spill size = 32
1e8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:73 (line 724) L[0]=_ L[1]=_ L[2]=sp + #36 L[3]=sp + #40 L[4]=R8 L[5]=sp + #0 L[6]=sp + #8 L[7]=sp + #16 L[8]=sp + #28 L[9]=sp + #32 STK[0]=sp + #28 STK[1]=sp + #32
        # OopMap {[0]=Oop [8]=Oop off=492/0x1ec}
1ec     #@ShouldNotReachHere

1f8     B38: #	out( N362 ) &lt;- in( B9 B6 B7 B8 )  Freq: 3.84188e-06
1f8 +   li R11, #-138	# int, #@loadConI
1fc     spill R10 -&gt; [sp, #0]	# spill size = 64
200 +   spill R14 -&gt; [sp, #8]	# spill size = 64
204 +   spill R30 -&gt; [sp, #16]	# spill size = 32
208 +   spill R15 -&gt; [sp, #20]	# spill size = 32
20c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:44 (line 721) L[0]=_ L[1]=_ L[2]=sp + #16 L[3]=sp + #20 L[4]=R8 L[5]=sp + #0 L[6]=sp + #8 L[7]=#0 L[8]=_ L[9]=_ STK[0]=#0 STK[1]=R8
        # OopMap {[0]=Oop [8]=Oop off=528/0x210}
210     #@ShouldNotReachHere

21c     B39: #	out( N362 ) &lt;- in( B12 )  Freq: 9.54132e-07
21c     #@ShouldNotReachHere

228     B40: #	out( N362 ) &lt;- in( B13 )  Freq: 9.54131e-07
228     #@ShouldNotReachHere

234     B41: #	out( N362 ) &lt;- in( B14 )  Freq: 9.5413e-07
234     #@ShouldNotReachHere

240     B42: #	out( N362 ) &lt;- in( B15 )  Freq: 9.54129e-07
240     #@ShouldNotReachHere

24c     B43: #	out( N362 ) &lt;- in( B25 )  Freq: 4.82961e-07
24c     #@ShouldNotReachHere

258     B44: #	out( N362 ) &lt;- in( B26 )  Freq: 4.82961e-07
258     #@ShouldNotReachHere

264     B45: #	out( N362 ) &lt;- in( B27 )  Freq: 4.8296e-07
264     #@ShouldNotReachHere

270     B46: #	out( N362 ) &lt;- in( B28 )  Freq: 4.8296e-07
270     #@ShouldNotReachHere

27c     B47: #	out( B37 ) &lt;- in( B10 )  Freq: 4.54966e-07
27c +   li R13, #0	# int, #@loadConI
280 +   j  B37	#@branch

284     B48: #	out( N362 ) &lt;- in( B3 )  Freq: 1e-35
284 +   li R11, #-34	# int, #@loadConI
288     spill R29 -&gt; R8	# spill size = 64
28c +   spill R30 -&gt; [sp, #8]	# spill size = 32
290 +   spill R12 -&gt; [sp, #16]	# spill size = 64
294     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:7 (line 714) L[0]=R8 L[1]=sp + #16 L[2]=sp + #8 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ STK[0]=sp + #16
        # OopMap {fp=Oop [16]=Oop off=664/0x298}
298     #@ShouldNotReachHere

2a4     B49: #	out( N362 ) &lt;- in( B1 )  Freq: 1.01328e-06
2a4 +   li R11, #-10	# int, #@loadConI
2a8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:4 (line 713) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ STK[0]=#NULL
        # OopMap {off=684/0x2ac}
2ac     #@ShouldNotReachHere

2b8     B50: #	out( N362 ) &lt;- in( B2 )  Freq: 1.01328e-06
2b8 +   li R11, #-12	# int, #@loadConI
2bc     spill R29 -&gt; R8	# spill size = 64
2c0 +   spill R30 -&gt; [sp, #0]	# spill size = 32
2c4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:7 (line 714) L[0]=R8 L[1]=#NULL L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ STK[0]=#NULL
        # OopMap {fp=Oop off=712/0x2c8}
2c8     #@ShouldNotReachHere

2d4     B51: #	out( N362 ) &lt;- in( B4 )  Freq: 1.01328e-06
2d4 +   li R11, #-10	# int, #@loadConI
2d8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:13 (line 714) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ STK[0]=#NULL
        # OopMap {off=732/0x2dc}
2dc     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='186'>
----------------------- MetaData before Compile_id = 186 ------------------------
{method}
 - this oop:          0x00000040962b7ac8
 - method holder:     &apos;sun/nio/fs/UnixPath&apos;
 - constants:         0x00000040962b5440 constant pool [472] {0x00000040962b5440} for &apos;sun/nio/fs/UnixPath&apos; cache=0x00000040962ba1a0
 - access:            0x81000001  public 
 - name:              &apos;getName&apos;
 - signature:         &apos;(I)Lsun/nio/fs/UnixPath;&apos;
 - max stack:         6
 - max locals:        5
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      9
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b960: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c4ec940
 - code size:         106
 - code start:        0x00000040962b7a00
 - code end (excl):   0x00000040962b7a6a
 - method data:       0x00000040965ebd28
 - checked ex length: 0
 - linenumber start:  0x00000040962b7a6a
 - localvar length:   6
 - localvar start:    0x00000040962b7a7e
 - compiled code: nmethod   5001  112       3       sun.nio.fs.UnixPath::getName (106 bytes)

------------------------ OptoAssembly for Compile_id = 186 -----------------------
#
#  sun/nio/fs/UnixPath * ( sun/nio/fs/UnixPath:NotNull *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixPath:NotNull *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N429: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B43 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     spill R12 -&gt; R8	# spill size = 32
040 +   spill R11 -&gt; [sp, #0]	# spill size = 64
044     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getName @ bci:1 (line 301) L[0]=sp + #0 L[1]=R8 L[2]=_ L[3]=_ L[4]=_
        # OopMap {[0]=Oop off=72/0x48}

048     B2: #	out( B33 B3 ) &lt;- in( B1 )  Freq: 0.99998
        # Block is sole successor of call
048 +   spill R8 -&gt; R31	# spill size = 32
04c +   blt  R31, zr, B33	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

050     B3: #	out( B35 B4 ) &lt;- in( B2 )  Freq: 0.999979
050 +   spill [sp, #0] -&gt; R7	# spill size = 64
054 +   lwu  R28, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
058 +   #@membar_acquire
	fence ir iorw
05c +   decode_heap_oop  R7, R28	#@decodeHeapOop
060     lwu  R8, [R7, #12]	# range, #@loadRange
064     NullCheck R7

064     B4: #	out( B34 B5 ) &lt;- in( B3 )  Freq: 0.999978
064 +   bge  R31, R8, B34	#@cmpI_branch  P=0.000000 C=5375.000000

068     B5: #	out( B36 B6 ) &lt;- in( B4 )  Freq: 0.999978
068 +   spill [sp, #0] -&gt; R7	# spill size = 64
06c +   lwu  R7, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
070 +   #@membar_acquire
	fence ir iorw
074 +   decode_heap_oop  R8, R7	#@decodeHeapOop
078     lwu  R28, [R8, #12]	# range, #@loadRange
07c     NullCheck R8

07c     B6: #	out( B30 B7 ) &lt;- in( B5 )  Freq: 0.999977
07c +   bgeu  R31, R28, B30	#@cmpU_branch  P=0.000001 C=-1.000000

080     B7: #	out( B37 B8 ) &lt;- in( B6 )  Freq: 0.999976
080 +   addw  R28, R31, zr	#@convI2L_reg_reg
084 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
088     spill [sp, #0] -&gt; R7	# spill size = 64
08c +   lwu  R7, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
090 +   add R29, R8, R28	# ptr, #@addP_reg_reg
094 +   lw  R29, [R29, #16]	# int, #@loadI
098 +   decode_heap_oop  R7, R7	#@decodeHeapOop
09c     spill R29 -&gt; [sp, #8]	# spill size = 32
0a0 +   #@membar_acquire
	fence ir iorw
0a4     lwu  R7, [R7, #12]	# range, #@loadRange
0a8     NullCheck R7

0a8     B8: #	out( B24 B9 ) &lt;- in( B7 )  Freq: 0.999975
0a8 +   addiw  R29, R7, #-1	#@addI_reg_imm
0ac +   beq  R31, R29, B24	#@cmpI_branch  P=0.084651 C=5375.000000

0b0     B9: #	out( B39 B10 ) &lt;- in( B8 )  Freq: 0.915326
0b0 +   spill [sp, #0] -&gt; R7	# spill size = 64
0b4 +   lwu  R7, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0b8 +   #@membar_acquire
	fence ir iorw
0bc +   decode_heap_oop  R7, R7	#@decodeHeapOop
0c0 +   addiw  R8, R31, #1	#@addI_reg_imm
0c4     lwu  R29, [R7, #12]	# range, #@loadRange
0c8     NullCheck R7

0c8     B10: #	out( B32 B11 ) &lt;- in( B9 )  Freq: 0.915325
0c8 +   bgeu  R8, R29, B32	#@cmpU_branch  P=0.000001 C=-1.000000

0cc     B11: #	out( B12 ) &lt;- in( B10 )  Freq: 0.915324
0cc +   add R7, R7, R28	# ptr, #@addP_reg_reg
0d0 +   lw  R7, [R7, #20]	# int, #@loadI
0d4 +   spill [sp, #8] -&gt; R29	# spill size = 32
0d8 +   subw  R28, R7, R29	#@subI_reg_reg
0dc +   addiw  R8, R28, #-1	#@addI_reg_imm

0e0     B12: #	out( B13 B13 ) &lt;- in( B11 B25 )  Freq: 0.999973
0e0     spill [sp, #0] -&gt; R7	# spill size = 64
0e4 +   lwu  R28, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
0e8 +   decode_heap_oop  R10, R28	#@decodeHeapOop
0ec +   li R7, #1048576	# int, #@loadConI
0f0 +   addw  R28, R8, zr	#@convI2L_reg_reg
0f4 +   bleu  R8, R7, B13	#@cmpU_branch  P=0.999999 C=-1.000000

0f8     B13: #	out( B38 B14 ) &lt;- in( B12 B12 )  Freq: 0.999973
0f8     lwu  R30, [R10, #12]	# range, #@loadRange
0fc     NullCheck R10

0fc     B14: #	out( B31 B15 ) &lt;- in( B13 )  Freq: 0.999972
0fc +   spill [sp, #8] -&gt; R31	# spill size = 32
100 +   addw  R29, R8, R31	#@addI_reg_reg
104 +   blt  R31, zr, B31	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

108     B15: #	out( B31 B16 ) &lt;- in( B14 )  Freq: 0.999971
108 +   bltu  R30, R29, B31	#@cmpU_branch  P=0.000001 C=-1.000000

10c     B16: #	out( B28 B17 ) &lt;- in( B15 )  Freq: 0.99997
10c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
10c     bgtu  R8, R7, B28	#@cmpU_branch  P=0.000001 C=-1.000000

110     B17: #	out( B28 B18 ) &lt;- in( B16 )  Freq: 0.999969
110 +   addi  R7, R28, #23	#@addL_reg_imm
114 +   ld  R29, [R23, #288]	# ptr, #@loadP
118 +   andi  R7, R7, #-8	#@andL_reg_imm
11c +   ld  R28, [R23, #304]	# ptr, #@loadP
120 +   add R7, R29, R7	# ptr, #@addP_reg_reg
124 +   bgeu  R7, R28, B28	#@cmpP_branch  P=0.000100 C=-1.000000

128     B18: #	out( B19 ) &lt;- in( B17 )  Freq: 0.999869
128 +   sd  R7, [R23, #288]	# ptr, #@storeP
12c +   li R7, #1	# long, #@loadConL
130 +   mv  R28, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
140 +   sd  R7, [R29]	# long, #@storeL
144 +   sw  R28, [R29, #8]	# compressed klass ptr, #@storeNKlass
148 +   sw  R8, [R29, #12]	# int, #@storeI

14c     B19: #	out( B21 B20 ) &lt;- in( B29 B18 )  Freq: 0.99997
14c     
14c +   # checkcastPP of R29, #@checkCastPP
14c     # castII of R8, #@castII
14c     spill R29 -&gt; [sp, #16]	# spill size = 64
150 +   beq  R8, zr, B21	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

154     B20: #	out( B21 ) &lt;- in( B19 )  Freq: 0.999969
154 +   spill [sp, #8] -&gt; R28	# spill size = 32
158 +   addw  R7, R28, zr	#@convI2L_reg_reg
15c +   add R7, R10, R7	# ptr, #@addP_reg_reg
160 +   addw  R12, R8, zr	#@convI2L_reg_reg
164 +   addi  R11, R29, #16	# ptr, #@addP_reg_imm
168 +   addi  R10, R7, #16	# ptr, #@addP_reg_imm
16c +   CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

170     B21: #	out( B26 B22 ) &lt;- in( B20 B19 )  Freq: 0.99997
170     MEMBAR-store-store	#@membar_storestore
174 +   ld  R10, [R23, #288]	# ptr, #@loadP
178 +   ld  R7, [R23, #304]	# ptr, #@loadP
17c +   addi  R28, R10, #32	# ptr, #@addP_reg_imm
180 +   bgeu  R28, R7, B26	#@cmpP_branch  P=0.000100 C=-1.000000

184     B22: #	out( B23 ) &lt;- in( B21 )  Freq: 0.99987
184 +   sd  R28, [R23, #288]	# ptr, #@storeP
188 +   li R7, #1	# long, #@loadConL
18c +   mv  R28, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d827fd00:Constant:exact *	# compressed klass ptr, #@loadConNKlass
19c +   sd  R7, [R10]	# long, #@storeL
1a0 +   sw  R28, [R10, #8]	# compressed klass ptr, #@storeNKlass
1a4 +   sw  zr, [R10, #12]	# int, #@storeimmI0
1a8 +   sw  zr, [R10, #16]	# int, #@storeimmI0
1ac +   sd  zr, [R10, #24]	# long, #@storeimmL0

1b0     B23: #	out( N429 ) &lt;- in( B27 B22 )  Freq: 0.99997
1b0     spill [sp, #16] -&gt; R7	# spill size = 64
1b4 +   encode_heap_oop  R7, R7	#@encodeHeapOop
1b8 +   sw  R7, [R10, #20]	# compressed ptr, #@storeN
1bc     
1bc     spill [sp, #0] -&gt; R7	# spill size = 64
1c0 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
1c4 +   # checkcastPP of R10, #@checkCastPP
1c4     sw  R28, [R10, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixPath.fs
1c8 +   #@membar_release
	fence iorw ow
1cc +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
1e4 +   ret	// return register, #@Ret

1e8     B24: #	out( B40 B25 ) &lt;- in( B8 )  Freq: 0.0846491
1e8 +   spill [sp, #0] -&gt; R7	# spill size = 64
1ec +   lwu  R28, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
1f0 +   decode_heap_oop  R7, R28	#@decodeHeapOop
1f4     lwu  R7, [R7, #12]	# range, #@loadRange
1f8     NullCheck R7

1f8     B25: #	out( B12 ) &lt;- in( B24 )  Freq: 0.084649
1f8 +   spill [sp, #8] -&gt; R28	# spill size = 32
1fc +   subw  R8, R7, R28	#@subI_reg_reg
200 +   j  B12	#@branch

204     B26: #	out( B41 B27 ) &lt;- in( B21 )  Freq: 0.000100014
204 +   mv  R11, precise klass sun/nio/fs/UnixPath: 0x00000040d827fd00:Constant:exact *	# ptr, #@loadConP
21c     spill [sp, #0] -&gt; R8	# spill size = 64
220     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixPath::getName @ bci:92 (line 318) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #16
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=548/0x224}

224     B27: #	out( B23 ) &lt;- in( B26 )  Freq: 0.000100012
        # Block is sole successor of call
224 +   j  B23	#@branch

228     B28: #	out( B42 B29 ) &lt;- in( B16 B17 )  Freq: 0.000101027
228 +   spill R10 -&gt; [sp, #16]	# spill size = 64
22c +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
244     spill R8 -&gt; R12	# spill size = 32
248     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #0 L[1]=_ L[2]=sp + #8 L[3]=R8 L[4]=_
        # OopMap {[0]=Oop [16]=Oop off=588/0x24c}

24c     B29: #	out( B19 ) &lt;- in( B28 )  Freq: 0.000101025
        # Block is sole successor of call
24c +   spill R10 -&gt; R7	# spill size = 64
250 +   spill [sp, #16] -&gt; R10	# spill size = 64
254 +   spill R7 -&gt; R29	# spill size = 64
258 +   j  B19	#@branch

25c     B30: #	out( N429 ) &lt;- in( B6 )  Freq: 1.01326e-06
25c +   li R11, #-28	# int, #@loadConI
260     spill R31 -&gt; [sp, #12]	# spill size = 32
264     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:38 (line 307) L[0]=sp + #0 L[1]=sp + #12 L[2]=_ L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #12
        # OopMap {fp=Oop [0]=Oop off=616/0x268}
268     #@ShouldNotReachHere

274     B31: #	out( N429 ) &lt;- in( B14 B15 )  Freq: 1.99994e-06
274 +   li R11, #-52	# int, #@loadConI
278     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #0 L[1]=_ L[2]=sp + #8 L[3]=R8 L[4]=_ STK[0]=R8
        # OopMap {[0]=Oop off=636/0x27c}
27c     #@ShouldNotReachHere

288     B32: #	out( N429 ) &lt;- in( B10 )  Freq: 9.2748e-07
288 +   li R11, #-28	# int, #@loadConI
28c     spill R7 -&gt; [sp, #16]	# spill size = 64
290     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:69 (line 312) L[0]=sp + #0 L[1]=_ L[2]=sp + #8 L[3]=_ L[4]=_ STK[0]=sp + #16 STK[1]=R8
        # OopMap {[0]=Oop [16]=Oop off=660/0x294}
294     #@ShouldNotReachHere

2a0     B33: #	out( N429 ) &lt;- in( B2 )  Freq: 4.76828e-07
2a0 +   spill [sp, #0] -&gt; R8	# spill size = 64
2a4 +   li R11, #-187	# int, #@loadConI
2a8     spill R31 -&gt; [sp, #4]	# spill size = 32
2ac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:5 (line 302) L[0]=R8 L[1]=sp + #4 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #4
        # OopMap {fp=Oop off=688/0x2b0}
2b0     #@ShouldNotReachHere

2bc     B34: #	out( N429 ) &lt;- in( B4 )  Freq: 4.76827e-07
2bc +   li R11, #-187	# int, #@loadConI
2c0     spill R31 -&gt; [sp, #12]	# spill size = 32
2c4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:22 (line 304) L[0]=sp + #0 L[1]=sp + #12 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #12 STK[1]=R8
        # OopMap {[0]=Oop off=712/0x2c8}
2c8     #@ShouldNotReachHere

2d4     B35: #	out( N429 ) &lt;- in( B3 )  Freq: 1.01326e-06
2d4 +   li R11, #-10	# int, #@loadConI
2d8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:21 (line 304) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=732/0x2dc}
2dc     #@ShouldNotReachHere

2e8     B36: #	out( N429 ) &lt;- in( B5 )  Freq: 1.01326e-06
2e8 +   li R11, #-10	# int, #@loadConI
2ec     spill R31 -&gt; R8	# spill size = 32
2f0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:38 (line 307) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=R8
        # OopMap {off=756/0x2f4}
2f4     #@ShouldNotReachHere

300     B37: #	out( N429 ) &lt;- in( B7 )  Freq: 1.01325e-06
300 +   li R11, #-10	# int, #@loadConI
304     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:45 (line 309) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=776/0x308}
308     #@ShouldNotReachHere

314     B38: #	out( N429 ) &lt;- in( B13 )  Freq: 1.01325e-06
314 +   li R11, #-12	# int, #@loadConI
318     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #0 L[1]=_ L[2]=sp + #8 L[3]=R8 L[4]=_ STK[0]=R8
        # OopMap {[0]=Oop off=796/0x31c}
31c     #@ShouldNotReachHere

328     B39: #	out( N429 ) &lt;- in( B9 )  Freq: 9.2748e-07
328 +   li R11, #-10	# int, #@loadConI
32c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:69 (line 312) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=R8
        # OopMap {off=816/0x330}
330     #@ShouldNotReachHere

33c     B40: #	out( N429 ) &lt;- in( B24 )  Freq: 8.57731e-08
33c +   li R11, #-10	# int, #@loadConI
340     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:55 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # OopMap {off=836/0x344}
344     #@ShouldNotReachHere

350     B41: #	out( B44 ) &lt;- in( B26 )  Freq: 1.00014e-09
350      -- 	// exception oop; no code emitted, #@CreateException
350 +   spill R10 -&gt; R11	# spill size = 64
354 +   j  B44	#@branch

358     B42: #	out( B44 ) &lt;- in( B28 )  Freq: 1.01027e-09
358      -- 	// exception oop; no code emitted, #@CreateException
358 +   spill R10 -&gt; R11	# spill size = 64
35c +   j  B44	#@branch

360     B43: #	out( B44 ) &lt;- in( B1 )  Freq: 1e-05
360      -- 	// exception oop; no code emitted, #@CreateException
360 +   spill R10 -&gt; R11	# spill size = 64

364     B44: #	out( N429 ) &lt;- in( B43 B42 B41 )  Freq: 1.0002e-05
364     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
370 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='188'>
----------------------- MetaData before Compile_id = 188 ------------------------
{method}
 - this oop:          0x0000004096009d50
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;length&apos;
 - signature:         &apos;()I&apos;
 - max stack:         3
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4ae580
 - code size:         11
 - code start:        0x0000004096009d30
 - code end (excl):   0x0000004096009d3b
 - method data:       0x00000040963b0950
 - checked ex length: 0
 - linenumber start:  0x0000004096009d3b
 - localvar length:   1
 - localvar start:    0x0000004096009d42
 - compiled code: nmethod   5036    7       3       java.lang.String::length (11 bytes)

------------------------ OptoAssembly for Compile_id = 188 -----------------------
#
#  int ( java/lang/String:NotNull:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N32: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B3 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     lwu  R28, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
040 +   decode_heap_oop  R7, R28	#@decodeHeapOop
044     lwu  R7, [R7, #12]	# range, #@loadRange
048     NullCheck R7

048     B2: #	out( N32 ) &lt;- in( B1 )  Freq: 0.999999
048 +   lb  R29, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
04c +   sraw  R10, R7, R29	#@rShiftI_reg_reg
050     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
068 +   ret	// return register, #@Ret

06c     B3: #	out( N32 ) &lt;- in( B1 )  Freq: 1.01328e-06
06c +   li R11, #-10	# int, #@loadConI
070     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # OopMap {off=116/0x74}
074 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='199'>
----------------------- MetaData before Compile_id = 199 ------------------------
{method}
 - this oop:          0x00000040962b6710
 - method holder:     &apos;sun/nio/fs/UnixPath&apos;
 - constants:         0x00000040962b5440 constant pool [472] {0x00000040962b5440} for &apos;sun/nio/fs/UnixPath&apos; cache=0x00000040962ba1a0
 - access:            0x81000000  
 - name:              &apos;&lt;init&gt;&apos;
 - signature:         &apos;(Lsun/nio/fs/UnixFileSystem;[B)V&apos;
 - max stack:         3
 - max locals:        3
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x00000040083172b0: 0xbbb i2c: 0x0000004013944dc0 c2i: 0x0000004013944e0c c2iUV: 0x0000004013944dd8
 - compiled entry     0x000000400c4ec280
 - code size:         15
 - code start:        0x00000040962b66d0
 - code end (excl):   0x00000040962b66df
 - method data:       0x00000040965ebb70
 - checked ex length: 0
 - linenumber start:  0x00000040962b66df
 - localvar length:   3
 - localvar start:    0x00000040962b66ea
 - compiled code: nmethod   5143  111       3       sun.nio.fs.UnixPath::&lt;init&gt; (15 bytes)

------------------------ OptoAssembly for Compile_id = 199 -----------------------
#
#  void ( sun/nio/fs/UnixPath:NotNull *, sun/nio/fs/LinuxFileSystem *, byte[int:&gt;=0]:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixPath:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: sun/nio/fs/LinuxFileSystem *
#r016 c_rarg3:c_rarg3   : parm 2: byte[int:&gt;=0]:exact *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N296: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B11 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c      -- 	// R23=Thread::current(), empty, #@tlsLoadP
03c     lb  R28, [R23, #56]	# byte, #@loadB
040     spill R13 -&gt; R18	# spill size = 64
044 +   spill R12 -&gt; R9	# spill size = 64
048 +   bne  R28, zr, B11	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

04c     B2: #	out( B3 ) &lt;- in( B1 )  Freq: 0.999
04c +   spill R11 -&gt; R19	# spill size = 64

050     B3: #	out( B6 B4 ) &lt;- in( B25 B13 B11 B2 )  Freq: 1
050 +   mv  R7, R19	# ptr -&gt; long, #@castP2X
054     spill R9 -&gt; R30	# spill size = 64
058 +   mv  R28, R30	# ptr -&gt; long, #@castP2X
05c +   xorr  R28, R28, R7	#@xorL_reg_reg
060 +   encode_heap_oop  R29, R30	#@encodeHeapOop
064 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
068     spill R18 -&gt; R21	# spill size = 64
06c +   encode_heap_oop  R18, R18	#@encodeHeapOop
070 +   li R9, #4	# int, #@loadConI
074 +   mv  R20, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
080 +   sw  R29, [R19, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixPath.fs
084 +   beq  R28, zr, B6	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

088     B4: #	out( B6 B5 ) &lt;- in( B3 )  Freq: 0.999
088 +   beq   R30, zr, B6	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

08c     B5: #	out( B17 B6 ) &lt;- in( B4 )  Freq: 0.998001
08c +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
090 +   add R10, R20, R7	# ptr, #@addP_reg_reg
094 +   lb  R28, [R10]	# byte, #@loadB
098 +   bne  R28, R9, B17	#@cmpI_branch  P=0.001000 C=-1.000000

09c     B6: #	out( B14 B7 ) &lt;- in( B19 B20 B17 B5 B4 B3 )  Freq: 1
09c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
09c     lb  R7, [R23, #56]	# byte, #@loadB
0a0 +   bne  R7, zr, B14	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0a4     B7: #	out( B10 B8 ) &lt;- in( B26 B16 B14 B6 )  Freq: 1
0a4 +   mv  R7, R19	# ptr -&gt; long, #@castP2X
0a8 +   mv  R28, R21	# ptr -&gt; long, #@castP2X
0ac +   xorr  R28, R28, R7	#@xorL_reg_reg
0b0 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0b4 +   sw  R18, [R19, #20]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixPath.path
0b8 +   beq  R28, zr, B10	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0bc     B8: #	out( B10 B9 ) &lt;- in( B7 )  Freq: 0.999
0bc +   beq   R21, zr, B10	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

0c0     B9: #	out( B21 B10 ) &lt;- in( B8 )  Freq: 0.998001
0c0 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0c4 +   add R10, R20, R7	# ptr, #@addP_reg_reg
0c8 +   lb  R28, [R10]	# byte, #@loadB
0cc +   bne  R28, R9, B21	#@cmpI_branch  P=0.001000 C=-1.000000

0d0     B10: #	out( N296 ) &lt;- in( B23 B24 B21 B9 B8 B7 )  Freq: 1
0d0 +   #@membar_release
	fence iorw ow
0d4 +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0ec +   ret	// return register, #@Ret

0f0     B11: #	out( B3 B12 ) &lt;- in( B1 )  Freq: 0.000999987
0f0 +   lwu  R7, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
0f4 +   decode_heap_oop  R10, R7	#@decodeHeapOop
0f8     spill R11 -&gt; R19	# spill size = 64
0fc +   beq   R10, zr, B3	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

100     B12: #	out( B25 B13 ) &lt;- in( B11 )  Freq: 0.000499994
100 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
100     ld  R7, [R23, #32]	# int, #@loadL
104 +   beq  R7, zr, B25	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

108     B13: #	out( B3 ) &lt;- in( B12 )  Freq: 0.000499494
108 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
108     ld  R28, [R23, #48]	# ptr, #@loadP
10c +   add R28, R28, R7	# ptr, #@addP_reg_reg
110 +   addi  R7, R7, #-8	#@addL_reg_imm
114 +   sd  R10, [R28, #-8]	# ptr, #@storeP
118 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
118     sd  R7, [R23, #32]	# long, #@storeL
11c +   j  B3	#@branch

120     B14: #	out( B7 B15 ) &lt;- in( B6 )  Freq: 0.000999987
120 +   lwu  R28, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
124 +   decode_heap_oop  R10, R28	#@decodeHeapOop
128 +   beq   R10, zr, B7	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

12c     B15: #	out( B26 B16 ) &lt;- in( B14 )  Freq: 0.000499994
12c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
12c     ld  R7, [R23, #32]	# int, #@loadL
130 +   beq  R7, zr, B26	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

134     B16: #	out( B7 ) &lt;- in( B15 )  Freq: 0.000499494
134 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
134     ld  R28, [R23, #48]	# ptr, #@loadP
138 +   add R28, R28, R7	# ptr, #@addP_reg_reg
13c +   addi  R7, R7, #-8	#@addL_reg_imm
140 +   sd  R10, [R28, #-8]	# ptr, #@storeP
144 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
144     sd  R7, [R23, #32]	# long, #@storeL
148 +   j  B7	#@branch

14c     B17: #	out( B6 B18 ) &lt;- in( B5 )  Freq: 0.000998001
14c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
14c     ld  R7, [R23, #64]	# int, #@loadL
150 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
150     ld  R28, [R23, #80]	# ptr, #@loadP
154 +   #@membar_volatile
	fence iorw iorw
158 +   lb  R29, [R10]	# byte, #@loadB
15c +   beq  R29, zr, B6	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

160     B18: #	out( B20 B19 ) &lt;- in( B17 )  Freq: 0.000499001
160 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
164 +   bne  R7, zr, B20	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

168     B19: #	out( B6 ) &lt;- in( B18 )  Freq: 0.0002495
168 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
168     spill R23 -&gt; R11	# spill size = 64
16c +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
19c +   j  B6	#@branch

1a0     B20: #	out( B6 ) &lt;- in( B18 )  Freq: 0.0002495
1a0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
1a4 +   addi  R7, R7, #-8	#@addL_reg_imm
1a8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
1ac +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ac     sd  R7, [R23, #64]	# long, #@storeL
1b0 +   j  B6	#@branch

1b4     B21: #	out( B10 B22 ) &lt;- in( B9 )  Freq: 0.000998001
1b4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b4     ld  R7, [R23, #64]	# int, #@loadL
1b8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b8     ld  R28, [R23, #80]	# ptr, #@loadP
1bc +   #@membar_volatile
	fence iorw iorw
1c0 +   lb  R29, [R10]	# byte, #@loadB
1c4 +   beq  R29, zr, B10	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1c8     B22: #	out( B24 B23 ) &lt;- in( B21 )  Freq: 0.000499001
1c8 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1cc +   bne  R7, zr, B24	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1d0     B23: #	out( B10 ) &lt;- in( B22 )  Freq: 0.0002495
1d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1d0     spill R23 -&gt; R11	# spill size = 64
1d4 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
204 +   j  B10	#@branch

208     B24: #	out( B10 ) &lt;- in( B22 )  Freq: 0.0002495
208 +   add R28, R28, R7	# ptr, #@addP_reg_reg
20c +   addi  R7, R7, #-8	#@addL_reg_imm
210 +   sd  R10, [R28, #-8]	# ptr, #@storeP
214 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
214     sd  R7, [R23, #64]	# long, #@storeL
218 +   j  B10	#@branch

21c     B25: #	out( B3 ) &lt;- in( B12 )  Freq: 4.99987e-07
21c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
21c     spill R23 -&gt; R11	# spill size = 64
220 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
250 +   j  B3	#@branch

254     B26: #	out( B7 ) &lt;- in( B15 )  Freq: 4.99987e-07
254 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
254     spill R23 -&gt; R11	# spill size = 64
258 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
288 +   j  B7	#@branch

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='260'>
----------------------- MetaData before Compile_id = 260 ------------------------
{method}
 - this oop:          0x00000040961e8718
 - method holder:     &apos;java/lang/CharacterData&apos;
 - constants:         0x00000040961e73f8 constant pool [80] {0x00000040961e73f8} for &apos;java/lang/CharacterData&apos; cache=0x00000040961e8780
 - access:            0x81000018  static final 
 - name:              &apos;of&apos;
 - signature:         &apos;(I)Ljava/lang/CharacterData;&apos;
 - max stack:         3
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b790: 0xa i2c: 0x00000040139d7540 c2i: 0x00000040139d7584 c2iUV: 0x00000040139d7550
 - compiled entry     0x000000400c4ee880
 - code size:         136
 - code start:        0x00000040961e8670
 - code end (excl):   0x00000040961e86f8
 - method data:       0x00000040965ec718
 - checked ex length: 0
 - linenumber start:  0x00000040961e86f8
 - localvar length:   1
 - localvar start:    0x00000040961e870a
 - compiled code: nmethod   5873  114       3       java.lang.CharacterData::of (136 bytes)

------------------------ OptoAssembly for Compile_id = 260 -----------------------
#
#  java/lang/CharacterDataLatin1 * ( int )
#
#r012 c_rarg1   : parm 0: int
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B3 B2 )  Freq: 1

000     B1: #	out( B3 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     srliw  R28, R11, (#8 &amp; 0x1f)	#@urShiftI_reg_imm
020 +   bne  R28, zr, B3	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

024     B2: #	out( N1 ) &lt;- in( B1 )  Freq: 1
024 +   mv  R10, java/lang/CharacterDataLatin1:exact *	# ptr, #@loadConP
03c     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
054 +   ret	// return register, #@Ret

058     B3: #	out( N1 ) &lt;- in( B1 )  Freq: 5e-07
058 +   spill R11 -&gt; R8	# spill size = 32
05c +   spill R28 -&gt; [sp, #0]	# spill size = 32
060 +   li R11, #-187	# int, #@loadConI
064     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.CharacterData::of @ bci:4 (line 72) L[0]=R8 STK[0]=sp + #0
        # OopMap {off=104/0x68}
068 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='262'>
----------------------- MetaData before Compile_id = 262 ------------------------
{method}
 - this oop:          0x0000004096120198
 - method holder:     &apos;java/lang/Character&apos;
 - constants:         0x000000409611d860 constant pool [576] {0x000000409611d860} for &apos;java/lang/Character&apos; cache=0x00000040961e65e8
 - access:            0x81000009  public static 
 - name:              &apos;codePointAt&apos;
 - signature:         &apos;(Ljava/lang/CharSequence;I)I&apos;
 - max stack:         3
 - max locals:        4
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400831ff40: 0xba i2c: 0x00000040139438c0 c2i: 0x0000004013943908 c2iUV: 0x00000040139438d4
 - compiled entry     0x000000400c4ef740
 - code size:         51
 - code start:        0x0000004096120128
 - code end (excl):   0x000000409612015b
 - method data:       0x00000040965ecbe0
 - checked ex length: 0
 - linenumber start:  0x000000409612015b
 - localvar length:   4
 - localvar start:    0x0000004096120166
 - compiled code: nmethod   5905  116       3       java.lang.Character::codePointAt (51 bytes)

------------------------ OptoAssembly for Compile_id = 262 -----------------------
#
#  int ( java/lang/CharSequence *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/CharSequence *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B10 B7 B8 B9 B11 B6 )  Freq: 1

000     B1: #	out( B10 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
01c     lwu  R7, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
020     NullCheck R11

020     B2: #	out( B7 B3 ) &lt;- in( B1 )  Freq: 0.999999
020 +   mv  R29, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
030 +   bne  R7, R29, B7	#@cmpN_branch  P=0.000001 C=-1.000000

034     B3: #	out( B8 B4 ) &lt;- in( B2 )  Freq: 0.999998
034 +   # checkcastPP of R11, #@checkCastPP
034     lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
038 +   lb  R28, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
03c +   decode_heap_oop  R8, R7	#@decodeHeapOop
040 +   bne  R28, zr, B8	#@cmpI_reg_imm0_branch  P=0.000000 C=29648.000000

044     B4: #	out( B11 B5 ) &lt;- in( B3 )  Freq: 0.999997
044     lwu  R28, [R8, #12]	# range, #@loadRange
048     NullCheck R8

048     B5: #	out( B9 B6 ) &lt;- in( B4 )  Freq: 0.999996
048 +   bgeu  R12, R28, B9	#@cmpU_branch  P=0.000000 C=23657.000000

04c     B6: #	out( N1 ) &lt;- in( B5 )  Freq: 0.999996
04c +   addw  R7, R12, zr	#@convI2L_reg_reg
050 +   add R7, R8, R7	# ptr, #@addP_reg_reg
054 +   lbu  R10, [R7, #16]	# byte, #@loadUB
058     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
070 +   ret	// return register, #@Ret

074     B7: #	out( N1 ) &lt;- in( B2 )  Freq: 9.99999e-07
074 +   spill R11 -&gt; [sp, #8]	# spill size = 64
078 +   spill R12 -&gt; [sp, #4]	# spill size = 32
07c +   li R11, #-34	# int, #@loadConI
080     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #8 L[1]=sp + #4 L[2]=_ L[3]=_ STK[0]=sp + #8 STK[1]=sp + #4
        # OopMap {[8]=Oop off=132/0x84}
084     #@ShouldNotReachHere

090     B8: #	out( N1 ) &lt;- in( B3 )  Freq: 4.99999e-07
090 +   spill R11 -&gt; [sp, #8]	# spill size = 64
094 +   spill R12 -&gt; [sp, #4]	# spill size = 32
098 +   spill R28 -&gt; [sp, #16]	# spill size = 32
09c +   li R11, #-187	# int, #@loadConI
0a0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #16
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=sp + #8 L[1]=sp + #4
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #8 L[1]=sp + #4 L[2]=_ L[3]=_
        # OopMap {[8]=Oop off=164/0xa4}
0a4     #@ShouldNotReachHere

0b0     B9: #	out( N1 ) &lt;- in( B5 )  Freq: 4.76835e-07
0b0 +   spill R11 -&gt; [sp, #0]	# spill size = 64
0b4 +   spill R12 -&gt; [sp, #12]	# spill size = 32
0b8 +   spill R12 -&gt; [sp, #16]	# spill size = 32
0bc +   li R11, #-27	# int, #@loadConI
0c0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:1 (line 47) L[0]=R8 L[1]=sp + #16 STK[0]=sp + #12
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #0 L[1]=sp + #12 L[2]=_ L[3]=_
        # OopMap {fp=Oop [0]=Oop off=196/0xc4}
0c4     #@ShouldNotReachHere

0d0     B10: #	out( N1 ) &lt;- in( B1 )  Freq: 1.01328e-06
0d0 +   li R11, #-10	# int, #@loadConI
0d4     spill R12 -&gt; R8	# spill size = 32
0d8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL STK[1]=R8
        # OopMap {off=220/0xdc}
0dc     #@ShouldNotReachHere

0e8     B11: #	out( N1 ) &lt;- in( B4 )  Freq: 1.01328e-06
0e8 +   spill R11 -&gt; [sp, #0]	# spill size = 64
0ec +   spill R12 -&gt; [sp, #12]	# spill size = 32
0f0 +   spill R12 -&gt; [sp, #16]	# spill size = 32
0f4 +   li R11, #-10	# int, #@loadConI
0f8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::charAt @ bci:1 (line 47) L[0]=R8 L[1]=sp + #16 STK[0]=sp + #12
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #0 L[1]=sp + #12 L[2]=_ L[3]=_
        # OopMap {fp=Oop [0]=Oop off=252/0xfc}
0fc +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='280'>
----------------------- MetaData before Compile_id = 280 ------------------------
{method}
 - this oop:          0x00000040961e9788
 - method holder:     &apos;java/lang/CharacterDataLatin1&apos;
 - constants:         0x00000040961e89b8 constant pool [130] {0x00000040961e89b8} for &apos;java/lang/CharacterDataLatin1&apos; cache=0x00000040961eb818
 - access:            0x81000000  
 - name:              &apos;isJavaIdentifierPart&apos;
 - signature:         &apos;(I)Z&apos;
 - max stack:         3
 - max locals:        3
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      28
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b960: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c4f1180
 - code size:         20
 - code start:        0x00000040961e9748
 - code end (excl):   0x00000040961e975c
 - method data:       0x00000040965ed668
 - checked ex length: 0
 - linenumber start:  0x00000040961e975c
 - localvar length:   3
 - localvar start:    0x00000040961e9762
 - compiled code: nmethod   6343  119       3       java.lang.CharacterDataLatin1::isJavaIdentifierPart (20 bytes)

------------------------ OptoAssembly for Compile_id = 280 -----------------------
#
#  bool ( java/lang/CharacterDataLatin1:NotNull *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/CharacterDataLatin1:NotNull *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N49: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B4 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     li R28, #65535	# int, #@loadConI
044 +   andr  R28, R12, R28	#@andI_reg_reg
048 +   addw  R7, R28, zr	#@convI2L_reg_reg
04c +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
050 +   mv  R29, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1157 address=0x00000040d833e1c0&gt; *	# ptr, #@loadConP
068 +   add R7, R29, R7	# ptr, #@addP_reg_reg
06c +   li R29, #256	# int, #@loadConI
070 +   bgeu  R28, R29, B4	#@cmpU_branch  P=0.000001 C=-1.000000

074     B2: #	out( B5 B3 ) &lt;- in( B1 )  Freq: 0.999999
074 +   lw  R28, [R7, #16]	# int, #@loadI
078 +   li R7, #12288	# int, #@loadConI
07c +   andr  R8, R28, R7	#@andI_reg_reg
080 +   beq  R8, zr, B5	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

084     B3: #	out( N49 ) &lt;- in( B2 )  Freq: 0.999999
084 +   li R10, #1	# int, #@loadConI
088     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0a0 +   ret	// return register, #@Ret

0a4     B4: #	out( N49 ) &lt;- in( B1 )  Freq: 1.01328e-06
0a4 +   li R11, #-28	# int, #@loadConI
0a8     spill R28 -&gt; R8	# spill size = 32
0ac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.CharacterDataLatin1::getProperties @ bci:7 (line 74) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#Ptr0x00000040d833e1c0 STK[1]=R8
        # java.lang.CharacterDataLatin1::isJavaIdentifierPart @ bci:2 (line 120) L[0]=_ L[1]=_ L[2]=_
        # OopMap {off=176/0xb0}
0b0     #@ShouldNotReachHere

0bc     B5: #	out( N49 ) &lt;- in( B2 )  Freq: 4.76837e-07
0bc +   li R11, #-187	# int, #@loadConI
0c0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.CharacterDataLatin1::isJavaIdentifierPart @ bci:11 (line 121) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8
        # OopMap {off=196/0xc4}
0c4 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='298'>
----------------------- MetaData before Compile_id = 298 ------------------------
{method}
 - this oop:          0x0000004096506500
 - method holder:     &apos;java/util/concurrent/locks/AbstractQueuedSynchronizer&apos;
 - constants:         0x0000004096505498 constant pool [349] {0x0000004096505498} for &apos;java/util/concurrent/locks/AbstractQueuedSynchronizer&apos; cache=0x0000004096508bb8
 - access:            0x81000014  protected final 
 - name:              &apos;compareAndSetState&apos;
 - signature:         &apos;(II)Z&apos;
 - max stack:         7
 - max locals:        3
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x0000004008316ed0: 0xbaa i2c: 0x0000004013945bc0 c2i: 0x0000004013945c0c c2iUV: 0x0000004013945bd8
 - compiled entry     0x000000400c4f8180
 - code size:         13
 - code start:        0x00000040965064c8
 - code end (excl):   0x00000040965064d5
 - method data:       0x00000040965eed10
 - checked ex length: 0
 - linenumber start:  0x00000040965064d5
 - localvar length:   3
 - localvar start:    0x00000040965064da
 - compiled code: nmethod   6600  140       3       java.util.concurrent.locks.AbstractQueuedSynchronizer::compareAndSetState (13 bytes)

------------------------ OptoAssembly for Compile_id = 298 -----------------------
#
#  bool ( java/util/concurrent/locks/ReentrantReadWriteLock$FairSync:NotNull:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/concurrent/locks/ReentrantReadWriteLock$FairSync:NotNull:exact *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N32: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N32 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     #@membar_release
	fence iorw ow
040 +   addi  R7, R11, #16	# ptr, #@addP_reg_imm
044     
044 +   cmpxchg_acq [R7], R12, R13	# (int) if [R7] == R12 then [R7] &lt;-- R13
	mv R10, R10 == R12	# R10 &lt;-- (R10 == R12 ? 1 : 0), #@compareAndSwapIAcq
060     
060 +   #@membar_acquire
	fence ir iorw
064 +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
07c +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='299'>
----------------------- MetaData before Compile_id = 299 ------------------------
{method}
 - this oop:          0x000000409600b6f0
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;hashCode&apos;
 - signature:         &apos;()I&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      3
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4acb40
 - code size:         60
 - code start:        0x000000409600b688
 - code end (excl):   0x000000409600b6c4
 - method data:       0x00000040962ffe18
 - checked ex length: 0
 - linenumber start:  0x000000409600b6c4
 - localvar length:   2
 - localvar start:    0x000000409600b6d6
 - compiled code: nmethod   6674    3       3       java.lang.String::hashCode (60 bytes)

------------------------ OptoAssembly for Compile_id = 299 -----------------------
#
#  int ( java/lang/String:NotNull:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N234: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B20 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lw  R10, [R11, #12]	# int, #@loadI ! Field: java/lang/String.hash
040     spill R11 -&gt; R29	# spill size = 64
044 +   bne  R10, zr, B20	#@cmpI_reg_imm0_branch  P=0.474233 C=5375.000000

048     B2: #	out( B22 B3 ) &lt;- in( B1 )  Freq: 0.525767
048 +   lbu  R28, [R11, #17]	# byte, #@loadUB ! Field: java/lang/String.hashIsZero
04c +   li R7, #0	# int, #@loadConI
050 +   bne  R28, zr, B22	#@cmpI_reg_imm0_branch  P=0.001062 C=2825.000000

054     B3: #	out( B27 B4 ) &lt;- in( B2 )  Freq: 0.525209
054 +   lwu  R30, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
058 +   lb  R8, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
05c +   decode_heap_oop  R13, R30	#@decodeHeapOop
060 +   bne  R8, zr, B27	#@cmpI_reg_imm0_branch  P=0.000000 C=32293.000000

064     B4: #	out( B30 B5 ) &lt;- in( B3 )  Freq: 0.525209
064     lwu  R12, [R13, #12]	# range, #@loadRange
068     NullCheck R13

068     B5: #	out( B21 B6 ) &lt;- in( B4 )  Freq: 0.525208
068 +   li R16, #1	# int, #@loadConI
06c +   bleu  R12, zr, B21	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.056079 C=18260.000000

070     B6: #	out( B23 B7 ) &lt;- in( B5 )  Freq: 0.495755
070 +   addiw  R28, R12, #-1	#@addI_reg_imm
074 +   bgeu  R28, R12, B23	#@cmpU_branch  P=0.000001 C=-1.000000

078     B7: #	out( B24 B8 ) &lt;- in( B6 )  Freq: 0.495755
078 +   addiw  R14, R12, #-3	#@addI_reg_imm
07c +   li R15, #4000	# int, #@loadConI
084 +   lbu  R10, [R13, #16]	# byte, #@loadUB
088 +   ble  R14, R16, B24	#@cmpI_branch  P=0.000001 C=-1.000000

08c     B8: #	out( B25 B9 ) &lt;- in( B7 )  Freq: 0.495754
08c +   slliw  R30, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
090 +   subw  R28, R30, R10	#@subI_reg_reg
094 +   li R30, #4	# int, #@loadConI
098 +   bleu  R12, R16, B25	#@cmpU_branch  P=0.000001 C=-1.000000

09c     B9: #	out( B26 B10 ) &lt;- in( B8 )  Freq: 0.495754
09c +   bleu  R12, R30, B26	#@cmpU_branch  P=0.000001 C=-1.000000

0a0     B10: #	out( B11 ) &lt;- in( B9 )  Freq: 0.495753
0a0 +   li R9, #1	# int, #@loadConI
0a4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP

0a4     B11: #	out( B12 ) &lt;- in( B10 B13 ) Loop( B11-B13 ) Freq: 8.84029
0a4     subw  R31, R12, R9	#@subI_reg_reg
0a8 +   addiw  R30, R31, #-3	#@addI_reg_imm
0ac     CMove R30, (R14 lt R9), R30, R7	#@cmovI_cmpI
	
0b4 +   CMove R30, (R30 gtu R15), R30, R15	#@cmovI_cmpU
	
0bc +   addw  R17, R30, R9	#@addI_reg_reg

0c0     B12: #	out( B12 B13 ) &lt;- in( B11 B12 ) Loop( B12-B12 inner main of N69 strip mined) Freq: 157.64
0c0 +   addw  R30, R9, zr	#@convI2L_reg_reg
0c4 +   add R30, R13, R30	# ptr, #@addP_reg_reg
0c8 +   lbu  R10, [R30, #16]	# byte, #@loadUB
0cc +   addw  R10, R28, R10	#@addI_reg_reg
0d0 +   lbu  R31, [R30, #17]	# byte, #@loadUB
0d4 +   slliw  R11, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0d8 +   subw  R28, R11, R10	#@subI_reg_reg
0dc +   addw  R31, R28, R31	#@addI_reg_reg
0e0 +   slliw  R28, R31, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0e4 +   lbu  R11, [R30, #18]	# byte, #@loadUB
0e8 +   subw  R31, R28, R31	#@subI_reg_reg
0ec +   lbu  R28, [R30, #19]	# byte, #@loadUB
0f0 +   addw  R31, R31, R11	#@addI_reg_reg
0f4 +   slliw  R30, R31, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0f8 +   subw  R31, R30, R31	#@subI_reg_reg
0fc +   addw  R10, R31, R28	#@addI_reg_reg
100 +   slliw  R28, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
104 +   addiw  R9, R9, #4	#@addI_reg_imm
108 +   subw  R28, R28, R10	#@subI_reg_reg
10c +   blt  R9, R17, B12	#@cmpI_loop  P=0.943921 C=17236.000000

110     B13: #	out( B11 B14 ) &lt;- in( B12 )  Freq: 8.84029
110 +   ld  R30, [R23, #920]	# ptr, #@loadP
114 +   lwu zr, [R30]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::hashCode @ bci:37 (line 196) L[0]=_ L[1]=R10 L[2]=R13 L[3]=R12 L[4]=R9 L[5]=_
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=R29 L[1]=_
        # OopMap {x29=Oop c_rarg3=Oop off=276/0x114}
118 +   blt  R9, R14, B11	#@cmpI_branch  P=0.943921 C=17236.000000

11c     B14: #	out( B18 B15 ) &lt;- in( B24 B13 )  Freq: 0.495754
11c +   bge  R9, R12, B18	#@cmpI_branch  P=0.500000 C=-1.000000

120     B15: #	out( B28 B16 ) &lt;- in( B14 )  Freq: 0.247877
120 +   # castII of R9, #@castII
120     bgeu  R9, R12, B28	#@cmpU_branch  P=0.000001 C=-1.000000

124     B16: #	out( B29 B17 ) &lt;- in( B15 )  Freq: 0.247877
124 +   spill R9 -&gt; R28	# spill size = 32
128 +   # castII of R28, #@castII
128     bgeu  R28, R12, B29	#@cmpU_branch  P=0.000001 C=-1.000000

12c     B17: #	out( B17 B18 ) &lt;- in( B16 B17 ) Loop( B17-B17 inner post of N283) Freq: 0.495753
12c +   addw  R7, R9, zr	#@convI2L_reg_reg
130 +   add R7, R13, R7	# ptr, #@addP_reg_reg
134 +   slliw  R30, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
138 +   lbu  R7, [R7, #16]	# byte, #@loadUB
13c +   subw  R28, R30, R10	#@subI_reg_reg
140 +   addiw  R9, R9, #1	#@addI_reg_imm
144 +   addw  R10, R28, R7	#@addI_reg_reg
148 +   blt  R9, R12, B17	#@cmpI_loop  P=0.500000 C=17236.000000

14c     B18: #	out( B21 B19 ) &lt;- in( B17 B14 )  Freq: 0.495753
14c +   beq  R10, zr, B21	#@cmpI_reg_imm0_branch  P=0.000354 C=2822.000000

150     B19: #	out( B20 ) &lt;- in( B18 )  Freq: 0.495578
150 +   sw  R10, [R29, #12]	# int, #@storeI ! Field: java/lang/String.hash

154     B20: #	out( N234 ) &lt;- in( B19 B21 B22 B1 )  Freq: 0.999997
154     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
16c +   ret	// return register, #@Ret

170     B21: #	out( B20 ) &lt;- in( B18 B5 )  Freq: 0.0296288
170 +   sb  R16, [R29, #17]	# byte, #@storeB ! Field: java/lang/String.hashIsZero
174 +   li R10, #0	# int, #@loadConI
178 +   j  B20	#@branch

17c     B22: #	out( B20 ) &lt;- in( B2 )  Freq: 0.000558337
17c +   li R10, #0	# int, #@loadConI
180 +   j  B20	#@branch

184     B23: #	out( N234 ) &lt;- in( B6 )  Freq: 5.02338e-07
184 +   li R11, #-138	# int, #@loadConI
188     spill R29 -&gt; R8	# spill size = 64
18c +   spill R13 -&gt; [sp, #0]	# spill size = 64
190 +   spill R12 -&gt; [sp, #12]	# spill size = 32
194     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:13 (line 196) L[0]=_ L[1]=#0 L[2]=sp + #0 L[3]=sp + #12 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=sp + #12
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=R8 L[1]=_
        # OopMap {fp=Oop [0]=Oop off=408/0x198}
198     #@ShouldNotReachHere

1a4     B24: #	out( B14 ) &lt;- in( B7 )  Freq: 5.02338e-07
1a4 +   li R9, #1	# int, #@loadConI
1a8 +   j  B14	#@branch

1ac     B25: #	out( N234 ) &lt;- in( B8 )  Freq: 4.95754e-07
1ac     #@ShouldNotReachHere

1b8     B26: #	out( N234 ) &lt;- in( B9 )  Freq: 4.95754e-07
1b8     #@ShouldNotReachHere

1c4     B27: #	out( N234 ) &lt;- in( B3 )  Freq: 2.62605e-07
1c4 +   li R11, #-187	# int, #@loadConI
1c8     spill R29 -&gt; [sp, #0]	# spill size = 64
1cc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=R8
        # java.lang.String::hashCode @ bci:17 (line 2337) L[0]=sp + #0 L[1]=_
        # OopMap {[0]=Oop off=464/0x1d0}
1d0     #@ShouldNotReachHere

1dc     B28: #	out( N234 ) &lt;- in( B15 )  Freq: 2.51168e-07
1dc     #@ShouldNotReachHere

1e8     B29: #	out( N234 ) &lt;- in( B16 )  Freq: 2.51168e-07
1e8     #@ShouldNotReachHere

1f4     B30: #	out( N234 ) &lt;- in( B4 )  Freq: 5.32183e-07
1f4 +   li R11, #-10	# int, #@loadConI
1f8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:5 (line 196) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=_ L[1]=_
        # OopMap {off=508/0x1fc}
1fc     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='300'>
----------------------- MetaData before Compile_id = 300 ------------------------
{method}
 - this oop:          0x0000004096186b38
 - method holder:     &apos;java/lang/StringLatin1&apos;
 - constants:         0x0000004096185338 constant pool [380] {0x0000004096185338} for &apos;java/lang/StringLatin1&apos; cache=0x0000004096189c30
 - access:            0xc1000009  public static 
 - name:              &apos;equals&apos;
 - signature:         &apos;([B[B)Z&apos;
 - max stack:         4
 - max locals:        3
 - size of params:    2
 - method size:       13
 - intrinsic id:      109 _equalsL
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400831aae0: 0xbb i2c: 0x000000401396c3c0 c2i: 0x000000401396c408 c2iUV: 0x000000401396c3d4
 - compiled entry     0x000000400c4d8280
 - code size:         36
 - code start:        0x0000004096186ad8
 - code end (excl):   0x0000004096186afc
 - method data:       0x000000409654abe0
 - checked ex length: 0
 - linenumber start:  0x0000004096186afc
 - localvar length:   3
 - localvar start:    0x0000004096186b0a
 - compiled code: nmethod   6783   80       3       java.lang.StringLatin1::equals (36 bytes)

------------------------ OptoAssembly for Compile_id = 300 -----------------------
#
#  bool ( byte[int:&gt;=0]:exact *, byte[int:&gt;=0]:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: byte[int:&gt;=0]:exact *
#r014 c_rarg2:c_rarg2   : parm 1: byte[int:&gt;=0]:exact *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B41 B42 B31 B40 B39 B30 B33 B36 B37 B38 B34 B35 )  Freq: 1

000     B1: #	out( B41 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     lwu  R28, [R11, #12]	# range, #@loadRange
020     NullCheck R11

020     B2: #	out( B42 B3 ) &lt;- in( B1 )  Freq: 0.999999
020     lwu  R15, [R12, #12]	# range, #@loadRange
024     NullCheck R12

024     B3: #	out( B30 B4 ) &lt;- in( B2 )  Freq: 0.999998
024 +   li R10, #0	# int, #@loadConI
028 +   bne  R28, R15, B30	#@cmpI_branch  P=0.614652 C=4095.000000

02c     B4: #	out( B29 B5 ) &lt;- in( B3 )  Freq: 0.385347
02c +   li R29, #1	# int, #@loadConI
030 +   bleu  R28, zr, B29	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.053177 C=14668.000000

034     B5: #	out( B31 B6 ) &lt;- in( B4 )  Freq: 0.364856
034 +   addiw  R7, R28, #-1	#@addI_reg_imm
038 +   bgeu  R7, R28, B31	#@cmpU_branch  P=0.000001 C=-1.000000

03c     B6: #	out( B31 B7 ) &lt;- in( B5 )  Freq: 0.364855
03c +   lb  R31, [R11, #16]	# byte, #@loadB
040 +   bleu  R15, zr, B31	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

044     B7: #	out( B31 B8 ) &lt;- in( B6 )  Freq: 0.364855
044 +   bgeu  R7, R15, B31	#@cmpU_branch  P=0.000001 C=-1.000000

048     B8: #	out( B30 B9 ) &lt;- in( B7 )  Freq: 0.364854
048 +   lb  R30, [R12, #16]	# byte, #@loadB
04c +   bne  R31, R30, B30	#@cmpI_branch  P=0.057460 C=13888.000000

050     B9: #	out( B32 B10 ) &lt;- in( B8 )  Freq: 0.34389
050 +   li R31, #-2147483648	# int, #@loadConI
054 +   addiw  R16, R28, #-3	#@addI_reg_imm
058     CMove R16, (R7 lt R16), R16, R31	#@cmovI_cmpI
	
060 +   li R17, #4000	# int, #@loadConI
068 +   ble  R16, R29, B32	#@cmpI_branch  P=0.000001 C=-1.000000

06c     B10: #	out( B33 B11 ) &lt;- in( B9 )  Freq: 0.34389
06c +   li R7, #4	# int, #@loadConI
070 +   bleu  R15, R29, B33	#@cmpU_branch  P=0.000001 C=-1.000000

074     B11: #	out( B34 B12 ) &lt;- in( B10 )  Freq: 0.343889
074 +   bleu  R28, R29, B34	#@cmpU_branch  P=0.000001 C=-1.000000

078     B12: #	out( B35 B13 ) &lt;- in( B11 )  Freq: 0.343889
078 +   bleu  R28, R7, B35	#@cmpU_branch  P=0.000001 C=-1.000000

07c     B13: #	out( B36 B14 ) &lt;- in( B12 )  Freq: 0.343889
07c +   bleu  R15, R7, B36	#@cmpU_branch  P=0.000001 C=-1.000000

080     B14: #	out( B15 ) &lt;- in( B13 )  Freq: 0.343888
080 +   li R9, #1	# int, #@loadConI

084     B15: #	out( B16 ) &lt;- in( B14 B21 ) Loop( B15-B21 ) Freq: 0.408041
084 +   subw  R29, R16, R9	#@subI_reg_reg
088     CMove R29, (R16 lt R9), R29, R10	#@cmovI_cmpI
	
090 +   CMove R29, (R29 gtu R17), R29, R17	#@cmovI_cmpU
	
098 +   addw  R14, R29, R9	#@addI_reg_reg
        nop 	# 2 bytes pad for loops and calls

0a0     B16: #	out( B30 B17 ) &lt;- in( B15 B20 ) Loop( B16-B20 inner main of N91 strip mined) Freq: 1.61443
0a0 +   addw  R7, R9, zr	#@convI2L_reg_reg
0a4 +   add R29, R11, R7	# ptr, #@addP_reg_reg
0a8 +   lb  R30, [R29, #16]	# byte, #@loadB
0ac +   add R7, R12, R7	# ptr, #@addP_reg_reg
0b0 +   lb  R13, [R7, #16]	# byte, #@loadB
0b4 +   bne  R30, R13, B30	#@cmpI_branch  P=0.057460 C=13888.000000

0b8     B17: #	out( B30 B18 ) &lt;- in( B16 )  Freq: 1.52167
0b8 +   lb  R30, [R29, #17]	# byte, #@loadB
0bc +   lb  R31, [R7, #17]	# byte, #@loadB
0c0 +   bne  R30, R31, B30	#@cmpI_branch  P=0.057460 C=13888.000000

0c4     B18: #	out( B30 B19 ) &lt;- in( B17 )  Freq: 1.43423
0c4 +   lb  R30, [R29, #18]	# byte, #@loadB
0c8 +   lb  R31, [R7, #18]	# byte, #@loadB
0cc +   bne  R30, R31, B30	#@cmpI_branch  P=0.057460 C=13888.000000

0d0     B19: #	out( B30 B20 ) &lt;- in( B18 )  Freq: 1.35182
0d0 +   lb  R30, [R29, #19]	# byte, #@loadB
0d4 +   lb  R7, [R7, #19]	# byte, #@loadB
0d8 +   bne  R30, R7, B30	#@cmpI_branch  P=0.057460 C=13888.000000

0dc     B20: #	out( B16 B21 ) &lt;- in( B19 )  Freq: 1.27415
0dc +   addiw  R9, R9, #4	#@addI_reg_imm
0e0 +   blt  R9, R14, B16	#@cmpI_loop  P=0.946823 C=13090.000000

0e4     B21: #	out( B15 B22 ) &lt;- in( B20 )  Freq: 0.0677554
0e4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e4     ld  R7, [R23, #920]	# ptr, #@loadP
0e8 +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::equals @ bci:29 (line 96) L[0]=R11 L[1]=R12 L[2]=R9
        # OopMap {c_rarg1=Oop c_rarg2=Oop off=232/0xe8}
0ec +   blt  R9, R16, B15	#@cmpI_branch  P=0.946823 C=13090.000000

0f0     B22: #	out( B29 B23 ) &lt;- in( B32 B21 )  Freq: 0.00360338
0f0 +   bge  R9, R28, B29	#@cmpI_branch  P=0.500000 C=-1.000000

0f4     B23: #	out( B37 B24 ) &lt;- in( B22 )  Freq: 0.00180169
0f4 +   # castII of R9, #@castII
0f4     bgeu  R9, R28, B37	#@cmpU_branch  P=0.000001 C=-1.000000

0f8     B24: #	out( B38 B25 ) &lt;- in( B23 )  Freq: 0.00180169
0f8 +   spill R9 -&gt; R29	# spill size = 32
0fc +   # castII of R29, #@castII
0fc     bgeu  R29, R28, B38	#@cmpU_branch  P=0.000001 C=-1.000000

100     B25: #	out( B39 B26 ) &lt;- in( B24 )  Freq: 0.00180168
100 +   bgeu  R9, R15, B39	#@cmpU_branch  P=0.000001 C=-1.000000

104     B26: #	out( B40 B27 ) &lt;- in( B25 )  Freq: 0.00180168
104 +   bgeu  R29, R15, B40	#@cmpU_branch  P=0.000001 C=-1.000000

108     B27: #	out( B30 B28 ) &lt;- in( B26 B28 ) Loop( B27-B28 inner post of N209) Freq: 0.00340756
108 +   addw  R7, R9, zr	#@convI2L_reg_reg
10c +   add R29, R11, R7	# ptr, #@addP_reg_reg
110 +   lb  R29, [R29, #16]	# byte, #@loadB
114 +   add R7, R12, R7	# ptr, #@addP_reg_reg
118 +   lb  R30, [R7, #16]	# byte, #@loadB
11c +   bne  R29, R30, B30	#@cmpI_branch  P=0.057460 C=13888.000000

120     B28: #	out( B27 B29 ) &lt;- in( B27 )  Freq: 0.00321177
120 +   addiw  R9, R9, #1	#@addI_reg_imm
124 +   blt  R9, R28, B27	#@cmpI_loop  P=0.500000 C=13090.000000

128     B29: #	out( B30 ) &lt;- in( B22 B4 B28 )  Freq: 0.0238992
128 +   li R10, #1	# int, #@loadConI

12c     B30: #	out( N1 ) &lt;- in( B27 B18 B8 B16 B17 B19 B29 B3 )  Freq: 0.999995
12c     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
144 +   ret	// return register, #@Ret

148     B31: #	out( N1 ) &lt;- in( B6 B7 B5 )  Freq: 1.10426e-06
148 +   spill R11 -&gt; R8	# spill size = 64
14c +   spill R12 -&gt; [sp, #0]	# spill size = 64
150 +   spill R28 -&gt; [sp, #8]	# spill size = 32
154 +   li R11, #-138	# int, #@loadConI
158     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::equals @ bci:12 (line 96) L[0]=R8 L[1]=sp + #0 L[2]=#0 STK[0]=#0 STK[1]=sp + #8
        # OopMap {fp=Oop [0]=Oop off=348/0x15c}
15c     #@ShouldNotReachHere

168     B32: #	out( B22 ) &lt;- in( B9 )  Freq: 3.48457e-07
168 +   li R9, #1	# int, #@loadConI
16c +   j  B22	#@branch

170     B33: #	out( N1 ) &lt;- in( B10 )  Freq: 3.4389e-07
170     #@ShouldNotReachHere

17c     B34: #	out( N1 ) &lt;- in( B11 )  Freq: 3.43889e-07
17c     #@ShouldNotReachHere

188     B35: #	out( N1 ) &lt;- in( B12 )  Freq: 3.43889e-07
188     #@ShouldNotReachHere

194     B36: #	out( N1 ) &lt;- in( B13 )  Freq: 3.43889e-07
194     #@ShouldNotReachHere

1a0     B37: #	out( N1 ) &lt;- in( B23 )  Freq: 1.82561e-09
1a0     #@ShouldNotReachHere

1ac     B38: #	out( N1 ) &lt;- in( B24 )  Freq: 1.82561e-09
1ac     #@ShouldNotReachHere

1b8     B39: #	out( N1 ) &lt;- in( B25 )  Freq: 1.82561e-09
1b8     #@ShouldNotReachHere

1c4     B40: #	out( N1 ) &lt;- in( B26 )  Freq: 1.82561e-09
1c4     #@ShouldNotReachHere

1d0     B41: #	out( N1 ) &lt;- in( B1 )  Freq: 1.01328e-06
1d0 +   li R11, #-10	# int, #@loadConI
1d4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::equals @ bci:1 (line 95) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # OopMap {off=472/0x1d8}
1d8     #@ShouldNotReachHere

1e4     B42: #	out( N1 ) &lt;- in( B2 )  Freq: 1.01328e-06
1e4 +   li R11, #-10	# int, #@loadConI
1e8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::equals @ bci:3 (line 95) L[0]=_ L[1]=_ L[2]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=492/0x1ec}
1ec     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='301'>
----------------------- MetaData before Compile_id = 301 ------------------------
{method}
 - this oop:          0x000000409600e598
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;toString&apos;
 - signature:         &apos;()Ljava/lang/String;&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c509280
 - code size:         2
 - code start:        0x000000409600e580
 - code end (excl):   0x000000409600e582
 - method data:       0x0000004096487c70
 - checked ex length: 0
 - linenumber start:  0x000000409600e582
 - localvar length:   1
 - localvar start:    0x000000409600e58a
 - compiled code: nmethod   6801  183       3       java.lang.String::toString (2 bytes)

------------------------ OptoAssembly for Compile_id = 301 -----------------------
#
#  java/lang/String:exact * ( java/lang/String:NotNull:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N16: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N16 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     spill R11 -&gt; R10	# spill size = 64
040 +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
058 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='302'>
----------------------- MetaData before Compile_id = 302 ------------------------
{method}
 - this oop:          0x000000409600a890
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;equals&apos;
 - signature:         &apos;(Ljava/lang/Object;)Z&apos;
 - max stack:         3
 - max locals:        3
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      1
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824bb30: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c4bb740
 - code size:         56
 - code start:        0x000000409600a820
 - code end (excl):   0x000000409600a858
 - method data:       0x00000040963f5748
 - checked ex length: 0
 - linenumber start:  0x000000409600a858
 - localvar length:   3
 - localvar start:    0x000000409600a86a
 - compiled code: nmethod   6842   49       3       java.lang.String::equals (56 bytes)

------------------------ OptoAssembly for Compile_id = 302 -----------------------
#
#  bool ( java/lang/String:NotNull:exact *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N111: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B10 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     beq  R11, R12, B10	#@cmpP_branch  P=0.064830 C=5337.000000

040     B2: #	out( B16 B3 ) &lt;- in( B1 )  Freq: 0.93517
040     lwu  R7, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
044     NullCheck R12

044     B3: #	out( B15 B4 ) &lt;- in( B2 )  Freq: 0.935169
044 +   mv  R29, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
054 +   lb  R30, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
058 +   bne  R7, R29, B15	#@cmpN_branch  P=0.000000 C=-1.000000

05c     B4: #	out( B14 B5 ) &lt;- in( B3 )  Freq: 0.935169
05c +   # checkcastPP of R12, #@checkCastPP
05c     lb  R8, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
060 +   bne  R30, R8, B14	#@cmpI_branch  P=0.000000 C=4991.000000

064     B5: #	out( B12 B6 ) &lt;- in( B4 )  Freq: 0.935168
064 +   lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
068 +   decode_heap_oop  R7, R7	#@decodeHeapOop
06c +   lwu  R29, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
070 +   beq   R7, zr, B12	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

074     B6: #	out( B13 B7 ) &lt;- in( B5 )  Freq: 0.935167
074 +   decode_heap_oop  R28, R29	#@decodeHeapOop
078 +   lwu  R14, [R7, #12]	# range, #@loadRange
07c +   beq   R28, zr, B13	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

080     B7: #	out( B11 B8 ) &lt;- in( B6 )  Freq: 0.935166
080 +   lwu  R30, [R28, #12]	# range, #@loadRange
084 +   bne  R14, R30, B11	#@cmpI_branch  P=0.001000 C=-1.000000

088     B8: #	out( B9 ) &lt;- in( B7 )  Freq: 0.934231
088 +   addi  R13, R28, #16	# ptr, #@addP_reg_imm
08c +   addi  R11, R7, #16	# ptr, #@addP_reg_imm
090 +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL

120     B9: #	out( N111 ) &lt;- in( B10 B8 B11 )  Freq: 0.999997
120     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
138     ret	// return register, #@Ret

13c     B10: #	out( B9 ) &lt;- in( B1 )  Freq: 0.0648304
13c +   li R10, #1	# int, #@loadConI
140 +   j  B9	#@branch

144     B11: #	out( B9 ) &lt;- in( B7 )  Freq: 0.000935166
144 +   li R10, #0	# int, #@loadConI
148 +   j  B9	#@branch

14c     B12: #	out( N111 ) &lt;- in( B5 )  Freq: 9.47586e-07
14c     #@ShouldNotReachHere

158     B13: #	out( N111 ) &lt;- in( B6 )  Freq: 9.47585e-07
158     #@ShouldNotReachHere

164     B14: #	out( N111 ) &lt;- in( B4 )  Freq: 4.67584e-07
164 +   spill R11 -&gt; [sp, #0]	# spill size = 64
168 +   spill R12 -&gt; [sp, #8]	# spill size = 64
16c +   spill R30 -&gt; [sp, #16]	# spill size = 32
170 +   li R11, #-187	# int, #@loadConI
174     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #0 L[1]=_ L[2]=sp + #8 STK[0]=sp + #16 STK[1]=R8
        # OopMap {[0]=Oop [8]=Oop off=376/0x178}
178     #@ShouldNotReachHere

184     B15: #	out( N111 ) &lt;- in( B3 )  Freq: 1e-35
184 +   spill R11 -&gt; R8	# spill size = 64
188 +   spill R12 -&gt; [sp, #8]	# spill size = 64
18c +   li R11, #-34	# int, #@loadConI
190     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=R8 L[1]=sp + #8 L[2]=_ STK[0]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=404/0x194}
194     #@ShouldNotReachHere

1a0     B16: #	out( N111 ) &lt;- in( B2 )  Freq: 9.47588e-07
1a0 +   spill R11 -&gt; R8	# spill size = 64
1a4 +   li R11, #-12	# int, #@loadConI
1a8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=R8 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # OopMap {fp=Oop off=428/0x1ac}
1ac     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='303'>
----------------------- MetaData before Compile_id = 303 ------------------------
{method}
 - this oop:          0x0000004096187e38
 - method holder:     &apos;java/lang/StringLatin1&apos;
 - constants:         0x0000004096185338 constant pool [380] {0x0000004096185338} for &apos;java/lang/StringLatin1&apos; cache=0x0000004096189c30
 - access:            0xc1000009  public static 
 - name:              &apos;replace&apos;
 - signature:         &apos;([BCC)Ljava/lang/String;&apos;
 - max stack:         6
 - max locals:        7
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x0000004008316ed0: 0xbaa i2c: 0x0000004013945bc0 c2i: 0x0000004013945c0c c2iUV: 0x0000004013945bd8
 - compiled entry     0x000000400c4da940
 - code size:         198
 - code start:        0x0000004096187cd0
 - code end (excl):   0x0000004096187d96
 - method data:       0x00000040965bec28
 - checked ex length: 0
 - linenumber start:  0x0000004096187d96
 - localvar length:   10
 - localvar start:    0x0000004096187dbe
 - compiled code: nmethod   7093   88       3       java.lang.StringLatin1::replace (198 bytes)

------------------------ OptoAssembly for Compile_id = 303 -----------------------
#
#  java/lang/String:exact * ( byte[int:&gt;=0]:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: byte[int:&gt;=0]:exact *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B100 B108 B90 B97 B103 B111 B101 B95 B98 B93 B75 B102 B91 B92 B96 B94 B105 B49 B106 B107 B99 B104 )  Freq: 1

000     B1: #	out( B100 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
01c     srliw  R28, R12, (#8 &amp; 0x1f)	#@urShiftI_reg_imm
020     spill R11 -&gt; R7	# spill size = 64
024 +   bne  R28, zr, B100	#@cmpI_reg_imm0_branch  P=0.000000 C=6786.000000

028     B2: #	out( B108 B3 ) &lt;- in( B1 )  Freq: 1
028 +   spill R11 -&gt; R15	# spill size = 64
02c     lwu  R10, [R11, #12]	# range, #@loadRange
030     NullCheck R11

030     B3: #	out( B85 B4 ) &lt;- in( B2 )  Freq: 0.999999
030 +   bleu  R10, zr, B85	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000829 C=4825.000000

034     B4: #	out( B90 B5 ) &lt;- in( B3 )  Freq: 0.999169
034 +   addiw  R9, R10, #-1	#@addI_reg_imm
038 +   bgeu  R9, R10, B90	#@cmpU_branch  P=0.000001 C=-1.000000

03c     B5: #	out( B7 B6 ) &lt;- in( B4 )  Freq: 0.999168
03c +   lb  R28, [R11, #16]	# byte, #@loadB
040 +   slliw  R7, R12, (#24 &amp; 0x1f)	#@lShiftI_reg_imm
044 +   sraiw  R11, R7, (#24 &amp; 0x1f)	#@rShiftI_reg_imm
048 +   addiw  R16, R10, #-3	#@addI_reg_imm
04c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
04c     bne  R28, R11, B7	#@cmpI_branch  P=0.788633 C=4821.000000

050     B6: #	out( B18 ) &lt;- in( B5 )  Freq: 0.211191
050 +   li R8, #0	# int, #@loadConI
054 +   li R7, #1	# int, #@loadConI
058 +   j  B18	#@branch

05c     B7: #	out( B78 B8 ) &lt;- in( B5 )  Freq: 0.787977
05c +   li R7, #1	# int, #@loadConI
060 +   ble  R16, R7, B78	#@cmpI_branch  P=0.000001 C=-1.000000

064     B8: #	out( B96 B9 ) &lt;- in( B7 )  Freq: 0.787976
064 +   li R29, #1	# int, #@loadConI
068 +   li R28, #4	# int, #@loadConI
06c +   bleu  R10, R29, B96	#@cmpU_branch  P=0.000001 C=-1.000000

070     B9: #	out( B97 B10 ) &lt;- in( B8 )  Freq: 0.787976
070 +   bleu  R10, R28, B97	#@cmpU_branch  P=0.000001 C=-1.000000

074     B10: #	out( B11 ) &lt;- in( B9 )  Freq: 0.787975
074 +   li R17, #1	# int, #@loadConI

078     B11: #	out( B12 ) &lt;- in( B10 B53 ) Loop( B11-B53 ) Freq: 0.788387
078     spill R17 -&gt; R14	# spill size = 32
        nop 	# 2 bytes pad for loops and calls

080     B12: #	out( B17 B13 ) &lt;- in( B11 B51 ) Loop( B12-B51 inner main of N153 strip mined) Freq: 1.28505
080 +   addw  R28, R14, zr	#@convI2L_reg_reg
084 +   add R28, R15, R28	# ptr, #@addP_reg_reg
088 +   lb  R29, [R28, #16]	# byte, #@loadB
08c +   beq  R29, R11, B17	#@cmpI_branch  P=0.211367 C=4821.000000

090     B13: #	out( B15 B14 ) &lt;- in( B12 )  Freq: 1.01343
090 +   lb  R30, [R28, #17]	# byte, #@loadB
094 +   bne  R30, R11, B15	#@cmpI_branch  P=0.788633 C=4821.000000

098     B14: #	out( B18 ) &lt;- in( B13 )  Freq: 0.214205
098 +   addiw  R8, R14, #1	#@addI_reg_imm
09c +   j  B18	#@branch

0a0     B15: #	out( B50 B16 ) &lt;- in( B13 )  Freq: 0.799224
0a0 +   lb  R30, [R28, #18]	# byte, #@loadB
0a4 +   bne  R30, R11, B50	#@cmpI_branch  P=0.788633 C=4821.000000

0a8     B16: #	out( B17 ) &lt;- in( B15 )  Freq: 0.16893
0a8 +   addiw  R14, R14, #2	#@addI_reg_imm

0ac     B17: #	out( B18 ) &lt;- in( B12 B16 )  Freq: 0.440546
0ac     spill R14 -&gt; R8	# spill size = 32

0b0     B18: #	out( B85 B19 ) &lt;- in( B83 B6 B17 B14 B50 )  Freq: 0.999166
0b0 +   bge  R8, R10, B85	#@cmpI_branch  P=0.003910 C=1023.000000

0b4     B19: #	out( B101 B20 ) &lt;- in( B18 )  Freq: 0.995259
0b4 +   srliw  R29, R13, (#8 &amp; 0x1f)	#@urShiftI_reg_imm
0b8 +   li R28, #1048576	# int, #@loadConI
0bc     spill R13 -&gt; R14	# spill size = 32
0c0 +   bne  R29, zr, B101	#@cmpI_reg_imm0_branch  P=0.000000 C=6786.000000

0c4     B20: #	out( B86 B21 ) &lt;- in( B19 )  Freq: 0.995259
0c4 +   bgtu  R10, R28, B86	#@cmpU_branch  P=0.000001 C=-1.000000

0c8     B21: #	out( B86 B22 ) &lt;- in( B20 )  Freq: 0.995258
0c8 +   addw  R28, R10, zr	#@convI2L_reg_reg
0cc +   addi  R28, R28, #23	#@addL_reg_imm
0d0 +   ld  R30, [R23, #288]	# ptr, #@loadP
0d4 +   andi  R28, R28, #-8	#@andL_reg_imm
0d8 +   ld  R29, [R23, #304]	# ptr, #@loadP
0dc +   add R28, R30, R28	# ptr, #@addP_reg_reg
0e0 +   bgeu  R28, R29, B86	#@cmpP_branch  P=0.000100 C=-1.000000

0e4     B22: #	out( B23 ) &lt;- in( B21 )  Freq: 0.995158
0e4 +   sd  R28, [R23, #288]	# ptr, #@storeP
0e8 +   li R28, #1	# long, #@loadConL
0ec +   mv  R29, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0fc +   sd  R28, [R30]	# long, #@storeL
100 +   sw  R29, [R30, #8]	# compressed klass ptr, #@storeNKlass
104 +   sw  R10, [R30, #12]	# int, #@storeI

108     B23: #	out( B36 B24 ) &lt;- in( B87 B22 )  Freq: 0.995259
108     
108 +   MEMBAR-store-store	#@membar_storestore
10c +   # checkcastPP of R30, #@checkCastPP
10c     spill R30 -&gt; [sp, #24]	# spill size = 64
110 +   ble  R8, zr, B36	#@cmpI_reg_imm0_branch  P=0.213314 C=4777.000000

114     B24: #	out( B95 B25 ) &lt;- in( B23 )  Freq: 0.782956
114 +   addiw  R17, R8, #-1	#@addI_reg_imm
118 +   bgeu  R17, R10, B95	#@cmpU_branch  P=0.000001 C=-1.000000

11c     B25: #	out( B95 B26 ) &lt;- in( B24 )  Freq: 0.782955
11c +   li R13, #2000	# int, #@loadConI
120 +   lb  R28, [R15, #16]	# byte, #@loadB
124 +   bleu  R10, zr, B95	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

128     B26: #	out( B32 B27 ) &lt;- in( B25 )  Freq: 0.782955
128 +   sb  R28, [R30, #16]	# byte, #@storeB
12c +   ble  R17, R7, B32	#@cmpI_branch  P=0.000001 C=-1.000000

130     B27: #	out( B98 B28 ) &lt;- in( B26 )  Freq: 0.782954
130 +   li R29, #2	# int, #@loadConI
134 +   bleu  R10, R7, B98	#@cmpU_branch  P=0.000001 C=-1.000000

138     B28: #	out( B99 B29 ) &lt;- in( B27 )  Freq: 0.782953
138 +   bleu  R10, R29, B99	#@cmpU_branch  P=0.000001 C=-1.000000

13c     B29: #	out( B30 ) &lt;- in( B28 B31 ) Loop( B29-B31 ) Freq: 3.67042
13c +   subw  R28, R8, R7	#@subI_reg_reg
140 +   li R30, #0	# int, #@loadConI
144 +   addiw  R29, R28, #-1	#@addI_reg_imm
148     CMove R29, (R17 lt R7), R29, R30	#@cmovI_cmpI
	
150 +   CMove R29, (R29 gtu R13), R29, R13	#@cmovI_cmpU
	
158 +   addw  R28, R29, R7	#@addI_reg_reg
        nop 	# 2 bytes pad for loops and calls

160     B30: #	out( B30 B31 ) &lt;- in( B29 B30 ) Loop( B30-B30 inner main of N232 strip mined) Freq: 17.2067
160 +   addw  R29, R7, zr	#@convI2L_reg_reg
164 +   add R30, R15, R29	# ptr, #@addP_reg_reg
168 +   lb  R18, [R30, #16]	# byte, #@loadB
16c +   spill [sp, #24] -&gt; R31	# spill size = 64
170 +   add R29, R31, R29	# ptr, #@addP_reg_reg
174 +   sb  R18, [R29, #16]	# byte, #@storeB
178 +   lb  R30, [R30, #17]	# byte, #@loadB
17c +   addiw  R7, R7, #2	#@addI_reg_imm
180 +   sb  R30, [R29, #17]	# byte, #@storeB
184 +   blt  R7, R28, B30	#@cmpI_loop  P=0.786686 C=3758.000000

188     B31: #	out( B29 B32 ) &lt;- in( B30 )  Freq: 3.67042
188 +   ld  R18, [R23, #920]	# ptr, #@loadP
18c +   lwu zr, [R18]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::replace @ bci:76 (line 314) L[0]=R15 L[1]=R12 L[2]=R14 L[3]=R10 L[4]=R8 L[5]=sp + #24 L[6]=R7
        # OopMap {c_rarg5=Oop [24]=Oop off=396/0x18c}
190 +   blt  R7, R17, B29	#@cmpI_branch  P=0.786686 C=3758.000000

194     B32: #	out( B36 B33 ) &lt;- in( B26 B31 )  Freq: 0.782953
194 +   bge  R7, R8, B36	#@cmpI_branch  P=0.500000 C=-1.000000

198     B33: #	out( B104 B34 ) &lt;- in( B32 )  Freq: 0.391477
198 +   # castII of R7, #@castII
198     bgeu  R7, R10, B104	#@cmpU_branch  P=0.000001 C=-1.000000

19c     B34: #	out( B105 B35 ) &lt;- in( B33 )  Freq: 0.391476
19c +   spill R7 -&gt; R29	# spill size = 32
1a0 +   # castII of R29, #@castII
1a0     bgeu  R29, R10, B105	#@cmpU_branch  P=0.000001 C=-1.000000

1a4     B35: #	out( B35 B36 ) &lt;- in( B34 B35 ) Loop( B35-B35 inner post of N765) Freq: 0.782951
1a4 +   addw  R28, R7, zr	#@convI2L_reg_reg
1a8 +   add R29, R15, R28	# ptr, #@addP_reg_reg
1ac +   lb  R29, [R29, #16]	# byte, #@loadB
1b0     spill [sp, #24] -&gt; R30	# spill size = 64
1b4 +   add R28, R30, R28	# ptr, #@addP_reg_reg
1b8 +   addiw  R7, R7, #1	#@addI_reg_imm
1bc +   sb  R29, [R28, #16]	# byte, #@storeB
1c0 +   blt  R7, R8, B35	#@cmpI_loop  P=0.500000 C=3758.000000

1c4     B36: #	out( B72 B37 ) &lt;- in( B35 B32 B23 )  Freq: 0.995255
1c4 +   bge  R8, R10, B72	#@cmpI_branch  P=0.066514 C=15320.000000

1c8     B37: #	out( B91 B38 ) &lt;- in( B36 )  Freq: 0.929056
1c8 +   bgeu  R8, R10, B91	#@cmpU_branch  P=0.000001 C=-1.000000

1cc     B38: #	out( B91 B39 ) &lt;- in( B37 )  Freq: 0.929055
1cc +   bgeu  R9, R10, B91	#@cmpU_branch  P=0.000001 C=-1.000000

1d0     B39: #	out( B91 B40 ) &lt;- in( B38 )  Freq: 0.929054
1d0 +   addiw  R28, R8, #1	#@addI_reg_imm
1d4 +   slliw  R7, R14, (#24 &amp; 0x1f)	#@lShiftI_reg_imm
1d8 +   bgeu  R9, R10, B91	#@cmpU_branch  P=0.000001 C=-1.000000

1dc     B40: #	out( B41 ) &lt;- in( B39 )  Freq: 0.929053
1dc +   sraiw  R31, R7, (#24 &amp; 0x1f)	#@rShiftI_reg_imm

1e0     B41: #	out( B76 B42 ) &lt;- in( B40 B43 ) Loop( B41-B43 inner pre of N776) Freq: 1.85811
1e0 +   addw  R7, R8, zr	#@convI2L_reg_reg
1e4 +   add R29, R15, R7	# ptr, #@addP_reg_reg
1e8 +   lb  R30, [R29, #16]	# byte, #@loadB
1ec +   beq  R30, R11, B76	#@cmpI_branch  P=0.149640 C=14301.000000

1f0     B42: #	out( B44 B43 ) &lt;- in( B41 B76 )  Freq: 1.85811
1f0 +   spill [sp, #24] -&gt; R29	# spill size = 64
1f4 +   add R7, R29, R7	# ptr, #@addP_reg_reg
1f8 +   addiw  R29, R8, #1	#@addI_reg_imm
1fc +   sb  R30, [R7, #16]	# byte, #@storeB
200 +   bge  R29, R28, B44	#@cmpI_loop  P=0.500000 C=14301.000000

204     B43: #	out( B41 ) &lt;- in( B42 )  Freq: 0.929053
204 +   spill R29 -&gt; R8	# spill size = 32
208 +   j  B41	#@branch

20c     B44: #	out( B66 B45 ) &lt;- in( B42 )  Freq: 0.929053
20c +   bge  R29, R16, B66	#@cmpI_branch  P=0.000001 C=-1.000000

210     B45: #	out( B92 B46 ) &lt;- in( B44 )  Freq: 0.929052
210 +   spill R29 -&gt; R17	# spill size = 32
214 +   # castII of R17, #@castII
214     spill R17 -&gt; R30	# spill size = 32
218 +   addiw  R7, R8, #4	#@addI_reg_imm
21c +   # castII of R30, #@castII
21c     bgeu  R30, R10, B92	#@cmpU_branch  P=0.000001 C=-1.000000

220     B46: #	out( B93 B47 ) &lt;- in( B45 )  Freq: 0.929051
220 +   bgeu  R17, R10, B93	#@cmpU_branch  P=0.000001 C=-1.000000

224     B47: #	out( B94 B48 ) &lt;- in( B46 )  Freq: 0.92905
224 +   bgeu  R29, R10, B94	#@cmpU_branch  P=0.000001 C=-1.000000

228     B48: #	out( B65 B49 ) &lt;- in( B47 )  Freq: 0.929049
228 +   bltu  R7, R10, B65	#@cmpU_branch  P=0.999999 C=-1.000000

22c     B49: #	out( N1 ) &lt;- in( B48 )  Freq: 9.41386e-07
22c     #@ShouldNotReachHere

238     B50: #	out( B18 B51 ) &lt;- in( B15 )  Freq: 0.630294
238 +   lb  R18, [R28, #19]	# byte, #@loadB
23c +   addiw  R8, R14, #3	#@addI_reg_imm
240 +   beq  R18, R11, B18	#@cmpI_branch  P=0.211367 C=4821.000000

244     B51: #	out( B12 B52 ) &lt;- in( B50 )  Freq: 0.497071
244 +   subw  R28, R10, R17	#@subI_reg_reg
248 +   addiw  R29, R28, #-3	#@addI_reg_imm
24c +   li R28, #0	# int, #@loadConI
250     CMove R29, (R16 lt R17), R29, R28	#@cmovI_cmpI
	
258 +   li R28, #4000	# int, #@loadConI
260 +   li R30, #4000	# int, #@loadConI
268     CMove R29, (R29 gtu R30), R29, R28	#@cmovI_cmpU
	
270 +   addw  R28, R29, R17	#@addI_reg_reg
274 +   addiw  R14, R14, #4	#@addI_reg_imm
278 +   blt  R14, R28, B12	#@cmpI_loop  P=0.999171 C=4825.000000

27c     B52: #	out( B79 B53 ) &lt;- in( B51 )  Freq: 0.000412092
27c +   ld  R17, [R23, #920]	# ptr, #@loadP
280 +   lwu zr, [R17]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::replace @ bci:28 (line 307) L[0]=R15 L[1]=R12 L[2]=R13 L[3]=R10 L[4]=R8 L[5]=_ L[6]=_ STK[0]=R18 STK[1]=R11
        # OopMap {c_rarg5=Oop off=640/0x280}
284 +   bge  R14, R16, B79	#@cmpI_branch  P=0.000829 C=4825.000000

288     B53: #	out( B11 ) &lt;- in( B52 )  Freq: 0.000411751
288 +   spill R14 -&gt; R17	# spill size = 32
28c +   j  B11	#@branch

290     B54: #	out( B55 ) &lt;- in( B60 ) top-of-loop Freq: 31.4235
290 +   spill R31 -&gt; R30	# spill size = 32
        nop 	# 6 bytes pad for loops and calls

2a0     B55: #	out( B64 B56 ) &lt;- in( B59 B54 ) top-of-loop Freq: 209.994
2a0 +   addiw  R17, R17, #4	#@addI_reg_imm
2a4 +   sb  R30, [R28, #19]	# byte, #@storeB
2a8 +   bge  R17, R7, B64	#@cmpI_loop  P=0.066514 C=14301.000000

2ac     B56: #	out( B61 B57 ) &lt;- in( B65 B55 ) Loop( B56-B55 inner main of N313 strip mined) Freq: 209.994
2ac +   addw  R28, R17, zr	#@convI2L_reg_reg
2b0 +   add R29, R15, R28	# ptr, #@addP_reg_reg
2b4 +   lb  R30, [R29, #16]	# byte, #@loadB
2b8 +   spill [sp, #24] -&gt; R13	# spill size = 64
2bc +   add R28, R13, R28	# ptr, #@addP_reg_reg
2c0 +   beq  R30, R11, B61	#@cmpI_branch  P=0.149640 C=14301.000000

2c4     B57: #	out( B62 B58 ) &lt;- in( B56 B61 )  Freq: 209.994
2c4 +   sb  R30, [R28, #16]	# byte, #@storeB
2c8 +   lb  R13, [R29, #17]	# byte, #@loadB
2cc +   beq  R13, R11, B62	#@cmpI_branch  P=0.149640 C=14301.000000

2d0     B58: #	out( B63 B59 ) &lt;- in( B57 B62 )  Freq: 209.994
2d0 +   sb  R13, [R28, #17]	# byte, #@storeB
2d4 +   lb  R30, [R29, #18]	# byte, #@loadB
2d8 +   beq  R30, R11, B63	#@cmpI_branch  P=0.149640 C=14301.000000

2dc     B59: #	out( B55 B60 ) &lt;- in( B58 B63 )  Freq: 209.994
2dc +   sb  R30, [R28, #18]	# byte, #@storeB
2e0 +   lb  R30, [R29, #19]	# byte, #@loadB
2e4 +   bne  R30, R11, B55	#@cmpI_branch  P=0.850360 C=14301.000000

2e8     B60: #	out( B54 ) &lt;- in( B59 )  Freq: 31.4235
2e8 +   j  B54	#@branch

2ec     B61: #	out( B57 ) &lt;- in( B56 )  Freq: 31.4235
2ec +   spill R31 -&gt; R30	# spill size = 32
2f0 +   j  B57	#@branch

2f4     B62: #	out( B58 ) &lt;- in( B57 )  Freq: 31.4235
2f4 +   spill R31 -&gt; R13	# spill size = 32
2f8 +   j  B58	#@branch

2fc     B63: #	out( B59 ) &lt;- in( B58 )  Freq: 31.4235
2fc +   spill R31 -&gt; R30	# spill size = 32
300 +   j  B59	#@branch

304     B64: #	out( B67 B65 ) &lt;- in( B55 )  Freq: 13.9676
304 +   ld  R13, [R23, #920]	# ptr, #@loadP
308 +   lwu zr, [R13]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::replace @ bci:113 (line 321) L[0]=R15 L[1]=R12 L[2]=R14 L[3]=R10 L[4]=R17 L[5]=sp + #24 L[6]=_
        # OopMap {c_rarg5=Oop [24]=Oop off=776/0x308}
30c +   bge  R17, R16, B67	#@cmpI_branch  P=0.066514 C=14301.000000

310     B65: #	out( B56 ) &lt;- in( B48 B64 ) Loop( B65-B64 ) Freq: 13.9676
310 +   subw  R7, R10, R17	#@subI_reg_reg
314 +   addiw  R28, R7, #-3	#@addI_reg_imm
318 +   li R7, #0	# int, #@loadConI
31c     CMove R28, (R16 lt R17), R28, R7	#@cmovI_cmpI
	
324 +   li R7, #4000	# int, #@loadConI
32c +   li R29, #4000	# int, #@loadConI
334     CMove R28, (R28 gtu R29), R28, R7	#@cmovI_cmpU
	
33c +   addw  R7, R28, R17	#@addI_reg_reg
340 +   j  B56	#@branch

344     B66: #	out( B67 ) &lt;- in( B44 )  Freq: 9.4139e-07
344 +   spill R29 -&gt; R17	# spill size = 32

348     B67: #	out( B72 B68 ) &lt;- in( B66 B64 )  Freq: 0.929049
348 +   bge  R17, R10, B72	#@cmpI_branch  P=0.500000 C=-1.000000

34c     B68: #	out( B102 B69 ) &lt;- in( B67 )  Freq: 0.464525
34c +   # castII of R17, #@castII
34c     bgeu  R17, R10, B102	#@cmpU_branch  P=0.000001 C=-1.000000

350     B69: #	out( B103 B70 ) &lt;- in( B68 )  Freq: 0.464524
350 +   spill R17 -&gt; R7	# spill size = 32
354 +   # castII of R7, #@castII
354     bgeu  R7, R10, B103	#@cmpU_branch  P=0.000001 C=-1.000000

358     B70: #	out( B77 B71 ) &lt;- in( B69 B71 ) Loop( B70-B71 inner post of N776) Freq: 0.929047
358 +   addw  R7, R17, zr	#@convI2L_reg_reg
35c +   add R28, R15, R7	# ptr, #@addP_reg_reg
360 +   lb  R29, [R28, #16]	# byte, #@loadB
364 +   spill [sp, #24] -&gt; R28	# spill size = 64
368 +   add R7, R28, R7	# ptr, #@addP_reg_reg
36c +   beq  R29, R11, B77	#@cmpI_branch  P=0.149640 C=14301.000000

370     B71: #	out( B70 B72 ) &lt;- in( B70 B77 )  Freq: 0.929047
370 +   addiw  R17, R17, #1	#@addI_reg_imm
374 +   sb  R29, [R7, #16]	# byte, #@storeB
378 +   blt  R17, R10, B70	#@cmpI_loop  P=0.500000 C=14301.000000

37c     B72: #	out( B88 B73 ) &lt;- in( B71 B67 B36 )  Freq: 0.995247
37c +   ld  R10, [R23, #288]	# ptr, #@loadP
380 +   ld  R7, [R23, #304]	# ptr, #@loadP
384 +   addi  R28, R10, #24	# ptr, #@addP_reg_imm
388 +   bgeu  R28, R7, B88	#@cmpP_branch  P=0.000100 C=-1.000000

38c     B73: #	out( B74 ) &lt;- in( B72 )  Freq: 0.995148
38c +   li R7, #1	# long, #@loadConL
390 +   sd  R28, [R23, #288]	# ptr, #@storeP
394 +   sd  R7, [R10]	# long, #@storeL
398 +   mv  R7, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
3a8 +   sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
3ac +   sw  zr, [R10, #12]	# int, #@storeimmI0
3b0 +   sd  zr, [R10, #16]	# long, #@storeimmL0

3b4     B74: #	out( B75 ) &lt;- in( B89 B73 )  Freq: 0.995247
3b4     spill [sp, #24] -&gt; R7	# spill size = 64
3b8 +   encode_heap_oop  R28, R7	#@encodeHeapOop
3bc     
3bc +   # checkcastPP of R10, #@checkCastPP
3bc     sw  R28, [R10, #20]	# compressed ptr, #@storeN ! Field: java/lang/String.value (constant)
3c0 +   #@membar_release
	fence iorw ow
3c4 +   #@membar_release
	fence iorw ow

3c4     B75: #	out( N1 ) &lt;- in( B74 B85 )  Freq: 0.999984
3c4     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
3dc +   ret	// return register, #@Ret

3e0     B76: #	out( B42 ) &lt;- in( B41 )  Freq: 0.278047
3e0 +   spill R31 -&gt; R30	# spill size = 32
3e4 +   j  B42	#@branch

3e8     B77: #	out( B71 ) &lt;- in( B70 )  Freq: 0.139023
3e8 +   spill R31 -&gt; R29	# spill size = 32
3ec +   j  B71	#@branch

3f0     B78: #	out( B79 ) &lt;- in( B7 )  Freq: 7.98441e-07
3f0 +   li R14, #1	# int, #@loadConI

3f4     B79: #	out( B85 B80 ) &lt;- in( B78 B52 )  Freq: 1.14008e-06
3f4 +   bge  R14, R10, B85	#@cmpI_branch  P=0.500000 C=-1.000000

3f8     B80: #	out( B106 B81 ) &lt;- in( B79 )  Freq: 5.70041e-07
3f8 +   # castII of R14, #@castII
3f8     bgeu  R14, R10, B106	#@cmpU_branch  P=0.000001 C=-1.000000

3fc     B81: #	out( B107 B82 ) &lt;- in( B80 )  Freq: 5.7004e-07
3fc +   spill R14 -&gt; R29	# spill size = 32
400 +   # castII of R29, #@castII
400     bgeu  R29, R10, B107	#@cmpU_branch  P=0.000001 C=-1.000000

404     B82: #	out( B84 B83 ) &lt;- in( B81 B84 ) Loop( B82-B84 inner post of N754) Freq: 9.41152e-07
404 +   addw  R28, R14, zr	#@convI2L_reg_reg
408 +   add R28, R15, R28	# ptr, #@addP_reg_reg
40c +   lb  R28, [R28, #16]	# byte, #@loadB
410 +   bne  R28, R11, B84	#@cmpI_branch  P=0.788633 C=4821.000000

414     B83: #	out( B18 ) &lt;- in( B82 )  Freq: 1.98928e-07
414 +   spill R14 -&gt; R8	# spill size = 32
418 +   j  B18	#@branch

41c     B84: #	out( B82 B85 ) &lt;- in( B82 )  Freq: 7.42223e-07
41c +   addiw  R14, R14, #1	#@addI_reg_imm
420 +   blt  R14, R10, B82	#@cmpI_loop  P=0.500000 C=4825.000000

424     B85: #	out( B75 ) &lt;- in( B79 B18 B3 B84 )  Freq: 0.00473676
424 +   mv  R10, NULL	# NULL ptr, #@loadConP0
428 +   j  B75	#@branch

42c     B86: #	out( B109 B87 ) &lt;- in( B20 B21 )  Freq: 0.000100551
42c +   spill R11 -&gt; [sp, #24]	# spill size = 32
430 +   spill R12 -&gt; [sp, #0]	# spill size = 32
434 +   spill R7 -&gt; [sp, #32]	# spill size = 32
438 +   spill R16 -&gt; [sp, #28]	# spill size = 32
43c +   spill R9 -&gt; [sp, #20]	# spill size = 32
440 +   spill R10 -&gt; [sp, #16]	# spill size = 32
444 +   spill R13 -&gt; [sp, #4]	# spill size = 32
448 +   spill R15 -&gt; [sp, #8]	# spill size = 64
44c +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
464     spill R10 -&gt; R12	# spill size = 32
468     CALL,static 0x000000401390d640	#@CallStaticJavaDirect wrapper for: _new_array_Java
        # jdk.internal.misc.Unsafe::allocateUninitializedArray @ bci:51 (line 1375) L[0]=_ L[1]=_ L[2]=_
        # java.lang.StringConcatHelper::newArray @ bci:33 (line 497) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.lang.StringLatin1::replace @ bci:49 (line 313) L[0]=sp + #8 L[1]=sp + #0 L[2]=sp + #4 L[3]=sp + #16 L[4]=R8 L[5]=_ L[6]=_
        # OopMap {[8]=Oop off=1132/0x46c}

46c     B87: #	out( B23 ) &lt;- in( B86 )  Freq: 0.000100549
        # Block is sole successor of call
46c +   spill R10 -&gt; R7	# spill size = 64
470 +   spill R7 -&gt; R28	# spill size = 64
474 +   spill [sp, #0] -&gt; R12	# spill size = 32
478 +   spill [sp, #8] -&gt; R15	# spill size = 64
47c +   spill [sp, #4] -&gt; R14	# spill size = 32
480 +   spill [sp, #16] -&gt; R10	# spill size = 32
484 +   spill [sp, #20] -&gt; R9	# spill size = 32
488 +   spill [sp, #24] -&gt; R11	# spill size = 32
48c +   spill [sp, #28] -&gt; R16	# spill size = 32
490 +   spill [sp, #32] -&gt; R7	# spill size = 32
494 +   spill R28 -&gt; R30	# spill size = 64
498 +   j  B23	#@branch

49c     B88: #	out( B110 B89 ) &lt;- in( B72 )  Freq: 9.95412e-05
49c +   mv  R11, precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# ptr, #@loadConP
4b4     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.lang.StringLatin1::replace @ bci:116 (line 322) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=sp + #24 L[6]=_
        # OopMap {[24]=Oop off=1208/0x4b8}

4b8     B89: #	out( B74 ) &lt;- in( B88 )  Freq: 9.95392e-05
        # Block is sole successor of call
4b8 +   j  B74	#@branch

4bc     B90: #	out( N1 ) &lt;- in( B4 )  Freq: 1.01244e-06
4bc +   li R11, #-138	# int, #@loadConI
4c0     spill R7 -&gt; R8	# spill size = 64
4c4 +   spill R12 -&gt; [sp, #0]	# spill size = 32
4c8 +   spill R13 -&gt; [sp, #4]	# spill size = 32
4cc +   spill R10 -&gt; [sp, #12]	# spill size = 32
4d0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::replace @ bci:19 (line 306) L[0]=R8 L[1]=sp + #0 L[2]=sp + #4 L[3]=sp + #12 L[4]=#0 L[5]=_ L[6]=_ STK[0]=#0 STK[1]=sp + #12
        # OopMap {fp=Oop off=1236/0x4d4}
4d4     #@ShouldNotReachHere

4e0     B91: #	out( N1 ) &lt;- in( B39 B37 B38 )  Freq: 2.82418e-06
4e0 +   li R11, #-138	# int, #@loadConI
4e4     spill R15 -&gt; [sp, #0]	# spill size = 64
4e8 +   spill R12 -&gt; [sp, #8]	# spill size = 32
4ec +   spill R14 -&gt; [sp, #12]	# spill size = 32
4f0 +   spill R10 -&gt; [sp, #32]	# spill size = 32
4f4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::replace @ bci:82 (line 317) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #12 L[3]=sp + #32 L[4]=R8 L[5]=sp + #24 L[6]=_ STK[0]=R8 STK[1]=sp + #32
        # OopMap {[0]=Oop [24]=Oop off=1272/0x4f8}
4f8     #@ShouldNotReachHere

504     B92: #	out( N1 ) &lt;- in( B45 )  Freq: 9.41389e-07
504     #@ShouldNotReachHere

510     B93: #	out( N1 ) &lt;- in( B46 )  Freq: 9.41388e-07
510     #@ShouldNotReachHere

51c     B94: #	out( N1 ) &lt;- in( B47 )  Freq: 9.41387e-07
51c     #@ShouldNotReachHere

528     B95: #	out( N1 ) &lt;- in( B24 B25 )  Freq: 1.57631e-06
528 +   li R11, #-138	# int, #@loadConI
52c     spill R15 -&gt; [sp, #0]	# spill size = 64
530 +   spill R12 -&gt; [sp, #8]	# spill size = 32
534 +   spill R14 -&gt; [sp, #12]	# spill size = 32
538 +   spill R10 -&gt; [sp, #16]	# spill size = 32
53c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::replace @ bci:61 (line 314) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #12 L[3]=sp + #16 L[4]=R8 L[5]=sp + #24 L[6]=#0 STK[0]=#0 STK[1]=R8
        # OopMap {[0]=Oop [24]=Oop off=1344/0x540}
540     #@ShouldNotReachHere

54c     B96: #	out( N1 ) &lt;- in( B8 )  Freq: 7.87976e-07
54c     #@ShouldNotReachHere

558     B97: #	out( N1 ) &lt;- in( B9 )  Freq: 7.87976e-07
558     #@ShouldNotReachHere

564     B98: #	out( N1 ) &lt;- in( B27 )  Freq: 7.82954e-07
564     #@ShouldNotReachHere

570     B99: #	out( N1 ) &lt;- in( B28 )  Freq: 7.82953e-07
570     #@ShouldNotReachHere

57c     B100: #	out( N1 ) &lt;- in( B1 )  Freq: 5e-07
57c +   li R11, #-187	# int, #@loadConI
580     spill R7 -&gt; R8	# spill size = 64
584 +   spill R12 -&gt; [sp, #0]	# spill size = 32
588 +   spill R13 -&gt; [sp, #4]	# spill size = 32
58c +   spill R28 -&gt; [sp, #8]	# spill size = 32
590     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::canEncode @ bci:4 (line 54) L[0]=_ STK[0]=sp + #8
        # java.lang.StringLatin1::replace @ bci:1 (line 303) L[0]=R8 L[1]=sp + #0 L[2]=sp + #4 L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # OopMap {fp=Oop off=1428/0x594}
594     #@ShouldNotReachHere

5a0     B101: #	out( N1 ) &lt;- in( B19 )  Freq: 4.9763e-07
5a0 +   li R11, #-187	# int, #@loadConI
5a4     spill R15 -&gt; [sp, #0]	# spill size = 64
5a8 +   spill R12 -&gt; [sp, #8]	# spill size = 32
5ac +   spill R13 -&gt; [sp, #12]	# spill size = 32
5b0 +   spill R10 -&gt; [sp, #16]	# spill size = 32
5b4 +   spill R29 -&gt; [sp, #20]	# spill size = 32
5b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::canEncode @ bci:4 (line 54) L[0]=_ STK[0]=sp + #20
        # java.lang.StringLatin1::replace @ bci:41 (line 312) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #12 L[3]=sp + #16 L[4]=R8 L[5]=_ L[6]=_
        # OopMap {[0]=Oop off=1468/0x5bc}
5bc     #@ShouldNotReachHere

5c8     B102: #	out( N1 ) &lt;- in( B68 )  Freq: 4.70693e-07
5c8     #@ShouldNotReachHere

5d4     B103: #	out( N1 ) &lt;- in( B69 )  Freq: 4.70693e-07
5d4     #@ShouldNotReachHere

5e0     B104: #	out( N1 ) &lt;- in( B33 )  Freq: 3.96675e-07
5e0     #@ShouldNotReachHere

5ec     B105: #	out( N1 ) &lt;- in( B34 )  Freq: 3.96675e-07
5ec     #@ShouldNotReachHere

5f8     B106: #	out( N1 ) &lt;- in( B80 )  Freq: 5.77611e-13
5f8     #@ShouldNotReachHere

604     B107: #	out( N1 ) &lt;- in( B81 )  Freq: 5.7761e-13
604     #@ShouldNotReachHere

610     B108: #	out( N1 ) &lt;- in( B2 )  Freq: 1.01328e-06
610 +   li R11, #-10	# int, #@loadConI
614     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::replace @ bci:8 (line 304) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=#NULL
        # OopMap {off=1560/0x618}
618     #@ShouldNotReachHere

624     B109: #	out( B111 ) &lt;- in( B86 )  Freq: 1.00551e-09
624      -- 	// exception oop; no code emitted, #@CreateException
624 +   spill R10 -&gt; R11	# spill size = 64
628 +   j  B111	#@branch

62c     B110: #	out( B111 ) &lt;- in( B88 )  Freq: 9.95412e-10
62c      -- 	// exception oop; no code emitted, #@CreateException
62c +   spill R10 -&gt; R11	# spill size = 64

630     B111: #	out( N1 ) &lt;- in( B109 B110 )  Freq: 2.00092e-09
630     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
63c +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='304'>
----------------------- MetaData before Compile_id = 304 ------------------------
{method}
 - this oop:          0x00000040962b74d8
 - method holder:     &apos;sun/nio/fs/UnixPath&apos;
 - constants:         0x00000040962b5440 constant pool [472] {0x00000040962b5440} for &apos;sun/nio/fs/UnixPath&apos; cache=0x00000040962ba1a0
 - access:            0xc1000002  private 
 - name:              &apos;hasDotOrDotDot&apos;
 - signature:         &apos;()Z&apos;
 - max stack:         3
 - max locals:        4
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c508200
 - code size:         69
 - code start:        0x00000040962b7450
 - code end (excl):   0x00000040962b7495
 - method data:       0x0000004096487860
 - checked ex length: 0
 - linenumber start:  0x00000040962b7495
 - localvar length:   4
 - localvar start:    0x00000040962b74a6
 - compiled code: nmethod   7282  180       3       sun.nio.fs.UnixPath::hasDotOrDotDot (69 bytes)

------------------------ OptoAssembly for Compile_id = 304 -----------------------
#
#  bool ( sun/nio/fs/UnixPath:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixPath:NotNull *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N514: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B52 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     spill R11 -&gt; R8	# spill size = 64
040     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getNameCount @ bci:1 (line 295) L[0]=R8
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:1 (line 227) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop off=68/0x44}

044     B2: #	out( B49 B3 ) &lt;- in( B1 )  Freq: 0.99998
        # Block is sole successor of call
044 +   spill R8 -&gt; R21	# spill size = 64
048 +   lwu  R7, [R21, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
04c +   #@membar_acquire
	fence ir iorw
050 +   decode_heap_oop  R7, R7	#@decodeHeapOop
054     lwu  R28, [R7, #12]	# range, #@loadRange
058     NullCheck R7

058     B3: #	out( B31 B4 ) &lt;- in( B2 )  Freq: 0.999979
058 +   bleu  R28, zr, B31	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.092012 C=22247.000000

05c     B4: #	out( B5 ) &lt;- in( B3 )  Freq: 0.907968
05c +   li R29, #0	# int, #@loadConI
060 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
060     li R20, #0	# int, #@loadConI
064     spill R29 -&gt; [sp, #28]	# spill size = 32
        nop 	# 4 bytes pad for loops and calls

070     B5: #	out( B53 B6 ) &lt;- in( B4 B26 ) Loop( B5-B26 inner ) Freq: 9.86571
070 +   spill R20 -&gt; [sp, #0]	# spill size = 32
074 +   spill R28 -&gt; [sp, #8]	# spill size = 32
078 +   spill R21 -&gt; R8	# spill size = 64
07c +   spill R21 -&gt; R11	# spill size = 64
080     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getName @ bci:1 (line 301) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=R8 L[1]=sp + #8 L[2]=sp + #0 L[3]=_
        # OopMap {fp=Oop off=132/0x84}

084     B6: #	out( B44 B7 ) &lt;- in( B5 )  Freq: 9.86551
        # Block is sole successor of call
084 +   spill R8 -&gt; R21	# spill size = 64
088 +   lwu  R28, [R21, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
08c +   #@membar_acquire
	fence ir iorw
090 +   decode_heap_oop  R7, R28	#@decodeHeapOop
094     lwu  R8, [R7, #12]	# range, #@loadRange
098     NullCheck R7

098     B7: #	out( B41 B8 ) &lt;- in( B6 )  Freq: 9.8655
098 +   spill [sp, #0] -&gt; R18	# spill size = 32
09c +   bge  R18, R8, B41	#@cmpI_branch  P=0.000000 C=5376.000000

0a0     B8: #	out( B45 B9 ) &lt;- in( B7 )  Freq: 9.8655
0a0 +   lwu  R7, [R21, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0a4 +   #@membar_acquire
	fence ir iorw
0a8 +   decode_heap_oop  R8, R7	#@decodeHeapOop
0ac     lwu  R28, [R8, #12]	# range, #@loadRange
0b0     NullCheck R8

0b0     B9: #	out( B38 B10 ) &lt;- in( B8 )  Freq: 9.86549
0b0 +   bgeu  R18, R28, B38	#@cmpU_branch  P=0.000001 C=-1.000000

0b4     B10: #	out( B46 B11 ) &lt;- in( B9 )  Freq: 9.86548
0b4 +   addw  R28, R18, zr	#@convI2L_reg_reg
0b8 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0bc +   lwu  R7, [R21, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0c0 +   add R29, R8, R28	# ptr, #@addP_reg_reg
0c4 +   lw  R30, [R29, #16]	# int, #@loadI
0c8 +   decode_heap_oop  R7, R7	#@decodeHeapOop
0cc +   #@membar_acquire
	fence ir iorw
0d0     lwu  R29, [R7, #12]	# range, #@loadRange
0d4     NullCheck R7

0d4     B11: #	out( B29 B12 ) &lt;- in( B10 )  Freq: 9.86547
0d4 +   addiw  R7, R29, #-1	#@addI_reg_imm
0d8 +   addiw  R20, R18, #1	#@addI_reg_imm
0dc +   beq  R18, R7, B29	#@cmpI_branch  P=0.084635 C=5376.000000

0e0     B12: #	out( B48 B13 ) &lt;- in( B11 )  Freq: 9.0305
0e0 +   lwu  R29, [R21, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0e4 +   #@membar_acquire
	fence ir iorw
0e8 +   decode_heap_oop  R8, R29	#@decodeHeapOop
0ec     lwu  R29, [R8, #12]	# range, #@loadRange
0f0     NullCheck R8

0f0     B13: #	out( B40 B14 ) &lt;- in( B12 )  Freq: 9.03049
0f0 +   bgeu  R20, R29, B40	#@cmpU_branch  P=0.000001 C=-1.000000

0f4     B14: #	out( B15 ) &lt;- in( B13 )  Freq: 9.03048
0f4 +   add R7, R8, R28	# ptr, #@addP_reg_reg
0f8 +   lw  R7, [R7, #20]	# int, #@loadI
0fc +   subw  R28, R7, R30	#@subI_reg_reg
100 +   addiw  R9, R28, #-1	#@addI_reg_imm

104     B15: #	out( B16 B16 ) &lt;- in( B14 B30 )  Freq: 9.86545
104 +   lwu  R7, [R21, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
108 +   decode_heap_oop  R8, R7	#@decodeHeapOop
10c +   li R28, #1048576	# int, #@loadConI
110 +   addw  R7, R9, zr	#@convI2L_reg_reg
114 +   bleu  R9, R28, B16	#@cmpU_branch  P=0.999999 C=-1.000000

118     B16: #	out( B47 B17 ) &lt;- in( B15 B15 )  Freq: 9.86545
118     lwu  R29, [R8, #12]	# range, #@loadRange
11c     NullCheck R8

11c     B17: #	out( B39 B18 ) &lt;- in( B16 )  Freq: 9.86544
11c +   addw  R28, R9, R30	#@addI_reg_reg
120 +   blt  R30, zr, B39	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

124     B18: #	out( B39 B19 ) &lt;- in( B17 )  Freq: 9.86543
124 +   bltu  R29, R28, B39	#@cmpU_branch  P=0.000001 C=-1.000000

128     B19: #	out( B36 B20 ) &lt;- in( B18 )  Freq: 9.86542
128 +   li R29, #1048576	# int, #@loadConI
12c +   bgtu  R9, R29, B36	#@cmpU_branch  P=0.000001 C=-1.000000

130     B20: #	out( B36 B21 ) &lt;- in( B19 )  Freq: 9.86541
130 +   addi  R7, R7, #23	#@addL_reg_imm
134 +   ld  R19, [R23, #288]	# ptr, #@loadP
138 +   andi  R7, R7, #-8	#@andL_reg_imm
13c +   ld  R28, [R23, #304]	# ptr, #@loadP
140 +   add R7, R19, R7	# ptr, #@addP_reg_reg
144 +   bgeu  R7, R28, B36	#@cmpP_branch  P=0.000100 C=-1.000000

148     B21: #	out( B22 ) &lt;- in( B20 )  Freq: 9.86442
148 +   sd  R7, [R23, #288]	# ptr, #@storeP
14c +   li R7, #1	# long, #@loadConL
150 +   sd  R7, [R19]	# long, #@storeL
154 +   mv  R7, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
164 +   sw  R7, [R19, #8]	# compressed klass ptr, #@storeNKlass
168 +   sw  R9, [R19, #12]	# int, #@storeI

16c     B22: #	out( B24 B23 ) &lt;- in( B37 B21 )  Freq: 9.86542
16c +   addw  R7, R30, zr	#@convI2L_reg_reg
170     
170 +   add R7, R8, R7	# ptr, #@addP_reg_reg
174 +   # checkcastPP of R19, #@checkCastPP
174     addi  R22, R19, #16	# ptr, #@addP_reg_imm
178 +   # castII of R9, #@castII
178     beq  R9, zr, B24	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

17c     B23: #	out( B24 ) &lt;- in( B22 )  Freq: 9.86541
17c +   addw  R12, R9, zr	#@convI2L_reg_reg
180     spill R22 -&gt; R11	# spill size = 64
184 +   addi  R10, R7, #16	# ptr, #@addP_reg_imm
188 +   CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

18c     B24: #	out( B42 B25 ) &lt;- in( B23 B22 )  Freq: 9.86542
18c     
18c     li R7, #1	# int, #@loadConI
190 +   beq  R9, R7, B42	#@cmpI_branch  P=0.000000 C=20200.000000

194     B25: #	out( B32 B26 ) &lt;- in( B24 )  Freq: 9.86541
194 +   li R28, #2	# int, #@loadConI
198 +   beq  R9, R28, B32	#@cmpI_branch  P=0.000347 C=20200.000000

19c     B26: #	out( B5 B27 ) &lt;- in( B34 B33 B25 )  Freq: 9.86538
19c +   spill [sp, #8] -&gt; R28	# spill size = 32
1a0 +   blt  R20, R28, B5	#@cmpI_loop  P=0.907988 C=20200.000000

1a4     B27: #	out( B28 ) &lt;- in( B26 )  Freq: 0.907737
1a4 +   spill [sp, #28] -&gt; R10	# spill size = 32

1a8     B28: #	out( N514 ) &lt;- in( B35 B27 B31 )  Freq: 0.999782
1a8     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
1c0 +   ret	// return register, #@Ret

1c4     B29: #	out( B50 B30 ) &lt;- in( B11 )  Freq: 0.834968
1c4 +   lwu  R7, [R21, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
1c8 +   decode_heap_oop  R7, R7	#@decodeHeapOop
1cc     lwu  R28, [R7, #12]	# range, #@loadRange
1d0     NullCheck R7

1d0     B30: #	out( B15 ) &lt;- in( B29 )  Freq: 0.834967
1d0 +   subw  R9, R28, R30	#@subI_reg_reg
1d4 +   j  B15	#@branch

1d8     B31: #	out( B28 ) &lt;- in( B3 )  Freq: 0.0920105
1d8 +   li R10, #0	# int, #@loadConI
1dc +   j  B28	#@branch

1e0     B32: #	out( B43 B33 ) &lt;- in( B25 )  Freq: 0.00341877
1e0 +   bleu  R9, R7, B43	#@cmpU_branch  P=0.000001 C=-1.000000

1e4     B33: #	out( B26 B34 ) &lt;- in( B32 )  Freq: 0.00341877
1e4 +   lb  R7, [R22]	# byte, #@loadB
1e8 +   li R29, #46	# int, #@loadConI
1ec +   bne  R7, R29, B26	#@cmpI_branch  P=0.900000 C=-1.000000

1f0     B34: #	out( B26 B35 ) &lt;- in( B33 )  Freq: 0.000341877
1f0 +   lb  R7, [R19, #17]	# byte, #@loadB
1f4 +   bne  R7, R29, B26	#@cmpI_branch  P=0.900000 C=-1.000000

1f8     B35: #	out( B28 ) &lt;- in( B34 )  Freq: 3.41877e-05
1f8 +   li R10, #1	# int, #@loadConI
1fc +   j  B28	#@branch

200     B36: #	out( B51 B37 ) &lt;- in( B19 B20 )  Freq: 0.000996701
200 +   spill R9 -&gt; [sp, #24]	# spill size = 32
204 +   spill R20 -&gt; [sp, #20]	# spill size = 32
208 +   spill R30 -&gt; [sp, #16]	# spill size = 32
20c +   spill R18 -&gt; [sp, #12]	# spill size = 32
210 +   spill R21 -&gt; [sp, #0]	# spill size = 64
214 +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
22c     spill R9 -&gt; R12	# spill size = 32
230     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #0 L[1]=_ L[2]=sp + #16 L[3]=sp + #24 L[4]=_
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #12 L[3]=_
        # OopMap {fp=Oop [0]=Oop off=564/0x234}

234     B37: #	out( B22 ) &lt;- in( B36 )  Freq: 0.000996681
        # Block is sole successor of call
234 +   spill [sp, #0] -&gt; R21	# spill size = 64
238 +   spill [sp, #12] -&gt; R18	# spill size = 32
23c +   spill [sp, #16] -&gt; R30	# spill size = 32
240 +   spill [sp, #20] -&gt; R20	# spill size = 32
244 +   spill [sp, #24] -&gt; R9	# spill size = 32
248 +   spill R10 -&gt; R19	# spill size = 64
24c +   j  B22	#@branch

250     B38: #	out( N514 ) &lt;- in( B9 )  Freq: 9.99649e-06
250 +   li R11, #-28	# int, #@loadConI
254     spill R21 -&gt; [sp, #16]	# spill size = 64
258 +   spill R18 -&gt; [sp, #24]	# spill size = 32
25c +   spill R18 -&gt; [sp, #28]	# spill size = 32
260     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:38 (line 307) L[0]=sp + #16 L[1]=sp + #28 L[2]=_ L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #24
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #16 L[1]=sp + #8 L[2]=sp + #24 L[3]=_
        # OopMap {fp=Oop [16]=Oop off=612/0x264}
264     #@ShouldNotReachHere

270     B39: #	out( N514 ) &lt;- in( B17 B18 )  Freq: 1.97309e-05
270 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 32
278 +   li R11, #-52	# int, #@loadConI
27c     spill R18 -&gt; [sp, #4]	# spill size = 32
280 +   spill R21 -&gt; [sp, #8]	# spill size = 64
284 +   spill R30 -&gt; [sp, #16]	# spill size = 32
288 +   spill R9 -&gt; [sp, #24]	# spill size = 32
28c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #8 L[1]=_ L[2]=sp + #16 L[3]=sp + #24 L[4]=_ STK[0]=sp + #24
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #8 L[1]=sp + #0 L[2]=sp + #4 L[3]=_
        # OopMap {[8]=Oop off=656/0x290}
290     #@ShouldNotReachHere

29c     B40: #	out( N514 ) &lt;- in( B13 )  Freq: 9.15041e-06
29c +   li R11, #-28	# int, #@loadConI
2a0     spill R18 -&gt; [sp, #12]	# spill size = 32
2a4 +   spill R21 -&gt; [sp, #16]	# spill size = 64
2a8 +   spill R20 -&gt; [sp, #24]	# spill size = 32
2ac +   spill R30 -&gt; [sp, #28]	# spill size = 32
2b0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:69 (line 312) L[0]=sp + #16 L[1]=_ L[2]=sp + #28 L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #24
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #16 L[1]=sp + #8 L[2]=sp + #12 L[3]=_
        # OopMap {fp=Oop [16]=Oop off=692/0x2b4}
2b4     #@ShouldNotReachHere

2c0     B41: #	out( N514 ) &lt;- in( B7 )  Freq: 4.70424e-06
2c0 +   li R11, #-187	# int, #@loadConI
2c4     spill R21 -&gt; [sp, #16]	# spill size = 64
2c8 +   spill R18 -&gt; [sp, #24]	# spill size = 32
2cc +   spill R18 -&gt; [sp, #28]	# spill size = 32
2d0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:22 (line 304) L[0]=sp + #16 L[1]=sp + #28 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #24 STK[1]=R8
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #16 L[1]=sp + #8 L[2]=sp + #24 L[3]=_
        # OopMap {[16]=Oop off=724/0x2d4}
2d4     #@ShouldNotReachHere

2e0     B42: #	out( N514 ) &lt;- in( B24 )  Freq: 4.7042e-06
2e0 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 32
2e8 +   li R11, #-187	# int, #@loadConI
2ec     spill R21 -&gt; R8	# spill size = 64
2f0 +   spill R18 -&gt; [sp, #4]	# spill size = 32
2f4 +   spill R19 -&gt; [sp, #8]	# spill size = 64
2f8 +   spill R9 -&gt; [sp, #16]	# spill size = 32
2fc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:24 (line 230) L[0]=R8 L[1]=sp + #0 L[2]=sp + #4 L[3]=sp + #8 STK[0]=sp + #16 STK[1]=#1
        # OopMap {fp=Oop [8]=Oop off=768/0x300}
300     #@ShouldNotReachHere

30c     B43: #	out( N514 ) &lt;- in( B32 )  Freq: 3.41877e-09
30c +   li R11, #-28	# int, #@loadConI
310     spill R21 -&gt; R8	# spill size = 64
314 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 32
31c +   spill R18 -&gt; [sp, #4]	# spill size = 32
320 +   spill R19 -&gt; [sp, #16]	# spill size = 64
324     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:45 (line 232) L[0]=R8 L[1]=sp + #0 L[2]=sp + #4 L[3]=sp + #16 STK[0]=sp + #16 STK[1]=#0
        # OopMap {fp=Oop [16]=Oop off=808/0x328}
328     #@ShouldNotReachHere

334     B44: #	out( N514 ) &lt;- in( B6 )  Freq: 9.99652e-06
334 +   li R11, #-10	# int, #@loadConI
338     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:21 (line 304) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=828/0x33c}
33c     #@ShouldNotReachHere

348     B45: #	out( N514 ) &lt;- in( B8 )  Freq: 9.9965e-06
348 +   li R11, #-10	# int, #@loadConI
34c     spill R18 -&gt; R8	# spill size = 32
350     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:38 (line 307) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=852/0x354}
354     #@ShouldNotReachHere

360     B46: #	out( N514 ) &lt;- in( B10 )  Freq: 9.99648e-06
360 +   li R11, #-10	# int, #@loadConI
364     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:45 (line 309) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=872/0x368}
368     #@ShouldNotReachHere

374     B47: #	out( N514 ) &lt;- in( B16 )  Freq: 9.99645e-06
374 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 32
37c +   li R11, #-12	# int, #@loadConI
380     spill R18 -&gt; [sp, #4]	# spill size = 32
384 +   spill R21 -&gt; [sp, #8]	# spill size = 64
388 +   spill R30 -&gt; [sp, #16]	# spill size = 32
38c +   spill R9 -&gt; [sp, #24]	# spill size = 32
390     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #8 L[1]=_ L[2]=sp + #16 L[3]=sp + #24 L[4]=_ STK[0]=sp + #24
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #8 L[1]=sp + #0 L[2]=sp + #4 L[3]=_
        # OopMap {[8]=Oop off=916/0x394}
394     #@ShouldNotReachHere

3a0     B48: #	out( N514 ) &lt;- in( B12 )  Freq: 9.15042e-06
3a0 +   li R11, #-10	# int, #@loadConI
3a4     spill R20 -&gt; R8	# spill size = 32
3a8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:69 (line 312) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=940/0x3ac}
3ac     #@ShouldNotReachHere

3b8     B49: #	out( N514 ) &lt;- in( B2 )  Freq: 1.01326e-06
3b8 +   li R11, #-10	# int, #@loadConI
3bc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getNameCount @ bci:8 (line 296) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:1 (line 227) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=960/0x3c0}
3c0     #@ShouldNotReachHere

3cc     B50: #	out( N514 ) &lt;- in( B29 )  Freq: 8.46056e-07
3cc +   li R11, #-10	# int, #@loadConI
3d0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:55 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=980/0x3d4}
3d4     #@ShouldNotReachHere

3e0     B51: #	out( B54 ) &lt;- in( B36 )  Freq: 9.96701e-09
3e0      -- 	// exception oop; no code emitted, #@CreateException
3e0 +   j  B54	#@branch

3e4     B52: #	out( B55 ) &lt;- in( B1 )  Freq: 1e-05
3e4      -- 	// exception oop; no code emitted, #@CreateException
3e4 +   spill R10 -&gt; R11	# spill size = 64
3e8 +   j  B55	#@branch

3ec     B53: #	out( B54 ) &lt;- in( B5 )  Freq: 9.86571e-05
3ec      -- 	// exception oop; no code emitted, #@CreateException

3ec     B54: #	out( B55 ) &lt;- in( B53 B51 )  Freq: 9.86671e-05
3ec +   spill R10 -&gt; R11	# spill size = 64

3f0     B55: #	out( N514 ) &lt;- in( B52 B54 )  Freq: 0.000108667
3f0     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
3fc +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='305'>
----------------------- MetaData before Compile_id = 305 ------------------------
{method}
 - this oop:          0x00000040961dd1a0
 - method holder:     &apos;java/util/Arrays&apos;
 - constants:         0x00000040961d2728 constant pool [988]/operands[28] {0x00000040961d2728} for &apos;java/util/Arrays&apos; cache=0x00000040961e4d98
 - access:            0x81000009  public static 
 - name:              &apos;copyOfRange&apos;
 - signature:         &apos;([BII)[B&apos;
 - max stack:         7
 - max locals:        5
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x0000004008316ed0: 0xbaa i2c: 0x0000004013945bc0 c2i: 0x0000004013945c0c c2iUV: 0x0000004013945bd8
 - compiled entry     0x000000400c4b9480
 - code size:         64
 - code start:        0x00000040961dd110
 - code end (excl):   0x00000040961dd150
 - method data:       0x000000409652ad40
 - checked ex length: 0
 - linenumber start:  0x00000040961dd150
 - localvar length:   5
 - localvar start:    0x00000040961dd162
 - compiled code: nmethod   7351   43       3       java.util.Arrays::copyOfRange (64 bytes)

------------------------ OptoAssembly for Compile_id = 305 -----------------------
#
#  byte[int:&gt;=0]:exact * ( byte[int:&gt;=0]:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: byte[int:&gt;=0]:exact *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B20 B21 B19 B14 B22 )  Freq: 1

000     B1: #	out( B20 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
01c     subw  R8, R13, R12	#@subI_reg_reg
020     spill R11 -&gt; [sp, #0]	# spill size = 64
024 +   li R28, #1048576	# int, #@loadConI
028     spill R12 -&gt; [sp, #8]	# spill size = 32
02c +   blt  R8, zr, B20	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

030     B2: #	out( B3 B3 ) &lt;- in( B1 )  Freq: 1
030 +   addw  R7, R8, zr	#@convI2L_reg_reg
034 +   bleu  R8, R28, B3	#@cmpU_branch  P=0.999999 C=-1.000000

038     B3: #	out( B21 B4 ) &lt;- in( B2 B2 )  Freq: 1
038     lwu  R29, [R11, #12]	# range, #@loadRange
03c     NullCheck R11

03c     B4: #	out( B19 B5 ) &lt;- in( B3 )  Freq: 0.999999
03c +   subw  R31, R29, R12	#@subI_reg_reg
040     spill R8 -&gt; R13	# spill size = 32
044 +   CMove R13, (R31 lt R8), R13, R31	#@cmovI_cmpI
	
04c +   addw  R30, R12, R13	#@addI_reg_reg
050 +   blt  R12, zr, B19	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

054     B5: #	out( B19 B6 ) &lt;- in( B4 )  Freq: 0.999997
054 +   bltu  R29, R30, B19	#@cmpU_branch  P=0.000001 C=-1.000000

058     B6: #	out( B19 B7 ) &lt;- in( B5 )  Freq: 0.999996
058 +   bltu  R8, R13, B19	#@cmpU_branch  P=0.000001 C=-1.000000

05c     B7: #	out( B19 B8 ) &lt;- in( B6 )  Freq: 0.999995
05c +   blt  R13, zr, B19	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

060     B8: #	out( B16 B9 ) &lt;- in( B7 )  Freq: 0.999994
060 +   addi  R29, R7, #23	#@addL_reg_imm
064 +   bgtu  R8, R28, B16	#@cmpU_branch  P=0.000001 C=-1.000000

068     B9: #	out( B16 B10 ) &lt;- in( B8 )  Freq: 0.999993
068 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
068     ld  R9, [R23, #288]	# ptr, #@loadP
06c +   andi  R7, R29, #-8	#@andL_reg_imm
070 +   ld  R28, [R23, #304]	# ptr, #@loadP
074 +   add R7, R9, R7	# ptr, #@addP_reg_reg
078 +   bgeu  R7, R28, B16	#@cmpP_branch  P=0.000100 C=-1.000000

07c     B10: #	out( B11 ) &lt;- in( B9 )  Freq: 0.999893
07c +   sd  R7, [R23, #288]	# ptr, #@storeP
080 +   li R7, #1	# long, #@loadConL
084 +   sd  R7, [R9]	# long, #@storeL
088 +   mv  R7, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
098 +   sw  R7, [R9, #8]	# compressed klass ptr, #@storeNKlass
09c +   sw  R8, [R9, #12]	# int, #@storeI

0a0     B11: #	out( B18 B12 ) &lt;- in( B17 B10 )  Freq: 0.999994
0a0 +   srli  R7, R29, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
0a4     spill [sp, #8] -&gt; R29	# spill size = 32
0a8 +   addw  R28, R29, zr	#@convI2L_reg_reg
0ac     
0ac +   addw  R12, R13, zr	#@convI2L_reg_reg
0b0     spill [sp, #0] -&gt; R29	# spill size = 64
0b4 +   add R28, R29, R28	# ptr, #@addP_reg_reg
0b8 +   # checkcastPP of R9, #@checkCastPP
0b8     addi  R11, R9, #16	# ptr, #@addP_reg_imm
0bc +   beq  R13, zr, B18	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0c0     B12: #	out( B15 B13 ) &lt;- in( B11 )  Freq: 0.999993
0c0 +   addi  R10, R28, #16	# ptr, #@addP_reg_imm
0c4 +   blt  R13, R8, B15	#@cmpI_branch  P=0.001000 C=-1.000000

0c8     B13: #	out( B14 ) &lt;- in( B12 B15 )  Freq: 0.999993
0c8 +   CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

0cc     B14: #	out( N1 ) &lt;- in( B13 B18 )  Freq: 0.999994
0cc     MEMBAR-store-store	#@membar_storestore
0d0 +   spill R9 -&gt; R10	# spill size = 64
0d4 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0ec +   ret	// return register, #@Ret

0f0     B15: #	out( B13 ) &lt;- in( B12 )  Freq: 0.000999993
0f0 +   addi  R28, R12, #16	#@addL_reg_imm
0f4 +   srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
0f8 +   andi  R28, R28, #-8	#@andL_reg_imm
0fc +   add R28, R9, R28	# ptr, #@addP_reg_reg
100 +   sub  R29, R7, R29	#@subL_reg_reg
104 +   ClearArray R29, R28	#@clearArray_reg_reg
15c     j  B13	#@branch

160     B16: #	out( B22 B17 ) &lt;- in( B8 B9 )  Freq: 0.000101029
160 +   spill R29 -&gt; [sp, #16]	# spill size = 64
164 +   spill R13 -&gt; [sp, #12]	# spill size = 32
168 +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
180     spill R8 -&gt; R12	# spill size = 32
184     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # java.util.Arrays::copyOfRange @ bci:41 (line 3822) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=R8 L[4]=_
        # OopMap {[0]=Oop off=392/0x188}

188     B17: #	out( B11 ) &lt;- in( B16 )  Freq: 0.000101027
        # Block is sole successor of call
188 +   spill R10 -&gt; R9	# spill size = 64
18c +   spill [sp, #12] -&gt; R13	# spill size = 32
190 +   spill [sp, #16] -&gt; R29	# spill size = 64
194 +   j  B11	#@branch

198     B18: #	out( B14 ) &lt;- in( B11 )  Freq: 1.01327e-06
198 +   spill R11 -&gt; R28	# spill size = 64
19c +   addi  R29, R7, #-2	#@addL_reg_imm
1a0     ClearArray R29, R28	#@clearArray_reg_reg
1f8     
1f8 +   j  B14	#@branch

1fc     B19: #	out( N1 ) &lt;- in( B4 B5 B6 B7 )  Freq: 3.99999e-06
1fc +   li R11, #-52	# int, #@loadConI
200     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # java.util.Arrays::copyOfRange @ bci:41 (line 3822) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=R8 L[4]=_ STK[0]=R8
        # OopMap {[0]=Oop off=516/0x204}
204     #@ShouldNotReachHere

210     B20: #	out( N1 ) &lt;- in( B1 )  Freq: 4.76837e-07
210 +   li R11, #-187	# int, #@loadConI
214     spill R13 -&gt; [sp, #12]	# spill size = 32
218     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.Arrays::copyOfRange @ bci:5 (line 3820) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #12 L[3]=R8 L[4]=_ STK[0]=R8
        # OopMap {[0]=Oop off=540/0x21c}
21c     #@ShouldNotReachHere

228     B21: #	out( N1 ) &lt;- in( B3 )  Freq: 1.01328e-06
228 +   li R11, #-10	# int, #@loadConI
22c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.Arrays::copyOfRange @ bci:51 (line 3823) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=_ STK[2]=_ STK[3]=_ STK[4]=#NULL
        # OopMap {off=560/0x230}
230     #@ShouldNotReachHere

23c     B22: #	out( N1 ) &lt;- in( B16 )  Freq: 1.01029e-09
23c      -- 	// exception oop; no code emitted, #@CreateException
23c +   spill R10 -&gt; R11	# spill size = 64
240 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
24c +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='309'>
----------------------- MetaData before Compile_id = 309 ------------------------
{method}
 - this oop:          0x0000004096187598
 - method holder:     &apos;java/lang/StringLatin1&apos;
 - constants:         0x0000004096185338 constant pool [380] {0x0000004096185338} for &apos;java/lang/StringLatin1&apos; cache=0x0000004096189c30
 - access:            0x81000009  public static 
 - name:              &apos;indexOf&apos;
 - signature:         &apos;([BII)I&apos;
 - max stack:         5
 - max locals:        4
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x0000004008316ed0: 0xbaa i2c: 0x0000004013945bc0 c2i: 0x0000004013945c0c c2iUV: 0x0000004013945bd8
 - compiled entry     0x000000400c4d0600
 - code size:         36
 - code start:        0x0000004096187530
 - code end (excl):   0x0000004096187554
 - method data:       0x000000409652a830
 - checked ex length: 0
 - linenumber start:  0x0000004096187554
 - localvar length:   4
 - localvar start:    0x0000004096187566
 - compiled code: nmethod   7459   62       3       java.lang.StringLatin1::indexOf (36 bytes)

------------------------ OptoAssembly for Compile_id = 309 -----------------------
#
#  int ( byte[int:&gt;=0]:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: byte[int:&gt;=0]:exact *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B9 B11 B10 B7 B8 )  Freq: 1

000     B1: #	out( B9 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
01c     spill R13 -&gt; R31	# spill size = 32
020 +   srliw  R7, R12, (#8 &amp; 0x1f)	#@urShiftI_reg_imm
024     spill R12 -&gt; R13	# spill size = 32
028 +   bne  R7, zr, B9	#@cmpI_reg_imm0_branch  P=0.000000 C=8579.000000

02c     B2: #	out( B11 B3 ) &lt;- in( B1 )  Freq: 1
02c     lwu  R8, [R11, #12]	# range, #@loadRange
030     NullCheck R11

030     B3: #	out( B10 B4 ) &lt;- in( B2 )  Freq: 0.999999
030 +   subw  R12, R8, R31	#@subI_reg_reg
034 +   bgeu  R31, R8, B10	#@cmpU_branch  P=0.000000 C=5374.000000

038     B4: #	out( B8 B5 ) &lt;- in( B3 )  Freq: 0.999998
038 +   blt  R12, zr, B8	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

03c     B5: #	out( B7 B6 ) &lt;- in( B4 )  Freq: 0.999997
03c +   addw  R7, R31, zr	#@convI2L_reg_reg
040 +   add R7, R11, R7	# ptr, #@addP_reg_reg
044 +   addi  R11, R7, #16	# ptr, #@addP_reg_imm
048 +   StringUTF16 IndexOf char[] R11,R12,R13 -&gt; R10
2f8 +   blt  R10, zr, B7	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

2fc     B6: #	out( B7 ) &lt;- in( B5 )  Freq: 0.998997
2fc +   addw  R10, R31, R10	#@addI_reg_reg

300     B7: #	out( N1 ) &lt;- in( B6 B5 )  Freq: 0.999997
300     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
318 +   ret	// return register, #@Ret

31c     B8: #	out( N1 ) &lt;- in( B4 )  Freq: 9.99998e-07
31c +   spill R11 -&gt; [sp, #0]	# spill size = 64
320 +   spill R13 -&gt; [sp, #8]	# spill size = 32
324 +   spill R31 -&gt; [sp, #12]	# spill size = 32
328 +   li R11, #-50	# int, #@loadConI
32c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::indexOf @ bci:32 (line 213) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #0 STK[1]=sp + #8 STK[2]=sp + #12 STK[3]=R8
        # OopMap {[0]=Oop off=816/0x330}
330     #@ShouldNotReachHere

33c     B9: #	out( N1 ) &lt;- in( B1 )  Freq: 5e-07
33c +   spill R11 -&gt; R8	# spill size = 64
340 +   spill R12 -&gt; [sp, #0]	# spill size = 32
344 +   spill R31 -&gt; [sp, #4]	# spill size = 32
348 +   spill R7 -&gt; [sp, #8]	# spill size = 32
34c +   li R11, #-187	# int, #@loadConI
350     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::canEncode @ bci:4 (line 54) L[0]=_ STK[0]=sp + #8
        # java.lang.StringLatin1::indexOf @ bci:1 (line 203) L[0]=R8 L[1]=sp + #0 L[2]=sp + #4 L[3]=_
        # OopMap {fp=Oop off=852/0x354}
354     #@ShouldNotReachHere

360     B10: #	out( N1 ) &lt;- in( B3 )  Freq: 4.76836e-07
360 +   spill R11 -&gt; [sp, #0]	# spill size = 64
364 +   spill R13 -&gt; [sp, #8]	# spill size = 32
368 +   spill R31 -&gt; [sp, #16]	# spill size = 32
36c +   li R11, #-27	# int, #@loadConI
370     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::indexOf @ bci:13 (line 207) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #16 L[3]=R8 STK[0]=sp + #16
        # OopMap {[0]=Oop off=884/0x374}
374     #@ShouldNotReachHere

380     B11: #	out( N1 ) &lt;- in( B2 )  Freq: 1.01328e-06
380 +   li R11, #-10	# int, #@loadConI
384     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::indexOf @ bci:10 (line 206) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # OopMap {off=904/0x388}
388     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='310'>
----------------------- MetaData before Compile_id = 310 ------------------------
{method}
 - this oop:          0x00000040965e8a98
 - method holder:     &apos;jdk/internal/module/Checks&apos;
 - constants:         0x00000040965e7798 constant pool [250] {0x00000040965e7798} for &apos;jdk/internal/module/Checks&apos; cache=0x00000040965e8ce8
 - access:            0xc100000a  private static 
 - name:              &apos;isJavaIdentifier&apos;
 - signature:         &apos;(Ljava/lang/String;)Z&apos;
 - max stack:         3
 - max locals:        4
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4fbf00
 - code size:         76
 - code start:        0x00000040965e8a08
 - code end (excl):   0x00000040965e8a54
 - method data:       0x0000004096482320
 - checked ex length: 0
 - linenumber start:  0x00000040965e8a54
 - localvar length:   4
 - localvar start:    0x00000040965e8a66
 - compiled code: nmethod   7719  156       3       jdk.internal.module.Checks::isJavaIdentifier (76 bytes)

------------------------ OptoAssembly for Compile_id = 310 -----------------------
#
#  bool ( java/lang/String:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:exact *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B117 B118 B104 B113 B96 B99 B108 B109 B114 B90 B94 B98 B112 B87 B116 B103 B95 B91 B80 B107 B89 B105 B100 B55 B111 B93 B101 B92 )  Freq: 1

000     B1: #	out( B117 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
01c     spill R11 -&gt; R15	# spill size = 64
020     lwu  R28, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
024     NullCheck R11

024     B2: #	out( B118 B3 ) &lt;- in( B1 )  Freq: 0.999999
024 +   lw  R29, [R11, #12]	# int, #@loadI ! Field: java/lang/String.hash
028 +   li R13, #1272582903	# long, #@loadConL
030 +   li R25, #0	# int, #@loadConI
034 +   decode_heap_oop  R18, R28	#@decodeHeapOop
038 +   li R22, #108	# int, #@loadConI
03c     lwu  R16, [R18, #12]	# range, #@loadRange
040     NullCheck R18

040     B3: #	out( B104 B4 ) &lt;- in( B2 )  Freq: 0.999998
040 +   addi  R19, R18, #16	# ptr, #@addP_reg_imm
044 +   bleu  R16, zr, B104	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=4471.000000

048     B4: #	out( B6 B5 ) &lt;- in( B3 )  Freq: 0.999997
048 +   lbu  R17, [R19]	# byte, #@loadUB
04c +   addw  R7, R17, zr	#@convI2L_reg_reg
050 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
054 +   mv  R24, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1227 address=0x00000040d8324660&gt; *	# ptr, #@loadConP
06c +   lb  R9, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
070 +   mv  R31, stable:narrowoop: java/lang/Object *[int:108]&lt;ciObjArray length=108 type=&lt;ciObjArrayKlass name=[Ljava/lang/Object; loaded=true ident=1174 address=0x00000040d824d7d0&gt; ident=1190 address=0x00000040d828a3e0&gt; *	# ptr, #@loadConP
088 +   add R20, R24, R7	# ptr, #@addP_reg_reg
08c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
08c     beq  R29, zr, B6	#@cmpI_reg_imm0_branch  P=0.525856 C=5376.000000

090     B5: #	out( B21 ) &lt;- in( B4 )  Freq: 0.474143
090 +   sraiw  R30, R29, (#31 &amp; 0x1f)	#@rShiftI_reg_imm
094 +   j  B21	#@branch

098     B6: #	out( B83 B7 ) &lt;- in( B4 )  Freq: 0.525854
098 +   lbu  R7, [R11, #17]	# byte, #@loadUB ! Field: java/lang/String.hashIsZero
09c +   bne  R7, zr, B83	#@cmpI_reg_imm0_branch  P=0.001062 C=2826.000000

0a0     B7: #	out( B113 B8 ) &lt;- in( B6 )  Freq: 0.525296
0a0 +   addiw  R28, R16, #-1	#@addI_reg_imm
0a4 +   bne  R9, zr, B113	#@cmpI_reg_imm0_branch  P=0.000000 C=41603.000000

0a8     B8: #	out( B96 B9 ) &lt;- in( B7 )  Freq: 0.525296
0a8 +   bgeu  R28, R16, B96	#@cmpU_branch  P=0.000001 C=-1.000000

0ac     B9: #	out( B97 B10 ) &lt;- in( B8 )  Freq: 0.525295
0ac +   li R7, #1	# int, #@loadConI
0b0 +   addiw  R10, R16, #-3	#@addI_reg_imm
0b4 +   li R12, #4000	# int, #@loadConI
0bc +   ble  R10, R7, B97	#@cmpI_branch  P=0.000001 C=-1.000000

0c0     B10: #	out( B98 B11 ) &lt;- in( B9 )  Freq: 0.525295
0c0 +   slliw  R7, R17, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0c4 +   li R11, #1	# int, #@loadConI
0c8 +   subw  R7, R7, R17	#@subI_reg_reg
0cc +   li R29, #4	# int, #@loadConI
0d0 +   bleu  R16, R11, B98	#@cmpU_branch  P=0.000001 C=-1.000000

0d4     B11: #	out( B99 B12 ) &lt;- in( B10 )  Freq: 0.525294
0d4 +   bleu  R16, R29, B99	#@cmpU_branch  P=0.000001 C=-1.000000

0d8     B12: #	out( B13 ) &lt;- in( B11 B14 ) Loop( B12-B14 ) Freq: 9.36706
0d8 +   subw  R29, R16, R11	#@subI_reg_reg
0dc +   addiw  R29, R29, #-3	#@addI_reg_imm
0e0     CMove R29, (R10 lt R11), R29, R25	#@cmovI_cmpI
	
0e8 +   CMove R29, (R29 gtu R12), R29, R12	#@cmovI_cmpU
	
0f0 +   addw  R14, R29, R11	#@addI_reg_reg
        nop 	# 6 bytes pad for loops and calls

100     B13: #	out( B13 B14 ) &lt;- in( B12 B13 ) Loop( B13-B13 inner main of N165 strip mined) Freq: 167.034
100 +   addw  R28, R11, zr	#@convI2L_reg_reg
104 +   add R21, R18, R28	# ptr, #@addP_reg_reg
108 +   lbu  R29, [R21, #16]	# byte, #@loadUB
10c +   addw  R7, R7, R29	#@addI_reg_reg
110 +   lbu  R28, [R21, #17]	# byte, #@loadUB
114 +   slliw  R29, R7, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
118 +   subw  R7, R29, R7	#@subI_reg_reg
11c +   addw  R7, R7, R28	#@addI_reg_reg
120 +   lbu  R30, [R21, #18]	# byte, #@loadUB
124 +   slliw  R29, R7, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
128 +   subw  R7, R29, R7	#@subI_reg_reg
12c +   addw  R7, R7, R30	#@addI_reg_reg
130 +   lbu  R29, [R21, #19]	# byte, #@loadUB
134 +   slliw  R28, R7, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
138 +   subw  R7, R28, R7	#@subI_reg_reg
13c +   addw  R29, R7, R29	#@addI_reg_reg
140 +   slliw  R7, R29, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
144 +   addiw  R11, R11, #4	#@addI_reg_imm
148 +   subw  R7, R7, R29	#@subI_reg_reg
14c +   blt  R11, R14, B13	#@cmpI_loop  P=0.943921 C=17236.000000

150     B14: #	out( B12 B15 ) &lt;- in( B13 )  Freq: 9.36706
150 +   ld  R14, [R23, #920]	# ptr, #@loadP
154 +   lwu zr, [R14]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::hashCode @ bci:37 (line 196) L[0]=_ L[1]=R29 L[2]=R18 L[3]=R16 L[4]=R11 L[5]=_
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=R15 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=#Ptr0x00000040d8248c00 L[1]=R15 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=R15 L[1]=_ L[2]=_ L[3]=_
        # OopMap {xmethod=Oop c_rarg5=Oop x18=Oop x19=Derived_oop_x18 esp=Derived_oop_xlocals xlocals=Oop off=340/0x154}
158 +   blt  R11, R10, B12	#@cmpI_branch  P=0.943921 C=17236.000000

15c     B15: #	out( B19 B16 ) &lt;- in( B97 B14 )  Freq: 0.525294
15c +   bge  R11, R16, B19	#@cmpI_branch  P=0.500000 C=-1.000000

160     B16: #	out( B111 B17 ) &lt;- in( B15 )  Freq: 0.262647
160 +   # castII of R11, #@castII
160     bgeu  R11, R16, B111	#@cmpU_branch  P=0.000001 C=-1.000000

164     B17: #	out( B112 B18 ) &lt;- in( B16 )  Freq: 0.262647
164 +   spill R11 -&gt; R28	# spill size = 32
168 +   # castII of R28, #@castII
168     bgeu  R28, R16, B112	#@cmpU_branch  P=0.000001 C=-1.000000

16c     B18: #	out( B18 B19 ) &lt;- in( B17 B18 ) Loop( B18-B18 inner post of N1771) Freq: 0.525293
16c +   addw  R7, R11, zr	#@convI2L_reg_reg
170 +   add R7, R18, R7	# ptr, #@addP_reg_reg
174 +   lbu  R30, [R7, #16]	# byte, #@loadUB
178 +   slliw  R7, R29, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
17c +   subw  R7, R7, R29	#@subI_reg_reg
180 +   addiw  R11, R11, #1	#@addI_reg_imm
184 +   addw  R29, R7, R30	#@addI_reg_reg
188 +   blt  R11, R16, B18	#@cmpI_loop  P=0.500000 C=17236.000000

18c     B19: #	out( B84 B20 ) &lt;- in( B18 B15 )  Freq: 0.525294
18c +   beq  R29, zr, B84	#@cmpI_reg_imm0_branch  P=0.000354 C=2823.000000

190     B20: #	out( B21 ) &lt;- in( B19 )  Freq: 0.525108
190 +   sw  R29, [R15, #12]	# int, #@storeI ! Field: java/lang/String.hash
194 +   sraiw  R30, R29, (#31 &amp; 0x1f)	#@rShiftI_reg_imm

198     B21: #	out( B81 B22 ) &lt;- in( B20 B84 B83 B5 )  Freq: 0.999995
198 +   addw  R7, R29, zr	#@convI2L_reg_reg
19c +   mul  R7, R7, R13	#@mulL
1a0 +   srai  R7, R7, (#37 &amp; 0x3f)	#@rShiftL_reg_imm
1a4 +   subw  R7, l2i(R7), R30	#@subI_reg_reg
1a8 +   mulw  R28, R7, R22	#@mulI
1ac +   subw  R30, R29, R28	#@subI_reg_reg
1b0 +   xori  R7, R30, #108	#@xorI_reg_imm
1b4 +   blt  R7, zr, B81	#@cmpI_reg_imm0_branch  P=0.133348 C=4492.000000

1b8     B22: #	out( B90 B23 ) &lt;- in( B21 B82 )  Freq: 0.999995
1b8 +   addw  R7, R30, zr	#@convI2L_reg_reg
1bc +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
1c0 +   add R7, R31, R7	# ptr, #@addP_reg_reg
1c4 +   bgeu  R30, R22, B90	#@cmpU_branch  P=0.000001 C=-1.000000

1c8     B23: #	out( B35 B24 ) &lt;- in( B22 )  Freq: 0.999994
1c8 +   lw  R11, [R20, #16]	# int, #@loadI
1cc +   lwu  R10, [R7, #16]	# loadN, compressed ptr, #@loadN
1d0 +   li R13, #28672	# int, #@loadConI
1d4 +   andr  R21, R11, R13	#@andI_reg_reg
1d8 +   decode_heap_oop  R13, R10	#@decodeHeapOop
1dc +   sraw  R29, R16, R9	#@rShiftI_reg_reg
1e0 +   li R28, #-1	# int, #@loadConI
1e4 +   li R12, #20480	# int, #@loadConI
1e8 +   beq   R13, zr, B35	#@cmpP_imm0_branch  P=0.318616 C=13182.000000

1ec     B24: #	out( B66 B25 ) &lt;- in( B23 )  Freq: 0.68138
1ec +   lwu  R10, [R13, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
1f0 +   mv  R11, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
200 +   beq  R15, R13, B66	#@cmpP_branch  P=0.000001 C=5338.000000

204     B25: #	out( B116 B26 ) &lt;- in( B24 )  Freq: 0.681379
204 +   bne  R10, R11, B116	#@cmpN_branch  P=0.000000 C=-1.000000

208     B26: #	out( B103 B27 ) &lt;- in( B25 )  Freq: 0.681379
208 +   # checkcastPP of R13, #@checkCastPP
208     lwu  R10, [R13, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
20c +   lb  R14, [R13, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
210 +   decode_heap_oop  R11, R10	#@decodeHeapOop
214 +   bne  R9, R14, B103	#@cmpI_branch  P=0.000000 C=4992.000000

218     B27: #	out( B95 B28 ) &lt;- in( B26 )  Freq: 0.681379
218 +   beq   R18, zr, B95	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

21c     B28: #	out( B91 B29 ) &lt;- in( B27 )  Freq: 0.681378
21c +   beq   R11, zr, B91	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

220     B29: #	out( B31 B30 ) &lt;- in( B28 )  Freq: 0.681377
220 +   lwu  R10, [R11, #12]	# range, #@loadRange
224 +   addiw  R20, R30, #1	#@addI_reg_imm
228 +   bne  R16, R10, B31	#@cmpI_branch  P=0.001000 C=-1.000000

22c     B30: #	out( B79 B31 ) &lt;- in( B29 )  Freq: 0.680696
22c +   addi  R13, R11, #16	# ptr, #@addP_reg_imm
230     spill R16 -&gt; R14	# spill size = 32
234 +   spill R19 -&gt; R11	# spill size = 64
238 +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
2c8 +   bne  R10, zr, B79	#@cmpI_reg_imm0_branch  P=0.000000 C=8982.000000

2cc     B31: #	out( B106 B32 ) &lt;- in( B30 B29 )  Freq: 0.681377
2cc +   beq  R20, R22, B106	#@cmpI_branch  P=0.000000 C=8982.000000

2d0     B32: #	out( B88 B33 ) &lt;- in( B31 )  Freq: 0.681377
2d0 +   bgeu  R20, R22, B88	#@cmpU_branch  P=0.000001 C=-1.000000

2d4     B33: #	out( B56 B34 ) &lt;- in( B32 )  Freq: 0.681376
2d4 +   lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN
2d8 +   decode_heap_oop  R13, R7	#@decodeHeapOop
2dc +   bne   R13, zr, B56	#@cmpP_imm0_branch  P=0.681384 C=8982.000000

2e0     B34: #	out( B35 ) &lt;- in( B33 )  Freq: 0.217097
2e0 +   spill R20 -&gt; R30	# spill size = 32

2e4     B35: #	out( B105 B36 ) &lt;- in( B34 B70 B23 )  Freq: 0.999983
2e4 +   subw  R8, R28, R30	#@subI_reg_reg
2e8 +   bge  R8, zr, B105	#@cmpI_reg_imm0_branch  P=0.000000 C=4356.000000

2ec     B36: #	out( B100 B37 ) &lt;- in( B35 )  Freq: 0.999983
2ec +   bne  R9, zr, B100	#@cmpI_reg_imm0_branch  P=0.000000 C=41603.000000

2f0     B37: #	out( B101 B38 ) &lt;- in( B36 )  Freq: 0.999982
2f0 +   blt  R21, R12, B101	#@cmpI_branch  P=0.000000 C=4351.000000

2f4     B38: #	out( B55 B39 ) &lt;- in( B37 )  Freq: 0.999982
2f4 +   li R28, #1	# int, #@loadConI
2f8 +   ble  R29, R28, B55	#@cmpI_branch  P=0.223149 C=18351.000000

2fc     B39: #	out( B92 B40 ) &lt;- in( B38 )  Freq: 0.776837
2fc +   addw  R7, R29, zr	#@convI2L_reg_reg
300 +   li R30, #1	# int, #@loadConI
304 +   addw  R28, R16, zr	#@convI2L_reg_reg
308 +   addi  R7, R7, #-1	#@addL_reg_imm
30c +   bleu  R16, R30, B92	#@cmpU_branch  P=0.000001 C=-1.000000

310     B40: #	out( B92 B41 ) &lt;- in( B39 )  Freq: 0.776837
310 +   bgeu  R7, R28, B92	#@cmpUL_branch  P=0.000001 C=-1.000000

314     B41: #	out( B110 B42 ) &lt;- in( B40 )  Freq: 0.776836
314 +   lbu  R10, [R18, #17]	# byte, #@loadUB
318 +   addw  R7, R10, zr	#@convI2L_reg_reg
31c +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
320 +   add R7, R24, R7	# ptr, #@addP_reg_reg
324 +   lw  R28, [R7, #16]	# int, #@loadI
328 +   li R12, #12288	# int, #@loadConI
32c +   andr  R28, R28, R12	#@andI_reg_reg
330 +   beq  R28, zr, B110	#@cmpI_reg_imm0_branch  P=0.000000 C=5376.000000

334     B42: #	out( B50 B43 ) &lt;- in( B41 )  Freq: 0.776835
334 +   li R28, #-2147483648	# int, #@loadConI
338 +   addiw  R11, R29, #-1	#@addI_reg_imm
33c     CMove R11, (R29 lt R11), R11, R28	#@cmovI_cmpI
	
344 +   li R31, #2	# int, #@loadConI
348 +   li R7, #2000	# int, #@loadConI
34c +   ble  R11, R31, B50	#@cmpI_branch  P=0.000001 C=-1.000000

350     B43: #	out( B93 B44 ) &lt;- in( B42 )  Freq: 0.776835
350 +   li R28, #3	# int, #@loadConI
354 +   bleu  R16, R31, B93	#@cmpU_branch  P=0.000001 C=-1.000000

358     B44: #	out( B94 B45 ) &lt;- in( B43 )  Freq: 0.776834
358 +   bleu  R16, R28, B94	#@cmpU_branch  P=0.000001 C=-1.000000

35c     B45: #	out( B46 ) &lt;- in( B44 B49 ) Loop( B45-B49 ) Freq: 3.48118
35c +   subw  R30, R11, R31	#@subI_reg_reg
360     CMove R30, (R11 lt R31), R30, R25	#@cmovI_cmpI
	
368 +   CMove R30, (R30 gtu R7), R30, R7	#@cmovI_cmpU
	
370 +   addw  R30, R30, R31	#@addI_reg_reg
        nop 	# 6 bytes pad for loops and calls

380     B46: #	out( B85 B47 ) &lt;- in( B45 B48 ) Loop( B46-B48 inner main of N377 strip mined) Freq: 15.6002
380 +   addw  R28, R31, zr	#@convI2L_reg_reg
384 +   add R28, R18, R28	# ptr, #@addP_reg_reg
388 +   lbu  R17, [R28, #16]	# byte, #@loadUB
38c +   lbu  R10, [R28, #17]	# byte, #@loadUB
390 +   addw  R28, R17, zr	#@convI2L_reg_reg
394 +   addw  R13, R10, zr	#@convI2L_reg_reg
398 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
39c +   slli  R13, R13, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
3a0 +   add R28, R24, R28	# ptr, #@addP_reg_reg
3a4 +   add R13, R24, R13	# ptr, #@addP_reg_reg
3a8 +   lw  R28, [R28, #16]	# int, #@loadI
3ac +   lw  R14, [R13, #16]	# int, #@loadI
3b0 +   andr  R13, R28, R12	#@andI_reg_reg
3b4 +   andr  R28, R14, R12	#@andI_reg_reg
3b8 +   beq  R13, zr, B85	#@cmpI_reg_imm0_branch  P=0.000000 C=5376.000000

3bc     B47: #	out( B86 B48 ) &lt;- in( B46 )  Freq: 15.6002
3bc +   beq  R28, zr, B86	#@cmpI_reg_imm0_branch  P=0.000000 C=5376.000000

3c0     B48: #	out( B46 B49 ) &lt;- in( B47 )  Freq: 15.6002
3c0 +   addiw  R31, R31, #2	#@addI_reg_imm
3c4 +   blt  R31, R30, B46	#@cmpI_loop  P=0.776851 C=14256.000000

3c8     B49: #	out( B45 B50 ) &lt;- in( B48 )  Freq: 3.48117
3c8 +   ld  R28, [R23, #920]	# ptr, #@loadP
3cc +   lwu zr, [R28]	# Safepoint: poll for GC, #@safePoint        # jdk.internal.module.Checks::isJavaIdentifier @ bci:71 (line 185) L[0]=R15 L[1]=_ L[2]=R31 L[3]=_
        # OopMap {c_rarg5=Oop x18=Oop xlocals=Oop off=972/0x3cc}
3d0 +   blt  R31, R11, B45	#@cmpI_branch  P=0.776851 C=14256.000000

3d4     B50: #	out( B55 B51 ) &lt;- in( B42 B49 )  Freq: 0.776819
3d4 +   bge  R31, R29, B55	#@cmpI_branch  P=0.500000 C=-1.000000

3d8     B51: #	out( B108 B52 ) &lt;- in( B50 )  Freq: 0.388409
3d8 +   # castII of R31, #@castII
3d8     bgeu  R31, R16, B108	#@cmpU_branch  P=0.000001 C=-1.000000

3dc     B52: #	out( B109 B53 ) &lt;- in( B51 )  Freq: 0.388409
3dc +   spill R31 -&gt; R28	# spill size = 32
3e0 +   # castII of R28, #@castII
3e0     bgeu  R28, R16, B109	#@cmpU_branch  P=0.000001 C=-1.000000

3e4     B53: #	out( B87 B54 ) &lt;- in( B52 B54 ) Loop( B53-B54 inner post of N1841) Freq: 0.776817
3e4 +   addw  R7, R31, zr	#@convI2L_reg_reg
3e8 +   add R7, R18, R7	# ptr, #@addP_reg_reg
3ec +   lbu  R10, [R7, #16]	# byte, #@loadUB
3f0 +   addw  R7, R10, zr	#@convI2L_reg_reg
3f4 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
3f8 +   add R7, R24, R7	# ptr, #@addP_reg_reg
3fc +   lw  R7, [R7, #16]	# int, #@loadI
400 +   andr  R28, R7, R12	#@andI_reg_reg
404 +   beq  R28, zr, B87	#@cmpI_reg_imm0_branch  P=0.000000 C=5376.000000

408     B54: #	out( B53 B55 ) &lt;- in( B53 )  Freq: 0.776817
408 +   addiw  R31, R31, #1	#@addI_reg_imm
40c +   blt  R31, R29, B53	#@cmpI_loop  P=0.500000 C=14256.000000

410     B55: #	out( N1 ) &lt;- in( B50 B38 B54 )  Freq: 0.999962
410 +   li R10, #1	# int, #@loadConI
414     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
42c +   ret	// return register, #@Ret

430     B56: #	out( B65 B57 ) &lt;- in( B33 )  Freq: 0.464278
430 +   lwu  R7, [R13, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
434 +   mv  R10, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
444 +   beq  R15, R13, B65	#@cmpP_branch  P=0.000001 C=5338.000000

448     B57: #	out( B115 B58 ) &lt;- in( B56 )  Freq: 0.464278
448 +   bne  R7, R10, B115	#@cmpN_branch  P=0.000000 C=-1.000000

44c     B58: #	out( B102 B59 ) &lt;- in( B57 )  Freq: 0.464278
44c +   # checkcastPP of R13, #@checkCastPP
44c     lwu  R10, [R13, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
450 +   lb  R14, [R13, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
454 +   decode_heap_oop  R7, R10	#@decodeHeapOop
458 +   bne  R9, R14, B102	#@cmpI_branch  P=0.000000 C=4992.000000

45c     B59: #	out( B95 B60 ) &lt;- in( B58 )  Freq: 0.464278
45c +   beq   R18, zr, B95	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

460     B60: #	out( B91 B61 ) &lt;- in( B59 )  Freq: 0.464277
460 +   beq   R7, zr, B91	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

464     B61: #	out( B63 B62 ) &lt;- in( B60 )  Freq: 0.464277
464 +   lwu  R10, [R7, #12]	# range, #@loadRange
468 +   addiw  R30, R30, #2	#@addI_reg_imm
46c +   bne  R16, R10, B63	#@cmpI_branch  P=0.001000 C=-1.000000

470     B62: #	out( B78 B63 ) &lt;- in( B61 )  Freq: 0.463813
470 +   spill R16 -&gt; R14	# spill size = 32
474 +   addi  R13, R7, #16	# ptr, #@addP_reg_imm
478     spill R19 -&gt; R11	# spill size = 64
47c +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
50c +   bne  R10, zr, B78	#@cmpI_reg_imm0_branch  P=0.000000 C=8982.000000

510     B63: #	out( B107 B64 ) &lt;- in( B62 B61 )  Freq: 0.464277
510 +   beq  R30, R22, B107	#@cmpI_branch  P=0.000000 C=8982.000000

514     B64: #	out( B69 ) &lt;- in( B63 )  Freq: 0.464276
514 +   ld  R11, [R23, #920]	# ptr, #@loadP
518 +   mv  R7, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
528 +   j  B69	#@branch

52c     B65: #	out( B66 ) &lt;- in( B56 )  Freq: 4.70444e-07
52c +   spill R20 -&gt; R30	# spill size = 32

530     B66: #	out( B80 ) &lt;- in( B24 B65 B71 )  Freq: 2.16693e-06
530 +   li R8, #1	# int, #@loadConI
534 +   j  B80	#@branch
        nop 	# 4 bytes pad for loops and calls

540     B67: #	out( B107 B68 ) &lt;- in( B76 B75 ) top-of-loop Freq: 0.992875
540 +   addiw  R30, R30, #1	#@addI_reg_imm
544 +   beq  R30, R22, B107	#@cmpI_branch  P=0.000000 C=8982.000000

548     B68: #	out( B69 ) &lt;- in( B67 )  Freq: 0.992874
548 +   ld  R11, [R23, #920]	# ptr, #@loadP

54c     B69: #	out( B89 B70 ) &lt;- in( B64 B68 ) Loop( B69-B68 inner partial_peel ) Freq: 1.45715
54c +   lwu zr, [R11]	# Safepoint: poll for GC, #@safePoint        # java.util.ImmutableCollections$SetN::probe @ bci:53 (line 1017) L[0]=#Ptr0x00000040d8248c00 L[1]=R15 L[2]=R30 L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=R15 L[1]=_ L[2]=_ L[3]=_
        # OopMap {xmethod=Oop c_rarg5=Oop x18=Oop x19=Derived_oop_x18 xlocals=Oop off=1356/0x54c}
550 +   addw  R10, R30, zr	#@convI2L_reg_reg
554 +   slli  R10, R10, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
558 +   add R10, R31, R10	# ptr, #@addP_reg_reg
55c +   bgeu  R30, R22, B89	#@cmpU_branch  P=0.000001 C=-1.000000

560     B70: #	out( B35 B71 ) &lt;- in( B69 )  Freq: 1.45715
560 +   lwu  R11, [R10, #16]	# loadN, compressed ptr, #@loadN
564 +   decode_heap_oop  R13, R11	#@decodeHeapOop
568 +   beq   R13, zr, B35	#@cmpP_imm0_branch  P=0.318616 C=8982.000000

56c     B71: #	out( B66 B72 ) &lt;- in( B70 )  Freq: 0.992878
56c +   lwu  R10, [R13, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
570 +   beq  R15, R13, B66	#@cmpP_branch  P=0.000001 C=5338.000000

574     B72: #	out( B116 B73 ) &lt;- in( B71 )  Freq: 0.992877
574 +   bne  R10, R7, B116	#@cmpN_branch  P=0.000000 C=-1.000000

578     B73: #	out( B103 B74 ) &lt;- in( B72 )  Freq: 0.992877
578 +   # checkcastPP of R13, #@checkCastPP
578     lwu  R10, [R13, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
57c +   lb  R14, [R13, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
580 +   decode_heap_oop  R11, R10	#@decodeHeapOop
584 +   bne  R9, R14, B103	#@cmpI_branch  P=0.000000 C=4992.000000

588     B74: #	out( B91 B75 ) &lt;- in( B73 )  Freq: 0.992876
588 +   beq   R11, zr, B91	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

58c     B75: #	out( B67 B76 ) &lt;- in( B74 )  Freq: 0.992875
58c +   lwu  R10, [R11, #12]	# range, #@loadRange
590 +   bne  R16, R10, B67	#@cmpI_branch  P=0.001000 C=-1.000000

594     B76: #	out( B67 B77 ) &lt;- in( B75 )  Freq: 0.991882
594 +   addi  R13, R11, #16	# ptr, #@addP_reg_imm
598     spill R16 -&gt; R14	# spill size = 32
59c +   spill R19 -&gt; R11	# spill size = 64
5a0 +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
630 +   beq  R10, zr, B67	#@cmpI_reg_imm0_branch  P=1.000000 C=8982.000000

634     B77: #	out( B78 ) &lt;- in( B76 )  Freq: 4.72966e-07
634 +   spill R30 -&gt; R20	# spill size = 32

638     B78: #	out( B79 ) &lt;- in( B62 B77 )  Freq: 6.94129e-07
638 +   spill R20 -&gt; R30	# spill size = 32

63c     B79: #	out( B80 ) &lt;- in( B30 B78 )  Freq: 1.01871e-06
63c +   spill R10 -&gt; R8	# spill size = 32

640     B80: #	out( N1 ) &lt;- in( B66 B79 )  Freq: 3.18564e-06
640 +   li R11, #-187	# int, #@loadConI
644     spill R15 -&gt; [sp, #8]	# spill size = 64
648 +   spill R30 -&gt; [sp, #16]	# spill size = 32
64c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:34 (line 1012) L[0]=#Ptr0x00000040d8248c00 L[1]=sp + #8 L[2]=sp + #16 L[3]=_ STK[0]=R8
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[8]=Oop off=1616/0x650}
650     #@ShouldNotReachHere

65c     B81: #	out( B114 B82 ) &lt;- in( B21 )  Freq: 0.133348
65c +   addiw  R10, R30, #108	#@addI_reg_imm
660 +   beq  R29, R28, B114	#@cmpI_branch  P=0.000000 C=599.000000

664     B82: #	out( B22 ) &lt;- in( B81 )  Freq: 0.133347
664 +   spill R10 -&gt; R30	# spill size = 32
668 +   j  B22	#@branch

66c     B83: #	out( B21 ) &lt;- in( B6 )  Freq: 0.000558232
66c +   li R29, #0	# int, #@loadConI
670 +   li R30, #0	# int, #@loadConI
674 +   j  B21	#@branch

678     B84: #	out( B21 ) &lt;- in( B19 )  Freq: 0.000186075
678 +   li R28, #1	# int, #@loadConI
67c +   sb  R28, [R15, #17]	# byte, #@storeB ! Field: java/lang/String.hashIsZero
680 +   li R29, #0	# int, #@loadConI
684 +   li R30, #0	# int, #@loadConI
688 +   j  B21	#@branch

68c     B85: #	out( B87 ) &lt;- in( B46 )  Freq: 7.43878e-06
68c +   spill R13 -&gt; R28	# spill size = 32
690 +   spill R17 -&gt; R10	# spill size = 32
694 +   j  B87	#@branch

698     B86: #	out( B87 ) &lt;- in( B47 )  Freq: 7.43877e-06
698 +   addiw  R31, R31, #1	#@addI_reg_imm

69c     B87: #	out( N1 ) &lt;- in( B53 B110 B85 B86 )  Freq: 1.56184e-05
69c +   li R11, #-187	# int, #@loadConI
6a0     spill R15 -&gt; R8	# spill size = 64
6a4 +   spill R31 -&gt; [sp, #0]	# spill size = 32
6a8 +   spill R10 -&gt; [sp, #4]	# spill size = 32
6ac +   spill R28 -&gt; [sp, #8]	# spill size = 32
6b0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.CharacterDataLatin1::isJavaIdentifierPart @ bci:11 (line 121) L[0]=_ L[1]=_ L[2]=_ STK[0]=sp + #8
        # java.lang.Character::isJavaIdentifierPart @ bci:5 (line 10140) L[0]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:56 (line 182) L[0]=R8 L[1]=_ L[2]=sp + #0 L[3]=sp + #4
        # OopMap {fp=Oop off=1716/0x6b4}
6b4     #@ShouldNotReachHere

6c0     B88: #	out( B89 ) &lt;- in( B32 )  Freq: 6.90425e-07
6c0 +   spill R20 -&gt; R30	# spill size = 32

6c4     B89: #	out( N1 ) &lt;- in( B88 B69 )  Freq: 2.16692e-06
6c4 +   li R11, #-28	# int, #@loadConI
6c8     spill R15 -&gt; [sp, #0]	# spill size = 64
6cc +   spill R30 -&gt; [sp, #12]	# spill size = 32
6d0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:18 (line 1009) L[0]=#Ptr0x00000040d8248c00 L[1]=sp + #0 L[2]=sp + #12 L[3]=_ STK[0]=#Ptr0x00000040d828a3e0 STK[1]=sp + #12
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=1748/0x6d4}
6d4     #@ShouldNotReachHere

6e0     B90: #	out( N1 ) &lt;- in( B22 )  Freq: 1.01327e-06
6e0 +   li R11, #-28	# int, #@loadConI
6e4     spill R15 -&gt; [sp, #0]	# spill size = 64
6e8 +   spill R30 -&gt; [sp, #12]	# spill size = 32
6ec     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:18 (line 1009) L[0]=#Ptr0x00000040d8248c00 L[1]=sp + #0 L[2]=sp + #12 L[3]=_ STK[0]=#Ptr0x00000040d828a3e0 STK[1]=sp + #12
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=1776/0x6f0}
6f0     #@ShouldNotReachHere

6fc     B91: #	out( N1 ) &lt;- in( B28 B74 B60 )  Freq: 2.16693e-06
6fc     #@ShouldNotReachHere

708     B92: #	out( N1 ) &lt;- in( B40 B39 )  Freq: 1.56399e-06
708 +   li R11, #-138	# int, #@loadConI
70c     spill R15 -&gt; R8	# spill size = 64
710 +   spill R29 -&gt; [sp, #0]	# spill size = 32
714     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:46 (line 180) L[0]=R8 L[1]=_ L[2]=#1 L[3]=_ STK[0]=#1 STK[1]=sp + #0
        # OopMap {fp=Oop off=1816/0x718}
718     #@ShouldNotReachHere

724     B93: #	out( N1 ) &lt;- in( B43 )  Freq: 7.76835e-07
724     #@ShouldNotReachHere

730     B94: #	out( N1 ) &lt;- in( B44 )  Freq: 7.76834e-07
730     #@ShouldNotReachHere

73c     B95: #	out( N1 ) &lt;- in( B27 B59 )  Freq: 1.16087e-06
73c     #@ShouldNotReachHere

748     B96: #	out( N1 ) &lt;- in( B8 )  Freq: 5.32271e-07
748 +   li R11, #-138	# int, #@loadConI
74c     spill R15 -&gt; [sp, #0]	# spill size = 64
750 +   spill R15 -&gt; [sp, #8]	# spill size = 64
754 +   spill R18 -&gt; [sp, #16]	# spill size = 64
758 +   spill R16 -&gt; [sp, #28]	# spill size = 32
75c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:13 (line 196) L[0]=_ L[1]=#0 L[2]=sp + #16 L[3]=sp + #28 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=sp + #28
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=sp + #0 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=#Ptr0x00000040d8248c00 L[1]=sp + #8 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=1888/0x760}
760     #@ShouldNotReachHere

76c     B97: #	out( B15 ) &lt;- in( B9 )  Freq: 5.32271e-07
76c +   li R11, #1	# int, #@loadConI
770     spill R17 -&gt; R29	# spill size = 32
774 +   j  B15	#@branch

778     B98: #	out( N1 ) &lt;- in( B10 )  Freq: 5.25295e-07
778     #@ShouldNotReachHere

784     B99: #	out( N1 ) &lt;- in( B11 )  Freq: 5.25294e-07
784     #@ShouldNotReachHere

790     B100: #	out( N1 ) &lt;- in( B36 )  Freq: 4.99991e-07
790 +   li R11, #-187	# int, #@loadConI
794     spill R15 -&gt; [sp, #0]	# spill size = 64
798 +   spill R15 -&gt; [sp, #8]	# spill size = 64
79c +   spill R9 -&gt; [sp, #16]	# spill size = 32
7a0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #16
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=sp + #0 L[1]=#0
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #8 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop [8]=Oop off=1956/0x7a4}
7a4     #@ShouldNotReachHere

7b0     B101: #	out( N1 ) &lt;- in( B37 )  Freq: 4.99991e-07
7b0 +   li R11, #-187	# int, #@loadConI
7b4     spill R15 -&gt; R8	# spill size = 64
7b8 +   spill R17 -&gt; [sp, #0]	# spill size = 32
7bc +   spill R21 -&gt; [sp, #4]	# spill size = 32
7c0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.CharacterDataLatin1::isJavaIdentifierStart @ bci:14 (line 116) L[0]=_ L[1]=_ L[2]=_ STK[0]=sp + #4 STK[1]=#20480
        # java.lang.Character::isJavaIdentifierStart @ bci:5 (line 10070) L[0]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:28 (line 176) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_
        # OopMap {fp=Oop off=1988/0x7c4}
7c4     #@ShouldNotReachHere

7d0     B102: #	out( B103 ) &lt;- in( B58 )  Freq: 2.32139e-07
7d0 +   spill R20 -&gt; R30	# spill size = 32

7d4     B103: #	out( N1 ) &lt;- in( B26 B102 B73 )  Freq: 1.06927e-06
7d4 +   li R11, #-187	# int, #@loadConI
7d8     spill R15 -&gt; [sp, #0]	# spill size = 64
7dc +   spill R15 -&gt; [sp, #8]	# spill size = 64
7e0 +   spill R30 -&gt; [sp, #16]	# spill size = 32
7e4 +   spill R13 -&gt; [sp, #24]	# spill size = 64
7e8 +   spill R9 -&gt; [sp, #20]	# spill size = 32
7ec +   spill R14 -&gt; [sp, #32]	# spill size = 32
7f0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #0 L[1]=_ L[2]=sp + #24 STK[0]=sp + #20 STK[1]=sp + #32
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=#Ptr0x00000040d8248c00 L[1]=sp + #8 L[2]=sp + #16 L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop [8]=Oop [24]=Oop off=2036/0x7f4}
7f4     #@ShouldNotReachHere

800     B104: #	out( N1 ) &lt;- in( B3 )  Freq: 4.76836e-07
800 +   li R11, #-187	# int, #@loadConI
804     spill R15 -&gt; R8	# spill size = 64
808 +   spill R16 -&gt; [sp, #0]	# spill size = 32
80c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isEmpty @ bci:5 (line 1487) L[0]=_ STK[0]=sp + #0
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop off=2064/0x810}
810     #@ShouldNotReachHere

81c     B105: #	out( N1 ) &lt;- in( B35 )  Freq: 4.76829e-07
81c +   li R11, #-187	# int, #@loadConI
820     spill R15 -&gt; [sp, #0]	# spill size = 64
824     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::contains @ bci:17 (line 938) L[0]=_ L[1]=_ STK[0]=R8
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=2088/0x828}
828     #@ShouldNotReachHere

834     B106: #	out( B107 ) &lt;- in( B31 )  Freq: 3.24906e-07
834 +   spill R20 -&gt; R30	# spill size = 32

838     B107: #	out( N1 ) &lt;- in( B106 B63 B67 )  Freq: 1.01973e-06
838 +   li R11, #-187	# int, #@loadConI
83c     spill R15 -&gt; [sp, #0]	# spill size = 64
840 +   spill R30 -&gt; [sp, #12]	# spill size = 32
844     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:48 (line 1014) L[0]=#Ptr0x00000040d8248c00 L[1]=sp + #0 L[2]=sp + #12 L[3]=_ STK[0]=sp + #12 STK[1]=#108
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=2120/0x848}
848     #@ShouldNotReachHere

854     B108: #	out( N1 ) &lt;- in( B51 )  Freq: 3.93567e-07
854     #@ShouldNotReachHere

860     B109: #	out( N1 ) &lt;- in( B52 )  Freq: 3.93567e-07
860     #@ShouldNotReachHere

86c     B110: #	out( B87 ) &lt;- in( B41 )  Freq: 3.70424e-07
86c +   li R31, #1	# int, #@loadConI
870 +   j  B87	#@branch

874     B111: #	out( N1 ) &lt;- in( B16 )  Freq: 2.66135e-07
874     #@ShouldNotReachHere

880     B112: #	out( N1 ) &lt;- in( B17 )  Freq: 2.66135e-07
880     #@ShouldNotReachHere

88c     B113: #	out( N1 ) &lt;- in( B7 )  Freq: 2.62648e-07
88c +   li R11, #-187	# int, #@loadConI
890     spill R15 -&gt; [sp, #0]	# spill size = 64
894 +   spill R15 -&gt; [sp, #8]	# spill size = 64
898 +   spill R9 -&gt; [sp, #16]	# spill size = 32
89c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #16
        # java.lang.String::hashCode @ bci:17 (line 2337) L[0]=sp + #0 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=#Ptr0x00000040d8248c00 L[1]=sp + #8 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop [8]=Oop off=2208/0x8a0}
8a0     #@ShouldNotReachHere

8ac     B114: #	out( N1 ) &lt;- in( B81 )  Freq: 6.35851e-08
8ac +   li R11, #-187	# int, #@loadConI
8b0     spill R15 -&gt; [sp, #0]	# spill size = 64
8b4 +   spill R30 -&gt; [sp, #12]	# spill size = 32
8b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.Math::floorMod @ bci:11 (line 1344) L[0]=_ L[1]=#108 L[2]=sp + #12 STK[0]=sp + #12
        # java.util.ImmutableCollections$SetN::probe @ bci:9 (line 1007) L[0]=#Ptr0x00000040d8248c00 L[1]=sp + #0 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=2236/0x8bc}
8bc     #@ShouldNotReachHere

8c8     B115: #	out( B116 ) &lt;- in( B57 )  Freq: 1e-35
8c8 +   spill R20 -&gt; R30	# spill size = 32

8cc     B116: #	out( N1 ) &lt;- in( B25 B115 B72 )  Freq: 1e-35
8cc +   li R11, #-34	# int, #@loadConI
8d0     spill R15 -&gt; [sp, #0]	# spill size = 64
8d4 +   spill R15 -&gt; [sp, #8]	# spill size = 64
8d8 +   spill R30 -&gt; [sp, #16]	# spill size = 32
8dc +   spill R13 -&gt; [sp, #32]	# spill size = 64
8e0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #0 L[1]=sp + #32 L[2]=_ STK[0]=sp + #32
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=#Ptr0x00000040d8248c00 L[1]=sp + #8 L[2]=sp + #16 L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop [8]=Oop [32]=Oop off=2276/0x8e4}
8e4     #@ShouldNotReachHere

8f0     B117: #	out( N1 ) &lt;- in( B1 )  Freq: 1.01328e-06
8f0 +   li R11, #-10	# int, #@loadConI
8f4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # OopMap {off=2296/0x8f8}
8f8     #@ShouldNotReachHere

904     B118: #	out( N1 ) &lt;- in( B2 )  Freq: 1.01328e-06
904 +   li R11, #-10	# int, #@loadConI
908     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::isEmpty @ bci:4 (line 1487) L[0]=_ STK[0]=#NULL
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=2316/0x90c}
90c     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='311'>
----------------------- MetaData before Compile_id = 311 ------------------------
{method}
 - this oop:          0x00000040961897f0
 - method holder:     &apos;java/lang/StringLatin1&apos;
 - constants:         0x0000004096185338 constant pool [380] {0x0000004096185338} for &apos;java/lang/StringLatin1&apos; cache=0x0000004096189c30
 - access:            0x81000009  public static 
 - name:              &apos;newString&apos;
 - signature:         &apos;([BII)Ljava/lang/String;&apos;
 - max stack:         7
 - max locals:        3
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x0000004008316ed0: 0xbaa i2c: 0x0000004013945bc0 c2i: 0x0000004013945c0c c2iUV: 0x0000004013945bd8
 - compiled entry     0x000000400c4bef80
 - code size:         24
 - code start:        0x00000040961897a8
 - code end (excl):   0x00000040961897c0
 - method data:       0x000000409652be88
 - checked ex length: 0
 - linenumber start:  0x00000040961897c0
 - localvar length:   3
 - localvar start:    0x00000040961897ca
 - compiled code: nmethod   7831   58       3       java.lang.StringLatin1::newString (24 bytes)

------------------------ OptoAssembly for Compile_id = 311 -----------------------
#
#  java/lang/String:exact * ( byte[int:&gt;=0]:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: byte[int:&gt;=0]:exact *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B32 B33 B34 B31 B20 B37 )  Freq: 1

000     B1: #	out( B32 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
01c     spill R12 -&gt; [sp, #8]	# spill size = 32
020 +   spill R11 -&gt; [sp, #0]	# spill size = 64
024 +   spill R13 -&gt; [sp, #12]	# spill size = 32
028 +   beq  R13, zr, B32	#@cmpI_reg_imm0_branch  P=0.000000 C=5374.000000

02c     B2: #	out( B26 B3 ) &lt;- in( B1 )  Freq: 1
02c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
02c     ld  R9, [R23, #288]	# ptr, #@loadP
030 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
030     ld  R7, [R23, #304]	# ptr, #@loadP
034 +   addi  R28, R9, #24	# ptr, #@addP_reg_imm
038 +   bgeu  R28, R7, B26	#@cmpP_branch  P=0.000100 C=-1.000000

03c     B3: #	out( B4 ) &lt;- in( B2 )  Freq: 0.9999
03c +   li R7, #1	# long, #@loadConL
040 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
040     sd  R28, [R23, #288]	# ptr, #@storeP
044 +   sd  R7, [R9]	# long, #@storeL
048 +   mv  R7, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
058 +   sw  R7, [R9, #8]	# compressed klass ptr, #@storeNKlass
05c +   sw  zr, [R9, #12]	# int, #@storeimmI0
060 +   sd  zr, [R9, #16]	# long, #@storeimmL0

064     B4: #	out( B33 B5 ) &lt;- in( B27 B3 )  Freq: 1
064     
064     spill [sp, #12] -&gt; R28	# spill size = 32
068 +   li R7, #1048576	# int, #@loadConI
06c +   # checkcastPP of R9, #@checkCastPP
06c     blt  R28, zr, B33	#@cmpI_reg_imm0_branch  P=0.000000 C=5376.000000

070     B5: #	out( B6 B6 ) &lt;- in( B4 )  Freq: 0.999999
070 +   addw  R28, R28, zr	#@convI2L_reg_reg
074     spill [sp, #12] -&gt; R29	# spill size = 32
078 +   bleu  R29, R7, B6	#@cmpU_branch  P=0.999999 C=-1.000000

07c     B6: #	out( B34 B7 ) &lt;- in( B5 B5 )  Freq: 0.999999
07c +   spill [sp, #0] -&gt; R29	# spill size = 64
080     lwu  R30, [R29, #12]	# range, #@loadRange
084     NullCheck R29

084     B7: #	out( B31 B8 ) &lt;- in( B6 )  Freq: 0.999998
084 +   spill [sp, #8] -&gt; R31	# spill size = 32
088 +   subw  R29, R30, R31	#@subI_reg_reg
08c     spill [sp, #12] -&gt; R8	# spill size = 32
090 +   CMove R8, (R29 lt R8), R8, R29	#@cmovI_cmpI
	
098 +   spill [sp, #8] -&gt; R31	# spill size = 32
09c +   addw  R31, R31, R8	#@addI_reg_reg
0a0     spill [sp, #8] -&gt; R29	# spill size = 32
0a4 +   blt  R29, zr, B31	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0a8     B8: #	out( B31 B9 ) &lt;- in( B7 )  Freq: 0.999997
0a8 +   bltu  R30, R31, B31	#@cmpU_branch  P=0.000001 C=-1.000000

0ac     B9: #	out( B31 B10 ) &lt;- in( B8 )  Freq: 0.999996
0ac +   spill [sp, #12] -&gt; R30	# spill size = 32
0b0 +   bltu  R30, R8, B31	#@cmpU_branch  P=0.000001 C=-1.000000

0b4     B10: #	out( B31 B11 ) &lt;- in( B9 )  Freq: 0.999995
0b4 +   blt  R8, zr, B31	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0b8     B11: #	out( B28 B12 ) &lt;- in( B10 )  Freq: 0.999994
0b8 +   addi  R29, R28, #23	#@addL_reg_imm
0bc +   bgtu  R30, R7, B28	#@cmpU_branch  P=0.000001 C=-1.000000

0c0     B12: #	out( B28 B13 ) &lt;- in( B11 )  Freq: 0.999993
0c0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c0     ld  R18, [R23, #288]	# ptr, #@loadP
0c4 +   andi  R7, R29, #-8	#@andL_reg_imm
0c8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c8     ld  R28, [R23, #304]	# ptr, #@loadP
0cc +   add R7, R18, R7	# ptr, #@addP_reg_reg
0d0 +   bgeu  R7, R28, B28	#@cmpP_branch  P=0.000100 C=-1.000000

0d4     B13: #	out( B14 ) &lt;- in( B12 )  Freq: 0.999893
0d4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0d4     sd  R7, [R23, #288]	# ptr, #@storeP
0d8 +   li R7, #1	# long, #@loadConL
0dc +   sd  R7, [R18]	# long, #@storeL
0e0 +   mv  R7, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0f0 +   sw  R7, [R18, #8]	# compressed klass ptr, #@storeNKlass
0f4 +   sw  R30, [R18, #12]	# int, #@storeI

0f8     B14: #	out( B30 B15 ) &lt;- in( B29 B13 )  Freq: 0.999994
0f8     
0f8 +   srli  R7, R29, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
0fc +   # checkcastPP of R18, #@checkCastPP
0fc     addi  R11, R18, #16	# ptr, #@addP_reg_imm
100 +   encode_heap_oop  R20, R18	#@encodeHeapOop
104 +   beq  R8, zr, B30	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

108     B15: #	out( B21 B16 ) &lt;- in( B14 )  Freq: 0.999993
108 +   spill [sp, #8] -&gt; R28	# spill size = 32
10c +   addw  R28, R28, zr	#@convI2L_reg_reg
110     spill [sp, #0] -&gt; R29	# spill size = 64
114 +   add R28, R29, R28	# ptr, #@addP_reg_reg
118 +   addi  R10, R28, #16	# ptr, #@addP_reg_imm
11c +   addw  R12, R8, zr	#@convI2L_reg_reg
120     spill [sp, #12] -&gt; R29	# spill size = 32
124 +   blt  R8, R29, B21	#@cmpI_branch  P=0.001000 C=-1.000000

128     B16: #	out( B17 ) &lt;- in( B15 B21 )  Freq: 0.999993
128 +   CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

12c     B17: #	out( B18 B18 ) &lt;- in( B16 B30 )  Freq: 0.999994
12c     MEMBAR-store-store	#@membar_storestore
130 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
130     lb  R28, [R23, #56]	# byte, #@loadB
134 +   bne  R28, zr, B18	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

138     B18: #	out( B20 B19 ) &lt;- in( B17 B17 )  Freq: 0.999994
138 +   mv  R7, R9	# ptr -&gt; long, #@castP2X
13c +   mv  R28, R18	# ptr -&gt; long, #@castP2X
140 +   xorr  R28, R28, R7	#@xorL_reg_reg
144 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
148 +   sw  R20, [R9, #20]	# compressed ptr, #@storeN ! Field: java/lang/String.value (constant)
14c +   beq  R28, zr, B20	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

150     B19: #	out( B22 B20 ) &lt;- in( B18 )  Freq: 0.998994
150 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
154 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
160 +   add R10, R28, R7	# ptr, #@addP_reg_reg
164 +   lb  R7, [R10]	# byte, #@loadB
168 +   li R29, #4	# int, #@loadConI
16c +   bne  R7, R29, B22	#@cmpI_branch  P=0.001000 C=-1.000000

170     B20: #	out( N1 ) &lt;- in( B24 B25 B22 B19 B18 )  Freq: 0.999994
170 +   sb zr, [R9, #16]	# byte, #@storeimmB0 ! Field: java/lang/String.coder (constant)
174 +   #@membar_release
	fence iorw ow
178 +   #@membar_release
	fence iorw ow
178 +   spill R9 -&gt; R10	# spill size = 64
17c +   # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
194 +   ret	// return register, #@Ret

198     B21: #	out( B16 ) &lt;- in( B15 )  Freq: 0.000999993
198 +   addi  R28, R12, #16	#@addL_reg_imm
19c +   srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
1a0 +   andi  R28, R28, #-8	#@andL_reg_imm
1a4 +   add R28, R18, R28	# ptr, #@addP_reg_reg
1a8 +   sub  R29, R7, R29	#@subL_reg_reg
1ac +   ClearArray R29, R28	#@clearArray_reg_reg
204     j  B16	#@branch

208     B22: #	out( B20 B23 ) &lt;- in( B19 )  Freq: 0.000998994
208 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
208     ld  R7, [R23, #64]	# int, #@loadL
20c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
20c     ld  R28, [R23, #80]	# ptr, #@loadP
210 +   #@membar_volatile
	fence iorw iorw
214 +   lb  R29, [R10]	# byte, #@loadB
218 +   beq  R29, zr, B20	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

21c     B23: #	out( B25 B24 ) &lt;- in( B22 )  Freq: 0.000499497
21c +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
220 +   bne  R7, zr, B25	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

224     B24: #	out( B20 ) &lt;- in( B23 )  Freq: 0.000249749
224 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
224     spill R23 -&gt; R11	# spill size = 64
228 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
258 +   j  B20	#@branch

25c     B25: #	out( B20 ) &lt;- in( B23 )  Freq: 0.000249749
25c +   add R28, R28, R7	# ptr, #@addP_reg_reg
260 +   addi  R7, R7, #-8	#@addL_reg_imm
264 +   sd  R10, [R28, #-8]	# ptr, #@storeP
268 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
268     sd  R7, [R23, #64]	# long, #@storeL
26c +   j  B20	#@branch

270     B26: #	out( B36 B27 ) &lt;- in( B2 )  Freq: 0.000100017
270 +   mv  R11, precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# ptr, #@loadConP
288     spill R13 -&gt; R8	# spill size = 32
28c     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.lang.StringLatin1::newString @ bci:7 (line 769) L[0]=sp + #0 L[1]=sp + #8 L[2]=R8
        # OopMap {[0]=Oop off=656/0x290}

290     B27: #	out( B4 ) &lt;- in( B26 )  Freq: 0.000100015
        # Block is sole successor of call
290 +   spill R10 -&gt; R9	# spill size = 64
294 +   j  B4	#@branch

298     B28: #	out( B35 B29 ) &lt;- in( B11 B12 )  Freq: 0.000101029
298 +   spill R29 -&gt; [sp, #32]	# spill size = 64
29c +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
2b4     spill R30 -&gt; R12	# spill size = 32
2b8 +   spill R9 -&gt; [sp, #24]	# spill size = 64
2bc +   spill R9 -&gt; [sp, #40]	# spill size = 64
2c0     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # java.util.Arrays::copyOfRange @ bci:41 (line 3822) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=sp + #12 L[4]=_
        # java.lang.StringLatin1::newString @ bci:16 (line 769) L[0]=_ L[1]=_ L[2]=_ STK[0]=sp + #24 STK[1]=sp + #40
        # OopMap {[0]=Oop [24]=Oop [40]=Oop off=708/0x2c4}

2c4     B29: #	out( B14 ) &lt;- in( B28 )  Freq: 0.000101027
        # Block is sole successor of call
2c4 +   spill R10 -&gt; R18	# spill size = 64
2c8 +   spill [sp, #32] -&gt; R29	# spill size = 64
2cc +   spill [sp, #24] -&gt; R9	# spill size = 64
2d0 +   j  B14	#@branch

2d4     B30: #	out( B17 ) &lt;- in( B14 )  Freq: 1.01327e-06
2d4 +   spill R11 -&gt; R28	# spill size = 64
2d8 +   addi  R29, R7, #-2	#@addL_reg_imm
2dc     ClearArray R29, R28	#@clearArray_reg_reg
334     
334 +   j  B17	#@branch

338     B31: #	out( N1 ) &lt;- in( B7 B8 B9 B10 )  Freq: 3.99999e-06
338 +   spill [sp, #0] -&gt; R8	# spill size = 64
33c +   li R11, #-52	# int, #@loadConI
340     spill R29 -&gt; [sp, #0]	# spill size = 32
344 +   spill [sp, #12] -&gt; [sp, #4]	# spill size = 32
34c +   spill R9 -&gt; [sp, #24]	# spill size = 64
350     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # java.util.Arrays::copyOfRange @ bci:41 (line 3822) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=sp + #4 L[4]=_ STK[0]=sp + #4
        # java.lang.StringLatin1::newString @ bci:16 (line 769) L[0]=_ L[1]=_ L[2]=_ STK[0]=sp + #24 STK[1]=sp + #24
        # OopMap {fp=Oop [24]=Oop off=852/0x354}
354     #@ShouldNotReachHere

360     B32: #	out( N1 ) &lt;- in( B1 )  Freq: 4.76837e-07
360 +   spill [sp, #0] -&gt; R8	# spill size = 64
364 +   li R11, #-187	# int, #@loadConI
368     spill R12 -&gt; [sp, #0]	# spill size = 32
36c +   spill R13 -&gt; [sp, #8]	# spill size = 32
370     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::newString @ bci:1 (line 766) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 STK[0]=sp + #12
        # OopMap {fp=Oop off=884/0x374}
374     #@ShouldNotReachHere

380     B33: #	out( N1 ) &lt;- in( B4 )  Freq: 4.76837e-07
380 +   spill [sp, #12] -&gt; R7	# spill size = 32
384 +   spill [sp, #8] -&gt; R28	# spill size = 32
388 +   addw  R8, R28, R7	#@addI_reg_reg
38c +   li R11, #-187	# int, #@loadConI
390     spill R9 -&gt; [sp, #32]	# spill size = 64
394     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.Arrays::copyOfRange @ bci:5 (line 3820) L[0]=sp + #0 L[1]=sp + #8 L[2]=R8 L[3]=sp + #12 L[4]=_ STK[0]=sp + #12
        # java.lang.StringLatin1::newString @ bci:16 (line 769) L[0]=_ L[1]=_ L[2]=_ STK[0]=sp + #32 STK[1]=sp + #32
        # OopMap {[0]=Oop [32]=Oop off=920/0x398}
398     #@ShouldNotReachHere

3a4     B34: #	out( N1 ) &lt;- in( B6 )  Freq: 1.01328e-06
3a4 +   li R11, #-10	# int, #@loadConI
3a8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.Arrays::copyOfRange @ bci:51 (line 3823) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=_ STK[2]=_ STK[3]=_ STK[4]=#NULL
        # java.lang.StringLatin1::newString @ bci:16 (line 769) L[0]=_ L[1]=_ L[2]=_ STK[0]=_ STK[1]=_
        # OopMap {off=940/0x3ac}
3ac     #@ShouldNotReachHere

3b8     B35: #	out( B37 ) &lt;- in( B28 )  Freq: 1.01029e-09
3b8      -- 	// exception oop; no code emitted, #@CreateException
3b8 +   spill R10 -&gt; R11	# spill size = 64
3bc +   j  B37	#@branch

3c0     B36: #	out( B37 ) &lt;- in( B26 )  Freq: 1.00017e-09
3c0      -- 	// exception oop; no code emitted, #@CreateException
3c0 +   spill R10 -&gt; R11	# spill size = 64

3c4     B37: #	out( N1 ) &lt;- in( B36 B35 )  Freq: 2.01046e-09
3c4     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
3d0 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='312'>
----------------------- MetaData before Compile_id = 312 ------------------------
{method}
 - this oop:          0x00000040965e5990
 - method holder:     &apos;java/util/stream/ReferencePipeline$3$1&apos;
 - constants:         0x00000040965e55b8 constant pool [60] {0x00000040965e55b8} for &apos;java/util/stream/ReferencePipeline$3$1&apos; cache=0x00000040965e5a60
 - access:            0x81000001  public 
 - name:              &apos;accept&apos;
 - signature:         &apos;(Ljava/lang/Object;)V&apos;
 - max stack:         4
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      7
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824bb30: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c4fad40
 - code size:         23
 - code start:        0x00000040965e5950
 - code end (excl):   0x00000040965e5967
 - method data:       0x0000004096481f18
 - checked ex length: 0
 - linenumber start:  0x00000040965e5967
 - localvar length:   2
 - localvar start:    0x00000040965e5974
 - compiled code: nmethod   9030  154       3       java.util.stream.ReferencePipeline$3$1::accept (23 bytes)

------------------------ OptoAssembly for Compile_id = 312 -----------------------
#
#  void ( java/util/stream/ReferencePipeline$3$1:NotNull *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/stream/ReferencePipeline$3$1:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 112 --
#r263 sp+108: in_preserve
#r262 sp+104: return address
#r261 sp+100: in_preserve
#r260 sp+96: saved fp register
#r259 sp+92: pad2, stack alignment
#r258 sp+88: pad2, stack alignment
#r257 sp+84: Fixed slot 1
#r256 sp+80: Fixed slot 0
#r283 sp+76: spill
#r282 sp+72: spill
#r281 sp+68: spill
#r280 sp+64: spill
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
0000    N5509: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0000    # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

0020    B1: #	out( B439 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0020    # stack bang size=112
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #112
	
003c    lwu  R7, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$3$1.this$1
0040 +  decode_heap_oop  R7, R7	#@decodeHeapOop
0044    lwu  R28, [R7, #52]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$3.val$mapper
0048    NullCheck R7

0048    B2: #	out( B506 B3 ) &lt;- in( B1 )  Freq: 0.999999
0048 +  lwu  R7, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/Sink$ChainedReference.downstream
004c +  decode_heap_oop  R11, R28	#@decodeHeapOop
0050 +  decode_heap_oop  R8, R7	#@decodeHeapOop
0054    CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.function.Function::apply
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:12 (line 197) L[0]=_ L[1]=_ STK[0]=R8
        # OopMap {fp=Oop off=112/0x70}

0070    B3: #	out( B440 B4 ) &lt;- in( B2 )  Freq: 0.999979
        # Block is sole successor of call
0070 +  spill R10 -&gt; [sp, #0]	# spill size = 64
0074    lwu  R7, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0078    NullCheck R8

0078    B4: #	out( B49 B5 ) &lt;- in( B3 )  Freq: 0.999978
0078 +  mv  R29, narrowklass: precise klass java/util/stream/ReferencePipeline$3$1: 0x00000040d8350040:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0088 +  beq  R7, R29, B49	#@cmpN_branch  P=0.666732 C=-1.000000

008c    B5: #	out( B342 B6 ) &lt;- in( B4 )  Freq: 0.333261
008c +  mv  R29, narrowklass: precise klass java/util/stream/ReferencePipeline$7$1: 0x00000040d8350da0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
009c +  far_bne  R7, R29, B342	#@far_cmpN_branch  P=0.000001 C=-1.000000

00a4    B6: #	out( B443 B7 ) &lt;- in( B5 )  Freq: 0.333261
00a4 +  # checkcastPP of R8, #@checkCastPP
00a4    lwu  R7, [R8, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$7$1.this$1
00a8 +  spill R8 -&gt; R29	# spill size = 64
00ac +  decode_heap_oop  R7, R7	#@decodeHeapOop
00b0    lwu  R28, [R7, #52]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$7.val$mapper
00b4    NullCheck R7

00b4    B7: #	out( B444 B8 ) &lt;- in( B6 )  Freq: 0.33326
00b4 +  decode_heap_oop  R8, R28	#@decodeHeapOop
00b8    lwu  R7, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
00bc    NullCheck R8

00bc    B8: #	out( B343 B9 ) &lt;- in( B7 )  Freq: 0.33326
00bc +  mv  R30, narrowklass: precise klass jdk/internal/module/ModulePath$$Lambda$10+0x000000080001e230: 0x00000040d81f3250:Constant:exact *	# compressed klass ptr, #@loadConNKlass
00cc +  far_bne  R7, R30, B343	#@far_cmpN_branch  P=0.000001 C=-1.000000

00d4    B9: #	out( B445 B10 ) &lt;- in( B8 )  Freq: 0.33326
00d4 +  spill R10 -&gt; R28	# spill size = 64
00d8    lwu  R7, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
00dc    NullCheck R10

00dc    B10: #	out( B428 B11 ) &lt;- in( B9 )  Freq: 0.333259
00dc +  mv  R30, narrowklass: precise klass java/util/Optional: 0x00000040d81f6420:Constant:exact *	# compressed klass ptr, #@loadConNKlass
00ec +  far_bne  R7, R30, B428	#@far_cmpN_branch  P=0.000000 C=-1.000000

00f4    B11: #	out( B254 B12 ) &lt;- in( B10 )  Freq: 0.333259
00f4 +  # checkcastPP of R28, #@checkCastPP
00f4    lwu  R7, [R28, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/Optional.value
00f8 +  decode_heap_oop  R8, R7	#@decodeHeapOop
00fc    spill R7 -&gt; [sp, #8]	# spill size = 32
0100 +  far_beq   R8, zr, B254	#@far_cmpP_imm0_branch  P=0.004467 C=1791.000000

0108    B12: #	out( B304 B13 ) &lt;- in( B11 )  Freq: 0.331771
0108 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0108    ld  R30, [R23, #288]	# ptr, #@loadP
010c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
010c    ld  R7, [R23, #304]	# ptr, #@loadP
0110 +  addi  R28, R30, #24	# ptr, #@addP_reg_imm
0114 +  far_bgeu  R28, R7, B304	#@far_cmpP_branch  P=0.000100 C=-1.000000

011c    B13: #	out( B14 ) &lt;- in( B12 )  Freq: 0.331737
011c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
011c    sd  R28, [R23, #288]	# ptr, #@storeP
0120 +  li R7, #1	# long, #@loadConL
0124 +  mv  R28, narrowklass: precise klass java/util/stream/Streams$StreamBuilderImpl: 0x00000040d8403970:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0134 +  sd  R7, [R30]	# long, #@storeL
0138 +  sw  R28, [R30, #8]	# compressed klass ptr, #@storeNKlass
013c +  sw  zr, [R30, #20]	# int, #@storeimmI0

0140    B14: #	out( B306 B15 ) &lt;- in( B305 B13 )  Freq: 0.331771
0140 +  li R28, #-2	# int, #@loadConI
0144 +  sw  R28, [R30, #12]	# int, #@storeI
0148    spill [sp, #8] -&gt; R7	# spill size = 32
014c +  sw  R7, [R30, #16]	# compressed ptr, #@storeN
0150    
0150 +  MEMBAR-store-store	#@membar_storestore
0154 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0154    ld  R10, [R23, #288]	# ptr, #@loadP
0158 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0158    ld  R7, [R23, #304]	# ptr, #@loadP
015c +  addi  R28, R10, #56	# ptr, #@addP_reg_imm
0160 +  # checkcastPP of R30, #@checkCastPP
0160    far_bgeu  R28, R7, B306	#@far_cmpP_branch  P=0.000100 C=-1.000000

0168    B15: #	out( B16 ) &lt;- in( B14 )  Freq: 0.331737
0168 +  li R7, #1	# long, #@loadConL
016c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
016c    sd  R28, [R23, #288]	# ptr, #@storeP
0170 +  sd  R7, [R10]	# long, #@storeL
0174 +  mv  R7, narrowklass: precise klass java/util/stream/ReferencePipeline$Head: 0x00000040d81f3320:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0184 +  addi  R28, R10, #24	# ptr, #@addP_reg_imm
0188 +  sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
018c    ClearArray #2, R28	#@clearArray_imm_reg
0194 +  sw  zr, [R10, #44]	# int, #@storeimmI0
0198 +  sd  zr, [R10, #48]	# long, #@storeimmL0

019c    B16: #	out( B17 ) &lt;- in( B307 B15 )  Freq: 0.331771
019c +  li R28, #80	# int, #@loadConI
01a0 +  sw  R28, [R10, #12]	# int, #@storeI
01a4 +  li R7, #408021893120	# long, #@loadConL
01ac +  encode_heap_oop  R28, R30	#@encodeHeapOop
01b0 +  sd  R7, [R10, #16]	# long, #@storeL
01b4 +  sw  R28, [R10, #40]	# compressed ptr, #@storeN
01b8    
01b8 +  MEMBAR-store-store	#@membar_storestore
01bc +  # checkcastPP of R10, #@checkCastPP
01bc    encode_heap_oop  R7, R10	#@encodeHeapOop
01c0 +  sw  R7, [R10, #28]	# compressed ptr, #@storeN ! Field: java/util/stream/AbstractPipeline.sourceStage
01c4    spill R10 -&gt; R18	# spill size = 64
01c8 +  #@membar_release
	fence iorw ow
01cc +  # checkcastPP of R18, #@checkCastPP

01cc    B17: #	out( B430 B18 ) &lt;- in( B256 B16 )  Freq: 0.333259
01cc    lwu  R28, [R18, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
01d0 +  mv  R7, narrowklass: precise klass java/util/stream/ReferencePipeline$Head: 0x00000040d81f3320:Constant:exact *	# compressed klass ptr, #@loadConNKlass
01e0 +  far_bne  R28, R7, B430	#@far_cmpN_branch  P=0.000000 C=-1.000000

01e8    B18: #	out( B353 B19 ) &lt;- in( B17 )  Freq: 0.333259
01e8 +  # checkcastPP of R18, #@checkCastPP
01e8    lwu  R28, [R18, #28]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceStage
01ec    spill R18 -&gt; R12	# spill size = 64
01f0 +  lbu  R8, [R29, #16]	# byte, #@loadUB ! Field: java/util/stream/ReferencePipeline$7$1.cancellationRequestedCalled
01f4 +  # checkcastPP of R12, #@checkCastPP
01f4    lwu  R7, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
01f8 +  decode_heap_oop  R28, R28	#@decodeHeapOop
01fc +  mv  R31, narrowklass: precise klass java/util/stream/ReferencePipeline$Head: 0x00000040d81f3320:Constant:exact *	# compressed klass ptr, #@loadConNKlass
020c +  far_bne  R8, zr, B353	#@far_cmpI_reg_imm0_branch  P=0.000000 C=1791.000000

0214    B19: #	out( B446 B20 ) &lt;- in( B18 )  Freq: 0.333259
0214    sb zr, [R28, #26]	# byte, #@storeimmB0 ! Field: java/util/stream/AbstractPipeline.parallel
0218    NullCheck R28

0218    B20: #	out( B432 B21 ) &lt;- in( B19 )  Freq: 0.333259
0218 +  far_bne  R7, R31, B432	#@far_cmpN_branch  P=0.000000 C=-1.000000

0220    B21: #	out( B447 B22 ) &lt;- in( B20 )  Freq: 0.333259
0220 +  # checkcastPP of R12, #@checkCastPP
0220    lwu  R7, [R12, #28]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceStage
0224 +  decode_heap_oop  R31, R7	#@decodeHeapOop
0228    lbu  R13, [R31, #26]	# byte, #@loadUB ! Field: java/util/stream/AbstractPipeline.parallel
022c    NullCheck R31

022c    B22: #	out( B354 B23 ) &lt;- in( B21 )  Freq: 0.333258
022c +  lwu  R28, [R31, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceSpliterator
0230 +  lwu  R7, [R29, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/Sink$ChainedReference.downstream
0234 +  lbu  R10, [R12, #24]	# byte, #@loadUB ! Field: java/util/stream/AbstractPipeline.linkedOrConsumed
0238 +  decode_heap_oop  R19, R28	#@decodeHeapOop
023c +  decode_heap_oop  R30, R7	#@decodeHeapOop
0240 +  far_bne  R13, zr, B354	#@far_cmpI_reg_imm0_branch  P=0.000000 C=1791.000000

0248    B23: #	out( B363 B24 ) &lt;- in( B22 )  Freq: 0.333258
0248 +  far_bne  R12, R31, B363	#@far_cmpP_branch  P=0.000000 C=1791.000000

0250    B24: #	out( B364 B25 ) &lt;- in( B23 )  Freq: 0.333258
0250 +  far_bne  R10, zr, B364	#@far_cmpI_reg_imm0_branch  P=0.000000 C=1791.000000

0258    B25: #	out( B460 B26 ) &lt;- in( B24 )  Freq: 0.333258
0258 +  li R7, #1	# int, #@loadConI
025c +  sb  R7, [R12, #24]	# byte, #@storeB ! Field: java/util/stream/AbstractPipeline.linkedOrConsumed
0260    lwu  R9, [R19, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0264    NullCheck R19

0264    B26: #	out( B263 B27 ) &lt;- in( B25 )  Freq: 0.333258
0264 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0264    lb  R28, [R23, #56]	# byte, #@loadB
0268 +  far_bne  R28, zr, B263	#@far_cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0270    B27: #	out( B251 B28 ) &lt;- in( B355 B265 B263 B26 )  Freq: 0.333258
0270 +  mv  R7, narrowklass: precise klass java/util/stream/Streams$StreamBuilderImpl: 0x00000040d8403970:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0280 +  sw  rheapbase, [R31, #40]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/util/stream/AbstractPipeline.sourceSpliterator
0284 +  far_bne  R9, R7, B251	#@far_cmpN_branch  P=0.004560 C=-1.000000

028c    B28: #	out( B461 B29 ) &lt;- in( B27 )  Freq: 0.331738
028c +  # checkcastPP of R19, #@checkCastPP
028c    lwu  R31, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0290    NullCheck R30

0290    B29: #	out( B358 B30 ) &lt;- in( B28 )  Freq: 0.331738
0290 +  lw  R8, [R19, #12]	# int, #@loadI ! Field: java/util/stream/Streams$AbstractStreamBuilderImpl.count
0294 +  li R10, #-2	# int, #@loadConI
0298 +  lwu  R29, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/Streams$StreamBuilderImpl.first
029c +  mv  R28, narrowklass: precise klass java/util/stream/ReduceOps$3ReducingSink: 0x00000040d827a7d0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
02ac +  far_bne  R8, R10, B358	#@far_cmpI_branch  P=0.000000 C=1748.000000

02b4    B30: #	out( B344 B31 ) &lt;- in( B29 )  Freq: 0.331738
02b4 +  decode_heap_oop  R7, R29	#@decodeHeapOop
02b8 +  far_bne  R31, R28, B344	#@far_cmpN_branch  P=0.000001 C=-1.000000

02c0    B31: #	out( B449 B32 ) &lt;- in( B30 )  Freq: 0.331737
02c0 +  # checkcastPP of R30, #@checkCastPP
02c0    lwu  R31, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReduceOps$3ReducingSink.val$accumulator
02c4 +  lwu  R28, [R30, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReduceOps$Box.state
02c8 +  decode_heap_oop  R31, R31	#@decodeHeapOop
02cc +  decode_heap_oop  R8, R28	#@decodeHeapOop
02d0    lwu  R30, [R31, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
02d4    NullCheck R31

02d4    B32: #	out( B345 B33 ) &lt;- in( B31 )  Freq: 0.331737
02d4 +  mv  R28, narrowklass: precise klass java/util/stream/Collectors$$Lambda$12+0x0000000800008ea8: 0x00000040d827c550:Constant:exact *	# compressed klass ptr, #@loadConNKlass
02e4 +  far_bne  R30, R28, B345	#@far_cmpN_branch  P=0.000001 C=-1.000000

02ec    B33: #	out( B450 B34 ) &lt;- in( B32 )  Freq: 0.331737
02ec    lwu  R30, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
02f0    NullCheck R8

02f0    B34: #	out( B434 B35 ) &lt;- in( B33 )  Freq: 0.331736
02f0 +  mv  R28, narrowklass: precise klass java/util/HashSet: 0x00000040d828f9b0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0300 +  far_bne  R30, R28, B434	#@far_cmpN_branch  P=0.000000 C=-1.000000

0308    B35: #	out( B341 B36 ) &lt;- in( B34 )  Freq: 0.331736
0308 +  # checkcastPP of R8, #@checkCastPP
0308    lwu  R30, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashSet.map
030c +  decode_heap_oop  R21, R30	#@decodeHeapOop
0310 +  far_beq   R21, zr, B341	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0318    B36: #	out( B462 B37 ) &lt;- in( B35 )  Freq: 0.331736
0318    lwu  R30, [R7, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
031c    NullCheck R7

031c    B37: #	out( B245 B38 ) &lt;- in( B36 )  Freq: 0.331736
031c +  mv  R28, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
032c +  far_bne  R30, R28, B245	#@far_cmpN_branch  P=0.019314 C=-1.000000

0334    B38: #	out( B40 B39 ) &lt;- in( B37 )  Freq: 0.325329
0334 +  spill R7 -&gt; R14	# spill size = 64
0338 +  # checkcastPP of R14, #@checkCastPP
0338    lw  R10, [R14, #12]	# int, #@loadI ! Field: java/lang/String.hash
033c +  beq  R10, zr, B40	#@cmpI_reg_imm0_branch  P=0.525856 C=5376.000000

0340    B39: #	out( B110 ) &lt;- in( B38 )  Freq: 0.154253
0340 +  li R28, #0	# int, #@loadConI
0344 +  j  B110	#@branch

0348    B40: #	out( B295 B41 ) &lt;- in( B38 )  Freq: 0.171076
0348 +  lbu  R28, [R14, #17]	# byte, #@loadUB ! Field: java/lang/String.hashIsZero
034c +  far_bne  R28, zr, B295	#@far_cmpI_reg_imm0_branch  P=0.001062 C=2826.000000

0354    B41: #	out( B398 B42 ) &lt;- in( B40 )  Freq: 0.170894
0354 +  lwu  R31, [R14, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0358 +  lb  R8, [R14, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
035c +  decode_heap_oop  R15, R31	#@decodeHeapOop
0360 +  far_bne  R8, zr, B398	#@far_cmpI_reg_imm0_branch  P=0.000000 C=42934.000000

0368    B42: #	out( B459 B43 ) &lt;- in( B41 )  Freq: 0.170894
0368    lwu  R13, [R15, #12]	# range, #@loadRange
036c    NullCheck R15

036c    B43: #	out( B232 B44 ) &lt;- in( B42 )  Freq: 0.170894
036c +  far_bleu  R13, zr, B232	#@far_cmpUEqNeLeGt_imm0_branch  P=0.056079 C=18260.000000

0374    B44: #	out( B359 B45 ) &lt;- in( B43 )  Freq: 0.16131
0374 +  addiw  R28, R13, #-1	#@addI_reg_imm
0378 +  far_bgeu R28, R13, B359	#@far_cmpU_branch  P=0.000001 C=-1.000000

0380    B45: #	out( B360 B46 ) &lt;- in( B44 )  Freq: 0.16131
0380 +  li R11, #1	# int, #@loadConI
0384 +  addiw  R28, R13, #-3	#@addI_reg_imm
0388 +  lbu  R10, [R15, #16]	# byte, #@loadUB
038c +  far_ble  R28, R11, B360	#@far_cmpI_branch  P=0.000001 C=-1.000000

0394    B46: #	out( B361 B47 ) &lt;- in( B45 )  Freq: 0.16131
0394 +  slliw  R11, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0398 +  li R31, #1	# int, #@loadConI
039c +  subw  R16, R11, R10	#@subI_reg_reg
03a0 +  far_bleu R13, R31, B361	#@far_cmpU_branch  P=0.000001 C=-1.000000

03a8    B47: #	out( B362 B48 ) &lt;- in( B46 )  Freq: 0.16131
03a8 +  li R10, #4	# int, #@loadConI
03ac +  far_bleu R13, R10, B362	#@far_cmpU_branch  P=0.000001 C=-1.000000

03b4    B48: #	out( B100 ) &lt;- in( B47 )  Freq: 0.16131
03b4 +  li R12, #1	# int, #@loadConI
03b8 +  li R31, #0	# int, #@loadConI
03bc +  j  B100	#@branch

03c0    B49: #	out( B441 B50 ) &lt;- in( B4 )  Freq: 0.666717
03c0 +  # checkcastPP of R8, #@checkCastPP
03c0    lwu  R7, [R8, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$3$1.this$1
03c4 +  decode_heap_oop  R7, R7	#@decodeHeapOop
03c8    lwu  R28, [R7, #52]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$3.val$mapper
03cc    NullCheck R7

03cc    B50: #	out( B503 B51 ) &lt;- in( B49 )  Freq: 0.666716
03cc +  lwu  R7, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/Sink$ChainedReference.downstream
03d0 +  decode_heap_oop  R11, R28	#@decodeHeapOop
03d4 +  decode_heap_oop  R8, R7	#@decodeHeapOop
03d8    spill R10 -&gt; R12	# spill size = 64
03dc    CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.function.Function::apply
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:12 (line 197) L[0]=_ L[1]=_ STK[0]=R8
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=1016/0x3f8}

03f8    B51: #	out( B442 B52 ) &lt;- in( B50 )  Freq: 0.666703
        # Block is sole successor of call
03f8 +  spill R10 -&gt; [sp, #0]	# spill size = 64
03fc +  spill R8 -&gt; R30	# spill size = 64
0400    lwu  R7, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0404    NullCheck R8

0404    B52: #	out( B97 B53 ) &lt;- in( B51 )  Freq: 0.666702
0404 +  mv  R29, narrowklass: precise klass java/util/stream/ReferencePipeline$3$1: 0x00000040d8350040:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0414 +  beq  R7, R29, B97	#@cmpN_branch  P=0.666732 C=-1.000000

0418    B53: #	out( B348 B54 ) &lt;- in( B52 )  Freq: 0.222191
0418 +  mv  R28, narrowklass: precise klass java/util/stream/ReferencePipeline$7$1: 0x00000040d8350da0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0428 +  far_bne  R7, R28, B348	#@far_cmpN_branch  P=0.000001 C=-1.000000

0430    B54: #	out( B451 B55 ) &lt;- in( B53 )  Freq: 0.22219
0430 +  # checkcastPP of R30, #@checkCastPP
0430    lwu  R28, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$7$1.this$1
0434 +  decode_heap_oop  R7, R28	#@decodeHeapOop
0438    lwu  R7, [R7, #52]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$7.val$mapper
043c    NullCheck R7

043c    B55: #	out( B452 B56 ) &lt;- in( B54 )  Freq: 0.22219
043c +  decode_heap_oop  R8, R7	#@decodeHeapOop
0440    lwu  R28, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0444    NullCheck R8

0444    B56: #	out( B349 B57 ) &lt;- in( B55 )  Freq: 0.22219
0444 +  mv  R7, narrowklass: precise klass jdk/internal/module/ModulePath$$Lambda$10+0x000000080001e230: 0x00000040d81f3250:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0454 +  far_bne  R28, R7, B349	#@far_cmpN_branch  P=0.000001 C=-1.000000

045c    B57: #	out( B453 B58 ) &lt;- in( B56 )  Freq: 0.22219
045c +  spill R10 -&gt; R29	# spill size = 64
0460    lwu  R28, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0464    NullCheck R10

0464    B58: #	out( B427 B59 ) &lt;- in( B57 )  Freq: 0.22219
0464 +  mv  R7, narrowklass: precise klass java/util/Optional: 0x00000040d81f6420:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0474 +  far_bne  R28, R7, B427	#@far_cmpN_branch  P=0.000000 C=-1.000000

047c    B59: #	out( B260 B60 ) &lt;- in( B58 )  Freq: 0.22219
047c +  # checkcastPP of R29, #@checkCastPP
047c    lwu  R28, [R29, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/Optional.value
0480 +  decode_heap_oop  R8, R28	#@decodeHeapOop
0484    spill R28 -&gt; [sp, #8]	# spill size = 32
0488 +  far_beq   R8, zr, B260	#@far_cmpP_imm0_branch  P=0.004467 C=1791.000000

0490    B60: #	out( B315 B61 ) &lt;- in( B59 )  Freq: 0.221197
0490 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0490    ld  R29, [R23, #288]	# ptr, #@loadP
0494 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0494    ld  R7, [R23, #304]	# ptr, #@loadP
0498 +  addi  R28, R29, #24	# ptr, #@addP_reg_imm
049c +  far_bgeu  R28, R7, B315	#@far_cmpP_branch  P=0.000100 C=-1.000000

04a4    B61: #	out( B62 ) &lt;- in( B60 )  Freq: 0.221175
04a4 +  li R7, #1	# long, #@loadConL
04a8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
04a8    sd  R28, [R23, #288]	# ptr, #@storeP
04ac +  sd  R7, [R29]	# long, #@storeL
04b0 +  mv  R7, narrowklass: precise klass java/util/stream/Streams$StreamBuilderImpl: 0x00000040d8403970:Constant:exact *	# compressed klass ptr, #@loadConNKlass
04c0 +  sw  R7, [R29, #8]	# compressed klass ptr, #@storeNKlass
04c4 +  sw  zr, [R29, #20]	# int, #@storeimmI0

04c8    B62: #	out( B317 B63 ) &lt;- in( B316 B61 )  Freq: 0.221197
04c8 +  li R28, #-2	# int, #@loadConI
04cc +  sw  R28, [R29, #12]	# int, #@storeI
04d0    spill [sp, #8] -&gt; R7	# spill size = 32
04d4 +  sw  R7, [R29, #16]	# compressed ptr, #@storeN
04d8    
04d8 +  MEMBAR-store-store	#@membar_storestore
04dc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
04dc    ld  R10, [R23, #288]	# ptr, #@loadP
04e0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
04e0    ld  R7, [R23, #304]	# ptr, #@loadP
04e4 +  addi  R28, R10, #56	# ptr, #@addP_reg_imm
04e8 +  # checkcastPP of R29, #@checkCastPP
04e8    far_bgeu  R28, R7, B317	#@far_cmpP_branch  P=0.000100 C=-1.000000

04f0    B63: #	out( B64 ) &lt;- in( B62 )  Freq: 0.221175
04f0 +  li R7, #1	# long, #@loadConL
04f4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
04f4    sd  R28, [R23, #288]	# ptr, #@storeP
04f8 +  sd  R7, [R10]	# long, #@storeL
04fc +  mv  R7, narrowklass: precise klass java/util/stream/ReferencePipeline$Head: 0x00000040d81f3320:Constant:exact *	# compressed klass ptr, #@loadConNKlass
050c +  addi  R28, R10, #24	# ptr, #@addP_reg_imm
0510 +  sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
0514    ClearArray #2, R28	#@clearArray_imm_reg
051c +  sw  zr, [R10, #44]	# int, #@storeimmI0
0520 +  sd  zr, [R10, #48]	# long, #@storeimmL0

0524    B64: #	out( B65 ) &lt;- in( B318 B63 )  Freq: 0.221197
0524 +  li R28, #80	# int, #@loadConI
0528 +  li R7, #408021893120	# long, #@loadConL
0530 +  sw  R28, [R10, #12]	# int, #@storeI
0534 +  sd  R7, [R10, #16]	# long, #@storeL
0538 +  encode_heap_oop  R7, R29	#@encodeHeapOop
053c +  sw  R7, [R10, #40]	# compressed ptr, #@storeN
0540    
0540 +  MEMBAR-store-store	#@membar_storestore
0544 +  # checkcastPP of R10, #@checkCastPP
0544    encode_heap_oop  R28, R10	#@encodeHeapOop
0548 +  sw  R28, [R10, #28]	# compressed ptr, #@storeN ! Field: java/util/stream/AbstractPipeline.sourceStage
054c    spill R10 -&gt; R19	# spill size = 64
0550 +  #@membar_release
	fence iorw ow
0554 +  # checkcastPP of R19, #@checkCastPP

0554    B65: #	out( B429 B66 ) &lt;- in( B262 B64 )  Freq: 0.22219
0554    lwu  R7, [R19, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0558 +  mv  R29, narrowklass: precise klass java/util/stream/ReferencePipeline$Head: 0x00000040d81f3320:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0568 +  far_bne  R7, R29, B429	#@far_cmpN_branch  P=0.000000 C=-1.000000

0570    B66: #	out( B378 B67 ) &lt;- in( B65 )  Freq: 0.22219
0570 +  # checkcastPP of R19, #@checkCastPP
0570    lwu  R7, [R19, #28]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceStage
0574    spill R19 -&gt; R10	# spill size = 64
0578 +  lbu  R8, [R30, #16]	# byte, #@loadUB ! Field: java/util/stream/ReferencePipeline$7$1.cancellationRequestedCalled
057c +  # checkcastPP of R10, #@checkCastPP
057c    lwu  R29, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0580 +  decode_heap_oop  R7, R7	#@decodeHeapOop
0584 +  mv  R28, narrowklass: precise klass java/util/stream/ReferencePipeline$Head: 0x00000040d81f3320:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0594 +  far_bne  R8, zr, B378	#@far_cmpI_reg_imm0_branch  P=0.000000 C=1791.000000

059c    B67: #	out( B454 B68 ) &lt;- in( B66 )  Freq: 0.222189
059c    sb zr, [R7, #26]	# byte, #@storeimmB0 ! Field: java/util/stream/AbstractPipeline.parallel
05a0    NullCheck R7

05a0    B68: #	out( B431 B69 ) &lt;- in( B67 )  Freq: 0.222189
05a0 +  far_bne  R29, R28, B431	#@far_cmpN_branch  P=0.000000 C=-1.000000

05a8    B69: #	out( B455 B70 ) &lt;- in( B68 )  Freq: 0.222189
05a8 +  # checkcastPP of R10, #@checkCastPP
05a8    lwu  R28, [R10, #28]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceStage
05ac +  decode_heap_oop  R31, R28	#@decodeHeapOop
05b0    lbu  R12, [R31, #26]	# byte, #@loadUB ! Field: java/util/stream/AbstractPipeline.parallel
05b4    NullCheck R31

05b4    B70: #	out( B379 B71 ) &lt;- in( B69 )  Freq: 0.222189
05b4 +  lwu  R7, [R31, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceSpliterator
05b8 +  lwu  R29, [R30, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/Sink$ChainedReference.downstream
05bc +  lbu  R28, [R10, #24]	# byte, #@loadUB ! Field: java/util/stream/AbstractPipeline.linkedOrConsumed
05c0 +  decode_heap_oop  R9, R7	#@decodeHeapOop
05c4 +  decode_heap_oop  R29, R29	#@decodeHeapOop
05c8 +  far_bne  R12, zr, B379	#@far_cmpI_reg_imm0_branch  P=0.000000 C=1791.000000

05d0    B71: #	out( B388 B72 ) &lt;- in( B70 )  Freq: 0.222189
05d0 +  far_bne  R10, R31, B388	#@far_cmpP_branch  P=0.000000 C=1791.000000

05d8    B72: #	out( B389 B73 ) &lt;- in( B71 )  Freq: 0.222189
05d8 +  far_bne  R28, zr, B389	#@far_cmpI_reg_imm0_branch  P=0.000000 C=1791.000000

05e0    B73: #	out( B466 B74 ) &lt;- in( B72 )  Freq: 0.222189
05e0 +  li R7, #1	# int, #@loadConI
05e4 +  sb  R7, [R10, #24]	# byte, #@storeB ! Field: java/util/stream/AbstractPipeline.linkedOrConsumed
05e8    lwu  R18, [R9, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
05ec    NullCheck R9

05ec    B74: #	out( B279 B75 ) &lt;- in( B73 )  Freq: 0.222189
05ec +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
05ec    lb  R7, [R23, #56]	# byte, #@loadB
05f0 +  far_bne  R7, zr, B279	#@far_cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

05f8    B75: #	out( B257 B76 ) &lt;- in( B380 B281 B279 B74 )  Freq: 0.222189
05f8 +  mv  R28, narrowklass: precise klass java/util/stream/Streams$StreamBuilderImpl: 0x00000040d8403970:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0608 +  sw  rheapbase, [R31, #40]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/util/stream/AbstractPipeline.sourceSpliterator
060c +  far_bne  R18, R28, B257	#@far_cmpN_branch  P=0.004560 C=-1.000000

0614    B76: #	out( B467 B77 ) &lt;- in( B75 )  Freq: 0.221175
0614 +  # checkcastPP of R9, #@checkCastPP
0614    lwu  R28, [R29, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0618    NullCheck R29

0618    B77: #	out( B383 B78 ) &lt;- in( B76 )  Freq: 0.221175
0618 +  lw  R8, [R9, #12]	# int, #@loadI ! Field: java/util/stream/Streams$AbstractStreamBuilderImpl.count
061c +  li R31, #-2	# int, #@loadConI
0620 +  lwu  R30, [R9, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/Streams$StreamBuilderImpl.first
0624 +  mv  R10, narrowklass: precise klass java/util/stream/ReduceOps$3ReducingSink: 0x00000040d827a7d0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0634 +  far_bne  R8, R31, B383	#@far_cmpI_branch  P=0.000000 C=1748.000000

063c    B78: #	out( B350 B79 ) &lt;- in( B77 )  Freq: 0.221175
063c +  decode_heap_oop  R7, R30	#@decodeHeapOop
0640 +  far_bne  R28, R10, B350	#@far_cmpN_branch  P=0.000001 C=-1.000000

0648    B79: #	out( B457 B80 ) &lt;- in( B78 )  Freq: 0.221175
0648 +  # checkcastPP of R29, #@checkCastPP
0648    lwu  R28, [R29, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReduceOps$3ReducingSink.val$accumulator
064c +  lwu  R31, [R29, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReduceOps$Box.state
0650 +  decode_heap_oop  R29, R28	#@decodeHeapOop
0654 +  decode_heap_oop  R8, R31	#@decodeHeapOop
0658    lwu  R28, [R29, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
065c    NullCheck R29

065c    B80: #	out( B351 B81 ) &lt;- in( B79 )  Freq: 0.221175
065c +  mv  R31, narrowklass: precise klass java/util/stream/Collectors$$Lambda$12+0x0000000800008ea8: 0x00000040d827c550:Constant:exact *	# compressed klass ptr, #@loadConNKlass
066c +  far_bne  R28, R31, B351	#@far_cmpN_branch  P=0.000001 C=-1.000000

0674    B81: #	out( B458 B82 ) &lt;- in( B80 )  Freq: 0.221174
0674    lwu  R28, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0678    NullCheck R8

0678    B82: #	out( B433 B83 ) &lt;- in( B81 )  Freq: 0.221174
0678 +  mv  R31, narrowklass: precise klass java/util/HashSet: 0x00000040d828f9b0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0688 +  far_bne  R28, R31, B433	#@far_cmpN_branch  P=0.000000 C=-1.000000

0690    B83: #	out( B347 B84 ) &lt;- in( B82 )  Freq: 0.221174
0690 +  # checkcastPP of R8, #@checkCastPP
0690    lwu  R28, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashSet.map
0694 +  decode_heap_oop  R20, R28	#@decodeHeapOop
0698 +  far_beq   R20, zr, B347	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

06a0    B84: #	out( B468 B85 ) &lt;- in( B83 )  Freq: 0.221174
06a0    lwu  R31, [R7, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
06a4    NullCheck R7

06a4    B85: #	out( B249 B86 ) &lt;- in( B84 )  Freq: 0.221174
06a4 +  mv  R28, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
06b4 +  bne  R31, R28, B249	#@cmpN_branch  P=0.019314 C=-1.000000

06b8    B86: #	out( B88 B87 ) &lt;- in( B85 )  Freq: 0.216902
06b8 +  spill R7 -&gt; R29	# spill size = 64
06bc +  # checkcastPP of R29, #@checkCastPP
06bc    lw  R10, [R29, #12]	# int, #@loadI ! Field: java/lang/String.hash
06c0 +  beq  R10, zr, B88	#@cmpI_reg_imm0_branch  P=0.525856 C=5376.000000

06c4    B87: #	out( B160 ) &lt;- in( B86 )  Freq: 0.102843
06c4 +  li R18, #0	# int, #@loadConI
06c8 +  j  B160	#@branch

06cc    B88: #	out( B296 B89 ) &lt;- in( B86 )  Freq: 0.114059
06cc +  lbu  R10, [R29, #17]	# byte, #@loadUB ! Field: java/lang/String.hashIsZero
06d0 +  far_bne  R10, zr, B296	#@far_cmpI_reg_imm0_branch  P=0.001062 C=2826.000000

06d8    B89: #	out( B410 B90 ) &lt;- in( B88 )  Freq: 0.113938
06d8 +  lwu  R28, [R29, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
06dc +  lb  R8, [R29, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
06e0 +  decode_heap_oop  R14, R28	#@decodeHeapOop
06e4 +  far_bne  R8, zr, B410	#@far_cmpI_reg_imm0_branch  P=0.000000 C=42934.000000

06ec    B90: #	out( B465 B91 ) &lt;- in( B89 )  Freq: 0.113938
06ec    lwu  R8, [R14, #12]	# range, #@loadRange
06f0    NullCheck R14

06f0    B91: #	out( B247 B92 ) &lt;- in( B90 )  Freq: 0.113938
06f0 +  bleu  R8, zr, B247	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.056079 C=18260.000000

06f4    B92: #	out( B384 B93 ) &lt;- in( B91 )  Freq: 0.107548
06f4 +  addiw  R10, R8, #-1	#@addI_reg_imm
06f8 +  far_bgeu R10, R8, B384	#@far_cmpU_branch  P=0.000001 C=-1.000000

0700    B93: #	out( B385 B94 ) &lt;- in( B92 )  Freq: 0.107548
0700 +  li R11, #1	# int, #@loadConI
0704 +  addiw  R13, R8, #-3	#@addI_reg_imm
0708 +  lbu  R10, [R14, #16]	# byte, #@loadUB
070c +  far_ble  R13, R11, B385	#@far_cmpI_branch  P=0.000001 C=-1.000000

0714    B94: #	out( B386 B95 ) &lt;- in( B93 )  Freq: 0.107548
0714 +  slliw  R28, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0718 +  subw  R28, R28, R10	#@subI_reg_reg
071c +  li R10, #1	# int, #@loadConI
0720 +  far_bleu R8, R10, B386	#@far_cmpU_branch  P=0.000001 C=-1.000000

0728    B95: #	out( B387 B96 ) &lt;- in( B94 )  Freq: 0.107548
0728 +  li R11, #4	# int, #@loadConI
072c +  far_bleu R8, R11, B387	#@far_cmpU_branch  P=0.000001 C=-1.000000

0734    B96: #	out( B150 ) &lt;- in( B95 )  Freq: 0.107548
0734 +  li R11, #1	# int, #@loadConI
0738 +  li R15, #0	# int, #@loadConI
073c +  j  B150	#@branch

0740    B97: #	out( B504 B98 ) &lt;- in( B52 )  Freq: 0.444512
0740 +  spill R8 -&gt; R11	# spill size = 64
0744 +  # checkcastPP of R11, #@checkCastPP
0744    spill R10 -&gt; R12	# spill size = 64
0748    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.stream.ReferencePipeline$3$1::accept
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {off=1868/0x74c}

074c    B98: #	out( N5509 ) &lt;- in( B97 B197 B147 )  Freq: 0.999938
074c    # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0764 +  ret	// return register, #@Ret

0768    B99: #	out( B100 ) &lt;- in( B102 ) top-of-loop Freq: 2.71517
0768 +  spill R9 -&gt; R31	# spill size = 32
076c +  spill R17 -&gt; R29	# spill size = 32
0774 +  spill R20 -&gt; R7	# spill size = 64
0778 +  spill R22 -&gt; R30	# spill size = 32

0780    B100: #	out( B101 ) &lt;- in( B48 B99 ) Loop( B100-B99 ) Freq: 2.87648
0780 +  subw  R10, R13, R12	#@subI_reg_reg
0784 +  addiw  R11, R10, #-3	#@addI_reg_imm
0788    CMove R11, (R28 lt R12), R11, R31	#@cmovI_cmpI
	
0790 +  li R9, #4000	# int, #@loadConI
0798 +  li R10, #4000	# int, #@loadConI
07a0    CMove R11, (R11 gtu R10), R11, R9	#@cmovI_cmpU
	
07a8 +  addw  R11, R11, R12	#@addI_reg_reg
07ac    spill R31 -&gt; R9	# spill size = 32
07b0 +  spill R29 -&gt; R17	# spill size = 32
07b8 +  spill R7 -&gt; R20	# spill size = 64
07bc +  spill R30 -&gt; R22	# spill size = 32
        nop 	# 6 bytes pad for loops and calls

07d0    B101: #	out( B101 B102 ) &lt;- in( B100 B101 ) Loop( B101-B101 inner main of N1057 strip mined) Freq: 51.2935
07d0 +  addw  R7, R12, zr	#@convI2L_reg_reg
07d4 +  add R24, R15, R7	# ptr, #@addP_reg_reg
07d8 +  lbu  R7, [R24, #16]	# byte, #@loadUB
07dc +  addw  R7, R16, R7	#@addI_reg_reg
07e0 +  lbu  R29, [R24, #17]	# byte, #@loadUB
07e4 +  slliw  R31, R7, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
07e8 +  subw  R7, R31, R7	#@subI_reg_reg
07ec +  addw  R7, R7, R29	#@addI_reg_reg
07f0 +  lbu  R10, [R24, #18]	# byte, #@loadUB
07f4 +  slliw  R30, R7, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
07f8 +  subw  R29, R30, R7	#@subI_reg_reg
07fc +  addw  R7, R29, R10	#@addI_reg_reg
0800 +  lbu  R30, [R24, #19]	# byte, #@loadUB
0804 +  slliw  R31, R7, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0808 +  subw  R7, R31, R7	#@subI_reg_reg
080c +  addw  R10, R7, R30	#@addI_reg_reg
0810 +  slliw  R29, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0814 +  addiw  R12, R12, #4	#@addI_reg_imm
0818 +  subw  R16, R29, R10	#@subI_reg_reg
081c +  blt  R12, R11, B101	#@cmpI_loop  P=0.943921 C=17236.000000

0820    B102: #	out( B99 B103 ) &lt;- in( B101 )  Freq: 2.87648
0820 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0820    ld  R7, [R23, #920]	# ptr, #@loadP
0824 +  lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::hashCode @ bci:37 (line 196) L[0]=_ L[1]=R10 L[2]=R15 L[3]=R13 L[4]=R12 L[5]=_
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=R14 L[1]=_
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=R20 L[2]=#Ptr0x00000040d82922a0 STK[0]=R21
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=R19 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R18 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {c_rarg4=Oop c_rarg5=Oop c_rarg7=NarrowOop x18=Oop x19=Oop esp=Oop xdispatch=Oop off=2084/0x824}
0828 +  blt  R12, R28, B99	#@cmpI_branch  P=0.943921 C=17236.000000

082c    B103: #	out( B104 ) &lt;- in( B102 )  Freq: 0.16131
082c +  spill R9 -&gt; R28	# spill size = 32
0830 +  spill R17 -&gt; R29	# spill size = 32
0838 +  spill R20 -&gt; R7	# spill size = 64
083c +  spill R22 -&gt; R30	# spill size = 32

0844    B104: #	out( B108 B105 ) &lt;- in( B360 B103 )  Freq: 0.16131
0844 +  bge  R12, R13, B108	#@cmpI_branch  P=0.500000 C=-1.000000

0848    B105: #	out( B400 B106 ) &lt;- in( B104 )  Freq: 0.080655
0848 +  # castII of R12, #@castII
0848    far_bgeu R12, R13, B400	#@far_cmpU_branch  P=0.000001 C=-1.000000

0850    B106: #	out( B401 B107 ) &lt;- in( B105 )  Freq: 0.0806549
0850 +  spill R12 -&gt; R31	# spill size = 32
0854 +  # castII of R31, #@castII
0854    far_bgeu R31, R13, B401	#@far_cmpU_branch  P=0.000001 C=-1.000000

085c    B107: #	out( B107 B108 ) &lt;- in( B106 B107 ) Loop( B107-B107 inner post of N3399) Freq: 0.16131
085c +  addw  R31, R12, zr	#@convI2L_reg_reg
0860 +  add R31, R15, R31	# ptr, #@addP_reg_reg
0864 +  lbu  R11, [R31, #16]	# byte, #@loadUB
0868 +  slliw  R31, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
086c +  subw  R10, R31, R10	#@subI_reg_reg
0870 +  addiw  R12, R12, #1	#@addI_reg_imm
0874 +  addw  R10, R10, R11	#@addI_reg_reg
0878 +  blt  R12, R13, B107	#@cmpI_loop  P=0.500000 C=17236.000000

087c    B108: #	out( B233 B109 ) &lt;- in( B107 B104 )  Freq: 0.16131
087c +  beq  R10, zr, B233	#@cmpI_reg_imm0_branch  P=0.000354 C=2823.000000

0880    B109: #	out( B110 ) &lt;- in( B108 )  Freq: 0.161253
0880 +  sw  R10, [R14, #12]	# int, #@storeI ! Field: java/lang/String.hash

0884    B110: #	out( B229 B111 ) &lt;- in( B109 B233 B295 B39 B246 )  Freq: 0.331735
0884 +  lwu  R11, [R21, #36]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap.table
0888 +  srliw  R31, R10, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
088c +  decode_heap_oop  R22, R11	#@decodeHeapOop
0890 +  xorr  R20, R31, R10	#@xorI_reg_reg
0894 +  beq   R22, zr, B229	#@cmpP_imm0_branch  P=0.031876 C=2196.000000

0898    B111: #	out( B366 B112 ) &lt;- in( B110 )  Freq: 0.32116
0898 +  lwu  R31, [R22, #12]	# range, #@loadRange
089c +  far_bleu  R31, zr, B366	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000000 C=2126.000000

08a4    B112: #	out( B346 B113 ) &lt;- in( B231 B111 )  Freq: 0.331734
08a4 +  addiw  R11, R31, #-1	#@addI_reg_imm
08a8 +  andr  R10, R11, R20	#@andI_reg_reg
08ac +  addw  R11, R10, zr	#@convI2L_reg_reg
08b0 +  slli  R11, R11, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
08b4 +  add R11, R22, R11	# ptr, #@addP_reg_reg
08b8 +  addi  R24, R11, #16	# ptr, #@addP_reg_imm
08bc +  far_ble  R31, zr, B346	#@far_cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

08c4    B113: #	out( B199 B114 ) &lt;- in( B112 )  Freq: 0.331734
08c4 +  lwu  R31, [R24]	# loadN, compressed ptr, #@loadN
08c8 +  decode_heap_oop  R9, R31	#@decodeHeapOop
08cc +  beq   R9, zr, B199	#@cmpP_imm0_branch  P=0.112477 C=2196.000000

08d0    B114: #	out( B130 B115 ) &lt;- in( B113 )  Freq: 0.294422
08d0 +  lw  R10, [R9, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
08d4 +  beq  R10, R20, B130	#@cmpI_branch  P=0.523345 C=1949.000000

08d8    B115: #	out( B371 B116 ) &lt;- in( B114 )  Freq: 0.140337
08d8 +  lwu  R10, [R9, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
08dc +  lwu  R31, [R9, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
08e0 +  mv  R11, narrowklass: precise klass java/util/HashMap$TreeNode: 0x00000040d81cadf0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
08f0 +  decode_heap_oop  R24, R10	#@decodeHeapOop
08f4 +  far_beq  R31, R11, B371	#@far_cmpN_branch  P=0.000001 C=-1.000000

08fc    B116: #	out( B221 B117 ) &lt;- in( B115 )  Freq: 0.140337
08fc +  beq   R24, zr, B221	#@cmpP_imm0_branch  P=0.083176 C=1058.000000

0900    B117: #	out( B118 ) &lt;- in( B116 )  Freq: 0.128665
0900 +  li R9, #0	# int, #@loadConI

0904    B118: #	out( B217 B119 ) &lt;- in( B117 B218 ) Loop( B118-B218 inner ) Freq: 0.146531
0904 +  lw  R31, [R24, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
0908 +  bne  R31, R20, B217	#@cmpI_branch  P=0.132990 C=970.000000

090c    B119: #	out( B408 B120 ) &lt;- in( B118 )  Freq: 0.127044
090c +  lwu  R10, [R24, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
0910 +  decode_heap_oop  R12, R10	#@decodeHeapOop
0914 +  far_beq  R10, R29, B408	#@far_cmpN_branch  P=0.000000 C=841.000000

091c    B120: #	out( B373 B121 ) &lt;- in( B119 )  Freq: 0.127044
091c +  mv  R31, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
092c +  far_bne  R30, R31, B373	#@far_cmpN_branch  P=0.000001 C=-1.000000

0934    B121: #	out( B129 B122 ) &lt;- in( B120 )  Freq: 0.127044
0934 +  spill R7 -&gt; R15	# spill size = 64
0938 +  # checkcastPP of R15, #@checkCastPP
0938    beq  R15, R12, B129	#@cmpP_branch  P=0.064818 C=5338.000000

093c    B122: #	out( B464 B123 ) &lt;- in( B121 )  Freq: 0.118809
093c    lwu  R7, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0940    NullCheck R12

0940    B123: #	out( B438 B124 ) &lt;- in( B122 )  Freq: 0.118809
0940 +  mv  R29, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0950 +  lwu  R31, [R15, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0954 +  lb  R30, [R15, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0958 +  far_bne  R7, R29, B438	#@far_cmpN_branch  P=0.000000 C=-1.000000

0960    B124: #	out( B409 B125 ) &lt;- in( B123 )  Freq: 0.118809
0960 +  # checkcastPP of R12, #@checkCastPP
0960    lb  R8, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0964 +  lwu  R7, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0968 +  decode_heap_oop  R29, R31	#@decodeHeapOop
096c +  far_bne  R30, R8, B409	#@far_cmpI_branch  P=0.000000 C=4992.000000

0974    B125: #	out( B374 B126 ) &lt;- in( B124 )  Freq: 0.118809
0974 +  far_beq   R29, zr, B374	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

097c    B126: #	out( B375 B127 ) &lt;- in( B125 )  Freq: 0.118809
097c +  decode_heap_oop  R7, R7	#@decodeHeapOop
0980 +  lwu  R14, [R29, #12]	# range, #@loadRange
0984 +  far_beq   R7, zr, B375	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

098c    B127: #	out( B377 B128 ) &lt;- in( B126 )  Freq: 0.118808
098c +  lwu  R31, [R7, #12]	# range, #@loadRange
0990 +  far_bne  R14, R31, B377	#@far_cmpI_branch  P=0.000001 C=-1.000000

0998    B128: #	out( B376 B129 ) &lt;- in( B127 )  Freq: 0.118808
0998 +  addi  R13, R7, #16	# ptr, #@addP_reg_imm
099c +  addi  R11, R29, #16	# ptr, #@addP_reg_imm
09a0    String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
0a30 +  far_beq  R10, zr, B376	#@far_cmpI_reg_imm0_branch  P=0.000000 C=841.000000

0a38    B129: #	out( B140 ) &lt;- in( B121 B128 )  Freq: 0.127043
0a38 +  spill R24 -&gt; R9	# spill size = 64
0a3c +  j  B140	#@branch

0a40    B130: #	out( B406 B131 ) &lt;- in( B114 )  Freq: 0.154084
0a40 +  lwu  R31, [R9, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
0a44 +  decode_heap_oop  R10, R31	#@decodeHeapOop
0a48 +  far_beq  R31, R29, B406	#@far_cmpN_branch  P=0.000000 C=1020.000000

0a50    B131: #	out( B365 B132 ) &lt;- in( B130 )  Freq: 0.154084
0a50 +  mv  R31, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0a60 +  far_bne  R30, R31, B365	#@far_cmpN_branch  P=0.000001 C=-1.000000

0a68    B132: #	out( B140 B133 ) &lt;- in( B131 )  Freq: 0.154084
0a68 +  spill R7 -&gt; R12	# spill size = 64
0a6c +  # checkcastPP of R12, #@checkCastPP
0a6c    beq  R12, R10, B140	#@cmpP_branch  P=0.064818 C=5338.000000

0a70    B133: #	out( B463 B134 ) &lt;- in( B132 )  Freq: 0.144096
0a70    lwu  R29, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0a74    NullCheck R10

0a74    B134: #	out( B437 B135 ) &lt;- in( B133 )  Freq: 0.144096
0a74 +  lwu  R7, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0a78 +  lb  R30, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0a7c +  far_bne  R29, R31, B437	#@far_cmpN_branch  P=0.000000 C=-1.000000

0a84    B135: #	out( B407 B136 ) &lt;- in( B134 )  Freq: 0.144096
0a84 +  # checkcastPP of R10, #@checkCastPP
0a84    lb  R8, [R10, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0a88 +  lwu  R29, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0a8c +  decode_heap_oop  R7, R7	#@decodeHeapOop
0a90 +  far_bne  R30, R8, B407	#@far_cmpI_branch  P=0.000000 C=4992.000000

0a98    B136: #	out( B367 B137 ) &lt;- in( B135 )  Freq: 0.144096
0a98 +  far_beq   R7, zr, B367	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0aa0    B137: #	out( B368 B138 ) &lt;- in( B136 )  Freq: 0.144096
0aa0 +  decode_heap_oop  R29, R29	#@decodeHeapOop
0aa4 +  lwu  R14, [R7, #12]	# range, #@loadRange
0aa8 +  far_beq   R29, zr, B368	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0ab0    B138: #	out( B370 B139 ) &lt;- in( B137 )  Freq: 0.144096
0ab0 +  lwu  R30, [R29, #12]	# range, #@loadRange
0ab4 +  far_bne  R14, R30, B370	#@far_cmpI_branch  P=0.000001 C=-1.000000

0abc    B139: #	out( B369 B140 ) &lt;- in( B138 )  Freq: 0.144096
0abc +  addi  R13, R29, #16	# ptr, #@addP_reg_imm
0ac0 +  addi  R11, R7, #16	# ptr, #@addP_reg_imm
0ac4    String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
0b54 +  far_beq  R10, zr, B369	#@far_cmpI_reg_imm0_branch  P=0.000000 C=1020.000000

0b5c    B140: #	out( B272 B141 ) &lt;- in( B132 B139 B129 )  Freq: 0.281126
0b5c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0b5c    lb  R7, [R23, #56]	# byte, #@loadB
0b60 +  bne  R7, zr, B272	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0b64    B141: #	out( B143 B142 ) &lt;- in( B372 B274 B272 B140 )  Freq: 0.281126
0b64 +  mv  R28, java/lang/Object:exact *	# ptr, #@loadConP
0b7c +  mv  R7, R9	# ptr -&gt; long, #@castP2X
0b80 +  mv  R28, R28	# ptr -&gt; long, #@castP2X
0b80 +  xorr  R28, R28, R7	#@xorL_reg_reg
0b84 +  mv  R29, narrowoop: java/lang/Object:exact *	# compressed ptr, #@loadConN
0b94 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0b98 +  sw  R29, [R9, #20]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.value
0b9c +  beq  R28, zr, B143	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0ba0    B142: #	out( B275 B143 ) &lt;- in( B141 )  Freq: 0.280845
0ba0 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0ba4 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
0bb0 +  add R10, R28, R7	# ptr, #@addP_reg_reg
0bb4 +  lb  R28, [R10]	# byte, #@loadB
0bb8 +  li R29, #4	# int, #@loadConI
0bbc +  bne  R28, R29, B275	#@cmpI_branch  P=0.001000 C=-1.000000

0bc0    B143: #	out( B144 ) &lt;- in( B277 B278 B275 B142 B141 B207 B205 )  Freq: 0.331732
0bc0 +  li R28, #-1	# int, #@loadConI
0bc4 +  sw  R28, [R19, #12]	# int, #@storeI ! Field: java/util/stream/Streams$AbstractStreamBuilderImpl.count

0bc8    B144: #	out( B266 B145 ) &lt;- in( B143 B252 )  Freq: 0.333252
0bc8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0bc8    lb  R28, [R23, #56]	# byte, #@loadB
0bcc +  bne  R28, zr, B266	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0bd0    B145: #	out( B269 B146 ) &lt;- in( B356 B268 B266 B144 )  Freq: 0.333252
0bd0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0bd0    lb  R7, [R23, #56]	# byte, #@loadB
0bd4 +  lwu  R9, [R18, #28]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceStage
0bd8 +  bne  R7, zr, B269	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0bdc    B146: #	out( B448 B147 ) &lt;- in( B357 B271 B269 B145 )  Freq: 0.333252
0bdc +  li R28, #1	# int, #@loadConI
0be0 +  decode_heap_oop  R7, R9	#@decodeHeapOop
0be4 +  sb  R28, [R18, #24]	# byte, #@storeB ! Field: java/util/stream/AbstractPipeline.linkedOrConsumed
0be8 +  sw  rheapbase, [R18, #44]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/util/stream/AbstractPipeline.sourceSupplier
0bec +  sw  rheapbase, [R18, #40]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/util/stream/AbstractPipeline.sourceSpliterator
0bf0    lwu  R28, [R7, #48]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceCloseAction
0bf4    NullCheck R7

0bf4    B147: #	out( B98 B148 ) &lt;- in( B146 )  Freq: 0.333251
0bf4 +  decode_heap_oop  R8, R28	#@decodeHeapOop
0bf8 +  beq   R8, zr, B98	#@cmpP_imm0_branch  P=1.000000 C=1791.000000

0bfc    B148: #	out( N5509 ) &lt;- in( B147 )  Freq: 1.58907e-07
0bfc +  li R11, #-187	# int, #@loadConI
0c00    spill R18 -&gt; [sp, #0]	# spill size = 64
0c04    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.AbstractPipeline::close @ bci:22 (line 320) L[0]=sp + #0 L[1]=_ STK[0]=R8
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:94 (line 283) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=3080/0xc08}
0c08    #@ShouldNotReachHere

0c14    B149: #	out( B150 ) &lt;- in( B152 ) top-of-loop Freq: 1.81025
0c14 +  spill R16 -&gt; R7	# spill size = 64
0c18 +  spill R17 -&gt; R29	# spill size = 64

0c1c    B150: #	out( B151 ) &lt;- in( B96 B149 ) Loop( B150-B149 ) Freq: 1.9178
0c1c +  subw  R12, R8, R11	#@subI_reg_reg
0c20 +  addiw  R10, R12, #-3	#@addI_reg_imm
0c24    CMove R10, (R13 lt R11), R10, R15	#@cmovI_cmpI
	
0c2c +  li R17, #4000	# int, #@loadConI
0c34 +  li R12, #4000	# int, #@loadConI
0c3c    CMove R10, (R10 gtu R12), R10, R17	#@cmovI_cmpU
	
0c44 +  addw  R12, R10, R11	#@addI_reg_reg
0c48    spill R7 -&gt; R16	# spill size = 64
0c4c +  spill R29 -&gt; R17	# spill size = 64

0c50    B151: #	out( B151 B152 ) &lt;- in( B150 B151 ) Loop( B151-B151 inner main of N670 strip mined) Freq: 34.1983
0c50 +  addw  R7, R11, zr	#@convI2L_reg_reg
0c54 +  add R18, R14, R7	# ptr, #@addP_reg_reg
0c58 +  lbu  R29, [R18, #16]	# byte, #@loadUB
0c5c +  addw  R7, R28, R29	#@addI_reg_reg
0c60 +  lbu  R10, [R18, #17]	# byte, #@loadUB
0c64 +  slliw  R28, R7, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0c68 +  subw  R7, R28, R7	#@subI_reg_reg
0c6c +  addw  R7, R7, R10	#@addI_reg_reg
0c70 +  lbu  R29, [R18, #18]	# byte, #@loadUB
0c74 +  slliw  R28, R7, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0c78 +  subw  R7, R28, R7	#@subI_reg_reg
0c7c +  addw  R28, R7, R29	#@addI_reg_reg
0c80 +  lbu  R18, [R18, #19]	# byte, #@loadUB
0c84 +  slliw  R7, R28, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0c88 +  subw  R28, R7, R28	#@subI_reg_reg
0c8c +  addw  R10, R28, R18	#@addI_reg_reg
0c90 +  slliw  R7, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0c94 +  addiw  R11, R11, #4	#@addI_reg_imm
0c98 +  subw  R28, R7, R10	#@subI_reg_reg
0c9c +  blt  R11, R12, B151	#@cmpI_loop  P=0.943921 C=17236.000000

0ca0    B152: #	out( B149 B153 ) &lt;- in( B151 )  Freq: 1.9178
0ca0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0ca0    ld  R7, [R23, #920]	# ptr, #@loadP
0ca4 +  lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::hashCode @ bci:37 (line 196) L[0]=_ L[1]=R10 L[2]=R14 L[3]=R8 L[4]=R11 L[5]=_
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=R17 L[1]=_
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=R16 L[2]=#Ptr0x00000040d82922a0 STK[0]=R20
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=R9 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R19 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {x30=NarrowOop c_rarg4=Oop c_rarg6=Oop c_rarg7=Oop x9=Oop x19=Oop esp=Oop off=3236/0xca4}
0ca8 +  blt  R11, R13, B149	#@cmpI_branch  P=0.943921 C=17236.000000

0cac    B153: #	out( B154 ) &lt;- in( B152 )  Freq: 0.107548
0cac +  spill R15 -&gt; R18	# spill size = 32
0cb0 +  spill R16 -&gt; R7	# spill size = 64
0cb4 +  spill R17 -&gt; R29	# spill size = 64

0cb8    B154: #	out( B158 B155 ) &lt;- in( B385 B153 )  Freq: 0.107548
0cb8 +  bge  R11, R8, B158	#@cmpI_branch  P=0.500000 C=-1.000000

0cbc    B155: #	out( B411 B156 ) &lt;- in( B154 )  Freq: 0.0537741
0cbc +  # castII of R11, #@castII
0cbc    far_bgeu R11, R8, B411	#@far_cmpU_branch  P=0.000001 C=-1.000000

0cc4    B156: #	out( B412 B157 ) &lt;- in( B155 )  Freq: 0.053774
0cc4 +  spill R11 -&gt; R12	# spill size = 32
0cc8 +  # castII of R12, #@castII
0cc8    far_bgeu R12, R8, B412	#@far_cmpU_branch  P=0.000001 C=-1.000000

0cd0    B157: #	out( B157 B158 ) &lt;- in( B156 B157 ) Loop( B157-B157 inner post of N3410) Freq: 0.107548
0cd0 +  addw  R28, R11, zr	#@convI2L_reg_reg
0cd4 +  add R28, R14, R28	# ptr, #@addP_reg_reg
0cd8 +  slliw  R13, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0cdc +  lbu  R28, [R28, #16]	# byte, #@loadUB
0ce0 +  subw  R10, R13, R10	#@subI_reg_reg
0ce4 +  addiw  R11, R11, #1	#@addI_reg_imm
0ce8 +  addw  R10, R10, R28	#@addI_reg_reg
0cec +  blt  R11, R8, B157	#@cmpI_loop  P=0.500000 C=17236.000000

0cf0    B158: #	out( B248 B159 ) &lt;- in( B157 B154 )  Freq: 0.107548
0cf0 +  beq  R10, zr, B248	#@cmpI_reg_imm0_branch  P=0.000354 C=2823.000000

0cf4    B159: #	out( B160 ) &lt;- in( B158 )  Freq: 0.10751
0cf4 +  sw  R10, [R29, #12]	# int, #@storeI ! Field: java/lang/String.hash

0cf8    B160: #	out( B242 B161 ) &lt;- in( B159 B248 B296 B87 B250 )  Freq: 0.221173
0cf8 +  lwu  R28, [R20, #36]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap.table
0cfc +  srliw  R11, R10, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
0d00 +  decode_heap_oop  R22, R28	#@decodeHeapOop
0d04 +  xorr  R21, R11, R10	#@xorI_reg_reg
0d08 +  beq   R22, zr, B242	#@cmpP_imm0_branch  P=0.031876 C=2196.000000

0d0c    B161: #	out( B391 B162 ) &lt;- in( B160 )  Freq: 0.214123
0d0c +  lwu  R28, [R22, #12]	# range, #@loadRange
0d10 +  far_bleu  R28, zr, B391	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000000 C=2126.000000

0d18    B162: #	out( B352 B163 ) &lt;- in( B244 B161 )  Freq: 0.221173
0d18 +  addiw  R29, R28, #-1	#@addI_reg_imm
0d1c +  andr  R29, R29, R21	#@andI_reg_reg
0d20 +  addw  R10, R29, zr	#@convI2L_reg_reg
0d24 +  slli  R10, R10, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0d28 +  add R10, R22, R10	# ptr, #@addP_reg_reg
0d2c +  addi  R25, R10, #16	# ptr, #@addP_reg_imm
0d30 +  far_ble  R28, zr, B352	#@far_cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0d38    B163: #	out( B208 B164 ) &lt;- in( B162 )  Freq: 0.221173
0d38 +  lwu  R10, [R25]	# loadN, compressed ptr, #@loadN
0d3c +  decode_heap_oop  R24, R10	#@decodeHeapOop
0d40 +  beq   R24, zr, B208	#@cmpP_imm0_branch  P=0.112477 C=2196.000000

0d44    B164: #	out( B180 B165 ) &lt;- in( B163 )  Freq: 0.196296
0d44 +  lw  R28, [R24, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
0d48 +  beq  R28, R21, B180	#@cmpI_branch  P=0.523345 C=1949.000000

0d4c    B165: #	out( B396 B166 ) &lt;- in( B164 )  Freq: 0.0935653
0d4c +  lwu  R28, [R24, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
0d50 +  lwu  R10, [R24, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0d54 +  decode_heap_oop  R12, R28	#@decodeHeapOop
0d58 +  mv  R28, narrowklass: precise klass java/util/HashMap$TreeNode: 0x00000040d81cadf0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0d68 +  far_beq  R10, R28, B396	#@far_cmpN_branch  P=0.000001 C=-1.000000

0d70    B166: #	out( B235 B167 ) &lt;- in( B165 )  Freq: 0.0935652
0d70 +  beq   R12, zr, B235	#@cmpP_imm0_branch  P=0.083176 C=1058.000000

0d74    B167: #	out( B168 ) &lt;- in( B166 )  Freq: 0.0857829
0d74 +  li R28, #0	# int, #@loadConI

0d78    B168: #	out( B219 B169 ) &lt;- in( B167 B220 ) Loop( B168-B220 inner ) Freq: 0.0976946
0d78 +  lw  R10, [R12, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
0d7c +  bne  R10, R21, B219	#@cmpI_branch  P=0.132990 C=970.000000

0d80    B169: #	out( B415 B170 ) &lt;- in( B168 )  Freq: 0.0847022
0d80 +  lwu  R29, [R12, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
0d84 +  decode_heap_oop  R10, R29	#@decodeHeapOop
0d88 +  far_beq  R29, R30, B415	#@far_cmpN_branch  P=0.000000 C=841.000000

0d90    B170: #	out( B399 B171 ) &lt;- in( B169 )  Freq: 0.0847022
0d90 +  mv  R30, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0da0 +  far_bne  R31, R30, B399	#@far_cmpN_branch  P=0.000001 C=-1.000000

0da8    B171: #	out( B179 B172 ) &lt;- in( B170 )  Freq: 0.0847021
0da8 +  spill R7 -&gt; R15	# spill size = 64
0dac +  # checkcastPP of R15, #@checkCastPP
0dac    beq  R15, R10, B179	#@cmpP_branch  P=0.064818 C=5338.000000

0db0    B172: #	out( B470 B173 ) &lt;- in( B171 )  Freq: 0.0792119
0db0    lwu  R30, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0db4    NullCheck R10

0db4    B173: #	out( B436 B174 ) &lt;- in( B172 )  Freq: 0.0792118
0db4 +  mv  R7, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0dc4 +  lwu  R31, [R15, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0dc8 +  lb  R29, [R15, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0dcc +  far_bne  R30, R7, B436	#@far_cmpN_branch  P=0.000000 C=-1.000000

0dd4    B174: #	out( B416 B175 ) &lt;- in( B173 )  Freq: 0.0792118
0dd4 +  # checkcastPP of R10, #@checkCastPP
0dd4    lb  R8, [R10, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0dd8 +  lwu  R7, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0ddc +  decode_heap_oop  R30, R31	#@decodeHeapOop
0de0 +  far_bne  R29, R8, B416	#@far_cmpI_branch  P=0.000000 C=4992.000000

0de8    B175: #	out( B402 B176 ) &lt;- in( B174 )  Freq: 0.0792117
0de8 +  far_beq   R30, zr, B402	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0df0    B176: #	out( B403 B177 ) &lt;- in( B175 )  Freq: 0.0792117
0df0 +  decode_heap_oop  R7, R7	#@decodeHeapOop
0df4 +  lwu  R14, [R30, #12]	# range, #@loadRange
0df8 +  far_beq   R7, zr, B403	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0e00    B177: #	out( B405 B178 ) &lt;- in( B176 )  Freq: 0.0792116
0e00 +  lwu  R29, [R7, #12]	# range, #@loadRange
0e04 +  far_bne  R14, R29, B405	#@far_cmpI_branch  P=0.000001 C=-1.000000

0e0c    B178: #	out( B404 B179 ) &lt;- in( B177 )  Freq: 0.0792115
0e0c +  addi  R13, R7, #16	# ptr, #@addP_reg_imm
0e10 +  addi  R11, R30, #16	# ptr, #@addP_reg_imm
0e14    String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
0ea4 +  far_beq  R10, zr, B404	#@far_cmpI_reg_imm0_branch  P=0.000000 C=841.000000

0eac    B179: #	out( B190 ) &lt;- in( B171 B178 )  Freq: 0.0847017
0eac +  spill R12 -&gt; R24	# spill size = 64
0eb0 +  j  B190	#@branch

0eb4    B180: #	out( B413 B181 ) &lt;- in( B164 )  Freq: 0.102731
0eb4 +  lwu  R29, [R24, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
0eb8 +  decode_heap_oop  R10, R29	#@decodeHeapOop
0ebc +  far_beq  R29, R30, B413	#@far_cmpN_branch  P=0.000000 C=1020.000000

0ec4    B181: #	out( B390 B182 ) &lt;- in( B180 )  Freq: 0.10273
0ec4 +  mv  R29, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0ed4 +  far_bne  R31, R29, B390	#@far_cmpN_branch  P=0.000001 C=-1.000000

0edc    B182: #	out( B190 B183 ) &lt;- in( B181 )  Freq: 0.10273
0edc +  spill R7 -&gt; R31	# spill size = 64
0ee0 +  # checkcastPP of R31, #@checkCastPP
0ee0    beq  R31, R10, B190	#@cmpP_branch  P=0.064818 C=5338.000000

0ee4    B183: #	out( B469 B184 ) &lt;- in( B182 )  Freq: 0.0960716
0ee4    lwu  R7, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0ee8    NullCheck R10

0ee8    B184: #	out( B435 B185 ) &lt;- in( B183 )  Freq: 0.0960715
0ee8 +  mv  R28, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0ef8 +  lwu  R29, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0efc +  lb  R30, [R31, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0f00 +  far_bne  R7, R28, B435	#@far_cmpN_branch  P=0.000000 C=-1.000000

0f08    B185: #	out( B414 B186 ) &lt;- in( B184 )  Freq: 0.0960715
0f08 +  # checkcastPP of R10, #@checkCastPP
0f08    lb  R8, [R10, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0f0c +  lwu  R28, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0f10 +  decode_heap_oop  R7, R29	#@decodeHeapOop
0f14 +  far_bne  R30, R8, B414	#@far_cmpI_branch  P=0.000000 C=4992.000000

0f1c    B186: #	out( B392 B187 ) &lt;- in( B185 )  Freq: 0.0960714
0f1c +  far_beq   R7, zr, B392	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0f24    B187: #	out( B393 B188 ) &lt;- in( B186 )  Freq: 0.0960713
0f24 +  decode_heap_oop  R28, R28	#@decodeHeapOop
0f28 +  lwu  R14, [R7, #12]	# range, #@loadRange
0f2c +  far_beq   R28, zr, B393	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0f34    B188: #	out( B395 B189 ) &lt;- in( B187 )  Freq: 0.0960712
0f34 +  lwu  R30, [R28, #12]	# range, #@loadRange
0f38 +  far_bne  R14, R30, B395	#@far_cmpI_branch  P=0.000001 C=-1.000000

0f40    B189: #	out( B394 B190 ) &lt;- in( B188 )  Freq: 0.0960711
0f40 +  addi  R13, R28, #16	# ptr, #@addP_reg_imm
0f44 +  addi  R11, R7, #16	# ptr, #@addP_reg_imm
0f48    String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
0fd8 +  far_beq  R10, zr, B394	#@far_cmpI_reg_imm0_branch  P=0.000000 C=1020.000000

0fe0    B190: #	out( B288 B191 ) &lt;- in( B182 B189 B179 )  Freq: 0.187432
0fe0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0fe0    lb  R28, [R23, #56]	# byte, #@loadB
0fe4 +  bne  R28, zr, B288	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0fe8    B191: #	out( B193 B192 ) &lt;- in( B397 B290 B288 B190 )  Freq: 0.187432
0fe8 +  mv  R28, java/lang/Object:exact *	# ptr, #@loadConP
1000 +  mv  R7, R24	# ptr -&gt; long, #@castP2X
1004 +  mv  R28, R28	# ptr -&gt; long, #@castP2X
1004 +  xorr  R28, R28, R7	#@xorL_reg_reg
1008 +  mv  R29, narrowoop: java/lang/Object:exact *	# compressed ptr, #@loadConN
1018 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
101c +  sw  R29, [R24, #20]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.value
1020 +  beq  R28, zr, B193	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1024    B192: #	out( B291 B193 ) &lt;- in( B191 )  Freq: 0.187244
1024 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1028 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1034 +  add R10, R28, R7	# ptr, #@addP_reg_reg
1038 +  lb  R7, [R10]	# byte, #@loadB
103c +  li R29, #4	# int, #@loadConI
1040 +  bne  R7, R29, B291	#@cmpI_branch  P=0.001000 C=-1.000000

1044    B193: #	out( B194 ) &lt;- in( B293 B294 B291 B192 B191 B216 B214 )  Freq: 0.221171
1044 +  li R28, #-1	# int, #@loadConI
1048 +  sw  R28, [R9, #12]	# int, #@storeI ! Field: java/util/stream/Streams$AbstractStreamBuilderImpl.count

104c    B194: #	out( B282 B195 ) &lt;- in( B193 B258 )  Freq: 0.222185
104c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
104c    lb  R7, [R23, #56]	# byte, #@loadB
1050 +  bne  R7, zr, B282	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1054    B195: #	out( B285 B196 ) &lt;- in( B381 B284 B282 B194 )  Freq: 0.222185
1054 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1054    lb  R28, [R23, #56]	# byte, #@loadB
1058 +  lwu  R18, [R19, #28]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceStage
105c +  bne  R28, zr, B285	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1060    B196: #	out( B456 B197 ) &lt;- in( B382 B287 B285 B195 )  Freq: 0.222185
1060 +  li R28, #1	# int, #@loadConI
1064 +  decode_heap_oop  R7, R18	#@decodeHeapOop
1068 +  sb  R28, [R19, #24]	# byte, #@storeB ! Field: java/util/stream/AbstractPipeline.linkedOrConsumed
106c +  sw  rheapbase, [R19, #44]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/util/stream/AbstractPipeline.sourceSupplier
1070 +  sw  rheapbase, [R19, #40]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/util/stream/AbstractPipeline.sourceSpliterator
1074    lwu  R7, [R7, #48]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceCloseAction
1078    NullCheck R7

1078    B197: #	out( B98 B198 ) &lt;- in( B196 )  Freq: 0.222184
1078 +  decode_heap_oop  R8, R7	#@decodeHeapOop
107c +  beq   R8, zr, B98	#@cmpP_imm0_branch  P=1.000000 C=1791.000000

1080    B198: #	out( N5509 ) &lt;- in( B197 )  Freq: 1.05946e-07
1080 +  li R11, #-187	# int, #@loadConI
1084    spill R19 -&gt; [sp, #0]	# spill size = 64
1088    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.AbstractPipeline::close @ bci:22 (line 320) L[0]=sp + #0 L[1]=_ STK[0]=R8
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:94 (line 283) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=4236/0x108c}
108c    #@ShouldNotReachHere

1098    B199: #	out( B333 B200 ) &lt;- in( B113 )  Freq: 0.0373125
1098 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1098    ld  R9, [R23, #288]	# ptr, #@loadP
109c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
109c    ld  R28, [R23, #304]	# ptr, #@loadP
10a0 +  addi  R30, R9, #32	# ptr, #@addP_reg_imm
10a4 +  bgeu  R30, R28, B333	#@cmpP_branch  P=0.000100 C=-1.000000

10a8    B200: #	out( B201 ) &lt;- in( B199 )  Freq: 0.0373088
10a8 +  li R7, #1	# long, #@loadConL
10ac +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
10ac    sd  R30, [R23, #288]	# ptr, #@storeP
10b0 +  sd  R7, [R9]	# long, #@storeL
10b4 +  mv  R7, narrowklass: precise klass java/util/HashMap$Node: 0x00000040d81c94e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
10c4 +  sw  R7, [R9, #8]	# compressed klass ptr, #@storeNKlass
10c8 +  sw  zr, [R9, #12]	# int, #@storeimmI0
10cc +  sw  zr, [R9, #16]	# int, #@storeimmI0
10d0 +  sd  zr, [R9, #24]	# long, #@storeimmL0

10d4    B201: #	out( B417 B202 ) &lt;- in( B334 B200 )  Freq: 0.0373125
10d4 +  mv  R28, narrowoop: java/lang/Object:exact *	# compressed ptr, #@loadConN
10e4 +  sw  R28, [R9, #20]	# compressed ptr, #@storeN
10e8    
10e8 +  # checkcastPP of R9, #@checkCastPP
10e8    sw  R29, [R9, #16]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.key
10ec +  sw  R20, [R9, #12]	# int, #@storeI ! Field: java/util/HashMap$Node.hash
10f0 +  #@membar_release
	fence iorw ow
10f4 +  lwu  R28, [R22, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
10f8 +  mv  R7, narrowklass: precise klass [Ljava/util/HashMap$Node;: 0x00000040d81c95b0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1108 +  far_bne  R28, R7, B417	#@far_cmpN_branch  P=0.000001 C=-1.000000

1110    B202: #	out( B297 B203 ) &lt;- in( B201 )  Freq: 0.0373125
1110 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1110    lb  R28, [R23, #56]	# byte, #@loadB
1114 +  bne  R28, zr, B297	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1118    B203: #	out( B205 B204 ) &lt;- in( B419 B299 B297 B202 )  Freq: 0.0373125
1118 +  mv  R28, R24	# ptr -&gt; long, #@castP2X
111c +  mv  R7, R9	# ptr -&gt; long, #@castP2X
1120 +  xorr  R7, R7, R28	#@xorL_reg_reg
1124 +  encode_heap_oop  R29, R9	#@encodeHeapOop
1128 +  srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
112c +  sw  R29, [R24]	# compressed ptr, #@storeN
1130 +  beq  R7, zr, B205	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1134    B204: #	out( B300 B205 ) &lt;- in( B203 )  Freq: 0.0372752
1134 +  srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1138 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1144 +  add R10, R28, R7	# ptr, #@addP_reg_reg
1148 +  lb  R28, [R10]	# byte, #@loadB
114c +  li R7, #4	# int, #@loadConI
1150 +  bne  R28, R7, B300	#@cmpI_branch  P=0.001000 C=-1.000000

1154    B205: #	out( B143 B206 ) &lt;- in( B227 B302 B303 B300 B204 B203 )  Freq: 0.050606
1154 +  lw  R29, [R21, #24]	# int, #@loadI ! Field: java/util/HashMap.modCount
1158 +  lw  R7, [R21, #20]	# int, #@loadI ! Field: java/util/HashMap.size
115c +  addiw  R30, R29, #1	#@addI_reg_imm
1160 +  addiw  R7, R7, #1	#@addI_reg_imm
1164 +  lw  R28, [R21, #28]	# int, #@loadI ! Field: java/util/HashMap.threshold
1168 +  sw  R30, [R21, #24]	# int, #@storeI ! Field: java/util/HashMap.modCount
116c +  sw  R7, [R21, #20]	# int, #@storeI ! Field: java/util/HashMap.size
1170 +  ble  R7, R28, B143	#@cmpI_branch  P=0.952239 C=335.000000

1174    B206: #	out( B492 B207 ) &lt;- in( B205 )  Freq: 0.002417
1174 +  spill R19 -&gt; [sp, #8]	# spill size = 64
1178 +  spill R18 -&gt; [sp, #0]	# spill size = 64
117c +  spill R21 -&gt; R8	# spill size = 64
1180 +  spill R21 -&gt; R11	# spill size = 64
1184    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:288 (line 661) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=4488/0x1188}

1188    B207: #	out( B143 ) &lt;- in( B206 )  Freq: 0.00241696
        # Block is sole successor of call
1188 +  spill [sp, #0] -&gt; R18	# spill size = 64
118c +  spill [sp, #8] -&gt; R19	# spill size = 64
1190 +  j  B143	#@branch

1194    B208: #	out( B335 B209 ) &lt;- in( B163 )  Freq: 0.0248769
1194 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1194    ld  R18, [R23, #288]	# ptr, #@loadP
1198 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1198    ld  R28, [R23, #304]	# ptr, #@loadP
119c +  addi  R31, R18, #32	# ptr, #@addP_reg_imm
11a0 +  bgeu  R31, R28, B335	#@cmpP_branch  P=0.000100 C=-1.000000

11a4    B209: #	out( B210 ) &lt;- in( B208 )  Freq: 0.0248744
11a4 +  li R7, #1	# long, #@loadConL
11a8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
11a8    sd  R31, [R23, #288]	# ptr, #@storeP
11ac +  sd  R7, [R18]	# long, #@storeL
11b0 +  mv  R7, narrowklass: precise klass java/util/HashMap$Node: 0x00000040d81c94e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
11c0 +  sw  R7, [R18, #8]	# compressed klass ptr, #@storeNKlass
11c4 +  sw  zr, [R18, #12]	# int, #@storeimmI0
11c8 +  sw  zr, [R18, #16]	# int, #@storeimmI0
11cc +  sd  zr, [R18, #24]	# long, #@storeimmL0

11d0    B210: #	out( B418 B211 ) &lt;- in( B336 B209 )  Freq: 0.0248769
11d0 +  mv  R28, narrowoop: java/lang/Object:exact *	# compressed ptr, #@loadConN
11e0 +  sw  R28, [R18, #20]	# compressed ptr, #@storeN
11e4    
11e4 +  # checkcastPP of R18, #@checkCastPP
11e4    sw  R30, [R18, #16]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.key
11e8 +  sw  R21, [R18, #12]	# int, #@storeI ! Field: java/util/HashMap$Node.hash
11ec +  #@membar_release
	fence iorw ow
11f0 +  lwu  R7, [R22, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
11f4 +  mv  R30, narrowklass: precise klass [Ljava/util/HashMap$Node;: 0x00000040d81c95b0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1204 +  far_bne  R7, R30, B418	#@far_cmpN_branch  P=0.000001 C=-1.000000

120c    B211: #	out( B308 B212 ) &lt;- in( B210 )  Freq: 0.0248769
120c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
120c    lb  R7, [R23, #56]	# byte, #@loadB
1210 +  bne  R7, zr, B308	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1214    B212: #	out( B214 B213 ) &lt;- in( B420 B310 B308 B211 )  Freq: 0.0248769
1214 +  mv  R28, R25	# ptr -&gt; long, #@castP2X
1218 +  mv  R7, R18	# ptr -&gt; long, #@castP2X
121c +  xorr  R7, R7, R28	#@xorL_reg_reg
1220 +  encode_heap_oop  R30, R18	#@encodeHeapOop
1224 +  srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
1228 +  sw  R30, [R25]	# compressed ptr, #@storeN
122c +  beq  R7, zr, B214	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1230    B213: #	out( B311 B214 ) &lt;- in( B212 )  Freq: 0.024852
1230 +  srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1234 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1240 +  add R10, R28, R7	# ptr, #@addP_reg_reg
1244 +  lb  R7, [R10]	# byte, #@loadB
1248 +  li R28, #4	# int, #@loadConI
124c +  bne  R7, R28, B311	#@cmpI_branch  P=0.001000 C=-1.000000

1250    B214: #	out( B193 B215 ) &lt;- in( B240 B313 B314 B311 B213 B212 )  Freq: 0.0337399
1250 +  lw  R7, [R20, #24]	# int, #@loadI ! Field: java/util/HashMap.modCount
1254 +  lw  R28, [R20, #20]	# int, #@loadI ! Field: java/util/HashMap.size
1258 +  addiw  R7, R7, #1	#@addI_reg_imm
125c +  addiw  R29, R28, #1	#@addI_reg_imm
1260 +  lw  R30, [R20, #28]	# int, #@loadI ! Field: java/util/HashMap.threshold
1264 +  sw  R7, [R20, #24]	# int, #@storeI ! Field: java/util/HashMap.modCount
1268 +  sw  R29, [R20, #20]	# int, #@storeI ! Field: java/util/HashMap.size
126c +  ble  R29, R30, B193	#@cmpI_branch  P=0.952239 C=335.000000

1270    B215: #	out( B491 B216 ) &lt;- in( B214 )  Freq: 0.00161146
1270 +  spill R20 -&gt; [sp, #8]	# spill size = 64
1274 +  spill R9 -&gt; [sp, #0]	# spill size = 64
1278 +  spill R19 -&gt; R8	# spill size = 64
127c +  spill R20 -&gt; R11	# spill size = 64
1280    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:288 (line 661) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=4740/0x1284}

1284    B216: #	out( B193 ) &lt;- in( B215 )  Freq: 0.00161143
        # Block is sole successor of call
1284 +  spill R8 -&gt; R19	# spill size = 64
1288 +  spill [sp, #0] -&gt; R9	# spill size = 64
128c +  j  B193	#@branch

1290    B217: #	out( B222 B218 ) &lt;- in( B118 )  Freq: 0.0194871
1290 +  addiw  R9, R9, #1	#@addI_reg_imm
1294 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1294    ld  R31, [R23, #920]	# ptr, #@loadP
1298 +  lwu zr, [R31]	# Safepoint: poll for GC, #@safePoint        # java.util.HashMap::putVal @ bci:219 (line 638) L[0]=R21 L[1]=R20 L[2]=R7 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=R22 L[7]=R24 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=R9
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=R19 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R18 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {t2=Oop x29=NarrowOop x18=Oop x19=Oop xdispatch=Oop xbcp=Oop xlocals=Oop off=4760/0x1298}
129c +  lwu  R31, [R24, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
12a0 +  decode_heap_oop  R31, R31	#@decodeHeapOop
12a4 +  beq   R31, zr, B222	#@cmpP_imm0_branch  P=0.083176 C=129.000000

12a8    B218: #	out( B118 ) &lt;- in( B217 )  Freq: 0.0178662
12a8 +  spill R31 -&gt; R24	# spill size = 64
12ac +  j  B118	#@branch

12b0    B219: #	out( B234 B220 ) &lt;- in( B168 )  Freq: 0.0129924
12b0 +  addiw  R28, R28, #1	#@addI_reg_imm
12b4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
12b4    ld  R15, [R23, #920]	# ptr, #@loadP
12b8 +  lwu zr, [R15]	# Safepoint: poll for GC, #@safePoint        # java.util.HashMap::putVal @ bci:219 (line 638) L[0]=R20 L[1]=R21 L[2]=R7 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=R22 L[7]=R12 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=R28
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=R9 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R19 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {t2=Oop x30=NarrowOop c_rarg2=Oop x9=Oop x19=Oop esp=Oop xbcp=Oop off=4792/0x12b8}
12bc +  lwu  R10, [R12, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
12c0 +  decode_heap_oop  R29, R10	#@decodeHeapOop
12c4 +  beq   R29, zr, B234	#@cmpP_imm0_branch  P=0.083176 C=129.000000

12c8    B220: #	out( B168 ) &lt;- in( B219 )  Freq: 0.0119117
12c8 +  spill R29 -&gt; R12	# spill size = 64
12cc +  j  B168	#@branch

12d0    B221: #	out( B222 ) &lt;- in( B116 )  Freq: 0.0116727
12d0 +  spill R9 -&gt; R28	# spill size = 64
12d4 +  li R9, #0	# int, #@loadConI
12d8    spill R28 -&gt; R24	# spill size = 64

12dc    B222: #	out( B337 B223 ) &lt;- in( B217 B221 )  Freq: 0.0132935
12dc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
12dc    ld  R25, [R23, #288]	# ptr, #@loadP
12e0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
12e0    ld  R28, [R23, #304]	# ptr, #@loadP
12e4 +  addi  R30, R25, #32	# ptr, #@addP_reg_imm
12e8 +  bgeu  R30, R28, B337	#@cmpP_branch  P=0.000100 C=-1.000000

12ec    B223: #	out( B224 ) &lt;- in( B222 )  Freq: 0.0132922
12ec +  li R7, #1	# long, #@loadConL
12f0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
12f0    sd  R30, [R23, #288]	# ptr, #@storeP
12f4 +  sd  R7, [R25]	# long, #@storeL
12f8 +  mv  R7, narrowklass: precise klass java/util/HashMap$Node: 0x00000040d81c94e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1308 +  sw  R7, [R25, #8]	# compressed klass ptr, #@storeNKlass
130c +  sw  zr, [R25, #12]	# int, #@storeimmI0
1310 +  sw  zr, [R25, #16]	# int, #@storeimmI0
1314 +  sd  zr, [R25, #24]	# long, #@storeimmL0

1318    B224: #	out( B319 B225 ) &lt;- in( B338 B223 )  Freq: 0.0132935
1318 +  mv  R28, narrowoop: java/lang/Object:exact *	# compressed ptr, #@loadConN
1328 +  sw  R28, [R25, #20]	# compressed ptr, #@storeN
132c    
132c +  # checkcastPP of R25, #@checkCastPP
132c    sw  R29, [R25, #16]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.key
1330 +  sw  R20, [R25, #12]	# int, #@storeI ! Field: java/util/HashMap$Node.hash
1334 +  #@membar_release
	fence iorw ow
1338 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1338    lb  R28, [R23, #56]	# byte, #@loadB
133c +  bne  R28, zr, B319	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1340    B225: #	out( B227 B226 ) &lt;- in( B421 B321 B319 B224 )  Freq: 0.0132935
1340 +  mv  R28, R24	# ptr -&gt; long, #@castP2X
1344 +  mv  R7, R25	# ptr -&gt; long, #@castP2X
1348 +  xorr  R7, R7, R28	#@xorL_reg_reg
134c +  encode_heap_oop  R29, R25	#@encodeHeapOop
1350 +  srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
1354 +  sw  R29, [R24, #24]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.next
1358 +  beq  R7, zr, B227	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

135c    B226: #	out( B322 B227 ) &lt;- in( B225 )  Freq: 0.0132802
135c +  srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1360 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
136c +  add R10, R28, R7	# ptr, #@addP_reg_reg
1370 +  lb  R28, [R10]	# byte, #@loadB
1374 +  li R7, #4	# int, #@loadConI
1378 +  bne  R28, R7, B322	#@cmpI_branch  P=0.001000 C=-1.000000

137c    B227: #	out( B205 B228 ) &lt;- in( B324 B325 B322 B226 B225 )  Freq: 0.0132935
137c +  li R28, #7	# int, #@loadConI
1380 +  blt  R9, R28, B205	#@cmpI_branch  P=1.000000 C=88.000000

1384    B228: #	out( N5509 ) &lt;- in( B227 )  Freq: 6.33884e-09
1384 +  li R11, #-187	# int, #@loadConI
1388    spill R18 -&gt; R8	# spill size = 64
138c +  spill R19 -&gt; [sp, #0]	# spill size = 64
1390 +  spill R21 -&gt; [sp, #8]	# spill size = 64
1394 +  spill R20 -&gt; [sp, #16]	# spill size = 32
1398 +  spill R22 -&gt; [sp, #24]	# spill size = 64
139c +  spill R9 -&gt; [sp, #20]	# spill size = 32
13a0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:162 (line 641) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=_ STK[0]=sp + #20 STK[1]=#7
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop off=5028/0x13a4}
13a4    #@ShouldNotReachHere

13b0    B229: #	out( B498 B230 ) &lt;- in( B110 )  Freq: 0.0105744
13b0 +  spill R20 -&gt; [sp, #40]	# spill size = 32
13b4 +  spill R30 -&gt; [sp, #20]	# spill size = 32
13b8 +  spill R21 -&gt; [sp, #32]	# spill size = 64
13bc +  spill R7 -&gt; [sp, #24]	# spill size = 64
13c0 +  spill R29 -&gt; [sp, #16]	# spill size = 32
13c4 +  spill R19 -&gt; [sp, #8]	# spill size = 64
13c8 +  spill R18 -&gt; [sp, #0]	# spill size = 64
13cc +  spill R28 -&gt; R8	# spill size = 32
13d0 +  spill R21 -&gt; R11	# spill size = 64
13d4    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:20 (line 627) L[0]=sp + #32 L[1]=sp + #40 L[2]=sp + #24 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=NarrowOop [24]=Oop [32]=Oop off=5080/0x13d8}

13d8    B230: #	out( B471 B231 ) &lt;- in( B229 )  Freq: 0.0105742
        # Block is sole successor of call
13d8 +  spill R10 -&gt; R22	# spill size = 64
13dc    lwu  R31, [R10, #12]	# range, #@loadRange
13e0    NullCheck R10

13e0    B231: #	out( B112 ) &lt;- in( B230 )  Freq: 0.0105742
13e0 +  spill R8 -&gt; R28	# spill size = 32
13e4 +  spill [sp, #0] -&gt; R18	# spill size = 64
13e8 +  spill [sp, #8] -&gt; R19	# spill size = 64
13ec +  spill [sp, #16] -&gt; R29	# spill size = 32
13f0 +  spill [sp, #24] -&gt; R7	# spill size = 64
13f4 +  spill [sp, #32] -&gt; R21	# spill size = 64
13f8 +  spill [sp, #20] -&gt; R30	# spill size = 32
13fc +  spill [sp, #40] -&gt; R20	# spill size = 32
1400 +  j  B112	#@branch

1404    B232: #	out( B233 ) &lt;- in( B43 )  Freq: 0.00958354
1404 +  li R28, #0	# int, #@loadConI

1408    B233: #	out( B110 ) &lt;- in( B108 B232 )  Freq: 0.00964068
1408 +  li R31, #1	# int, #@loadConI
140c +  sb  R31, [R14, #17]	# byte, #@storeB ! Field: java/lang/String.hashIsZero
1410 +  li R10, #0	# int, #@loadConI
1414 +  j  B110	#@branch

1418    B234: #	out( B235 ) &lt;- in( B219 )  Freq: 0.00108065
1418 +  spill R28 -&gt; R18	# spill size = 32
141c +  spill R12 -&gt; R24	# spill size = 64

1420    B235: #	out( B339 B236 ) &lt;- in( B234 B166 )  Freq: 0.00886301
1420 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1420    ld  R25, [R23, #288]	# ptr, #@loadP
1424 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1424    ld  R28, [R23, #304]	# ptr, #@loadP
1428 +  addi  R29, R25, #32	# ptr, #@addP_reg_imm
142c +  bgeu  R29, R28, B339	#@cmpP_branch  P=0.000100 C=-1.000000

1430    B236: #	out( B237 ) &lt;- in( B235 )  Freq: 0.00886213
1430 +  li R7, #1	# long, #@loadConL
1434 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1434    sd  R29, [R23, #288]	# ptr, #@storeP
1438 +  sd  R7, [R25]	# long, #@storeL
143c +  mv  R7, narrowklass: precise klass java/util/HashMap$Node: 0x00000040d81c94e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
144c +  sw  R7, [R25, #8]	# compressed klass ptr, #@storeNKlass
1450 +  sw  zr, [R25, #12]	# int, #@storeimmI0
1454 +  sw  zr, [R25, #16]	# int, #@storeimmI0
1458 +  sd  zr, [R25, #24]	# long, #@storeimmL0

145c    B237: #	out( B326 B238 ) &lt;- in( B340 B236 )  Freq: 0.00886301
145c +  mv  R28, narrowoop: java/lang/Object:exact *	# compressed ptr, #@loadConN
146c +  sw  R28, [R25, #20]	# compressed ptr, #@storeN
1470    
1470 +  # checkcastPP of R25, #@checkCastPP
1470    sw  R30, [R25, #16]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.key
1474 +  sw  R21, [R25, #12]	# int, #@storeI ! Field: java/util/HashMap$Node.hash
1478 +  #@membar_release
	fence iorw ow
147c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
147c    lb  R7, [R23, #56]	# byte, #@loadB
1480 +  bne  R7, zr, B326	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1484    B238: #	out( B240 B239 ) &lt;- in( B422 B328 B326 B237 )  Freq: 0.00886301
1484 +  mv  R28, R24	# ptr -&gt; long, #@castP2X
1488 +  mv  R7, R25	# ptr -&gt; long, #@castP2X
148c +  xorr  R7, R7, R28	#@xorL_reg_reg
1490 +  encode_heap_oop  R30, R25	#@encodeHeapOop
1494 +  srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
1498 +  sw  R30, [R24, #24]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.next
149c +  beq  R7, zr, B240	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

14a0    B239: #	out( B329 B240 ) &lt;- in( B238 )  Freq: 0.00885415
14a0 +  srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
14a4 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
14b0 +  add R10, R28, R7	# ptr, #@addP_reg_reg
14b4 +  lb  R7, [R10]	# byte, #@loadB
14b8 +  li R28, #4	# int, #@loadConI
14bc +  bne  R7, R28, B329	#@cmpI_branch  P=0.001000 C=-1.000000

14c0    B240: #	out( B214 B241 ) &lt;- in( B331 B332 B329 B239 B238 )  Freq: 0.00886301
14c0 +  li R28, #7	# int, #@loadConI
14c4 +  blt  R18, R28, B214	#@cmpI_branch  P=1.000000 C=88.000000

14c8    B241: #	out( N5509 ) &lt;- in( B240 )  Freq: 4.22621e-09
14c8 +  li R11, #-187	# int, #@loadConI
14cc    spill R18 -&gt; R8	# spill size = 32
14d0 +  spill R19 -&gt; [sp, #0]	# spill size = 64
14d4 +  spill R9 -&gt; [sp, #8]	# spill size = 64
14d8 +  spill R20 -&gt; [sp, #16]	# spill size = 64
14dc +  spill R21 -&gt; [sp, #24]	# spill size = 32
14e0 +  spill R22 -&gt; [sp, #32]	# spill size = 64
14e4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:162 (line 641) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=_ STK[0]=R8 STK[1]=#7
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [32]=Oop off=5352/0x14e8}
14e8    #@ShouldNotReachHere

14f4    B242: #	out( B493 B243 ) &lt;- in( B160 )  Freq: 0.00705015
14f4 +  spill R21 -&gt; [sp, #36]	# spill size = 32
14f8 +  spill R31 -&gt; [sp, #32]	# spill size = 32
14fc +  spill R20 -&gt; [sp, #24]	# spill size = 64
1500 +  spill R7 -&gt; [sp, #16]	# spill size = 64
1504 +  spill R30 -&gt; [sp, #4]	# spill size = 32
1508 +  spill R9 -&gt; [sp, #8]	# spill size = 64
150c +  spill R19 -&gt; R8	# spill size = 64
1510 +  spill R18 -&gt; [sp, #0]	# spill size = 32
1514 +  spill R20 -&gt; R11	# spill size = 64
1518    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:20 (line 627) L[0]=sp + #24 L[1]=sp + #36 L[2]=sp + #16 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop off=5404/0x151c}

151c    B243: #	out( B472 B244 ) &lt;- in( B242 )  Freq: 0.00705001
        # Block is sole successor of call
151c +  spill R10 -&gt; R22	# spill size = 64
1520    lwu  R28, [R10, #12]	# range, #@loadRange
1524    NullCheck R10

1524    B244: #	out( B162 ) &lt;- in( B243 )  Freq: 0.00705
1524 +  spill [sp, #0] -&gt; R18	# spill size = 32
1528 +  spill R8 -&gt; R19	# spill size = 64
152c +  spill [sp, #8] -&gt; R9	# spill size = 64
1530 +  spill [sp, #4] -&gt; R30	# spill size = 32
1534 +  spill [sp, #16] -&gt; R7	# spill size = 64
1538 +  spill [sp, #24] -&gt; R20	# spill size = 64
153c +  spill [sp, #32] -&gt; R31	# spill size = 32
1540 +  spill [sp, #36] -&gt; R21	# spill size = 32
1544 +  j  B162	#@branch

1548    B245: #	out( B500 B246 ) &lt;- in( B37 )  Freq: 0.00640726
1548 +  spill R30 -&gt; [sp, #12]	# spill size = 32
154c +  spill R21 -&gt; [sp, #24]	# spill size = 64
1550 +  spill R7 -&gt; [sp, #16]	# spill size = 64
1554 +  spill R29 -&gt; [sp, #8]	# spill size = 32
1558 +  spill R19 -&gt; R8	# spill size = 64
155c +  spill R18 -&gt; [sp, #0]	# spill size = 64
1560 +  spill R7 -&gt; R11	# spill size = 64
1564    CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #16 L[2]=#Ptr0x00000040d82922a0 STK[0]=sp + #24
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=R8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=NarrowOop [16]=Oop [24]=Oop off=5504/0x1580}

1580    B246: #	out( B110 ) &lt;- in( B245 )  Freq: 0.00640713
        # Block is sole successor of call
1580 +  li R28, #0	# int, #@loadConI
1584    spill [sp, #0] -&gt; R18	# spill size = 64
1588 +  spill R8 -&gt; R19	# spill size = 64
158c +  spill [sp, #8] -&gt; R29	# spill size = 32
1590 +  spill [sp, #16] -&gt; R7	# spill size = 64
1594 +  spill [sp, #24] -&gt; R21	# spill size = 64
1598 +  spill [sp, #12] -&gt; R30	# spill size = 32
159c +  j  B110	#@branch

15a0    B247: #	out( B248 ) &lt;- in( B91 )  Freq: 0.00638951
15a0 +  li R18, #0	# int, #@loadConI

15a4    B248: #	out( B160 ) &lt;- in( B158 B247 )  Freq: 0.00642761
15a4 +  li R28, #1	# int, #@loadConI
15a8 +  sb  R28, [R29, #17]	# byte, #@storeB ! Field: java/lang/String.hashIsZero
15ac +  li R10, #0	# int, #@loadConI
15b0 +  j  B160	#@branch

15b4    B249: #	out( B495 B250 ) &lt;- in( B85 )  Freq: 0.00427183
15b4 +  spill R31 -&gt; [sp, #12]	# spill size = 32
15b8 +  spill R20 -&gt; [sp, #24]	# spill size = 64
15bc +  spill R7 -&gt; [sp, #16]	# spill size = 64
15c0 +  spill R30 -&gt; [sp, #8]	# spill size = 32
15c4 +  spill R9 -&gt; [sp, #0]	# spill size = 64
15c8 +  spill R19 -&gt; R8	# spill size = 64
15cc +  spill R7 -&gt; R11	# spill size = 64
15d0    CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #16 L[2]=#Ptr0x00000040d82922a0 STK[0]=sp + #24
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=NarrowOop [16]=Oop [24]=Oop off=5612/0x15ec}

15ec    B250: #	out( B160 ) &lt;- in( B249 )  Freq: 0.00427174
        # Block is sole successor of call
15ec +  li R18, #0	# int, #@loadConI
15f0    spill R8 -&gt; R19	# spill size = 64
15f4 +  spill [sp, #0] -&gt; R9	# spill size = 64
15f8 +  spill [sp, #8] -&gt; R30	# spill size = 32
15fc +  spill [sp, #16] -&gt; R7	# spill size = 64
1600 +  spill [sp, #24] -&gt; R20	# spill size = 64
1604 +  spill [sp, #12] -&gt; R31	# spill size = 32
1608 +  j  B160	#@branch

160c    B251: #	out( B423 B252 ) &lt;- in( B27 )  Freq: 0.00151973
160c +  mv  R7, narrowklass: precise klass java/util/Spliterators$EmptySpliterator$OfRef: 0x00000040d81e8d30:Constant:exact *	# compressed klass ptr, #@loadConNKlass
161c +  far_bne  R9, R7, B423	#@far_cmpN_branch  P=0.000001 C=-1.000000

1624    B252: #	out( B144 B253 ) &lt;- in( B251 )  Freq: 0.00151973
1624 +  bne   R30, zr, B144	#@cmpP_imm0_branch  P=1.000000 C=12850.000000

1628    B253: #	out( N5509 ) &lt;- in( B252 )  Freq: 7.24664e-10
1628 +  li R11, #-187	# int, #@loadConI
162c    spill R18 -&gt; R8	# spill size = 64
1630 +  spill R30 -&gt; [sp, #8]	# spill size = 64
1634    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.Objects::requireNonNull @ bci:1 (line 208) L[0]=sp + #8 STK[0]=sp + #8
        # java.util.Spliterators$EmptySpliterator::forEachRemaining @ bci:1 (line 894) L[0]=_ L[1]=_
        # java.util.Spliterators$EmptySpliterator$OfRef::forEachRemaining @ bci:2 (line 905) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop off=5688/0x1638}
1638    #@ShouldNotReachHere

1644    B254: #	out( B489 B255 ) &lt;- in( B11 )  Freq: 0.00148859
1644 +  spill R29 -&gt; R8	# spill size = 64
1648    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.util.stream.Stream::empty
        # java.util.Optional::stream @ bci:7 (line 335) L[0]=_
        # jdk.internal.module.ModulePath$$Lambda$10/0x000000080001e230::apply @ bci:4 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=5708/0x164c}

164c    B255: #	out( B424 B256 ) &lt;- in( B254 )  Freq: 0.00148856
        # Block is sole successor of call
164c +  far_beq   R10, zr, B424	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

1654    B256: #	out( B17 ) &lt;- in( B255 )  Freq: 0.00148856
1654 +  spill R8 -&gt; R29	# spill size = 64
1658 +  spill R10 -&gt; R18	# spill size = 64
165c +  j  B17	#@branch

1660    B257: #	out( B425 B258 ) &lt;- in( B75 )  Freq: 0.00101323
1660 +  mv  R28, narrowklass: precise klass java/util/Spliterators$EmptySpliterator$OfRef: 0x00000040d81e8d30:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1670 +  far_bne  R18, R28, B425	#@far_cmpN_branch  P=0.000001 C=-1.000000

1678    B258: #	out( B194 B259 ) &lt;- in( B257 )  Freq: 0.00101323
1678 +  bne   R29, zr, B194	#@cmpP_imm0_branch  P=1.000000 C=12850.000000

167c    B259: #	out( N5509 ) &lt;- in( B258 )  Freq: 4.83146e-10
167c +  li R11, #-187	# int, #@loadConI
1680    spill R19 -&gt; R8	# spill size = 64
1684 +  spill R29 -&gt; [sp, #8]	# spill size = 64
1688    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.Objects::requireNonNull @ bci:1 (line 208) L[0]=sp + #8 STK[0]=sp + #8
        # java.util.Spliterators$EmptySpliterator::forEachRemaining @ bci:1 (line 894) L[0]=_ L[1]=_
        # java.util.Spliterators$EmptySpliterator$OfRef::forEachRemaining @ bci:2 (line 905) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop off=5772/0x168c}
168c    #@ShouldNotReachHere

1698    B260: #	out( B487 B261 ) &lt;- in( B59 )  Freq: 0.00099247
1698 +  spill R30 -&gt; R8	# spill size = 64
169c    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.util.stream.Stream::empty
        # java.util.Optional::stream @ bci:7 (line 335) L[0]=_
        # jdk.internal.module.ModulePath$$Lambda$10/0x000000080001e230::apply @ bci:4 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=5792/0x16a0}

16a0    B261: #	out( B426 B262 ) &lt;- in( B260 )  Freq: 0.00099245
        # Block is sole successor of call
16a0 +  far_beq   R10, zr, B426	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

16a8    B262: #	out( B65 ) &lt;- in( B261 )  Freq: 0.000992449
16a8 +  spill R8 -&gt; R30	# spill size = 64
16ac +  spill R10 -&gt; R19	# spill size = 64
16b0 +  j  B65	#@branch

16b4    B263: #	out( B27 B264 ) &lt;- in( B26 )  Freq: 0.000333253
16b4 +  lwu  R7, [R31, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceSpliterator
16b8 +  decode_heap_oop  R10, R7	#@decodeHeapOop
16bc +  far_beq   R10, zr, B27	#@far_cmpP_imm0_branch  P=0.500000 C=-1.000000

16c4    B264: #	out( B355 B265 ) &lt;- in( B263 )  Freq: 0.000166627
16c4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16c4    ld  R7, [R23, #32]	# int, #@loadL
16c8 +  beq  R7, zr, B355	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

16cc    B265: #	out( B27 ) &lt;- in( B264 )  Freq: 0.00016646
16cc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16cc    ld  R28, [R23, #48]	# ptr, #@loadP
16d0 +  add R28, R28, R7	# ptr, #@addP_reg_reg
16d4 +  addi  R7, R7, #-8	#@addL_reg_imm
16d8 +  sd  R10, [R28, #-8]	# ptr, #@storeP
16dc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16dc    sd  R7, [R23, #32]	# long, #@storeL
16e0 +  j  B27	#@branch

16e4    B266: #	out( B145 B267 ) &lt;- in( B144 )  Freq: 0.000333248
16e4 +  lwu  R7, [R18, #44]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceSupplier
16e8 +  decode_heap_oop  R10, R7	#@decodeHeapOop
16ec +  beq   R10, zr, B145	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

16f0    B267: #	out( B356 B268 ) &lt;- in( B266 )  Freq: 0.000166624
16f0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16f0    ld  R7, [R23, #32]	# int, #@loadL
16f4 +  beq  R7, zr, B356	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

16f8    B268: #	out( B145 ) &lt;- in( B267 )  Freq: 0.000166457
16f8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16f8    ld  R28, [R23, #48]	# ptr, #@loadP
16fc +  add R28, R28, R7	# ptr, #@addP_reg_reg
1700 +  addi  R7, R7, #-8	#@addL_reg_imm
1704 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1708 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1708    sd  R7, [R23, #32]	# long, #@storeL
170c +  j  B145	#@branch

1710    B269: #	out( B146 B270 ) &lt;- in( B145 )  Freq: 0.000333248
1710 +  lwu  R28, [R18, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceSpliterator
1714 +  decode_heap_oop  R10, R28	#@decodeHeapOop
1718 +  beq   R10, zr, B146	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

171c    B270: #	out( B357 B271 ) &lt;- in( B269 )  Freq: 0.000166624
171c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
171c    ld  R7, [R23, #32]	# int, #@loadL
1720 +  beq  R7, zr, B357	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1724    B271: #	out( B146 ) &lt;- in( B270 )  Freq: 0.000166457
1724 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1724    ld  R28, [R23, #48]	# ptr, #@loadP
1728 +  add R28, R28, R7	# ptr, #@addP_reg_reg
172c +  addi  R7, R7, #-8	#@addL_reg_imm
1730 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1734 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1734    sd  R7, [R23, #32]	# long, #@storeL
1738 +  j  B146	#@branch

173c    B272: #	out( B141 B273 ) &lt;- in( B140 )  Freq: 0.000281123
173c +  lwu  R28, [R9, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.value
1740 +  decode_heap_oop  R10, R28	#@decodeHeapOop
1744 +  beq   R10, zr, B141	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1748    B273: #	out( B372 B274 ) &lt;- in( B272 )  Freq: 0.000140561
1748 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1748    ld  R7, [R23, #32]	# int, #@loadL
174c +  beq  R7, zr, B372	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1750    B274: #	out( B141 ) &lt;- in( B273 )  Freq: 0.000140421
1750 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1750    ld  R28, [R23, #48]	# ptr, #@loadP
1754 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1758 +  addi  R7, R7, #-8	#@addL_reg_imm
175c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1760 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1760    sd  R7, [R23, #32]	# long, #@storeL
1764 +  j  B141	#@branch

1768    B275: #	out( B143 B276 ) &lt;- in( B142 )  Freq: 0.000280845
1768 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1768    ld  R7, [R23, #64]	# int, #@loadL
176c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
176c    ld  R28, [R23, #80]	# ptr, #@loadP
1770 +  #@membar_volatile
	fence iorw iorw
1774 +  lb  R29, [R10]	# byte, #@loadB
1778 +  beq  R29, zr, B143	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

177c    B276: #	out( B278 B277 ) &lt;- in( B275 )  Freq: 0.000140423
177c +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1780 +  bne  R7, zr, B278	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1784    B277: #	out( B143 ) &lt;- in( B276 )  Freq: 7.02113e-05
1784 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1784    spill R23 -&gt; R11	# spill size = 64
1788 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
17b8 +  j  B143	#@branch

17bc    B278: #	out( B143 ) &lt;- in( B276 )  Freq: 7.02113e-05
17bc +  add R28, R28, R7	# ptr, #@addP_reg_reg
17c0 +  addi  R7, R7, #-8	#@addL_reg_imm
17c4 +  sd  R10, [R28, #-8]	# ptr, #@storeP
17c8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
17c8    sd  R7, [R23, #64]	# long, #@storeL
17cc +  j  B143	#@branch

17d0    B279: #	out( B75 B280 ) &lt;- in( B74 )  Freq: 0.000222186
17d0 +  lwu  R28, [R31, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceSpliterator
17d4 +  decode_heap_oop  R10, R28	#@decodeHeapOop
17d8 +  far_beq   R10, zr, B75	#@far_cmpP_imm0_branch  P=0.500000 C=-1.000000

17e0    B280: #	out( B380 B281 ) &lt;- in( B279 )  Freq: 0.000111093
17e0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
17e0    ld  R7, [R23, #32]	# int, #@loadL
17e4 +  beq  R7, zr, B380	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

17e8    B281: #	out( B75 ) &lt;- in( B280 )  Freq: 0.000110982
17e8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
17e8    ld  R28, [R23, #48]	# ptr, #@loadP
17ec +  add R28, R28, R7	# ptr, #@addP_reg_reg
17f0 +  addi  R7, R7, #-8	#@addL_reg_imm
17f4 +  sd  R10, [R28, #-8]	# ptr, #@storeP
17f8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
17f8    sd  R7, [R23, #32]	# long, #@storeL
17fc +  j  B75	#@branch

1800    B282: #	out( B195 B283 ) &lt;- in( B194 )  Freq: 0.000222182
1800 +  lwu  R28, [R19, #44]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceSupplier
1804 +  decode_heap_oop  R10, R28	#@decodeHeapOop
1808 +  beq   R10, zr, B195	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

180c    B283: #	out( B381 B284 ) &lt;- in( B282 )  Freq: 0.000111091
180c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
180c    ld  R7, [R23, #32]	# int, #@loadL
1810 +  beq  R7, zr, B381	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1814    B284: #	out( B195 ) &lt;- in( B283 )  Freq: 0.00011098
1814 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1814    ld  R28, [R23, #48]	# ptr, #@loadP
1818 +  add R28, R28, R7	# ptr, #@addP_reg_reg
181c +  addi  R7, R7, #-8	#@addL_reg_imm
1820 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1824 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1824    sd  R7, [R23, #32]	# long, #@storeL
1828 +  j  B195	#@branch

182c    B285: #	out( B196 B286 ) &lt;- in( B195 )  Freq: 0.000222182
182c +  lwu  R7, [R19, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/AbstractPipeline.sourceSpliterator
1830 +  decode_heap_oop  R10, R7	#@decodeHeapOop
1834 +  beq   R10, zr, B196	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1838    B286: #	out( B382 B287 ) &lt;- in( B285 )  Freq: 0.000111091
1838 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1838    ld  R7, [R23, #32]	# int, #@loadL
183c +  beq  R7, zr, B382	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1840    B287: #	out( B196 ) &lt;- in( B286 )  Freq: 0.00011098
1840 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1840    ld  R28, [R23, #48]	# ptr, #@loadP
1844 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1848 +  addi  R7, R7, #-8	#@addL_reg_imm
184c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1850 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1850    sd  R7, [R23, #32]	# long, #@storeL
1854 +  j  B196	#@branch

1858    B288: #	out( B191 B289 ) &lt;- in( B190 )  Freq: 0.000187429
1858 +  lwu  R7, [R24, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.value
185c +  decode_heap_oop  R10, R7	#@decodeHeapOop
1860 +  beq   R10, zr, B191	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1864    B289: #	out( B397 B290 ) &lt;- in( B288 )  Freq: 9.37146e-05
1864 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1864    ld  R7, [R23, #32]	# int, #@loadL
1868 +  beq  R7, zr, B397	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

186c    B290: #	out( B191 ) &lt;- in( B289 )  Freq: 9.36209e-05
186c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
186c    ld  R28, [R23, #48]	# ptr, #@loadP
1870 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1874 +  addi  R7, R7, #-8	#@addL_reg_imm
1878 +  sd  R10, [R28, #-8]	# ptr, #@storeP
187c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
187c    sd  R7, [R23, #32]	# long, #@storeL
1880 +  j  B191	#@branch

1884    B291: #	out( B193 B292 ) &lt;- in( B192 )  Freq: 0.000187244
1884 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1884    ld  R7, [R23, #64]	# int, #@loadL
1888 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1888    ld  R28, [R23, #80]	# ptr, #@loadP
188c +  #@membar_volatile
	fence iorw iorw
1890 +  lb  R30, [R10]	# byte, #@loadB
1894 +  beq  R30, zr, B193	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1898    B292: #	out( B294 B293 ) &lt;- in( B291 )  Freq: 9.36221e-05
1898 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
189c +  bne  R7, zr, B294	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

18a0    B293: #	out( B193 ) &lt;- in( B292 )  Freq: 4.6811e-05
18a0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
18a0    spill R23 -&gt; R11	# spill size = 64
18a4 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
18d4 +  j  B193	#@branch

18d8    B294: #	out( B193 ) &lt;- in( B292 )  Freq: 4.6811e-05
18d8 +  add R28, R28, R7	# ptr, #@addP_reg_reg
18dc +  addi  R7, R7, #-8	#@addL_reg_imm
18e0 +  sd  R10, [R28, #-8]	# ptr, #@storeP
18e4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
18e4    sd  R7, [R23, #64]	# long, #@storeL
18e8 +  j  B193	#@branch

18ec    B295: #	out( B110 ) &lt;- in( B40 )  Freq: 0.000181609
18ec +  li R10, #0	# int, #@loadConI
18f0 +  li R28, #0	# int, #@loadConI
18f4 +  j  B110	#@branch

18f8    B296: #	out( B160 ) &lt;- in( B88 )  Freq: 0.000121082
18f8 +  li R10, #0	# int, #@loadConI
18fc +  li R18, #0	# int, #@loadConI
1900 +  j  B160	#@branch

1904    B297: #	out( B203 B298 ) &lt;- in( B202 )  Freq: 3.7312e-05
1904 +  lwu  R7, [R24]	# loadN, compressed ptr, #@loadN
1908 +  decode_heap_oop  R10, R7	#@decodeHeapOop
190c +  beq   R10, zr, B203	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1910    B298: #	out( B419 B299 ) &lt;- in( B297 )  Freq: 1.8656e-05
1910 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1910    ld  R7, [R23, #32]	# int, #@loadL
1914 +  far_beq  R7, zr, B419	#@far_cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

191c    B299: #	out( B203 ) &lt;- in( B298 )  Freq: 1.86374e-05
191c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
191c    ld  R28, [R23, #48]	# ptr, #@loadP
1920 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1924 +  addi  R7, R7, #-8	#@addL_reg_imm
1928 +  sd  R10, [R28, #-8]	# ptr, #@storeP
192c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
192c    sd  R7, [R23, #32]	# long, #@storeL
1930 +  j  B203	#@branch

1934    B300: #	out( B205 B301 ) &lt;- in( B204 )  Freq: 3.72752e-05
1934 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1934    ld  R7, [R23, #64]	# int, #@loadL
1938 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1938    ld  R28, [R23, #80]	# ptr, #@loadP
193c +  #@membar_volatile
	fence iorw iorw
1940 +  lb  R29, [R10]	# byte, #@loadB
1944 +  beq  R29, zr, B205	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1948    B301: #	out( B303 B302 ) &lt;- in( B300 )  Freq: 1.86376e-05
1948 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
194c +  bne  R7, zr, B303	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1950    B302: #	out( B205 ) &lt;- in( B301 )  Freq: 9.3188e-06
1950 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1950    spill R23 -&gt; R11	# spill size = 64
1954 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1984 +  j  B205	#@branch

1988    B303: #	out( B205 ) &lt;- in( B301 )  Freq: 9.3188e-06
1988 +  add R28, R28, R7	# ptr, #@addP_reg_reg
198c +  addi  R7, R7, #-8	#@addL_reg_imm
1990 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1994 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1994    sd  R7, [R23, #64]	# long, #@storeL
1998 +  j  B205	#@branch

199c    B304: #	out( B485 B305 ) &lt;- in( B12 )  Freq: 3.31826e-05
199c +  spill R29 -&gt; [sp, #0]	# spill size = 64
19a0 +  mv  R11, precise klass java/util/stream/Streams$StreamBuilderImpl: 0x00000040d8403970:Constant:exact *	# ptr, #@loadConP
19b8    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.stream.Stream::of @ bci:0 (line 1398) L[0]=R8
        # java.util.Optional::stream @ bci:15 (line 337) L[0]=_
        # jdk.internal.module.ModulePath$$Lambda$10/0x000000080001e230::apply @ bci:4 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=NarrowOop off=6588/0x19bc}

19bc    B305: #	out( B14 ) &lt;- in( B304 )  Freq: 3.31819e-05
        # Block is sole successor of call
19bc +  spill [sp, #0] -&gt; R29	# spill size = 64
19c0 +  spill R10 -&gt; R30	# spill size = 64
19c4 +  j  B14	#@branch

19c8    B306: #	out( B486 B307 ) &lt;- in( B14 )  Freq: 3.31826e-05
19c8 +  spill R30 -&gt; [sp, #0]	# spill size = 64
19cc +  spill R29 -&gt; R8	# spill size = 64
19d0 +  mv  R11, precise klass java/util/stream/ReferencePipeline$Head: 0x00000040d81f3320:Constant:exact *	# ptr, #@loadConP
19e8    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.stream.StreamSupport::stream @ bci:5 (line 69) L[0]=sp + #0 L[1]=#0
        # java.util.stream.Stream::of @ bci:9 (line 1398) L[0]=_
        # java.util.Optional::stream @ bci:15 (line 337) L[0]=_
        # jdk.internal.module.ModulePath$$Lambda$10/0x000000080001e230::apply @ bci:4 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=6636/0x19ec}

19ec    B307: #	out( B16 ) &lt;- in( B306 )  Freq: 3.31819e-05
        # Block is sole successor of call
19ec +  spill R8 -&gt; R29	# spill size = 64
19f0 +  spill [sp, #0] -&gt; R30	# spill size = 64
19f4 +  j  B16	#@branch

19f8    B308: #	out( B212 B309 ) &lt;- in( B211 )  Freq: 2.48766e-05
19f8 +  lwu  R28, [R25]	# loadN, compressed ptr, #@loadN
19fc +  decode_heap_oop  R10, R28	#@decodeHeapOop
1a00 +  beq   R10, zr, B212	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1a04    B309: #	out( B420 B310 ) &lt;- in( B308 )  Freq: 1.24383e-05
1a04 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a04    ld  R7, [R23, #32]	# int, #@loadL
1a08 +  beq  R7, zr, B420	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1a0c    B310: #	out( B212 ) &lt;- in( B309 )  Freq: 1.24258e-05
1a0c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a0c    ld  R28, [R23, #48]	# ptr, #@loadP
1a10 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1a14 +  addi  R7, R7, #-8	#@addL_reg_imm
1a18 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1a1c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a1c    sd  R7, [R23, #32]	# long, #@storeL
1a20 +  j  B212	#@branch

1a24    B311: #	out( B214 B312 ) &lt;- in( B213 )  Freq: 2.4852e-05
1a24 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a24    ld  R7, [R23, #64]	# int, #@loadL
1a28 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a28    ld  R28, [R23, #80]	# ptr, #@loadP
1a2c +  #@membar_volatile
	fence iorw iorw
1a30 +  lb  R30, [R10]	# byte, #@loadB
1a34 +  beq  R30, zr, B214	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1a38    B312: #	out( B314 B313 ) &lt;- in( B311 )  Freq: 1.2426e-05
1a38 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1a3c +  bne  R7, zr, B314	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1a40    B313: #	out( B214 ) &lt;- in( B312 )  Freq: 6.213e-06
1a40 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a40    spill R23 -&gt; R11	# spill size = 64
1a44 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1a74 +  j  B214	#@branch

1a78    B314: #	out( B214 ) &lt;- in( B312 )  Freq: 6.213e-06
1a78 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1a7c +  addi  R7, R7, #-8	#@addL_reg_imm
1a80 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1a84 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a84    sd  R7, [R23, #64]	# long, #@storeL
1a88 +  j  B214	#@branch

1a8c    B315: #	out( B483 B316 ) &lt;- in( B60 )  Freq: 2.21234e-05
1a8c +  spill R30 -&gt; [sp, #0]	# spill size = 64
1a90 +  mv  R11, precise klass java/util/stream/Streams$StreamBuilderImpl: 0x00000040d8403970:Constant:exact *	# ptr, #@loadConP
1aa8    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.stream.Stream::of @ bci:0 (line 1398) L[0]=R8
        # java.util.Optional::stream @ bci:15 (line 337) L[0]=_
        # jdk.internal.module.ModulePath$$Lambda$10/0x000000080001e230::apply @ bci:4 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=NarrowOop off=6828/0x1aac}

1aac    B316: #	out( B62 ) &lt;- in( B315 )  Freq: 2.21229e-05
        # Block is sole successor of call
1aac +  spill [sp, #0] -&gt; R30	# spill size = 64
1ab0 +  spill R10 -&gt; R29	# spill size = 64
1ab4 +  j  B62	#@branch

1ab8    B317: #	out( B484 B318 ) &lt;- in( B62 )  Freq: 2.21234e-05
1ab8 +  spill R29 -&gt; [sp, #0]	# spill size = 64
1abc +  spill R30 -&gt; R8	# spill size = 64
1ac0 +  mv  R11, precise klass java/util/stream/ReferencePipeline$Head: 0x00000040d81f3320:Constant:exact *	# ptr, #@loadConP
1ad8    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.stream.StreamSupport::stream @ bci:5 (line 69) L[0]=sp + #0 L[1]=#0
        # java.util.stream.Stream::of @ bci:9 (line 1398) L[0]=_
        # java.util.Optional::stream @ bci:15 (line 337) L[0]=_
        # jdk.internal.module.ModulePath$$Lambda$10/0x000000080001e230::apply @ bci:4 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=6876/0x1adc}

1adc    B318: #	out( B64 ) &lt;- in( B317 )  Freq: 2.21229e-05
        # Block is sole successor of call
1adc +  spill R8 -&gt; R30	# spill size = 64
1ae0 +  spill [sp, #0] -&gt; R29	# spill size = 64
1ae4 +  j  B64	#@branch

1ae8    B319: #	out( B225 B320 ) &lt;- in( B224 )  Freq: 1.32933e-05
1ae8 +  lwu  R7, [R24, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
1aec +  decode_heap_oop  R10, R7	#@decodeHeapOop
1af0 +  beq   R10, zr, B225	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1af4    B320: #	out( B421 B321 ) &lt;- in( B319 )  Freq: 6.64667e-06
1af4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1af4    ld  R7, [R23, #32]	# int, #@loadL
1af8 +  beq  R7, zr, B421	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1afc    B321: #	out( B225 ) &lt;- in( B320 )  Freq: 6.64003e-06
1afc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1afc    ld  R28, [R23, #48]	# ptr, #@loadP
1b00 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1b04 +  addi  R7, R7, #-8	#@addL_reg_imm
1b08 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1b0c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b0c    sd  R7, [R23, #32]	# long, #@storeL
1b10 +  j  B225	#@branch

1b14    B322: #	out( B227 B323 ) &lt;- in( B226 )  Freq: 1.32802e-05
1b14 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b14    ld  R7, [R23, #64]	# int, #@loadL
1b18 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b18    ld  R28, [R23, #80]	# ptr, #@loadP
1b1c +  #@membar_volatile
	fence iorw iorw
1b20 +  lb  R29, [R10]	# byte, #@loadB
1b24 +  beq  R29, zr, B227	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1b28    B323: #	out( B325 B324 ) &lt;- in( B322 )  Freq: 6.64011e-06
1b28 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1b2c +  bne  R7, zr, B325	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1b30    B324: #	out( B227 ) &lt;- in( B323 )  Freq: 3.32006e-06
1b30 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b30    spill R23 -&gt; R11	# spill size = 64
1b34 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1b64 +  j  B227	#@branch

1b68    B325: #	out( B227 ) &lt;- in( B323 )  Freq: 3.32006e-06
1b68 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1b6c +  addi  R7, R7, #-8	#@addL_reg_imm
1b70 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1b74 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b74    sd  R7, [R23, #64]	# long, #@storeL
1b78 +  j  B227	#@branch

1b7c    B326: #	out( B238 B327 ) &lt;- in( B237 )  Freq: 8.8629e-06
1b7c +  lwu  R28, [R24, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
1b80 +  decode_heap_oop  R10, R28	#@decodeHeapOop
1b84 +  beq   R10, zr, B238	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1b88    B327: #	out( B422 B328 ) &lt;- in( B326 )  Freq: 4.43145e-06
1b88 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b88    ld  R7, [R23, #32]	# int, #@loadL
1b8c +  beq  R7, zr, B422	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1b90    B328: #	out( B238 ) &lt;- in( B327 )  Freq: 4.42702e-06
1b90 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b90    ld  R28, [R23, #48]	# ptr, #@loadP
1b94 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1b98 +  addi  R7, R7, #-8	#@addL_reg_imm
1b9c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1ba0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ba0    sd  R7, [R23, #32]	# long, #@storeL
1ba4 +  j  B238	#@branch

1ba8    B329: #	out( B240 B330 ) &lt;- in( B239 )  Freq: 8.85415e-06
1ba8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ba8    ld  R7, [R23, #64]	# int, #@loadL
1bac +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1bac    ld  R28, [R23, #80]	# ptr, #@loadP
1bb0 +  #@membar_volatile
	fence iorw iorw
1bb4 +  lb  R30, [R10]	# byte, #@loadB
1bb8 +  beq  R30, zr, B240	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1bbc    B330: #	out( B332 B331 ) &lt;- in( B329 )  Freq: 4.42708e-06
1bbc +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1bc0 +  bne  R7, zr, B332	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1bc4    B331: #	out( B240 ) &lt;- in( B330 )  Freq: 2.21354e-06
1bc4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1bc4    spill R23 -&gt; R11	# spill size = 64
1bc8 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1bf8 +  j  B240	#@branch

1bfc    B332: #	out( B240 ) &lt;- in( B330 )  Freq: 2.21354e-06
1bfc +  add R28, R28, R7	# ptr, #@addP_reg_reg
1c00 +  addi  R7, R7, #-8	#@addL_reg_imm
1c04 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1c08 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1c08    sd  R7, [R23, #64]	# long, #@storeL
1c0c +  j  B240	#@branch

1c10    B333: #	out( B482 B334 ) &lt;- in( B199 )  Freq: 3.73187e-06
1c10 +  spill R24 -&gt; [sp, #48]	# spill size = 64
1c14 +  spill R10 -&gt; [sp, #40]	# spill size = 32
1c18 +  spill R20 -&gt; [sp, #20]	# spill size = 32
1c1c +  spill R22 -&gt; [sp, #32]	# spill size = 64
1c20 +  spill R21 -&gt; [sp, #24]	# spill size = 64
1c24 +  spill R29 -&gt; [sp, #16]	# spill size = 32
1c28 +  spill R19 -&gt; [sp, #8]	# spill size = 64
1c2c +  spill R18 -&gt; [sp, #0]	# spill size = 64
1c30 +  mv  R11, precise klass java/util/HashMap$Node: 0x00000040d81c94e0:Constant:exact *	# ptr, #@loadConP
1c48    spill R7 -&gt; R8	# spill size = 64
1c4c    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #20 L[2]=R8 L[3]=#Ptr0x00000040d82922a0 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:56 (line 629) L[0]=sp + #24 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #32 STK[1]=sp + #40
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=NarrowOop [24]=Oop [32]=Oop [48]=Derived_oop_[32] off=7248/0x1c50}

1c50    B334: #	out( B201 ) &lt;- in( B333 )  Freq: 3.7318e-06
        # Block is sole successor of call
1c50 +  spill R10 -&gt; R7	# spill size = 64
1c54 +  spill [sp, #0] -&gt; R18	# spill size = 64
1c58 +  spill [sp, #8] -&gt; R19	# spill size = 64
1c5c +  spill [sp, #16] -&gt; R29	# spill size = 32
1c60 +  spill [sp, #24] -&gt; R21	# spill size = 64
1c64 +  spill [sp, #32] -&gt; R22	# spill size = 64
1c68 +  spill [sp, #20] -&gt; R20	# spill size = 32
1c6c +  spill [sp, #40] -&gt; R10	# spill size = 32
1c70 +  spill [sp, #48] -&gt; R24	# spill size = 64
1c74 +  spill R7 -&gt; R9	# spill size = 64
1c78 +  j  B201	#@branch

1c7c    B335: #	out( B481 B336 ) &lt;- in( B208 )  Freq: 2.4881e-06
1c7c +  spill R25 -&gt; [sp, #48]	# spill size = 64
1c80 +  spill R29 -&gt; [sp, #40]	# spill size = 32
1c84 +  spill R21 -&gt; [sp, #12]	# spill size = 32
1c88 +  spill R22 -&gt; [sp, #32]	# spill size = 64
1c8c +  spill R20 -&gt; [sp, #24]	# spill size = 64
1c90 +  spill R7 -&gt; [sp, #16]	# spill size = 64
1c94 +  spill R30 -&gt; [sp, #8]	# spill size = 32
1c98 +  spill R9 -&gt; [sp, #0]	# spill size = 64
1c9c +  spill R19 -&gt; R8	# spill size = 64
1ca0 +  mv  R11, precise klass java/util/HashMap$Node: 0x00000040d81c94e0:Constant:exact *	# ptr, #@loadConP
1cb8    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #12 L[2]=sp + #16 L[3]=#Ptr0x00000040d82922a0 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:56 (line 629) L[0]=sp + #24 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #32 STK[1]=sp + #40
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=NarrowOop [16]=Oop [24]=Oop [32]=Oop [48]=Derived_oop_[32] off=7356/0x1cbc}

1cbc    B336: #	out( B210 ) &lt;- in( B335 )  Freq: 2.48805e-06
        # Block is sole successor of call
1cbc +  spill R8 -&gt; R19	# spill size = 64
1cc0 +  spill [sp, #0] -&gt; R9	# spill size = 64
1cc4 +  spill [sp, #8] -&gt; R30	# spill size = 32
1cc8 +  spill [sp, #24] -&gt; R20	# spill size = 64
1ccc +  spill [sp, #32] -&gt; R22	# spill size = 64
1cd0 +  spill [sp, #12] -&gt; R21	# spill size = 32
1cd4 +  spill [sp, #40] -&gt; R29	# spill size = 32
1cd8 +  spill [sp, #48] -&gt; R25	# spill size = 64
1cdc +  spill R10 -&gt; R18	# spill size = 64
1ce0 +  j  B210	#@branch

1ce4    B337: #	out( B480 B338 ) &lt;- in( B222 )  Freq: 1.32957e-06
1ce4 +  spill R9 -&gt; [sp, #48]	# spill size = 32
1ce8 +  spill R24 -&gt; [sp, #40]	# spill size = 64
1cec +  spill R20 -&gt; [sp, #20]	# spill size = 32
1cf0 +  spill R22 -&gt; [sp, #32]	# spill size = 64
1cf4 +  spill R21 -&gt; [sp, #24]	# spill size = 64
1cf8 +  spill R29 -&gt; [sp, #16]	# spill size = 32
1cfc +  spill R19 -&gt; [sp, #8]	# spill size = 64
1d00 +  spill R18 -&gt; [sp, #0]	# spill size = 64
1d04 +  mv  R11, precise klass java/util/HashMap$Node: 0x00000040d81c94e0:Constant:exact *	# ptr, #@loadConP
1d1c    spill R7 -&gt; R8	# spill size = 64
1d20    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #20 L[2]=R8 L[3]=#Ptr0x00000040d82922a0 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:152 (line 640) L[0]=sp + #24 L[1]=sp + #20 L[2]=_ L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=sp + #48 STK[0]=sp + #40
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=NarrowOop [24]=Oop [32]=Oop [40]=Oop off=7460/0x1d24}

1d24    B338: #	out( B224 ) &lt;- in( B337 )  Freq: 1.32955e-06
        # Block is sole successor of call
1d24 +  spill [sp, #0] -&gt; R18	# spill size = 64
1d28 +  spill [sp, #8] -&gt; R19	# spill size = 64
1d2c +  spill [sp, #16] -&gt; R29	# spill size = 32
1d30 +  spill [sp, #24] -&gt; R21	# spill size = 64
1d34 +  spill [sp, #32] -&gt; R22	# spill size = 64
1d38 +  spill [sp, #20] -&gt; R20	# spill size = 32
1d3c +  spill [sp, #40] -&gt; R24	# spill size = 64
1d40 +  spill [sp, #48] -&gt; R9	# spill size = 32
1d44 +  spill R10 -&gt; R25	# spill size = 64
1d48 +  j  B224	#@branch

1d4c    B339: #	out( B479 B340 ) &lt;- in( B235 )  Freq: 8.86448e-07
1d4c +  spill R24 -&gt; [sp, #48]	# spill size = 64
1d50 +  spill R21 -&gt; [sp, #40]	# spill size = 32
1d54 +  spill R22 -&gt; [sp, #32]	# spill size = 64
1d58 +  spill R20 -&gt; [sp, #24]	# spill size = 64
1d5c +  spill R7 -&gt; [sp, #16]	# spill size = 64
1d60 +  spill R30 -&gt; [sp, #4]	# spill size = 32
1d64 +  spill R9 -&gt; [sp, #8]	# spill size = 64
1d68 +  spill R19 -&gt; R8	# spill size = 64
1d6c +  spill R18 -&gt; [sp, #0]	# spill size = 32
1d70 +  mv  R11, precise klass java/util/HashMap$Node: 0x00000040d81c94e0:Constant:exact *	# ptr, #@loadConP
1d88    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #40 L[2]=sp + #16 L[3]=#Ptr0x00000040d82922a0 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:152 (line 640) L[0]=sp + #24 L[1]=sp + #40 L[2]=_ L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=sp + #0 STK[0]=sp + #48
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [48]=Oop off=7564/0x1d8c}

1d8c    B340: #	out( B237 ) &lt;- in( B339 )  Freq: 8.86431e-07
        # Block is sole successor of call
1d8c +  spill [sp, #0] -&gt; R18	# spill size = 32
1d90 +  spill R8 -&gt; R19	# spill size = 64
1d94 +  spill [sp, #8] -&gt; R9	# spill size = 64
1d98 +  spill [sp, #4] -&gt; R30	# spill size = 32
1d9c +  spill [sp, #24] -&gt; R20	# spill size = 64
1da0 +  spill [sp, #32] -&gt; R22	# spill size = 64
1da4 +  spill [sp, #40] -&gt; R21	# spill size = 32
1da8 +  spill [sp, #48] -&gt; R24	# spill size = 64
1dac +  spill R10 -&gt; R25	# spill size = 64
1db0 +  j  B237	#@branch

1db4    B341: #	out( N5509 ) &lt;- in( B35 )  Freq: 3.36141e-07
1db4 +  li R11, #-10	# int, #@loadConI
1db8    spill R18 -&gt; R8	# spill size = 64
1dbc +  spill R7 -&gt; [sp, #0]	# spill size = 64
1dc0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=sp + #0 STK[2]=#Ptr0x00000040d82922a0
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=7620/0x1dc4}
1dc4    #@ShouldNotReachHere

1dd0    B342: #	out( N5509 ) &lt;- in( B5 )  Freq: 3.33261e-07
1dd0 +  li R11, #-58	# int, #@loadConI
1dd4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;bimorphic&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop off=7640/0x1dd8}
1dd8    #@ShouldNotReachHere

1de4    B343: #	out( N5509 ) &lt;- in( B8 )  Freq: 3.3326e-07
1de4 +  li R11, #-34	# int, #@loadConI
1de8    spill R29 -&gt; [sp, #8]	# spill size = 64
1dec    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #0
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=7664/0x1df0}
1df0    #@ShouldNotReachHere

1dfc    B344: #	out( N5509 ) &lt;- in( B30 )  Freq: 3.31738e-07
1dfc +  li R11, #-34	# int, #@loadConI
1e00    spill R18 -&gt; R8	# spill size = 64
1e04 +  spill R19 -&gt; [sp, #0]	# spill size = 64
1e08 +  spill R7 -&gt; [sp, #8]	# spill size = 64
1e0c +  spill R30 -&gt; [sp, #16]	# spill size = 64
1e10    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_ STK[0]=sp + #16 STK[1]=sp + #8
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=7700/0x1e14}
1e14    #@ShouldNotReachHere

1e20    B345: #	out( N5509 ) &lt;- in( B32 )  Freq: 3.31737e-07
1e20 +  li R11, #-34	# int, #@loadConI
1e24    spill R18 -&gt; [sp, #0]	# spill size = 64
1e28 +  spill R19 -&gt; [sp, #8]	# spill size = 64
1e2c +  spill R7 -&gt; [sp, #16]	# spill size = 64
1e30 +  spill R31 -&gt; [sp, #24]	# spill size = 64
1e34    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_ STK[0]=sp + #24 STK[1]=R8 STK[2]=sp + #16
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=7736/0x1e38}
1e38    #@ShouldNotReachHere

1e44    B346: #	out( N5509 ) &lt;- in( B112 )  Freq: 3.31734e-07
1e44 +  li R11, #-28	# int, #@loadConI
1e48    spill R18 -&gt; R8	# spill size = 64
1e4c +  spill R19 -&gt; [sp, #0]	# spill size = 64
1e50 +  spill R21 -&gt; [sp, #8]	# spill size = 64
1e54 +  spill R7 -&gt; [sp, #16]	# spill size = 64
1e58 +  spill R20 -&gt; [sp, #24]	# spill size = 32
1e5c +  spill R22 -&gt; [sp, #40]	# spill size = 64
1e60 +  spill R10 -&gt; [sp, #48]	# spill size = 32
1e64    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.HashMap::putVal @ bci:40 (line 628) L[0]=sp + #8 L[1]=sp + #24 L[2]=sp + #16 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=_ L[8]=_ L[9]=sp + #48 L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #40 STK[1]=sp + #48
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [40]=Oop off=7784/0x1e68}
1e68    #@ShouldNotReachHere

1e74    B347: #	out( N5509 ) &lt;- in( B83 )  Freq: 2.24111e-07
1e74 +  li R11, #-10	# int, #@loadConI
1e78    spill R19 -&gt; R8	# spill size = 64
1e7c +  spill R7 -&gt; [sp, #0]	# spill size = 64
1e80    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=sp + #0 STK[2]=#Ptr0x00000040d82922a0
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=7812/0x1e84}
1e84    #@ShouldNotReachHere

1e90    B348: #	out( N5509 ) &lt;- in( B53 )  Freq: 2.22191e-07
1e90 +  li R11, #-58	# int, #@loadConI
1e94    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;bimorphic&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #0
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=7832/0x1e98}
1e98    #@ShouldNotReachHere

1ea4    B349: #	out( N5509 ) &lt;- in( B56 )  Freq: 2.2219e-07
1ea4 +  li R11, #-34	# int, #@loadConI
1ea8    spill R30 -&gt; [sp, #8]	# spill size = 64
1eac    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #0
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=7856/0x1eb0}
1eb0    #@ShouldNotReachHere

1ebc    B350: #	out( N5509 ) &lt;- in( B78 )  Freq: 2.21175e-07
1ebc +  li R11, #-34	# int, #@loadConI
1ec0    spill R19 -&gt; R8	# spill size = 64
1ec4 +  spill R9 -&gt; [sp, #0]	# spill size = 64
1ec8 +  spill R29 -&gt; [sp, #8]	# spill size = 64
1ecc +  spill R7 -&gt; [sp, #16]	# spill size = 64
1ed0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_ STK[0]=sp + #8 STK[1]=sp + #16
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=7892/0x1ed4}
1ed4    #@ShouldNotReachHere

1ee0    B351: #	out( N5509 ) &lt;- in( B80 )  Freq: 2.21175e-07
1ee0 +  li R11, #-34	# int, #@loadConI
1ee4    spill R19 -&gt; [sp, #0]	# spill size = 64
1ee8 +  spill R9 -&gt; [sp, #8]	# spill size = 64
1eec +  spill R29 -&gt; [sp, #16]	# spill size = 64
1ef0 +  spill R7 -&gt; [sp, #24]	# spill size = 64
1ef4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_ STK[0]=sp + #16 STK[1]=R8 STK[2]=sp + #24
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=7928/0x1ef8}
1ef8    #@ShouldNotReachHere

1f04    B352: #	out( N5509 ) &lt;- in( B162 )  Freq: 2.21173e-07
1f04 +  li R11, #-28	# int, #@loadConI
1f08    spill R19 -&gt; R8	# spill size = 64
1f0c +  spill R9 -&gt; [sp, #0]	# spill size = 64
1f10 +  spill R20 -&gt; [sp, #8]	# spill size = 64
1f14 +  spill R21 -&gt; [sp, #16]	# spill size = 32
1f18 +  spill R7 -&gt; [sp, #24]	# spill size = 64
1f1c +  spill R22 -&gt; [sp, #40]	# spill size = 64
1f20 +  spill R29 -&gt; [sp, #48]	# spill size = 32
1f24    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.HashMap::putVal @ bci:40 (line 628) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #24 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=_ L[8]=_ L[9]=sp + #48 L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #40 STK[1]=sp + #48
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [40]=Oop off=7976/0x1f28}
1f28    #@ShouldNotReachHere

1f34    B353: #	out( N5509 ) &lt;- in( B18 )  Freq: 1.6663e-07
1f34 +  li R11, #-187	# int, #@loadConI
1f38    spill R18 -&gt; [sp, #0]	# spill size = 64
1f3c +  spill R29 -&gt; [sp, #8]	# spill size = 64
1f40    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:25 (line 275) L[0]=sp + #8 L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ STK[0]=R8
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop off=8004/0x1f44}
1f44    #@ShouldNotReachHere

1f50    B354: #	out( N5509 ) &lt;- in( B22 )  Freq: 1.66629e-07
1f50 +  li R11, #-187	# int, #@loadConI
1f54    spill R18 -&gt; R8	# spill size = 64
1f58 +  spill R12 -&gt; [sp, #0]	# spill size = 64
1f5c +  spill R30 -&gt; [sp, #8]	# spill size = 64
1f60 +  spill R13 -&gt; [sp, #16]	# spill size = 32
1f64    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:4 (line 761) L[0]=sp + #0 L[1]=sp + #8 STK[0]=sp + #16
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=8040/0x1f68}
1f68    #@ShouldNotReachHere

1f74    B355: #	out( B27 ) &lt;- in( B264 )  Freq: 1.66625e-07
1f74 +  spill R19 -&gt; R20	# spill size = 64
1f78 +  spill R31 -&gt; R19	# spill size = 64
1f7c    
1f7c    
1f7c +  spill R30 -&gt; R21	# spill size = 64
1f80    
1f80    
1f80 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1f80    spill R23 -&gt; R11	# spill size = 64
1f84 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
1fb4 +  spill R19 -&gt; R31	# spill size = 64
1fb8 +  spill R20 -&gt; R19	# spill size = 64
1fbc +  spill R21 -&gt; R30	# spill size = 64
1fc0 +  j  B27	#@branch

1fc4    B356: #	out( B145 ) &lt;- in( B267 )  Freq: 1.66622e-07
1fc4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1fc4    spill R23 -&gt; R11	# spill size = 64
1fc8 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
1ff8 +  j  B145	#@branch

1ffc    B357: #	out( B146 ) &lt;- in( B270 )  Freq: 1.66622e-07
1ffc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ffc    spill R23 -&gt; R11	# spill size = 64
2000 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2030 +  j  B146	#@branch

2034    B358: #	out( N5509 ) &lt;- in( B29 )  Freq: 1.65869e-07
2034 +  li R11, #-187	# int, #@loadConI
2038    spill R18 -&gt; [sp, #0]	# spill size = 64
203c +  spill R19 -&gt; [sp, #8]	# spill size = 64
2040 +  spill R30 -&gt; [sp, #16]	# spill size = 64
2044    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:11 (line 410) L[0]=sp + #8 L[1]=sp + #16 STK[0]=R8 STK[1]=#-2
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=8264/0x2048}
2048    #@ShouldNotReachHere

2054    B359: #	out( N5509 ) &lt;- in( B44 )  Freq: 1.63452e-07
2054 +  li R11, #-138	# int, #@loadConI
2058    spill R18 -&gt; R8	# spill size = 64
205c +  spill R19 -&gt; [sp, #0]	# spill size = 64
2060 +  spill R7 -&gt; [sp, #8]	# spill size = 64
2064 +  spill R21 -&gt; [sp, #16]	# spill size = 64
2068 +  spill R14 -&gt; [sp, #24]	# spill size = 64
206c +  spill R15 -&gt; [sp, #32]	# spill size = 64
2070 +  spill R13 -&gt; [sp, #44]	# spill size = 32
2074    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:13 (line 196) L[0]=_ L[1]=#0 L[2]=sp + #32 L[3]=sp + #44 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=sp + #44
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=sp + #24 L[1]=_
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #8 L[2]=#Ptr0x00000040d82922a0 STK[0]=sp + #16
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop off=8312/0x2078}
2078    #@ShouldNotReachHere

2084    B360: #	out( B104 ) &lt;- in( B45 )  Freq: 1.63452e-07
2084 +  li R12, #1	# int, #@loadConI
2088 +  li R28, #0	# int, #@loadConI
208c +  j  B104	#@branch

2090    B361: #	out( N5509 ) &lt;- in( B46 )  Freq: 1.6131e-07
2090    #@ShouldNotReachHere

209c    B362: #	out( N5509 ) &lt;- in( B47 )  Freq: 1.6131e-07
209c    #@ShouldNotReachHere

20a8    B363: #	out( N5509 ) &lt;- in( B23 )  Freq: 1.5891e-07
20a8 +  li R11, #-187	# int, #@loadConI
20ac    spill R18 -&gt; R8	# spill size = 64
20b0 +  spill R30 -&gt; [sp, #0]	# spill size = 64
20b4 +  spill R12 -&gt; [sp, #16]	# spill size = 64
20b8 +  spill R31 -&gt; [sp, #24]	# spill size = 64
20bc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.AbstractPipeline::sourceStageSpliterator @ bci:5 (line 275) L[0]=sp + #16 L[1]=_ STK[0]=sp + #16 STK[1]=sp + #24
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:8 (line 762) L[0]=_ L[1]=sp + #0
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=8384/0x20c0}
20c0    #@ShouldNotReachHere

20cc    B364: #	out( N5509 ) &lt;- in( B24 )  Freq: 1.5891e-07
20cc +  li R11, #-187	# int, #@loadConI
20d0    spill R18 -&gt; R8	# spill size = 64
20d4 +  spill R30 -&gt; [sp, #0]	# spill size = 64
20d8 +  spill R12 -&gt; [sp, #8]	# spill size = 64
20dc +  spill R10 -&gt; [sp, #16]	# spill size = 32
20e0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.AbstractPipeline::sourceStageSpliterator @ bci:20 (line 278) L[0]=sp + #8 L[1]=_ STK[0]=sp + #16
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:8 (line 762) L[0]=_ L[1]=sp + #0
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=8420/0x20e4}
20e4    #@ShouldNotReachHere

20f0    B365: #	out( N5509 ) &lt;- in( B131 )  Freq: 1.54084e-07
20f0 +  li R11, #-34	# int, #@loadConI
20f4    spill R18 -&gt; R8	# spill size = 64
20f8 +  spill R19 -&gt; [sp, #0]	# spill size = 64
20fc +  spill R21 -&gt; [sp, #8]	# spill size = 64
2100 +  spill R7 -&gt; [sp, #24]	# spill size = 64
2104 +  spill R20 -&gt; [sp, #32]	# spill size = 32
2108 +  spill R22 -&gt; [sp, #40]	# spill size = 64
210c +  spill R9 -&gt; [sp, #48]	# spill size = 64
2110 +  spill R10 -&gt; [sp, #56]	# spill size = 64
2114    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=sp + #8 L[1]=sp + #32 L[2]=sp + #24 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=sp + #48 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #24 STK[1]=sp + #56
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop off=8472/0x2118}
2118    #@ShouldNotReachHere

2124    B366: #	out( N5509 ) &lt;- in( B111 )  Freq: 1.53141e-07
2124 +  li R11, #-187	# int, #@loadConI
2128    spill R18 -&gt; R8	# spill size = 64
212c +  spill R19 -&gt; [sp, #0]	# spill size = 64
2130 +  spill R21 -&gt; [sp, #8]	# spill size = 64
2134 +  spill R7 -&gt; [sp, #16]	# spill size = 64
2138 +  spill R20 -&gt; [sp, #24]	# spill size = 32
213c +  spill R22 -&gt; [sp, #32]	# spill size = 64
2140 +  spill R31 -&gt; [sp, #40]	# spill size = 32
2144    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:16 (line 626) L[0]=sp + #8 L[1]=sp + #24 L[2]=sp + #16 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=sp + #40 L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #40
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [32]=Oop off=8520/0x2148}
2148    #@ShouldNotReachHere

2154    B367: #	out( N5509 ) &lt;- in( B136 )  Freq: 1.4601e-07
2154    #@ShouldNotReachHere

2160    B368: #	out( N5509 ) &lt;- in( B137 )  Freq: 1.4601e-07
2160    #@ShouldNotReachHere

216c    B369: #	out( B370 ) &lt;- in( B139 )  Freq: 6.87102e-08
216c +  spill R10 -&gt; R28	# spill size = 32

2170    B370: #	out( N5509 ) &lt;- in( B369 B138 )  Freq: 2.12806e-07
2170 +  li R11, #-187	# int, #@loadConI
2174    spill R18 -&gt; R8	# spill size = 64
2178 +  spill R19 -&gt; [sp, #0]	# spill size = 64
217c +  spill R21 -&gt; [sp, #8]	# spill size = 64
2180 +  spill R28 -&gt; [sp, #16]	# spill size = 32
2184 +  spill R20 -&gt; [sp, #20]	# spill size = 32
2188 +  spill R12 -&gt; [sp, #24]	# spill size = 64
218c +  spill R22 -&gt; [sp, #32]	# spill size = 64
2190 +  spill R9 -&gt; [sp, #40]	# spill size = 64
2194    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:94 (line 633) L[0]=sp + #8 L[1]=sp + #20 L[2]=sp + #24 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #16
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop off=8600/0x2198}
2198    #@ShouldNotReachHere

21a4    B371: #	out( N5509 ) &lt;- in( B115 )  Freq: 1.42201e-07
21a4 +  li R11, #-187	# int, #@loadConI
21a8    spill R18 -&gt; R8	# spill size = 64
21ac +  spill R19 -&gt; [sp, #0]	# spill size = 64
21b0 +  spill R21 -&gt; [sp, #8]	# spill size = 64
21b4 +  spill R7 -&gt; [sp, #16]	# spill size = 64
21b8 +  spill R20 -&gt; [sp, #24]	# spill size = 32
21bc +  spill R22 -&gt; [sp, #32]	# spill size = 64
21c0 +  spill R9 -&gt; [sp, #40]	# spill size = 64
21c4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:109 (line 635) L[0]=sp + #8 L[1]=sp + #24 L[2]=sp + #16 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#1
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop off=8648/0x21c8}
21c8    #@ShouldNotReachHere

21d4    B372: #	out( B141 ) &lt;- in( B273 )  Freq: 1.40559e-07
21d4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
21d4    spill R23 -&gt; R11	# spill size = 64
21d8 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2208 +  j  B141	#@branch

220c    B373: #	out( N5509 ) &lt;- in( B120 )  Freq: 1.27044e-07
220c +  li R11, #-34	# int, #@loadConI
2210    spill R18 -&gt; R8	# spill size = 64
2214 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2218 +  spill R21 -&gt; [sp, #8]	# spill size = 64
221c +  spill R7 -&gt; [sp, #24]	# spill size = 64
2220 +  spill R20 -&gt; [sp, #32]	# spill size = 32
2224 +  spill R22 -&gt; [sp, #40]	# spill size = 64
2228 +  spill R24 -&gt; [sp, #48]	# spill size = 64
222c +  spill R9 -&gt; [sp, #36]	# spill size = 32
2230 +  spill R12 -&gt; [sp, #56]	# spill size = 64
2234    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #8 L[1]=sp + #32 L[2]=sp + #24 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #48 L[11]=_ L[12]=sp + #36 STK[0]=sp + #24 STK[1]=sp + #56
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop off=8760/0x2238}
2238    #@ShouldNotReachHere

2244    B374: #	out( N5509 ) &lt;- in( B125 )  Freq: 1.20386e-07
2244    #@ShouldNotReachHere

2250    B375: #	out( N5509 ) &lt;- in( B126 )  Freq: 1.20386e-07
2250    #@ShouldNotReachHere

225c    B376: #	out( B377 ) &lt;- in( B128 )  Freq: 5.66522e-08
225c +  spill R10 -&gt; R28	# spill size = 32

2260    B377: #	out( N5509 ) &lt;- in( B376 B127 )  Freq: 1.75461e-07
2260 +  li R11, #-187	# int, #@loadConI
2264    spill R18 -&gt; R8	# spill size = 64
2268 +  spill R19 -&gt; [sp, #0]	# spill size = 64
226c +  spill R21 -&gt; [sp, #8]	# spill size = 64
2270 +  spill R28 -&gt; [sp, #16]	# spill size = 32
2274 +  spill R20 -&gt; [sp, #20]	# spill size = 32
2278 +  spill R15 -&gt; [sp, #24]	# spill size = 64
227c +  spill R22 -&gt; [sp, #32]	# spill size = 64
2280 +  spill R24 -&gt; [sp, #40]	# spill size = 64
2284 +  spill R9 -&gt; [sp, #48]	# spill size = 32
2288    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:206 (line 646) L[0]=sp + #8 L[1]=sp + #20 L[2]=sp + #24 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=_ L[12]=sp + #48 STK[0]=sp + #16
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop off=8844/0x228c}
228c    #@ShouldNotReachHere

2298    B378: #	out( N5509 ) &lt;- in( B66 )  Freq: 1.11095e-07
2298 +  li R11, #-187	# int, #@loadConI
229c    spill R30 -&gt; [sp, #0]	# spill size = 64
22a0 +  spill R19 -&gt; [sp, #8]	# spill size = 64
22a4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:25 (line 275) L[0]=sp + #0 L[1]=_ L[2]=sp + #8 L[3]=_ L[4]=_ STK[0]=R8
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop off=8872/0x22a8}
22a8    #@ShouldNotReachHere

22b4    B379: #	out( N5509 ) &lt;- in( B70 )  Freq: 1.11095e-07
22b4 +  li R11, #-187	# int, #@loadConI
22b8    spill R19 -&gt; R8	# spill size = 64
22bc +  spill R10 -&gt; [sp, #0]	# spill size = 64
22c0 +  spill R29 -&gt; [sp, #8]	# spill size = 64
22c4 +  spill R12 -&gt; [sp, #16]	# spill size = 32
22c8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:4 (line 761) L[0]=sp + #0 L[1]=sp + #8 STK[0]=sp + #16
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=8908/0x22cc}
22cc    #@ShouldNotReachHere

22d8    B380: #	out( B75 ) &lt;- in( B280 )  Freq: 1.11091e-07
22d8 +  spill R31 -&gt; R20	# spill size = 64
22dc    
22dc    
22dc +  spill R29 -&gt; R22	# spill size = 64
22e0    
22e0    
22e0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
22e0    spill R23 -&gt; R11	# spill size = 64
22e4 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2314 +  spill R9 -&gt; R21	# spill size = 64
2318 +  spill R20 -&gt; R31	# spill size = 64
231c +  spill R21 -&gt; R9	# spill size = 64
2320 +  spill R22 -&gt; R29	# spill size = 64
2324 +  j  B75	#@branch

2328    B381: #	out( B195 ) &lt;- in( B283 )  Freq: 1.11089e-07
2328 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2328    spill R23 -&gt; R11	# spill size = 64
232c +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
235c +  j  B195	#@branch

2360    B382: #	out( B196 ) &lt;- in( B286 )  Freq: 1.11089e-07
2360 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2360    spill R23 -&gt; R11	# spill size = 64
2364 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2394 +  j  B196	#@branch

2398    B383: #	out( N5509 ) &lt;- in( B77 )  Freq: 1.10588e-07
2398 +  li R11, #-187	# int, #@loadConI
239c    spill R19 -&gt; [sp, #0]	# spill size = 64
23a0 +  spill R9 -&gt; [sp, #8]	# spill size = 64
23a4 +  spill R29 -&gt; [sp, #16]	# spill size = 64
23a8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:11 (line 410) L[0]=sp + #8 L[1]=sp + #16 STK[0]=R8 STK[1]=#-2
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=9132/0x23ac}
23ac    #@ShouldNotReachHere

23b8    B384: #	out( N5509 ) &lt;- in( B92 )  Freq: 1.08977e-07
23b8 +  li R11, #-138	# int, #@loadConI
23bc    spill R14 -&gt; [sp, #0]	# spill size = 64
23c0 +  spill R19 -&gt; [sp, #8]	# spill size = 64
23c4 +  spill R9 -&gt; [sp, #16]	# spill size = 64
23c8 +  spill R7 -&gt; [sp, #24]	# spill size = 64
23cc +  spill R20 -&gt; [sp, #32]	# spill size = 64
23d0 +  spill R29 -&gt; [sp, #40]	# spill size = 64
23d4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:13 (line 196) L[0]=_ L[1]=#0 L[2]=sp + #0 L[3]=R8 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=R8
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=sp + #40 L[1]=_
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #24 L[2]=#Ptr0x00000040d82922a0 STK[0]=sp + #32
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #16 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=9176/0x23d8}
23d8    #@ShouldNotReachHere

23e4    B385: #	out( B154 ) &lt;- in( B93 )  Freq: 1.08976e-07
23e4 +  li R18, #0	# int, #@loadConI
23e8 +  j  B154	#@branch

23ec    B386: #	out( N5509 ) &lt;- in( B94 )  Freq: 1.07548e-07
23ec    #@ShouldNotReachHere

23f8    B387: #	out( N5509 ) &lt;- in( B95 )  Freq: 1.07548e-07
23f8    #@ShouldNotReachHere

2404    B388: #	out( N5509 ) &lt;- in( B71 )  Freq: 1.05948e-07
2404 +  li R11, #-187	# int, #@loadConI
2408    spill R19 -&gt; R8	# spill size = 64
240c +  spill R29 -&gt; [sp, #0]	# spill size = 64
2410 +  spill R10 -&gt; [sp, #16]	# spill size = 64
2414 +  spill R31 -&gt; [sp, #24]	# spill size = 64
2418    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.AbstractPipeline::sourceStageSpliterator @ bci:5 (line 275) L[0]=sp + #16 L[1]=_ STK[0]=sp + #16 STK[1]=sp + #24
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:8 (line 762) L[0]=_ L[1]=sp + #0
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=9244/0x241c}
241c    #@ShouldNotReachHere

2428    B389: #	out( N5509 ) &lt;- in( B72 )  Freq: 1.05948e-07
2428 +  li R11, #-187	# int, #@loadConI
242c    spill R19 -&gt; R8	# spill size = 64
2430 +  spill R29 -&gt; [sp, #0]	# spill size = 64
2434 +  spill R10 -&gt; [sp, #8]	# spill size = 64
2438 +  spill R28 -&gt; [sp, #16]	# spill size = 32
243c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.AbstractPipeline::sourceStageSpliterator @ bci:20 (line 278) L[0]=sp + #8 L[1]=_ STK[0]=sp + #16
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:8 (line 762) L[0]=_ L[1]=sp + #0
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=9280/0x2440}
2440    #@ShouldNotReachHere

244c    B390: #	out( N5509 ) &lt;- in( B181 )  Freq: 1.0273e-07
244c +  li R11, #-34	# int, #@loadConI
2450    spill R19 -&gt; R8	# spill size = 64
2454 +  spill R9 -&gt; [sp, #0]	# spill size = 64
2458 +  spill R20 -&gt; [sp, #8]	# spill size = 64
245c +  spill R21 -&gt; [sp, #16]	# spill size = 32
2460 +  spill R22 -&gt; [sp, #32]	# spill size = 64
2464 +  spill R24 -&gt; [sp, #40]	# spill size = 64
2468 +  spill R7 -&gt; [sp, #48]	# spill size = 64
246c +  spill R10 -&gt; [sp, #56]	# spill size = 64
2470    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #48 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #48 STK[1]=sp + #56
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=9332/0x2474}
2474    #@ShouldNotReachHere

2480    B391: #	out( N5509 ) &lt;- in( B161 )  Freq: 1.02102e-07
2480 +  li R11, #-187	# int, #@loadConI
2484    spill R19 -&gt; R8	# spill size = 64
2488 +  spill R9 -&gt; [sp, #0]	# spill size = 64
248c +  spill R20 -&gt; [sp, #8]	# spill size = 64
2490 +  spill R21 -&gt; [sp, #16]	# spill size = 32
2494 +  spill R7 -&gt; [sp, #24]	# spill size = 64
2498 +  spill R22 -&gt; [sp, #32]	# spill size = 64
249c +  spill R28 -&gt; [sp, #40]	# spill size = 32
24a0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:16 (line 626) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #24 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=sp + #40 L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #40
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop off=9380/0x24a4}
24a4    #@ShouldNotReachHere

24b0    B392: #	out( N5509 ) &lt;- in( B186 )  Freq: 9.73471e-08
24b0    #@ShouldNotReachHere

24bc    B393: #	out( N5509 ) &lt;- in( B187 )  Freq: 9.7347e-08
24bc    #@ShouldNotReachHere

24c8    B394: #	out( B395 ) &lt;- in( B189 )  Freq: 4.58103e-08
24c8 +  spill R10 -&gt; R18	# spill size = 32

24cc    B395: #	out( N5509 ) &lt;- in( B394 B188 )  Freq: 1.41881e-07
24cc +  li R11, #-187	# int, #@loadConI
24d0    spill R18 -&gt; R8	# spill size = 32
24d4 +  spill R19 -&gt; [sp, #0]	# spill size = 64
24d8 +  spill R9 -&gt; [sp, #8]	# spill size = 64
24dc +  spill R20 -&gt; [sp, #16]	# spill size = 64
24e0 +  spill R21 -&gt; [sp, #24]	# spill size = 32
24e4 +  spill R31 -&gt; [sp, #32]	# spill size = 64
24e8 +  spill R22 -&gt; [sp, #40]	# spill size = 64
24ec +  spill R24 -&gt; [sp, #48]	# spill size = 64
24f0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:94 (line 633) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #32 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=sp + #48 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=R8
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop off=9460/0x24f4}
24f4    #@ShouldNotReachHere

2500    B396: #	out( N5509 ) &lt;- in( B165 )  Freq: 9.48078e-08
2500 +  li R11, #-187	# int, #@loadConI
2504    spill R19 -&gt; R8	# spill size = 64
2508 +  spill R9 -&gt; [sp, #0]	# spill size = 64
250c +  spill R20 -&gt; [sp, #8]	# spill size = 64
2510 +  spill R21 -&gt; [sp, #16]	# spill size = 32
2514 +  spill R7 -&gt; [sp, #24]	# spill size = 64
2518 +  spill R22 -&gt; [sp, #32]	# spill size = 64
251c +  spill R24 -&gt; [sp, #40]	# spill size = 64
2520    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:109 (line 635) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #24 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#1
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop off=9508/0x2524}
2524    #@ShouldNotReachHere

2530    B397: #	out( B191 ) &lt;- in( B289 )  Freq: 9.37134e-08
2530 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2530    spill R23 -&gt; R11	# spill size = 64
2534 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2564 +  j  B191	#@branch

2568    B398: #	out( N5509 ) &lt;- in( B41 )  Freq: 8.54471e-08
2568 +  li R11, #-187	# int, #@loadConI
256c    spill R18 -&gt; [sp, #0]	# spill size = 64
2570 +  spill R19 -&gt; [sp, #8]	# spill size = 64
2574 +  spill R7 -&gt; [sp, #16]	# spill size = 64
2578 +  spill R21 -&gt; [sp, #24]	# spill size = 64
257c +  spill R14 -&gt; [sp, #32]	# spill size = 64
2580    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=R8
        # java.lang.String::hashCode @ bci:17 (line 2337) L[0]=sp + #32 L[1]=_
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #16 L[2]=#Ptr0x00000040d82922a0 STK[0]=sp + #24
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop off=9604/0x2584}
2584    #@ShouldNotReachHere

2590    B399: #	out( N5509 ) &lt;- in( B170 )  Freq: 8.47022e-08
2590 +  li R11, #-34	# int, #@loadConI
2594    spill R19 -&gt; R8	# spill size = 64
2598 +  spill R9 -&gt; [sp, #0]	# spill size = 64
259c +  spill R20 -&gt; [sp, #8]	# spill size = 64
25a0 +  spill R21 -&gt; [sp, #16]	# spill size = 32
25a4 +  spill R22 -&gt; [sp, #32]	# spill size = 64
25a8 +  spill R12 -&gt; [sp, #40]	# spill size = 64
25ac +  spill R28 -&gt; [sp, #20]	# spill size = 32
25b0 +  spill R7 -&gt; [sp, #48]	# spill size = 64
25b4 +  spill R10 -&gt; [sp, #56]	# spill size = 64
25b8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #48 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=_ L[12]=sp + #20 STK[0]=sp + #48 STK[1]=sp + #56
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=9660/0x25bc}
25bc    #@ShouldNotReachHere

25c8    B400: #	out( N5509 ) &lt;- in( B105 )  Freq: 8.1726e-08
25c8    #@ShouldNotReachHere

25d4    B401: #	out( N5509 ) &lt;- in( B106 )  Freq: 8.17259e-08
25d4    #@ShouldNotReachHere

25e0    B402: #	out( N5509 ) &lt;- in( B175 )  Freq: 8.02636e-08
25e0    #@ShouldNotReachHere

25ec    B403: #	out( N5509 ) &lt;- in( B176 )  Freq: 8.02635e-08
25ec    #@ShouldNotReachHere

25f8    B404: #	out( B405 ) &lt;- in( B178 )  Freq: 3.7771e-08
25f8 +  spill R10 -&gt; R18	# spill size = 32

25fc    B405: #	out( N5509 ) &lt;- in( B404 B177 )  Freq: 1.16983e-07
25fc +  li R11, #-187	# int, #@loadConI
2600    spill R18 -&gt; R8	# spill size = 32
2604 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2608 +  spill R9 -&gt; [sp, #8]	# spill size = 64
260c +  spill R20 -&gt; [sp, #16]	# spill size = 64
2610 +  spill R21 -&gt; [sp, #24]	# spill size = 32
2614 +  spill R15 -&gt; [sp, #32]	# spill size = 64
2618 +  spill R22 -&gt; [sp, #40]	# spill size = 64
261c +  spill R12 -&gt; [sp, #48]	# spill size = 64
2620 +  spill R28 -&gt; [sp, #28]	# spill size = 32
2624    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:206 (line 646) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #32 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #48 L[11]=_ L[12]=sp + #28 STK[0]=R8
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop off=9768/0x2628}
2628    #@ShouldNotReachHere

2634    B406: #	out( N5509 ) &lt;- in( B130 )  Freq: 7.3473e-08
2634 +  li R11, #-187	# int, #@loadConI
2638    spill R18 -&gt; R8	# spill size = 64
263c +  spill R19 -&gt; [sp, #0]	# spill size = 64
2640 +  spill R21 -&gt; [sp, #8]	# spill size = 64
2644 +  spill R7 -&gt; [sp, #24]	# spill size = 64
2648 +  spill R20 -&gt; [sp, #32]	# spill size = 32
264c +  spill R22 -&gt; [sp, #40]	# spill size = 64
2650 +  spill R9 -&gt; [sp, #48]	# spill size = 64
2654 +  spill R10 -&gt; [sp, #64]	# spill size = 64
2658    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:81 (line 632) L[0]=sp + #8 L[1]=sp + #32 L[2]=sp + #24 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=sp + #48 L[8]=_ L[9]=_ L[10]=_ L[11]=sp + #64 L[12]=_ STK[0]=sp + #64 STK[1]=sp + #24
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [40]=Oop [48]=Oop [64]=Oop off=9820/0x265c}
265c    #@ShouldNotReachHere

2668    B407: #	out( N5509 ) &lt;- in( B135 )  Freq: 7.20481e-08
2668 +  li R11, #-187	# int, #@loadConI
266c    spill R18 -&gt; [sp, #0]	# spill size = 64
2670 +  spill R19 -&gt; [sp, #8]	# spill size = 64
2674 +  spill R21 -&gt; [sp, #16]	# spill size = 64
2678 +  spill R20 -&gt; [sp, #24]	# spill size = 32
267c +  spill R22 -&gt; [sp, #40]	# spill size = 64
2680 +  spill R9 -&gt; [sp, #48]	# spill size = 64
2684 +  spill R12 -&gt; [sp, #56]	# spill size = 64
2688 +  spill R10 -&gt; [sp, #64]	# spill size = 64
268c +  spill R30 -&gt; [sp, #28]	# spill size = 32
2690    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #56 L[1]=_ L[2]=sp + #64 STK[0]=sp + #28 STK[1]=R8
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #56 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=sp + #48 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop off=9876/0x2694}
2694    #@ShouldNotReachHere

26a0    B408: #	out( N5509 ) &lt;- in( B119 )  Freq: 6.05792e-08
26a0 +  li R11, #-187	# int, #@loadConI
26a4    spill R18 -&gt; R8	# spill size = 64
26a8 +  spill R19 -&gt; [sp, #0]	# spill size = 64
26ac +  spill R21 -&gt; [sp, #8]	# spill size = 64
26b0 +  spill R7 -&gt; [sp, #24]	# spill size = 64
26b4 +  spill R20 -&gt; [sp, #32]	# spill size = 32
26b8 +  spill R22 -&gt; [sp, #40]	# spill size = 64
26bc +  spill R24 -&gt; [sp, #48]	# spill size = 64
26c0 +  spill R9 -&gt; [sp, #36]	# spill size = 32
26c4 +  spill R12 -&gt; [sp, #64]	# spill size = 64
26c8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:193 (line 645) L[0]=sp + #8 L[1]=sp + #32 L[2]=sp + #24 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #48 L[11]=sp + #64 L[12]=sp + #36 STK[0]=sp + #64 STK[1]=sp + #24
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [40]=Oop [48]=Oop [64]=Oop off=9932/0x26cc}
26cc    #@ShouldNotReachHere

26d8    B409: #	out( N5509 ) &lt;- in( B124 )  Freq: 5.94043e-08
26d8 +  li R11, #-187	# int, #@loadConI
26dc    spill R18 -&gt; [sp, #0]	# spill size = 64
26e0 +  spill R19 -&gt; [sp, #8]	# spill size = 64
26e4 +  spill R21 -&gt; [sp, #16]	# spill size = 64
26e8 +  spill R20 -&gt; [sp, #24]	# spill size = 32
26ec +  spill R22 -&gt; [sp, #40]	# spill size = 64
26f0 +  spill R24 -&gt; [sp, #48]	# spill size = 64
26f4 +  spill R9 -&gt; [sp, #28]	# spill size = 32
26f8 +  spill R15 -&gt; [sp, #56]	# spill size = 64
26fc +  spill R12 -&gt; [sp, #64]	# spill size = 64
2700 +  spill R30 -&gt; [sp, #72]	# spill size = 32
2704    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #56 L[1]=_ L[2]=sp + #64 STK[0]=sp + #72 STK[1]=R8
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #56 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #48 L[11]=_ L[12]=sp + #28
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop off=9992/0x2708}
2708    #@ShouldNotReachHere

2714    B410: #	out( N5509 ) &lt;- in( B89 )  Freq: 5.69691e-08
2714 +  li R11, #-187	# int, #@loadConI
2718    spill R19 -&gt; [sp, #0]	# spill size = 64
271c +  spill R9 -&gt; [sp, #8]	# spill size = 64
2720 +  spill R7 -&gt; [sp, #16]	# spill size = 64
2724 +  spill R20 -&gt; [sp, #24]	# spill size = 64
2728 +  spill R29 -&gt; [sp, #32]	# spill size = 64
272c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=R8
        # java.lang.String::hashCode @ bci:17 (line 2337) L[0]=sp + #32 L[1]=_
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #16 L[2]=#Ptr0x00000040d82922a0 STK[0]=sp + #24
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop off=10032/0x2730}
2730    #@ShouldNotReachHere

273c    B411: #	out( N5509 ) &lt;- in( B155 )  Freq: 5.44881e-08
273c    #@ShouldNotReachHere

2748    B412: #	out( N5509 ) &lt;- in( B156 )  Freq: 5.44881e-08
2748    #@ShouldNotReachHere

2754    B413: #	out( N5509 ) &lt;- in( B180 )  Freq: 4.89857e-08
2754 +  li R11, #-187	# int, #@loadConI
2758    spill R19 -&gt; R8	# spill size = 64
275c +  spill R9 -&gt; [sp, #0]	# spill size = 64
2760 +  spill R20 -&gt; [sp, #8]	# spill size = 64
2764 +  spill R21 -&gt; [sp, #16]	# spill size = 32
2768 +  spill R22 -&gt; [sp, #32]	# spill size = 64
276c +  spill R24 -&gt; [sp, #40]	# spill size = 64
2770 +  spill R10 -&gt; [sp, #56]	# spill size = 64
2774 +  spill R7 -&gt; [sp, #64]	# spill size = 64
2778    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:81 (line 632) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #64 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=sp + #56 L[12]=_ STK[0]=sp + #56 STK[1]=sp + #64
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=10108/0x277c}
277c    #@ShouldNotReachHere

2788    B414: #	out( N5509 ) &lt;- in( B185 )  Freq: 4.80357e-08
2788 +  li R11, #-187	# int, #@loadConI
278c    spill R19 -&gt; [sp, #0]	# spill size = 64
2790 +  spill R9 -&gt; [sp, #8]	# spill size = 64
2794 +  spill R20 -&gt; [sp, #16]	# spill size = 64
2798 +  spill R21 -&gt; [sp, #24]	# spill size = 32
279c +  spill R22 -&gt; [sp, #40]	# spill size = 64
27a0 +  spill R24 -&gt; [sp, #48]	# spill size = 64
27a4 +  spill R31 -&gt; [sp, #56]	# spill size = 64
27a8 +  spill R10 -&gt; [sp, #64]	# spill size = 64
27ac +  spill R30 -&gt; [sp, #28]	# spill size = 32
27b0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #56 L[1]=_ L[2]=sp + #64 STK[0]=sp + #28 STK[1]=R8
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #56 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=sp + #48 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop off=10164/0x27b4}
27b4    #@ShouldNotReachHere

27c0    B415: #	out( N5509 ) &lt;- in( B169 )  Freq: 4.03892e-08
27c0 +  li R11, #-187	# int, #@loadConI
27c4    spill R19 -&gt; R8	# spill size = 64
27c8 +  spill R9 -&gt; [sp, #0]	# spill size = 64
27cc +  spill R20 -&gt; [sp, #8]	# spill size = 64
27d0 +  spill R21 -&gt; [sp, #16]	# spill size = 32
27d4 +  spill R22 -&gt; [sp, #32]	# spill size = 64
27d8 +  spill R12 -&gt; [sp, #40]	# spill size = 64
27dc +  spill R28 -&gt; [sp, #20]	# spill size = 32
27e0 +  spill R10 -&gt; [sp, #56]	# spill size = 64
27e4 +  spill R7 -&gt; [sp, #64]	# spill size = 64
27e8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:193 (line 645) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #64 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=sp + #56 L[12]=sp + #20 STK[0]=sp + #56 STK[1]=sp + #64
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=10220/0x27ec}
27ec    #@ShouldNotReachHere

27f8    B416: #	out( N5509 ) &lt;- in( B174 )  Freq: 3.96059e-08
27f8 +  li R11, #-187	# int, #@loadConI
27fc    spill R19 -&gt; [sp, #0]	# spill size = 64
2800 +  spill R9 -&gt; [sp, #8]	# spill size = 64
2804 +  spill R20 -&gt; [sp, #16]	# spill size = 64
2808 +  spill R21 -&gt; [sp, #24]	# spill size = 32
280c +  spill R22 -&gt; [sp, #40]	# spill size = 64
2810 +  spill R12 -&gt; [sp, #48]	# spill size = 64
2814 +  spill R28 -&gt; [sp, #28]	# spill size = 32
2818 +  spill R15 -&gt; [sp, #56]	# spill size = 64
281c +  spill R10 -&gt; [sp, #64]	# spill size = 64
2820 +  spill R29 -&gt; [sp, #72]	# spill size = 32
2824    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #56 L[1]=_ L[2]=sp + #64 STK[0]=sp + #72 STK[1]=R8
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #56 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #40 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #48 L[11]=_ L[12]=sp + #28
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop off=10280/0x2828}
2828    #@ShouldNotReachHere

2834    B417: #	out( N5509 ) &lt;- in( B201 )  Freq: 3.73125e-08
2834 +  li R11, #-42	# int, #@loadConI
2838    spill R18 -&gt; R8	# spill size = 64
283c +  spill R19 -&gt; [sp, #0]	# spill size = 64
2840 +  spill R21 -&gt; [sp, #8]	# spill size = 64
2844 +  spill R22 -&gt; [sp, #16]	# spill size = 64
2848 +  spill R10 -&gt; [sp, #24]	# spill size = 32
284c +  spill R9 -&gt; [sp, #32]	# spill size = 64
2850    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;array_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:59 (line 629) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #16 STK[1]=sp + #24 STK[2]=sp + #32
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [32]=Oop off=10324/0x2854}
2854    #@ShouldNotReachHere

2860    B418: #	out( N5509 ) &lt;- in( B210 )  Freq: 2.48769e-08
2860 +  li R11, #-42	# int, #@loadConI
2864    spill R19 -&gt; R8	# spill size = 64
2868 +  spill R9 -&gt; [sp, #0]	# spill size = 64
286c +  spill R20 -&gt; [sp, #8]	# spill size = 64
2870 +  spill R22 -&gt; [sp, #16]	# spill size = 64
2874 +  spill R29 -&gt; [sp, #24]	# spill size = 32
2878 +  spill R18 -&gt; [sp, #32]	# spill size = 64
287c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;array_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:59 (line 629) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #16 STK[1]=sp + #24 STK[2]=sp + #32
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [32]=Oop off=10368/0x2880}
2880    #@ShouldNotReachHere

288c    B419: #	out( B203 ) &lt;- in( B298 )  Freq: 1.86558e-08
288c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
288c    spill R23 -&gt; R11	# spill size = 64
2890 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
28c0 +  j  B203	#@branch

28c4    B420: #	out( B212 ) &lt;- in( B309 )  Freq: 1.24381e-08
28c4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
28c4    spill R23 -&gt; R11	# spill size = 64
28c8 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
28f8 +  j  B212	#@branch

28fc    B421: #	out( B225 ) &lt;- in( B320 )  Freq: 6.64659e-09
28fc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
28fc    spill R23 -&gt; R11	# spill size = 64
2900 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2930 +  j  B225	#@branch

2934    B422: #	out( B238 ) &lt;- in( B327 )  Freq: 4.43139e-09
2934 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2934    spill R23 -&gt; R11	# spill size = 64
2938 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2968 +  j  B238	#@branch

296c    B423: #	out( N5509 ) &lt;- in( B251 )  Freq: 1.51973e-09
296c +  li R11, #-58	# int, #@loadConI
2970    spill R18 -&gt; R8	# spill size = 64
2974 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2978 +  spill R30 -&gt; [sp, #8]	# spill size = 64
297c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;bimorphic&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_ STK[0]=sp + #0 STK[1]=sp + #8
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=10624/0x2980}
2980    #@ShouldNotReachHere

298c    B424: #	out( N5509 ) &lt;- in( B255 )  Freq: 1.50833e-09
298c +  li R11, #-12	# int, #@loadConI
2990    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:13 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=10644/0x2994}
2994    #@ShouldNotReachHere

29a0    B425: #	out( N5509 ) &lt;- in( B257 )  Freq: 1.01323e-09
29a0 +  li R11, #-58	# int, #@loadConI
29a4    spill R19 -&gt; R8	# spill size = 64
29a8 +  spill R9 -&gt; [sp, #0]	# spill size = 64
29ac +  spill R29 -&gt; [sp, #8]	# spill size = 64
29b0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;bimorphic&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_ STK[0]=sp + #0 STK[1]=sp + #8
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=10676/0x29b4}
29b4    #@ShouldNotReachHere

29c0    B426: #	out( N5509 ) &lt;- in( B261 )  Freq: 1.00563e-09
29c0 +  li R11, #-12	# int, #@loadConI
29c4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:13 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=10696/0x29c8}
29c8    #@ShouldNotReachHere

29d4    B427: #	out( N5509 ) &lt;- in( B58 )  Freq: 1e-35
29d4 +  li R11, #-34	# int, #@loadConI
29d8    spill R30 -&gt; R8	# spill size = 64
29dc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$10/0x000000080001e230::apply @ bci:1 L[0]=_ L[1]=_ STK[0]=sp + #0
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=10720/0x29e0}
29e0    #@ShouldNotReachHere

29ec    B428: #	out( N5509 ) &lt;- in( B10 )  Freq: 1e-35
29ec +  li R11, #-34	# int, #@loadConI
29f0    spill R29 -&gt; R8	# spill size = 64
29f4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$10/0x000000080001e230::apply @ bci:1 L[0]=_ L[1]=_ STK[0]=sp + #0
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=10744/0x29f8}
29f8    #@ShouldNotReachHere

2a04    B429: #	out( N5509 ) &lt;- in( B65 )  Freq: 1e-35
2a04 +  li R11, #-34	# int, #@loadConI
2a08    spill R30 -&gt; R8	# spill size = 64
2a0c +  spill R19 -&gt; [sp, #0]	# spill size = 64
2a10    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:13 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #0
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=10772/0x2a14}
2a14    #@ShouldNotReachHere

2a20    B430: #	out( N5509 ) &lt;- in( B17 )  Freq: 1e-35
2a20 +  li R11, #-34	# int, #@loadConI
2a24    spill R18 -&gt; R8	# spill size = 64
2a28 +  spill R29 -&gt; [sp, #0]	# spill size = 64
2a2c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:13 (line 273) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=10800/0x2a30}
2a30    #@ShouldNotReachHere

2a3c    B431: #	out( N5509 ) &lt;- in( B68 )  Freq: 1e-35
2a3c +  li R11, #-34	# int, #@loadConI
2a40    spill R30 -&gt; R8	# spill size = 64
2a44 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2a48 +  spill R10 -&gt; [sp, #8]	# spill size = 64
2a4c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:34 (line 276) L[0]=R8 L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ STK[0]=sp + #8
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=10832/0x2a50}
2a50    #@ShouldNotReachHere

2a5c    B432: #	out( N5509 ) &lt;- in( B20 )  Freq: 1e-35
2a5c +  li R11, #-34	# int, #@loadConI
2a60    spill R18 -&gt; R8	# spill size = 64
2a64 +  spill R29 -&gt; [sp, #0]	# spill size = 64
2a68 +  spill R12 -&gt; [sp, #8]	# spill size = 64
2a6c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:34 (line 276) L[0]=sp + #0 L[1]=_ L[2]=R8 L[3]=_ L[4]=_ STK[0]=sp + #8
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=10864/0x2a70}
2a70    #@ShouldNotReachHere

2a7c    B433: #	out( N5509 ) &lt;- in( B82 )  Freq: 1e-35
2a7c +  li R11, #-34	# int, #@loadConI
2a80    spill R19 -&gt; [sp, #0]	# spill size = 64
2a84 +  spill R9 -&gt; [sp, #8]	# spill size = 64
2a88 +  spill R7 -&gt; [sp, #16]	# spill size = 64
2a8c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:1 L[0]=_ L[1]=_ L[2]=sp + #16 STK[0]=R8
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=10896/0x2a90}
2a90    #@ShouldNotReachHere

2a9c    B434: #	out( N5509 ) &lt;- in( B34 )  Freq: 1e-35
2a9c +  li R11, #-34	# int, #@loadConI
2aa0    spill R18 -&gt; [sp, #0]	# spill size = 64
2aa4 +  spill R19 -&gt; [sp, #8]	# spill size = 64
2aa8 +  spill R7 -&gt; [sp, #16]	# spill size = 64
2aac    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:1 L[0]=_ L[1]=_ L[2]=sp + #16 STK[0]=R8
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #8 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=10928/0x2ab0}
2ab0    #@ShouldNotReachHere

2abc    B435: #	out( N5509 ) &lt;- in( B184 )  Freq: 1e-35
2abc +  li R11, #-34	# int, #@loadConI
2ac0    spill R19 -&gt; R8	# spill size = 64
2ac4 +  spill R9 -&gt; [sp, #0]	# spill size = 64
2ac8 +  spill R20 -&gt; [sp, #8]	# spill size = 64
2acc +  spill R21 -&gt; [sp, #16]	# spill size = 32
2ad0 +  spill R22 -&gt; [sp, #32]	# spill size = 64
2ad4 +  spill R24 -&gt; [sp, #40]	# spill size = 64
2ad8 +  spill R31 -&gt; [sp, #48]	# spill size = 64
2adc +  spill R10 -&gt; [sp, #64]	# spill size = 64
2ae0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=sp + #64 L[2]=_ STK[0]=sp + #64
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #48 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [48]=Oop [64]=Oop off=10980/0x2ae4}
2ae4    #@ShouldNotReachHere

2af0    B436: #	out( N5509 ) &lt;- in( B173 )  Freq: 1e-35
2af0 +  li R11, #-34	# int, #@loadConI
2af4    spill R19 -&gt; R8	# spill size = 64
2af8 +  spill R9 -&gt; [sp, #0]	# spill size = 64
2afc +  spill R20 -&gt; [sp, #8]	# spill size = 64
2b00 +  spill R21 -&gt; [sp, #16]	# spill size = 32
2b04 +  spill R22 -&gt; [sp, #32]	# spill size = 64
2b08 +  spill R12 -&gt; [sp, #40]	# spill size = 64
2b0c +  spill R28 -&gt; [sp, #20]	# spill size = 32
2b10 +  spill R15 -&gt; [sp, #48]	# spill size = 64
2b14 +  spill R10 -&gt; [sp, #64]	# spill size = 64
2b18    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=sp + #64 L[2]=_ STK[0]=sp + #64
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #48 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=_ L[12]=sp + #20
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [48]=Oop [64]=Oop off=11036/0x2b1c}
2b1c    #@ShouldNotReachHere

2b28    B437: #	out( N5509 ) &lt;- in( B134 )  Freq: 1e-35
2b28 +  li R11, #-34	# int, #@loadConI
2b2c    spill R18 -&gt; R8	# spill size = 64
2b30 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2b34 +  spill R21 -&gt; [sp, #8]	# spill size = 64
2b38 +  spill R20 -&gt; [sp, #16]	# spill size = 32
2b3c +  spill R22 -&gt; [sp, #32]	# spill size = 64
2b40 +  spill R9 -&gt; [sp, #40]	# spill size = 64
2b44 +  spill R12 -&gt; [sp, #48]	# spill size = 64
2b48 +  spill R10 -&gt; [sp, #64]	# spill size = 64
2b4c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=sp + #64 L[2]=_ STK[0]=sp + #64
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #48 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [48]=Oop [64]=Oop off=11088/0x2b50}
2b50    #@ShouldNotReachHere

2b5c    B438: #	out( N5509 ) &lt;- in( B123 )  Freq: 1e-35
2b5c +  li R11, #-34	# int, #@loadConI
2b60    spill R18 -&gt; R8	# spill size = 64
2b64 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2b68 +  spill R21 -&gt; [sp, #8]	# spill size = 64
2b6c +  spill R20 -&gt; [sp, #16]	# spill size = 32
2b70 +  spill R22 -&gt; [sp, #32]	# spill size = 64
2b74 +  spill R24 -&gt; [sp, #40]	# spill size = 64
2b78 +  spill R9 -&gt; [sp, #20]	# spill size = 32
2b7c +  spill R15 -&gt; [sp, #48]	# spill size = 64
2b80 +  spill R12 -&gt; [sp, #64]	# spill size = 64
2b84    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=sp + #64 L[2]=_ STK[0]=sp + #64
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #48 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=_ L[12]=sp + #20
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [48]=Oop [64]=Oop off=11144/0x2b88}
2b88    #@ShouldNotReachHere

2b94    B439: #	out( N5509 ) &lt;- in( B1 )  Freq: 1.01328e-06
2b94 +  li R11, #-10	# int, #@loadConI
2b98    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:8 (line 197) L[0]=_ L[1]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=11164/0x2b9c}
2b9c    #@ShouldNotReachHere

2ba8    B440: #	out( N5509 ) &lt;- in( B3 )  Freq: 1.01326e-06
2ba8 +  li R11, #-10	# int, #@loadConI
2bac    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=sp + #0
        # OopMap {[0]=Oop off=11184/0x2bb0}
2bb0    #@ShouldNotReachHere

2bbc    B441: #	out( N5509 ) &lt;- in( B49 )  Freq: 6.7557e-07
2bbc +  li R11, #-10	# int, #@loadConI
2bc0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:8 (line 197) L[0]=_ L[1]=_ STK[0]=_ STK[1]=#NULL
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {off=11204/0x2bc4}
2bc4    #@ShouldNotReachHere

2bd0    B442: #	out( N5509 ) &lt;- in( B51 )  Freq: 6.75556e-07
2bd0 +  li R11, #-10	# int, #@loadConI
2bd4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=sp + #0
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop off=11224/0x2bd8}
2bd8    #@ShouldNotReachHere

2be4    B443: #	out( N5509 ) &lt;- in( B6 )  Freq: 3.37686e-07
2be4 +  li R11, #-10	# int, #@loadConI
2be8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:4 (line 273) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=11244/0x2bec}
2bec    #@ShouldNotReachHere

2bf8    B444: #	out( N5509 ) &lt;- in( B7 )  Freq: 3.37686e-07
2bf8 +  li R11, #-10	# int, #@loadConI
2bfc    spill R29 -&gt; R8	# spill size = 64
2c00    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=sp + #0
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=11268/0x2c04}
2c04    #@ShouldNotReachHere

2c10    B445: #	out( N5509 ) &lt;- in( B9 )  Freq: 3.37685e-07
2c10 +  li R11, #-12	# int, #@loadConI
2c14    spill R29 -&gt; R8	# spill size = 64
2c18    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.module.ModulePath$$Lambda$10/0x000000080001e230::apply @ bci:1 L[0]=_ L[1]=_ STK[0]=#NULL
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=11292/0x2c1c}
2c1c    #@ShouldNotReachHere

2c28    B446: #	out( N5509 ) &lt;- in( B19 )  Freq: 3.37684e-07
2c28 +  li R11, #-10	# int, #@loadConI
2c2c    spill R18 -&gt; R8	# spill size = 64
2c30 +  spill R29 -&gt; [sp, #0]	# spill size = 64
2c34    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.AbstractPipeline::sequential @ bci:5 (line 304) L[0]=_ STK[0]=#NULL STK[1]=#0
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:29 (line 276) L[0]=sp + #0 L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=11320/0x2c38}
2c38    #@ShouldNotReachHere

2c44    B447: #	out( N5509 ) &lt;- in( B21 )  Freq: 3.37684e-07
2c44 +  li R11, #-10	# int, #@loadConI
2c48    spill R18 -&gt; R8	# spill size = 64
2c4c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.AbstractPipeline::isParallel @ bci:4 (line 373) L[0]=_ STK[0]=#NULL
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:1 (line 761) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=11344/0x2c50}
2c50    #@ShouldNotReachHere

2c5c    B448: #	out( N5509 ) &lt;- in( B146 )  Freq: 3.37677e-07
2c5c +  li R11, #-10	# int, #@loadConI
2c60    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.AbstractPipeline::close @ bci:19 (line 320) L[0]=_ L[1]=_ STK[0]=#NULL
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:94 (line 283) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {off=11364/0x2c64}
2c64    #@ShouldNotReachHere

2c70    B449: #	out( N5509 ) &lt;- in( B31 )  Freq: 3.36142e-07
2c70 +  li R11, #-10	# int, #@loadConI
2c74    spill R18 -&gt; [sp, #0]	# spill size = 64
2c78 +  spill R7 -&gt; [sp, #8]	# spill size = 64
2c7c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8 STK[2]=sp + #8
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=11392/0x2c80}
2c80    #@ShouldNotReachHere

2c8c    B450: #	out( N5509 ) &lt;- in( B33 )  Freq: 3.36142e-07
2c8c +  li R11, #-12	# int, #@loadConI
2c90    spill R18 -&gt; R8	# spill size = 64
2c94 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2c98 +  spill R7 -&gt; [sp, #8]	# spill size = 64
2c9c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:1 L[0]=_ L[1]=_ L[2]=sp + #8 STK[0]=#NULL
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=11424/0x2ca0}
2ca0    #@ShouldNotReachHere

2cac    B451: #	out( N5509 ) &lt;- in( B54 )  Freq: 2.25141e-07
2cac +  li R11, #-10	# int, #@loadConI
2cb0    spill R30 -&gt; R8	# spill size = 64
2cb4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:4 (line 273) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=11448/0x2cb8}
2cb8    #@ShouldNotReachHere

2cc4    B452: #	out( N5509 ) &lt;- in( B55 )  Freq: 2.25141e-07
2cc4 +  li R11, #-10	# int, #@loadConI
2cc8    spill R30 -&gt; R8	# spill size = 64
2ccc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=sp + #0
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=11472/0x2cd0}
2cd0    #@ShouldNotReachHere

2cdc    B453: #	out( N5509 ) &lt;- in( B57 )  Freq: 2.2514e-07
2cdc +  li R11, #-12	# int, #@loadConI
2ce0    spill R30 -&gt; R8	# spill size = 64
2ce4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.module.ModulePath$$Lambda$10/0x000000080001e230::apply @ bci:1 L[0]=_ L[1]=_ STK[0]=#NULL
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:8 (line 273) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=11496/0x2ce8}
2ce8    #@ShouldNotReachHere

2cf4    B454: #	out( N5509 ) &lt;- in( B67 )  Freq: 2.2514e-07
2cf4 +  li R11, #-10	# int, #@loadConI
2cf8    spill R30 -&gt; R8	# spill size = 64
2cfc +  spill R19 -&gt; [sp, #0]	# spill size = 64
2d00    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.AbstractPipeline::sequential @ bci:5 (line 304) L[0]=_ STK[0]=#NULL STK[1]=#0
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:29 (line 276) L[0]=R8 L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=11524/0x2d04}
2d04    #@ShouldNotReachHere

2d10    B455: #	out( N5509 ) &lt;- in( B69 )  Freq: 2.2514e-07
2d10 +  li R11, #-10	# int, #@loadConI
2d14    spill R19 -&gt; R8	# spill size = 64
2d18    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.AbstractPipeline::isParallel @ bci:4 (line 373) L[0]=_ STK[0]=#NULL
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:1 (line 761) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=11548/0x2d1c}
2d1c    #@ShouldNotReachHere

2d28    B456: #	out( N5509 ) &lt;- in( B196 )  Freq: 2.25135e-07
2d28 +  li R11, #-10	# int, #@loadConI
2d2c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.AbstractPipeline::close @ bci:19 (line 320) L[0]=_ L[1]=_ STK[0]=#NULL
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:94 (line 283) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {off=11568/0x2d30}
2d30    #@ShouldNotReachHere

2d3c    B457: #	out( N5509 ) &lt;- in( B79 )  Freq: 2.24112e-07
2d3c +  li R11, #-10	# int, #@loadConI
2d40    spill R19 -&gt; [sp, #0]	# spill size = 64
2d44 +  spill R7 -&gt; [sp, #8]	# spill size = 64
2d48    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8 STK[2]=sp + #8
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=11596/0x2d4c}
2d4c    #@ShouldNotReachHere

2d58    B458: #	out( N5509 ) &lt;- in( B81 )  Freq: 2.24111e-07
2d58 +  li R11, #-12	# int, #@loadConI
2d5c    spill R19 -&gt; R8	# spill size = 64
2d60 +  spill R9 -&gt; [sp, #0]	# spill size = 64
2d64 +  spill R7 -&gt; [sp, #8]	# spill size = 64
2d68    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:1 L[0]=_ L[1]=_ L[2]=sp + #8 STK[0]=#NULL
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=11628/0x2d6c}
2d6c    #@ShouldNotReachHere

2d78    B459: #	out( N5509 ) &lt;- in( B42 )  Freq: 1.73163e-07
2d78 +  li R11, #-10	# int, #@loadConI
2d7c    spill R18 -&gt; R8	# spill size = 64
2d80    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:5 (line 196) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=_ L[1]=_
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=_ L[2]=_ STK[0]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=11652/0x2d84}
2d84    #@ShouldNotReachHere

2d90    B460: #	out( N5509 ) &lt;- in( B25 )  Freq: 1.5891e-07
2d90 +  li R11, #-187	# int, #@loadConI
2d94    spill R18 -&gt; R8	# spill size = 64
2d98 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2d9c +  spill R30 -&gt; [sp, #8]	# spill size = 64
2da0 +  spill R12 -&gt; [sp, #16]	# spill size = 64
2da4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.AbstractPipeline::sourceStageSpliterator @ bci:45 (line 282) L[0]=sp + #16 L[1]=_ STK[0]=sp + #0
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:8 (line 762) L[0]=_ L[1]=sp + #8
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=11688/0x2da8}
2da8    #@ShouldNotReachHere

2db4    B461: #	out( N5509 ) &lt;- in( B28 )  Freq: 1.58185e-07
2db4 +  li R11, #-187	# int, #@loadConI
2db8    spill R18 -&gt; R8	# spill size = 64
2dbc +  spill R19 -&gt; [sp, #0]	# spill size = 64
2dc0 +  spill R30 -&gt; [sp, #16]	# spill size = 64
2dc4 +  spill R30 -&gt; [sp, #24]	# spill size = 64
2dc8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.Objects::requireNonNull @ bci:1 (line 208) L[0]=sp + #24 STK[0]=sp + #16
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:1 (line 408) L[0]=sp + #0 L[1]=sp + #16
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=11724/0x2dcc}
2dcc    #@ShouldNotReachHere

2dd8    B462: #	out( N5509 ) &lt;- in( B36 )  Freq: 1.58184e-07
2dd8 +  li R11, #-187	# int, #@loadConI
2ddc    spill R18 -&gt; R8	# spill size = 64
2de0 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2de4 +  spill R21 -&gt; [sp, #16]	# spill size = 64
2de8 +  spill R7 -&gt; [sp, #24]	# spill size = 64
2dec +  spill R7 -&gt; [sp, #32]	# spill size = 64
2df0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::hash @ bci:1 (line 338) L[0]=sp + #32 L[1]=_ STK[0]=sp + #24
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #24 L[2]=#Ptr0x00000040d82922a0 STK[0]=sp + #16
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop off=11764/0x2df4}
2df4    #@ShouldNotReachHere

2e00    B463: #	out( N5509 ) &lt;- in( B133 )  Freq: 1.4601e-07
2e00 +  li R11, #-12	# int, #@loadConI
2e04    spill R18 -&gt; R8	# spill size = 64
2e08 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2e0c +  spill R21 -&gt; [sp, #8]	# spill size = 64
2e10 +  spill R20 -&gt; [sp, #16]	# spill size = 32
2e14 +  spill R22 -&gt; [sp, #32]	# spill size = 64
2e18 +  spill R9 -&gt; [sp, #40]	# spill size = 64
2e1c +  spill R12 -&gt; [sp, #48]	# spill size = 64
2e20    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #48 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [48]=Oop off=11812/0x2e24}
2e24    #@ShouldNotReachHere

2e30    B464: #	out( N5509 ) &lt;- in( B122 )  Freq: 1.20386e-07
2e30 +  li R11, #-12	# int, #@loadConI
2e34    spill R18 -&gt; R8	# spill size = 64
2e38 +  spill R19 -&gt; [sp, #0]	# spill size = 64
2e3c +  spill R21 -&gt; [sp, #8]	# spill size = 64
2e40 +  spill R20 -&gt; [sp, #16]	# spill size = 32
2e44 +  spill R22 -&gt; [sp, #32]	# spill size = 64
2e48 +  spill R24 -&gt; [sp, #40]	# spill size = 64
2e4c +  spill R9 -&gt; [sp, #20]	# spill size = 32
2e50 +  spill R15 -&gt; [sp, #48]	# spill size = 64
2e54    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #48 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=_ L[12]=sp + #20
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [48]=Oop off=11864/0x2e58}
2e58    #@ShouldNotReachHere

2e64    B465: #	out( N5509 ) &lt;- in( B90 )  Freq: 1.15451e-07
2e64 +  li R11, #-10	# int, #@loadConI
2e68    spill R19 -&gt; R8	# spill size = 64
2e6c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:5 (line 196) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=_ L[1]=_
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=_ L[2]=_ STK[0]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=11888/0x2e70}
2e70    #@ShouldNotReachHere

2e7c    B466: #	out( N5509 ) &lt;- in( B73 )  Freq: 1.05948e-07
2e7c +  li R11, #-187	# int, #@loadConI
2e80    spill R19 -&gt; R8	# spill size = 64
2e84 +  spill R29 -&gt; [sp, #0]	# spill size = 64
2e88 +  spill R10 -&gt; [sp, #8]	# spill size = 64
2e8c +  spill R9 -&gt; [sp, #16]	# spill size = 64
2e90    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.stream.AbstractPipeline::sourceStageSpliterator @ bci:45 (line 282) L[0]=sp + #8 L[1]=_ STK[0]=sp + #16
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:8 (line 762) L[0]=_ L[1]=sp + #0
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=11924/0x2e94}
2e94    #@ShouldNotReachHere

2ea0    B467: #	out( N5509 ) &lt;- in( B76 )  Freq: 1.05465e-07
2ea0 +  li R11, #-187	# int, #@loadConI
2ea4    spill R19 -&gt; R8	# spill size = 64
2ea8 +  spill R9 -&gt; [sp, #0]	# spill size = 64
2eac +  spill R29 -&gt; [sp, #16]	# spill size = 64
2eb0 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2eb4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.Objects::requireNonNull @ bci:1 (line 208) L[0]=sp + #24 STK[0]=sp + #16
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:1 (line 408) L[0]=sp + #0 L[1]=sp + #16
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=11960/0x2eb8}
2eb8    #@ShouldNotReachHere

2ec4    B468: #	out( N5509 ) &lt;- in( B84 )  Freq: 1.05464e-07
2ec4 +  li R11, #-187	# int, #@loadConI
2ec8    spill R19 -&gt; R8	# spill size = 64
2ecc +  spill R9 -&gt; [sp, #0]	# spill size = 64
2ed0 +  spill R20 -&gt; [sp, #16]	# spill size = 64
2ed4 +  spill R7 -&gt; [sp, #24]	# spill size = 64
2ed8 +  spill R7 -&gt; [sp, #32]	# spill size = 64
2edc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::hash @ bci:1 (line 338) L[0]=sp + #32 L[1]=_ STK[0]=sp + #24
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #24 L[2]=#Ptr0x00000040d82922a0 STK[0]=sp + #16
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop off=12000/0x2ee0}
2ee0    #@ShouldNotReachHere

2eec    B469: #	out( N5509 ) &lt;- in( B183 )  Freq: 9.73473e-08
2eec +  li R11, #-12	# int, #@loadConI
2ef0    spill R19 -&gt; R8	# spill size = 64
2ef4 +  spill R9 -&gt; [sp, #0]	# spill size = 64
2ef8 +  spill R20 -&gt; [sp, #8]	# spill size = 64
2efc +  spill R21 -&gt; [sp, #16]	# spill size = 32
2f00 +  spill R22 -&gt; [sp, #32]	# spill size = 64
2f04 +  spill R24 -&gt; [sp, #40]	# spill size = 64
2f08 +  spill R31 -&gt; [sp, #48]	# spill size = 64
2f0c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #48 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [48]=Oop off=12048/0x2f10}
2f10    #@ShouldNotReachHere

2f1c    B470: #	out( N5509 ) &lt;- in( B172 )  Freq: 8.02637e-08
2f1c +  li R11, #-12	# int, #@loadConI
2f20    spill R19 -&gt; R8	# spill size = 64
2f24 +  spill R9 -&gt; [sp, #0]	# spill size = 64
2f28 +  spill R20 -&gt; [sp, #8]	# spill size = 64
2f2c +  spill R21 -&gt; [sp, #16]	# spill size = 32
2f30 +  spill R22 -&gt; [sp, #32]	# spill size = 64
2f34 +  spill R12 -&gt; [sp, #40]	# spill size = 64
2f38 +  spill R28 -&gt; [sp, #20]	# spill size = 32
2f3c +  spill R15 -&gt; [sp, #48]	# spill size = 64
2f40    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #48 L[3]=#Ptr0x00000040d82922a0 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=_ L[12]=sp + #20
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=sp + #0 L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [48]=Oop off=12100/0x2f44}
2f44    #@ShouldNotReachHere

2f50    B471: #	out( N5509 ) &lt;- in( B230 )  Freq: 1.07146e-08
2f50 +  li R11, #-10	# int, #@loadConI
2f54    spill [sp, #0] -&gt; R8	# spill size = 64
2f58    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:26 (line 627) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#NULL
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=12124/0x2f5c}
2f5c    #@ShouldNotReachHere

2f68    B472: #	out( N5509 ) &lt;- in( B243 )  Freq: 7.14363e-09
2f68 +  li R11, #-10	# int, #@loadConI
2f6c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:26 (line 627) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#NULL
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # java.util.stream.Collectors$$Lambda$12/0x0000000800008ea8::accept @ bci:8 L[0]=_ L[1]=_ L[2]=_
        # java.util.stream.ReduceOps$3ReducingSink::accept @ bci:9 (line 169) L[0]=_ L[1]=_
        # java.util.stream.Streams$StreamBuilderImpl::forEachRemaining @ bci:19 (line 411) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$Head::forEach @ bci:12 (line 762) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:41 (line 276) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=12144/0x2f70}
2f70    #@ShouldNotReachHere

2f7c    B473: #	out( B497 ) &lt;- in( B475 )  Freq: 1.29368e-17
2f7c     -- 	// exception oop; no code emitted, #@CreateException
2f7c +  spill R10 -&gt; [sp, #0]	# spill size = 64
2f80 +  j  B497	#@branch

2f84    B474: #	out( B502 ) &lt;- in( B477 )  Freq: 1.94038e-17
2f84     -- 	// exception oop; no code emitted, #@CreateException
2f84 +  spill R10 -&gt; R8	# spill size = 64
2f88 +  j  B502	#@branch

2f8c    B475: #	out( B473 B476 ) &lt;- in( B496 )  Freq: 1.29368e-12
2f8c     -- 	// exception oop; no code emitted, #@CreateException
2f8c +  spill [sp, #0] -&gt; R11	# spill size = 64
2f90 +  spill R10 -&gt; R12	# spill size = 64
2f94    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.Throwable::addSuppressed
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:121 (line 273) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop off=12184/0x2f98}

2f98    B476: #	out( B497 ) &lt;- in( B475 )  Freq: 1.29366e-12
        # Block is sole successor of call
2f98 +  j  B497	#@branch

2f9c    B477: #	out( B474 B478 ) &lt;- in( B501 )  Freq: 1.94038e-12
2f9c     -- 	// exception oop; no code emitted, #@CreateException
2f9c +  spill R8 -&gt; R11	# spill size = 64
2fa0 +  spill R10 -&gt; R12	# spill size = 64
2fa4    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.Throwable::addSuppressed
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:121 (line 273) L[0]=_ L[1]=_ L[2]=_ L[3]=R8 L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=12200/0x2fa8}

2fa8    B478: #	out( B502 ) &lt;- in( B477 )  Freq: 1.94034e-12
        # Block is sole successor of call
2fa8 +  j  B502	#@branch

2fac    B479: #	out( B494 ) &lt;- in( B339 )  Freq: 8.86448e-12
2fac     -- 	// exception oop; no code emitted, #@CreateException
2fac +  j  B494	#@branch

2fb0    B480: #	out( B499 ) &lt;- in( B337 )  Freq: 1.32957e-11
2fb0     -- 	// exception oop; no code emitted, #@CreateException
2fb0 +  j  B499	#@branch

2fb4    B481: #	out( B494 ) &lt;- in( B335 )  Freq: 2.4881e-11
2fb4     -- 	// exception oop; no code emitted, #@CreateException
2fb4 +  j  B494	#@branch

2fb8    B482: #	out( B499 ) &lt;- in( B333 )  Freq: 3.73187e-11
2fb8     -- 	// exception oop; no code emitted, #@CreateException
2fb8 +  j  B499	#@branch

2fbc    B483: #	out( B488 ) &lt;- in( B315 )  Freq: 2.21234e-10
2fbc     -- 	// exception oop; no code emitted, #@CreateException
2fbc +  j  B488	#@branch

2fc0    B484: #	out( B488 ) &lt;- in( B317 )  Freq: 2.21234e-10
2fc0     -- 	// exception oop; no code emitted, #@CreateException
2fc0 +  j  B488	#@branch

2fc4    B485: #	out( B490 ) &lt;- in( B304 )  Freq: 3.31826e-10
2fc4     -- 	// exception oop; no code emitted, #@CreateException
2fc4 +  j  B490	#@branch

2fc8    B486: #	out( B490 ) &lt;- in( B306 )  Freq: 3.31826e-10
2fc8     -- 	// exception oop; no code emitted, #@CreateException
2fc8 +  j  B490	#@branch

2fcc    B487: #	out( B488 ) &lt;- in( B260 )  Freq: 9.9247e-09
2fcc     -- 	// exception oop; no code emitted, #@CreateException

2fcc    B488: #	out( B497 ) &lt;- in( B487 B483 B484 )  Freq: 1.03672e-08
2fcc +  spill R10 -&gt; [sp, #0]	# spill size = 64
2fd0 +  j  B497	#@branch

2fd4    B489: #	out( B490 ) &lt;- in( B254 )  Freq: 1.48859e-08
2fd4     -- 	// exception oop; no code emitted, #@CreateException

2fd4    B490: #	out( B502 ) &lt;- in( B489 B485 B486 )  Freq: 1.55496e-08
2fd4 +  spill R10 -&gt; R8	# spill size = 64
2fd8 +  j  B502	#@branch

2fdc    B491: #	out( B494 ) &lt;- in( B215 )  Freq: 1.61146e-08
2fdc     -- 	// exception oop; no code emitted, #@CreateException
2fdc +  j  B494	#@branch

2fe0    B492: #	out( B499 ) &lt;- in( B206 )  Freq: 2.417e-08
2fe0     -- 	// exception oop; no code emitted, #@CreateException
2fe0 +  j  B499	#@branch

2fe4    B493: #	out( B494 ) &lt;- in( B242 )  Freq: 7.05015e-08
2fe4     -- 	// exception oop; no code emitted, #@CreateException

2fe4    B494: #	out( B496 ) &lt;- in( B493 B481 B479 B491 )  Freq: 8.66498e-08
2fe4 +  spill R10 -&gt; [sp, #0]	# spill size = 64
2fe8 +  j  B496	#@branch

2fec    B495: #	out( B496 ) &lt;- in( B249 )  Freq: 4.27183e-08
2fec     -- 	// exception oop; no code emitted, #@CreateException
2fec +  spill R10 -&gt; [sp, #0]	# spill size = 64

2ff0    B496: #	out( B475 B497 ) &lt;- in( B495 B494 )  Freq: 1.29368e-07
2ff0 +  spill R8 -&gt; R11	# spill size = 64
2ff4 +  # checkcastPP of R11, #@checkCastPP
2ff4    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.stream.AbstractPipeline::close
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:108 (line 273) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {[0]=Oop off=12280/0x2ff8}

2ff8    B497: #	out( B505 ) &lt;- in( B488 B473 B476 B496 )  Freq: 1.39734e-07
2ff8 +  spill [sp, #0] -&gt; R10	# spill size = 64
2ffc +  j  B505	#@branch

3000    B498: #	out( B499 ) &lt;- in( B229 )  Freq: 1.05744e-07
3000     -- 	// exception oop; no code emitted, #@CreateException

3000    B499: #	out( B501 ) &lt;- in( B498 B482 B480 B492 )  Freq: 1.29965e-07
3000 +  spill R10 -&gt; R8	# spill size = 64
3004 +  j  B501	#@branch

3008    B500: #	out( B501 ) &lt;- in( B245 )  Freq: 6.40726e-08
3008     -- 	// exception oop; no code emitted, #@CreateException
3008 +  spill R10 -&gt; R8	# spill size = 64

300c    B501: #	out( B477 B502 ) &lt;- in( B500 B499 )  Freq: 1.94038e-07
300c +  spill [sp, #0] -&gt; R11	# spill size = 64
3010 +  # checkcastPP of R11, #@checkCastPP
3010    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.stream.AbstractPipeline::close
        # java.util.stream.ReferencePipeline$7$1::accept @ bci:108 (line 273) L[0]=_ L[1]=_ L[2]=_ L[3]=R8 L[4]=_
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=12308/0x3014}

3014    B502: #	out( B507 ) &lt;- in( B490 B474 B478 B501 )  Freq: 2.09585e-07
3014 +  spill R8 -&gt; R11	# spill size = 64
3018 +  j  B507	#@branch

301c    B503: #	out( B505 ) &lt;- in( B50 )  Freq: 6.66716e-06
301c     -- 	// exception oop; no code emitted, #@CreateException
301c +  j  B505	#@branch

3020    B504: #	out( B505 ) &lt;- in( B97 )  Freq: 4.44512e-06
3020     -- 	// exception oop; no code emitted, #@CreateException

3020    B505: #	out( B507 ) &lt;- in( B503 B497 B504 )  Freq: 1.1252e-05
3020 +  spill R10 -&gt; R11	# spill size = 64
3024 +  j  B507	#@branch

3028    B506: #	out( B507 ) &lt;- in( B2 )  Freq: 9.99999e-06
3028     -- 	// exception oop; no code emitted, #@CreateException
3028 +  spill R10 -&gt; R11	# spill size = 64

302c    B507: #	out( N5509 ) &lt;- in( B506 B502 B505 )  Freq: 2.14616e-05
302c    # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
3038 +  j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='313'>
----------------------- MetaData before Compile_id = 313 ------------------------
{method}
 - this oop:          0x00000040960100c8
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000008  static 
 - name:              &apos;checkBoundsBeginEnd&apos;
 - signature:         &apos;(III)V&apos;
 - max stack:         5
 - max locals:        3
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x0000004008318650: 0xaaa i2c: 0x0000004013943c40 c2i: 0x0000004013943c8c c2iUV: 0x0000004013943c58
 - compiled entry     0x000000400c4dd340
 - code size:         63
 - code start:        0x0000004096010058
 - code end (excl):   0x0000004096010097
 - method data:       0x000000409658c430
 - checked ex length: 0
 - linenumber start:  0x0000004096010097
 - localvar length:   3
 - localvar start:    0x00000040960100a2
 - compiled code: nmethod   9280   90       3       java.lang.String::checkBoundsBeginEnd (63 bytes)

------------------------ OptoAssembly for Compile_id = 313 -----------------------
#
#  void ( int, int, int )
#
#r012 c_rarg1   : parm 0: int
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B5 B6 B7 B4 )  Freq: 1

000     B1: #	out( B5 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     blt  R11, zr, B5	#@cmpI_reg_imm0_branch  P=0.000000 C=5374.000000

020     B2: #	out( B6 B3 ) &lt;- in( B1 )  Freq: 1
020 +   bgt  R11, R12, B6	#@cmpI_branch  P=0.000000 C=5374.000000

024     B3: #	out( B7 B4 ) &lt;- in( B2 )  Freq: 0.999999
024 +   bgt  R12, R13, B7	#@cmpI_branch  P=0.000000 C=5374.000000

028     B4: #	out( N1 ) &lt;- in( B3 )  Freq: 0.999999
028     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
040 +   ret	// return register, #@Ret

044     B5: #	out( N1 ) &lt;- in( B1 )  Freq: 5e-07
044 +   spill R11 -&gt; [sp, #8]	# spill size = 32
048 +   spill R12 -&gt; [sp, #0]	# spill size = 32
04c +   spill R13 -&gt; [sp, #4]	# spill size = 32
050 +   li R11, #-187	# int, #@loadConI
054     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:1 (line 4598) L[0]=sp + #8 L[1]=sp + #0 L[2]=sp + #4 STK[0]=sp + #8
        # OopMap {off=88/0x58}
058     #@ShouldNotReachHere

064     B6: #	out( N1 ) &lt;- in( B2 )  Freq: 4.76837e-07
064 +   spill R11 -&gt; [sp, #8]	# spill size = 32
068 +   spill R13 -&gt; [sp, #4]	# spill size = 32
06c +   spill R12 -&gt; [sp, #12]	# spill size = 32
070 +   li R11, #-187	# int, #@loadConI
074     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:6 (line 4598) L[0]=sp + #8 L[1]=sp + #12 L[2]=sp + #4 STK[0]=sp + #8 STK[1]=sp + #12
        # OopMap {off=120/0x78}
078     #@ShouldNotReachHere

084     B7: #	out( N1 ) &lt;- in( B3 )  Freq: 4.76837e-07
084 +   spill R11 -&gt; R8	# spill size = 32
088 +   spill R12 -&gt; [sp, #8]	# spill size = 32
08c +   spill R13 -&gt; [sp, #12]	# spill size = 32
090 +   li R11, #-187	# int, #@loadConI
094     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:11 (line 4598) L[0]=R8 L[1]=sp + #8 L[2]=sp + #12 STK[0]=sp + #8 STK[1]=sp + #12
        # OopMap {off=152/0x98}
098 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='314'>
----------------------- MetaData before Compile_id = 314 ------------------------
{method}
 - this oop:          0x000000409600c2c8
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;substring&apos;
 - signature:         &apos;(II)Ljava/lang/String;&apos;
 - max stack:         4
 - max locals:        5
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x0000004008316ed0: 0xbaa i2c: 0x0000004013945bc0 c2i: 0x0000004013945c0c c2iUV: 0x0000004013945bd8
 - compiled entry     0x000000400c4cf880
 - code size:         58
 - code start:        0x000000409600c240
 - code end (excl):   0x000000409600c27a
 - method data:       0x000000409658c198
 - checked ex length: 0
 - linenumber start:  0x000000409600c27a
 - localvar length:   5
 - localvar start:    0x000000409600c28a
 - compiled code: nmethod   9306   61       3       java.lang.String::substring (58 bytes)

------------------------ OptoAssembly for Compile_id = 314 -----------------------
#
#  java/lang/String:exact * ( java/lang/String:NotNull:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N143: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B18 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lwu  R28, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
040 +   spill R11 -&gt; R29	# spill size = 64
044 +   decode_heap_oop  R11, R28	#@decodeHeapOop
048     lwu  R7, [R11, #12]	# range, #@loadRange
04c     NullCheck R11

04c     B2: #	out( B13 B3 ) &lt;- in( B1 )  Freq: 0.999999
04c +   lb  R28, [R29, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
050 +   sraw  R8, R7, R28	#@rShiftI_reg_reg
054 +   blt  R12, zr, B13	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

058     B3: #	out( B15 B4 ) &lt;- in( B2 )  Freq: 0.999999
058 +   bgt  R12, R13, B15	#@cmpI_branch  P=0.000000 C=5375.000000

05c     B4: #	out( B16 B5 ) &lt;- in( B3 )  Freq: 0.999998
05c +   bgt  R13, R8, B16	#@cmpI_branch  P=0.000000 C=5375.000000

060     B5: #	out( B8 B6 ) &lt;- in( B4 )  Freq: 0.999998
060 +   bne  R12, zr, B8	#@cmpI_reg_imm0_branch  P=0.627721 C=5375.000000

064     B6: #	out( B12 B7 ) &lt;- in( B5 )  Freq: 0.372278
064 +   beq  R13, R8, B12	#@cmpI_branch  P=0.011494 C=2001.000000

068     B7: #	out( B9 ) &lt;- in( B6 )  Freq: 0.367999
068 +   li R12, #0	# int, #@loadConI
06c +   j  B9	#@branch

070     B8: #	out( B9 ) &lt;- in( B5 )  Freq: 0.627719
070 +   subw  R13, R13, R12	#@subI_reg_reg

074     B9: #	out( B14 B10 ) &lt;- in( B7 B8 )  Freq: 0.995718
074 +   bne  R28, zr, B14	#@cmpI_reg_imm0_branch  P=0.000000 C=42978.000000

078     B10: #	out( B17 B11 ) &lt;- in( B9 )  Freq: 0.995718
078     CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringLatin1::newString
        # java.lang.String::substring @ bci:41 (line 2707) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # OopMap {off=124/0x7c}

07c     B11: #	out( N143 ) &lt;- in( B12 B10 )  Freq: 0.999977
07c     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
094 +   ret	// return register, #@Ret

098     B12: #	out( B11 ) &lt;- in( B6 )  Freq: 0.00427907
098 +   spill R29 -&gt; R10	# spill size = 64
09c +   j  B11	#@branch

0a0     B13: #	out( N143 ) &lt;- in( B2 )  Freq: 4.99999e-07
0a0 +   li R11, #-187	# int, #@loadConI
0a4     spill R29 -&gt; [sp, #0]	# spill size = 64
0a8 +   spill R12 -&gt; [sp, #16]	# spill size = 32
0ac +   spill R13 -&gt; [sp, #20]	# spill size = 32
0b0 +   spill R12 -&gt; [sp, #24]	# spill size = 32
0b4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:1 (line 4598) L[0]=sp + #24 L[1]=sp + #20 L[2]=R8 STK[0]=sp + #16
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #0 L[1]=sp + #16 L[2]=sp + #20 L[3]=R8 L[4]=_
        # OopMap {[0]=Oop off=184/0xb8}
0b8     #@ShouldNotReachHere

0c4     B14: #	out( N143 ) &lt;- in( B9 )  Freq: 4.97859e-07
0c4 +   li R11, #-187	# int, #@loadConI
0c8     spill R29 -&gt; R8	# spill size = 64
0cc +   spill R12 -&gt; [sp, #0]	# spill size = 32
0d0 +   spill R13 -&gt; [sp, #4]	# spill size = 32
0d4 +   spill R28 -&gt; [sp, #8]	# spill size = 32
0d8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #8
        # java.lang.String::substring @ bci:28 (line 2707) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=sp + #4
        # OopMap {fp=Oop off=220/0xdc}
0dc     #@ShouldNotReachHere

0e8     B15: #	out( N143 ) &lt;- in( B3 )  Freq: 4.76836e-07
0e8 +   li R11, #-187	# int, #@loadConI
0ec     spill R29 -&gt; [sp, #0]	# spill size = 64
0f0 +   spill R12 -&gt; [sp, #16]	# spill size = 32
0f4 +   spill R13 -&gt; [sp, #20]	# spill size = 32
0f8 +   spill R12 -&gt; [sp, #24]	# spill size = 32
0fc +   spill R13 -&gt; [sp, #28]	# spill size = 32
100     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:6 (line 4598) L[0]=sp + #24 L[1]=sp + #28 L[2]=R8 STK[0]=sp + #16 STK[1]=sp + #20
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #0 L[1]=sp + #16 L[2]=sp + #20 L[3]=R8 L[4]=_
        # OopMap {[0]=Oop off=260/0x104}
104     #@ShouldNotReachHere

110     B16: #	out( N143 ) &lt;- in( B4 )  Freq: 4.76836e-07
110 +   li R11, #-187	# int, #@loadConI
114     spill R29 -&gt; [sp, #0]	# spill size = 64
118 +   spill R12 -&gt; [sp, #16]	# spill size = 32
11c +   spill R13 -&gt; [sp, #20]	# spill size = 32
120 +   spill R13 -&gt; [sp, #24]	# spill size = 32
124     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:11 (line 4598) L[0]=sp + #16 L[1]=sp + #24 L[2]=R8 STK[0]=sp + #20 STK[1]=R8
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #0 L[1]=sp + #16 L[2]=sp + #20 L[3]=R8 L[4]=_
        # OopMap {[0]=Oop off=296/0x128}
128     #@ShouldNotReachHere

134     B17: #	out( N143 ) &lt;- in( B10 )  Freq: 9.95718e-06
134      -- 	// exception oop; no code emitted, #@CreateException
134 +   spill R10 -&gt; R11	# spill size = 64
138 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
144 +   j rethrow_stub	#@RethrowException

14c     B18: #	out( N143 ) &lt;- in( B1 )  Freq: 1.01328e-06
14c +   li R11, #-10	# int, #@loadConI
150     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::substring @ bci:1 (line 2701) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # OopMap {off=340/0x154}
154     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='315'>
----------------------- MetaData before Compile_id = 315 ------------------------
{method}
 - this oop:          0x00000040962b8388
 - method holder:     &apos;sun/nio/fs/UnixPath&apos;
 - constants:         0x00000040962b5440 constant pool [472] {0x00000040962b5440} for &apos;sun/nio/fs/UnixPath&apos; cache=0x00000040962ba1a0
 - access:            0xc1000001  public 
 - name:              &apos;relativize&apos;
 - signature:         &apos;(Ljava/nio/file/Path;)Lsun/nio/fs/UnixPath;&apos;
 - max stack:         6
 - max locals:        15
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      32
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824bb30: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c556540
 - code size:         408
 - code start:        0x00000040962b80e8
 - code end (excl):   0x00000040962b8280
 - method data:       0x0000004096496be8
 - checked ex length: 0
 - linenumber start:  0x00000040962b8280
 - localvar length:   17
 - localvar start:    0x00000040962b82ba
 - compiled code: nmethod   9881  275       3       sun.nio.fs.UnixPath::relativize (408 bytes)

------------------------ OptoAssembly for Compile_id = 315 -----------------------
#
#  sun/nio/fs/UnixPath * ( sun/nio/fs/UnixPath:NotNull *, java/nio/file/Path * )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixPath:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/nio/file/Path *
# -- Old sp -- Framesize: 128 --
#r263 sp+124: in_preserve
#r262 sp+120: return address
#r261 sp+116: in_preserve
#r260 sp+112: saved fp register
#r259 sp+108: pad2, stack alignment
#r258 sp+104: pad2, stack alignment
#r257 sp+100: Fixed slot 1
#r256 sp+96: Fixed slot 0
#r287 sp+92: spill
#r286 sp+88: spill
#r285 sp+84: spill
#r284 sp+80: spill
#r283 sp+76: spill
#r282 sp+72: spill
#r281 sp+68: spill
#r280 sp+64: spill
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
0000    N2499: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0000    # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

0020    B1: #	out( B238 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0020    # stack bang size=128
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #128
	
003c    spill R11 -&gt; R7	# spill size = 64
0040    lwu  R29, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0044    NullCheck R12

0044    B2: #	out( B215 B3 ) &lt;- in( B1 )  Freq: 1
0044 +  mv  R28, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d060f9c0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0054 +  bne  R29, R28, B215	#@cmpN_branch  P=0.000000 C=-1.000000

0058    B3: #	out( B226 B4 ) &lt;- in( B2 )  Freq: 1
0058 +  lwu  R28, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
005c +  # checkcastPP of R12, #@checkCastPP
005c    lwu  R7, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
0060 +  decode_heap_oop  R17, R28	#@decodeHeapOop
0064    spill R11 -&gt; R14	# spill size = 64
0068 +  decode_heap_oop  R9, R7	#@decodeHeapOop
006c    lwu  R30, [R9, #12]	# range, #@loadRange
0070    NullCheck R9

0070    B4: #	out( B227 B5 ) &lt;- in( B3 )  Freq: 0.999999
0070    lwu  R16, [R17, #12]	# range, #@loadRange
0074    NullCheck R17

0074    B5: #	out( B31 B6 ) &lt;- in( B4 )  Freq: 0.999997
0074 +  spill R16 -&gt; R8	# spill size = 32
0078 +  CMove R8, (R30 lt R16), R8, R30	#@cmovI_cmpI
	
0080 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0080    ble  R8, zr, B31	#@cmpI_reg_imm0_branch  P=0.045878 C=22320.000000

0084    B6: #	out( B190 B7 ) &lt;- in( B5 )  Freq: 0.954119
0084 +  addiw  R7, R8, #-1	#@addI_reg_imm
0088 +  bleu  R30, zr, B190	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

008c    B7: #	out( B190 B8 ) &lt;- in( B6 )  Freq: 0.954119
008c +  bgeu  R7, R30, B190	#@cmpU_branch  P=0.000001 C=-1.000000

0090    B8: #	out( B190 B9 ) &lt;- in( B7 )  Freq: 0.954118
0090 +  lbu  R10, [R9, #16]	# byte, #@loadUB
0094 +  bleu  R16, zr, B190	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

0098    B9: #	out( B190 B10 ) &lt;- in( B8 )  Freq: 0.954117
0098 +  bgeu  R7, R16, B190	#@cmpU_branch  P=0.000001 C=-1.000000

009c    B10: #	out( B214 B11 ) &lt;- in( B9 )  Freq: 0.954116
009c +  lbu  R13, [R17, #16]	# byte, #@loadUB
00a0 +  bne  R10, R13, B214	#@cmpI_branch  P=0.000000 C=21296.000000

00a4    B11: #	out( B191 B12 ) &lt;- in( B10 )  Freq: 0.954115
00a4 +  li R29, #-2147483648	# int, #@loadConI
00a8 +  addiw  R15, R8, #-3	#@addI_reg_imm
00ac    CMove R15, (R7 lt R15), R15, R29	#@cmovI_cmpI
	
00b4 +  li R7, #1	# int, #@loadConI
00b8 +  ble  R15, R7, B191	#@cmpI_branch  P=0.000001 C=-1.000000

00bc    B12: #	out( B192 B13 ) &lt;- in( B11 )  Freq: 0.954114
00bc +  li R28, #1	# int, #@loadConI
00c0 +  bleu  R16, R28, B192	#@cmpU_branch  P=0.000001 C=-1.000000

00c4    B13: #	out( B193 B14 ) &lt;- in( B12 )  Freq: 0.954113
00c4 +  bleu  R30, R7, B193	#@cmpU_branch  P=0.000001 C=-1.000000

00c8    B14: #	out( B194 B15 ) &lt;- in( B13 )  Freq: 0.954112
00c8 +  li R28, #4	# int, #@loadConI
00cc +  bleu  R30, R28, B194	#@cmpU_branch  P=0.000001 C=-1.000000

00d0    B15: #	out( B195 B16 ) &lt;- in( B14 )  Freq: 0.954111
00d0 +  li R7, #4	# int, #@loadConI
00d4 +  bleu  R16, R7, B195	#@cmpU_branch  P=0.000001 C=-1.000000

00d8    B16: #	out( B17 ) &lt;- in( B15 )  Freq: 0.95411
00d8 +  li R31, #1	# int, #@loadConI

00dc    B17: #	out( B18 ) &lt;- in( B16 B23 ) Loop( B17-B23 ) Freq: 20.7787
00dc +  li R29, #0	# int, #@loadConI
00e0 +  subw  R7, R15, R31	#@subI_reg_reg
00e4    CMove R7, (R15 lt R31), R7, R29	#@cmovI_cmpI
	
00ec +  li R10, #4000	# int, #@loadConI
00f4 +  li R28, #4000	# int, #@loadConI
00fc    CMove R7, (R7 gtu R28), R7, R10	#@cmovI_cmpU
	
0104 +  addw  R7, R7, R31	#@addI_reg_reg
        nop 	# 4 bytes pad for loops and calls

0110    B18: #	out( B157 B19 ) &lt;- in( B17 B22 ) Loop( B18-B22 inner main of N315 strip mined) Freq: 452.892
0110 +  addw  R11, R31, zr	#@convI2L_reg_reg
0114 +  add R13, R9, R11	# ptr, #@addP_reg_reg
0118 +  add R11, R17, R11	# ptr, #@addP_reg_reg
011c +  lbu  R29, [R13, #16]	# byte, #@loadUB
0120 +  lbu  R10, [R13, #19]	# byte, #@loadUB
0124 +  lbu  R28, [R13, #18]	# byte, #@loadUB
0128 +  lbu  R19, [R13, #17]	# byte, #@loadUB
012c +  lbu  R18, [R11, #16]	# byte, #@loadUB
0130 +  lbu  R13, [R11, #19]	# byte, #@loadUB
0134 +  lbu  R21, [R11, #18]	# byte, #@loadUB
0138 +  lbu  R11, [R11, #17]	# byte, #@loadUB
013c +  bne  R29, R18, B157	#@cmpI_branch  P=0.000000 C=21296.000000

0140    B19: #	out( B160 B20 ) &lt;- in( B18 )  Freq: 452.892
0140 +  bne  R19, R11, B160	#@cmpI_branch  P=0.000000 C=21296.000000

0144    B20: #	out( B158 B21 ) &lt;- in( B19 )  Freq: 452.892
0144 +  bne  R28, R21, B158	#@cmpI_branch  P=0.000000 C=21296.000000

0148    B21: #	out( B161 B22 ) &lt;- in( B20 )  Freq: 452.892
0148 +  bne  R10, R13, B161	#@cmpI_branch  P=0.000000 C=21296.000000

014c    B22: #	out( B18 B23 ) &lt;- in( B21 )  Freq: 452.891
014c +  addiw  R31, R31, #4	#@addI_reg_imm
0150 +  blt  R31, R7, B18	#@cmpI_loop  P=0.954122 C=21296.000000

0154    B23: #	out( B17 B24 ) &lt;- in( B22 )  Freq: 20.7778
0154 +  ld  R11, [R23, #920]	# ptr, #@loadP
0158 +  lwu zr, [R11]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.UnixPath::compareTo @ bci:85 (line 728) L[0]=_ L[1]=_ L[2]=R30 L[3]=R16 L[4]=R8 L[5]=R9 L[6]=R17 L[7]=R31 L[8]=_ L[9]=_
        # sun.nio.fs.UnixPath::equals @ bci:14 (line 735) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.UnixPath::relativize @ bci:7 (line 393) L[0]=R14 L[1]=R12 L[2]=R12 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {c_rarg2=Oop c_rarg4=Oop c_rarg7=Oop x9=Oop off=344/0x158}
015c +  blt  R31, R15, B17	#@cmpI_branch  P=0.954122 C=21296.000000

0160    B24: #	out( B31 B25 ) &lt;- in( B191 B23 )  Freq: 0.953247
0160 +  bge  R31, R8, B31	#@cmpI_branch  P=0.500000 C=-1.000000

0164    B25: #	out( B203 B26 ) &lt;- in( B24 )  Freq: 0.476624
0164 +  # castII of R31, #@castII
0164    bgeu  R31, R30, B203	#@cmpU_branch  P=0.000001 C=-1.000000

0168    B26: #	out( B204 B27 ) &lt;- in( B25 )  Freq: 0.476623
0168 +  spill R31 -&gt; R28	# spill size = 32
016c +  # castII of R28, #@castII
016c    bgeu  R28, R30, B204	#@cmpU_branch  P=0.000001 C=-1.000000

0170    B27: #	out( B205 B28 ) &lt;- in( B26 )  Freq: 0.476623
0170 +  bgeu  R31, R16, B205	#@cmpU_branch  P=0.000001 C=-1.000000

0174    B28: #	out( B206 B29 ) &lt;- in( B27 )  Freq: 0.476622
0174 +  bgeu  R28, R16, B206	#@cmpU_branch  P=0.000001 C=-1.000000

0178    B29: #	out( B162 B30 ) &lt;- in( B28 B30 ) Loop( B29-B30 inner post of N2754) Freq: 0.953243
0178 +  addw  R7, R31, zr	#@convI2L_reg_reg
017c +  add R28, R9, R7	# ptr, #@addP_reg_reg
0180 +  lbu  R10, [R28, #16]	# byte, #@loadUB
0184 +  add R7, R17, R7	# ptr, #@addP_reg_reg
0188 +  lbu  R13, [R7, #16]	# byte, #@loadUB
018c +  bne  R10, R13, B162	#@cmpI_branch  P=0.000000 C=21296.000000

0190    B30: #	out( B29 B31 ) &lt;- in( B29 )  Freq: 0.953243
0190 +  addiw  R31, R31, #1	#@addI_reg_imm
0194 +  blt  R31, R8, B29	#@cmpI_loop  P=0.500000 C=21296.000000

0198    B31: #	out( B186 B32 ) &lt;- in( B24 B5 B30 )  Freq: 0.999123
0198 +  beq  R30, R16, B186	#@cmpI_branch  P=0.000001 C=20718.000000

019c    B32: #	out( B196 B33 ) &lt;- in( B31 )  Freq: 0.999122
019c +  bleu  R16, zr, B196	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=4608.000000

01a0    B33: #	out( B197 B34 ) &lt;- in( B32 )  Freq: 0.999122
01a0 +  lb  R8, [R17, #16]	# byte, #@loadB
01a4 +  li R7, #47	# int, #@loadConI
01a8 +  bne  R8, R7, B197	#@cmpI_branch  P=0.000000 C=4608.000000

01ac    B34: #	out( B198 B35 ) &lt;- in( B33 )  Freq: 0.999121
01ac +  bleu  R30, zr, B198	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=4608.000000

01b0    B35: #	out( B199 B36 ) &lt;- in( B34 )  Freq: 0.999121
01b0 +  lb  R8, [R9, #16]	# byte, #@loadB
01b4 +  bne  R8, R7, B199	#@cmpI_branch  P=0.000000 C=4608.000000

01b8    B36: #	out( B248 B37 ) &lt;- in( B35 )  Freq: 0.99912
01b8 +  spill R12 -&gt; [sp, #0]	# spill size = 64
01bc +  spill R14 -&gt; R8	# spill size = 64
01c0 +  spill R14 -&gt; R11	# spill size = 64
01c4    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::hasDotOrDotDot
        # sun.nio.fs.UnixPath::relativize @ bci:51 (line 405) L[0]=R8 L[1]=sp + #0 L[2]=sp + #0 L[3]=R8 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [0]=Oop off=456/0x1c8}

01c8    B37: #	out( B200 B38 ) &lt;- in( B36 )  Freq: 0.9991
        # Block is sole successor of call
01c8 +  bne  R10, zr, B200	#@cmpI_reg_imm0_branch  P=0.000000 C=2047.000000

01cc    B38: #	out( B247 B39 ) &lt;- in( B37 )  Freq: 0.9991
01cc +  spill [sp, #0] -&gt; R11	# spill size = 64
01d0    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::hasDotOrDotDot
        # sun.nio.fs.UnixPath::relativize @ bci:58 (line 405) L[0]=R8 L[1]=sp + #0 L[2]=sp + #0 L[3]=R8 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [0]=Oop off=468/0x1d4}

01d4    B39: #	out( B207 B40 ) &lt;- in( B38 )  Freq: 0.99908
        # Block is sole successor of call
01d4 +  bne  R10, zr, B207	#@cmpI_reg_imm0_branch  P=0.000000 C=2047.000000

01d8    B40: #	out( B246 B41 ) &lt;- in( B39 )  Freq: 0.999079
01d8 +  spill R8 -&gt; R11	# spill size = 64
01dc    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getNameCount @ bci:1 (line 295) L[0]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:75 (line 410) L[0]=R8 L[1]=sp + #0 L[2]=sp + #0 L[3]=R8 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [0]=Oop off=480/0x1e0}

01e0    B41: #	out( B228 B42 ) &lt;- in( B40 )  Freq: 0.999059
        # Block is sole successor of call
01e0 +  spill R8 -&gt; R29	# spill size = 64
01e4 +  lwu  R28, [R29, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
01e8 +  #@membar_acquire
	fence ir iorw
01ec +  decode_heap_oop  R7, R28	#@decodeHeapOop
01f0    lwu  R8, [R7, #12]	# range, #@loadRange
01f4    NullCheck R7

01f4    B42: #	out( B245 B43 ) &lt;- in( B41 )  Freq: 0.999058
01f4 +  spill R29 -&gt; [sp, #24]	# spill size = 64
01f8 +  spill [sp, #0] -&gt; R11	# spill size = 64
01fc    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getNameCount @ bci:1 (line 295) L[0]=sp + #0
        # sun.nio.fs.UnixPath::relativize @ bci:81 (line 411) L[0]=sp + #24 L[1]=sp + #0 L[2]=sp + #0 L[3]=sp + #24 L[4]=R8 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[0]=Oop [24]=Oop off=512/0x200}

0200    B43: #	out( B229 B44 ) &lt;- in( B42 )  Freq: 0.999038
        # Block is sole successor of call
0200 +  spill [sp, #0] -&gt; R22	# spill size = 64
0204 +  lwu  R7, [R22, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0208 +  #@membar_acquire
	fence ir iorw
020c +  decode_heap_oop  R7, R7	#@decodeHeapOop
0210    lwu  R28, [R7, #12]	# range, #@loadRange
0214    NullCheck R7

0214    B44: #	out( B144 B45 ) &lt;- in( B43 )  Freq: 0.999037
0214 +  spill R28 -&gt; R29	# spill size = 32
0218 +  CMove R29, (R8 lt R28), R29, R8	#@cmovI_cmpI
	
0220 +  spill R8 -&gt; R7	# spill size = 32
0224 +  ble  R29, zr, B144	#@cmpI_reg_imm0_branch  P=0.111111 C=18423.000000

0228    B45: #	out( B49 ) &lt;- in( B44 )  Freq: 0.888033
0228 +  li R19, #0	# int, #@loadConI
022c +  j  B49	#@branch

0230    B46: #	out( B172 B47 ) &lt;- in( B106 B87 B111 ) top-of-loop Freq: 7.92709
0230 +  bne  R21, R20, B172	#@cmpI_branch  P=0.000001 C=20718.000000

0234    B47: #	out( B112 B48 ) &lt;- in( B46 )  Freq: 7.92708
0234 +  spill [sp, #40] -&gt; R29	# spill size = 32
0238 +  bge  R19, R29, B112	#@cmpI_loop  P=0.111111 C=16376.000000

023c    B48: #	out( B49 ) &lt;- in( B47 )  Freq: 7.04629
023c +  spill [sp, #32] -&gt; R7	# spill size = 32
0240 +  spill [sp, #36] -&gt; R28	# spill size = 32

0244    B49: #	out( B249 B50 ) &lt;- in( B45 B48 ) Loop( B49-B48 ) Freq: 7.93449
0244 +  spill R19 -&gt; [sp, #0]	# spill size = 32
0248 +  spill R29 -&gt; [sp, #40]	# spill size = 32
024c +  spill R28 -&gt; [sp, #36]	# spill size = 32
0250 +  spill R7 -&gt; [sp, #32]	# spill size = 32
0254 +  spill R22 -&gt; [sp, #8]	# spill size = 64
0258 +  spill [sp, #24] -&gt; R11	# spill size = 64
025c    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getName @ bci:1 (line 301) L[0]=sp + #24 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=sp + #24 L[1]=sp + #8 L[2]=sp + #8 L[3]=sp + #24 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=sp + #0 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[8]=Oop [24]=Oop off=608/0x260}

0260    B50: #	out( B216 B51 ) &lt;- in( B49 )  Freq: 7.93433
        # Block is sole successor of call
0260 +  spill [sp, #24] -&gt; R9	# spill size = 64
0264 +  lwu  R28, [R9, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0268 +  #@membar_acquire
	fence ir iorw
026c +  decode_heap_oop  R7, R28	#@decodeHeapOop
0270    lwu  R8, [R7, #12]	# range, #@loadRange
0274    NullCheck R7

0274    B51: #	out( B183 B52 ) &lt;- in( B50 )  Freq: 7.93432
0274 +  spill [sp, #0] -&gt; R30	# spill size = 32
0278 +  bge  R30, R8, B183	#@cmpI_branch  P=0.000000 C=5376.000000

027c    B52: #	out( B217 B53 ) &lt;- in( B51 )  Freq: 7.93431
027c +  lwu  R7, [R9, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0280 +  #@membar_acquire
	fence ir iorw
0284 +  decode_heap_oop  R8, R7	#@decodeHeapOop
0288    lwu  R28, [R8, #12]	# range, #@loadRange
028c    NullCheck R8

028c    B53: #	out( B167 B54 ) &lt;- in( B52 )  Freq: 7.93431
028c +  bgeu  R30, R28, B167	#@cmpU_branch  P=0.000001 C=-1.000000

0290    B54: #	out( B218 B55 ) &lt;- in( B53 )  Freq: 7.9343
0290 +  addw  R28, R30, zr	#@convI2L_reg_reg
0294 +  slli  R11, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0298 +  lwu  R7, [R9, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
029c +  add R28, R8, R11	# ptr, #@addP_reg_reg
02a0 +  lw  R29, [R28, #16]	# int, #@loadI
02a4 +  decode_heap_oop  R7, R7	#@decodeHeapOop
02a8 +  #@membar_acquire
	fence ir iorw
02ac    lwu  R7, [R7, #12]	# range, #@loadRange
02b0    NullCheck R7

02b0    B55: #	out( B140 B56 ) &lt;- in( B54 )  Freq: 7.93429
02b0 +  addiw  R28, R7, #-1	#@addI_reg_imm
02b4 +  addiw  R10, R30, #1	#@addI_reg_imm
02b8 +  beq  R30, R28, B140	#@cmpI_branch  P=0.084635 C=5376.000000

02bc    B56: #	out( B224 B57 ) &lt;- in( B55 )  Freq: 7.26277
02bc +  lwu  R7, [R9, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
02c0 +  #@membar_acquire
	fence ir iorw
02c4 +  decode_heap_oop  R8, R7	#@decodeHeapOop
02c8    lwu  R28, [R8, #12]	# range, #@loadRange
02cc    NullCheck R8

02cc    B57: #	out( B179 B58 ) &lt;- in( B56 )  Freq: 7.26276
02cc +  bgeu  R10, R28, B179	#@cmpU_branch  P=0.000001 C=-1.000000

02d0    B58: #	out( B59 ) &lt;- in( B57 )  Freq: 7.26275
02d0 +  add R7, R8, R11	# ptr, #@addP_reg_reg
02d4 +  lw  R28, [R7, #20]	# int, #@loadI
02d8 +  subw  R7, R28, R29	#@subI_reg_reg
02dc +  addiw  R7, R7, #-1	#@addI_reg_imm

02e0    B59: #	out( B60 B60 ) &lt;- in( B58 B141 )  Freq: 7.93428
02e0 +  lwu  R31, [R9, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
02e4 +  li R13, #1048576	# int, #@loadConI
02e8 +  decode_heap_oop  R12, R31	#@decodeHeapOop
02ec +  addw  R28, R7, zr	#@convI2L_reg_reg
02f0 +  bleu  R7, R13, B60	#@cmpU_branch  P=0.999999 C=-1.000000

02f4    B60: #	out( B219 B61 ) &lt;- in( B59 B59 )  Freq: 7.93428
02f4    lwu  R31, [R12, #12]	# range, #@loadRange
02f8    NullCheck R12

02f8    B61: #	out( B170 B62 ) &lt;- in( B60 )  Freq: 7.93427
02f8 +  addw  R13, R7, R29	#@addI_reg_reg
02fc +  blt  R29, zr, B170	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0300    B62: #	out( B170 B63 ) &lt;- in( B61 )  Freq: 7.93426
0300 +  bltu  R31, R13, B170	#@cmpU_branch  P=0.000001 C=-1.000000

0304    B63: #	out( B153 B64 ) &lt;- in( B62 )  Freq: 7.93425
0304 +  li R31, #1048576	# int, #@loadConI
0308 +  bgtu  R7, R31, B153	#@cmpU_branch  P=0.000001 C=-1.000000

030c    B64: #	out( B153 B65 ) &lt;- in( B63 )  Freq: 7.93424
030c +  addi  R28, R28, #23	#@addL_reg_imm
0310 +  ld  R13, [R23, #288]	# ptr, #@loadP
0314 +  andi  R28, R28, #-8	#@andL_reg_imm
0318 +  ld  R31, [R23, #304]	# ptr, #@loadP
031c +  add R28, R13, R28	# ptr, #@addP_reg_reg
0320 +  bgeu  R28, R31, B153	#@cmpP_branch  P=0.000100 C=-1.000000

0324    B65: #	out( B66 ) &lt;- in( B64 )  Freq: 7.93345
0324 +  sd  R28, [R23, #288]	# ptr, #@storeP
0328 +  li R28, #1	# long, #@loadConL
032c +  mv  R31, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
033c +  sd  R28, [R13]	# long, #@storeL
0340 +  sw  R31, [R13, #8]	# compressed klass ptr, #@storeNKlass
0344 +  sw  R7, [R13, #12]	# int, #@storeI

0348    B66: #	out( B168 B67 ) &lt;- in( B154 B65 )  Freq: 7.93425
0348    
0348 +  # checkcastPP of R13, #@checkCastPP
0348    addi  R28, R13, #16	# ptr, #@addP_reg_imm
034c +  # castII of R7, #@castII
034c    beq  R7, zr, B168	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0350    B67: #	out( B68 ) &lt;- in( B66 )  Freq: 7.93424
0350 +  spill R28 -&gt; [sp, #48]	# spill size = 64
0354 +  addw  R28, R29, zr	#@convI2L_reg_reg
0358 +  add R28, R12, R28	# ptr, #@addP_reg_reg
035c    spill R10 -&gt; [sp, #4]	# spill size = 32
0360 +  addi  R10, R28, #16	# ptr, #@addP_reg_imm
0364    spill R11 -&gt; [sp, #16]	# spill size = 64
0368 +  spill R13 -&gt; [sp, #64]	# spill size = 64
036c +  spill R30 -&gt; [sp, #0]	# spill size = 32
0370 +  spill R7 -&gt; [sp, #44]	# spill size = 32
0374 +  addw  R12, R7, zr	#@convI2L_reg_reg
0378    spill [sp, #48] -&gt; R11	# spill size = 64
037c +  CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

0380    B68: #	out( B251 B69 ) &lt;- in( B67 B168 )  Freq: 7.93425
0380    
0380    lwu  R28, [R9, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
0384 +  decode_heap_oop  R7, R28	#@decodeHeapOop
0388    spill R9 -&gt; [sp, #24]	# spill size = 64
038c +  spill R7 -&gt; [sp, #72]	# spill size = 64
0390 +  spill [sp, #8] -&gt; R11	# spill size = 64
0394    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getName @ bci:1 (line 301) L[0]=sp + #8 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=sp + #24 L[1]=sp + #8 L[2]=sp + #8 L[3]=sp + #24 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=sp + #0 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#ScObj0
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=sp + #72, [path :2]=sp + #64, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # OopMap {[8]=Oop [24]=Oop [48]=Derived_oop_[64] [64]=Oop [72]=Oop off=920/0x398}

0398    B69: #	out( B220 B70 ) &lt;- in( B68 )  Freq: 7.93409
        # Block is sole successor of call
0398 +  spill [sp, #8] -&gt; R22	# spill size = 64
039c +  lwu  R7, [R22, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
03a0 +  #@membar_acquire
	fence ir iorw
03a4 +  decode_heap_oop  R7, R7	#@decodeHeapOop
03a8    lwu  R8, [R7, #12]	# range, #@loadRange
03ac    NullCheck R7

03ac    B70: #	out( B184 B71 ) &lt;- in( B69 )  Freq: 7.93408
03ac +  spill [sp, #0] -&gt; R9	# spill size = 32
03b0 +  bge  R9, R8, B184	#@cmpI_branch  P=0.000000 C=5376.000000

03b4    B71: #	out( B221 B72 ) &lt;- in( B70 )  Freq: 7.93408
03b4 +  lwu  R28, [R22, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
03b8 +  #@membar_acquire
	fence ir iorw
03bc +  decode_heap_oop  R8, R28	#@decodeHeapOop
03c0    lwu  R7, [R8, #12]	# range, #@loadRange
03c4    NullCheck R8

03c4    B72: #	out( B169 B73 ) &lt;- in( B71 )  Freq: 7.93407
03c4 +  bgeu  R9, R7, B169	#@cmpU_branch  P=0.000001 C=-1.000000

03c8    B73: #	out( B222 B74 ) &lt;- in( B72 )  Freq: 7.93406
03c8 +  lwu  R28, [R22, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
03cc +  decode_heap_oop  R7, R28	#@decodeHeapOop
03d0    spill [sp, #16] -&gt; R30	# spill size = 64
03d4 +  add R28, R8, R30	# ptr, #@addP_reg_reg
03d8 +  lw  R29, [R28, #16]	# int, #@loadI
03dc +  #@membar_acquire
	fence ir iorw
03e0    lwu  R7, [R7, #12]	# range, #@loadRange
03e4    NullCheck R7

03e4    B74: #	out( B142 B75 ) &lt;- in( B73 )  Freq: 7.93406
03e4 +  addiw  R28, R7, #-1	#@addI_reg_imm
03e8 +  beq  R9, R28, B142	#@cmpI_branch  P=0.084635 C=5376.000000

03ec    B75: #	out( B225 B76 ) &lt;- in( B74 )  Freq: 7.26255
03ec +  lwu  R7, [R22, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
03f0 +  #@membar_acquire
	fence ir iorw
03f4 +  decode_heap_oop  R8, R7	#@decodeHeapOop
03f8    lwu  R28, [R8, #12]	# range, #@loadRange
03fc    NullCheck R8

03fc    B76: #	out( B180 B77 ) &lt;- in( B75 )  Freq: 7.26255
03fc +  spill [sp, #4] -&gt; R19	# spill size = 32
0400 +  bgeu  R19, R28, B180	#@cmpU_branch  P=0.000001 C=-1.000000

0404    B77: #	out( B78 ) &lt;- in( B76 )  Freq: 7.26254
0404 +  add R7, R8, R30	# ptr, #@addP_reg_reg
0408 +  lw  R7, [R7, #20]	# int, #@loadI
040c +  subw  R28, R7, R29	#@subI_reg_reg
0410 +  addiw  R20, R28, #-1	#@addI_reg_imm

0414    B78: #	out( B79 B79 ) &lt;- in( B77 B143 )  Freq: 7.93404
0414 +  lwu  R28, [R22, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
0418 +  li R30, #1048576	# int, #@loadConI
041c +  decode_heap_oop  R8, R28	#@decodeHeapOop
0420 +  addw  R7, R20, zr	#@convI2L_reg_reg
0424 +  bleu  R20, R30, B79	#@cmpU_branch  P=0.999999 C=-1.000000

0428    B79: #	out( B223 B80 ) &lt;- in( B78 B78 )  Freq: 7.93404
0428    lwu  R28, [R8, #12]	# range, #@loadRange
042c    NullCheck R8

042c    B80: #	out( B171 B81 ) &lt;- in( B79 )  Freq: 7.93403
042c +  addw  R31, R20, R29	#@addI_reg_reg
0430 +  blt  R29, zr, B171	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0434    B81: #	out( B171 B82 ) &lt;- in( B80 )  Freq: 7.93402
0434 +  bltu  R28, R31, B171	#@cmpU_branch  P=0.000001 C=-1.000000

0438    B82: #	out( B155 B83 ) &lt;- in( B81 )  Freq: 7.93402
0438 +  li R28, #1048576	# int, #@loadConI
043c +  bgtu  R20, R28, B155	#@cmpU_branch  P=0.000001 C=-1.000000

0440    B83: #	out( B155 B84 ) &lt;- in( B82 )  Freq: 7.93401
0440 +  addi  R7, R7, #23	#@addL_reg_imm
0444 +  ld  R24, [R23, #288]	# ptr, #@loadP
0448 +  andi  R7, R7, #-8	#@andL_reg_imm
044c +  ld  R28, [R23, #304]	# ptr, #@loadP
0450 +  add R7, R24, R7	# ptr, #@addP_reg_reg
0454 +  bgeu  R7, R28, B155	#@cmpP_branch  P=0.000100 C=-1.000000

0458    B84: #	out( B85 ) &lt;- in( B83 )  Freq: 7.93322
0458 +  sd  R7, [R23, #288]	# ptr, #@storeP
045c +  li R7, #1	# long, #@loadConL
0460 +  mv  R28, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0470 +  sd  R7, [R24]	# long, #@storeL
0474 +  sw  R28, [R24, #8]	# compressed klass ptr, #@storeNKlass
0478 +  sw  R20, [R24, #12]	# int, #@storeI

047c    B85: #	out( B87 B86 ) &lt;- in( B156 B84 )  Freq: 7.93402
047c    
047c +  # castII of R20, #@castII
047c    # checkcastPP of R24, #@checkCastPP
047c    spill [sp, #44] -&gt; R21	# spill size = 32
0480 +  spill R20 -&gt; R18	# spill size = 32
0484 +  addi  R25, R24, #16	# ptr, #@addP_reg_imm
0488 +  CMove R18, (R21 lt R20), R18, R21	#@cmovI_cmpI
	
0490    beq  R20, zr, B87	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0494    B86: #	out( B87 ) &lt;- in( B85 )  Freq: 7.93401
0494 +  addw  R7, R29, zr	#@convI2L_reg_reg
0498 +  add R7, R8, R7	# ptr, #@addP_reg_reg
049c +  addw  R12, R20, zr	#@convI2L_reg_reg
04a0    spill R25 -&gt; R11	# spill size = 64
04a4 +  addi  R10, R7, #16	# ptr, #@addP_reg_imm
04a8 +  CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

04ac    B87: #	out( B46 B88 ) &lt;- in( B86 B85 )  Freq: 7.93402
04ac    
04ac    ble  R18, zr, B46	#@cmpI_reg_imm0_branch  P=0.045878 C=22320.000000

04b0    B88: #	out( B173 B89 ) &lt;- in( B87 )  Freq: 7.57002
04b0 +  addiw  R30, R18, #-1	#@addI_reg_imm
04b4 +  beq  R21, zr, B173	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

04b8    B89: #	out( B173 B90 ) &lt;- in( B88 )  Freq: 7.57001
04b8 +  bgeu  R30, R21, B173	#@cmpU_branch  P=0.000001 C=-1.000000

04bc    B90: #	out( B173 B91 ) &lt;- in( B89 )  Freq: 7.57
04bc +  spill [sp, #48] -&gt; R7	# spill size = 64
04c0 +  lbu  R29, [R7]	# byte, #@loadUB
04c4 +  beq  R20, zr, B173	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

04c8    B91: #	out( B173 B92 ) &lt;- in( B90 )  Freq: 7.57
04c8 +  bgeu  R30, R20, B173	#@cmpU_branch  P=0.000001 C=-1.000000

04cc    B92: #	out( B185 B93 ) &lt;- in( B91 )  Freq: 7.56999
04cc +  lbu  R31, [R25]	# byte, #@loadUB
04d0 +  bne  R29, R31, B185	#@cmpI_branch  P=0.000000 C=21296.000000

04d4    B93: #	out( B174 B94 ) &lt;- in( B92 )  Freq: 7.56998
04d4 +  li R29, #-2147483648	# int, #@loadConI
04d8 +  addiw  R7, R18, #-3	#@addI_reg_imm
04dc    CMove R7, (R30 lt R7), R7, R29	#@cmovI_cmpI
	
04e4 +  li R28, #1	# int, #@loadConI
04e8 +  ble  R7, R28, B174	#@cmpI_branch  P=0.000001 C=-1.000000

04ec    B94: #	out( B175 B95 ) &lt;- in( B93 )  Freq: 7.56998
04ec +  li R29, #1	# int, #@loadConI
04f0 +  bleu  R20, R29, B175	#@cmpU_branch  P=0.000001 C=-1.000000

04f4    B95: #	out( B176 B96 ) &lt;- in( B94 )  Freq: 7.56997
04f4 +  bleu  R21, R28, B176	#@cmpU_branch  P=0.000001 C=-1.000000

04f8    B96: #	out( B177 B97 ) &lt;- in( B95 )  Freq: 7.56996
04f8 +  li R29, #4	# int, #@loadConI
04fc +  bleu  R21, R29, B177	#@cmpU_branch  P=0.000001 C=-1.000000

0500    B97: #	out( B178 B98 ) &lt;- in( B96 )  Freq: 7.56995
0500 +  li R28, #4	# int, #@loadConI
0504 +  bleu  R20, R28, B178	#@cmpU_branch  P=0.000001 C=-1.000000

0508    B98: #	out( B99 ) &lt;- in( B97 )  Freq: 7.56995
0508 +  li R30, #1	# int, #@loadConI

050c    B99: #	out( B100 ) &lt;- in( B98 B105 ) Loop( B99-B105 ) Freq: 164.859
050c +  li R31, #0	# int, #@loadConI
0510 +  subw  R28, R7, R30	#@subI_reg_reg
0514    CMove R28, (R7 lt R30), R28, R31	#@cmovI_cmpI
	
051c +  li R10, #4000	# int, #@loadConI
0524 +  li R29, #4000	# int, #@loadConI
052c    CMove R28, (R28 gtu R29), R28, R10	#@cmovI_cmpU
	
0534 +  addw  R28, R28, R30	#@addI_reg_reg
        nop 	# 4 bytes pad for loops and calls

0540    B100: #	out( B145 B101 ) &lt;- in( B99 B104 ) Loop( B100-B104 inner main of N417 strip mined) Freq: 3593.26
0540 +  addw  R31, R30, zr	#@convI2L_reg_reg
0544    spill [sp, #64] -&gt; R29	# spill size = 64
0548 +  add R10, R29, R31	# ptr, #@addP_reg_reg
054c +  lbu  R11, [R10, #16]	# byte, #@loadUB
0550 +  lbu  R29, [R10, #19]	# byte, #@loadUB
0554 +  lbu  R14, [R10, #18]	# byte, #@loadUB
0558 +  lbu  R16, [R10, #17]	# byte, #@loadUB
055c +  add R10, R24, R31	# ptr, #@addP_reg_reg
0560 +  lbu  R12, [R10, #16]	# byte, #@loadUB
0564 +  lbu  R31, [R10, #19]	# byte, #@loadUB
0568 +  lbu  R13, [R10, #18]	# byte, #@loadUB
056c +  lbu  R10, [R10, #17]	# byte, #@loadUB
0570 +  bne  R11, R12, B145	#@cmpI_branch  P=0.000000 C=21296.000000

0574    B101: #	out( B148 B102 ) &lt;- in( B100 )  Freq: 3593.26
0574 +  bne  R16, R10, B148	#@cmpI_branch  P=0.000000 C=21296.000000

0578    B102: #	out( B146 B103 ) &lt;- in( B101 )  Freq: 3593.26
0578 +  bne  R14, R13, B146	#@cmpI_branch  P=0.000000 C=21296.000000

057c    B103: #	out( B149 B104 ) &lt;- in( B102 )  Freq: 3593.26
057c +  bne  R29, R31, B149	#@cmpI_branch  P=0.000000 C=21296.000000

0580    B104: #	out( B100 B105 ) &lt;- in( B103 )  Freq: 3593.26
0580 +  addiw  R30, R30, #4	#@addI_reg_imm
0584 +  blt  R30, R28, B100	#@cmpI_loop  P=0.954122 C=21296.000000

0588    B105: #	out( B99 B106 ) &lt;- in( B104 )  Freq: 164.852
0588 +  ld  R28, [R23, #920]	# ptr, #@loadP
058c +  lwu zr, [R28]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.UnixPath::compareTo @ bci:85 (line 728) L[0]=_ L[1]=_ L[2]=R21 L[3]=R20 L[4]=R18 L[5]=sp + #64 L[6]=R24 L[7]=R30 L[8]=_ L[9]=_
        # sun.nio.fs.UnixPath::equals @ bci:14 (line 735) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.UnixPath::relativize @ bci:117 (line 417) L[0]=sp + #24 L[1]=R22 L[2]=R22 L[3]=sp + #24 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=R9 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {xbcp=Oop xlocals=Oop [24]=Oop [64]=Oop off=1420/0x58c}
0590 +  blt  R30, R7, B99	#@cmpI_branch  P=0.954122 C=21296.000000

0594    B106: #	out( B46 B107 ) &lt;- in( B174 B105 )  Freq: 7.5631
0594 +  bge  R30, R18, B46	#@cmpI_branch  P=0.500000 C=-1.000000

0598    B107: #	out( B181 B108 ) &lt;- in( B106 )  Freq: 3.78155
0598 +  # castII of R30, #@castII
0598    bgeu  R30, R21, B181	#@cmpU_branch  P=0.000001 C=-1.000000

059c    B108: #	out( B182 B109 ) &lt;- in( B107 )  Freq: 3.78155
059c +  bgeu  R30, R20, B182	#@cmpU_branch  P=0.000001 C=-1.000000

05a0    B109: #	out( B152 B110 ) &lt;- in( B108 B110 ) Loop( B109-B110 inner post of N2770) Freq: 7.56308
05a0 +  addw  R28, R30, zr	#@convI2L_reg_reg
05a4    spill [sp, #64] -&gt; R7	# spill size = 64
05a8 +  add R29, R7, R28	# ptr, #@addP_reg_reg
05ac +  lbu  R29, [R29, #16]	# byte, #@loadUB
05b0 +  add R28, R24, R28	# ptr, #@addP_reg_reg
05b4 +  lbu  R31, [R28, #16]	# byte, #@loadUB
05b8 +  bne  R29, R31, B152	#@cmpI_branch  P=0.000000 C=21296.000000

05bc    B110: #	out( B109 B111 ) &lt;- in( B109 )  Freq: 7.56308
05bc +  addiw  R30, R30, #1	#@addI_reg_imm
05c0 +  blt  R30, R18, B109	#@cmpI_loop  P=0.500000 C=21296.000000

05c4    B111: #	out( B46 ) &lt;- in( B110 )  Freq: 3.78154
05c4 +  j  B46	#@branch

05c8    B112: #	out( B113 ) &lt;- in( B47 )  Freq: 0.880786
05c8 +  spill [sp, #32] -&gt; R7	# spill size = 32
05cc +  spill [sp, #36] -&gt; R28	# spill size = 32

05d0    B113: #	out( B208 B114 ) &lt;- in( B144 B112 )  Freq: 0.991791
05d0 +  beq  R19, R28, B208	#@cmpI_branch  P=0.000000 C=2047.000000

05d4    B114: #	out( B243 B115 ) &lt;- in( B113 )  Freq: 0.99179
05d4 +  spill R19 -&gt; [sp, #48]	# spill size = 32
05d8 +  spill R28 -&gt; [sp, #44]	# spill size = 32
05dc +  spill R7 -&gt; [sp, #40]	# spill size = 32
05e0 +  spill R22 -&gt; [sp, #32]	# spill size = 64
05e4 +  spill R22 -&gt; R11	# spill size = 64
05e8    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::subpath @ bci:1 (line 323) L[0]=sp + #32 L[1]=sp + #48 L[2]=sp + #44 L[3]=_ L[4]=_ L[5]=_
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=sp + #24 L[1]=sp + #32 L[2]=_ L[3]=sp + #24 L[4]=sp + #40 L[5]=_ L[6]=_ L[7]=sp + #48 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[24]=Oop [32]=Oop off=1516/0x5ec}

05ec    B115: #	out( B209 B116 ) &lt;- in( B114 )  Freq: 0.99177
        # Block is sole successor of call
05ec +  spill [sp, #48] -&gt; R28	# spill size = 32
05f0 +  blt  R28, zr, B209	#@cmpI_reg_imm0_branch  P=0.000000 C=2302.000000

05f4    B116: #	out( B230 B117 ) &lt;- in( B115 )  Freq: 0.99177
05f4 +  spill [sp, #32] -&gt; R7	# spill size = 64
05f8 +  lwu  R28, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
05fc +  #@membar_acquire
	fence ir iorw
0600 +  decode_heap_oop  R7, R28	#@decodeHeapOop
0604    lwu  R8, [R7, #12]	# range, #@loadRange
0608    NullCheck R7

0608    B117: #	out( B210 B118 ) &lt;- in( B116 )  Freq: 0.991769
0608 +  spill [sp, #48] -&gt; R7	# spill size = 32
060c +  bge  R7, R8, B210	#@cmpI_branch  P=0.000000 C=2302.000000

0610    B118: #	out( B231 B119 ) &lt;- in( B117 )  Freq: 0.991768
0610 +  spill [sp, #32] -&gt; R7	# spill size = 64
0614 +  lwu  R7, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0618 +  #@membar_acquire
	fence ir iorw
061c +  decode_heap_oop  R7, R7	#@decodeHeapOop
0620    lwu  R8, [R7, #12]	# range, #@loadRange
0624    NullCheck R7

0624    B119: #	out( B211 B120 ) &lt;- in( B118 )  Freq: 0.991767
0624 +  spill [sp, #44] -&gt; R31	# spill size = 32
0628 +  bgt  R31, R8, B211	#@cmpI_branch  P=0.000000 C=2302.000000

062c    B120: #	out( B212 B121 ) &lt;- in( B119 )  Freq: 0.991767
062c +  spill [sp, #48] -&gt; R28	# spill size = 32
0630 +  bge  R28, R31, B212	#@cmpI_branch  P=0.000000 C=2302.000000

0634    B121: #	out( B232 B122 ) &lt;- in( B120 )  Freq: 0.991766
0634 +  spill [sp, #32] -&gt; R7	# spill size = 64
0638 +  lwu  R28, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
063c +  #@membar_acquire
	fence ir iorw
0640 +  decode_heap_oop  R8, R28	#@decodeHeapOop
0644    lwu  R7, [R8, #12]	# range, #@loadRange
0648    NullCheck R8

0648    B122: #	out( B187 B123 ) &lt;- in( B121 )  Freq: 0.991765
0648 +  spill [sp, #48] -&gt; R28	# spill size = 32
064c +  bgeu  R28, R7, B187	#@cmpU_branch  P=0.000001 C=-1.000000

0650    B123: #	out( B233 B124 ) &lt;- in( B122 )  Freq: 0.991764
0650 +  spill [sp, #32] -&gt; R7	# spill size = 64
0654 +  lwu  R28, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0658    spill [sp, #48] -&gt; R29	# spill size = 32
065c +  addw  R7, R29, zr	#@convI2L_reg_reg
0660 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0664 +  add R7, R8, R7	# ptr, #@addP_reg_reg
0668 +  lw  R7, [R7, #16]	# int, #@loadI
066c +  #@membar_acquire
	fence ir iorw
0670 +  decode_heap_oop  R28, R28	#@decodeHeapOop
0674    spill [sp, #32] -&gt; R29	# spill size = 64
0678 +  lwu  R29, [R29, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
067c    lwu  R8, [R28, #12]	# range, #@loadRange
0680    NullCheck R28

0680    B124: #	out( B201 B125 ) &lt;- in( B123 )  Freq: 0.991763
0680 +  decode_heap_oop  R11, R29	#@decodeHeapOop
0684 +  bne  R31, R8, B201	#@cmpI_branch  P=0.000000 C=2302.000000

0688    B125: #	out( B234 B126 ) &lt;- in( B124 )  Freq: 0.991763
0688    lwu  R10, [R11, #12]	# range, #@loadRange
068c    NullCheck R11

068c    B126: #	out( B188 B127 ) &lt;- in( B125 )  Freq: 0.991762
068c +  subw  R29, R10, R7	#@subI_reg_reg
0690 +  li R28, #1048576	# int, #@loadConI
0694 +  addw  R13, R7, zr	#@convI2L_reg_reg
0698 +  addw  R12, R29, zr	#@convI2L_reg_reg
069c +  bgtu  R29, R28, B188	#@cmpU_branch  P=0.000001 C=-1.000000

06a0    B127: #	out( B128 ) &lt;- in( B126 )  Freq: 0.991761
06a0 +  addw  R28, R10, zr	#@convI2L_reg_reg
06a4 +  sub  R28, R28, R13	#@subL_reg_reg

06a8    B128: #	out( B189 B129 ) &lt;- in( B127 B188 )  Freq: 0.991762
06a8 +  blt  R7, zr, B189	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

06ac    B129: #	out( B165 B130 ) &lt;- in( B128 )  Freq: 0.991761
06ac +  li R31, #1048576	# int, #@loadConI
06b0 +  bgtu  R29, R31, B165	#@cmpU_branch  P=0.000001 C=-1.000000

06b4    B130: #	out( B165 B131 ) &lt;- in( B129 )  Freq: 0.99176
06b4 +  addi  R28, R28, #23	#@addL_reg_imm
06b8 +  ld  R8, [R23, #288]	# ptr, #@loadP
06bc +  andi  R28, R28, #-8	#@andL_reg_imm
06c0 +  ld  R30, [R23, #304]	# ptr, #@loadP
06c4 +  add R28, R8, R28	# ptr, #@addP_reg_reg
06c8 +  bgeu  R28, R30, B165	#@cmpP_branch  P=0.000100 C=-1.000000

06cc    B131: #	out( B132 ) &lt;- in( B130 )  Freq: 0.991661
06cc +  sd  R28, [R23, #288]	# ptr, #@storeP
06d0 +  li R28, #1	# long, #@loadConL
06d4 +  mv  R30, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
06e4 +  sd  R28, [R8]	# long, #@storeL
06e8 +  sw  R30, [R8, #8]	# compressed klass ptr, #@storeNKlass
06ec +  sw  R29, [R8, #12]	# int, #@storeI

06f0    B132: #	out( B134 B133 ) &lt;- in( B166 B131 )  Freq: 0.991761
06f0    
06f0 +  # checkcastPP of R8, #@checkCastPP
06f0    beq  R10, R7, B134	#@cmpI_branch  P=0.000001 C=-1.000000

06f4    B133: #	out( B134 ) &lt;- in( B132 )  Freq: 0.99176
06f4 +  add R7, R11, R13	# ptr, #@addP_reg_reg
06f8 +  addi  R10, R7, #16	# ptr, #@addP_reg_imm
06fc +  addi  R11, R8, #16	# ptr, #@addP_reg_imm
0700 +  CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

0704    B134: #	out( B163 B135 ) &lt;- in( B133 B132 )  Freq: 0.991761
0704    MEMBAR-store-store	#@membar_storestore
0708 +  ld  R10, [R23, #288]	# ptr, #@loadP
070c +  ld  R7, [R23, #304]	# ptr, #@loadP
0710 +  addi  R28, R10, #32	# ptr, #@addP_reg_imm
0714 +  bgeu  R28, R7, B163	#@cmpP_branch  P=0.000100 C=-1.000000

0718    B135: #	out( B136 ) &lt;- in( B134 )  Freq: 0.991662
0718 +  sd  R28, [R23, #288]	# ptr, #@storeP
071c +  li R7, #1	# long, #@loadConL
0720 +  mv  R28, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d060f9c0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0730 +  sd  R7, [R10]	# long, #@storeL
0734 +  sw  R28, [R10, #8]	# compressed klass ptr, #@storeNKlass
0738 +  sw  zr, [R10, #12]	# int, #@storeimmI0
073c +  sw  zr, [R10, #16]	# int, #@storeimmI0
0740 +  sd  zr, [R10, #24]	# long, #@storeimmL0

0744    B136: #	out( B235 B137 ) &lt;- in( B164 B135 )  Freq: 0.991761
0744 +  encode_heap_oop  R7, R8	#@encodeHeapOop
0748 +  sw  R7, [R10, #20]	# compressed ptr, #@storeN
074c    
074c    spill [sp, #32] -&gt; R7	# spill size = 64
0750 +  lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
0754 +  # checkcastPP of R10, #@checkCastPP
0754    sw  R28, [R10, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixPath.fs
0758 +  #@membar_release
	fence iorw ow
075c +  lwu  R7, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
0760 +  decode_heap_oop  R7, R7	#@decodeHeapOop
0764    lwu  R8, [R7, #12]	# range, #@loadRange
0768    NullCheck R7

0768    B137: #	out( B213 B138 ) &lt;- in( B136 )  Freq: 0.99176
0768 +  bleu  R8, zr, B213	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=9503.000000

076c    B138: #	out( B202 B139 ) &lt;- in( B137 )  Freq: 0.991759
076c +  spill [sp, #40] -&gt; R7	# spill size = 32
0770 +  spill [sp, #48] -&gt; R28	# spill size = 32
0774 +  bne  R28, R7, B202	#@cmpI_branch  P=0.000000 C=2047.000000

0778    B139: #	out( N2499 ) &lt;- in( B138 )  Freq: 0.991759
0778    # pop frame 128
	add  sp, sp, #128
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0790 +  ret	// return register, #@Ret

0794    B140: #	out( B236 B141 ) &lt;- in( B55 )  Freq: 0.671522
0794 +  lwu  R28, [R9, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
0798 +  decode_heap_oop  R7, R28	#@decodeHeapOop
079c    lwu  R7, [R7, #12]	# range, #@loadRange
07a0    NullCheck R7

07a0    B141: #	out( B59 ) &lt;- in( B140 )  Freq: 0.671521
07a0 +  subw  R7, R7, R29	#@subI_reg_reg
07a4 +  j  B59	#@branch

07a8    B142: #	out( B237 B143 ) &lt;- in( B74 )  Freq: 0.671502
07a8 +  lwu  R28, [R22, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
07ac +  decode_heap_oop  R7, R28	#@decodeHeapOop
07b0    lwu  R7, [R7, #12]	# range, #@loadRange
07b4    NullCheck R7

07b4    B143: #	out( B78 ) &lt;- in( B142 )  Freq: 0.671502
07b4 +  subw  R20, R7, R29	#@subI_reg_reg
07b8    spill [sp, #4] -&gt; R19	# spill size = 32
07bc +  j  B78	#@branch

07c0    B144: #	out( B113 ) &lt;- in( B44 )  Freq: 0.111004
07c0 +  li R19, #0	# int, #@loadConI
07c4 +  j  B113	#@branch

07c8    B145: #	out( B147 ) &lt;- in( B100 )  Freq: 0.0017134
07c8 +  spill R12 -&gt; R13	# spill size = 32
07cc +  spill R11 -&gt; R14	# spill size = 32
07d0 +  j  B147	#@branch

07d4    B146: #	out( B147 ) &lt;- in( B102 )  Freq: 0.0017134
07d4 +  # castII of R30, #@castII
07d4    addiw  R30, R30, #2	#@addI_reg_imm

07d8    B147: #	out( B151 ) &lt;- in( B145 B146 )  Freq: 0.0034268
07d8    spill R13 -&gt; R31	# spill size = 32
07dc +  spill R14 -&gt; R29	# spill size = 32
07e0 +  j  B151	#@branch

07e4    B148: #	out( B150 ) &lt;- in( B101 )  Freq: 0.0017134
07e4 +  spill R10 -&gt; R31	# spill size = 32
07e8 +  spill R16 -&gt; R29	# spill size = 32
07ec +  j  B150	#@branch

07f0    B149: #	out( B150 ) &lt;- in( B103 )  Freq: 0.0017134
07f0 +  # castII of R30, #@castII
07f0    addiw  R30, R30, #2	#@addI_reg_imm

07f4    B150: #	out( B151 ) &lt;- in( B148 B149 )  Freq: 0.0034268
07f4 +  addiw  R30, R30, #1	#@addI_reg_imm

07f8    B151: #	out( B152 ) &lt;- in( B185 B147 B150 )  Freq: 0.00685721
07f8    spill [sp, #64] -&gt; R7	# spill size = 64

07fc    B152: #	out( N2499 ) &lt;- in( B109 B151 )  Freq: 0.00686082
07fc +  spill [sp, #24] -&gt; R8	# spill size = 64
0800 +  spill [sp, #32] -&gt; R28	# spill size = 32
0804 +  spill R28 -&gt; [sp, #24]	# spill size = 32
0808 +  spill [sp, #36] -&gt; R10	# spill size = 32
080c +  spill [sp, #40] -&gt; R28	# spill size = 32
0810 +  li R11, #-187	# int, #@loadConI
0814    spill R22 -&gt; [sp, #8]	# spill size = 64
0818 +  spill R10 -&gt; [sp, #28]	# spill size = 32
081c +  spill R28 -&gt; [sp, #32]	# spill size = 32
0820 +  spill R9 -&gt; [sp, #36]	# spill size = 32
0824 +  spill R21 -&gt; [sp, #40]	# spill size = 32
0828 +  spill R20 -&gt; [sp, #44]	# spill size = 32
082c +  spill R18 -&gt; [sp, #48]	# spill size = 32
0830 +  spill R7 -&gt; [sp, #56]	# spill size = 64
0834 +  spill R24 -&gt; [sp, #64]	# spill size = 64
0838 +  spill R30 -&gt; [sp, #52]	# spill size = 32
083c +  spill R29 -&gt; [sp, #80]	# spill size = 32
0840 +  spill R31 -&gt; [sp, #84]	# spill size = 32
0844    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:73 (line 724) L[0]=_ L[1]=_ L[2]=sp + #40 L[3]=sp + #44 L[4]=sp + #48 L[5]=sp + #56 L[6]=sp + #64 L[7]=sp + #52 L[8]=sp + #80 L[9]=sp + #84 STK[0]=sp + #80 STK[1]=sp + #84
        # sun.nio.fs.UnixPath::equals @ bci:14 (line 735) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.UnixPath::relativize @ bci:117 (line 417) L[0]=R8 L[1]=sp + #8 L[2]=sp + #8 L[3]=R8 L[4]=sp + #24 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #36 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [8]=Oop [56]=Oop [64]=Oop off=2120/0x848}
0848    #@ShouldNotReachHere

0854    B153: #	out( B242 B154 ) &lt;- in( B63 B64 )  Freq: 0.000801596
0854 +  spill R11 -&gt; [sp, #16]	# spill size = 64
0858 +  spill R12 -&gt; [sp, #48]	# spill size = 64
085c +  spill R7 -&gt; [sp, #28]	# spill size = 32
0860 +  spill R10 -&gt; [sp, #24]	# spill size = 32
0864 +  spill R29 -&gt; [sp, #4]	# spill size = 32
0868 +  spill R9 -&gt; R8	# spill size = 64
086c +  mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
0884    spill R7 -&gt; R12	# spill size = 32
0888    CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=R8 L[1]=_ L[2]=sp + #4 L[3]=sp + #28 L[4]=_
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=R8 L[1]=sp + #8 L[2]=sp + #8 L[3]=R8 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=sp + #0 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [8]=Oop [48]=Oop off=2188/0x88c}

088c    B154: #	out( B66 ) &lt;- in( B153 )  Freq: 0.00080158
        # Block is sole successor of call
088c +  spill R10 -&gt; R28	# spill size = 64
0890 +  spill R8 -&gt; R9	# spill size = 64
0894 +  spill [sp, #0] -&gt; R30	# spill size = 32
0898 +  spill [sp, #16] -&gt; R11	# spill size = 64
089c +  spill [sp, #4] -&gt; R29	# spill size = 32
08a0 +  spill [sp, #24] -&gt; R10	# spill size = 32
08a4 +  spill [sp, #28] -&gt; R7	# spill size = 32
08a8 +  spill [sp, #48] -&gt; R12	# spill size = 64
08ac +  spill R28 -&gt; R13	# spill size = 64
08b0 +  j  B66	#@branch

08b4    B155: #	out( B241 B156 ) &lt;- in( B82 B83 )  Freq: 0.000801572
08b4 +  spill [sp, #0] -&gt; [sp, #8]	# spill size = 32
08bc +  spill R20 -&gt; [sp, #20]	# spill size = 32
08c0 +  spill R29 -&gt; [sp, #16]	# spill size = 32
08c4 +  spill R19 -&gt; [sp, #12]	# spill size = 32
08c8 +  spill R22 -&gt; [sp, #0]	# spill size = 64
08cc +  mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
08e4    spill R20 -&gt; R12	# spill size = 32
08e8    CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #0 L[1]=_ L[2]=sp + #16 L[3]=sp + #20 L[4]=_
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=sp + #24 L[1]=sp + #0 L[2]=sp + #0 L[3]=sp + #24 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=sp + #8 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#ScObj0
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=sp + #72, [path :2]=sp + #64, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # OopMap {fp=Oop [0]=Oop [24]=Oop [48]=Derived_oop_[64] [64]=Oop [72]=Oop off=2284/0x8ec}

08ec    B156: #	out( B85 ) &lt;- in( B155 )  Freq: 0.000801556
        # Block is sole successor of call
08ec +  spill [sp, #0] -&gt; R22	# spill size = 64
08f0 +  spill [sp, #8] -&gt; R9	# spill size = 32
08f4 +  spill [sp, #12] -&gt; R19	# spill size = 32
08f8 +  spill [sp, #16] -&gt; R29	# spill size = 32
08fc +  spill [sp, #20] -&gt; R20	# spill size = 32
0900 +  spill R10 -&gt; R24	# spill size = 64
0904 +  j  B85	#@branch

0908    B157: #	out( B159 ) &lt;- in( B18 )  Freq: 0.000215956
0908 +  spill R18 -&gt; R21	# spill size = 32
090c +  spill R29 -&gt; R28	# spill size = 32
0910 +  j  B159	#@branch

0914    B158: #	out( B159 ) &lt;- in( B20 )  Freq: 0.000215956
0914 +  addiw  R31, R31, #2	#@addI_reg_imm

0918    B159: #	out( B162 ) &lt;- in( B157 B158 )  Freq: 0.000431912
0918    spill R21 -&gt; R13	# spill size = 32
091c +  spill R28 -&gt; R10	# spill size = 32
0920 +  j  B162	#@branch

0924    B160: #	out( B162 ) &lt;- in( B19 )  Freq: 0.000215956
0924 +  addiw  R31, R31, #1	#@addI_reg_imm
0928    spill R11 -&gt; R13	# spill size = 32
092c +  spill R19 -&gt; R10	# spill size = 32
0930 +  j  B162	#@branch

0934    B161: #	out( B162 ) &lt;- in( B21 )  Freq: 0.000215956
0934 +  addiw  R31, R31, #3	#@addI_reg_imm

0938    B162: #	out( N2499 ) &lt;- in( B29 B214 B159 B160 B161 )  Freq: 0.000864732
0938 +  li R11, #-187	# int, #@loadConI
093c    spill R14 -&gt; [sp, #0]	# spill size = 64
0940 +  spill R12 -&gt; [sp, #16]	# spill size = 64
0944 +  spill R9 -&gt; [sp, #24]	# spill size = 64
0948 +  spill R17 -&gt; [sp, #32]	# spill size = 64
094c +  spill R31 -&gt; [sp, #40]	# spill size = 32
0950 +  spill R10 -&gt; [sp, #52]	# spill size = 32
0954 +  spill R13 -&gt; [sp, #56]	# spill size = 32
0958 +  spill R30 -&gt; [sp, #60]	# spill size = 32
095c +  spill R16 -&gt; [sp, #64]	# spill size = 32
0960    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:73 (line 724) L[0]=_ L[1]=_ L[2]=sp + #60 L[3]=sp + #64 L[4]=R8 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=sp + #52 L[9]=sp + #56 STK[0]=sp + #52 STK[1]=sp + #56
        # sun.nio.fs.UnixPath::equals @ bci:14 (line 735) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.UnixPath::relativize @ bci:7 (line 393) L[0]=sp + #0 L[1]=sp + #16 L[2]=sp + #16 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop off=2404/0x964}
0964    #@ShouldNotReachHere

0970    B163: #	out( B239 B164 ) &lt;- in( B134 )  Freq: 9.91925e-05
0970 +  mv  R11, precise klass sun/nio/fs/UnixPath: 0x00000040d060f9c0:Constant:exact *	# ptr, #@loadConP
0988    spill [sp, #32] -&gt; [sp, #0]	# spill size = 64
0990    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixPath::subpath @ bci:122 (line 347) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=sp + #24 L[1]=sp + #0 L[2]=_ L[3]=sp + #24 L[4]=sp + #40 L[5]=_ L[6]=_ L[7]=sp + #48 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [0]=Oop [24]=Oop [32]=Oop off=2452/0x994}

0994    B164: #	out( B136 ) &lt;- in( B163 )  Freq: 9.91906e-05
        # Block is sole successor of call
0994 +  j  B136	#@branch

0998    B165: #	out( B240 B166 ) &lt;- in( B129 B130 )  Freq: 0.000100197
0998 +  spill R11 -&gt; [sp, #56]	# spill size = 64
099c +  spill R12 -&gt; [sp, #16]	# spill size = 64
09a0 +  spill R13 -&gt; [sp, #64]	# spill size = 64
09a4 +  spill R10 -&gt; [sp, #12]	# spill size = 32
09a8 +  spill R29 -&gt; [sp, #8]	# spill size = 32
09ac +  spill R7 -&gt; [sp, #4]	# spill size = 32
09b0 +  spill [sp, #48] -&gt; [sp, #0]	# spill size = 32
09b8 +  spill [sp, #32] -&gt; R8	# spill size = 64
09bc +  mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
09d4    spill R29 -&gt; R12	# spill size = 32
09d8    CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::subpath @ bci:105 (line 345) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #4 L[4]=sp + #8 L[5]=_
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=sp + #24 L[1]=R8 L[2]=_ L[3]=sp + #24 L[4]=sp + #40 L[5]=_ L[6]=_ L[7]=sp + #0 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [24]=Oop [32]=Oop [56]=Oop off=2524/0x9dc}

09dc    B166: #	out( B132 ) &lt;- in( B165 )  Freq: 0.000100195
        # Block is sole successor of call
09dc +  spill R10 -&gt; R8	# spill size = 64
09e0 +  spill [sp, #4] -&gt; R7	# spill size = 32
09e4 +  spill [sp, #16] -&gt; R12	# spill size = 64
09e8 +  spill [sp, #56] -&gt; R11	# spill size = 64
09ec +  spill [sp, #12] -&gt; R10	# spill size = 32
09f0 +  spill [sp, #64] -&gt; R13	# spill size = 64
09f4 +  j  B132	#@branch

09f8    B167: #	out( N2499 ) &lt;- in( B53 )  Freq: 8.03967e-06
09f8 +  li R11, #-28	# int, #@loadConI
09fc    spill R30 -&gt; [sp, #56]	# spill size = 32
0a00 +  spill R30 -&gt; [sp, #60]	# spill size = 32
0a04    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:38 (line 307) L[0]=sp + #24 L[1]=sp + #60 L[2]=_ L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #56
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=sp + #24 L[1]=sp + #8 L[2]=sp + #8 L[3]=sp + #24 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=sp + #56 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop off=2568/0xa08}
0a08    #@ShouldNotReachHere

0a14    B168: #	out( B68 ) &lt;- in( B66 )  Freq: 8.03961e-06
0a14 +  spill R30 -&gt; [sp, #0]	# spill size = 32
0a18 +  spill R11 -&gt; [sp, #16]	# spill size = 64
0a1c +  spill R10 -&gt; [sp, #4]	# spill size = 32
0a20 +  spill R7 -&gt; [sp, #44]	# spill size = 32
0a24 +  spill R13 -&gt; [sp, #64]	# spill size = 64
0a28 +  spill R28 -&gt; [sp, #48]	# spill size = 64
0a2c +  j  B68	#@branch

0a30    B169: #	out( N2499 ) &lt;- in( B72 )  Freq: 8.03943e-06
0a30 +  li R11, #-28	# int, #@loadConI
0a34    spill R9 -&gt; [sp, #56]	# spill size = 32
0a38 +  spill R9 -&gt; [sp, #60]	# spill size = 32
0a3c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:38 (line 307) L[0]=sp + #8 L[1]=sp + #60 L[2]=_ L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #56
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=sp + #24 L[1]=sp + #8 L[2]=sp + #8 L[3]=sp + #24 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=sp + #56 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#ScObj0
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=sp + #72, [path :2]=sp + #64, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # OopMap {fp=Oop [8]=Oop [24]=Oop [64]=Oop [72]=Oop off=2624/0xa40}
0a40    #@ShouldNotReachHere

0a4c    B170: #	out( N2499 ) &lt;- in( B61 B62 )  Freq: 1.58685e-05
0a4c +  spill [sp, #24] -&gt; [sp, #16]	# spill size = 64
0a54 +  spill [sp, #32] -&gt; R31	# spill size = 32
0a58 +  spill R31 -&gt; [sp, #24]	# spill size = 32
0a5c +  spill [sp, #36] -&gt; R28	# spill size = 32
0a60 +  spill [sp, #40] -&gt; R31	# spill size = 32
0a64 +  li R11, #-52	# int, #@loadConI
0a68    spill R28 -&gt; [sp, #28]	# spill size = 32
0a6c +  spill R31 -&gt; [sp, #32]	# spill size = 32
0a70 +  spill R30 -&gt; [sp, #36]	# spill size = 32
0a74 +  spill R9 -&gt; [sp, #40]	# spill size = 64
0a78 +  spill R7 -&gt; [sp, #52]	# spill size = 32
0a7c +  spill R29 -&gt; [sp, #56]	# spill size = 32
0a80    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #16 L[1]=_ L[2]=sp + #56 L[3]=sp + #52 L[4]=_ STK[0]=sp + #52
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=sp + #16 L[1]=sp + #8 L[2]=sp + #8 L[3]=sp + #40 L[4]=sp + #24 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #36 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[8]=Oop [16]=Oop [40]=Oop off=2692/0xa84}
0a84    #@ShouldNotReachHere

0a90    B171: #	out( N2499 ) &lt;- in( B80 B81 )  Freq: 1.58681e-05
0a90 +  spill [sp, #24] -&gt; R8	# spill size = 64
0a94 +  spill [sp, #32] -&gt; R28	# spill size = 32
0a98 +  spill [sp, #36] -&gt; R7	# spill size = 32
0a9c +  spill R28 -&gt; [sp, #24]	# spill size = 32
0aa0 +  spill R7 -&gt; [sp, #28]	# spill size = 32
0aa4 +  spill [sp, #40] -&gt; R28	# spill size = 32
0aa8 +  spill [sp, #64] -&gt; R7	# spill size = 64
0aac +  li R11, #-52	# int, #@loadConI
0ab0    spill R28 -&gt; [sp, #32]	# spill size = 32
0ab4 +  spill R9 -&gt; [sp, #36]	# spill size = 32
0ab8 +  spill R20 -&gt; [sp, #52]	# spill size = 32
0abc +  spill R7 -&gt; [sp, #56]	# spill size = 64
0ac0 +  spill R29 -&gt; [sp, #64]	# spill size = 32
0ac4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #8 L[1]=_ L[2]=sp + #64 L[3]=sp + #52 L[4]=_ STK[0]=sp + #52
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=R8 L[1]=sp + #8 L[2]=sp + #8 L[3]=R8 L[4]=sp + #24 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #36 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#ScObj0
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=sp + #72, [path :2]=sp + #56, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # OopMap {fp=Oop [8]=Oop [56]=Oop [72]=Oop off=2760/0xac8}
0ac8    #@ShouldNotReachHere

0ad4    B172: #	out( N2499 ) &lt;- in( B46 )  Freq: 7.92709e-06
0ad4 +  spill [sp, #24] -&gt; R8	# spill size = 64
0ad8 +  spill [sp, #32] -&gt; R7	# spill size = 32
0adc +  spill [sp, #36] -&gt; R28	# spill size = 32
0ae0 +  li R11, #-187	# int, #@loadConI
0ae4    spill R22 -&gt; [sp, #8]	# spill size = 64
0ae8 +  spill R7 -&gt; [sp, #24]	# spill size = 32
0aec +  spill R28 -&gt; [sp, #28]	# spill size = 32
0af0 +  spill R9 -&gt; [sp, #36]	# spill size = 32
0af4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::relativize @ bci:120 (line 417) L[0]=R8 L[1]=sp + #8 L[2]=sp + #8 L[3]=R8 L[4]=sp + #24 L[5]=sp + #28 L[6]=sp + #40 L[7]=sp + #36 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#0
        # OopMap {fp=Oop [8]=Oop off=2808/0xaf8}
0af8    #@ShouldNotReachHere

0b04    B173: #	out( N2499 ) &lt;- in( B90 B88 B89 B91 )  Freq: 3.06821e-05
0b04 +  spill [sp, #24] -&gt; R8	# spill size = 64
0b08 +  spill [sp, #32] -&gt; R28	# spill size = 32
0b0c +  spill R28 -&gt; [sp, #24]	# spill size = 32
0b10 +  spill [sp, #36] -&gt; R7	# spill size = 32
0b14 +  spill [sp, #40] -&gt; R28	# spill size = 32
0b18 +  spill R7 -&gt; [sp, #28]	# spill size = 32
0b1c +  spill [sp, #44] -&gt; [sp, #40]	# spill size = 32
0b24 +  spill [sp, #64] -&gt; R7	# spill size = 64
0b28 +  li R11, #-138	# int, #@loadConI
0b2c    spill R22 -&gt; [sp, #8]	# spill size = 64
0b30 +  spill R28 -&gt; [sp, #32]	# spill size = 32
0b34 +  spill R9 -&gt; [sp, #36]	# spill size = 32
0b38 +  spill R20 -&gt; [sp, #44]	# spill size = 32
0b3c +  spill R7 -&gt; [sp, #56]	# spill size = 64
0b40 +  spill R24 -&gt; [sp, #64]	# spill size = 64
0b44 +  spill R18 -&gt; [sp, #52]	# spill size = 32
0b48    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:44 (line 721) L[0]=_ L[1]=_ L[2]=sp + #40 L[3]=sp + #44 L[4]=sp + #52 L[5]=sp + #56 L[6]=sp + #64 L[7]=#0 L[8]=_ L[9]=_ STK[0]=#0 STK[1]=sp + #52
        # sun.nio.fs.UnixPath::equals @ bci:14 (line 735) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.UnixPath::relativize @ bci:117 (line 417) L[0]=R8 L[1]=sp + #8 L[2]=sp + #8 L[3]=R8 L[4]=sp + #24 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #36 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [8]=Oop [56]=Oop [64]=Oop off=2892/0xb4c}
0b4c    #@ShouldNotReachHere

0b58    B174: #	out( B106 ) &lt;- in( B93 )  Freq: 7.67051e-06
0b58 +  li R30, #1	# int, #@loadConI
0b5c +  j  B106	#@branch

0b60    B175: #	out( N2499 ) &lt;- in( B94 )  Freq: 7.56998e-06
0b60    #@ShouldNotReachHere

0b6c    B176: #	out( N2499 ) &lt;- in( B95 )  Freq: 7.56997e-06
0b6c    #@ShouldNotReachHere

0b78    B177: #	out( N2499 ) &lt;- in( B96 )  Freq: 7.56996e-06
0b78    #@ShouldNotReachHere

0b84    B178: #	out( N2499 ) &lt;- in( B97 )  Freq: 7.56995e-06
0b84    #@ShouldNotReachHere

0b90    B179: #	out( N2499 ) &lt;- in( B57 )  Freq: 7.3592e-06
0b90 +  li R11, #-28	# int, #@loadConI
0b94    spill R30 -&gt; [sp, #44]	# spill size = 32
0b98 +  spill R29 -&gt; [sp, #56]	# spill size = 32
0b9c +  spill R10 -&gt; [sp, #60]	# spill size = 32
0ba0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:69 (line 312) L[0]=sp + #24 L[1]=_ L[2]=sp + #56 L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #60
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=sp + #24 L[1]=sp + #8 L[2]=sp + #8 L[3]=sp + #24 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=sp + #44 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop off=2980/0xba4}
0ba4    #@ShouldNotReachHere

0bb0    B180: #	out( N2499 ) &lt;- in( B76 )  Freq: 7.35899e-06
0bb0 +  spill [sp, #64] -&gt; R7	# spill size = 64
0bb4 +  li R11, #-28	# int, #@loadConI
0bb8    spill R9 -&gt; [sp, #44]	# spill size = 32
0bbc +  spill R7 -&gt; [sp, #56]	# spill size = 64
0bc0 +  spill R29 -&gt; [sp, #64]	# spill size = 32
0bc4 +  spill R19 -&gt; [sp, #68]	# spill size = 32
0bc8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:69 (line 312) L[0]=sp + #8 L[1]=_ L[2]=sp + #64 L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #68
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=sp + #24 L[1]=sp + #8 L[2]=sp + #8 L[3]=sp + #24 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=sp + #44 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#ScObj0
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=sp + #72, [path :2]=sp + #56, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # OopMap {fp=Oop [8]=Oop [24]=Oop [56]=Oop [72]=Oop off=3020/0xbcc}
0bcc    #@ShouldNotReachHere

0bd8    B181: #	out( N2499 ) &lt;- in( B107 )  Freq: 3.83177e-06
0bd8    #@ShouldNotReachHere

0be4    B182: #	out( N2499 ) &lt;- in( B108 )  Freq: 3.83176e-06
0be4    #@ShouldNotReachHere

0bf0    B183: #	out( N2499 ) &lt;- in( B51 )  Freq: 3.78338e-06
0bf0 +  li R11, #-187	# int, #@loadConI
0bf4    spill R30 -&gt; [sp, #56]	# spill size = 32
0bf8 +  spill R30 -&gt; [sp, #60]	# spill size = 32
0bfc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:22 (line 304) L[0]=sp + #24 L[1]=sp + #60 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #56 STK[1]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=sp + #24 L[1]=sp + #8 L[2]=sp + #8 L[3]=sp + #24 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=sp + #56 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[8]=Oop [24]=Oop off=3072/0xc00}
0c00    #@ShouldNotReachHere

0c0c    B184: #	out( N2499 ) &lt;- in( B70 )  Freq: 3.78327e-06
0c0c +  li R11, #-187	# int, #@loadConI
0c10    spill R9 -&gt; [sp, #56]	# spill size = 32
0c14 +  spill R9 -&gt; [sp, #60]	# spill size = 32
0c18    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:22 (line 304) L[0]=sp + #8 L[1]=sp + #60 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #56 STK[1]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=sp + #24 L[1]=sp + #8 L[2]=sp + #8 L[3]=sp + #24 L[4]=sp + #32 L[5]=sp + #36 L[6]=sp + #40 L[7]=sp + #56 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#ScObj0
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=sp + #72, [path :2]=sp + #64, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # OopMap {[8]=Oop [24]=Oop [64]=Oop [72]=Oop off=3100/0xc1c}
0c1c    #@ShouldNotReachHere

0c28    B185: #	out( B151 ) &lt;- in( B92 )  Freq: 3.60965e-06
0c28 +  li R30, #0	# int, #@loadConI
0c2c +  j  B151	#@branch

0c30    B186: #	out( N2499 ) &lt;- in( B31 )  Freq: 1.01239e-06
0c30 +  li R11, #-187	# int, #@loadConI
0c34    spill R14 -&gt; R8	# spill size = 64
0c38 +  spill R12 -&gt; [sp, #8]	# spill size = 64
0c3c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::relativize @ bci:10 (line 393) L[0]=R8 L[1]=sp + #8 L[2]=sp + #8 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#1
        # OopMap {fp=Oop [8]=Oop off=3136/0xc40}
0c40    #@ShouldNotReachHere

0c4c    B187: #	out( N2499 ) &lt;- in( B122 )  Freq: 1.00493e-06
0c4c +  spill [sp, #24] -&gt; R7	# spill size = 64
0c50 +  spill R7 -&gt; [sp, #16]	# spill size = 64
0c54 +  spill [sp, #40] -&gt; R7	# spill size = 32
0c58 +  li R11, #-28	# int, #@loadConI
0c5c    spill R7 -&gt; [sp, #24]	# spill size = 32
0c60 +  spill R31 -&gt; [sp, #28]	# spill size = 32
0c64 +  spill R28 -&gt; [sp, #44]	# spill size = 32
0c68    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:68 (line 336) L[0]=sp + #32 L[1]=_ L[2]=sp + #28 L[3]=_ L[4]=_ L[5]=_ STK[0]=R8 STK[1]=sp + #48
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=sp + #16 L[1]=sp + #32 L[2]=_ L[3]=sp + #16 L[4]=sp + #24 L[5]=_ L[6]=_ L[7]=sp + #44 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [16]=Oop [32]=Oop off=3180/0xc6c}
0c6c    #@ShouldNotReachHere

0c78    B188: #	out( B128 ) &lt;- in( B126 )  Freq: 1.00493e-06
0c78 +  spill R12 -&gt; R28	# spill size = 64
0c7c +  j  B128	#@branch

0c80    B189: #	out( N2499 ) &lt;- in( B128 )  Freq: 9.91762e-07
0c80 +  spill [sp, #40] -&gt; R28	# spill size = 32
0c84 +  spill [sp, #32] -&gt; [sp, #0]	# spill size = 64
0c8c +  li R11, #-52	# int, #@loadConI
0c90    spill [sp, #24] -&gt; R8	# spill size = 64
0c94 +  spill R28 -&gt; [sp, #16]	# spill size = 32
0c98 +  spill R7 -&gt; [sp, #32]	# spill size = 32
0c9c +  spill R29 -&gt; [sp, #40]	# spill size = 32
0ca0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:105 (line 345) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=sp + #32 L[4]=sp + #40 L[5]=_ STK[0]=sp + #40
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=R8 L[4]=sp + #16 L[5]=_ L[6]=_ L[7]=sp + #48 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [0]=Oop off=3236/0xca4}
0ca4    #@ShouldNotReachHere

0cb0    B190: #	out( N2499 ) &lt;- in( B8 B6 B7 B9 )  Freq: 3.84181e-06
0cb0 +  li R11, #-138	# int, #@loadConI
0cb4    spill R14 -&gt; [sp, #0]	# spill size = 64
0cb8 +  spill R12 -&gt; [sp, #16]	# spill size = 64
0cbc +  spill R9 -&gt; [sp, #24]	# spill size = 64
0cc0 +  spill R17 -&gt; [sp, #32]	# spill size = 64
0cc4 +  spill R30 -&gt; [sp, #40]	# spill size = 32
0cc8 +  spill R16 -&gt; [sp, #44]	# spill size = 32
0ccc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:44 (line 721) L[0]=_ L[1]=_ L[2]=sp + #40 L[3]=sp + #44 L[4]=R8 L[5]=sp + #24 L[6]=sp + #32 L[7]=#0 L[8]=_ L[9]=_ STK[0]=#0 STK[1]=R8
        # sun.nio.fs.UnixPath::equals @ bci:14 (line 735) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.UnixPath::relativize @ bci:7 (line 393) L[0]=sp + #0 L[1]=sp + #16 L[2]=sp + #16 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop off=3280/0xcd0}
0cd0    #@ShouldNotReachHere

0cdc    B191: #	out( B24 ) &lt;- in( B11 )  Freq: 9.66785e-07
0cdc +  li R31, #1	# int, #@loadConI
0ce0 +  j  B24	#@branch

0ce4    B192: #	out( N2499 ) &lt;- in( B12 )  Freq: 9.54114e-07
0ce4    #@ShouldNotReachHere

0cf0    B193: #	out( N2499 ) &lt;- in( B13 )  Freq: 9.54113e-07
0cf0    #@ShouldNotReachHere

0cfc    B194: #	out( N2499 ) &lt;- in( B14 )  Freq: 9.54112e-07
0cfc    #@ShouldNotReachHere

0d08    B195: #	out( N2499 ) &lt;- in( B15 )  Freq: 9.54111e-07
0d08    #@ShouldNotReachHere

0d14    B196: #	out( N2499 ) &lt;- in( B32 )  Freq: 4.99561e-07
0d14 +  li R11, #-187	# int, #@loadConI
0d18    spill R12 -&gt; [sp, #8]	# spill size = 64
0d1c +  spill R14 -&gt; [sp, #16]	# spill size = 64
0d20 +  spill R16 -&gt; [sp, #24]	# spill size = 32
0d24    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::isAbsolute @ bci:5 (line 352) L[0]=sp + #16 STK[0]=sp + #24
        # sun.nio.fs.UnixPath::relativize @ bci:19 (line 397) L[0]=sp + #16 L[1]=sp + #8 L[2]=sp + #8 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[8]=Oop [16]=Oop off=3368/0xd28}
0d28    #@ShouldNotReachHere

0d34    B197: #	out( N2499 ) &lt;- in( B33 )  Freq: 4.99561e-07
0d34 +  li R11, #-187	# int, #@loadConI
0d38    spill R14 -&gt; [sp, #0]	# spill size = 64
0d3c +  spill R12 -&gt; [sp, #16]	# spill size = 64
0d40    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::isAbsolute @ bci:16 (line 352) L[0]=_ STK[0]=R8 STK[1]=#47
        # sun.nio.fs.UnixPath::relativize @ bci:19 (line 397) L[0]=sp + #0 L[1]=sp + #16 L[2]=sp + #16 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[0]=Oop [16]=Oop off=3396/0xd44}
0d44    #@ShouldNotReachHere

0d50    B198: #	out( N2499 ) &lt;- in( B34 )  Freq: 4.99561e-07
0d50 +  li R11, #-187	# int, #@loadConI
0d54    spill R14 -&gt; R8	# spill size = 64
0d58 +  spill R12 -&gt; [sp, #8]	# spill size = 64
0d5c +  spill R12 -&gt; [sp, #16]	# spill size = 64
0d60 +  spill R30 -&gt; [sp, #24]	# spill size = 32
0d64    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::isAbsolute @ bci:5 (line 352) L[0]=sp + #8 STK[0]=sp + #24
        # sun.nio.fs.UnixPath::relativize @ bci:23 (line 397) L[0]=R8 L[1]=sp + #8 L[2]=sp + #16 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#1
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=3432/0xd68}
0d68    #@ShouldNotReachHere

0d74    B199: #	out( N2499 ) &lt;- in( B35 )  Freq: 4.9956e-07
0d74 +  li R11, #-187	# int, #@loadConI
0d78    spill R14 -&gt; [sp, #0]	# spill size = 64
0d7c +  spill R12 -&gt; [sp, #16]	# spill size = 64
0d80    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::isAbsolute @ bci:16 (line 352) L[0]=_ STK[0]=R8 STK[1]=#47
        # sun.nio.fs.UnixPath::relativize @ bci:23 (line 397) L[0]=sp + #0 L[1]=sp + #16 L[2]=sp + #16 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#1
        # OopMap {[0]=Oop [16]=Oop off=3460/0xd84}
0d84    #@ShouldNotReachHere

0d90    B200: #	out( N2499 ) &lt;- in( B37 )  Freq: 4.9955e-07
0d90 +  li R11, #-187	# int, #@loadConI
0d94    spill R10 -&gt; [sp, #24]	# spill size = 32
0d98    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::relativize @ bci:54 (line 405) L[0]=R8 L[1]=sp + #0 L[2]=sp + #0 L[3]=R8 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=sp + #24
        # OopMap {fp=Oop [0]=Oop off=3484/0xd9c}
0d9c    #@ShouldNotReachHere

0da8    B201: #	out( N2499 ) &lt;- in( B124 )  Freq: 4.95882e-07
0da8 +  spill [sp, #24] -&gt; R28	# spill size = 64
0dac +  spill [sp, #40] -&gt; R29	# spill size = 32
0db0 +  spill [sp, #48] -&gt; [sp, #44]	# spill size = 32
0db8 +  li R11, #-187	# int, #@loadConI
0dbc    spill R28 -&gt; [sp, #16]	# spill size = 64
0dc0 +  spill R29 -&gt; [sp, #24]	# spill size = 32
0dc4 +  spill R31 -&gt; [sp, #40]	# spill size = 32
0dc8 +  spill R7 -&gt; [sp, #48]	# spill size = 32
0dcc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:76 (line 338) L[0]=sp + #32 L[1]=_ L[2]=sp + #40 L[3]=sp + #48 L[4]=_ L[5]=_ STK[0]=sp + #40 STK[1]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=sp + #16 L[1]=sp + #32 L[2]=_ L[3]=sp + #16 L[4]=sp + #24 L[5]=_ L[6]=_ L[7]=sp + #44 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[16]=Oop [32]=Oop off=3536/0xdd0}
0dd0    #@ShouldNotReachHere

0ddc    B202: #	out( N2499 ) &lt;- in( B138 )  Freq: 4.9588e-07
0ddc +  spill [sp, #24] -&gt; R8	# spill size = 64
0de0 +  spill [sp, #32] -&gt; [sp, #0]	# spill size = 64
0de8 +  li R11, #-187	# int, #@loadConI
0dec    spill R7 -&gt; [sp, #20]	# spill size = 32
0df0 +  spill [sp, #48] -&gt; [sp, #24]	# spill size = 32
0df8 +  spill R10 -&gt; [sp, #32]	# spill size = 64
0dfc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::relativize @ bci:172 (line 434) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=R8 L[4]=sp + #20 L[5]=_ L[6]=_ L[7]=sp + #24 L[8]=sp + #32 L[9]=#0 L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=sp + #24 STK[1]=sp + #40
        # OopMap {fp=Oop [0]=Oop [32]=Oop off=3584/0xe00}
0e00    #@ShouldNotReachHere

0e0c    B203: #	out( N2499 ) &lt;- in( B25 )  Freq: 4.82953e-07
0e0c    #@ShouldNotReachHere

0e18    B204: #	out( N2499 ) &lt;- in( B26 )  Freq: 4.82952e-07
0e18    #@ShouldNotReachHere

0e24    B205: #	out( N2499 ) &lt;- in( B27 )  Freq: 4.82952e-07
0e24    #@ShouldNotReachHere

0e30    B206: #	out( N2499 ) &lt;- in( B28 )  Freq: 4.82951e-07
0e30    #@ShouldNotReachHere

0e3c    B207: #	out( N2499 ) &lt;- in( B39 )  Freq: 4.76398e-07
0e3c +  li R11, #-187	# int, #@loadConI
0e40    spill R10 -&gt; [sp, #24]	# spill size = 32
0e44    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::relativize @ bci:61 (line 405) L[0]=R8 L[1]=sp + #0 L[2]=sp + #0 L[3]=R8 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=sp + #24
        # OopMap {fp=Oop [0]=Oop off=3656/0xe48}
0e48    #@ShouldNotReachHere

0e54    B208: #	out( N2499 ) &lt;- in( B113 )  Freq: 4.72923e-07
0e54 +  spill [sp, #24] -&gt; R8	# spill size = 64
0e58 +  li R11, #-187	# int, #@loadConI
0e5c    spill R22 -&gt; [sp, #8]	# spill size = 64
0e60 +  spill R7 -&gt; [sp, #24]	# spill size = 32
0e64 +  spill R28 -&gt; [sp, #32]	# spill size = 32
0e68 +  spill R19 -&gt; [sp, #40]	# spill size = 32
0e6c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::relativize @ bci:136 (line 425) L[0]=R8 L[1]=sp + #8 L[2]=sp + #8 L[3]=R8 L[4]=sp + #24 L[5]=sp + #32 L[6]=_ L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=sp + #40 STK[1]=sp + #32
        # OopMap {fp=Oop [8]=Oop off=3696/0xe70}
0e70    #@ShouldNotReachHere

0e7c    B209: #	out( N2499 ) &lt;- in( B115 )  Freq: 4.72913e-07
0e7c +  spill [sp, #40] -&gt; R28	# spill size = 32
0e80 +  spill [sp, #32] -&gt; [sp, #0]	# spill size = 64
0e88 +  li R11, #-187	# int, #@loadConI
0e8c    spill [sp, #24] -&gt; R8	# spill size = 64
0e90 +  spill R28 -&gt; [sp, #16]	# spill size = 32
0e94 +  spill [sp, #48] -&gt; [sp, #32]	# spill size = 32
0e9c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:5 (line 325) L[0]=sp + #0 L[1]=sp + #32 L[2]=sp + #44 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #32
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=R8 L[4]=sp + #16 L[5]=_ L[6]=_ L[7]=sp + #32 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [0]=Oop off=3744/0xea0}
0ea0    #@ShouldNotReachHere

0eac    B210: #	out( N2499 ) &lt;- in( B117 )  Freq: 4.72912e-07
0eac +  spill [sp, #24] -&gt; R7	# spill size = 64
0eb0 +  spill R7 -&gt; [sp, #16]	# spill size = 64
0eb4 +  spill [sp, #40] -&gt; R7	# spill size = 32
0eb8 +  spill [sp, #44] -&gt; R28	# spill size = 32
0ebc +  li R11, #-187	# int, #@loadConI
0ec0    spill R7 -&gt; [sp, #24]	# spill size = 32
0ec4 +  spill R28 -&gt; [sp, #28]	# spill size = 32
0ec8 +  spill [sp, #48] -&gt; [sp, #40]	# spill size = 32
0ed0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:22 (line 327) L[0]=sp + #32 L[1]=sp + #40 L[2]=sp + #28 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #40 STK[1]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=sp + #16 L[1]=sp + #32 L[2]=_ L[3]=sp + #16 L[4]=sp + #24 L[5]=_ L[6]=_ L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[16]=Oop [32]=Oop off=3796/0xed4}
0ed4    #@ShouldNotReachHere

0ee0    B211: #	out( N2499 ) &lt;- in( B119 )  Freq: 4.72912e-07
0ee0 +  spill [sp, #24] -&gt; R7	# spill size = 64
0ee4 +  spill R7 -&gt; [sp, #16]	# spill size = 64
0ee8 +  spill [sp, #40] -&gt; R7	# spill size = 32
0eec +  li R11, #-187	# int, #@loadConI
0ef0    spill R7 -&gt; [sp, #24]	# spill size = 32
0ef4 +  spill R31 -&gt; [sp, #40]	# spill size = 32
0ef8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:39 (line 329) L[0]=sp + #32 L[1]=sp + #48 L[2]=sp + #40 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #40 STK[1]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=sp + #16 L[1]=sp + #32 L[2]=_ L[3]=sp + #16 L[4]=sp + #24 L[5]=_ L[6]=_ L[7]=sp + #48 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[16]=Oop [32]=Oop off=3836/0xefc}
0efc    #@ShouldNotReachHere

0f08    B212: #	out( N2499 ) &lt;- in( B120 )  Freq: 4.72911e-07
0f08 +  spill [sp, #40] -&gt; R28	# spill size = 32
0f0c +  spill [sp, #32] -&gt; [sp, #0]	# spill size = 64
0f14 +  li R11, #-187	# int, #@loadConI
0f18    spill [sp, #24] -&gt; R8	# spill size = 64
0f1c +  spill R28 -&gt; [sp, #16]	# spill size = 32
0f20 +  spill R31 -&gt; [sp, #32]	# spill size = 32
0f24 +  spill [sp, #48] -&gt; [sp, #36]	# spill size = 32
0f2c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:52 (line 331) L[0]=sp + #0 L[1]=sp + #36 L[2]=sp + #32 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #36 STK[1]=sp + #32
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=R8 L[4]=sp + #16 L[5]=_ L[6]=_ L[7]=sp + #36 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [0]=Oop off=3888/0xf30}
0f30    #@ShouldNotReachHere

0f3c    B213: #	out( N2499 ) &lt;- in( B137 )  Freq: 4.72908e-07
0f3c +  spill [sp, #24] -&gt; R7	# spill size = 64
0f40 +  spill [sp, #32] -&gt; [sp, #8]	# spill size = 64
0f48 +  li R11, #-187	# int, #@loadConI
0f4c    spill R7 -&gt; [sp, #16]	# spill size = 64
0f50 +  spill R10 -&gt; [sp, #32]	# spill size = 64
0f54    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::isEmpty @ bci:5 (line 216) L[0]=_ STK[0]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:163 (line 430) L[0]=sp + #16 L[1]=sp + #8 L[2]=_ L[3]=sp + #16 L[4]=sp + #40 L[5]=_ L[6]=_ L[7]=sp + #48 L[8]=sp + #32 L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[8]=Oop [16]=Oop [32]=Oop off=3928/0xf58}
0f58    #@ShouldNotReachHere

0f64    B214: #	out( B162 ) &lt;- in( B10 )  Freq: 4.54958e-07
0f64 +  li R31, #0	# int, #@loadConI
0f68 +  j  B162	#@branch

0f6c    B215: #	out( N2499 ) &lt;- in( B2 )  Freq: 1e-35
0f6c +  li R11, #-34	# int, #@loadConI
0f70    spill R7 -&gt; R8	# spill size = 64
0f74 +  spill R12 -&gt; [sp, #8]	# spill size = 64
0f78 +  spill R12 -&gt; [sp, #16]	# spill size = 64
0f7c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::toUnixPath @ bci:13 (line 166) L[0]=sp + #16 STK[0]=sp + #8
        # sun.nio.fs.UnixPath::relativize @ bci:1 (line 392) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=3968/0xf80}
0f80    #@ShouldNotReachHere

0f8c    B216: #	out( N2499 ) &lt;- in( B50 )  Freq: 8.03969e-06
0f8c +  li R11, #-10	# int, #@loadConI
0f90    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:21 (line 304) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=3988/0xf94}
0f94    #@ShouldNotReachHere

0fa0    B217: #	out( N2499 ) &lt;- in( B52 )  Freq: 8.03967e-06
0fa0 +  li R11, #-10	# int, #@loadConI
0fa4    spill R30 -&gt; R8	# spill size = 32
0fa8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:38 (line 307) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4012/0xfac}
0fac    #@ShouldNotReachHere

0fb8    B218: #	out( N2499 ) &lt;- in( B54 )  Freq: 8.03966e-06
0fb8 +  li R11, #-10	# int, #@loadConI
0fbc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:45 (line 309) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4032/0xfc0}
0fc0    #@ShouldNotReachHere

0fcc    B219: #	out( N2499 ) &lt;- in( B60 )  Freq: 8.03963e-06
0fcc +  spill [sp, #24] -&gt; [sp, #16]	# spill size = 64
0fd4 +  spill [sp, #32] -&gt; R28	# spill size = 32
0fd8 +  spill R28 -&gt; [sp, #24]	# spill size = 32
0fdc +  spill [sp, #36] -&gt; R31	# spill size = 32
0fe0 +  spill [sp, #40] -&gt; R28	# spill size = 32
0fe4 +  li R11, #-12	# int, #@loadConI
0fe8    spill R31 -&gt; [sp, #28]	# spill size = 32
0fec +  spill R28 -&gt; [sp, #32]	# spill size = 32
0ff0 +  spill R30 -&gt; [sp, #36]	# spill size = 32
0ff4 +  spill R9 -&gt; [sp, #40]	# spill size = 64
0ff8 +  spill R7 -&gt; [sp, #52]	# spill size = 32
0ffc +  spill R29 -&gt; [sp, #56]	# spill size = 32
1000    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #16 L[1]=_ L[2]=sp + #56 L[3]=sp + #52 L[4]=_ STK[0]=sp + #52
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=sp + #16 L[1]=sp + #8 L[2]=sp + #8 L[3]=sp + #40 L[4]=sp + #24 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #36 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {[8]=Oop [16]=Oop [40]=Oop off=4100/0x1004}
1004    #@ShouldNotReachHere

1010    B220: #	out( N2499 ) &lt;- in( B69 )  Freq: 8.03945e-06
1010 +  li R11, #-10	# int, #@loadConI
1014    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:21 (line 304) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=_
        # OopMap {off=4120/0x1018}
1018    #@ShouldNotReachHere

1024    B221: #	out( N2499 ) &lt;- in( B71 )  Freq: 8.03944e-06
1024 +  li R11, #-10	# int, #@loadConI
1028    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:38 (line 307) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=sp + #0
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=_
        # OopMap {off=4140/0x102c}
102c    #@ShouldNotReachHere

1038    B222: #	out( N2499 ) &lt;- in( B73 )  Freq: 8.03942e-06
1038 +  li R11, #-10	# int, #@loadConI
103c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:45 (line 309) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=_
        # OopMap {off=4160/0x1040}
1040    #@ShouldNotReachHere

104c    B223: #	out( N2499 ) &lt;- in( B79 )  Freq: 8.0394e-06
104c +  spill [sp, #24] -&gt; R8	# spill size = 64
1050 +  spill [sp, #32] -&gt; R7	# spill size = 32
1054 +  spill R7 -&gt; [sp, #24]	# spill size = 32
1058 +  spill [sp, #40] -&gt; R7	# spill size = 32
105c +  spill R7 -&gt; [sp, #32]	# spill size = 32
1060 +  spill [sp, #36] -&gt; R28	# spill size = 32
1064 +  spill [sp, #64] -&gt; R7	# spill size = 64
1068 +  li R11, #-12	# int, #@loadConI
106c    spill R28 -&gt; [sp, #28]	# spill size = 32
1070 +  spill R9 -&gt; [sp, #36]	# spill size = 32
1074 +  spill R20 -&gt; [sp, #52]	# spill size = 32
1078 +  spill R7 -&gt; [sp, #56]	# spill size = 64
107c +  spill R29 -&gt; [sp, #64]	# spill size = 32
1080    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #8 L[1]=_ L[2]=sp + #64 L[3]=sp + #52 L[4]=_ STK[0]=sp + #52
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=R8 L[1]=sp + #8 L[2]=sp + #8 L[3]=R8 L[4]=sp + #24 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #36 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=#ScObj0
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=sp + #72, [path :2]=sp + #56, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # OopMap {fp=Oop [8]=Oop [56]=Oop [72]=Oop off=4228/0x1084}
1084    #@ShouldNotReachHere

1090    B224: #	out( N2499 ) &lt;- in( B56 )  Freq: 7.35921e-06
1090 +  li R11, #-10	# int, #@loadConI
1094    spill R10 -&gt; R8	# spill size = 32
1098    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:69 (line 312) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4252/0x109c}
109c    #@ShouldNotReachHere

10a8    B225: #	out( N2499 ) &lt;- in( B75 )  Freq: 7.35899e-06
10a8 +  li R11, #-10	# int, #@loadConI
10ac    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:69 (line 312) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=sp + #4
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=_
        # OopMap {off=4272/0x10b0}
10b0    #@ShouldNotReachHere

10bc    B226: #	out( N2499 ) &lt;- in( B3 )  Freq: 1.01328e-06
10bc +  li R11, #-10	# int, #@loadConI
10c0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:4 (line 713) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::equals @ bci:14 (line 735) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.UnixPath::relativize @ bci:7 (line 393) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4292/0x10c4}
10c4    #@ShouldNotReachHere

10d0    B227: #	out( N2499 ) &lt;- in( B4 )  Freq: 1.01328e-06
10d0 +  li R11, #-10	# int, #@loadConI
10d4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::compareTo @ bci:13 (line 714) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::equals @ bci:14 (line 735) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.UnixPath::relativize @ bci:7 (line 393) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4312/0x10d8}
10d8    #@ShouldNotReachHere

10e4    B228: #	out( N2499 ) &lt;- in( B41 )  Freq: 1.01233e-06
10e4 +  li R11, #-10	# int, #@loadConI
10e8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getNameCount @ bci:8 (line 296) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:75 (line 410) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4332/0x10ec}
10ec    #@ShouldNotReachHere

10f8    B229: #	out( N2499 ) &lt;- in( B43 )  Freq: 1.0123e-06
10f8 +  li R11, #-10	# int, #@loadConI
10fc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getNameCount @ bci:8 (line 296) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:81 (line 411) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4352/0x1100}
1100    #@ShouldNotReachHere

110c    B230: #	out( N2499 ) &lt;- in( B116 )  Freq: 1.00494e-06
110c +  li R11, #-10	# int, #@loadConI
1110    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:21 (line 327) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4372/0x1114}
1114    #@ShouldNotReachHere

1120    B231: #	out( N2499 ) &lt;- in( B118 )  Freq: 1.00494e-06
1120 +  li R11, #-10	# int, #@loadConI
1124    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:38 (line 329) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4392/0x1128}
1128    #@ShouldNotReachHere

1134    B232: #	out( N2499 ) &lt;- in( B121 )  Freq: 1.00494e-06
1134 +  li R11, #-10	# int, #@loadConI
1138    spill [sp, #48] -&gt; R8	# spill size = 32
113c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:68 (line 336) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4416/0x1140}
1140    #@ShouldNotReachHere

114c    B233: #	out( N2499 ) &lt;- in( B123 )  Freq: 1.00493e-06
114c +  li R11, #-10	# int, #@loadConI
1150    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:75 (line 338) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4436/0x1154}
1154    #@ShouldNotReachHere

1160    B234: #	out( N2499 ) &lt;- in( B125 )  Freq: 1.00493e-06
1160 +  li R11, #-10	# int, #@loadConI
1164    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::subpath @ bci:83 (line 339) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:156 (line 429) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4456/0x1168}
1168    #@ShouldNotReachHere

1174    B235: #	out( N2499 ) &lt;- in( B136 )  Freq: 1.00493e-06
1174 +  li R11, #-10	# int, #@loadConI
1178    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::isEmpty @ bci:4 (line 216) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:163 (line 430) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4476/0x117c}
117c    #@ShouldNotReachHere

1188    B236: #	out( N2499 ) &lt;- in( B140 )  Freq: 6.80439e-07
1188 +  li R11, #-10	# int, #@loadConI
118c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:55 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:108 (line 417) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {off=4496/0x1190}
1190    #@ShouldNotReachHere

119c    B237: #	out( N2499 ) &lt;- in( B142 )  Freq: 6.80419e-07
119c +  li R11, #-10	# int, #@loadConI
11a0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:55 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::relativize @ bci:114 (line 417) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_ STK[0]=_
        # OopMap {off=4516/0x11a4}
11a4    #@ShouldNotReachHere

11b0    B238: #	out( N2499 ) &lt;- in( B1 )  Freq: 4.76837e-07
11b0 +  li R11, #-187	# int, #@loadConI
11b4    spill R7 -&gt; R8	# spill size = 64
11b8 +  spill R12 -&gt; [sp, #8]	# spill size = 64
11bc +  spill R12 -&gt; [sp, #16]	# spill size = 64
11c0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::toUnixPath @ bci:1 (line 164) L[0]=sp + #16 STK[0]=sp + #8
        # sun.nio.fs.UnixPath::relativize @ bci:1 (line 392) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ L[14]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=4548/0x11c4}
11c4    #@ShouldNotReachHere

11d0    B239: #	out( B244 ) &lt;- in( B163 )  Freq: 9.91925e-10
11d0     -- 	// exception oop; no code emitted, #@CreateException
11d0 +  j  B244	#@branch

11d4    B240: #	out( B244 ) &lt;- in( B165 )  Freq: 1.00197e-09
11d4     -- 	// exception oop; no code emitted, #@CreateException
11d4 +  j  B244	#@branch

11d8    B241: #	out( B252 ) &lt;- in( B155 )  Freq: 8.01572e-09
11d8     -- 	// exception oop; no code emitted, #@CreateException
11d8 +  j  B252	#@branch

11dc    B242: #	out( B250 ) &lt;- in( B153 )  Freq: 8.01596e-09
11dc     -- 	// exception oop; no code emitted, #@CreateException
11dc +  j  B250	#@branch

11e0    B243: #	out( B244 ) &lt;- in( B114 )  Freq: 9.9179e-06
11e0     -- 	// exception oop; no code emitted, #@CreateException

11e0    B244: #	out( B253 ) &lt;- in( B243 B240 B239 )  Freq: 9.9199e-06
11e0 +  spill R10 -&gt; R11	# spill size = 64
11e4 +  j  B253	#@branch

11e8    B245: #	out( B253 ) &lt;- in( B42 )  Freq: 9.99058e-06
11e8     -- 	// exception oop; no code emitted, #@CreateException
11e8 +  spill R10 -&gt; R11	# spill size = 64
11ec +  j  B253	#@branch

11f0    B246: #	out( B253 ) &lt;- in( B40 )  Freq: 9.99079e-06
11f0     -- 	// exception oop; no code emitted, #@CreateException
11f0 +  spill R10 -&gt; R11	# spill size = 64
11f4 +  j  B253	#@branch

11f8    B247: #	out( B253 ) &lt;- in( B38 )  Freq: 9.991e-06
11f8     -- 	// exception oop; no code emitted, #@CreateException
11f8 +  spill R10 -&gt; R11	# spill size = 64
11fc +  j  B253	#@branch

1200    B248: #	out( B253 ) &lt;- in( B36 )  Freq: 9.9912e-06
1200     -- 	// exception oop; no code emitted, #@CreateException
1200 +  spill R10 -&gt; R11	# spill size = 64
1204 +  j  B253	#@branch

1208    B249: #	out( B250 ) &lt;- in( B49 )  Freq: 7.93449e-05
1208     -- 	// exception oop; no code emitted, #@CreateException

1208    B250: #	out( B253 ) &lt;- in( B249 B242 )  Freq: 7.93529e-05
1208 +  spill R10 -&gt; R11	# spill size = 64
120c +  j  B253	#@branch

1210    B251: #	out( B252 ) &lt;- in( B68 )  Freq: 7.93425e-05
1210     -- 	// exception oop; no code emitted, #@CreateException

1210    B252: #	out( B253 ) &lt;- in( B251 B241 )  Freq: 7.93505e-05
1210 +  spill R10 -&gt; R11	# spill size = 64

1214    B253: #	out( N2499 ) &lt;- in( B248 B247 B246 B245 B250 B252 B244 )  Freq: 0.000208587
1214    # pop frame 128
	add  sp, sp, #128
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
1220 +  j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='316'>
----------------------- MetaData before Compile_id = 316 ------------------------
{method}
 - this oop:          0x00000040962eecc0
 - method holder:     &apos;java/lang/ThreadLocal$ThreadLocalMap&apos;
 - constants:         0x00000040962ee148 constant pool [142] {0x00000040962ee148} for &apos;java/lang/ThreadLocal$ThreadLocalMap&apos; cache=0x00000040962ef9e0
 - access:            0x81000002  private 
 - name:              &apos;getEntry&apos;
 - signature:         &apos;(Ljava/lang/ThreadLocal;)Ljava/lang/ThreadLocal$ThreadLocalMap$Entry;&apos;
 - max stack:         5
 - max locals:        4
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824bb30: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c5076c0
 - code size:         42
 - code start:        0x00000040962eec58
 - code end (excl):   0x00000040962eec82
 - method data:       0x0000004096481668
 - checked ex length: 0
 - linenumber start:  0x00000040962eec82
 - localvar length:   4
 - localvar start:    0x00000040962eec8c
 - compiled code: nmethod  10031  179       3       java.lang.ThreadLocal$ThreadLocalMap::getEntry (42 bytes)

------------------------ OptoAssembly for Compile_id = 316 -----------------------
#
#  java/lang/ThreadLocal$ThreadLocalMap$Entry * ( java/lang/ThreadLocal$ThreadLocalMap:NotNull *, java/lang/ThreadLocal * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/ThreadLocal$ThreadLocalMap:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/ThreadLocal *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N105: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B9 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap.table
040 +   spill R11 -&gt; R31	# spill size = 64
044 +   decode_heap_oop  R7, R7	#@decodeHeapOop
048     lw  R28, [R12, #12]	# int, #@loadI ! Field: java/lang/ThreadLocal.threadLocalHashCode (constant)
04c     NullCheck R12

04c     B2: #	out( B10 B3 ) &lt;- in( B1 )  Freq: 0.999999
04c     lwu  R30, [R7, #12]	# range, #@loadRange
050     NullCheck R7

050     B3: #	out( B7 B4 ) &lt;- in( B2 )  Freq: 0.999998
050 +   addiw  R29, R30, #-1	#@addI_reg_imm
054 +   andr  R8, R28, R29	#@andI_reg_reg
058 +   addw  R28, R8, zr	#@convI2L_reg_reg
05c +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
060 +   add R28, R7, R28	# ptr, #@addP_reg_reg
064 +   bleu  R30, zr, B7	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

068     B4: #	out( B11 B5 ) &lt;- in( B3 )  Freq: 0.999997
068 +   lwu  R28, [R28, #16]	# loadN, compressed ptr, #@loadN
06c +   decode_heap_oop  R10, R28	#@decodeHeapOop
070     lwu  R7, [R10, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
074     NullCheck R10

074     B5: #	out( B8 B6 ) &lt;- in( B4 )  Freq: 0.999996
074 +   decode_heap_oop  R7, R7	#@decodeHeapOop
078     
078 +   bne  R7, R12, B8	#@cmpP_branch  P=0.000001 C=-1.000000

07c     B6: #	out( N105 ) &lt;- in( B5 )  Freq: 0.999995
07c     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
094 +   ret	// return register, #@Ret

098     B7: #	out( N105 ) &lt;- in( B3 )  Freq: 9.99998e-07
098 +   li R11, #-28	# int, #@loadConI
09c     spill R31 -&gt; [sp, #0]	# spill size = 64
0a0 +   spill R12 -&gt; [sp, #8]	# spill size = 64
0a4 +   spill R7 -&gt; [sp, #16]	# spill size = 64
0a8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:18 (line 435) L[0]=sp + #0 L[1]=sp + #8 L[2]=R8 L[3]=_ STK[0]=sp + #16 STK[1]=R8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=172/0xac}
0ac     #@ShouldNotReachHere

0b8     B8: #	out( N105 ) &lt;- in( B5 )  Freq: 9.99996e-07
0b8 +   li R11, #-187	# int, #@loadConI
0bc     spill R31 -&gt; [sp, #0]	# spill size = 64
0c0 +   spill R12 -&gt; [sp, #8]	# spill size = 64
0c4 +   spill R10 -&gt; [sp, #16]	# spill size = 64
0c8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:29 (line 436) L[0]=sp + #0 L[1]=sp + #8 L[2]=R8 L[3]=sp + #16 STK[0]=#0
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=204/0xcc}
0cc     #@ShouldNotReachHere

0d8     B9: #	out( N105 ) &lt;- in( B1 )  Freq: 1.01328e-06
0d8 +   li R11, #-10	# int, #@loadConI
0dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:1 (line 434) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # OopMap {off=224/0xe0}
0e0     #@ShouldNotReachHere

0ec     B10: #	out( N105 ) &lt;- in( B2 )  Freq: 1.01328e-06
0ec +   li R11, #-10	# int, #@loadConI
0f0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:8 (line 434) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=244/0xf4}
0f4     #@ShouldNotReachHere

100     B11: #	out( N105 ) &lt;- in( B4 )  Freq: 4.76836e-07
100 +   li R11, #-187	# int, #@loadConI
104     spill R31 -&gt; [sp, #0]	# spill size = 64
108 +   spill R12 -&gt; [sp, #8]	# spill size = 64
10c +   spill R10 -&gt; [sp, #24]	# spill size = 64
110     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:21 (line 436) L[0]=sp + #0 L[1]=sp + #8 L[2]=R8 L[3]=sp + #24 STK[0]=sp + #24
        # OopMap {[0]=Oop [8]=Oop [24]=Oop off=276/0x114}
114 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='317'>
----------------------- MetaData before Compile_id = 317 ------------------------
{method}
 - this oop:          0x0000004096210c78
 - method holder:     &apos;java/lang/ThreadLocal&apos;
 - constants:         0x0000004096210350 constant pool [141] {0x0000004096210350} for &apos;java/lang/ThreadLocal&apos; cache=0x0000004096211498
 - access:            0x81000001  public 
 - name:              &apos;get&apos;
 - signature:         &apos;()Ljava/lang/Object;&apos;
 - max stack:         3
 - max locals:        5
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      10
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4f9ac0
 - code size:         38
 - code start:        0x0000004096210c00
 - code end (excl):   0x0000004096210c26
 - method data:       0x0000004096481408
 - checked ex length: 0
 - linenumber start:  0x0000004096210c26
 - localvar length:   5
 - localvar start:    0x0000004096210c38
 - compiled code: nmethod  10066  147       3       java.lang.ThreadLocal::get (38 bytes)

------------------------ OptoAssembly for Compile_id = 317 -----------------------
#
#  java/lang/Object * ( java/lang/ThreadLocal:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/ThreadLocal:NotNull *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N117: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B10 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c      -- 	// R23=Thread::current(), empty, #@tlsLoadP
03c     ld  R7, [R23, #712]	# ptr, #@loadP
040 +   ld  R7, [R7]	# ptr, #@loadP
044 +   lwu  R28, [R7, #68]	# loadN, compressed ptr, #@loadN ! Field: java/lang/Thread.threadLocals
048 +   spill R11 -&gt; R10	# spill size = 64
04c +   decode_heap_oop  R7, R28	#@decodeHeapOop
050     lwu  R28, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap.table
054     NullCheck R7

054     B2: #	out( B9 B3 ) &lt;- in( B1 )  Freq: 1
054 +   decode_heap_oop  R30, R28	#@decodeHeapOop
058     lwu  R29, [R30, #12]	# range, #@loadRange
05c     NullCheck R30

05c     B3: #	out( B7 B4 ) &lt;- in( B2 )  Freq: 0.999999
05c +   lw  R28, [R11, #12]	# int, #@loadI ! Field: java/lang/ThreadLocal.threadLocalHashCode (constant)
060 +   addiw  R31, R29, #-1	#@addI_reg_imm
064 +   andr  R31, R28, R31	#@andI_reg_reg
068 +   addw  R28, R31, zr	#@convI2L_reg_reg
06c +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
070 +   add R28, R30, R28	# ptr, #@addP_reg_reg
074 +   bleu  R29, zr, B7	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

078     B4: #	out( B11 B5 ) &lt;- in( B3 )  Freq: 0.999997
078 +   lwu  R28, [R28, #16]	# loadN, compressed ptr, #@loadN
07c +   decode_heap_oop  R8, R28	#@decodeHeapOop
080     lwu  R29, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
084     NullCheck R8

084     B5: #	out( B8 B6 ) &lt;- in( B4 )  Freq: 0.999997
084 +   decode_heap_oop  R28, R29	#@decodeHeapOop
088     
088 +   bne  R28, R11, B8	#@cmpP_branch  P=0.000001 C=-1.000000

08c     B6: #	out( N117 ) &lt;- in( B5 )  Freq: 0.999996
08c +   lwu  R7, [R8, #28]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap$Entry.value
090 +   decode_heap_oop  R10, R7	#@decodeHeapOop
094     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0ac +   ret	// return register, #@Ret

0b0     B7: #	out( N117 ) &lt;- in( B3 )  Freq: 9.99999e-07
0b0 +   li R11, #-28	# int, #@loadConI
0b4     spill R7 -&gt; [sp, #0]	# spill size = 64
0b8 +   spill R10 -&gt; [sp, #8]	# spill size = 64
0bc +   spill R30 -&gt; [sp, #24]	# spill size = 64
0c0 +   spill R31 -&gt; [sp, #20]	# spill size = 32
0c4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:18 (line 435) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #20 L[3]=_ STK[0]=sp + #24 STK[1]=sp + #20
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # OopMap {[0]=Oop [8]=Oop [24]=Oop off=200/0xc8}
0c8     #@ShouldNotReachHere

0d4     B8: #	out( N117 ) &lt;- in( B5 )  Freq: 9.99997e-07
0d4 +   li R11, #-187	# int, #@loadConI
0d8     spill R7 -&gt; [sp, #8]	# spill size = 64
0dc +   spill R10 -&gt; [sp, #16]	# spill size = 64
0e0 +   spill R31 -&gt; [sp, #24]	# spill size = 32
0e4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:29 (line 436) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #24 L[3]=R8 STK[0]=#0
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=232/0xe8}
0e8     #@ShouldNotReachHere

0f4     B9: #	out( N117 ) &lt;- in( B2 )  Freq: 1.01328e-06
0f4 +   li R11, #-10	# int, #@loadConI
0f8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:8 (line 434) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # OopMap {off=252/0xfc}
0fc     #@ShouldNotReachHere

108     B10: #	out( N117 ) &lt;- in( B1 )  Freq: 4.76837e-07
108 +   li R11, #-187	# int, #@loadConI
10c     spill R10 -&gt; R8	# spill size = 64
110 +   spill R7 -&gt; [sp, #8]	# spill size = 64
114     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal::get @ bci:11 (line 164) L[0]=R8 L[1]=_ L[2]=sp + #8 L[3]=_ L[4]=_ STK[0]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=280/0x118}
118     #@ShouldNotReachHere

124     B11: #	out( N117 ) &lt;- in( B4 )  Freq: 4.76836e-07
124 +   li R11, #-187	# int, #@loadConI
128     spill R7 -&gt; [sp, #8]	# spill size = 64
12c +   spill R10 -&gt; [sp, #16]	# spill size = 64
130 +   spill R31 -&gt; [sp, #24]	# spill size = 32
134     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:21 (line 436) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #24 L[3]=R8 STK[0]=R8
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=312/0x138}
138 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='318'>
----------------------- MetaData before Compile_id = 318 ------------------------
{method}
 - this oop:          0x0000004096550570
 - method holder:     &apos;java/nio/file/FileTreeIterator&apos;
 - constants:         0x000000409654fe20 constant pool [128] {0x000000409654fe20} for &apos;java/nio/file/FileTreeIterator&apos; cache=0x0000004096550a20
 - access:            0xc1000002  private 
 - name:              &apos;fetchNextIfNeeded&apos;
 - signature:         &apos;()V&apos;
 - max stack:         4
 - max locals:        3
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c501b00
 - code size:         65
 - code start:        0x00000040965504f8
 - code end (excl):   0x0000004096550539
 - method data:       0x0000004096484b08
 - checked ex length: 0
 - linenumber start:  0x0000004096550539
 - localvar length:   3
 - localvar start:    0x000000409655054a
 - compiled code: nmethod  11607  169       3       java.nio.file.FileTreeIterator::fetchNextIfNeeded (65 bytes)

------------------------ OptoAssembly for Compile_id = 318 -----------------------
#
#  void ( java/nio/file/FileTreeIterator:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/nio/file/FileTreeIterator:NotNull *
# -- Old sp -- Framesize: 176 --
#r263 sp+172: in_preserve
#r262 sp+168: return address
#r261 sp+164: in_preserve
#r260 sp+160: saved fp register
#r259 sp+156: Fixed slot 3
#r258 sp+152: Fixed slot 2
#r257 sp+148: Fixed slot 1
#r256 sp+144: Fixed slot 0
#r299 sp+140: spill
#r298 sp+136: spill
#r297 sp+132: spill
#r296 sp+128: spill
#r295 sp+124: spill
#r294 sp+120: spill
#r293 sp+116: spill
#r292 sp+112: spill
#r291 sp+108: spill
#r290 sp+104: spill
#r289 sp+100: spill
#r288 sp+96: spill
#r287 sp+92: spill
#r286 sp+88: spill
#r285 sp+84: spill
#r284 sp+80: spill
#r283 sp+76: spill
#r282 sp+72: spill
#r281 sp+68: spill
#r280 sp+64: spill
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
0000    N6590: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0000    # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

0020    B1: #	out( B162 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0020    # stack bang size=176
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #176
	
003c    lwu  R28, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.next
0040    spill R11 -&gt; R9	# spill size = 64
0044 +  bne   R28, zr, B162	#@cmpP_narrowOop_imm0_branch  P=0.500279 C=5375.000000

0048    B2: #	out( B410 B3 ) &lt;- in( B1 )  Freq: 0.499721
0048 +  lwu  R7, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.walker
004c +  decode_heap_oop  R18, R7	#@decodeHeapOop
0050    lwu  R28, [R18, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker.stack
0054    NullCheck R18

0054    B3: #	out( B411 B4 ) &lt;- in( B2 )  Freq: 0.49972
0054 +  decode_heap_oop  R7, R28	#@decodeHeapOop
0058    lwu  R28, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/ArrayDeque.elements
005c    NullCheck R7

005c    B4: #	out( B412 B5 ) &lt;- in( B3 )  Freq: 0.49972
005c +  lw  R30, [R7, #12]	# int, #@loadI ! Field: java/util/ArrayDeque.head
0060 +  addw  R7, R30, zr	#@convI2L_reg_reg
0064 +  decode_heap_oop  R8, R28	#@decodeHeapOop
0068 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
006c    lwu  R29, [R8, #12]	# range, #@loadRange
0070    NullCheck R8

0070    B5: #	out( B325 B6 ) &lt;- in( B4 )  Freq: 0.499719
0070 +  add R7, R8, R7	# ptr, #@addP_reg_reg
0074 +  far_bgeu R30, R29, B325	#@far_cmpU_branch  P=0.000001 C=-1.000000

007c    B6: #	out( B162 B7 ) &lt;- in( B5 )  Freq: 0.499719
007c +  lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN
0080 +  decode_heap_oop  R24, R7	#@decodeHeapOop
0084 +  beq   R24, zr, B162	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

0088    B7: #	out( B399 B8 ) &lt;- in( B6 )  Freq: 0.499219
0088 +  lwu  R28, [R24, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
008c +  mv  R7, narrowklass: precise klass java/nio/file/FileTreeWalker$DirectoryNode: 0x00000040d83de560:Constant:exact *	# compressed klass ptr, #@loadConNKlass
009c +  far_bne  R28, R7, B399	#@far_cmpN_branch  P=0.000000 C=-1.000000

00a4    B8: #	out( B356 B9 ) &lt;- in( B7 )  Freq: 0.499219
00a4 +  # checkcastPP of R24, #@checkCastPP
00a4    lwu  R28, [R24, #28]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.iterator
00a8 +  lbu  R8, [R24, #12]	# byte, #@loadUB ! Field: java/nio/file/FileTreeWalker$DirectoryNode.skipped
00ac +  decode_heap_oop  R19, R28	#@decodeHeapOop
00b0 +  far_bne  R8, zr, B356	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2774.000000

00b8    B9: #	out( B413 B10 ) &lt;- in( B8 )  Freq: 0.499219
00b8    lwu  R7, [R19, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
00bc    NullCheck R19

00bc    B10: #	out( B326 B11 ) &lt;- in( B9 )  Freq: 0.499218
00bc +  mv  R29, narrowklass: precise klass sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator: 0x00000040d82bf9a0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
00cc +  far_bne  R7, R29, B326	#@far_cmpN_branch  P=0.000001 C=-1.000000

00d4    B11: #	out( B327 B12 ) &lt;- in( B10 )  Freq: 0.499218
00d4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
00d4    ld  R7, [R23, #712]	# ptr, #@loadP
00d8 +  ld  R20, [R7]	# ptr, #@loadP
00dc +  add R29, sp, #144	# box lock
00e0 +  # checkcastPP of R19, #@checkCastPP
00e0    fastlock R19,R29	! kills R7,R28, #@cmpFastLock
0174 +  far_bne RFLAGS, zr, B327	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

017c    B12: #	out( B357 B13 ) &lt;- in( B327 B11 )  Freq: 0.499218
017c +  #@membar_acquire_lock (elided)
017c +  lwu  R28, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
0180 +  lwu  R7, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
0184 +  decode_heap_oop  R8, R28	#@decodeHeapOop
0188 +  lbu  R29, [R19, #12]	# byte, #@loadUB ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.atEof
018c +  decode_heap_oop  R7, R7	#@decodeHeapOop
0190 +  far_bne   R8, zr, B357	#@far_cmpP_imm0_branch  P=0.000000 C=2778.000000

0198    B13: #	out( B358 B14 ) &lt;- in( B12 )  Freq: 0.499218
0198 +  far_bne  R29, zr, B358	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2778.000000

01a0    B14: #	out( B414 B15 ) &lt;- in( B13 )  Freq: 0.499217
01a0    lwu  R28, [R7, #32]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream.streamLock
01a4    NullCheck R7

01a4    B15: #	out( B415 B16 ) &lt;- in( B14 )  Freq: 0.499217
01a4 +  decode_heap_oop  R7, R28	#@decodeHeapOop
01a8    lwu  R7, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock.readerLock
01ac    NullCheck R7

01ac    B16: #	out( B416 B17 ) &lt;- in( B15 )  Freq: 0.499216
01ac +  decode_heap_oop  R8, R7	#@decodeHeapOop
01b0    # checkcastPP of R8, #@checkCastPP
01b0    lwu  R28, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
01b4    NullCheck R8

01b4    B17: #	out( B328 B18 ) &lt;- in( B16 )  Freq: 0.499216
01b4 +  mv  R7, narrowklass: precise klass java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock: 0x00000040d836c420:Constant:exact *	# compressed klass ptr, #@loadConNKlass
01c4 +  far_bne  R28, R7, B328	#@far_cmpN_branch  P=0.000001 C=-1.000000

01cc    B18: #	out( B417 B19 ) &lt;- in( B17 )  Freq: 0.499215
01cc +  # checkcastPP of R8, #@checkCastPP
01cc    lwu  R28, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock.sync
01d0 +  decode_heap_oop  R21, R28	#@decodeHeapOop
01d4    lw  R31, [R21, #16]	# int, #@loadI ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.state
01d8    NullCheck R21

01d8    B19: #	out( B371 B20 ) &lt;- in( B18 )  Freq: 0.499215
01d8 +  #@membar_acquire
	fence ir iorw
01dc +  li R28, #65535	# int, #@loadConI
01e4 +  andr  R8, R31, R28	#@andI_reg_reg
01e8 +  far_bne  R8, zr, B371	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2964.000000

01f0    B20: #	out( B329 B21 ) &lt;- in( B19 )  Freq: 0.499215
01f0 +  lwu  R7, [R21, #20]	# loadN, compressed ptr, #@loadN ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.head
01f4 +  #@membar_acquire
	fence ir iorw
01f8 +  decode_heap_oop  R8, R7	#@decodeHeapOop
01fc +  srliw  R28, R31, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
0200 +  far_bne   R8, zr, B329	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0208    B21: #	out( B372 B22 ) &lt;- in( B20 )  Freq: 0.499214
0208 +  li R29, #65535	# int, #@loadConI
0210 +  far_bge  R28, R29, B372	#@far_cmpI_branch  P=0.000000 C=2964.000000

0218    B22: #	out( B373 B23 ) &lt;- in( B21 )  Freq: 0.499214
0218 +  #@membar_release
	fence iorw ow
021c +  li R29, #65536	# int, #@loadConI
0220 +  addw  R29, R31, R29	#@addI_reg_reg
0224 +  addi  R7, R21, #16	# ptr, #@addP_reg_imm
0228    
0228 +  cmpxchg_acq [R7], R31, R29	# (int) if [R7] == R31 then [R7] &lt;-- R29
	mv R8, R8 == R31	# R8 &lt;-- (R8 == R31 ? 1 : 0), #@compareAndSwapIAcq
0244    
0244 +  #@membar_acquire
	fence ir iorw
0248 +  far_beq  R8, zr, B373	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2964.000000

0250    B23: #	out( B359 B24 ) &lt;- in( B22 )  Freq: 0.499214
0250 +  far_bne  R28, zr, B359	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2964.000000

0258    B24: #	out( B228 B25 ) &lt;- in( B23 )  Freq: 0.499213
0258 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0258    lb  R7, [R23, #56]	# byte, #@loadB
025c +  far_bne  R7, zr, B228	#@far_cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0264    B25: #	out( B27 B26 ) &lt;- in( B360 B230 B228 B24 )  Freq: 0.499213
0264 +  mv  R7, R21	# ptr -&gt; long, #@castP2X
0268 +  mv  R28, R20	# ptr -&gt; long, #@castP2X
026c +  xorr  R29, R28, R7	#@xorL_reg_reg
0270 +  encode_heap_oop  R28, R20	#@encodeHeapOop
0274 +  srli  R29, R29, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0278 +  sw  R28, [R21, #40]	# compressed ptr, #@storeN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
027c +  beq  R29, zr, B27	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0280    B26: #	out( B237 B27 ) &lt;- in( B25 )  Freq: 0.498714
0280 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0284 +  mv  R29, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
0290 +  add R10, R29, R7	# ptr, #@addP_reg_reg
0294 +  lb  R29, [R10]	# byte, #@loadB
0298 +  li R30, #4	# int, #@loadConI
029c +  far_bne  R29, R30, B237	#@far_cmpI_branch  P=0.001000 C=-1.000000

02a4    B27: #	out( B28 ) &lt;- in( B239 B240 B237 B26 B25 )  Freq: 0.499213
02a4 +  li R7, #1	# int, #@loadConI
02a8 +  sw  R7, [R21, #28]	# int, #@storeI ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReaderHoldCount

02ac    B28: #	out( B404 B29 ) &lt;- in( B27 B180 ) Loop( B28-B180 inner ) Freq: 0.525792
02ac +  lwu  R7, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
02b0 +  decode_heap_oop  R7, R7	#@decodeHeapOop
02b4    lbu  R8, [R7, #12]	# byte, #@loadUB ! Field: volatile sun/nio/fs/UnixDirectoryStream.isClosed
02b8    NullCheck R7

02b8    B29: #	out( B350 B30 ) &lt;- in( B28 )  Freq: 0.525792
02b8 +  #@membar_acquire
	fence ir iorw
02bc +  lwu  R29, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
02c0 +  decode_heap_oop  R7, R29	#@decodeHeapOop
02c4 +  far_bne  R8, zr, B350	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2964.000000

02cc    B30: #	out( B405 B31 ) &lt;- in( B29 )  Freq: 0.525792
02cc    ld  R11, [R7, #16]	# int, #@loadL ! Field: sun/nio/fs/UnixDirectoryStream.dp
02d0    NullCheck R7

02d0    B31: #	out( B403 B32 ) &lt;- in( B30 )  Freq: 0.525791
02d0 +  spill R28 -&gt; [sp, #40]	# spill size = 32
02d4 +  spill R20 -&gt; [sp, #32]	# spill size = 64
02d8 +  spill R19 -&gt; [sp, #0]	# spill size = 64
02dc +  spill R24 -&gt; [sp, #24]	# spill size = 64
02e0 +  spill R18 -&gt; [sp, #16]	# spill size = 64
02e4 +  spill R9 -&gt; [sp, #8]	# spill size = 64
02e8    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect sun.nio.fs.UnixNativeDispatcher::readdir
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:52 (line 165) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=NarrowOop off=748/0x2ec}

02ec    B32: #	out( B406 B33 ) &lt;- in( B31 )  Freq: 0.525781
        # Block is sole successor of call
02ec +  spill [sp, #0] -&gt; R28	# spill size = 64
02f0 +  lwu  R7, [R28, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
02f4 +  spill R10 -&gt; [sp, #48]	# spill size = 64
02f8 +  decode_heap_oop  R7, R7	#@decodeHeapOop
02fc    lwu  R29, [R7, #32]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream.streamLock
0300    NullCheck R7

0300    B33: #	out( B407 B34 ) &lt;- in( B32 )  Freq: 0.52578
0300 +  decode_heap_oop  R7, R29	#@decodeHeapOop
0304    lwu  R7, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock.readerLock
0308    NullCheck R7

0308    B34: #	out( B408 B35 ) &lt;- in( B33 )  Freq: 0.525779
0308 +  decode_heap_oop  R8, R7	#@decodeHeapOop
030c    # checkcastPP of R8, #@checkCastPP
030c    lwu  R29, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0310    NullCheck R8

0310    B35: #	out( B321 B36 ) &lt;- in( B34 )  Freq: 0.525779
0310 +  mv  R30, narrowklass: precise klass java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock: 0x00000040d836c420:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0320 +  far_bne  R29, R30, B321	#@far_cmpN_branch  P=0.000001 C=-1.000000

0328    B36: #	out( B409 B37 ) &lt;- in( B35 )  Freq: 0.525778
0328 +  # checkcastPP of R8, #@checkCastPP
0328    lwu  R7, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock.sync
032c +  decode_heap_oop  R12, R7	#@decodeHeapOop
0330    lwu  R29, [R12, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
0334    NullCheck R12

0334    B37: #	out( B351 B38 ) &lt;- in( B36 )  Freq: 0.525778
0334 +  decode_heap_oop  R8, R29	#@decodeHeapOop
0338 +  lw  R10, [R12, #28]	# int, #@loadI ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReaderHoldCount
033c    spill [sp, #32] -&gt; R30	# spill size = 64
0340 +  far_bne  R8, R30, B351	#@far_cmpP_branch  P=0.000000 C=2964.000000

0348    B38: #	out( B352 B39 ) &lt;- in( B37 )  Freq: 0.525778
0348 +  li R7, #1	# int, #@loadConI
034c +  far_bne  R10, R7, B352	#@far_cmpI_branch  P=0.000000 C=2964.000000

0354    B39: #	out( B225 B40 ) &lt;- in( B38 )  Freq: 0.525777
0354 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0354    lb  R7, [R23, #56]	# byte, #@loadB
0358 +  far_bne  R7, zr, B225	#@far_cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0360    B40: #	out( B355 B41 ) &lt;- in( B354 B227 B225 B39 )  Freq: 0.525777
0360 +  lw  R29, [R12, #16]	# int, #@loadI ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.state
0364 +  sw  rheapbase, [R12, #40]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
0368 +  #@membar_acquire
	fence ir iorw
036c +  #@membar_release
	fence iorw ow
036c +  li R10, #-65536	# int, #@loadConI
0370 +  addw  R31, R29, R10	#@addI_reg_reg
0374 +  addi  R7, R12, #16	# ptr, #@addP_reg_imm
0378    
0378 +  cmpxchg_acq [R7], R29, R31	# (int) if [R7] == R29 then [R7] &lt;-- R31
	mv R8, R8 == R29	# R8 &lt;-- (R8 == R29 ? 1 : 0), #@compareAndSwapIAcq
0394    
0394 +  #@membar_acquire
	fence ir iorw
0398 +  far_beq  R8, zr, B355	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2964.000000

03a0    B41: #	out( B353 B42 ) &lt;- in( B40 )  Freq: 0.525777
03a0 +  li R7, #65536	# int, #@loadConI
03a4 +  far_bne  R29, R7, B353	#@far_cmpI_branch  P=0.000000 C=2964.000000

03ac    B42: #	out( B322 B43 ) &lt;- in( B41 )  Freq: 0.525777
03ac +  lwu  R7, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.head
03b0 +  #@membar_acquire
	fence ir iorw
03b4 +  decode_heap_oop  R8, R7	#@decodeHeapOop
03b8 +  far_bne   R8, zr, B322	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

03c0    B43: #	out( B508 B44 ) &lt;- in( B42 )  Freq: 0.525776
03c0 +  spill R30 -&gt; [sp, #32]	# spill size = 64
03c4 +  spill R28 -&gt; [sp, #0]	# spill size = 64
03c8 +  mv  R11, NULL	# NULL ptr, #@loadConP0
03cc    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.util.concurrent.locks.AbstractQueuedSynchronizer::signalNext
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:12 (line 1095) L[0]=_ L[1]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #0 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=NarrowOop [48]=Oop off=976/0x3d0}

03d0    B44: #	out( B194 B45 ) &lt;- in( B43 )  Freq: 0.525766
        # Block is sole successor of call
03d0 +  spill [sp, #48] -&gt; R20	# spill size = 64
03d4 +  beq   R20, zr, B194	#@cmpP_imm0_branch  P=0.025965 C=2927.000000

03d8    B45: #	out( B324 B46 ) &lt;- in( B44 )  Freq: 0.512114
03d8 +  lwu  R9, [R20, #12]	# range, #@loadRange
03dc +  li R29, #1	# int, #@loadConI
03e0 +  addi  R30, R20, #16	# ptr, #@addP_reg_imm
03e4    spill [sp, #0] -&gt; R19	# spill size = 64
03e8 +  lwu  R28, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
03ec +  far_bleu R9, R29, B324	#@far_cmpU_branch  P=0.000001 C=-1.000000

03f4    B46: #	out( B163 B47 ) &lt;- in( B45 )  Freq: 0.512114
03f4 +  lb  R31, [R30]	# byte, #@loadB
03f8 +  li R7, #46	# int, #@loadConI
03fc +  decode_heap_oop  R10, R28	#@decodeHeapOop
0400 +  beq  R31, R7, B163	#@cmpI_branch  P=0.051880 C=2872.000000

0404    B47: #	out( B418 B48 ) &lt;- in( B46 )  Freq: 0.485545
0404    lwu  R7, [R10, #24]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream.dir
0408    NullCheck R10

0408    B48: #	out( B419 B49 ) &lt;- in( B47 )  Freq: 0.485545
0408 +  decode_heap_oop  R22, R7	#@decodeHeapOop
040c    lwu  R28, [R22, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
0410    NullCheck R22

0410    B49: #	out( B364 B50 ) &lt;- in( B48 )  Freq: 0.485544
0410 +  lwu  R7, [R22, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
0414 +  decode_heap_oop  R28, R28	#@decodeHeapOop
0418 +  decode_heap_oop  R8, R7	#@decodeHeapOop
041c +  far_bleu  R9, zr, B364	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000000 C=2692.000000

0424    B50: #	out( B375 B51 ) &lt;- in( B49 )  Freq: 0.485544
0424 +  li R7, #47	# int, #@loadConI
0428 +  far_beq  R31, R7, B375	#@far_cmpI_branch  P=0.000000 C=2692.000000

0430    B51: #	out( B420 B52 ) &lt;- in( B50 )  Freq: 0.485544
0430    lwu  R18, [R28, #12]	# range, #@loadRange
0434    NullCheck R28

0434    B52: #	out( B365 B53 ) &lt;- in( B51 )  Freq: 0.485543
0434 +  addw  R29, R9, R18	#@addI_reg_reg
0438 +  addiw  R21, R29, #1	#@addI_reg_imm
043c +  li R7, #1048576	# int, #@loadConI
0440 +  far_bleu  R18, zr, B365	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000000 C=2692.000000

0448    B53: #	out( B376 B54 ) &lt;- in( B52 )  Freq: 0.485543
0448 +  li R31, #1	# int, #@loadConI
044c +  far_beq  R18, R31, B376	#@far_cmpI_branch  P=0.000000 C=2692.000000

0454    B54: #	out( B331 B55 ) &lt;- in( B53 )  Freq: 0.485543
0454 +  addw  R31, R9, zr	#@convI2L_reg_reg
0458 +  addw  R26, R18, zr	#@convI2L_reg_reg
045c +  far_bgtu R21, R7, B331	#@far_cmpU_branch  P=0.000001 C=-1.000000

0464    B55: #	out( B56 ) &lt;- in( B54 )  Freq: 0.485542
0464 +  add  R29, R26, R31	#@addL_reg_reg
0468 +  addi  R29, R29, #1	#@addL_reg_imm

046c    B56: #	out( B336 B57 ) &lt;- in( B55 B331 )  Freq: 0.485543
046c +  addi  R8, R29, #23	#@addL_reg_imm
0470 +  far_bltu R21, R18, B336	#@far_cmpU_branch  P=0.000001 C=-1.000000

0478    B57: #	out( B270 B58 ) &lt;- in( B56 )  Freq: 0.485542
0478 +  andi  R29, R8, #-8	#@andL_reg_imm
047c    spill R29 -&gt; [sp, #104]	# spill size = 64
0480 +  far_bgtu R21, R7, B270	#@far_cmpU_branch  P=0.000001 C=-1.000000

0488    B58: #	out( B270 B59 ) &lt;- in( B57 )  Freq: 0.485542
0488 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0488    ld  R24, [R23, #288]	# ptr, #@loadP
048c +  add R7, R24, R29	# ptr, #@addP_reg_reg
0490 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0490    ld  R29, [R23, #304]	# ptr, #@loadP
0494 +  far_bgeu  R7, R29, B270	#@far_cmpP_branch  P=0.000100 C=-1.000000

049c    B59: #	out( B60 ) &lt;- in( B58 )  Freq: 0.485493
049c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
049c    sd  R7, [R23, #288]	# ptr, #@storeP
04a0 +  li R7, #1	# long, #@loadConL
04a4 +  sd  R7, [R24]	# long, #@storeL
04a8 +  mv  R7, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
04b8 +  sw  R7, [R24, #8]	# compressed klass ptr, #@storeNKlass
04bc +  sw  R21, [R24, #12]	# int, #@storeI

04c0    B60: #	out( B337 B61 ) &lt;- in( B271 B59 )  Freq: 0.485542
04c0    
04c0 +  srli  R7, R8, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
04c4 +  # checkcastPP of R24, #@checkCastPP
04c4    addi  R11, R24, #16	# ptr, #@addP_reg_imm
04c8 +  far_bleu  R18, zr, B337	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

04d0    B61: #	out( B246 B62 ) &lt;- in( B60 )  Freq: 0.485542
04d0 +  addi  R10, R28, #16	# ptr, #@addP_reg_imm
04d4 +  far_blt  R18, R21, B246	#@far_cmpI_branch  P=0.001000 C=-1.000000

04dc    B62: #	out( B63 ) &lt;- in( B61 )  Freq: 0.485056
04dc +  spill R21 -&gt; R25	# spill size = 32
04e0 +  spill [sp, #104] -&gt; R7	# spill size = 64
04e4 +  spill R24 -&gt; R8	# spill size = 64
04e8 +  spill R18 -&gt; R21	# spill size = 32
04ec +  addi  R7, R7, #-16	#@addL_reg_imm
04f0    spill R31 -&gt; R24	# spill size = 64
04f4 +  spill R30 -&gt; R18	# spill size = 64
04f8    
04f8    
04f8    
04f8    
04f8 +  srli  R12, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
04fc    CALL, runtime leaf nofp 0x000000401396d840	#@CallLeafNoFPDirect jlong_disjoint_arraycopy
        No JVM State Info
        # 
0500 +  spill R18 -&gt; R30	# spill size = 64
0504 +  spill R21 -&gt; R18	# spill size = 32
0508 +  spill R24 -&gt; R31	# spill size = 64
050c +  spill R25 -&gt; R21	# spill size = 32
0510 +  spill R8 -&gt; R24	# spill size = 64

0514    B63: #	out( B332 B64 ) &lt;- in( B246 B62 B337 )  Freq: 0.485542
0514 +  MEMBAR-store-store	#@membar_storestore
0518 +  add R7, R24, R26	# ptr, #@addP_reg_reg
051c +  addiw  R8, R18, #1	#@addI_reg_imm
0520 +  far_bgeu R18, R21, B332	#@far_cmpU_branch  P=0.000001 C=-1.000000

0528    B64: #	out( B338 B65 ) &lt;- in( B63 )  Freq: 0.485542
0528 +  li R29, #47	# int, #@loadConI
052c +  sb  R29, [R7, #16]	# byte, #@storeB
0530 +  far_blt  R8, zr, B338	#@far_cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0538    B65: #	out( B67 B66 ) &lt;- in( B64 )  Freq: 0.485541
0538 +  bleu  R9, zr, B67	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

053c    B66: #	out( B67 ) &lt;- in( B65 )  Freq: 0.485541
053c +  spill R31 -&gt; R12	# spill size = 64
0540 +  addi  R11, R7, #17	# ptr, #@addP_reg_imm
0544    spill R30 -&gt; R10	# spill size = 64
0548 +  CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

054c    B67: #	out( B272 B68 ) &lt;- in( B66 B65 )  Freq: 0.485541
054c    
054c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
054c    ld  R18, [R23, #288]	# ptr, #@loadP
0550 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0550    ld  R7, [R23, #304]	# ptr, #@loadP
0554 +  addi  R28, R18, #32	# ptr, #@addP_reg_imm
0558 +  far_bgeu  R28, R7, B272	#@far_cmpP_branch  P=0.000100 C=-1.000000

0560    B68: #	out( B69 ) &lt;- in( B67 )  Freq: 0.485493
0560 +  li R7, #1	# long, #@loadConL
0564 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0564    sd  R28, [R23, #288]	# ptr, #@storeP
0568 +  sd  R7, [R18]	# long, #@storeL
056c +  mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d82bfa70:Constant:exact *	# compressed klass ptr, #@loadConNKlass
057c +  sw  R7, [R18, #8]	# compressed klass ptr, #@storeNKlass
0580 +  sw  zr, [R18, #12]	# int, #@storeimmI0
0584 +  sw  zr, [R18, #16]	# int, #@storeimmI0
0588 +  sd  zr, [R18, #24]	# long, #@storeimmL0

058c    B69: #	out( B421 B70 ) &lt;- in( B273 B68 )  Freq: 0.485541
058c +  encode_heap_oop  R28, R24	#@encodeHeapOop
0590 +  sw  R28, [R18, #20]	# compressed ptr, #@storeN
0594    
0594 +  lwu  R7, [R22, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
0598 +  # checkcastPP of R18, #@checkCastPP
0598    sw  R7, [R18, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixPath.fs
059c +  #@membar_release
	fence iorw ow
05a0 +  lwu  R28, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
05a4 +  decode_heap_oop  R7, R28	#@decodeHeapOop
05a8    lwu  R7, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream.filter
05ac    NullCheck R7

05ac    B70: #	out( B435 B71 ) &lt;- in( B69 )  Freq: 0.485541
05ac +  decode_heap_oop  R8, R7	#@decodeHeapOop
05b0    lwu  R28, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
05b4    NullCheck R8

05b4    B71: #	out( B339 B72 ) &lt;- in( B70 )  Freq: 0.48554
05b4 +  mv  R7, narrowklass: precise klass java/nio/file/Files$AcceptAllFilter: 0x00000040d836c4f0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
05c4 +  far_bne  R28, R7, B339	#@far_cmpN_branch  P=0.000001 C=-1.000000

05cc    B72: #	out( B73 ) &lt;- in( B71 )  Freq: 0.48554
05cc +  # checkcastPP of R18, #@checkCastPP

05cc    B73: #	out( B231 B74 ) &lt;- in( B194 B72 )  Freq: 0.499192
05cc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
05cc    lb  R28, [R23, #56]	# byte, #@loadB
05d0 +  bne  R28, zr, B231	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

05d4    B74: #	out( B77 B75 ) &lt;- in( B361 B233 B231 B73 )  Freq: 0.499192
05d4 +  mv  R7, R19	# ptr -&gt; long, #@castP2X
05d8 +  mv  R28, R18	# ptr -&gt; long, #@castP2X
05dc +  xorr  R28, R28, R7	#@xorL_reg_reg
05e0 +  encode_heap_oop  R9, R18	#@encodeHeapOop
05e4 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
05e8 +  sw  R9, [R19, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
05ec +  beq  R28, zr, B77	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

05f0    B75: #	out( B77 B76 ) &lt;- in( B74 )  Freq: 0.498692
05f0 +  beq   R18, zr, B77	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

05f4    B76: #	out( B241 B77 ) &lt;- in( B75 )  Freq: 0.498194
05f4 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
05f8 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
0604 +  add R10, R28, R7	# ptr, #@addP_reg_reg
0608 +  lb  R7, [R10]	# byte, #@loadB
060c +  li R28, #4	# int, #@loadConI
0610 +  bne  R7, R28, B241	#@cmpI_branch  P=0.001000 C=-1.000000

0614    B77: #	out( B330 B78 ) &lt;- in( B245 B76 B75 B74 )  Freq: 0.499192
0614 +  #@membar_release_lock (elided)
0614    add R29, sp, #144	# box lock
0618 +  fastunlock R19,R29	! kills R7, R28, #@cmpFastUnlock
0690 +  far_bne RFLAGS, zr, B330	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

0698    B78: #	out( B185 B79 ) &lt;- in( B330 B77 )  Freq: 0.499192
0698 +  beq   R9, zr, B185	#@cmpP_narrowOop_imm0_branch  P=0.028479 C=2774.000000

069c    B79: #	out( B340 B80 ) &lt;- in( B78 )  Freq: 0.484975
069c    add R29, sp, #144	# box lock
06a0 +  fastlock R19,R29	! kills R7,R28, #@cmpFastLock
0734 +  far_bne RFLAGS, zr, B340	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

073c    B80: #	out( B436 B81 ) &lt;- in( B340 B79 )  Freq: 0.484975
073c +  #@membar_acquire_lock (elided)
073c +  lwu  R7, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
0740 +  decode_heap_oop  R8, R7	#@decodeHeapOop
0744    lwu  R18, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0748    NullCheck R8

0748    B81: #	out( B247 B82 ) &lt;- in( B80 )  Freq: 0.484975
0748 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0748    lb  R28, [R23, #56]	# byte, #@loadB
074c +  bne  R28, zr, B247	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0750    B82: #	out( B341 B83 ) &lt;- in( B366 B249 B247 B81 )  Freq: 0.484975
0750 +  sw  rheapbase, [R19, #16]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
0754 +  #@membar_release_lock (elided)
0754    add R29, sp, #144	# box lock
0758 +  fastunlock R19,R29	! kills R28, R7, #@cmpFastUnlock
07d0 +  far_bne RFLAGS, zr, B341	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

07d8    B83: #	out( B400 B84 ) &lt;- in( B341 B82 )  Freq: 0.484975
07d8 +  mv  R14, precise klass sun/nio/fs/UnixPath: 0x00000040d82bfa70:Constant:exact *	# ptr, #@loadConP
07f0 +  mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d82bfa70:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0800 +  ld  R28, [R14, #40]	# class, #@loadKlass
0804 +  mv  R10, precise klass sun/nio/fs/BasicFileAttributesHolder: 0x00000040d01caff0:Constant:exact *	# ptr, #@loadConP
081c +  far_bne  R18, R7, B400	#@far_cmpN_branch  P=0.000000 C=-1.000000

0824    B84: #	out( B333 B85 ) &lt;- in( B83 )  Freq: 0.484975
0824 +  spill R8 -&gt; R7	# spill size = 64
0828 +  # checkcastPP of R7, #@checkCastPP
0828    far_beq  R28, R10, B333	#@far_cmpP_branch  P=0.000001 C=-1.000000

0830    B85: #	out( B334 B86 ) &lt;- in( B84 )  Freq: 0.484974
0830 +  partialSubtypeCheck R15, R14, R10 == 0	#@partialSubtypeCheckVsZero
088c +  lwu  R30, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
0890 +  spill [sp, #16] -&gt; R29	# spill size = 64
0894 +  lwu  R28, [R29, #20]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker.linkOptions
0898 +  decode_heap_oop  R30, R30	#@decodeHeapOop
089c +  far_beq RFLAGS, zr, B334	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

08a4    B86: #	out( B422 B87 ) &lt;- in( B85 )  Freq: 0.484974
08a4    lwu  R30, [R30, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileSystem.provider
08a8    NullCheck R30

08a8    B87: #	out( B335 B88 ) &lt;- in( B86 )  Freq: 0.484974
08a8 +  decode_heap_oop  R15, R28	#@decodeHeapOop
08ac +  far_beq   R30, zr, B335	#@far_cmpP_narrowOop_imm0_branch  P=0.000001 C=-1.000000

08b4    B88: #	out( B423 B89 ) &lt;- in( B87 )  Freq: 0.484973
08b4    lwu  R28, [R15, #12]	# range, #@loadRange
08b8    NullCheck R15

08b8    B89: #	out( B97 B90 ) &lt;- in( B88 )  Freq: 0.484973
08b8 +  bleu  R28, zr, B97	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.500093 C=5383.000000

08bc    B90: #	out( B363 B91 ) &lt;- in( B89 )  Freq: 0.242441
08bc +  addiw  R31, R28, #-1	#@addI_reg_imm
08c0 +  li R14, #1000	# int, #@loadConI
08c4 +  far_bgeu R31, R28, B363	#@far_cmpU_branch  P=0.000001 C=-1.000000

08cc    B91: #	out( B92 ) &lt;- in( B90 )  Freq: 0.242441
08cc +  mv  R13, narrowoop: java/nio/file/LinkOption:exact *	# compressed ptr, #@loadConN
08dc +  li R12, #0	# int, #@loadConI
08e0 +  li R9, #0	# int, #@loadConI

08e4    B92: #	out( B93 ) &lt;- in( B91 B95 ) Loop( B92-B95 ) Freq: 0.484791
08e4 +  subw  R30, R28, R12	#@subI_reg_reg
08e8    CMove R30, (R28 lt R12), R30, R9	#@cmovI_cmpI
	
08f0 +  CMove R30, (R30 gtu R14), R30, R14	#@cmovI_cmpU
	
08f8 +  addw  R31, R30, R12	#@addI_reg_reg

08fc    B93: #	out( B349 B94 ) &lt;- in( B92 B94 ) Loop( B93-B94 inner  strip mined) Freq: 0.969402
08fc +  addw  R30, R12, zr	#@convI2L_reg_reg
0900 +  slli  R30, R30, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0904 +  add R30, R15, R30	# ptr, #@addP_reg_reg
0908 +  lwu  R30, [R30, #16]	# loadN, compressed ptr, #@loadN
090c +  far_bne  R30, R13, B349	#@far_cmpN_branch  P=0.000000 C=2691.000000

0914    B94: #	out( B93 B95 ) &lt;- in( B93 )  Freq: 0.969402
0914 +  addiw  R12, R12, #1	#@addI_reg_imm
0918 +  blt  R12, R31, B93	#@cmpI_loop  P=0.499907 C=2691.000000

091c    B95: #	out( B92 B96 ) &lt;- in( B94 )  Freq: 0.484791
091c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
091c    ld  R16, [R23, #920]	# ptr, #@loadP
0920 +  lwu zr, [R16]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.Util::followLinks @ bci:61 (line 121) L[0]=_ L[1]=#0 L[2]=R15 L[3]=R28 L[4]=R12 L[5]=_
        # sun.nio.fs.UnixFileSystemProvider::getFileAttributeView @ bci:7 (line 120) L[0]=_ L[1]=_ L[2]=#Ptr0x00000040d82d3410 L[3]=_ L[4]=R7 L[5]=_
        # sun.nio.fs.LinuxFileSystemProvider::getFileAttributeView @ bci:48 (line 68) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:51 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=R29 L[1]=R7 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=R29 L[1]=R7 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=R29 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {t2=Oop x29=Oop c_rarg3=NarrowOop c_rarg5=Oop [8]=Oop [24]=Oop [32]=Oop off=2336/0x920}
0924 +  blt  R12, R28, B92	#@cmpI_branch  P=0.499907 C=2691.000000

0928    B96: #	out( B98 ) &lt;- in( B95 )  Freq: 0.24244
0928 +  j  B98	#@branch

092c    B97: #	out( B98 ) &lt;- in( B89 )  Freq: 0.242531
092c +  li R9, #1	# int, #@loadConI

0930    B98: #	out( B377 B99 ) &lt;- in( B96 B97 )  Freq: 0.484972
0930 +  mv  R28, java/lang/Class:exact *	# ptr, #@loadConP
0948 +  lw  R8, [R28, #156]	# int, #@loadI ! Field: java/lang/System.allowSecurityManager (constant)
094c +  li R31, #1	# int, #@loadConI
0950 +  far_beq  R8, R31, B377	#@far_cmpI_branch  P=0.000000 C=5568.000000

0958    B99: #	out( B378 B100 ) &lt;- in( B98 )  Freq: 0.484972
0958 +  lwu  R30, [R28, #124]	# loadN, compressed ptr, #@loadN ! Field: volatile java/lang/System.security
095c +  #@membar_acquire
	fence ir iorw
0960 +  decode_heap_oop  R8, R30	#@decodeHeapOop
0964 +  far_bne   R8, zr, B378	#@far_cmpP_imm0_branch  P=0.000000 C=5385.000000

096c    B100: #	out( B274 B101 ) &lt;- in( B99 )  Freq: 0.484971
096c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
096c    ld  R10, [R23, #288]	# ptr, #@loadP
0970 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0970    ld  R28, [R23, #304]	# ptr, #@loadP
0974 +  addi  R30, R10, #128	# ptr, #@addP_reg_imm
0978 +  bgeu  R30, R28, B274	#@cmpP_branch  P=0.000100 C=-1.000000

097c    B101: #	out( B102 ) &lt;- in( B100 )  Freq: 0.484923
097c +  li R28, #1	# long, #@loadConL
0980 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0980    sd  R30, [R23, #288]	# ptr, #@storeP
0984 +  sd  R28, [R10]	# long, #@storeL
0988 +  mv  R28, narrowklass: precise klass sun/nio/fs/UnixFileAttributes: 0x00000040d819cfa0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0998 +  sw  R28, [R10, #8]	# compressed klass ptr, #@storeNKlass
099c +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
09a0 +  sw  zr, [R10, #12]	# int, #@storeimmI0
09a4 +  ClearArray #14, R28	#@clearArray_imm_reg

09dc    B102: #	out( B268 B103 ) &lt;- in( B275 B101 )  Freq: 0.484971
09dc    
09dc    MEMBAR-store-store	#@membar_storestore
09e0 +  spill R10 -&gt; R30	# spill size = 64
09e4 +  encode_heap_oop  R11, R7	#@encodeHeapOop
09e8 +  # checkcastPP of R30, #@checkCastPP
09e8    bne  R9, zr, B268	#@cmpI_reg_imm0_branch  P=0.000371 C=2692.000000

09ec    B103: #	out( B427 B104 ) &lt;- in( B102 )  Freq: 0.484791
09ec +  lwu  R31, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
09f0 +  mv  R28, java/lang/Class:exact *	# ptr, #@loadConP
0a08 +  lwu  R12, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
0a0c    spill [sp, #32] -&gt; R17	# spill size = 64
0a10 +  lwu  R10, [R17, #68]	# loadN, compressed ptr, #@loadN ! Field: java/lang/Thread.threadLocals
0a14 +  lwu  R28, [R28, #116]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/NativeBuffers.threadLocal
0a18 +  decode_heap_oop  R31, R31	#@decodeHeapOop
0a1c    lbu  R31, [R31, #12]	# byte, #@loadUB ! Field: sun/nio/fs/UnixFileSystem.needToResolveAgainstDefaultDirectory
0a20    NullCheck R31

0a20    B104: #	out( B380 B105 ) &lt;- in( B103 )  Freq: 0.484791
0a20 +  decode_heap_oop  R12, R12	#@decodeHeapOop
0a24 +  far_bne  R31, zr, B380	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2801.000000

0a2c    B105: #	out( B428 B106 ) &lt;- in( B104 )  Freq: 0.48479
0a2c    lwu  R14, [R12, #12]	# range, #@loadRange
0a30    NullCheck R12

0a30    B106: #	out( B381 B107 ) &lt;- in( B105 )  Freq: 0.48479
0a30 +  decode_heap_oop  R15, R10	#@decodeHeapOop
0a34 +  decode_heap_oop  R16, R28	#@decodeHeapOop
0a38 +  far_bleu  R14, zr, B381	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000000 C=10104.000000

0a40    B107: #	out( B429 B108 ) &lt;- in( B106 )  Freq: 0.48479
0a40    lw  R31, [R16, #12]	# int, #@loadI ! Field: java/lang/ThreadLocal.threadLocalHashCode (constant)
0a44    NullCheck R16

0a44    B108: #	out( B437 B109 ) &lt;- in( B107 )  Freq: 0.484789
0a44 +  addiw  R19, R14, #1	#@addI_reg_imm
0a48    lwu  R13, [R15, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap.table
0a4c    NullCheck R15

0a4c    B109: #	out( B430 B110 ) &lt;- in( B108 )  Freq: 0.484789
0a4c +  decode_heap_oop  R20, R13	#@decodeHeapOop
0a50    lwu  R18, [R20, #12]	# range, #@loadRange
0a54    NullCheck R20

0a54    B110: #	out( B343 B111 ) &lt;- in( B109 )  Freq: 0.484789
0a54 +  addiw  R10, R18, #-1	#@addI_reg_imm
0a58 +  andr  R13, R31, R10	#@andI_reg_reg
0a5c +  addw  R31, R13, zr	#@convI2L_reg_reg
0a60 +  slli  R31, R31, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0a64 +  add R31, R20, R31	# ptr, #@addP_reg_reg
0a68 +  far_bleu  R18, zr, B343	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

0a70    B111: #	out( B438 B112 ) &lt;- in( B110 )  Freq: 0.484788
0a70 +  lwu  R31, [R31, #16]	# loadN, compressed ptr, #@loadN
0a74 +  decode_heap_oop  R20, R31	#@decodeHeapOop
0a78    lwu  R10, [R20, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
0a7c    NullCheck R20

0a7c    B112: #	out( B344 B113 ) &lt;- in( B111 )  Freq: 0.484788
0a7c    
0a7c +  lwu  R31, [R20, #28]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap$Entry.value
0a80 +  decode_heap_oop  R18, R31	#@decodeHeapOop
0a84 +  far_bne  R10, R28, B344	#@far_cmpN_branch  P=0.000001 C=-1.000000

0a8c    B113: #	out( B431 B114 ) &lt;- in( B112 )  Freq: 0.484787
0a8c    lwu  R31, [R18, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0a90    NullCheck R18

0a90    B114: #	out( B401 B115 ) &lt;- in( B113 )  Freq: 0.484787
0a90 +  mv  R28, narrowklass: precise klass [Lsun/nio/fs/NativeBuffer;: 0x00000040d0586160:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0aa0 +  far_bne  R31, R28, B401	#@far_cmpN_branch  P=0.000000 C=-1.000000

0aa8    B115: #	out( B345 B116 ) &lt;- in( B114 )  Freq: 0.484787
0aa8 +  # checkcastPP of R18, #@checkCastPP
0aa8    lwu  R31, [R18, #12]	# range, #@loadRange
0aac +  far_bleu  R31, zr, B345	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

0ab4    B116: #	out( B439 B117 ) &lt;- in( B115 )  Freq: 0.484786
0ab4 +  lwu  R31, [R18, #16]	# loadN, compressed ptr, #@loadN
0ab8 +  decode_heap_oop  R21, R31	#@decodeHeapOop
0abc    lw  R8, [R21, #12]	# int, #@loadI ! Field: sun/nio/fs/NativeBuffer.size
0ac0    NullCheck R21

0ac0    B117: #	out( B367 B118 ) &lt;- in( B116 )  Freq: 0.484786
0ac0 +  far_blt  R8, R19, B367	#@far_cmpI_branch  P=0.000000 C=2801.000000

0ac8    B118: #	out( B250 B119 ) &lt;- in( B117 )  Freq: 0.484786
0ac8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0ac8    lb  R28, [R23, #56]	# byte, #@loadB
0acc +  lwu  R19, [R21, #28]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/NativeBuffer.owner
0ad0 +  bne  R28, zr, B250	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0ad4    B119: #	out( B224 B120 ) &lt;- in( B368 B252 B250 B118 )  Freq: 0.484786
0ad4 +  decode_heap_oop  R28, R19	#@decodeHeapOop
0ad8 +  sw  rheapbase, [R18, #16]	# compressed ptr (rheapbase==0), #@storeImmN0
0adc +  ld  R24, [R21, #16]	# int, #@loadL ! Field: sun/nio/fs/NativeBuffer.address
0ae0 +  beq  R28, R7, B224	#@cmpP_branch  P=0.027133 C=2801.000000

0ae4    B120: #	out( B260 B121 ) &lt;- in( B119 )  Freq: 0.471632
0ae4 +  spill R7 -&gt; R18	# spill size = 64
0ae8 +  li R7, #1	# int, #@loadConI
0aec    
0aec +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0aec    sb  R7, [R23, #968]	# byte, #@storeB
0af0    
0af0    
0af0 +  addi  R10, R12, #16	# ptr, #@addP_reg_imm
0af4    spill R9 -&gt; R19	# spill size = 32
0af8 +  addw  R25, R14, zr	#@convI2L_reg_reg
0afc    spill R11 -&gt; R22	# spill size = 32
0b04 +  spill R31 -&gt; [sp, #0]	# spill size = 32
0b08 +  spill R30 -&gt; R20	# spill size = 64
0b0c +  spill R17 -&gt; R8	# spill size = 64
0b10 +  spill R29 -&gt; R9	# spill size = 64
0b14 +  spill R25 -&gt; R12	# spill size = 64
0b18 +  mv  R11, R24	# long -&gt; ptr, #@castX2P
0b1c    CALL, runtime leaf nofp 0x000000401396e3c0	#@CallLeafNoFPDirect unsafe_arraycopy
        No JVM State Info
        # 
0b20 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0b20    sb zr, [R23, #968]	# byte, #@storeimmB0
0b24    
0b24 +  ld  R24, [R21, #16]	# int, #@loadL ! Field: sun/nio/fs/NativeBuffer.address
0b28 +  mv  R7, R24	# long -&gt; ptr, #@castX2P
0b2c +  add R7, R7, R25	# ptr, #@addP_reg_reg
0b30 +  sb zr, [R7]	# byte, #@storeimmB0
0b34 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0b34    lb  R7, [R23, #56]	# byte, #@loadB
0b38 +  bne  R7, zr, B260	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0b3c    B121: #	out( B123 B122 ) &lt;- in( B374 B262 B260 B120 )  Freq: 0.471632
0b3c +  mv  R28, R21	# ptr -&gt; long, #@castP2X
0b40    spill R18 -&gt; R7	# spill size = 64
0b44 +  mv  R29, R7	# ptr -&gt; long, #@castP2X
0b48 +  xorr  R29, R29, R28	#@xorL_reg_reg
0b4c +  srli  R29, R29, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0b50 +  sw  R22, [R21, #28]	# compressed ptr, #@storeN ! Field: sun/nio/fs/NativeBuffer.owner
0b54 +  beq  R29, zr, B123	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0b58    B122: #	out( B263 B123 ) &lt;- in( B121 )  Freq: 0.47116
0b58 +  srli  R28, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0b5c +  mv  R29, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
0b68 +  add R10, R29, R28	# ptr, #@addP_reg_reg
0b6c +  lb  R29, [R10]	# byte, #@loadB
0b70 +  li R30, #4	# int, #@loadConI
0b74 +  bne  R29, R30, B263	#@cmpI_branch  P=0.001000 C=-1.000000

0b78    B123: #	out( B124 ) &lt;- in( B267 B122 B121 )  Freq: 0.471632
0b78 +  spill R9 -&gt; R29	# spill size = 64
0b7c +  spill R19 -&gt; R9	# spill size = 32
0b80 +  spill R20 -&gt; R30	# spill size = 64
0b84 +  spill R22 -&gt; [sp, #4]	# spill size = 32

0b88    B124: #	out( B462 B125 ) &lt;- in( B224 B123 )  Freq: 0.484786
0b88 +  spill R21 -&gt; [sp, #56]	# spill size = 64
0b8c +  spill R30 -&gt; [sp, #32]	# spill size = 64
0b90 +  spill R9 -&gt; [sp, #48]	# spill size = 32
0b94 +  spill R7 -&gt; [sp, #40]	# spill size = 64
0b98 +  spill R29 -&gt; [sp, #16]	# spill size = 64
0b9c +  spill R24 -&gt; R11	# spill size = 64
0ba0 +  spill R30 -&gt; R12	# spill size = 64
0ba4    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect sun.nio.fs.UnixNativeDispatcher::lstat0
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:10 (line 308) L[0]=_ L[1]=_ L[2]=sp + #56 L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=NarrowOop [4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop off=2984/0xba8}

0ba8    B125: #	out( B432 B126 ) &lt;- in( B124 )  Freq: 0.484776
        # Block is sole successor of call
0ba8 +  mv  R7, java/lang/Class:exact *	# ptr, #@loadConP
0bc0 +  lwu  R31, [R7, #116]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/NativeBuffers.threadLocal
0bc4 +  lwu  R7, [R8, #68]	# loadN, compressed ptr, #@loadN ! Field: java/lang/Thread.threadLocals
0bc8 +  decode_heap_oop  R28, R31	#@decodeHeapOop
0bcc +  decode_heap_oop  R30, R7	#@decodeHeapOop
0bd0    lw  R10, [R28, #12]	# int, #@loadI ! Field: java/lang/ThreadLocal.threadLocalHashCode (constant)
0bd4    NullCheck R28

0bd4    B126: #	out( B440 B127 ) &lt;- in( B125 )  Freq: 0.484776
0bd4    lwu  R7, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap.table
0bd8    NullCheck R30

0bd8    B127: #	out( B433 B128 ) &lt;- in( B126 )  Freq: 0.484775
0bd8 +  decode_heap_oop  R12, R7	#@decodeHeapOop
0bdc    lwu  R7, [R12, #12]	# range, #@loadRange
0be0    NullCheck R12

0be0    B128: #	out( B346 B129 ) &lt;- in( B127 )  Freq: 0.484775
0be0 +  addiw  R11, R7, #-1	#@addI_reg_imm
0be4 +  andr  R29, R10, R11	#@andI_reg_reg
0be8 +  addw  R10, R29, zr	#@convI2L_reg_reg
0bec +  slli  R10, R10, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0bf0 +  add R10, R12, R10	# ptr, #@addP_reg_reg
0bf4 +  far_bleu  R7, zr, B346	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

0bfc    B129: #	out( B441 B130 ) &lt;- in( B128 )  Freq: 0.484774
0bfc +  lwu  R7, [R10, #16]	# loadN, compressed ptr, #@loadN
0c00 +  decode_heap_oop  R7, R7	#@decodeHeapOop
0c04    lwu  R11, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
0c08    NullCheck R7

0c08    B130: #	out( B347 B131 ) &lt;- in( B129 )  Freq: 0.484774
0c08    
0c08 +  lwu  R10, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap$Entry.value
0c0c +  decode_heap_oop  R10, R10	#@decodeHeapOop
0c10 +  far_bne  R11, R31, B347	#@far_cmpN_branch  P=0.000001 C=-1.000000

0c18    B131: #	out( B434 B132 ) &lt;- in( B130 )  Freq: 0.484774
0c18    lwu  R28, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0c1c    NullCheck R10

0c1c    B132: #	out( B402 B133 ) &lt;- in( B131 )  Freq: 0.484773
0c1c +  mv  R7, narrowklass: precise klass [Lsun/nio/fs/NativeBuffer;: 0x00000040d0586160:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0c2c +  far_bne  R28, R7, B402	#@far_cmpN_branch  P=0.000000 C=-1.000000

0c34    B133: #	out( B348 B134 ) &lt;- in( B132 )  Freq: 0.484773
0c34 +  # checkcastPP of R10, #@checkCastPP
0c34    lwu  R28, [R10, #12]	# range, #@loadRange
0c38 +  addi  R9, R10, #16	# ptr, #@addP_reg_imm
0c3c +  far_bleu  R28, zr, B348	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

0c44    B134: #	out( B369 B135 ) &lt;- in( B133 )  Freq: 0.484773
0c44 +  lwu  R7, [R9]	# loadN, compressed ptr, #@loadN
0c48 +  decode_heap_oop  R8, R7	#@decodeHeapOop
0c4c +  far_bne   R8, zr, B369	#@far_cmpP_imm0_branch  P=0.000000 C=2801.000000

0c54    B135: #	out( B253 B136 ) &lt;- in( B134 )  Freq: 0.484773
0c54 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c54    lb  R28, [R23, #56]	# byte, #@loadB
0c58 +  bne  R28, zr, B253	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0c5c    B136: #	out( B138 B137 ) &lt;- in( B370 B255 B253 B135 )  Freq: 0.484773
0c5c +  mv  R7, R9	# ptr -&gt; long, #@castP2X
0c60    spill [sp, #56] -&gt; R28	# spill size = 64
0c64 +  mv  R28, R28	# ptr -&gt; long, #@castP2X
0c64 +  xorr  R28, R28, R7	#@xorL_reg_reg
0c68 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0c6c    spill [sp, #0] -&gt; R29	# spill size = 32
0c70 +  sw  R29, [R9]	# compressed ptr, #@storeN
0c74 +  beq  R28, zr, B138	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0c78    B137: #	out( B256 B138 ) &lt;- in( B136 )  Freq: 0.484288
0c78 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0c7c +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
0c88 +  add R10, R28, R7	# ptr, #@addP_reg_reg
0c8c +  lb  R7, [R10]	# byte, #@loadB
0c90 +  li R29, #4	# int, #@loadConI
0c94 +  bne  R7, R29, B256	#@cmpI_branch  P=0.001000 C=-1.000000

0c98    B138: #	out( B276 B139 ) &lt;- in( B258 B259 B256 B137 B136 B269 )  Freq: 0.484953
0c98 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c98    ld  R10, [R23, #288]	# ptr, #@loadP
0c9c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c9c    ld  R7, [R23, #304]	# ptr, #@loadP
0ca0 +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
0ca4 +  bgeu  R28, R7, B276	#@cmpP_branch  P=0.000100 C=-1.000000

0ca8    B139: #	out( B140 ) &lt;- in( B138 )  Freq: 0.484904
0ca8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0ca8    sd  R28, [R23, #288]	# ptr, #@storeP
0cac +  li R7, #1	# long, #@loadConL
0cb0 +  mv  R28, narrowklass: precise klass sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes: 0x00000040d01c5d50:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0cc0 +  sd  R7, [R10]	# long, #@storeL
0cc4 +  sw  R28, [R10, #8]	# compressed klass ptr, #@storeNKlass
0cc8 +  sw  zr, [R10, #12]	# int, #@storeimmI0

0ccc    B140: #	out( B424 B141 ) &lt;- in( B277 B139 )  Freq: 0.484953
0ccc    spill [sp, #32] -&gt; R7	# spill size = 64
0cd0 +  encode_heap_oop  R7, R7	#@encodeHeapOop
0cd4    
0cd4 +  # checkcastPP of R10, #@checkCastPP
0cd4    sw  R7, [R10, #12]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes.attrs
0cd8 +  #@membar_release
	fence iorw ow
0cdc +  spill [sp, #16] -&gt; R31	# spill size = 64
0ce0 +  lwu  R28, [R31, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker.stack
0ce4 +  spill R10 -&gt; R12	# spill size = 64
0ce8 +  # checkcastPP of R12, #@checkCastPP
0ce8    decode_heap_oop  R7, R28	#@decodeHeapOop
0cec    lwu  R28, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/ArrayDeque.elements
0cf0    NullCheck R7

0cf0    B141: #	out( B425 B142 ) &lt;- in( B140 )  Freq: 0.484952
0cf0 +  lw  R30, [R7, #12]	# int, #@loadI ! Field: java/util/ArrayDeque.head
0cf4 +  lw  R7, [R7, #16]	# int, #@loadI ! Field: java/util/ArrayDeque.tail
0cf8 +  decode_heap_oop  R28, R28	#@decodeHeapOop
0cfc    lwu  R29, [R28, #12]	# range, #@loadRange
0d00    NullCheck R28

0d00    B142: #	out( B379 B143 ) &lt;- in( B141 )  Freq: 0.484952
0d00 +  subw  R7, R7, R30	#@subI_reg_reg
0d04 +  sraiw R28, R28, 31	#@cmpLTMask_reg_reg
0d08 +  andr  R29, R28, R29	#@andI_reg_reg
0d0c +  addw  R8, R29, R7	#@addI_reg_reg
0d10 +  lw  R28, [R31, #12]	# int, #@loadI ! Field: java/nio/file/FileTreeWalker.maxDepth
0d14 +  lwu  R30, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0d18 +  mv  R7, narrowklass: precise klass sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes: 0x00000040d01c5d50:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0d28 +  far_bge  R8, R28, B379	#@far_cmpI_branch  P=0.000000 C=2686.000000

0d30    B143: #	out( B342 B144 ) &lt;- in( B142 )  Freq: 0.484951
0d30 +  far_bne  R30, R7, B342	#@far_cmpN_branch  P=0.000001 C=-1.000000

0d38    B144: #	out( B426 B145 ) &lt;- in( B143 )  Freq: 0.484951
0d38 +  spill R12 -&gt; R30	# spill size = 64
0d3c +  # checkcastPP of R30, #@checkCastPP
0d3c    lwu  R28, [R30, #12]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes.attrs
0d40 +  decode_heap_oop  R7, R28	#@decodeHeapOop
0d44    lw  R7, [R7, #12]	# int, #@loadI ! Field: sun/nio/fs/UnixFileAttributes.st_mode
0d48    NullCheck R7

0d48    B145: #	out( B195 B146 ) &lt;- in( B144 )  Freq: 0.48495
0d48 +  li R29, #61440	# int, #@loadConI
0d4c +  andr  R7, R7, R29	#@andI_reg_reg
0d50 +  li R29, #16384	# int, #@loadConI
0d54 +  beq  R7, R29, B195	#@cmpI_branch  P=0.027923 C=2686.000000

0d58    B146: #	out( B278 B147 ) &lt;- in( B145 )  Freq: 0.471409
0d58 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0d58    ld  R10, [R23, #288]	# ptr, #@loadP
0d5c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0d5c    ld  R7, [R23, #304]	# ptr, #@loadP
0d60 +  addi  R28, R10, #32	# ptr, #@addP_reg_imm
0d64 +  bgeu  R28, R7, B278	#@cmpP_branch  P=0.000100 C=-1.000000

0d68    B147: #	out( B148 ) &lt;- in( B146 )  Freq: 0.471362
0d68 +  li R7, #1	# long, #@loadConL
0d6c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0d6c    sd  R28, [R23, #288]	# ptr, #@storeP
0d70 +  sd  R7, [R10]	# long, #@storeL
0d74 +  mv  R7, narrowklass: precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d82188f0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0d84 +  sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
0d88 +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
0d8c +  sw  zr, [R10, #12]	# int, #@storeimmI0
0d90 +  ClearArray #2, R28	#@clearArray_imm_reg

0d98    B148: #	out( B531 B149 ) &lt;- in( B279 B147 )  Freq: 0.471409
0d98    
0d98    MEMBAR-store-store	#@membar_storestore
0d9c +  spill R10 -&gt; R8	# spill size = 64
0da0 +  # checkcastPP of R8, #@checkCastPP
0da0    mv  R12, java/nio/file/FileTreeWalker$EventType:exact *	# ptr, #@loadConP
0db8    spill R8 -&gt; R11	# spill size = 64
0dbc +  spill [sp, #40] -&gt; R13	# spill size = 64
0dc0 +  spill R30 -&gt; R14	# spill size = 64
0dc4 +  mv  R15, NULL	# NULL ptr, #@loadConP0
0dc8    spill R31 -&gt; [sp, #0]	# spill size = 64
0dcc    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeWalker$Event::&lt;init&gt;
        # java.nio.file.FileTreeWalker$Event::&lt;init&gt; @ bci:5 (line 141) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.nio.file.FileTreeWalker::visit @ bci:76 (line 289) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=R8
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #0 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop off=3536/0xdd0}

0dd0    B149: #	out( B150 ) &lt;- in( B148 )  Freq: 0.4714
        # Block is sole successor of call
0dd0 +  spill R8 -&gt; [sp, #0]	# spill size = 64

0dd4    B150: #	out( B151 ) &lt;- in( B223 B149 B193 )  Freq: 0.499155
0dd4 +  mv  R8, narrowoop: java/nio/file/FileTreeWalker$EventType:exact *	# compressed ptr, #@loadConN

0de4    B151: #	out( B533 B152 ) &lt;- in( B150 B184 ) Loop( B151-B184 inner ) Freq: 0.513841
0de4    spill [sp, #0] -&gt; R11	# spill size = 64
0de8    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeWalker$Event::ioeException
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:20 (line 85) L[0]=sp + #8 L[1]=sp + #0 L[2]=_
        # OopMap {fp=NarrowOop [0]=Oop [8]=Oop off=3564/0xdec}

0dec    B152: #	out( B323 B153 ) &lt;- in( B151 )  Freq: 0.513831
        # Block is sole successor of call
0dec +  spill [sp, #0] -&gt; R9	# spill size = 64
0df0 +  lwu  R7, [R9, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.type
0df4 +  bne   R10, zr, B323	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

0df8    B153: #	out( B181 B154 ) &lt;- in( B152 )  Freq: 0.51383
0df8 +  beq  R7, R8, B181	#@cmpN_branch  P=0.028602 C=2762.000000

0dfc    B154: #	out( B234 B155 ) &lt;- in( B153 )  Freq: 0.499133
0dfc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0dfc    lb  R28, [R23, #56]	# byte, #@loadB
0e00 +  bne  R28, zr, B234	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0e04    B155: #	out( B156 ) &lt;- in( B154 )  Freq: 0.498634
0e04 +  spill [sp, #8] -&gt; R18	# spill size = 64

0e08    B156: #	out( B162 B157 ) &lt;- in( B362 B236 B234 B155 )  Freq: 0.499133
0e08 +  mv  R7, R18	# ptr -&gt; long, #@castP2X
0e0c +  mv  R28, R9	# ptr -&gt; long, #@castP2X
0e10 +  xorr  R28, R28, R7	#@xorL_reg_reg
0e14 +  encode_heap_oop  R29, R9	#@encodeHeapOop
0e18 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0e1c +  sw  R29, [R18, #16]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeIterator.next
0e20 +  beq  R28, zr, B162	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0e24    B157: #	out( B162 B158 ) &lt;- in( B156 )  Freq: 0.498634
0e24 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0e28 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
0e34 +  add R10, R28, R7	# ptr, #@addP_reg_reg
0e38 +  lb  R28, [R10]	# byte, #@loadB
0e3c +  li R29, #4	# int, #@loadConI
0e40 +  beq  R28, R29, B162	#@cmpI_branch  P=0.999000 C=-1.000000

0e44    B158: #	out( B162 B159 ) &lt;- in( B157 )  Freq: 0.000498634
0e44 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e44    ld  R7, [R23, #64]	# int, #@loadL
0e48 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e48    ld  R28, [R23, #80]	# ptr, #@loadP
0e4c +  #@membar_volatile
	fence iorw iorw
0e50 +  lb  R29, [R10]	# byte, #@loadB
0e54 +  beq  R29, zr, B162	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

0e58    B159: #	out( B161 B160 ) &lt;- in( B158 )  Freq: 0.000249317
0e58 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
0e5c +  bne  R7, zr, B161	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

0e60    B160: #	out( B162 ) &lt;- in( B159 )  Freq: 0.000124659
0e60 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e60    spill R23 -&gt; R11	# spill size = 64
0e64 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
0e94 +  j  B162	#@branch

0e98    B161: #	out( B162 ) &lt;- in( B159 )  Freq: 0.000124659
0e98 +  add R28, R28, R7	# ptr, #@addP_reg_reg
0e9c +  addi  R7, R7, #-8	#@addL_reg_imm
0ea0 +  sd  R10, [R28, #-8]	# ptr, #@storeP
0ea4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0ea4    sd  R7, [R23, #64]	# long, #@storeL

0ea8    B162: #	out( N6590 ) &lt;- in( B160 B161 B158 B157 B156 B183 B6 B1 )  Freq: 0.999928
0ea8    # pop frame 176
	add  sp, sp, #176
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0f08 +  ret	// return register, #@Ret

0f0c    B163: #	out( B167 B164 ) &lt;- in( B46 )  Freq: 0.0265686
0f0c +  li R7, #1	# int, #@loadConI
0f10 +  beq  R9, R7, B167	#@cmpI_branch  P=0.500000 C=150.000000

0f14    B164: #	out( B397 B165 ) &lt;- in( B163 )  Freq: 0.0132843
0f14 +  li R7, #2	# int, #@loadConI
0f18 +  lb  R8, [R20, #17]	# byte, #@loadB
0f1c +  far_bne  R9, R7, B397	#@far_cmpI_branch  P=0.000000 C=75.000000

0f24    B165: #	out( B167 B166 ) &lt;- in( B164 )  Freq: 0.0132843
0f24 +  li R28, #46	# int, #@loadConI
0f28 +  beq  R8, R28, B167	#@cmpI_branch  P=1.000000 C=75.000000

0f2c    B166: #	out( N6590 ) &lt;- in( B165 )  Freq: 6.64214e-09
0f2c +  spill [sp, #8] -&gt; R7	# spill size = 64
0f30 +  li R11, #-187	# int, #@loadConI
0f34    spill R7 -&gt; [sp, #0]	# spill size = 64
0f38 +  spill R19 -&gt; [sp, #32]	# spill size = 64
0f3c +  spill R19 -&gt; [sp, #40]	# spill size = 64
0f40 +  spill R20 -&gt; [sp, #64]	# spill size = 64
0f44    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::isSelfOrParent @ bci:25 (line 146) L[0]=_ L[1]=_ STK[0]=R8 STK[1]=#46
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:123 (line 181) L[0]=sp + #32 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [64]=Oop off=3912/0xf48}
0f48    #@ShouldNotReachHere

0f54    B167: #	out( B444 B168 ) &lt;- in( B165 B163 )  Freq: 0.0265686
0f54 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0f54    spill R19 -&gt; R7	# spill size = 64
0f58 +  ld  R11, [R23, #920]	# ptr, #@loadP
0f5c    spill R7 -&gt; R28	# spill size = 64
0f60 +  lwu zr, [R11]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:182 (line 192) L[0]=R28 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=R28 STK[0]=R28 MON-BOX0=sp+144 MON-OBJ[0]=R28
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=R28 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {x28=Oop c_rarg0=Oop x19=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=NarrowOop off=3936/0xf60}
0f64    lwu  R28, [R10, #32]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream.streamLock
0f68    NullCheck R10

0f68    B168: #	out( B445 B169 ) &lt;- in( B167 )  Freq: 0.0265685
0f68 +  decode_heap_oop  R7, R28	#@decodeHeapOop
0f6c    lwu  R7, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock.readerLock
0f70    NullCheck R7

0f70    B169: #	out( B446 B170 ) &lt;- in( B168 )  Freq: 0.0265685
0f70 +  decode_heap_oop  R8, R7	#@decodeHeapOop
0f74    # checkcastPP of R8, #@checkCastPP
0f74    lwu  R28, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0f78    NullCheck R8

0f78    B170: #	out( B382 B171 ) &lt;- in( B169 )  Freq: 0.0265685
0f78 +  mv  R7, narrowklass: precise klass java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock: 0x00000040d836c420:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0f88 +  far_bne  R28, R7, B382	#@far_cmpN_branch  P=0.000001 C=-1.000000

0f90    B171: #	out( B447 B172 ) &lt;- in( B170 )  Freq: 0.0265685
0f90 +  # checkcastPP of R8, #@checkCastPP
0f90    lwu  R28, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock.sync
0f94 +  decode_heap_oop  R30, R28	#@decodeHeapOop
0f98    lw  R10, [R30, #16]	# int, #@loadI ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.state
0f9c    NullCheck R30

0f9c    B172: #	out( B390 B173 ) &lt;- in( B171 )  Freq: 0.0265684
0f9c +  #@membar_acquire
	fence ir iorw
0fa0 +  li R7, #65535	# int, #@loadConI
0fa8 +  andr  R8, R10, R7	#@andI_reg_reg
0fac +  far_bne  R8, zr, B390	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2964.000000

0fb4    B173: #	out( B383 B174 ) &lt;- in( B172 )  Freq: 0.0265684
0fb4 +  lwu  R7, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.head
0fb8 +  #@membar_acquire
	fence ir iorw
0fbc +  decode_heap_oop  R8, R7	#@decodeHeapOop
0fc0 +  srliw  R31, R10, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
0fc4 +  far_bne   R8, zr, B383	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0fcc    B174: #	out( B391 B175 ) &lt;- in( B173 )  Freq: 0.0265684
0fcc +  li R28, #65535	# int, #@loadConI
0fd4 +  far_bge  R31, R28, B391	#@far_cmpI_branch  P=0.000000 C=2964.000000

0fdc    B175: #	out( B392 B176 ) &lt;- in( B174 )  Freq: 0.0265684
0fdc +  #@membar_release
	fence iorw ow
0fe0 +  li R28, #65536	# int, #@loadConI
0fe4 +  addw  R29, R10, R28	#@addI_reg_reg
0fe8 +  addi  R7, R30, #16	# ptr, #@addP_reg_imm
0fec    
0fec +  cmpxchg_acq [R7], R10, R29	# (int) if [R7] == R10 then [R7] &lt;-- R29
	mv R8, R8 == R10	# R8 &lt;-- (R8 == R10 ? 1 : 0), #@compareAndSwapIAcq
1008    
1008 +  #@membar_acquire
	fence ir iorw
100c +  far_beq  R8, zr, B392	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2964.000000

1014    B176: #	out( B388 B177 ) &lt;- in( B175 )  Freq: 0.0265684
1014 +  far_bne  R31, zr, B388	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2964.000000

101c    B177: #	out( B280 B178 ) &lt;- in( B176 )  Freq: 0.0265684
101c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
101c    lb  R7, [R23, #56]	# byte, #@loadB
1020 +  bne  R7, zr, B280	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1024    B178: #	out( B180 B179 ) &lt;- in( B389 B282 B280 B177 )  Freq: 0.0265684
1024 +  mv  R7, R30	# ptr -&gt; long, #@castP2X
1028    spill [sp, #32] -&gt; R20	# spill size = 64
102c +  mv  R28, R20	# ptr -&gt; long, #@castP2X
1030 +  xorr  R28, R28, R7	#@xorL_reg_reg
1034 +  srli  R29, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
1038    spill [sp, #40] -&gt; R28	# spill size = 32
103c +  sw  R28, [R30, #40]	# compressed ptr, #@storeN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
1040 +  beq  R29, zr, B180	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1044    B179: #	out( B283 B180 ) &lt;- in( B178 )  Freq: 0.0265418
1044 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1048 +  mv  R29, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1054 +  add R10, R29, R7	# ptr, #@addP_reg_reg
1058 +  lb  R7, [R10]	# byte, #@loadB
105c +  li R31, #4	# int, #@loadConI
1060 +  bne  R7, R31, B283	#@cmpI_branch  P=0.001000 C=-1.000000

1064    B180: #	out( B28 ) &lt;- in( B285 B286 B283 B179 B178 )  Freq: 0.0265684
1064 +  li R7, #1	# int, #@loadConI
1068 +  sw  R7, [R30, #28]	# int, #@storeI ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReaderHoldCount
106c    spill [sp, #8] -&gt; R9	# spill size = 64
1070 +  spill [sp, #16] -&gt; R18	# spill size = 64
1074 +  spill [sp, #24] -&gt; R24	# spill size = 64
1078 +  j  B28	#@branch

107c    B181: #	out( B384 B182 ) &lt;- in( B153 )  Freq: 0.0146968
107c +  spill [sp, #8] -&gt; R28	# spill size = 64
1080 +  lwu  R7, [R28, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.walker
1084 +  decode_heap_oop  R11, R7	#@decodeHeapOop
1088 +  far_beq   R11, zr, B384	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

1090    B182: #	out( B530 B183 ) &lt;- in( B181 )  Freq: 0.0146968
1090    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeWalker::next
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:57 (line 94) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=NarrowOop [8]=Oop off=4244/0x1094}

1094    B183: #	out( B162 B184 ) &lt;- in( B182 )  Freq: 0.0146965
        # Block is sole successor of call
1094 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1094    ld  R7, [R23, #920]	# ptr, #@loadP
1098 +  lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:61 (line 95) L[0]=sp + #8 L[1]=R10 L[2]=_
        # OopMap {c_rarg0=Oop fp=NarrowOop [8]=Oop off=4248/0x1098}
109c +  beq   R10, zr, B162	#@cmpP_imm0_branch  P=0.001085 C=79.000000

10a0    B184: #	out( B151 ) &lt;- in( B183 )  Freq: 0.0146806
10a0 +  spill R10 -&gt; [sp, #0]	# spill size = 64
10a4 +  j  B151	#@branch

10a8    B185: #	out( B448 B186 ) &lt;- in( B78 )  Freq: 0.0142163
10a8 +  spill [sp, #24] -&gt; R29	# spill size = 64
10ac +  lwu  R7, [R29, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.stream
10b0 +  decode_heap_oop  R30, R7	#@decodeHeapOop
10b4    lwu  R28, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
10b8    NullCheck R30

10b8    B186: #	out( B386 B187 ) &lt;- in( B185 )  Freq: 0.0142163
10b8 +  mv  R7, narrowklass: precise klass sun/nio/fs/UnixSecureDirectoryStream: 0x00000040d82bfb40:Constant:exact *	# compressed klass ptr, #@loadConNKlass
10c8 +  far_bne  R28, R7, B386	#@far_cmpN_branch  P=0.000001 C=-1.000000

10d0    B187: #	out( B442 B188 ) &lt;- in( B186 )  Freq: 0.0142163
10d0 +  # checkcastPP of R30, #@checkCastPP
10d0    spill R29 -&gt; [sp, #0]	# spill size = 64
10d4 +  spill R30 -&gt; R11	# spill size = 64
10d8    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixSecureDirectoryStream::close
        # java.nio.file.FileTreeWalker::next @ bci:76 (line 361) L[0]=sp + #16 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=4316/0x10dc}

10dc    B188: #	out( B385 B189 ) &lt;- in( B187 )  Freq: 0.014216
        # Block is sole successor of call
10dc +  spill [sp, #16] -&gt; R7	# spill size = 64
10e0 +  lwu  R28, [R7, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker.stack
10e4 +  decode_heap_oop  R11, R28	#@decodeHeapOop
10e8 +  far_beq   R11, zr, B385	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

10f0    B189: #	out( B529 B190 ) &lt;- in( B188 )  Freq: 0.014216
10f0    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.ArrayDeque::removeFirst
        # java.util.ArrayDeque::pop @ bci:1 (line 593) L[0]=_
        # java.nio.file.FileTreeWalker::next @ bci:109 (line 369) L[0]=_ L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop off=4340/0x10f4}

10f4    B190: #	out( B315 B191 ) &lt;- in( B189 )  Freq: 0.0142157
        # Block is sole successor of call
10f4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
10f4    ld  R10, [R23, #288]	# ptr, #@loadP
10f8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
10f8    ld  R7, [R23, #304]	# ptr, #@loadP
10fc +  addi  R28, R10, #32	# ptr, #@addP_reg_imm
1100 +  bgeu  R28, R7, B315	#@cmpP_branch  P=0.000100 C=-1.000000

1104    B191: #	out( B192 ) &lt;- in( B190 )  Freq: 0.0142143
1104 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1104    sd  R28, [R23, #288]	# ptr, #@storeP
1108 +  li R7, #1	# long, #@loadConL
110c +  mv  R28, narrowklass: precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d82188f0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
111c +  sd  R7, [R10]	# long, #@storeL
1120 +  sw  R28, [R10, #8]	# compressed klass ptr, #@storeNKlass
1124 +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
1128 +  sw  zr, [R10, #12]	# int, #@storeimmI0
112c +  ClearArray #2, R28	#@clearArray_imm_reg

1134    B192: #	out( B528 B193 ) &lt;- in( B316 B191 )  Freq: 0.0142157
1134    
1134    MEMBAR-store-store	#@membar_storestore
1138 +  spill [sp, #0] -&gt; R7	# spill size = 64
113c +  lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.dir
1140 +  spill R10 -&gt; R8	# spill size = 64
1144 +  decode_heap_oop  R13, R28	#@decodeHeapOop
1148 +  # checkcastPP of R8, #@checkCastPP
1148    mv  R12, java/nio/file/FileTreeWalker$EventType:exact *	# ptr, #@loadConP
1160    spill R8 -&gt; R11	# spill size = 64
1164 +  mv  R14, NULL	# NULL ptr, #@loadConP0
1168    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeWalker$Event::&lt;init&gt;
        # java.nio.file.FileTreeWalker::next @ bci:126 (line 370) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=R8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop off=4460/0x116c}

116c    B193: #	out( B150 ) &lt;- in( B192 )  Freq: 0.0142155
        # Block is sole successor of call
116c +  spill R8 -&gt; [sp, #0]	# spill size = 64
1170 +  j  B150	#@branch

1174    B194: #	out( B73 ) &lt;- in( B44 )  Freq: 0.0136516
1174 +  li R28, #1	# int, #@loadConI
1178    spill [sp, #0] -&gt; R19	# spill size = 64
117c +  sb  R28, [R19, #12]	# byte, #@storeB ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.atEof
1180 +  mv  R18, NULL	# NULL ptr, #@loadConP0
1184 +  j  B73	#@branch

1188    B195: #	out( B398 B196 ) &lt;- in( B145 )  Freq: 0.0135411
1188 +  lbu  R8, [R31, #16]	# byte, #@loadUB ! Field: java/nio/file/FileTreeWalker.followLinks
118c +  far_bne  R8, zr, B398	#@far_cmpI_reg_imm0_branch  P=0.000000 C=75.000000

1194    B196: #	out( B443 B197 ) &lt;- in( B195 )  Freq: 0.0135411
1194 +  spill R30 -&gt; [sp, #32]	# spill size = 64
1198 +  spill [sp, #40] -&gt; R11	# spill size = 64
119c    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.nio.file.Files::newDirectoryStream
        # java.nio.file.FileTreeWalker::visit @ bci:131 (line 301) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=4512/0x11a0}

11a0    B197: #	out( B317 B198 ) &lt;- in( B196 )  Freq: 0.0135408
        # Block is sole successor of call
11a0 +  spill R10 -&gt; R8	# spill size = 64
11a4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
11a4    ld  R10, [R23, #288]	# ptr, #@loadP
11a8    spill [sp, #16] -&gt; R30	# spill size = 64
11ac +  lwu  R28, [R30, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker.stack
11b0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
11b0    ld  R29, [R23, #304]	# ptr, #@loadP
11b4 +  addi  R7, R10, #32	# ptr, #@addP_reg_imm
11b8 +  decode_heap_oop  R31, R28	#@decodeHeapOop
11bc +  bgeu  R7, R29, B317	#@cmpP_branch  P=0.000100 C=-1.000000

11c0    B198: #	out( B199 ) &lt;- in( B197 )  Freq: 0.0135394
11c0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
11c0    sd  R7, [R23, #288]	# ptr, #@storeP
11c4 +  li R7, #1	# long, #@loadConL
11c8 +  sd  R7, [R10]	# long, #@storeL
11cc +  mv  R7, narrowklass: precise klass java/nio/file/FileTreeWalker$DirectoryNode: 0x00000040d83de560:Constant:exact *	# compressed klass ptr, #@loadConNKlass
11dc +  sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
11e0 +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
11e4 +  sw  zr, [R10, #12]	# int, #@storeimmI0
11e8    ClearArray #2, R28	#@clearArray_imm_reg
11f0    spill R31 -&gt; [sp, #48]	# spill size = 64

11f4    B199: #	out( B527 B200 ) &lt;- in( B318 B198 )  Freq: 0.0135408
11f4    
11f4 +  spill R10 -&gt; R7	# spill size = 64
11f8 +  # checkcastPP of R7, #@checkCastPP
11f8    spill R7 -&gt; [sp, #56]	# spill size = 64
11fc +  spill [sp, #32] -&gt; R11	# spill size = 64
1200    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes::fileKey
        # java.nio.file.FileTreeWalker::visit @ bci:177 (line 311) L[0]=_ L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=R8 L[7]=_ STK[0]=sp + #48 STK[1]=sp + #56 STK[2]=sp + #56 STK[3]=sp + #40
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=4612/0x1204}

1204    B200: #	out( B287 B201 ) &lt;- in( B199 )  Freq: 0.0135405
        # Block is sole successor of call
1204 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1204    lb  R7, [R23, #56]	# byte, #@loadB
1208    spill R10 -&gt; R9	# spill size = 64
120c +  bne  R7, zr, B287	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1210    B201: #	out( B202 ) &lt;- in( B200 )  Freq: 0.013527
1210 +  spill [sp, #56] -&gt; R20	# spill size = 64

1214    B202: #	out( B204 B203 ) &lt;- in( B393 B289 B287 B201 )  Freq: 0.0135405
1214 +  mv  R7, R20	# ptr -&gt; long, #@castP2X
1218    spill [sp, #40] -&gt; R18	# spill size = 64
121c +  mv  R28, R18	# ptr -&gt; long, #@castP2X
1220 +  xorr  R28, R28, R7	#@xorL_reg_reg
1224 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
1228    spill R8 -&gt; R21	# spill size = 64
122c +  encode_heap_oop  R19, R21	#@encodeHeapOop
1230    spill R9 -&gt; R22	# spill size = 64
1234 +  encode_heap_oop  R9, R9	#@encodeHeapOop
1238    spill [sp, #4] -&gt; R30	# spill size = 32
123c +  sw  R30, [R20, #16]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.dir
1240 +  beq  R28, zr, B204	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1244    B203: #	out( B299 B204 ) &lt;- in( B202 )  Freq: 0.013527
1244 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1248 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1254 +  add R10, R28, R7	# ptr, #@addP_reg_reg
1258 +  lb  R28, [R10]	# byte, #@loadB
125c +  li R7, #4	# int, #@loadConI
1260 +  bne  R28, R7, B299	#@cmpI_branch  P=0.001000 C=-1.000000

1264    B204: #	out( B290 B205 ) &lt;- in( B301 B302 B299 B203 B202 )  Freq: 0.0135405
1264 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1264    lb  R7, [R23, #56]	# byte, #@loadB
1268 +  bne  R7, zr, B290	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

126c    B205: #	out( B208 B206 ) &lt;- in( B394 B292 B290 B204 )  Freq: 0.0135405
126c +  mv  R7, R20	# ptr -&gt; long, #@castP2X
1270 +  mv  R28, R22	# ptr -&gt; long, #@castP2X
1274 +  xorr  R28, R28, R7	#@xorL_reg_reg
1278 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
127c +  sw  R9, [R20, #20]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.key
1280 +  beq  R28, zr, B208	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1284    B206: #	out( B208 B207 ) &lt;- in( B205 )  Freq: 0.013527
1284 +  beq   R22, zr, B208	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

1288    B207: #	out( B303 B208 ) &lt;- in( B206 )  Freq: 0.0135134
1288 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
128c +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1298 +  add R10, R28, R7	# ptr, #@addP_reg_reg
129c +  lb  R28, [R10]	# byte, #@loadB
12a0 +  li R29, #4	# int, #@loadConI
12a4 +  bne  R28, R29, B303	#@cmpI_branch  P=0.001000 C=-1.000000

12a8    B208: #	out( B293 B209 ) &lt;- in( B305 B306 B303 B207 B206 B205 )  Freq: 0.0135405
12a8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
12a8    lb  R7, [R23, #56]	# byte, #@loadB
12ac +  bne  R7, zr, B293	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

12b0    B209: #	out( B212 B210 ) &lt;- in( B395 B295 B293 B208 )  Freq: 0.0135405
12b0 +  mv  R7, R20	# ptr -&gt; long, #@castP2X
12b4 +  mv  R28, R21	# ptr -&gt; long, #@castP2X
12b8 +  xorr  R28, R28, R7	#@xorL_reg_reg
12bc +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
12c0 +  sw  R19, [R20, #24]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.stream
12c4 +  beq  R28, zr, B212	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

12c8    B210: #	out( B212 B211 ) &lt;- in( B209 )  Freq: 0.013527
12c8 +  beq   R21, zr, B212	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

12cc    B211: #	out( B307 B212 ) &lt;- in( B210 )  Freq: 0.0135134
12cc +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
12d0 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
12dc +  add R10, R28, R7	# ptr, #@addP_reg_reg
12e0 +  lb  R28, [R10]	# byte, #@loadB
12e4 +  li R7, #4	# int, #@loadConI
12e8 +  bne  R28, R7, B307	#@cmpI_branch  P=0.001000 C=-1.000000

12ec    B212: #	out( B526 B213 ) &lt;- in( B309 B310 B307 B211 B210 B209 )  Freq: 0.0135405
12ec +  spill R20 -&gt; R8	# spill size = 64
12f0 +  spill R21 -&gt; R11	# spill size = 64
12f4    CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.nio.file.DirectoryStream::iterator
        # java.nio.file.FileTreeWalker$DirectoryNode::&lt;init&gt; @ bci:21 (line 78) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=R8
        # java.nio.file.FileTreeWalker::visit @ bci:184 (line 311) L[0]=_ L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #48 STK[1]=R8
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop off=4880/0x1310}

1310    B213: #	out( B296 B214 ) &lt;- in( B212 )  Freq: 0.0135402
        # Block is sole successor of call
1310 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1310    lb  R28, [R23, #56]	# byte, #@loadB
1314    spill R10 -&gt; R9	# spill size = 64
1318 +  bne  R28, zr, B296	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

131c    B214: #	out( B215 ) &lt;- in( B213 )  Freq: 0.0135267
131c +  spill R8 -&gt; R18	# spill size = 64

1320    B215: #	out( B218 B216 ) &lt;- in( B396 B298 B296 B214 )  Freq: 0.0135402
1320 +  mv  R7, R18	# ptr -&gt; long, #@castP2X
1324    spill R9 -&gt; R30	# spill size = 64
1328 +  mv  R28, R30	# ptr -&gt; long, #@castP2X
132c +  xorr  R28, R28, R7	#@xorL_reg_reg
1330 +  encode_heap_oop  R29, R30	#@encodeHeapOop
1334 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
1338 +  sw  R29, [R18, #28]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.iterator
133c +  beq  R28, zr, B218	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1340    B216: #	out( B218 B217 ) &lt;- in( B215 )  Freq: 0.0135267
1340 +  beq   R30, zr, B218	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

1344    B217: #	out( B311 B218 ) &lt;- in( B216 )  Freq: 0.0135132
1344 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1348 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1354 +  add R10, R28, R7	# ptr, #@addP_reg_reg
1358 +  lb  R28, [R10]	# byte, #@loadB
135c +  li R29, #4	# int, #@loadConI
1360 +  bne  R28, R29, B311	#@cmpI_branch  P=0.001000 C=-1.000000

1364    B218: #	out( B387 B219 ) &lt;- in( B313 B314 B311 B217 B216 B215 )  Freq: 0.0135402
1364 +  #@membar_release
	fence iorw ow
1368 +  spill [sp, #48] -&gt; R7	# spill size = 64
136c +  far_beq   R7, zr, B387	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

1374    B219: #	out( B525 B220 ) &lt;- in( B218 )  Freq: 0.0135402
1374 +  spill [sp, #48] -&gt; R11	# spill size = 64
1378 +  spill R18 -&gt; R12	# spill size = 64
137c    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.ArrayDeque::addFirst
        # java.util.ArrayDeque::push @ bci:2 (line 579) L[0]=_ L[1]=_
        # java.nio.file.FileTreeWalker::visit @ bci:187 (line 311) L[0]=_ L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=4992/0x1380}

1380    B220: #	out( B319 B221 ) &lt;- in( B219 )  Freq: 0.01354
        # Block is sole successor of call
1380 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1380    ld  R10, [R23, #288]	# ptr, #@loadP
1384 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1384    ld  R7, [R23, #304]	# ptr, #@loadP
1388 +  addi  R28, R10, #32	# ptr, #@addP_reg_imm
138c +  bgeu  R28, R7, B319	#@cmpP_branch  P=0.000100 C=-1.000000

1390    B221: #	out( B222 ) &lt;- in( B220 )  Freq: 0.0135386
1390 +  li R7, #1	# long, #@loadConL
1394 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1394    sd  R28, [R23, #288]	# ptr, #@storeP
1398 +  sd  R7, [R10]	# long, #@storeL
139c +  mv  R7, narrowklass: precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d82188f0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
13ac +  sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
13b0 +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
13b4 +  sw  zr, [R10, #12]	# int, #@storeimmI0
13b8 +  ClearArray #2, R28	#@clearArray_imm_reg

13c0    B222: #	out( B524 B223 ) &lt;- in( B320 B221 )  Freq: 0.01354
13c0    
13c0    MEMBAR-store-store	#@membar_storestore
13c4 +  spill R10 -&gt; R8	# spill size = 64
13c8 +  # checkcastPP of R8, #@checkCastPP
13c8    mv  R12, java/nio/file/FileTreeWalker$EventType:exact *	# ptr, #@loadConP
13e0    spill R8 -&gt; R11	# spill size = 64
13e4 +  spill [sp, #40] -&gt; R13	# spill size = 64
13e8 +  spill [sp, #32] -&gt; R14	# spill size = 64
13ec +  mv  R15, NULL	# NULL ptr, #@loadConP0
13f0    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeWalker$Event::&lt;init&gt;
        # java.nio.file.FileTreeWalker$Event::&lt;init&gt; @ bci:5 (line 141) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.nio.file.FileTreeWalker::visit @ bci:200 (line 312) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=R8
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop off=5108/0x13f4}

13f4    B223: #	out( B150 ) &lt;- in( B222 )  Freq: 0.0135397
        # Block is sole successor of call
13f4 +  spill R8 -&gt; [sp, #0]	# spill size = 64
13f8 +  j  B150	#@branch

13fc    B224: #	out( B124 ) &lt;- in( B119 )  Freq: 0.0131538
13fc +  spill R17 -&gt; R8	# spill size = 64
1400 +  spill R11 -&gt; [sp, #4]	# spill size = 32
1404 +  spill R31 -&gt; [sp, #0]	# spill size = 32
1408 +  j  B124	#@branch

140c    B225: #	out( B40 B226 ) &lt;- in( B39 )  Freq: 0.000525771
140c +  lwu  R29, [R12, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
1410 +  decode_heap_oop  R10, R29	#@decodeHeapOop
1414 +  far_beq   R10, zr, B40	#@far_cmpP_imm0_branch  P=0.500000 C=-1.000000

141c    B226: #	out( B354 B227 ) &lt;- in( B225 )  Freq: 0.000262885
141c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
141c    ld  R7, [R23, #32]	# int, #@loadL
1420 +  beq  R7, zr, B354	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1424    B227: #	out( B40 ) &lt;- in( B226 )  Freq: 0.000262622
1424 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1424    ld  R29, [R23, #48]	# ptr, #@loadP
1428 +  add R29, R29, R7	# ptr, #@addP_reg_reg
142c +  addi  R7, R7, #-8	#@addL_reg_imm
1430 +  sd  R10, [R29, #-8]	# ptr, #@storeP
1434 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1434    sd  R7, [R23, #32]	# long, #@storeL
1438 +  j  B40	#@branch

143c    B228: #	out( B25 B229 ) &lt;- in( B24 )  Freq: 0.000499207
143c +  lwu  R28, [R21, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
1440 +  decode_heap_oop  R10, R28	#@decodeHeapOop
1444 +  far_beq   R10, zr, B25	#@far_cmpP_imm0_branch  P=0.500000 C=-1.000000

144c    B229: #	out( B360 B230 ) &lt;- in( B228 )  Freq: 0.000249604
144c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
144c    ld  R7, [R23, #32]	# int, #@loadL
1450 +  beq  R7, zr, B360	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1454    B230: #	out( B25 ) &lt;- in( B229 )  Freq: 0.000249354
1454 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1454    ld  R28, [R23, #48]	# ptr, #@loadP
1458 +  add R28, R28, R7	# ptr, #@addP_reg_reg
145c +  addi  R7, R7, #-8	#@addL_reg_imm
1460 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1464 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1464    sd  R7, [R23, #32]	# long, #@storeL
1468 +  j  B25	#@branch

146c    B231: #	out( B74 B232 ) &lt;- in( B73 )  Freq: 0.000499185
146c +  lwu  R7, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
1470 +  decode_heap_oop  R10, R7	#@decodeHeapOop
1474 +  beq   R10, zr, B74	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1478    B232: #	out( B361 B233 ) &lt;- in( B231 )  Freq: 0.000249593
1478 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1478    ld  R7, [R23, #32]	# int, #@loadL
147c +  beq  R7, zr, B361	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1480    B233: #	out( B74 ) &lt;- in( B232 )  Freq: 0.000249343
1480 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1480    ld  R28, [R23, #48]	# ptr, #@loadP
1484 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1488 +  addi  R7, R7, #-8	#@addL_reg_imm
148c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1490 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1490    sd  R7, [R23, #32]	# long, #@storeL
1494 +  j  B74	#@branch

1498    B234: #	out( B156 B235 ) &lt;- in( B154 )  Freq: 0.000499127
1498 +  spill [sp, #8] -&gt; R18	# spill size = 64
149c +  lwu  R7, [R18, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.next
14a0 +  decode_heap_oop  R10, R7	#@decodeHeapOop
14a4 +  beq   R10, zr, B156	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

14a8    B235: #	out( B362 B236 ) &lt;- in( B234 )  Freq: 0.000249563
14a8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
14a8    ld  R7, [R23, #32]	# int, #@loadL
14ac +  beq  R7, zr, B362	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

14b0    B236: #	out( B156 ) &lt;- in( B235 )  Freq: 0.000249314
14b0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
14b0    ld  R28, [R23, #48]	# ptr, #@loadP
14b4 +  add R28, R28, R7	# ptr, #@addP_reg_reg
14b8 +  addi  R7, R7, #-8	#@addL_reg_imm
14bc +  sd  R10, [R28, #-8]	# ptr, #@storeP
14c0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
14c0    sd  R7, [R23, #32]	# long, #@storeL
14c4 +  j  B156	#@branch

14c8    B237: #	out( B27 B238 ) &lt;- in( B26 )  Freq: 0.000498714
14c8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
14c8    ld  R7, [R23, #64]	# int, #@loadL
14cc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
14cc    ld  R29, [R23, #80]	# ptr, #@loadP
14d0 +  #@membar_volatile
	fence iorw iorw
14d4 +  lb  R30, [R10]	# byte, #@loadB
14d8 +  far_beq  R30, zr, B27	#@far_cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

14e0    B238: #	out( B240 B239 ) &lt;- in( B237 )  Freq: 0.000249357
14e0 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
14e4 +  bne  R7, zr, B240	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

14e8    B239: #	out( B27 ) &lt;- in( B238 )  Freq: 0.000124679
14e8 +  spill R28 -&gt; R26	# spill size = 32
14f0    
14f0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
14f0    spill R23 -&gt; R11	# spill size = 64
14f4 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1524 +  spill R21 -&gt; R22	# spill size = 64
1528 +  spill R20 -&gt; R21	# spill size = 64
152c +  spill R19 -&gt; R20	# spill size = 64
1530 +  spill R20 -&gt; R19	# spill size = 64
1534 +  spill R21 -&gt; R20	# spill size = 64
1538 +  spill R22 -&gt; R21	# spill size = 64
153c +  spill R26 -&gt; R28	# spill size = 32
1544 +  j  B27	#@branch

1548    B240: #	out( B27 ) &lt;- in( B238 )  Freq: 0.000124679
1548 +  add R29, R29, R7	# ptr, #@addP_reg_reg
154c +  addi  R7, R7, #-8	#@addL_reg_imm
1550 +  sd  R10, [R29, #-8]	# ptr, #@storeP
1554 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1554    sd  R7, [R23, #64]	# long, #@storeL
1558 +  j  B27	#@branch

155c    B241: #	out( B245 B242 ) &lt;- in( B76 )  Freq: 0.000498194
155c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
155c    ld  R7, [R23, #64]	# int, #@loadL
1560 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1560    ld  R28, [R23, #80]	# ptr, #@loadP
1564 +  #@membar_volatile
	fence iorw iorw
1568 +  lb  R30, [R10]	# byte, #@loadB
156c +  beq  R30, zr, B245	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1570    B242: #	out( B244 B243 ) &lt;- in( B241 )  Freq: 0.000249097
1570 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1574 +  beq  R7, zr, B244	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1578    B243: #	out( B245 ) &lt;- in( B242 )  Freq: 0.000124548
1578 +  add R28, R28, R7	# ptr, #@addP_reg_reg
157c +  addi  R7, R7, #-8	#@addL_reg_imm
1580 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1584 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1584    sd  R7, [R23, #64]	# long, #@storeL
1588 +  j  B245	#@branch

158c    B244: #	out( B245 ) &lt;- in( B242 )  Freq: 0.000124548
158c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
158c    spill R23 -&gt; R11	# spill size = 64
1590 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 

15c0    B245: #	out( B77 ) &lt;- in( B244 B243 B241 )  Freq: 0.000498194
15c0    lwu  R9, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
15c4 +  j  B77	#@branch

15c8    B246: #	out( B63 ) &lt;- in( B61 )  Freq: 0.000485542
15c8 +  addi  R28, R26, #16	#@addL_reg_imm
15cc +  srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
15d0 +  andi  R28, R28, #-8	#@andL_reg_imm
15d4 +  add R28, R24, R28	# ptr, #@addP_reg_reg
15d8 +  sub  R29, R7, R29	#@subL_reg_reg
15dc    ClearArray R29, R28	#@clearArray_reg_reg
1634 +  spill R31 -&gt; [sp, #40]	# spill size = 64
1638    
1638    
1638 +  spill R22 -&gt; R25	# spill size = 64
163c +  spill R30 -&gt; R22	# spill size = 64
1640    
1640    
1640 +  spill R26 -&gt; R12	# spill size = 64
1644 +  CALL, runtime leaf nofp 0x000000401396cf00	#@CallLeafNoFPDirect arrayof_jbyte_disjoint_arraycopy
        No JVM State Info
        # 
1648 +  spill R21 -&gt; [sp, #0]	# spill size = 32
164c +  spill R9 -&gt; R21	# spill size = 32
1650 +  spill R22 -&gt; R30	# spill size = 64
1654 +  spill R18 -&gt; R8	# spill size = 32
1658 +  spill R21 -&gt; R9	# spill size = 32
165c +  spill R25 -&gt; R22	# spill size = 64
1660 +  spill R8 -&gt; R18	# spill size = 32
1664 +  spill [sp, #0] -&gt; R21	# spill size = 32
1668 +  spill [sp, #40] -&gt; R31	# spill size = 64
166c +  j  B63	#@branch

1670    B247: #	out( B82 B248 ) &lt;- in( B81 )  Freq: 0.000484969
1670 +  lwu  R7, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
1674 +  decode_heap_oop  R10, R7	#@decodeHeapOop
1678 +  beq   R10, zr, B82	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

167c    B248: #	out( B366 B249 ) &lt;- in( B247 )  Freq: 0.000242484
167c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
167c    ld  R7, [R23, #32]	# int, #@loadL
1680 +  beq  R7, zr, B366	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1684    B249: #	out( B82 ) &lt;- in( B248 )  Freq: 0.000242242
1684 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1684    ld  R28, [R23, #48]	# ptr, #@loadP
1688 +  add R28, R28, R7	# ptr, #@addP_reg_reg
168c +  addi  R7, R7, #-8	#@addL_reg_imm
1690 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1694 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1694    sd  R7, [R23, #32]	# long, #@storeL
1698 +  j  B82	#@branch

169c    B250: #	out( B119 B251 ) &lt;- in( B118 )  Freq: 0.00048478
169c +  lwu  R10, [R18, #16]	# loadN, compressed ptr, #@loadN
16a0 +  decode_heap_oop  R10, R10	#@decodeHeapOop
16a4 +  beq   R10, zr, B119	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

16a8    B251: #	out( B368 B252 ) &lt;- in( B250 )  Freq: 0.00024239
16a8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16a8    ld  R28, [R23, #32]	# int, #@loadL
16ac +  beq  R28, zr, B368	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

16b0    B252: #	out( B119 ) &lt;- in( B251 )  Freq: 0.000242147
16b0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16b0    ld  R13, [R23, #48]	# ptr, #@loadP
16b4 +  add R13, R13, R28	# ptr, #@addP_reg_reg
16b8 +  addi  R28, R28, #-8	#@addL_reg_imm
16bc +  sd  R10, [R13, #-8]	# ptr, #@storeP
16c0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16c0    sd  R28, [R23, #32]	# long, #@storeL
16c4 +  j  B119	#@branch

16c8    B253: #	out( B136 B254 ) &lt;- in( B135 )  Freq: 0.000484766
16c8 +  lwu  R7, [R9]	# loadN, compressed ptr, #@loadN
16cc +  decode_heap_oop  R10, R7	#@decodeHeapOop
16d0 +  beq   R10, zr, B136	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

16d4    B254: #	out( B370 B255 ) &lt;- in( B253 )  Freq: 0.000242383
16d4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16d4    ld  R7, [R23, #32]	# int, #@loadL
16d8 +  beq  R7, zr, B370	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

16dc    B255: #	out( B136 ) &lt;- in( B254 )  Freq: 0.000242141
16dc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16dc    ld  R28, [R23, #48]	# ptr, #@loadP
16e0 +  add R28, R28, R7	# ptr, #@addP_reg_reg
16e4 +  addi  R7, R7, #-8	#@addL_reg_imm
16e8 +  sd  R10, [R28, #-8]	# ptr, #@storeP
16ec +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16ec    sd  R7, [R23, #32]	# long, #@storeL
16f0 +  j  B136	#@branch

16f4    B256: #	out( B138 B257 ) &lt;- in( B137 )  Freq: 0.000484288
16f4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16f4    ld  R7, [R23, #64]	# int, #@loadL
16f8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16f8    ld  R28, [R23, #80]	# ptr, #@loadP
16fc +  #@membar_volatile
	fence iorw iorw
1700 +  lb  R30, [R10]	# byte, #@loadB
1704 +  beq  R30, zr, B138	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1708    B257: #	out( B259 B258 ) &lt;- in( B256 )  Freq: 0.000242144
1708 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
170c +  bne  R7, zr, B259	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1710    B258: #	out( B138 ) &lt;- in( B257 )  Freq: 0.000121072
1710 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1710    spill R23 -&gt; R11	# spill size = 64
1714 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1744 +  j  B138	#@branch

1748    B259: #	out( B138 ) &lt;- in( B257 )  Freq: 0.000121072
1748 +  add R28, R28, R7	# ptr, #@addP_reg_reg
174c +  addi  R7, R7, #-8	#@addL_reg_imm
1750 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1754 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1754    sd  R7, [R23, #64]	# long, #@storeL
1758 +  j  B138	#@branch

175c    B260: #	out( B121 B261 ) &lt;- in( B120 )  Freq: 0.000471626
175c +  lwu  R28, [R21, #28]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/NativeBuffer.owner
1760 +  decode_heap_oop  R10, R28	#@decodeHeapOop
1764 +  beq   R10, zr, B121	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1768    B261: #	out( B374 B262 ) &lt;- in( B260 )  Freq: 0.000235813
1768 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1768    ld  R7, [R23, #32]	# int, #@loadL
176c +  beq  R7, zr, B374	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1770    B262: #	out( B121 ) &lt;- in( B261 )  Freq: 0.000235577
1770 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1770    ld  R28, [R23, #48]	# ptr, #@loadP
1774 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1778 +  addi  R7, R7, #-8	#@addL_reg_imm
177c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1780 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1780    sd  R7, [R23, #32]	# long, #@storeL
1784 +  j  B121	#@branch

1788    B263: #	out( B267 B264 ) &lt;- in( B122 )  Freq: 0.00047116
1788 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1788    ld  R28, [R23, #64]	# int, #@loadL
178c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
178c    ld  R29, [R23, #80]	# ptr, #@loadP
1790 +  #@membar_volatile
	fence iorw iorw
1794 +  lb  R30, [R10]	# byte, #@loadB
1798 +  beq  R30, zr, B267	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

179c    B264: #	out( B266 B265 ) &lt;- in( B263 )  Freq: 0.00023558
179c +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
17a0 +  beq  R28, zr, B266	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

17a4    B265: #	out( B267 ) &lt;- in( B264 )  Freq: 0.00011779
17a4 +  add R29, R29, R28	# ptr, #@addP_reg_reg
17a8 +  addi  R28, R28, #-8	#@addL_reg_imm
17ac +  sd  R10, [R29, #-8]	# ptr, #@storeP
17b0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
17b0    sd  R28, [R23, #64]	# long, #@storeL
17b4 +  j  B267	#@branch

17b8    B266: #	out( B267 ) &lt;- in( B264 )  Freq: 0.00011779
17b8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
17b8    spill R23 -&gt; R11	# spill size = 64
17bc +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
17ec +  spill R18 -&gt; R7	# spill size = 64

17f0    B267: #	out( B123 ) &lt;- in( B266 B265 B263 )  Freq: 0.00047116
17f0 +  ld  R24, [R21, #16]	# int, #@loadL ! Field: sun/nio/fs/NativeBuffer.address
17f4 +  j  B123	#@branch

17f8    B268: #	out( B461 B269 ) &lt;- in( B102 )  Freq: 0.000180146
17f8 +  spill R11 -&gt; [sp, #4]	# spill size = 32
17fc +  spill R30 -&gt; [sp, #32]	# spill size = 64
1800 +  spill R9 -&gt; [sp, #48]	# spill size = 32
1804 +  spill R7 -&gt; [sp, #40]	# spill size = 64
1808 +  spill R29 -&gt; [sp, #16]	# spill size = 64
180c +  spill R7 -&gt; R11	# spill size = 64
1810 +  spill R30 -&gt; R12	# spill size = 64
1814    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect sun.nio.fs.UnixNativeDispatcher::stat
        # sun.nio.fs.UnixFileAttributes::get @ bci:14 (line 70) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=6168/0x1818}

1818    B269: #	out( B138 ) &lt;- in( B268 )  Freq: 0.000180142
        # Block is sole successor of call
1818 +  j  B138	#@branch

181c    B270: #	out( B505 B271 ) &lt;- in( B57 B58 )  Freq: 4.90542e-05
181c +  spill R26 -&gt; [sp, #96]	# spill size = 64
1820 +  spill R31 -&gt; [sp, #88]	# spill size = 64
1824 +  spill R21 -&gt; [sp, #80]	# spill size = 32
1828 +  spill R18 -&gt; [sp, #52]	# spill size = 32
182c +  spill R28 -&gt; [sp, #72]	# spill size = 64
1830 +  spill R22 -&gt; [sp, #64]	# spill size = 64
1834 +  spill R30 -&gt; [sp, #56]	# spill size = 64
1838 +  spill R9 -&gt; [sp, #48]	# spill size = 32
183c +  spill R20 -&gt; [sp, #40]	# spill size = 64
1840 +  mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
1858    spill R21 -&gt; R12	# spill size = 32
185c    CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::resolve @ bci:69 (line 369) L[0]=sp + #72 L[1]=sp + #40 L[2]=sp + #52 L[3]=sp + #48 L[4]=_
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #64 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Derived_oop_[40] [64]=Oop [72]=Oop off=6240/0x1860}

1860    B271: #	out( B60 ) &lt;- in( B270 )  Freq: 4.90532e-05
        # Block is sole successor of call
1860 +  spill [sp, #0] -&gt; R19	# spill size = 64
1864 +  spill [sp, #40] -&gt; R20	# spill size = 64
1868 +  spill [sp, #48] -&gt; R9	# spill size = 32
186c +  spill [sp, #56] -&gt; R30	# spill size = 64
1870 +  spill [sp, #64] -&gt; R22	# spill size = 64
1874 +  spill [sp, #72] -&gt; R28	# spill size = 64
1878 +  spill [sp, #52] -&gt; R18	# spill size = 32
187c +  spill [sp, #80] -&gt; R21	# spill size = 32
1880 +  spill [sp, #88] -&gt; R31	# spill size = 64
1884 +  spill [sp, #96] -&gt; R26	# spill size = 64
1888 +  spill R10 -&gt; R24	# spill size = 64
188c +  j  B60	#@branch

1890    B272: #	out( B506 B273 ) &lt;- in( B67 )  Freq: 4.85622e-05
1890 +  spill R24 -&gt; [sp, #40]	# spill size = 64
1894 +  spill R22 -&gt; R8	# spill size = 64
1898 +  spill R19 -&gt; [sp, #0]	# spill size = 64
189c +  mv  R11, precise klass sun/nio/fs/UnixPath: 0x00000040d82bfa70:Constant:exact *	# ptr, #@loadConP
18b4    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixPath::resolve @ bci:35 (line 383) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #40
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=6328/0x18b8}

18b8    B273: #	out( B69 ) &lt;- in( B272 )  Freq: 4.85612e-05
        # Block is sole successor of call
18b8 +  spill [sp, #0] -&gt; R19	# spill size = 64
18bc +  spill R8 -&gt; R22	# spill size = 64
18c0 +  spill [sp, #40] -&gt; R24	# spill size = 64
18c4 +  spill R10 -&gt; R18	# spill size = 64
18c8 +  j  B69	#@branch

18cc    B274: #	out( B460 B275 ) &lt;- in( B100 )  Freq: 4.85052e-05
18cc +  spill R9 -&gt; [sp, #48]	# spill size = 32
18d0 +  spill R7 -&gt; [sp, #40]	# spill size = 64
18d4 +  spill R29 -&gt; [sp, #16]	# spill size = 64
18d8 +  mv  R11, precise klass sun/nio/fs/UnixFileAttributes: 0x00000040d819cfa0:Constant:exact *	# ptr, #@loadConP
18f0    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixFileAttributes::get @ bci:0 (line 68) L[0]=sp + #40 L[1]=sp + #48 L[2]=_
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=6388/0x18f4}

18f4    B275: #	out( B102 ) &lt;- in( B274 )  Freq: 4.85042e-05
        # Block is sole successor of call
18f4 +  spill [sp, #16] -&gt; R29	# spill size = 64
18f8 +  spill [sp, #40] -&gt; R7	# spill size = 64
18fc +  spill [sp, #48] -&gt; R9	# spill size = 32
1900 +  j  B102	#@branch

1904    B276: #	out( B449 B277 ) &lt;- in( B138 )  Freq: 4.85033e-05
1904 +  mv  R11, precise klass sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes: 0x00000040d01c5d50:Constant:exact *	# ptr, #@loadConP
191c    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes::wrap @ bci:0 (line 274) L[0]=sp + #32
        # sun.nio.fs.UnixFileAttributes::asBasicFileAttributes @ bci:1 (line 251) L[0]=_
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:20 (line 53) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=6432/0x1920}

1920    B277: #	out( B140 ) &lt;- in( B276 )  Freq: 4.85023e-05
        # Block is sole successor of call
1920 +  j  B140	#@branch

1924    B278: #	out( B523 B279 ) &lt;- in( B146 )  Freq: 4.71488e-05
1924 +  spill R30 -&gt; [sp, #0]	# spill size = 64
1928 +  mv  R11, precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d82188f0:Constant:exact *	# ptr, #@loadConP
1940    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.nio.file.FileTreeWalker::visit @ bci:66 (line 289) L[0]=_ L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop off=6468/0x1944}

1944    B279: #	out( B148 ) &lt;- in( B278 )  Freq: 4.71478e-05
        # Block is sole successor of call
1944 +  spill [sp, #16] -&gt; R31	# spill size = 64
1948 +  spill [sp, #0] -&gt; R30	# spill size = 64
194c +  j  B148	#@branch

1950    B280: #	out( B178 B281 ) &lt;- in( B177 )  Freq: 2.6568e-05
1950 +  lwu  R28, [R30, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
1954 +  decode_heap_oop  R10, R28	#@decodeHeapOop
1958 +  beq   R10, zr, B178	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

195c    B281: #	out( B389 B282 ) &lt;- in( B280 )  Freq: 1.3284e-05
195c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
195c    ld  R7, [R23, #32]	# int, #@loadL
1960 +  far_beq  R7, zr, B389	#@far_cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1968    B282: #	out( B178 ) &lt;- in( B281 )  Freq: 1.32707e-05
1968 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1968    ld  R28, [R23, #48]	# ptr, #@loadP
196c +  add R28, R28, R7	# ptr, #@addP_reg_reg
1970 +  addi  R7, R7, #-8	#@addL_reg_imm
1974 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1978 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1978    sd  R7, [R23, #32]	# long, #@storeL
197c +  j  B178	#@branch

1980    B283: #	out( B180 B284 ) &lt;- in( B179 )  Freq: 2.65418e-05
1980 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1980    ld  R7, [R23, #64]	# int, #@loadL
1984 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1984    ld  R29, [R23, #80]	# ptr, #@loadP
1988 +  #@membar_volatile
	fence iorw iorw
198c +  lb  R11, [R10]	# byte, #@loadB
1990 +  beq  R11, zr, B180	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1994    B284: #	out( B286 B285 ) &lt;- in( B283 )  Freq: 1.32709e-05
1994 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1998 +  bne  R7, zr, B286	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

199c    B285: #	out( B180 ) &lt;- in( B284 )  Freq: 6.63545e-06
199c +  spill R30 -&gt; R22	# spill size = 64
19a0    
19a0    
19a0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
19a0    spill R23 -&gt; R11	# spill size = 64
19a4 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
19d4 +  spill [sp, #40] -&gt; R28	# spill size = 32
19d8 +  spill R22 -&gt; R30	# spill size = 64
19dc +  j  B180	#@branch

19e0    B286: #	out( B180 ) &lt;- in( B284 )  Freq: 6.63545e-06
19e0 +  add R29, R29, R7	# ptr, #@addP_reg_reg
19e4 +  addi  R7, R7, #-8	#@addL_reg_imm
19e8 +  sd  R10, [R29, #-8]	# ptr, #@storeP
19ec +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
19ec    sd  R7, [R23, #64]	# long, #@storeL
19f0 +  j  B180	#@branch

19f4    B287: #	out( B202 B288 ) &lt;- in( B200 )  Freq: 1.35403e-05
19f4 +  spill [sp, #56] -&gt; R20	# spill size = 64
19f8 +  lwu  R28, [R20, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.dir
19fc +  decode_heap_oop  R10, R28	#@decodeHeapOop
1a00 +  beq   R10, zr, B202	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1a04    B288: #	out( B393 B289 ) &lt;- in( B287 )  Freq: 6.77017e-06
1a04 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a04    ld  R7, [R23, #32]	# int, #@loadL
1a08 +  far_beq  R7, zr, B393	#@far_cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1a10    B289: #	out( B202 ) &lt;- in( B288 )  Freq: 6.7634e-06
1a10 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a10    ld  R28, [R23, #48]	# ptr, #@loadP
1a14 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1a18 +  addi  R7, R7, #-8	#@addL_reg_imm
1a1c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1a20 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a20    sd  R7, [R23, #32]	# long, #@storeL
1a24 +  j  B202	#@branch

1a28    B290: #	out( B205 B291 ) &lt;- in( B204 )  Freq: 1.35403e-05
1a28 +  lwu  R28, [R20, #20]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.key
1a2c +  decode_heap_oop  R10, R28	#@decodeHeapOop
1a30 +  beq   R10, zr, B205	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1a34    B291: #	out( B394 B292 ) &lt;- in( B290 )  Freq: 6.77017e-06
1a34 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a34    ld  R7, [R23, #32]	# int, #@loadL
1a38 +  far_beq  R7, zr, B394	#@far_cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1a40    B292: #	out( B205 ) &lt;- in( B291 )  Freq: 6.7634e-06
1a40 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a40    ld  R28, [R23, #48]	# ptr, #@loadP
1a44 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1a48 +  addi  R7, R7, #-8	#@addL_reg_imm
1a4c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1a50 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a50    sd  R7, [R23, #32]	# long, #@storeL
1a54 +  j  B205	#@branch

1a58    B293: #	out( B209 B294 ) &lt;- in( B208 )  Freq: 1.35403e-05
1a58 +  lwu  R28, [R20, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.stream
1a5c +  decode_heap_oop  R10, R28	#@decodeHeapOop
1a60 +  beq   R10, zr, B209	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1a64    B294: #	out( B395 B295 ) &lt;- in( B293 )  Freq: 6.77017e-06
1a64 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a64    ld  R7, [R23, #32]	# int, #@loadL
1a68 +  far_beq  R7, zr, B395	#@far_cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1a70    B295: #	out( B209 ) &lt;- in( B294 )  Freq: 6.7634e-06
1a70 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a70    ld  R28, [R23, #48]	# ptr, #@loadP
1a74 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1a78 +  addi  R7, R7, #-8	#@addL_reg_imm
1a7c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1a80 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a80    sd  R7, [R23, #32]	# long, #@storeL
1a84 +  j  B209	#@branch

1a88    B296: #	out( B215 B297 ) &lt;- in( B213 )  Freq: 1.35401e-05
1a88 +  spill R8 -&gt; R18	# spill size = 64
1a8c +  lwu  R7, [R18, #28]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.iterator
1a90 +  decode_heap_oop  R10, R7	#@decodeHeapOop
1a94 +  beq   R10, zr, B215	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1a98    B297: #	out( B396 B298 ) &lt;- in( B296 )  Freq: 6.77003e-06
1a98 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a98    ld  R7, [R23, #32]	# int, #@loadL
1a9c +  far_beq  R7, zr, B396	#@far_cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1aa4    B298: #	out( B215 ) &lt;- in( B297 )  Freq: 6.76326e-06
1aa4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1aa4    ld  R28, [R23, #48]	# ptr, #@loadP
1aa8 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1aac +  addi  R7, R7, #-8	#@addL_reg_imm
1ab0 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1ab4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ab4    sd  R7, [R23, #32]	# long, #@storeL
1ab8 +  j  B215	#@branch

1abc    B299: #	out( B204 B300 ) &lt;- in( B203 )  Freq: 1.3527e-05
1abc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1abc    ld  R7, [R23, #64]	# int, #@loadL
1ac0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ac0    ld  R28, [R23, #80]	# ptr, #@loadP
1ac4 +  #@membar_volatile
	fence iorw iorw
1ac8 +  lb  R29, [R10]	# byte, #@loadB
1acc +  beq  R29, zr, B204	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1ad0    B300: #	out( B302 B301 ) &lt;- in( B299 )  Freq: 6.76349e-06
1ad0 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1ad4 +  bne  R7, zr, B302	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1ad8    B301: #	out( B204 ) &lt;- in( B300 )  Freq: 3.38174e-06
1ad8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ad8    spill R23 -&gt; R11	# spill size = 64
1adc +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1b0c +  j  B204	#@branch

1b10    B302: #	out( B204 ) &lt;- in( B300 )  Freq: 3.38174e-06
1b10 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1b14 +  addi  R7, R7, #-8	#@addL_reg_imm
1b18 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1b1c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b1c    sd  R7, [R23, #64]	# long, #@storeL
1b20 +  j  B204	#@branch

1b24    B303: #	out( B208 B304 ) &lt;- in( B207 )  Freq: 1.35134e-05
1b24 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b24    ld  R7, [R23, #64]	# int, #@loadL
1b28 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b28    ld  R28, [R23, #80]	# ptr, #@loadP
1b2c +  #@membar_volatile
	fence iorw iorw
1b30 +  lb  R29, [R10]	# byte, #@loadB
1b34 +  beq  R29, zr, B208	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1b38    B304: #	out( B306 B305 ) &lt;- in( B303 )  Freq: 6.75672e-06
1b38 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1b3c +  bne  R7, zr, B306	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1b40    B305: #	out( B208 ) &lt;- in( B304 )  Freq: 3.37836e-06
1b40 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b40    spill R23 -&gt; R11	# spill size = 64
1b44 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1b74 +  j  B208	#@branch

1b78    B306: #	out( B208 ) &lt;- in( B304 )  Freq: 3.37836e-06
1b78 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1b7c +  addi  R7, R7, #-8	#@addL_reg_imm
1b80 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1b84 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b84    sd  R7, [R23, #64]	# long, #@storeL
1b88 +  j  B208	#@branch

1b8c    B307: #	out( B212 B308 ) &lt;- in( B211 )  Freq: 1.35134e-05
1b8c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b8c    ld  R7, [R23, #64]	# int, #@loadL
1b90 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b90    ld  R28, [R23, #80]	# ptr, #@loadP
1b94 +  #@membar_volatile
	fence iorw iorw
1b98 +  lb  R29, [R10]	# byte, #@loadB
1b9c +  beq  R29, zr, B212	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1ba0    B308: #	out( B310 B309 ) &lt;- in( B307 )  Freq: 6.75672e-06
1ba0 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1ba4 +  bne  R7, zr, B310	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1ba8    B309: #	out( B212 ) &lt;- in( B308 )  Freq: 3.37836e-06
1ba8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ba8    spill R23 -&gt; R11	# spill size = 64
1bac +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1bdc +  j  B212	#@branch

1be0    B310: #	out( B212 ) &lt;- in( B308 )  Freq: 3.37836e-06
1be0 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1be4 +  addi  R7, R7, #-8	#@addL_reg_imm
1be8 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1bec +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1bec    sd  R7, [R23, #64]	# long, #@storeL
1bf0 +  j  B212	#@branch

1bf4    B311: #	out( B218 B312 ) &lt;- in( B217 )  Freq: 1.35132e-05
1bf4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1bf4    ld  R7, [R23, #64]	# int, #@loadL
1bf8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1bf8    ld  R28, [R23, #80]	# ptr, #@loadP
1bfc +  #@membar_volatile
	fence iorw iorw
1c00 +  lb  R29, [R10]	# byte, #@loadB
1c04 +  beq  R29, zr, B218	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1c08    B312: #	out( B314 B313 ) &lt;- in( B311 )  Freq: 6.75659e-06
1c08 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1c0c +  bne  R7, zr, B314	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1c10    B313: #	out( B218 ) &lt;- in( B312 )  Freq: 3.37829e-06
1c10 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1c10    spill R23 -&gt; R11	# spill size = 64
1c14 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1c44 +  j  B218	#@branch

1c48    B314: #	out( B218 ) &lt;- in( B312 )  Freq: 3.37829e-06
1c48 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1c4c +  addi  R7, R7, #-8	#@addL_reg_imm
1c50 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1c54 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1c54    sd  R7, [R23, #64]	# long, #@storeL
1c58 +  j  B218	#@branch

1c5c    B315: #	out( B521 B316 ) &lt;- in( B190 )  Freq: 1.42181e-06
1c5c +  mv  R11, precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d82188f0:Constant:exact *	# ptr, #@loadConP
1c74    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.nio.file.FileTreeWalker::next @ bci:113 (line 370) L[0]=_ L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop off=7288/0x1c78}

1c78    B316: #	out( B192 ) &lt;- in( B315 )  Freq: 1.42178e-06
        # Block is sole successor of call
1c78 +  j  B192	#@branch

1c7c    B317: #	out( B520 B318 ) &lt;- in( B197 )  Freq: 1.3543e-06
1c7c +  spill R31 -&gt; [sp, #48]	# spill size = 64
1c80 +  mv  R11, precise klass java/nio/file/FileTreeWalker$DirectoryNode: 0x00000040d83de560:Constant:exact *	# ptr, #@loadConP
1c98    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.nio.file.FileTreeWalker::visit @ bci:170 (line 311) L[0]=_ L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=R8 L[7]=_ STK[0]=sp + #48
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop off=7324/0x1c9c}

1c9c    B318: #	out( B199 ) &lt;- in( B317 )  Freq: 1.35428e-06
        # Block is sole successor of call
1c9c +  j  B199	#@branch

1ca0    B319: #	out( B519 B320 ) &lt;- in( B220 )  Freq: 1.35422e-06
1ca0 +  mv  R11, precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d82188f0:Constant:exact *	# ptr, #@loadConP
1cb8    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.nio.file.FileTreeWalker::visit @ bci:190 (line 312) L[0]=_ L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=7356/0x1cbc}

1cbc    B320: #	out( B222 ) &lt;- in( B319 )  Freq: 1.35419e-06
        # Block is sole successor of call
1cbc +  j  B222	#@branch

1cc0    B321: #	out( N6590 ) &lt;- in( B35 )  Freq: 5.25779e-07
1cc0 +  spill [sp, #8] -&gt; R7	# spill size = 64
1cc4 +  li R11, #-34	# int, #@loadConI
1cc8    spill R7 -&gt; [sp, #0]	# spill size = 64
1ccc +  spill R28 -&gt; [sp, #32]	# spill size = 64
1cd0 +  spill R28 -&gt; [sp, #40]	# spill size = 64
1cd4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #32 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop off=7384/0x1cd8}
1cd8    #@ShouldNotReachHere

1ce4    B322: #	out( N6590 ) &lt;- in( B42 )  Freq: 5.25777e-07
1ce4 +  spill [sp, #8] -&gt; R7	# spill size = 64
1ce8 +  li R11, #-20	# int, #@loadConI
1cec    spill R7 -&gt; [sp, #0]	# spill size = 64
1cf0 +  spill R28 -&gt; [sp, #32]	# spill size = 64
1cf4 +  spill R28 -&gt; [sp, #40]	# spill size = 64
1cf8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_assert&apos; action=&apos;make_not_entrant&apos;)
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:12 (line 1095) L[0]=_ L[1]=_ STK[0]=R8
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #32 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop off=7420/0x1cfc}
1cfc    #@ShouldNotReachHere

1d08    B323: #	out( N6590 ) &lt;- in( B152 )  Freq: 5.13831e-07
1d08 +  spill [sp, #8] -&gt; R8	# spill size = 64
1d0c +  li R11, #-20	# int, #@loadConI
1d10    spill R10 -&gt; [sp, #8]	# spill size = 64
1d14    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_assert&apos; action=&apos;make_not_entrant&apos;)
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:23 (line 85) L[0]=R8 L[1]=sp + #0 L[2]=_ STK[0]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=7448/0x1d18}
1d18    #@ShouldNotReachHere

1d24    B324: #	out( N6590 ) &lt;- in( B45 )  Freq: 5.12114e-07
1d24 +  li R11, #-28	# int, #@loadConI
1d28    spill [sp, #8] -&gt; R8	# spill size = 64
1d2c +  spill R20 -&gt; [sp, #64]	# spill size = 64
1d30 +  spill R20 -&gt; [sp, #72]	# spill size = 64
1d34    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::isSelfOrParent @ bci:2 (line 145) L[0]=_ L[1]=sp + #72 STK[0]=sp + #64 STK[1]=#0
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:123 (line 181) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [64]=Oop [72]=Oop off=7480/0x1d38}
1d38    #@ShouldNotReachHere

1d44    B325: #	out( N6590 ) &lt;- in( B5 )  Freq: 5.06355e-07
1d44 +  li R11, #-28	# int, #@loadConI
1d48    spill R9 -&gt; [sp, #0]	# spill size = 64
1d4c +  spill R18 -&gt; [sp, #8]	# spill size = 64
1d50 +  spill R30 -&gt; [sp, #16]	# spill size = 32
1d54    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ArrayDeque::elementAt @ bci:2 (line 259) L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #16
        # java.util.ArrayDeque::peekFirst @ bci:8 (line 418) L[0]=_
        # java.util.ArrayDeque::peek @ bci:1 (line 564) L[0]=_
        # java.nio.file.FileTreeWalker::next @ bci:4 (line 335) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=7512/0x1d58}
1d58    #@ShouldNotReachHere

1d64    B326: #	out( N6590 ) &lt;- in( B10 )  Freq: 4.99218e-07
1d64 +  li R11, #-34	# int, #@loadConI
1d68    spill R9 -&gt; R8	# spill size = 64
1d6c +  spill R18 -&gt; [sp, #0]	# spill size = 64
1d70 +  spill R24 -&gt; [sp, #8]	# spill size = 64
1d74 +  spill R19 -&gt; [sp, #24]	# spill size = 64
1d78    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #24 L[6]=_ STK[0]=sp + #24
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop off=7548/0x1d7c}
1d7c    #@ShouldNotReachHere

1d88    B327: #	out( B12 ) &lt;- in( B11 )  Freq: 4.99218e-07
1d88 +  spill R20 -&gt; [sp, #24]	# spill size = 64
1d8c    
1d8c    
1d8c +  spill R11 -&gt; R8	# spill size = 64
1d90 +  spill R19 -&gt; [sp, #16]	# spill size = 64
1d94 +  spill R19 -&gt; R11	# spill size = 64
1d98    
1d98    
1d98 +  spill R18 -&gt; [sp, #0]	# spill size = 64
1d9c    
1d9c    
1d9c +  spill R24 -&gt; [sp, #8]	# spill size = 64
1da0    
1da0    
1da0    add R12, sp, #144	# box lock
1da4 +  CALL,static 0x000000401390c140	#@CallStaticJavaDirect wrapper for: _complete_monitor_locking_Java
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:-1 (line 197) L[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=7592/0x1da8}
1da8 +  spill R8 -&gt; R9	# spill size = 64
1dac +  spill [sp, #0] -&gt; R18	# spill size = 64
1db0 +  spill [sp, #8] -&gt; R24	# spill size = 64
1db4 +  spill [sp, #16] -&gt; R19	# spill size = 64
1db8 +  spill [sp, #24] -&gt; R20	# spill size = 64
1dbc +  j  B12	#@branch

1dc0    B328: #	out( N6590 ) &lt;- in( B17 )  Freq: 4.99216e-07
1dc0 +  li R11, #-34	# int, #@loadConI
1dc4    spill R9 -&gt; [sp, #0]	# spill size = 64
1dc8 +  spill R18 -&gt; [sp, #8]	# spill size = 64
1dcc +  spill R24 -&gt; [sp, #16]	# spill size = 64
1dd0 +  spill R19 -&gt; [sp, #32]	# spill size = 64
1dd4 +  spill R19 -&gt; [sp, #40]	# spill size = 64
1dd8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #32 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop off=7644/0x1ddc}
1ddc    #@ShouldNotReachHere

1de8    B329: #	out( N6590 ) &lt;- in( B20 )  Freq: 4.99215e-07
1de8 +  li R11, #-20	# int, #@loadConI
1dec    spill R9 -&gt; [sp, #0]	# spill size = 64
1df0 +  spill R18 -&gt; [sp, #8]	# spill size = 64
1df4 +  spill R24 -&gt; [sp, #16]	# spill size = 64
1df8 +  spill R19 -&gt; [sp, #32]	# spill size = 64
1dfc +  spill R19 -&gt; [sp, #40]	# spill size = 64
1e00 +  spill R21 -&gt; [sp, #72]	# spill size = 64
1e04 +  spill R20 -&gt; [sp, #80]	# spill size = 64
1e08 +  spill R31 -&gt; [sp, #88]	# spill size = 32
1e0c +  spill R28 -&gt; [sp, #92]	# spill size = 32
1e10 +  spill R21 -&gt; [sp, #96]	# spill size = 64
1e14    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_assert&apos; action=&apos;make_not_entrant&apos;)
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::hasQueuedPredecessors @ bci:6 (line 1234) L[0]=sp + #72 L[1]=#NULL L[2]=_ L[3]=_ STK[0]=R8
        # java.util.concurrent.locks.ReentrantReadWriteLock$FairSync::readerShouldBlock @ bci:1 (line 706) L[0]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:33 (line 475) L[0]=sp + #96 L[1]=_ L[2]=sp + #80 L[3]=sp + #88 L[4]=sp + #92 L[5]=_
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #72 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #32 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop [72]=Oop [80]=Oop [96]=Oop off=7704/0x1e18}
1e18    #@ShouldNotReachHere

1e24    B330: #	out( B78 ) &lt;- in( B77 )  Freq: 4.99192e-07
1e24    add R11, sp, #144	# box lock
1e28 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1e28    spill R23 -&gt; R12	# spill size = 64
1e2c +  spill R19 -&gt; R10	# spill size = 64
1e30 +  CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
1e60 +  j  B78	#@branch

1e64    B331: #	out( B56 ) &lt;- in( B54 )  Freq: 4.9199e-07
1e64 +  addw  R29, R21, zr	#@convI2L_reg_reg
1e68 +  j  B56	#@branch

1e6c    B332: #	out( N6590 ) &lt;- in( B63 )  Freq: 4.9199e-07
1e6c +  spill [sp, #8] -&gt; R8	# spill size = 64
1e70 +  li R11, #-28	# int, #@loadConI
1e74    spill R19 -&gt; [sp, #8]	# spill size = 64
1e78 +  spill R19 -&gt; [sp, #32]	# spill size = 64
1e7c +  spill R22 -&gt; [sp, #56]	# spill size = 64
1e80 +  spill R20 -&gt; [sp, #64]	# spill size = 64
1e84 +  spill R9 -&gt; [sp, #76]	# spill size = 32
1e88 +  spill R24 -&gt; [sp, #88]	# spill size = 64
1e8c +  spill R18 -&gt; [sp, #96]	# spill size = 32
1e90    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:88 (line 371) L[0]=_ L[1]=sp + #64 L[2]=sp + #96 L[3]=sp + #76 L[4]=sp + #88 STK[0]=sp + #88 STK[1]=sp + #96 STK[2]=#47
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [56]=Oop [64]=Oop [88]=Oop off=7828/0x1e94}
1e94    #@ShouldNotReachHere

1ea0    B333: #	out( B334 ) &lt;- in( B84 )  Freq: 4.91415e-07
1ea0 +  spill [sp, #16] -&gt; R29	# spill size = 64

1ea4    B334: #	out( N6590 ) &lt;- in( B333 B85 )  Freq: 9.82829e-07
1ea4 +  spill [sp, #8] -&gt; R8	# spill size = 64
1ea8 +  li R11, #-187	# int, #@loadConI
1eac    spill R29 -&gt; [sp, #8]	# spill size = 64
1eb0 +  spill R29 -&gt; [sp, #32]	# spill size = 64
1eb4 +  spill R7 -&gt; [sp, #40]	# spill size = 64
1eb8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::getAttributes @ bci:8 (line 206) L[0]=sp + #8 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_ STK[0]=#1
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop off=7868/0x1ebc}
1ebc    #@ShouldNotReachHere

1ec8    B335: #	out( N6590 ) &lt;- in( B87 )  Freq: 4.91413e-07
1ec8 +  li R11, #-10	# int, #@loadConI
1ecc    spill [sp, #8] -&gt; R8	# spill size = 64
1ed0 +  spill R15 -&gt; [sp, #0]	# spill size = 64
1ed4 +  spill R7 -&gt; [sp, #48]	# spill size = 64
1ed8 +  spill R7 -&gt; [sp, #56]	# spill size = 64
1edc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL STK[1]=sp + #48 STK[2]=#Ptr0x00000040d01ca340 STK[3]=sp + #0
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #48 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop off=7904/0x1ee0}
1ee0    #@ShouldNotReachHere

1eec    B336: #	out( N6590 ) &lt;- in( B56 )  Freq: 4.85543e-07
1eec +  li R11, #-52	# int, #@loadConI
1ef0    spill [sp, #8] -&gt; R8	# spill size = 64
1ef4 +  spill R22 -&gt; [sp, #56]	# spill size = 64
1ef8 +  spill R28 -&gt; [sp, #64]	# spill size = 64
1efc +  spill R20 -&gt; [sp, #72]	# spill size = 64
1f00 +  spill R18 -&gt; [sp, #80]	# spill size = 32
1f04 +  spill R9 -&gt; [sp, #84]	# spill size = 32
1f08 +  spill R21 -&gt; [sp, #88]	# spill size = 32
1f0c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:69 (line 369) L[0]=sp + #64 L[1]=sp + #72 L[2]=sp + #80 L[3]=sp + #84 L[4]=_ STK[0]=sp + #88
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [56]=Oop [64]=Oop [72]=Oop off=7952/0x1f10}
1f10    #@ShouldNotReachHere

1f1c    B337: #	out( B63 ) &lt;- in( B60 )  Freq: 4.85542e-07
1f1c +  spill R11 -&gt; R28	# spill size = 64
1f20 +  addi  R29, R7, #-2	#@addL_reg_imm
1f24    ClearArray R29, R28	#@clearArray_reg_reg
1f7c    
1f7c +  j  B63	#@branch

1f80    B338: #	out( N6590 ) &lt;- in( B64 )  Freq: 4.85542e-07
1f80 +  spill [sp, #8] -&gt; R7	# spill size = 64
1f84 +  li R11, #-52	# int, #@loadConI
1f88    spill R7 -&gt; [sp, #0]	# spill size = 64
1f8c +  spill R19 -&gt; [sp, #32]	# spill size = 64
1f90 +  spill R19 -&gt; [sp, #40]	# spill size = 64
1f94 +  spill R22 -&gt; [sp, #64]	# spill size = 64
1f98 +  spill R20 -&gt; [sp, #80]	# spill size = 64
1f9c +  spill R24 -&gt; [sp, #88]	# spill size = 64
1fa0 +  spill R9 -&gt; [sp, #96]	# spill size = 32
1fa4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:97 (line 372) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #88 STK[0]=sp + #80 STK[1]=#0 STK[2]=sp + #88 STK[3]=R8 STK[4]=sp + #96
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #64 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #32 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [64]=Oop [80]=Oop [88]=Oop off=8104/0x1fa8}
1fa8    #@ShouldNotReachHere

1fb4    B339: #	out( N6590 ) &lt;- in( B71 )  Freq: 4.8554e-07
1fb4 +  spill [sp, #8] -&gt; R7	# spill size = 64
1fb8 +  li R11, #-34	# int, #@loadConI
1fbc    spill R7 -&gt; [sp, #0]	# spill size = 64
1fc0 +  spill R19 -&gt; [sp, #32]	# spill size = 64
1fc4 +  spill R19 -&gt; [sp, #40]	# spill size = 64
1fc8 +  spill R18 -&gt; [sp, #72]	# spill size = 64
1fcc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:159 (line 186) L[0]=sp + #32 L[1]=_ L[2]=sp + #72 L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #72
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [72]=Oop off=8144/0x1fd0}
1fd0    #@ShouldNotReachHere

1fdc    B340: #	out( B80 ) &lt;- in( B79 )  Freq: 4.84975e-07
1fdc +  spill R19 -&gt; R8	# spill size = 64
1fe0 +  spill R19 -&gt; R11	# spill size = 64
1fe4    
1fe4    
1fe4    add R12, sp, #144	# box lock
1fe8 +  CALL,static 0x000000401390c140	#@CallStaticJavaDirect wrapper for: _complete_monitor_locking_Java
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::next @ bci:-1 (line 205) L[0]=R8 L[1]=_ MON-BOX0=sp+144 MON-OBJ[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::next @ bci:1 (line 132) L[0]=_
        # java.nio.file.FileTreeWalker::next @ bci:47 (line 350) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop off=8172/0x1fec}
1fec +  spill R8 -&gt; R19	# spill size = 64
1ff0 +  j  B80	#@branch

1ff4    B341: #	out( B83 ) &lt;- in( B82 )  Freq: 4.84975e-07
1ff4    add R11, sp, #144	# box lock
1ff8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ff8    spill R23 -&gt; R12	# spill size = 64
1ffc +  spill R19 -&gt; R10	# spill size = 64
2000 +  CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
2030 +  j  B83	#@branch

2034    B342: #	out( N6590 ) &lt;- in( B143 )  Freq: 4.84951e-07
2034 +  spill [sp, #8] -&gt; R8	# spill size = 64
2038 +  li R11, #-34	# int, #@loadConI
203c    spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
2044 +  spill R12 -&gt; [sp, #32]	# spill size = 64
2048    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:58 (line 288) L[0]=sp + #8 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop off=8268/0x204c}
204c    #@ShouldNotReachHere

2058    B343: #	out( N6590 ) &lt;- in( B110 )  Freq: 4.84789e-07
2058 +  spill [sp, #8] -&gt; R8	# spill size = 64
205c +  li R11, #-28	# int, #@loadConI
2060    spill R29 -&gt; [sp, #8]	# spill size = 64
2064 +  spill R29 -&gt; [sp, #32]	# spill size = 64
2068 +  spill R7 -&gt; [sp, #40]	# spill size = 64
206c +  spill R30 -&gt; [sp, #56]	# spill size = 64
2070 +  spill R7 -&gt; [sp, #64]	# spill size = 64
2074 +  spill R12 -&gt; [sp, #72]	# spill size = 64
2078 +  spill R19 -&gt; [sp, #84]	# spill size = 32
207c +  spill R15 -&gt; [sp, #96]	# spill size = 64
2080 +  spill R16 -&gt; [sp, #104]	# spill size = 64
2084 +  spill R20 -&gt; [sp, #120]	# spill size = 64
2088 +  spill R13 -&gt; [sp, #116]	# spill size = 32
208c +  spill R9 -&gt; [sp, #128]	# spill size = 32
2090    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:18 (line 435) L[0]=sp + #96 L[1]=sp + #104 L[2]=sp + #116 L[3]=_ STK[0]=sp + #120 STK[1]=sp + #116
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #104 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #40 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #128, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [96]=Oop [104]=Oop [120]=Oop off=8340/0x2094}
2094    #@ShouldNotReachHere

20a0    B344: #	out( N6590 ) &lt;- in( B112 )  Freq: 4.84788e-07
20a0 +  spill [sp, #8] -&gt; R8	# spill size = 64
20a4 +  li R11, #-187	# int, #@loadConI
20a8    spill R29 -&gt; [sp, #8]	# spill size = 64
20ac +  spill R29 -&gt; [sp, #32]	# spill size = 64
20b0 +  spill R7 -&gt; [sp, #40]	# spill size = 64
20b4 +  spill R30 -&gt; [sp, #56]	# spill size = 64
20b8 +  spill R7 -&gt; [sp, #64]	# spill size = 64
20bc +  spill R12 -&gt; [sp, #72]	# spill size = 64
20c0 +  spill R19 -&gt; [sp, #84]	# spill size = 32
20c4 +  spill R15 -&gt; [sp, #96]	# spill size = 64
20c8 +  spill R16 -&gt; [sp, #104]	# spill size = 64
20cc +  spill R13 -&gt; [sp, #112]	# spill size = 32
20d0 +  spill R20 -&gt; [sp, #120]	# spill size = 64
20d4 +  spill R9 -&gt; [sp, #116]	# spill size = 32
20d8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:29 (line 436) L[0]=sp + #96 L[1]=sp + #104 L[2]=sp + #112 L[3]=sp + #120 STK[0]=#0
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #104 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #40 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #116, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [96]=Oop [104]=Oop [120]=Oop off=8412/0x20dc}
20dc    #@ShouldNotReachHere

20e8    B345: #	out( N6590 ) &lt;- in( B115 )  Freq: 4.84787e-07
20e8 +  spill [sp, #8] -&gt; R8	# spill size = 64
20ec +  li R11, #-28	# int, #@loadConI
20f0    spill R29 -&gt; [sp, #8]	# spill size = 64
20f4 +  spill R29 -&gt; [sp, #32]	# spill size = 64
20f8 +  spill R7 -&gt; [sp, #40]	# spill size = 64
20fc +  spill R30 -&gt; [sp, #56]	# spill size = 64
2100 +  spill R7 -&gt; [sp, #64]	# spill size = 64
2104 +  spill R12 -&gt; [sp, #72]	# spill size = 64
2108 +  spill R19 -&gt; [sp, #84]	# spill size = 32
210c +  spill R18 -&gt; [sp, #96]	# spill size = 64
2110 +  spill R9 -&gt; [sp, #104]	# spill size = 32
2114    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:23 (line 75) L[0]=sp + #84 L[1]=sp + #96 L[2]=#0 L[3]=_ STK[0]=sp + #96 STK[1]=#0
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #40 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #104, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [96]=Oop off=8472/0x2118}
2118    #@ShouldNotReachHere

2124    B346: #	out( N6590 ) &lt;- in( B128 )  Freq: 4.84775e-07
2124 +  spill [sp, #8] -&gt; R8	# spill size = 64
2128 +  li R11, #-28	# int, #@loadConI
212c    spill R30 -&gt; [sp, #8]	# spill size = 64
2130 +  spill R28 -&gt; [sp, #64]	# spill size = 64
2134 +  spill R12 -&gt; [sp, #72]	# spill size = 64
2138 +  spill R29 -&gt; [sp, #80]	# spill size = 32
213c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:18 (line 435) L[0]=sp + #8 L[1]=sp + #64 L[2]=sp + #80 L[3]=_ STK[0]=sp + #72 STK[1]=sp + #80
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #64 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop off=8512/0x2140}
2140    #@ShouldNotReachHere

214c    B347: #	out( N6590 ) &lt;- in( B130 )  Freq: 4.84774e-07
214c +  spill [sp, #8] -&gt; R8	# spill size = 64
2150 +  li R11, #-187	# int, #@loadConI
2154    spill R30 -&gt; [sp, #8]	# spill size = 64
2158 +  spill R28 -&gt; [sp, #64]	# spill size = 64
215c +  spill R29 -&gt; [sp, #52]	# spill size = 32
2160 +  spill R7 -&gt; [sp, #72]	# spill size = 64
2164    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:29 (line 436) L[0]=sp + #8 L[1]=sp + #64 L[2]=sp + #52 L[3]=sp + #72 STK[0]=#0
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #64 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop off=8552/0x2168}
2168    #@ShouldNotReachHere

2174    B348: #	out( N6590 ) &lt;- in( B133 )  Freq: 4.84773e-07
2174 +  spill [sp, #8] -&gt; R8	# spill size = 64
2178 +  li R11, #-28	# int, #@loadConI
217c    spill R10 -&gt; [sp, #8]	# spill size = 64
2180    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:40 (line 115) L[0]=sp + #56 L[1]=sp + #8 L[2]=#0 L[3]=_ STK[0]=sp + #8 STK[1]=#0
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop off=8580/0x2184}
2184    #@ShouldNotReachHere

2190    B349: #	out( N6590 ) &lt;- in( B93 )  Freq: 4.84701e-07
2190 +  decode_heap_oop  R8, R30	#@decodeHeapOop
2194    spill [sp, #8] -&gt; R30	# spill size = 64
2198 +  li R11, #-187	# int, #@loadConI
219c    spill R30 -&gt; [sp, #0]	# spill size = 64
21a0 +  spill R15 -&gt; [sp, #8]	# spill size = 64
21a4 +  spill R12 -&gt; [sp, #16]	# spill size = 32
21a8 +  spill R29 -&gt; [sp, #40]	# spill size = 64
21ac +  spill R29 -&gt; [sp, #56]	# spill size = 64
21b0 +  spill R7 -&gt; [sp, #64]	# spill size = 64
21b4 +  spill R7 -&gt; [sp, #72]	# spill size = 64
21b8 +  spill R28 -&gt; [sp, #20]	# spill size = 32
21bc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.Util::followLinks @ bci:27 (line 122) L[0]=_ L[1]=_ L[2]=sp + #8 L[3]=sp + #20 L[4]=sp + #16 L[5]=R8 STK[0]=R8 STK[1]=#Ptr0x00000040d8198290
        # sun.nio.fs.UnixFileSystemProvider::getFileAttributeView @ bci:7 (line 120) L[0]=_ L[1]=_ L[2]=#Ptr0x00000040d82d3410 L[3]=_ L[4]=sp + #64 L[5]=_
        # sun.nio.fs.LinuxFileSystemProvider::getFileAttributeView @ bci:48 (line 68) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:51 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #40 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #56 L[1]=sp + #64 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #40 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop off=8640/0x21c0}
21c0    #@ShouldNotReachHere

21cc    B350: #	out( N6590 ) &lt;- in( B29 )  Freq: 2.62896e-07
21cc +  li R11, #-187	# int, #@loadConI
21d0    spill R9 -&gt; [sp, #0]	# spill size = 64
21d4 +  spill R18 -&gt; [sp, #8]	# spill size = 64
21d8 +  spill R24 -&gt; [sp, #16]	# spill size = 64
21dc +  spill R19 -&gt; [sp, #32]	# spill size = 64
21e0 +  spill R19 -&gt; [sp, #40]	# spill size = 64
21e4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream::isOpen @ bci:4 (line 83) L[0]=_ STK[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:39 (line 164) L[0]=sp + #32 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop off=8680/0x21e8}
21e8    #@ShouldNotReachHere

21f4    B351: #	out( N6590 ) &lt;- in( B37 )  Freq: 2.62889e-07
21f4 +  spill [sp, #8] -&gt; R7	# spill size = 64
21f8 +  li R11, #-187	# int, #@loadConI
21fc    spill R7 -&gt; [sp, #0]	# spill size = 64
2200 +  spill R28 -&gt; [sp, #32]	# spill size = 64
2204 +  spill R28 -&gt; [sp, #40]	# spill size = 64
2208 +  spill R12 -&gt; [sp, #80]	# spill size = 64
220c +  spill R30 -&gt; [sp, #96]	# spill size = 64
2210    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryReleaseShared @ bci:9 (line 417) L[0]=sp + #80 L[1]=_ L[2]=sp + #96 L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #96
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:2 (line 1094) L[0]=sp + #80 L[1]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #32 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop [80]=Oop [96]=Oop off=8724/0x2214}
2214    #@ShouldNotReachHere

2220    B352: #	out( N6590 ) &lt;- in( B38 )  Freq: 2.62889e-07
2220 +  li R11, #-187	# int, #@loadConI
2224    spill [sp, #8] -&gt; R8	# spill size = 64
2228 +  spill R12 -&gt; [sp, #72]	# spill size = 64
222c +  spill R10 -&gt; [sp, #80]	# spill size = 32
2230    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryReleaseShared @ bci:17 (line 419) L[0]=sp + #72 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #80 STK[1]=#1
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:2 (line 1094) L[0]=sp + #72 L[1]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #0 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [72]=Oop off=8756/0x2234}
2234    #@ShouldNotReachHere

2240    B353: #	out( N6590 ) &lt;- in( B41 )  Freq: 2.62889e-07
2240 +  spill [sp, #8] -&gt; R8	# spill size = 64
2244 +  li R11, #-187	# int, #@loadConI
2248    spill R28 -&gt; [sp, #8]	# spill size = 64
224c +  spill R28 -&gt; [sp, #32]	# spill size = 64
2250 +  spill R12 -&gt; [sp, #64]	# spill size = 64
2254 +  spill R31 -&gt; [sp, #72]	# spill size = 32
2258    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryReleaseShared @ bci:134 (line 443) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #72
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:2 (line 1094) L[0]=sp + #64 L[1]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #8 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [48]=Oop [64]=Oop off=8796/0x225c}
225c    #@ShouldNotReachHere

2268    B354: #	out( B40 ) &lt;- in( B226 )  Freq: 2.62882e-07
2268 +  spill R12 -&gt; R19	# spill size = 64
226c    
226c    
226c +  spill R28 -&gt; R9	# spill size = 64
2270    
2270    
2270 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2270    spill R23 -&gt; R11	# spill size = 64
2274 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
22a4 +  spill R9 -&gt; R28	# spill size = 64
22a8 +  spill [sp, #32] -&gt; R30	# spill size = 64
22ac +  spill R19 -&gt; R12	# spill size = 64
22b0 +  j  B40	#@branch

22b4    B355: #	out( N6590 ) &lt;- in( B40 )  Freq: 2.5071e-07
22b4 +  spill [sp, #8] -&gt; R7	# spill size = 64
22b8 +  li R11, #-187	# int, #@loadConI
22bc    spill R7 -&gt; [sp, #0]	# spill size = 64
22c0 +  spill R28 -&gt; [sp, #32]	# spill size = 64
22c4 +  spill R28 -&gt; [sp, #40]	# spill size = 64
22c8 +  spill R12 -&gt; [sp, #80]	# spill size = 64
22cc +  spill R31 -&gt; [sp, #88]	# spill size = 32
22d0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryReleaseShared @ bci:129 (line 439) L[0]=sp + #80 L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #88 STK[0]=R8
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:2 (line 1094) L[0]=sp + #80 L[1]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #32 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop [80]=Oop off=8916/0x22d4}
22d4    #@ShouldNotReachHere

22e0    B356: #	out( N6590 ) &lt;- in( B8 )  Freq: 2.4961e-07
22e0 +  li R11, #-187	# int, #@loadConI
22e4    spill R9 -&gt; [sp, #0]	# spill size = 64
22e8 +  spill R18 -&gt; [sp, #8]	# spill size = 64
22ec +  spill R24 -&gt; [sp, #16]	# spill size = 64
22f0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:26 (line 346) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=_ L[6]=_ STK[0]=R8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=8948/0x22f4}
22f4    #@ShouldNotReachHere

2300    B357: #	out( N6590 ) &lt;- in( B12 )  Freq: 2.49609e-07
2300 +  li R11, #-187	# int, #@loadConI
2304    spill R9 -&gt; [sp, #0]	# spill size = 64
2308 +  spill R18 -&gt; [sp, #8]	# spill size = 64
230c +  spill R24 -&gt; [sp, #16]	# spill size = 64
2310 +  spill R19 -&gt; [sp, #32]	# spill size = 64
2314 +  spill R19 -&gt; [sp, #40]	# spill size = 64
2318    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:4 (line 197) L[0]=sp + #40 STK[0]=R8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop off=8988/0x231c}
231c    #@ShouldNotReachHere

2328    B358: #	out( N6590 ) &lt;- in( B13 )  Freq: 2.49609e-07
2328 +  li R11, #-187	# int, #@loadConI
232c    spill R9 -&gt; R8	# spill size = 64
2330 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2334 +  spill R24 -&gt; [sp, #8]	# spill size = 64
2338 +  spill R19 -&gt; [sp, #24]	# spill size = 64
233c +  spill R29 -&gt; [sp, #32]	# spill size = 32
2340 +  spill R19 -&gt; [sp, #40]	# spill size = 64
2344    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:11 (line 197) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #24
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #24 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [40]=Oop off=9032/0x2348}
2348    #@ShouldNotReachHere

2354    B359: #	out( N6590 ) &lt;- in( B23 )  Freq: 2.49607e-07
2354 +  li R11, #-187	# int, #@loadConI
2358    spill R9 -&gt; R8	# spill size = 64
235c +  spill R18 -&gt; [sp, #0]	# spill size = 64
2360 +  spill R24 -&gt; [sp, #8]	# spill size = 64
2364 +  spill R19 -&gt; [sp, #24]	# spill size = 64
2368 +  spill R19 -&gt; [sp, #32]	# spill size = 64
236c +  spill R21 -&gt; [sp, #64]	# spill size = 64
2370 +  spill R20 -&gt; [sp, #72]	# spill size = 64
2374 +  spill R28 -&gt; [sp, #80]	# spill size = 32
2378    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:60 (line 478) L[0]=sp + #64 L[1]=_ L[2]=sp + #72 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #80
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #64 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #24 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #24 MON-BOX0=sp+144 MON-OBJ[0]=sp + #24
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #24 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop [64]=Oop [72]=Oop off=9084/0x237c}
237c    #@ShouldNotReachHere

2388    B360: #	out( B25 ) &lt;- in( B229 )  Freq: 2.496e-07
2388 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2388    spill R23 -&gt; R11	# spill size = 64
238c +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
23bc +  j  B25	#@branch

23c0    B361: #	out( B74 ) &lt;- in( B232 )  Freq: 2.49589e-07
23c0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
23c0    spill R23 -&gt; R11	# spill size = 64
23c4 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
23f4 +  j  B74	#@branch

23f8    B362: #	out( B156 ) &lt;- in( B235 )  Freq: 2.4956e-07
23f8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
23f8    spill R23 -&gt; R11	# spill size = 64
23fc +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
242c +  j  B156	#@branch

2430    B363: #	out( N6590 ) &lt;- in( B90 )  Freq: 2.45661e-07
2430 +  li R11, #-138	# int, #@loadConI
2434    spill [sp, #8] -&gt; R8	# spill size = 64
2438 +  spill R15 -&gt; [sp, #0]	# spill size = 64
243c +  spill R7 -&gt; [sp, #48]	# spill size = 64
2440 +  spill R7 -&gt; [sp, #56]	# spill size = 64
2444 +  spill R28 -&gt; [sp, #68]	# spill size = 32
2448    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.Util::followLinks @ bci:13 (line 121) L[0]=_ L[1]=#1 L[2]=sp + #0 L[3]=sp + #68 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=sp + #68
        # sun.nio.fs.UnixFileSystemProvider::getFileAttributeView @ bci:7 (line 120) L[0]=_ L[1]=_ L[2]=#Ptr0x00000040d82d3410 L[3]=_ L[4]=sp + #48 L[5]=_
        # sun.nio.fs.LinuxFileSystemProvider::getFileAttributeView @ bci:48 (line 68) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:51 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #48 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop off=9292/0x244c}
244c    #@ShouldNotReachHere

2458    B364: #	out( N6590 ) &lt;- in( B49 )  Freq: 2.42772e-07
2458 +  spill [sp, #8] -&gt; R7	# spill size = 64
245c +  li R11, #-187	# int, #@loadConI
2460    spill R7 -&gt; [sp, #0]	# spill size = 64
2464 +  spill R19 -&gt; [sp, #32]	# spill size = 64
2468 +  spill R19 -&gt; [sp, #40]	# spill size = 64
246c +  spill R22 -&gt; [sp, #64]	# spill size = 64
2470 +  spill R9 -&gt; [sp, #80]	# spill size = 32
2474 +  spill R20 -&gt; [sp, #88]	# spill size = 64
2478    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:10 (line 380) L[0]=sp + #64 L[1]=#ScObj0 L[2]=sp + #88 L[3]=_ STK[0]=sp + #80
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=R8, [path :2]=sp + #88, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #32 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [64]=Oop [88]=Oop off=9340/0x247c}
247c    #@ShouldNotReachHere

2488    B365: #	out( N6590 ) &lt;- in( B52 )  Freq: 2.42772e-07
2488 +  li R11, #-187	# int, #@loadConI
248c    spill [sp, #8] -&gt; R8	# spill size = 64
2490 +  spill R22 -&gt; [sp, #56]	# spill size = 64
2494 +  spill R28 -&gt; [sp, #64]	# spill size = 64
2498 +  spill R20 -&gt; [sp, #72]	# spill size = 64
249c +  spill R9 -&gt; [sp, #84]	# spill size = 32
24a0 +  spill R18 -&gt; [sp, #88]	# spill size = 32
24a4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 361) L[0]=sp + #64 L[1]=sp + #72 L[2]=sp + #88 L[3]=sp + #84 L[4]=_ STK[0]=sp + #88
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [56]=Oop [64]=Oop [72]=Oop off=9384/0x24a8}
24a8    #@ShouldNotReachHere

24b4    B366: #	out( B82 ) &lt;- in( B248 )  Freq: 2.42481e-07
24b4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
24b4    spill R23 -&gt; R11	# spill size = 64
24b8 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
24e8 +  j  B82	#@branch

24ec    B367: #	out( N6590 ) &lt;- in( B117 )  Freq: 2.42393e-07
24ec +  spill [sp, #8] -&gt; R28	# spill size = 64
24f0 +  li R11, #-187	# int, #@loadConI
24f4    spill R28 -&gt; [sp, #0]	# spill size = 64
24f8 +  spill R29 -&gt; [sp, #16]	# spill size = 64
24fc +  spill R29 -&gt; [sp, #40]	# spill size = 64
2500 +  spill R7 -&gt; [sp, #48]	# spill size = 64
2504 +  spill R30 -&gt; [sp, #64]	# spill size = 64
2508 +  spill R7 -&gt; [sp, #72]	# spill size = 64
250c +  spill R12 -&gt; [sp, #80]	# spill size = 64
2510 +  spill R19 -&gt; [sp, #92]	# spill size = 32
2514 +  spill R18 -&gt; [sp, #96]	# spill size = 64
2518 +  spill R21 -&gt; [sp, #104]	# spill size = 64
251c +  spill R19 -&gt; [sp, #112]	# spill size = 32
2520 +  spill R9 -&gt; [sp, #116]	# spill size = 32
2524    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:34 (line 76) L[0]=sp + #112 L[1]=sp + #96 L[2]=#0 L[3]=sp + #104 STK[0]=R8 STK[1]=sp + #92
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #48 L[1]=sp + #80 L[2]=sp + #92 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #64 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #64
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #116, [file :1]=sp + #48 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #40 L[1]=sp + #48 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [64]=Oop [72]=Oop [80]=Oop [96]=Oop [104]=Oop off=9512/0x2528}
2528    #@ShouldNotReachHere

2534    B368: #	out( B119 ) &lt;- in( B251 )  Freq: 2.42387e-07
2534 +  spill R18 -&gt; R8	# spill size = 64
2538 +  spill R17 -&gt; R18	# spill size = 64
253c    
253c    
253c +  spill R14 -&gt; R26	# spill size = 32
2540    
2540 +  spill R12 -&gt; R24	# spill size = 64
2544    
2544    
2544 +  spill R31 -&gt; [sp, #0]	# spill size = 32
2548    
2548 +  spill R30 -&gt; R22	# spill size = 64
254c    
254c    
254c +  spill R21 -&gt; [sp, #16]	# spill size = 64
2550 +  spill R9 -&gt; R21	# spill size = 32
2554 +  spill R29 -&gt; R9	# spill size = 64
2558    
2558    
2558 +  spill R7 -&gt; R20	# spill size = 64
255c    
255c    
255c +  spill R11 -&gt; R25	# spill size = 32
2564 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2564    spill R23 -&gt; R11	# spill size = 64
2568 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2598 +  spill R9 -&gt; R29	# spill size = 64
259c +  spill R18 -&gt; R17	# spill size = 64
25a0 +  spill R21 -&gt; R9	# spill size = 32
25a4 +  spill R20 -&gt; R7	# spill size = 64
25a8 +  spill R22 -&gt; R30	# spill size = 64
25ac +  spill R25 -&gt; R11	# spill size = 32
25b4 +  spill R24 -&gt; R12	# spill size = 64
25b8 +  spill R26 -&gt; R14	# spill size = 32
25bc +  spill R8 -&gt; R18	# spill size = 64
25c0 +  spill [sp, #0] -&gt; R31	# spill size = 32
25c4 +  spill [sp, #16] -&gt; R21	# spill size = 64
25c8 +  j  B119	#@branch

25cc    B369: #	out( N6590 ) &lt;- in( B134 )  Freq: 2.42386e-07
25cc +  spill [sp, #8] -&gt; R7	# spill size = 64
25d0 +  li R11, #-187	# int, #@loadConI
25d4    spill R7 -&gt; [sp, #0]	# spill size = 64
25d8 +  spill R10 -&gt; [sp, #8]	# spill size = 64
25dc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:41 (line 115) L[0]=sp + #56 L[1]=sp + #8 L[2]=#0 L[3]=_ STK[0]=R8
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop off=9696/0x25e0}
25e0    #@ShouldNotReachHere

25ec    B370: #	out( B136 ) &lt;- in( B254 )  Freq: 2.4238e-07
25ec +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
25ec    spill R23 -&gt; R11	# spill size = 64
25f0 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2620 +  j  B136	#@branch

2624    B371: #	out( N6590 ) &lt;- in( B19 )  Freq: 2.38044e-07
2624 +  li R11, #-187	# int, #@loadConI
2628    spill R9 -&gt; [sp, #0]	# spill size = 64
262c +  spill R18 -&gt; [sp, #8]	# spill size = 64
2630 +  spill R24 -&gt; [sp, #16]	# spill size = 64
2634 +  spill R19 -&gt; [sp, #32]	# spill size = 64
2638 +  spill R19 -&gt; [sp, #40]	# spill size = 64
263c +  spill R21 -&gt; [sp, #72]	# spill size = 64
2640 +  spill R20 -&gt; [sp, #80]	# spill size = 64
2644 +  spill R31 -&gt; [sp, #88]	# spill size = 32
2648    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:13 (line 471) L[0]=sp + #72 L[1]=_ L[2]=sp + #80 L[3]=sp + #88 L[4]=_ L[5]=_ STK[0]=R8
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #72 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #32 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop [72]=Oop [80]=Oop off=9804/0x264c}
264c    #@ShouldNotReachHere

2658    B372: #	out( N6590 ) &lt;- in( B21 )  Freq: 2.38044e-07
2658 +  li R11, #-187	# int, #@loadConI
265c    spill R9 -&gt; R8	# spill size = 64
2660 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2664 +  spill R24 -&gt; [sp, #8]	# spill size = 64
2668 +  spill R19 -&gt; [sp, #24]	# spill size = 64
266c +  spill R19 -&gt; [sp, #32]	# spill size = 64
2670 +  spill R21 -&gt; [sp, #64]	# spill size = 64
2674 +  spill R20 -&gt; [sp, #72]	# spill size = 64
2678 +  spill R31 -&gt; [sp, #80]	# spill size = 32
267c +  spill R28 -&gt; [sp, #88]	# spill size = 32
2680    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:43 (line 475) L[0]=sp + #64 L[1]=_ L[2]=sp + #72 L[3]=sp + #80 L[4]=sp + #88 L[5]=_ STK[0]=sp + #88 STK[1]=#65535
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #64 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #24 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #24 MON-BOX0=sp+144 MON-OBJ[0]=sp + #24
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #24 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop [64]=Oop [72]=Oop off=9860/0x2684}
2684    #@ShouldNotReachHere

2690    B373: #	out( N6590 ) &lt;- in( B22 )  Freq: 2.38044e-07
2690 +  li R11, #-187	# int, #@loadConI
2694    spill R9 -&gt; [sp, #0]	# spill size = 64
2698 +  spill R18 -&gt; [sp, #8]	# spill size = 64
269c +  spill R24 -&gt; [sp, #16]	# spill size = 64
26a0 +  spill R19 -&gt; [sp, #32]	# spill size = 64
26a4 +  spill R19 -&gt; [sp, #40]	# spill size = 64
26a8 +  spill R21 -&gt; [sp, #72]	# spill size = 64
26ac +  spill R20 -&gt; [sp, #80]	# spill size = 64
26b0 +  spill R28 -&gt; [sp, #88]	# spill size = 32
26b4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:55 (line 477) L[0]=sp + #72 L[1]=_ L[2]=sp + #80 L[3]=_ L[4]=sp + #88 L[5]=_ STK[0]=R8
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #72 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #32 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop [72]=Oop [80]=Oop off=9912/0x26b8}
26b8    #@ShouldNotReachHere

26c4    B374: #	out( B121 ) &lt;- in( B261 )  Freq: 2.3581e-07
26c4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
26c4    spill R23 -&gt; R11	# spill size = 64
26c8 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
26f8 +  j  B121	#@branch

26fc    B375: #	out( N6590 ) &lt;- in( B50 )  Freq: 2.31525e-07
26fc +  spill [sp, #8] -&gt; R7	# spill size = 64
2700 +  li R11, #-187	# int, #@loadConI
2704    spill R7 -&gt; [sp, #0]	# spill size = 64
2708 +  spill R19 -&gt; [sp, #32]	# spill size = 64
270c +  spill R19 -&gt; [sp, #40]	# spill size = 64
2710 +  spill R22 -&gt; [sp, #64]	# spill size = 64
2714 +  spill R31 -&gt; [sp, #80]	# spill size = 32
2718 +  spill R20 -&gt; [sp, #88]	# spill size = 64
271c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:18 (line 380) L[0]=sp + #64 L[1]=#ScObj0 L[2]=sp + #88 L[3]=_ STK[0]=sp + #80 STK[1]=#47
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=R8, [path :2]=sp + #88, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #32 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [64]=Oop [88]=Oop off=10016/0x2720}
2720    #@ShouldNotReachHere

272c    B376: #	out( N6590 ) &lt;- in( B53 )  Freq: 2.31525e-07
272c +  li R11, #-187	# int, #@loadConI
2730    spill [sp, #8] -&gt; R8	# spill size = 64
2734 +  spill R22 -&gt; [sp, #56]	# spill size = 64
2738 +  spill R28 -&gt; [sp, #64]	# spill size = 64
273c +  spill R20 -&gt; [sp, #72]	# spill size = 64
2740 +  spill R9 -&gt; [sp, #84]	# spill size = 32
2744 +  spill R18 -&gt; [sp, #88]	# spill size = 32
2748    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:28 (line 364) L[0]=sp + #64 L[1]=sp + #72 L[2]=sp + #88 L[3]=sp + #84 L[4]=_ STK[0]=sp + #88 STK[1]=#1
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [56]=Oop [64]=Oop [72]=Oop off=10060/0x274c}
274c    #@ShouldNotReachHere

2758    B377: #	out( N6590 ) &lt;- in( B98 )  Freq: 2.31253e-07
2758 +  spill [sp, #8] -&gt; R28	# spill size = 64
275c +  li R11, #-187	# int, #@loadConI
2760    spill R28 -&gt; [sp, #0]	# spill size = 64
2764 +  spill R29 -&gt; [sp, #16]	# spill size = 64
2768 +  spill R29 -&gt; [sp, #40]	# spill size = 64
276c +  spill R7 -&gt; [sp, #48]	# spill size = 64
2770 +  spill R7 -&gt; [sp, #56]	# spill size = 64
2774 +  spill R9 -&gt; [sp, #64]	# spill size = 32
2778    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.System::allowSecurityManager @ bci:4 (line 193) STK[0]=R8 STK[1]=#1
        # java.lang.System::getSecurityManager @ bci:0 (line 483)
        # sun.nio.fs.UnixPath::checkRead @ bci:0 (line 778) L[0]=sp + #48 L[1]=_
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:4 (line 49) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #48 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #40 L[1]=sp + #48 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop off=10108/0x277c}
277c    #@ShouldNotReachHere

2788    B378: #	out( N6590 ) &lt;- in( B99 )  Freq: 2.31252e-07
2788 +  spill [sp, #8] -&gt; R28	# spill size = 64
278c +  li R11, #-187	# int, #@loadConI
2790    spill R28 -&gt; [sp, #0]	# spill size = 64
2794 +  spill R29 -&gt; [sp, #16]	# spill size = 64
2798 +  spill R29 -&gt; [sp, #40]	# spill size = 64
279c +  spill R7 -&gt; [sp, #48]	# spill size = 64
27a0 +  spill R7 -&gt; [sp, #56]	# spill size = 64
27a4 +  spill R9 -&gt; [sp, #64]	# spill size = 32
27a8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::checkRead @ bci:5 (line 779) L[0]=sp + #48 L[1]=R8 STK[0]=R8
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:4 (line 49) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #48 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #40 L[1]=sp + #48 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop off=10156/0x27ac}
27ac    #@ShouldNotReachHere

27b8    B379: #	out( N6590 ) &lt;- in( B142 )  Freq: 2.31243e-07
27b8 +  spill [sp, #8] -&gt; R7	# spill size = 64
27bc +  li R11, #-187	# int, #@loadConI
27c0    spill R7 -&gt; [sp, #0]	# spill size = 64
27c4 +  spill R12 -&gt; [sp, #32]	# spill size = 64
27c8 +  spill R28 -&gt; [sp, #48]	# spill size = 32
27cc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:53 (line 288) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ STK[0]=R8 STK[1]=sp + #48
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=10192/0x27d0}
27d0    #@ShouldNotReachHere

27dc    B380: #	out( N6590 ) &lt;- in( B104 )  Freq: 2.31166e-07
27dc +  spill [sp, #8] -&gt; R8	# spill size = 64
27e0 +  li R11, #-187	# int, #@loadConI
27e4    spill R29 -&gt; [sp, #8]	# spill size = 64
27e8 +  spill R29 -&gt; [sp, #32]	# spill size = 64
27ec +  spill R7 -&gt; [sp, #40]	# spill size = 64
27f0 +  spill R30 -&gt; [sp, #56]	# spill size = 64
27f4 +  spill R7 -&gt; [sp, #64]	# spill size = 64
27f8 +  spill R31 -&gt; [sp, #80]	# spill size = 32
27fc +  spill R9 -&gt; [sp, #84]	# spill size = 32
2800    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getByteArrayForSysCalls @ bci:7 (line 135) L[0]=sp + #40 L[1]=_ STK[0]=sp + #80
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:1 (line 37) L[0]=sp + #40 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #84, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=10244/0x2804}
2804    #@ShouldNotReachHere

2810    B381: #	out( N6590 ) &lt;- in( B106 )  Freq: 2.31166e-07
2810 +  spill [sp, #8] -&gt; R8	# spill size = 64
2814 +  li R11, #-187	# int, #@loadConI
2818    spill R29 -&gt; [sp, #8]	# spill size = 64
281c +  spill R29 -&gt; [sp, #32]	# spill size = 64
2820 +  spill R7 -&gt; [sp, #40]	# spill size = 64
2824 +  spill R30 -&gt; [sp, #56]	# spill size = 64
2828 +  spill R7 -&gt; [sp, #64]	# spill size = 64
282c +  spill R14 -&gt; [sp, #80]	# spill size = 32
2830 +  spill R9 -&gt; [sp, #84]	# spill size = 32
2834    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::isEmpty @ bci:5 (line 216) L[0]=_ STK[0]=sp + #80
        # sun.nio.fs.UnixPath::getByteArrayForSysCalls @ bci:26 (line 138) L[0]=sp + #40 L[1]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:1 (line 37) L[0]=sp + #40 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #84, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=10296/0x2838}
2838    #@ShouldNotReachHere

2844    B382: #	out( N6590 ) &lt;- in( B170 )  Freq: 2.65685e-08
2844 +  spill [sp, #8] -&gt; R7	# spill size = 64
2848 +  li R11, #-34	# int, #@loadConI
284c    spill R7 -&gt; [sp, #0]	# spill size = 64
2850 +  spill R19 -&gt; [sp, #32]	# spill size = 64
2854 +  spill R19 -&gt; [sp, #40]	# spill size = 64
2858    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #32 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=10332/0x285c}
285c    #@ShouldNotReachHere

2868    B383: #	out( N6590 ) &lt;- in( B173 )  Freq: 2.65684e-08
2868 +  spill [sp, #8] -&gt; R7	# spill size = 64
286c +  li R11, #-20	# int, #@loadConI
2870    spill R7 -&gt; [sp, #0]	# spill size = 64
2874 +  spill R19 -&gt; [sp, #40]	# spill size = 64
2878 +  spill R19 -&gt; [sp, #48]	# spill size = 64
287c +  spill R30 -&gt; [sp, #80]	# spill size = 64
2880 +  spill R10 -&gt; [sp, #88]	# spill size = 32
2884 +  spill R31 -&gt; [sp, #92]	# spill size = 32
2888 +  spill R30 -&gt; [sp, #96]	# spill size = 64
288c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_assert&apos; action=&apos;make_not_entrant&apos;)
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::hasQueuedPredecessors @ bci:6 (line 1234) L[0]=sp + #80 L[1]=#NULL L[2]=_ L[3]=_ STK[0]=R8
        # java.util.concurrent.locks.ReentrantReadWriteLock$FairSync::readerShouldBlock @ bci:1 (line 706) L[0]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:33 (line 475) L[0]=sp + #96 L[1]=_ L[2]=sp + #32 L[3]=sp + #88 L[4]=sp + #92 L[5]=_
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #80 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #40 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #48 STK[0]=sp + #40 MON-BOX0=sp+144 MON-OBJ[0]=sp + #40
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #40 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop [80]=Oop [96]=Oop off=10384/0x2890}
2890    #@ShouldNotReachHere

289c    B384: #	out( N6590 ) &lt;- in( B181 )  Freq: 1.4892e-08
289c +  li R11, #-10	# int, #@loadConI
28a0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:57 (line 94) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # OopMap {off=10404/0x28a4}
28a4    #@ShouldNotReachHere

28b0    B385: #	out( N6590 ) &lt;- in( B188 )  Freq: 1.44048e-08
28b0 +  li R11, #-10	# int, #@loadConI
28b4    spill [sp, #8] -&gt; R8	# spill size = 64
28b8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:109 (line 369) L[0]=_ L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_ STK[0]=#NULL
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop off=10428/0x28bc}
28bc    #@ShouldNotReachHere

28c8    B386: #	out( N6590 ) &lt;- in( B186 )  Freq: 1.42163e-08
28c8 +  spill [sp, #8] -&gt; R8	# spill size = 64
28cc +  li R11, #-34	# int, #@loadConI
28d0    spill R30 -&gt; [sp, #8]	# spill size = 64
28d4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:76 (line 361) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_ STK[0]=sp + #8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop off=10456/0x28d8}
28d8    #@ShouldNotReachHere

28e4    B387: #	out( N6590 ) &lt;- in( B218 )  Freq: 1.372e-08
28e4 +  spill [sp, #8] -&gt; R8	# spill size = 64
28e8 +  li R11, #-10	# int, #@loadConI
28ec    spill R18 -&gt; [sp, #8]	# spill size = 64
28f0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:187 (line 311) L[0]=_ L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ STK[0]=#NULL STK[1]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=10484/0x28f4}
28f4    #@ShouldNotReachHere

2900    B388: #	out( N6590 ) &lt;- in( B176 )  Freq: 1.32842e-08
2900 +  li R11, #-187	# int, #@loadConI
2904    spill [sp, #8] -&gt; R8	# spill size = 64
2908 +  spill R30 -&gt; [sp, #72]	# spill size = 64
290c +  spill R31 -&gt; [sp, #80]	# spill size = 32
2910    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:60 (line 478) L[0]=sp + #72 L[1]=_ L[2]=sp + #32 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #80
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #72 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [72]=Oop off=10516/0x2914}
2914    #@ShouldNotReachHere

2920    B389: #	out( B178 ) &lt;- in( B281 )  Freq: 1.32838e-08
2920 +  spill R30 -&gt; R18	# spill size = 64
2924    
2924    
2924 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2924    spill R23 -&gt; R11	# spill size = 64
2928 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2958 +  spill R18 -&gt; R30	# spill size = 64
295c +  j  B178	#@branch

2960    B390: #	out( N6590 ) &lt;- in( B172 )  Freq: 1.26688e-08
2960 +  spill [sp, #8] -&gt; R7	# spill size = 64
2964 +  li R11, #-187	# int, #@loadConI
2968    spill R7 -&gt; [sp, #0]	# spill size = 64
296c +  spill R19 -&gt; [sp, #40]	# spill size = 64
2970 +  spill R19 -&gt; [sp, #48]	# spill size = 64
2974 +  spill R30 -&gt; [sp, #80]	# spill size = 64
2978 +  spill R10 -&gt; [sp, #88]	# spill size = 32
297c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:13 (line 471) L[0]=sp + #80 L[1]=_ L[2]=sp + #32 L[3]=sp + #88 L[4]=_ L[5]=_ STK[0]=R8
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #80 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #40 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #48 STK[0]=sp + #40 MON-BOX0=sp+144 MON-OBJ[0]=sp + #40
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #40 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop [80]=Oop off=10624/0x2980}
2980    #@ShouldNotReachHere

298c    B391: #	out( N6590 ) &lt;- in( B174 )  Freq: 1.26688e-08
298c +  li R11, #-187	# int, #@loadConI
2990    spill [sp, #8] -&gt; R8	# spill size = 64
2994 +  spill R30 -&gt; [sp, #72]	# spill size = 64
2998 +  spill R10 -&gt; [sp, #80]	# spill size = 32
299c +  spill R31 -&gt; [sp, #88]	# spill size = 32
29a0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:43 (line 475) L[0]=sp + #72 L[1]=_ L[2]=sp + #32 L[3]=sp + #80 L[4]=sp + #88 L[5]=_ STK[0]=sp + #88 STK[1]=#65535
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #72 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [72]=Oop off=10660/0x29a4}
29a4    #@ShouldNotReachHere

29b0    B392: #	out( N6590 ) &lt;- in( B175 )  Freq: 1.26688e-08
29b0 +  spill [sp, #8] -&gt; R7	# spill size = 64
29b4 +  li R11, #-187	# int, #@loadConI
29b8    spill R7 -&gt; [sp, #0]	# spill size = 64
29bc +  spill R19 -&gt; [sp, #40]	# spill size = 64
29c0 +  spill R19 -&gt; [sp, #48]	# spill size = 64
29c4 +  spill R30 -&gt; [sp, #80]	# spill size = 64
29c8 +  spill R31 -&gt; [sp, #88]	# spill size = 32
29cc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:55 (line 477) L[0]=sp + #80 L[1]=_ L[2]=sp + #32 L[3]=_ L[4]=sp + #88 L[5]=_ STK[0]=R8
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #80 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #40 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #48 STK[0]=sp + #40 MON-BOX0=sp+144 MON-OBJ[0]=sp + #40
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #40 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop [80]=Oop off=10704/0x29d0}
29d0    #@ShouldNotReachHere

29dc    B393: #	out( B202 ) &lt;- in( B288 )  Freq: 6.77008e-09
29dc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
29dc    spill R23 -&gt; R11	# spill size = 64
29e0 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2a10 +  j  B202	#@branch

2a14    B394: #	out( B205 ) &lt;- in( B291 )  Freq: 6.77008e-09
2a14 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2a14    spill R23 -&gt; R11	# spill size = 64
2a18 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2a48 +  j  B205	#@branch

2a4c    B395: #	out( B209 ) &lt;- in( B294 )  Freq: 6.77008e-09
2a4c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2a4c    spill R23 -&gt; R11	# spill size = 64
2a50 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2a80 +  j  B209	#@branch

2a84    B396: #	out( B215 ) &lt;- in( B297 )  Freq: 6.76995e-09
2a84 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2a84    spill R23 -&gt; R11	# spill size = 64
2a88 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2ab8 +  j  B215	#@branch

2abc    B397: #	out( N6590 ) &lt;- in( B164 )  Freq: 6.64215e-09
2abc +  li R11, #-187	# int, #@loadConI
2ac0    spill [sp, #8] -&gt; R8	# spill size = 64
2ac4 +  spill R20 -&gt; [sp, #64]	# spill size = 64
2ac8 +  spill R9 -&gt; [sp, #72]	# spill size = 32
2acc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::isSelfOrParent @ bci:17 (line 146) L[0]=_ L[1]=sp + #64 STK[0]=sp + #72 STK[1]=#2
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:123 (line 181) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [64]=Oop off=10960/0x2ad0}
2ad0    #@ShouldNotReachHere

2adc    B398: #	out( N6590 ) &lt;- in( B195 )  Freq: 6.45688e-09
2adc +  spill [sp, #8] -&gt; R7	# spill size = 64
2ae0 +  li R11, #-187	# int, #@loadConI
2ae4    spill R7 -&gt; [sp, #0]	# spill size = 64
2ae8 +  spill R30 -&gt; [sp, #32]	# spill size = 64
2aec    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:84 (line 293) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ STK[0]=R8
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=10992/0x2af0}
2af0    #@ShouldNotReachHere

2afc    B399: #	out( N6590 ) &lt;- in( B7 )  Freq: 1e-35
2afc +  li R11, #-34	# int, #@loadConI
2b00    spill R9 -&gt; R8	# spill size = 64
2b04 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2b08 +  spill R24 -&gt; [sp, #8]	# spill size = 64
2b0c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:7 (line 335) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=sp + #8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=11024/0x2b10}
2b10    #@ShouldNotReachHere

2b1c    B400: #	out( N6590 ) &lt;- in( B83 )  Freq: 1e-35
2b1c +  li R11, #-34	# int, #@loadConI
2b20    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:52 (line 350) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=_ L[6]=_ STK[0]=R8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop off=11044/0x2b24}
2b24    #@ShouldNotReachHere

2b30    B401: #	out( N6590 ) &lt;- in( B114 )  Freq: 1e-35
2b30 +  spill [sp, #8] -&gt; R8	# spill size = 64
2b34 +  li R11, #-34	# int, #@loadConI
2b38    spill R29 -&gt; [sp, #8]	# spill size = 64
2b3c +  spill R29 -&gt; [sp, #32]	# spill size = 64
2b40 +  spill R7 -&gt; [sp, #40]	# spill size = 64
2b44 +  spill R30 -&gt; [sp, #56]	# spill size = 64
2b48 +  spill R7 -&gt; [sp, #64]	# spill size = 64
2b4c +  spill R12 -&gt; [sp, #72]	# spill size = 64
2b50 +  spill R19 -&gt; [sp, #84]	# spill size = 32
2b54 +  spill R18 -&gt; [sp, #88]	# spill size = 64
2b58 +  spill R9 -&gt; [sp, #96]	# spill size = 32
2b5c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:6 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #88
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #40 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #96, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [88]=Oop off=11104/0x2b60}
2b60    #@ShouldNotReachHere

2b6c    B402: #	out( N6590 ) &lt;- in( B132 )  Freq: 1e-35
2b6c +  li R11, #-34	# int, #@loadConI
2b70    spill [sp, #8] -&gt; R8	# spill size = 64
2b74 +  spill R10 -&gt; [sp, #0]	# spill size = 64
2b78    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:6 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #0
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop off=11132/0x2b7c}
2b7c    #@ShouldNotReachHere

2b88    B403: #	out( B451 B501 B452 ) &lt;- in( B31 )  Freq: 5.25791e-06
2b88     -- 	// exception oop; no code emitted, #@CreateException
2b88 +  spill [sp, #0] -&gt; R28	# spill size = 64
2b8c +  lwu  R28, [R28, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
2b90 +  decode_heap_oop  R28, R28	#@decodeHeapOop
2b94    spill R28 -&gt; R8	# spill size = 64
2b98 +  spill R10 -&gt; R11	# spill size = 64
2b9c    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:52 (line 165) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=11168/0x2ba0}

2ba0    B404: #	out( N6590 ) &lt;- in( B28 )  Freq: 5.32774e-07
2ba0 +  li R11, #-10	# int, #@loadConI
2ba4    spill R9 -&gt; R8	# spill size = 64
2ba8 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2bac +  spill R24 -&gt; [sp, #8]	# spill size = 64
2bb0 +  spill R19 -&gt; [sp, #24]	# spill size = 64
2bb4 +  spill R19 -&gt; [sp, #32]	# spill size = 64
2bb8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:39 (line 164) L[0]=sp + #24 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #24 MON-BOX0=sp+144 MON-OBJ[0]=sp + #24
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #24 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop off=11196/0x2bbc}
2bbc    #@ShouldNotReachHere

2bc8    B405: #	out( N6590 ) &lt;- in( B30 )  Freq: 5.32774e-07
2bc8 +  li R11, #-10	# int, #@loadConI
2bcc    spill R9 -&gt; R8	# spill size = 64
2bd0 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2bd4 +  spill R24 -&gt; [sp, #8]	# spill size = 64
2bd8 +  spill R19 -&gt; [sp, #24]	# spill size = 64
2bdc +  spill R19 -&gt; [sp, #32]	# spill size = 64
2be0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:49 (line 165) L[0]=sp + #24 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #24 MON-BOX0=sp+144 MON-OBJ[0]=sp + #24
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #24 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop off=11236/0x2be4}
2be4    #@ShouldNotReachHere

2bf0    B406: #	out( N6590 ) &lt;- in( B32 )  Freq: 5.32762e-07
2bf0 +  li R11, #-10	# int, #@loadConI
2bf4    spill [sp, #8] -&gt; R8	# spill size = 64
2bf8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:60 (line 171) L[0]=sp + #0 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop off=11260/0x2bfc}
2bfc    #@ShouldNotReachHere

2c08    B407: #	out( N6590 ) &lt;- in( B33 )  Freq: 5.32762e-07
2c08 +  li R11, #-10	# int, #@loadConI
2c0c    spill [sp, #8] -&gt; R8	# spill size = 64
2c10    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream::readLock @ bci:4 (line 75) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:60 (line 171) L[0]=sp + #0 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop off=11284/0x2c14}
2c14    #@ShouldNotReachHere

2c20    B408: #	out( N6590 ) &lt;- in( B34 )  Freq: 5.32761e-07
2c20 +  li R11, #-10	# int, #@loadConI
2c24    spill [sp, #8] -&gt; R8	# spill size = 64
2c28    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #0 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop off=11308/0x2c2c}
2c2c    #@ShouldNotReachHere

2c38    B409: #	out( N6590 ) &lt;- in( B36 )  Freq: 5.3276e-07
2c38 +  li R11, #-10	# int, #@loadConI
2c3c    spill [sp, #8] -&gt; R8	# spill size = 64
2c40    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_ STK[0]=#NULL STK[1]=#1
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #0 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop off=11332/0x2c44}
2c44    #@ShouldNotReachHere

2c50    B410: #	out( N6590 ) &lt;- in( B2 )  Freq: 5.06357e-07
2c50 +  li R11, #-10	# int, #@loadConI
2c54    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # OopMap {off=11352/0x2c58}
2c58    #@ShouldNotReachHere

2c64    B411: #	out( N6590 ) &lt;- in( B3 )  Freq: 5.06356e-07
2c64 +  li R11, #-10	# int, #@loadConI
2c68    spill R9 -&gt; R8	# spill size = 64
2c6c +  spill R18 -&gt; [sp, #0]	# spill size = 64
2c70    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:4 (line 335) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=#NULL
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop off=11380/0x2c74}
2c74    #@ShouldNotReachHere

2c80    B412: #	out( N6590 ) &lt;- in( B4 )  Freq: 5.06356e-07
2c80 +  li R11, #-10	# int, #@loadConI
2c84    spill R9 -&gt; R8	# spill size = 64
2c88 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2c8c +  spill R30 -&gt; [sp, #8]	# spill size = 32
2c90    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ArrayDeque::elementAt @ bci:2 (line 259) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=sp + #8
        # java.util.ArrayDeque::peekFirst @ bci:8 (line 418) L[0]=_
        # java.util.ArrayDeque::peek @ bci:1 (line 564) L[0]=_
        # java.nio.file.FileTreeWalker::next @ bci:4 (line 335) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop off=11412/0x2c94}
2c94    #@ShouldNotReachHere

2ca0    B413: #	out( N6590 ) &lt;- in( B9 )  Freq: 5.05848e-07
2ca0 +  li R11, #-10	# int, #@loadConI
2ca4    spill R9 -&gt; R8	# spill size = 64
2ca8 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2cac +  spill R24 -&gt; [sp, #8]	# spill size = 64
2cb0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=#NULL L[6]=_ STK[0]=#NULL
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=11444/0x2cb4}
2cb4    #@ShouldNotReachHere

2cc0    B414: #	out( N6590 ) &lt;- in( B14 )  Freq: 5.05847e-07
2cc0 +  li R11, #-10	# int, #@loadConI
2cc4    spill R9 -&gt; R8	# spill size = 64
2cc8 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2ccc +  spill R24 -&gt; [sp, #8]	# spill size = 64
2cd0 +  spill R19 -&gt; [sp, #24]	# spill size = 64
2cd4 +  spill R19 -&gt; [sp, #32]	# spill size = 64
2cd8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:27 (line 162) L[0]=sp + #24 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #24 MON-BOX0=sp+144 MON-OBJ[0]=sp + #24
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #24 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop off=11484/0x2cdc}
2cdc    #@ShouldNotReachHere

2ce8    B415: #	out( N6590 ) &lt;- in( B15 )  Freq: 5.05846e-07
2ce8 +  li R11, #-10	# int, #@loadConI
2cec    spill R9 -&gt; R8	# spill size = 64
2cf0 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2cf4 +  spill R24 -&gt; [sp, #8]	# spill size = 64
2cf8 +  spill R19 -&gt; [sp, #24]	# spill size = 64
2cfc +  spill R19 -&gt; [sp, #32]	# spill size = 64
2d00    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream::readLock @ bci:4 (line 75) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:27 (line 162) L[0]=sp + #24 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #24 MON-BOX0=sp+144 MON-OBJ[0]=sp + #24
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #24 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop off=11524/0x2d04}
2d04    #@ShouldNotReachHere

2d10    B416: #	out( N6590 ) &lt;- in( B16 )  Freq: 5.05846e-07
2d10 +  li R11, #-10	# int, #@loadConI
2d14    spill R9 -&gt; R8	# spill size = 64
2d18 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2d1c +  spill R24 -&gt; [sp, #8]	# spill size = 64
2d20 +  spill R19 -&gt; [sp, #24]	# spill size = 64
2d24 +  spill R19 -&gt; [sp, #32]	# spill size = 64
2d28    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #24 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #24 MON-BOX0=sp+144 MON-OBJ[0]=sp + #24
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #24 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop off=11564/0x2d2c}
2d2c    #@ShouldNotReachHere

2d38    B417: #	out( N6590 ) &lt;- in( B18 )  Freq: 5.05844e-07
2d38 +  li R11, #-10	# int, #@loadConI
2d3c    spill R9 -&gt; R8	# spill size = 64
2d40 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2d44 +  spill R24 -&gt; [sp, #8]	# spill size = 64
2d48 +  spill R19 -&gt; [sp, #24]	# spill size = 64
2d4c +  spill R19 -&gt; [sp, #32]	# spill size = 64
2d50    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_ STK[0]=#NULL STK[1]=#1
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #24 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #24 MON-BOX0=sp+144 MON-OBJ[0]=sp + #24
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #24 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=Oop off=11604/0x2d54}
2d54    #@ShouldNotReachHere

2d60    B418: #	out( N6590 ) &lt;- in( B47 )  Freq: 4.91993e-07
2d60 +  li R11, #-10	# int, #@loadConI
2d64    spill [sp, #8] -&gt; R8	# spill size = 64
2d68 +  spill R20 -&gt; [sp, #56]	# spill size = 64
2d6c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:133 (line 182) L[0]=sp + #0 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [56]=Oop off=11632/0x2d70}
2d70    #@ShouldNotReachHere

2d7c    B419: #	out( N6590 ) &lt;- in( B48 )  Freq: 4.91992e-07
2d7c +  li R11, #-10	# int, #@loadConI
2d80    spill [sp, #8] -&gt; R8	# spill size = 64
2d84 +  spill R20 -&gt; [sp, #56]	# spill size = 64
2d88    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=sp + #56
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [56]=Oop off=11660/0x2d8c}
2d8c    #@ShouldNotReachHere

2d98    B420: #	out( N6590 ) &lt;- in( B51 )  Freq: 4.91991e-07
2d98 +  li R11, #-10	# int, #@loadConI
2d9c    spill [sp, #8] -&gt; R8	# spill size = 64
2da0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:1 (line 357) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=11684/0x2da4}
2da4    #@ShouldNotReachHere

2db0    B421: #	out( N6590 ) &lt;- in( B69 )  Freq: 4.91989e-07
2db0 +  spill [sp, #8] -&gt; R8	# spill size = 64
2db4 +  li R11, #-10	# int, #@loadConI
2db8    spill R19 -&gt; [sp, #8]	# spill size = 64
2dbc +  spill R19 -&gt; [sp, #32]	# spill size = 64
2dc0 +  spill R18 -&gt; [sp, #56]	# spill size = 64
2dc4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:145 (line 186) L[0]=sp + #8 L[1]=_ L[2]=sp + #56 L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #32 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [56]=Oop off=11720/0x2dc8}
2dc8    #@ShouldNotReachHere

2dd4    B422: #	out( N6590 ) &lt;- in( B86 )  Freq: 4.91414e-07
2dd4 +  spill [sp, #8] -&gt; R8	# spill size = 64
2dd8 +  li R11, #-10	# int, #@loadConI
2ddc    spill R29 -&gt; [sp, #8]	# spill size = 64
2de0 +  spill R29 -&gt; [sp, #32]	# spill size = 64
2de4 +  spill R7 -&gt; [sp, #40]	# spill size = 64
2de8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::provider @ bci:6 (line 105) L[0]=_ STK[0]=#NULL
        # java.nio.file.Files::readAttributes @ bci:1 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop off=11756/0x2dec}
2dec    #@ShouldNotReachHere

2df8    B423: #	out( N6590 ) &lt;- in( B88 )  Freq: 4.91413e-07
2df8 +  spill [sp, #8] -&gt; R8	# spill size = 64
2dfc +  li R11, #-10	# int, #@loadConI
2e00    spill R29 -&gt; [sp, #8]	# spill size = 64
2e04 +  spill R29 -&gt; [sp, #32]	# spill size = 64
2e08 +  spill R7 -&gt; [sp, #40]	# spill size = 64
2e0c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.Util::followLinks @ bci:5 (line 121) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # sun.nio.fs.UnixFileSystemProvider::getFileAttributeView @ bci:7 (line 120) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # sun.nio.fs.LinuxFileSystemProvider::getFileAttributeView @ bci:48 (line 68) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:51 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop off=11792/0x2e10}
2e10    #@ShouldNotReachHere

2e1c    B424: #	out( N6590 ) &lt;- in( B140 )  Freq: 4.91392e-07
2e1c +  spill [sp, #8] -&gt; R8	# spill size = 64
2e20 +  spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
2e28 +  li R11, #-10	# int, #@loadConI
2e2c    spill R12 -&gt; [sp, #16]	# spill size = 64
2e30    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:42 (line 287) L[0]=sp + #8 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=sp + #16 L[5]=_ L[6]=_ L[7]=_ STK[0]=#NULL
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop off=11828/0x2e34}
2e34    #@ShouldNotReachHere

2e40    B425: #	out( N6590 ) &lt;- in( B141 )  Freq: 4.91392e-07
2e40 +  spill [sp, #8] -&gt; R8	# spill size = 64
2e44 +  spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
2e4c +  li R11, #-10	# int, #@loadConI
2e50    spill R12 -&gt; [sp, #16]	# spill size = 64
2e54    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ArrayDeque::size @ bci:12 (line 649) L[0]=_ STK[0]=_ STK[1]=_ STK[2]=#NULL
        # java.nio.file.FileTreeWalker::visit @ bci:42 (line 287) L[0]=sp + #8 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=sp + #16 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop off=11864/0x2e58}
2e58    #@ShouldNotReachHere

2e64    B426: #	out( N6590 ) &lt;- in( B144 )  Freq: 4.91391e-07
2e64 +  spill [sp, #8] -&gt; R8	# spill size = 64
2e68 +  spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
2e70 +  li R11, #-10	# int, #@loadConI
2e74    spill R30 -&gt; [sp, #16]	# spill size = 64
2e78    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes::isDirectory @ bci:4 (line 299) L[0]=_ STK[0]=#NULL
        # java.nio.file.FileTreeWalker::visit @ bci:58 (line 288) L[0]=sp + #8 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=sp + #16 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop off=11900/0x2e7c}
2e7c    #@ShouldNotReachHere

2e88    B427: #	out( N6590 ) &lt;- in( B103 )  Freq: 4.91229e-07
2e88 +  spill [sp, #8] -&gt; R8	# spill size = 64
2e8c +  li R11, #-10	# int, #@loadConI
2e90    spill R29 -&gt; [sp, #8]	# spill size = 64
2e94 +  spill R29 -&gt; [sp, #32]	# spill size = 64
2e98 +  spill R7 -&gt; [sp, #40]	# spill size = 64
2e9c +  spill R30 -&gt; [sp, #56]	# spill size = 64
2ea0 +  spill R9 -&gt; [sp, #64]	# spill size = 32
2ea4 +  spill R7 -&gt; [sp, #72]	# spill size = 64
2ea8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getByteArrayForSysCalls @ bci:4 (line 135) L[0]=_ L[1]=_ STK[0]=#NULL
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:1 (line 37) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [72]=Oop off=11948/0x2eac}
2eac    #@ShouldNotReachHere

2eb8    B428: #	out( N6590 ) &lt;- in( B105 )  Freq: 4.91228e-07
2eb8 +  spill [sp, #8] -&gt; R8	# spill size = 64
2ebc +  li R11, #-10	# int, #@loadConI
2ec0    spill R29 -&gt; [sp, #8]	# spill size = 64
2ec4 +  spill R29 -&gt; [sp, #32]	# spill size = 64
2ec8 +  spill R7 -&gt; [sp, #40]	# spill size = 64
2ecc +  spill R30 -&gt; [sp, #56]	# spill size = 64
2ed0 +  spill R9 -&gt; [sp, #64]	# spill size = 32
2ed4 +  spill R7 -&gt; [sp, #72]	# spill size = 64
2ed8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::isEmpty @ bci:4 (line 216) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::getByteArrayForSysCalls @ bci:26 (line 138) L[0]=_ L[1]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:1 (line 37) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [72]=Oop off=11996/0x2edc}
2edc    #@ShouldNotReachHere

2ee8    B429: #	out( N6590 ) &lt;- in( B107 )  Freq: 4.91227e-07
2ee8 +  spill [sp, #8] -&gt; R8	# spill size = 64
2eec +  li R11, #-10	# int, #@loadConI
2ef0    spill R29 -&gt; [sp, #8]	# spill size = 64
2ef4 +  spill R29 -&gt; [sp, #32]	# spill size = 64
2ef8 +  spill R7 -&gt; [sp, #40]	# spill size = 64
2efc +  spill R30 -&gt; [sp, #56]	# spill size = 64
2f00 +  spill R9 -&gt; [sp, #64]	# spill size = 32
2f04 +  spill R7 -&gt; [sp, #72]	# spill size = 64
2f08    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [72]=Oop off=12044/0x2f0c}
2f0c    #@ShouldNotReachHere

2f18    B430: #	out( N6590 ) &lt;- in( B109 )  Freq: 4.91226e-07
2f18 +  spill [sp, #8] -&gt; R8	# spill size = 64
2f1c +  li R11, #-10	# int, #@loadConI
2f20    spill R29 -&gt; [sp, #8]	# spill size = 64
2f24 +  spill R29 -&gt; [sp, #32]	# spill size = 64
2f28 +  spill R7 -&gt; [sp, #40]	# spill size = 64
2f2c +  spill R30 -&gt; [sp, #56]	# spill size = 64
2f30 +  spill R9 -&gt; [sp, #64]	# spill size = 32
2f34 +  spill R7 -&gt; [sp, #72]	# spill size = 64
2f38    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:8 (line 434) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [72]=Oop off=12092/0x2f3c}
2f3c    #@ShouldNotReachHere

2f48    B431: #	out( N6590 ) &lt;- in( B113 )  Freq: 4.91225e-07
2f48 +  spill [sp, #8] -&gt; R8	# spill size = 64
2f4c +  li R11, #-12	# int, #@loadConI
2f50    spill R29 -&gt; [sp, #8]	# spill size = 64
2f54 +  spill R29 -&gt; [sp, #32]	# spill size = 64
2f58 +  spill R7 -&gt; [sp, #40]	# spill size = 64
2f5c +  spill R30 -&gt; [sp, #56]	# spill size = 64
2f60 +  spill R7 -&gt; [sp, #64]	# spill size = 64
2f64 +  spill R12 -&gt; [sp, #72]	# spill size = 64
2f68 +  spill R19 -&gt; [sp, #84]	# spill size = 32
2f6c +  spill R9 -&gt; [sp, #88]	# spill size = 32
2f70    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:6 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #40 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #88, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop off=12148/0x2f74}
2f74    #@ShouldNotReachHere

2f80    B432: #	out( N6590 ) &lt;- in( B125 )  Freq: 4.91213e-07
2f80 +  li R11, #-10	# int, #@loadConI
2f84    spill [sp, #8] -&gt; R8	# spill size = 64
2f88    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=12172/0x2f8c}
2f8c    #@ShouldNotReachHere

2f98    B433: #	out( N6590 ) &lt;- in( B127 )  Freq: 4.91213e-07
2f98 +  li R11, #-10	# int, #@loadConI
2f9c    spill [sp, #8] -&gt; R8	# spill size = 64
2fa0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:8 (line 434) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=12196/0x2fa4}
2fa4    #@ShouldNotReachHere

2fb0    B434: #	out( N6590 ) &lt;- in( B131 )  Freq: 4.91211e-07
2fb0 +  li R11, #-12	# int, #@loadConI
2fb4    spill [sp, #8] -&gt; R8	# spill size = 64
2fb8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:6 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop off=12220/0x2fbc}
2fbc    #@ShouldNotReachHere

2fc8    B435: #	out( N6590 ) &lt;- in( B70 )  Freq: 2.31524e-07
2fc8 +  spill [sp, #8] -&gt; R7	# spill size = 64
2fcc +  li R11, #-187	# int, #@loadConI
2fd0    spill R7 -&gt; [sp, #0]	# spill size = 64
2fd4 +  spill R19 -&gt; [sp, #32]	# spill size = 64
2fd8 +  spill R19 -&gt; [sp, #40]	# spill size = 64
2fdc +  spill R18 -&gt; [sp, #64]	# spill size = 64
2fe0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:148 (line 186) L[0]=sp + #32 L[1]=_ L[2]=sp + #64 L[3]=_ L[4]=_ STK[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #40 STK[0]=sp + #32 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #32 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [64]=Oop off=12260/0x2fe4}
2fe4    #@ShouldNotReachHere

2ff0    B436: #	out( N6590 ) &lt;- in( B80 )  Freq: 2.31254e-07
2ff0 +  spill [sp, #8] -&gt; R7	# spill size = 64
2ff4 +  li R11, #-187	# int, #@loadConI
2ff8    spill R7 -&gt; [sp, #0]	# spill size = 64
2ffc +  spill R19 -&gt; [sp, #32]	# spill size = 64
3000    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::next @ bci:4 (line 205) L[0]=sp + #32 L[1]=_ STK[0]=R8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #32
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::next @ bci:1 (line 132) L[0]=_
        # java.nio.file.FileTreeWalker::next @ bci:47 (line 350) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop off=12292/0x3004}
3004    #@ShouldNotReachHere

3010    B437: #	out( N6590 ) &lt;- in( B108 )  Freq: 2.31166e-07
3010 +  spill [sp, #8] -&gt; R8	# spill size = 64
3014 +  li R11, #-187	# int, #@loadConI
3018    spill R29 -&gt; [sp, #8]	# spill size = 64
301c +  spill R29 -&gt; [sp, #32]	# spill size = 64
3020 +  spill R7 -&gt; [sp, #40]	# spill size = 64
3024 +  spill R30 -&gt; [sp, #56]	# spill size = 64
3028 +  spill R7 -&gt; [sp, #64]	# spill size = 64
302c +  spill R12 -&gt; [sp, #72]	# spill size = 64
3030 +  spill R19 -&gt; [sp, #84]	# spill size = 32
3034 +  spill R16 -&gt; [sp, #88]	# spill size = 64
3038 +  spill R15 -&gt; [sp, #104]	# spill size = 64
303c +  spill R9 -&gt; [sp, #112]	# spill size = 32
3040    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal::get @ bci:11 (line 164) L[0]=sp + #88 L[1]=_ L[2]=sp + #104 L[3]=_ L[4]=_ STK[0]=sp + #104
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #40 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #112, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [88]=Oop [104]=Oop off=12356/0x3044}
3044    #@ShouldNotReachHere

3050    B438: #	out( N6590 ) &lt;- in( B111 )  Freq: 2.31165e-07
3050 +  spill [sp, #8] -&gt; R8	# spill size = 64
3054 +  li R11, #-187	# int, #@loadConI
3058    spill R29 -&gt; [sp, #8]	# spill size = 64
305c +  spill R29 -&gt; [sp, #32]	# spill size = 64
3060 +  spill R7 -&gt; [sp, #40]	# spill size = 64
3064 +  spill R30 -&gt; [sp, #56]	# spill size = 64
3068 +  spill R7 -&gt; [sp, #64]	# spill size = 64
306c +  spill R12 -&gt; [sp, #72]	# spill size = 64
3070 +  spill R19 -&gt; [sp, #84]	# spill size = 32
3074 +  spill R15 -&gt; [sp, #96]	# spill size = 64
3078 +  spill R16 -&gt; [sp, #104]	# spill size = 64
307c +  spill R13 -&gt; [sp, #112]	# spill size = 32
3080 +  spill R20 -&gt; [sp, #128]	# spill size = 64
3084 +  spill R9 -&gt; [sp, #116]	# spill size = 32
3088    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:21 (line 436) L[0]=sp + #96 L[1]=sp + #104 L[2]=sp + #112 L[3]=sp + #128 STK[0]=sp + #128
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #104 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #40 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #116, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [96]=Oop [104]=Oop [128]=Oop off=12428/0x308c}
308c    #@ShouldNotReachHere

3098    B439: #	out( N6590 ) &lt;- in( B116 )  Freq: 2.31164e-07
3098 +  spill [sp, #8] -&gt; R8	# spill size = 64
309c +  li R11, #-187	# int, #@loadConI
30a0    spill R29 -&gt; [sp, #8]	# spill size = 64
30a4 +  spill R29 -&gt; [sp, #32]	# spill size = 64
30a8 +  spill R7 -&gt; [sp, #40]	# spill size = 64
30ac +  spill R30 -&gt; [sp, #56]	# spill size = 64
30b0 +  spill R7 -&gt; [sp, #64]	# spill size = 64
30b4 +  spill R12 -&gt; [sp, #72]	# spill size = 64
30b8 +  spill R19 -&gt; [sp, #84]	# spill size = 32
30bc +  spill R18 -&gt; [sp, #88]	# spill size = 64
30c0 +  spill R21 -&gt; [sp, #104]	# spill size = 64
30c4 +  spill R9 -&gt; [sp, #112]	# spill size = 32
30c8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:26 (line 76) L[0]=sp + #84 L[1]=sp + #88 L[2]=#0 L[3]=sp + #104 STK[0]=sp + #104
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #40 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #56 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #56
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #112, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [88]=Oop [104]=Oop off=12492/0x30cc}
30cc    #@ShouldNotReachHere

30d8    B440: #	out( N6590 ) &lt;- in( B126 )  Freq: 2.31159e-07
30d8 +  li R11, #-187	# int, #@loadConI
30dc    spill [sp, #8] -&gt; R8	# spill size = 64
30e0 +  spill R28 -&gt; [sp, #0]	# spill size = 64
30e4 +  spill R30 -&gt; [sp, #64]	# spill size = 64
30e8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal::get @ bci:11 (line 164) L[0]=sp + #0 L[1]=_ L[2]=sp + #64 L[3]=_ L[4]=_ STK[0]=sp + #64
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=12524/0x30ec}
30ec    #@ShouldNotReachHere

30f8    B441: #	out( N6590 ) &lt;- in( B129 )  Freq: 2.31158e-07
30f8 +  spill [sp, #8] -&gt; R8	# spill size = 64
30fc +  li R11, #-187	# int, #@loadConI
3100    spill R30 -&gt; [sp, #8]	# spill size = 64
3104 +  spill R28 -&gt; [sp, #64]	# spill size = 64
3108 +  spill R29 -&gt; [sp, #52]	# spill size = 32
310c +  spill R7 -&gt; [sp, #80]	# spill size = 64
3110    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:21 (line 436) L[0]=sp + #8 L[1]=sp + #64 L[2]=sp + #52 L[3]=sp + #80 STK[0]=sp + #80
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #64 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [80]=Oop off=12564/0x3114}
3114    #@ShouldNotReachHere

3120    B442: #	out( B518 B491 ) &lt;- in( B187 )  Freq: 1.42163e-07
3120     -- 	// exception oop; no code emitted, #@CreateException
3120 +  spill R10 -&gt; R11	# spill size = 64
3124    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::next @ bci:76 (line 361) L[0]=sp + #16 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=12584/0x3128}

3128    B443: #	out( B492 B517 B493 ) &lt;- in( B196 )  Freq: 1.35411e-07
3128     -- 	// exception oop; no code emitted, #@CreateException
3128 +  spill R10 -&gt; R11	# spill size = 64
312c    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::visit @ bci:131 (line 301) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=12592/0x3130}

3130    B444: #	out( N6590 ) &lt;- in( B167 )  Freq: 2.69214e-08
3130 +  li R11, #-10	# int, #@loadConI
3134    spill [sp, #8] -&gt; R8	# spill size = 64
3138    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:27 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=12604/0x313c}
313c    #@ShouldNotReachHere

3148    B445: #	out( N6590 ) &lt;- in( B168 )  Freq: 2.69213e-08
3148 +  li R11, #-10	# int, #@loadConI
314c    spill [sp, #8] -&gt; R8	# spill size = 64
3150    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream::readLock @ bci:4 (line 75) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:27 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=12628/0x3154}
3154    #@ShouldNotReachHere

3160    B446: #	out( N6590 ) &lt;- in( B169 )  Freq: 2.69213e-08
3160 +  li R11, #-10	# int, #@loadConI
3164    spill [sp, #8] -&gt; R8	# spill size = 64
3168    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=12652/0x316c}
316c    #@ShouldNotReachHere

3178    B447: #	out( N6590 ) &lt;- in( B171 )  Freq: 2.69213e-08
3178 +  li R11, #-10	# int, #@loadConI
317c    spill [sp, #8] -&gt; R8	# spill size = 64
3180    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_ STK[0]=#NULL STK[1]=#1
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=12676/0x3184}
3184    #@ShouldNotReachHere

3190    B448: #	out( N6590 ) &lt;- in( B185 )  Freq: 1.44051e-08
3190 +  li R11, #-10	# int, #@loadConI
3194    spill [sp, #8] -&gt; R8	# spill size = 64
3198    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:76 (line 361) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_ STK[0]=#NULL
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop off=12700/0x319c}
319c    #@ShouldNotReachHere

31a8    B449: #	out( B494 B497 ) &lt;- in( B276 )  Freq: 4.85033e-10
31a8     -- 	// exception oop; no code emitted, #@CreateException
31a8 +  spill R10 -&gt; R11	# spill size = 64
31ac    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:20 (line 53) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [40]=Oop off=12720/0x31b0}

31b0    B450: #	out( N6590 ) &lt;- in( B510 )  Freq: 5.25879e-11
31b0     -- 	// exception oop; no code emitted, #@CreateException
31b0 +  spill R10 -&gt; [sp, #0]	# spill size = 64
31b4 +  li R11, #-75	# int, #@loadConI
31b8    spill [sp, #8] -&gt; R8	# spill size = 64
31bc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:59 (line 352) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=_ L[5]=_ L[6]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=12736/0x31c0}
31c0    #@ShouldNotReachHere

31cc    B451: #	out( N6590 ) &lt;- in( B403 )  Freq: 5.25791e-11
31cc     -- 	// exception oop; no code emitted, #@CreateException
31cc +  spill R10 -&gt; [sp, #32]	# spill size = 64
31d0 +  li R11, #-75	# int, #@loadConI
31d4    spill [sp, #8] -&gt; R8	# spill size = 64
31d8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:71 (line 167) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #32
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop off=12764/0x31dc}
31dc    #@ShouldNotReachHere

31e8    B452: #	out( B454 B453 ) &lt;- in( B403 )  Freq: 5.25791e-11
31e8     -- 	// exception oop; no code emitted, #@CreateException
31e8 +  #@membar_release_lock (elided)
31e8    add R29, sp, #144	# box lock
31ec +  spill [sp, #0] -&gt; R18	# spill size = 64
31f0 +  fastunlock R18,R29	! kills R28, R7, #@cmpFastUnlock
3268 +  spill R10 -&gt; R9	# spill size = 64
326c +  far_bne RFLAGS, zr, B454	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

3274    B453: #	out( B516 B498 ) &lt;- in( B454 B452 )  Freq: 5.25791e-11
3274 +  spill R9 -&gt; R11	# spill size = 64
3278 +  spill R18 -&gt; R8	# spill size = 64
327c    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=R8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop off=12928/0x3280}

3280    B454: #	out( B453 ) &lt;- in( B452 )  Freq: 5.25791e-17
3280    add R11, sp, #144	# box lock
3284 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3284    spill R23 -&gt; R12	# spill size = 64
3288 +  spill R18 -&gt; R10	# spill size = 64
328c +  CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
32bc +  j  B453	#@branch

32c0    B455: #	out( N6590 ) &lt;- in( B476 )  Freq: 4.85011e-11
32c0     -- 	// exception oop; no code emitted, #@CreateException
32c0 +  spill R10 -&gt; [sp, #0]	# spill size = 64
32c4 +  li R11, #-75	# int, #@loadConI
32c8    spill [sp, #8] -&gt; R8	# spill size = 64
32cc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:24 (line 54) L[0]=#ScObj0 L[1]=_ STK[0]=sp + #0
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop off=13008/0x32d0}
32d0    #@ShouldNotReachHere

32dc    B456: #	out( N6590 ) &lt;- in( B462 )  Freq: 4.91223e-12
32dc +  li R11, #-10	# int, #@loadConI
32e0    spill [sp, #8] -&gt; R8	# spill size = 64
32e4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [64]=Oop off=13032/0x32e8}
32e8    #@ShouldNotReachHere

32f4    B457: #	out( N6590 ) &lt;- in( B464 )  Freq: 4.91223e-12
32f4 +  li R11, #-10	# int, #@loadConI
32f8    spill [sp, #8] -&gt; R8	# spill size = 64
32fc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:8 (line 434) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [64]=Oop off=13056/0x3300}
3300    #@ShouldNotReachHere

330c    B458: #	out( N6590 ) &lt;- in( B468 )  Freq: 4.91221e-12
330c +  li R11, #-12	# int, #@loadConI
3310    spill [sp, #8] -&gt; R8	# spill size = 64
3314    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:6 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=13080/0x3318}
3318    #@ShouldNotReachHere

3324    B459: #	out( B473 ) &lt;- in( B478 )  Freq: 2.42385e-12
3324 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3324    spill R23 -&gt; R11	# spill size = 64
3328 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
3358 +  j  B473	#@branch

335c    B460: #	out( B476 ) &lt;- in( B274 )  Freq: 4.85052e-10
335c     -- 	// exception oop; no code emitted, #@CreateException
335c +  spill R10 -&gt; R11	# spill size = 64
3360 +  j  B476	#@branch

3364    B461: #	out( B476 ) &lt;- in( B268 )  Freq: 1.80146e-09
3364     -- 	// exception oop; no code emitted, #@CreateException
3364 +  spill R10 -&gt; R11	# spill size = 64
3368 +  j  B476	#@branch

336c    B462: #	out( B456 B463 ) &lt;- in( B124 )  Freq: 4.84786e-06
336c     -- 	// exception oop; no code emitted, #@CreateException
336c +  mv  R7, java/lang/Class:exact *	# ptr, #@loadConP
3384    spill R10 -&gt; [sp, #64]	# spill size = 64
3388 +  lwu  R10, [R7, #116]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/NativeBuffers.threadLocal
338c +  lwu  R7, [R8, #68]	# loadN, compressed ptr, #@loadN ! Field: java/lang/Thread.threadLocals
3390 +  decode_heap_oop  R30, R10	#@decodeHeapOop
3394 +  decode_heap_oop  R31, R7	#@decodeHeapOop
3398    lw  R28, [R30, #12]	# int, #@loadI ! Field: java/lang/ThreadLocal.threadLocalHashCode (constant)
339c    NullCheck R30

339c    B463: #	out( B489 B464 ) &lt;- in( B462 )  Freq: 4.84785e-06
339c    lwu  R7, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap.table
33a0    NullCheck R31

33a0    B464: #	out( B457 B465 ) &lt;- in( B463 )  Freq: 4.84785e-06
33a0 +  decode_heap_oop  R12, R7	#@decodeHeapOop
33a4    lwu  R29, [R12, #12]	# range, #@loadRange
33a8    NullCheck R12

33a8    B465: #	out( B484 B466 ) &lt;- in( B464 )  Freq: 4.84785e-06
33a8 +  addiw  R7, R29, #-1	#@addI_reg_imm
33ac +  andr  R28, R28, R7	#@andI_reg_reg
33b0 +  addw  R7, R28, zr	#@convI2L_reg_reg
33b4 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
33b8 +  add R7, R12, R7	# ptr, #@addP_reg_reg
33bc +  bleu  R29, zr, B484	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

33c0    B466: #	out( B490 B467 ) &lt;- in( B465 )  Freq: 4.84784e-06
33c0 +  lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN
33c4 +  decode_heap_oop  R7, R7	#@decodeHeapOop
33c8    lwu  R29, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
33cc    NullCheck R7

33cc    B467: #	out( B485 B468 ) &lt;- in( B466 )  Freq: 4.84784e-06
33cc    
33cc +  lwu  R11, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap$Entry.value
33d0 +  decode_heap_oop  R12, R11	#@decodeHeapOop
33d4 +  bne  R29, R10, B485	#@cmpN_branch  P=0.000001 C=-1.000000

33d8    B468: #	out( B458 B469 ) &lt;- in( B467 )  Freq: 4.84783e-06
33d8    lwu  R7, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
33dc    NullCheck R12

33dc    B469: #	out( B488 B470 ) &lt;- in( B468 )  Freq: 4.84783e-06
33dc +  mv  R29, narrowklass: precise klass [Lsun/nio/fs/NativeBuffer;: 0x00000040d0586160:Constant:exact *	# compressed klass ptr, #@loadConNKlass
33ec +  bne  R7, R29, B488	#@cmpN_branch  P=0.000000 C=-1.000000

33f0    B470: #	out( B486 B471 ) &lt;- in( B469 )  Freq: 4.84783e-06
33f0 +  # checkcastPP of R12, #@checkCastPP
33f0    lwu  R7, [R12, #12]	# range, #@loadRange
33f4 +  addi  R9, R12, #16	# ptr, #@addP_reg_imm
33f8 +  bleu  R7, zr, B486	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

33fc    B471: #	out( B487 B472 ) &lt;- in( B470 )  Freq: 4.84782e-06
33fc +  lwu  R28, [R9]	# loadN, compressed ptr, #@loadN
3400 +  decode_heap_oop  R8, R28	#@decodeHeapOop
3404 +  bne   R8, zr, B487	#@cmpP_imm0_branch  P=0.000000 C=2801.000000

3408    B472: #	out( B477 B473 ) &lt;- in( B471 )  Freq: 4.84782e-06
3408 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3408    lb  R7, [R23, #56]	# byte, #@loadB
340c +  bne  R7, zr, B477	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

3410    B473: #	out( B475 B474 ) &lt;- in( B459 B479 B477 B472 )  Freq: 4.84782e-06
3410 +  mv  R7, R9	# ptr -&gt; long, #@castP2X
3414    spill [sp, #56] -&gt; R28	# spill size = 64
3418 +  mv  R28, R28	# ptr -&gt; long, #@castP2X
3418 +  xorr  R28, R28, R7	#@xorL_reg_reg
341c +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
3420    spill [sp, #0] -&gt; R29	# spill size = 32
3424 +  sw  R29, [R9]	# compressed ptr, #@storeN
3428 +  beq  R28, zr, B475	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

342c    B474: #	out( B480 B475 ) &lt;- in( B473 )  Freq: 4.84297e-06
342c +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
3430 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
343c +  add R10, R28, R7	# ptr, #@addP_reg_reg
3440 +  lb  R28, [R10]	# byte, #@loadB
3444 +  li R29, #4	# int, #@loadConI
3448 +  bne  R28, R29, B480	#@cmpI_branch  P=0.001000 C=-1.000000

344c    B475: #	out( B476 ) &lt;- in( B482 B483 B480 B474 B473 )  Freq: 4.84782e-06
344c +  spill [sp, #64] -&gt; R11	# spill size = 64

3450    B476: #	out( B495 B455 ) &lt;- in( B460 B461 B475 )  Freq: 4.85011e-06
3450    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [40]=Oop off=13396/0x3454}

3454    B477: #	out( B473 B478 ) &lt;- in( B472 )  Freq: 4.84776e-09
3454 +  lwu  R28, [R9]	# loadN, compressed ptr, #@loadN
3458 +  decode_heap_oop  R10, R28	#@decodeHeapOop
345c +  beq   R10, zr, B473	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

3460    B478: #	out( B459 B479 ) &lt;- in( B477 )  Freq: 2.42388e-09
3460 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3460    ld  R7, [R23, #32]	# int, #@loadL
3464 +  beq  R7, zr, B459	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

3468    B479: #	out( B473 ) &lt;- in( B478 )  Freq: 2.42146e-09
3468 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3468    ld  R28, [R23, #48]	# ptr, #@loadP
346c +  add R28, R28, R7	# ptr, #@addP_reg_reg
3470 +  addi  R7, R7, #-8	#@addL_reg_imm
3474 +  sd  R10, [R28, #-8]	# ptr, #@storeP
3478 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3478    sd  R7, [R23, #32]	# long, #@storeL
347c +  j  B473	#@branch

3480    B480: #	out( B475 B481 ) &lt;- in( B474 )  Freq: 4.84297e-09
3480 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3480    ld  R7, [R23, #64]	# int, #@loadL
3484 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3484    ld  R28, [R23, #80]	# ptr, #@loadP
3488 +  #@membar_volatile
	fence iorw iorw
348c +  lb  R29, [R10]	# byte, #@loadB
3490 +  beq  R29, zr, B475	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

3494    B481: #	out( B483 B482 ) &lt;- in( B480 )  Freq: 2.42149e-09
3494 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
3498 +  bne  R7, zr, B483	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

349c    B482: #	out( B475 ) &lt;- in( B481 )  Freq: 1.21074e-09
349c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
349c    spill R23 -&gt; R11	# spill size = 64
34a0 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
34d0 +  j  B475	#@branch

34d4    B483: #	out( B475 ) &lt;- in( B481 )  Freq: 1.21074e-09
34d4 +  add R28, R28, R7	# ptr, #@addP_reg_reg
34d8 +  addi  R7, R7, #-8	#@addL_reg_imm
34dc +  sd  R10, [R28, #-8]	# ptr, #@storeP
34e0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
34e0    sd  R7, [R23, #64]	# long, #@storeL
34e4 +  j  B475	#@branch

34e8    B484: #	out( N6590 ) &lt;- in( B465 )  Freq: 4.84785e-12
34e8 +  spill [sp, #8] -&gt; R8	# spill size = 64
34ec +  li R11, #-28	# int, #@loadConI
34f0    spill R31 -&gt; [sp, #8]	# spill size = 64
34f4 +  spill R30 -&gt; [sp, #72]	# spill size = 64
34f8 +  spill R12 -&gt; [sp, #80]	# spill size = 64
34fc +  spill R28 -&gt; [sp, #88]	# spill size = 32
3500    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:18 (line 435) L[0]=sp + #8 L[1]=sp + #72 L[2]=sp + #88 L[3]=_ STK[0]=sp + #80 STK[1]=sp + #88
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #72 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [80]=Oop off=13572/0x3504}
3504    #@ShouldNotReachHere

3510    B485: #	out( N6590 ) &lt;- in( B467 )  Freq: 4.84784e-12
3510 +  spill [sp, #8] -&gt; R8	# spill size = 64
3514 +  li R11, #-187	# int, #@loadConI
3518    spill R31 -&gt; [sp, #8]	# spill size = 64
351c +  spill R30 -&gt; [sp, #72]	# spill size = 64
3520 +  spill R28 -&gt; [sp, #52]	# spill size = 32
3524 +  spill R7 -&gt; [sp, #80]	# spill size = 64
3528    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:29 (line 436) L[0]=sp + #8 L[1]=sp + #72 L[2]=sp + #52 L[3]=sp + #80 STK[0]=#0
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #72 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [80]=Oop off=13612/0x352c}
352c    #@ShouldNotReachHere

3538    B486: #	out( N6590 ) &lt;- in( B470 )  Freq: 4.84783e-12
3538 +  spill [sp, #8] -&gt; R8	# spill size = 64
353c +  li R11, #-28	# int, #@loadConI
3540    spill R12 -&gt; [sp, #8]	# spill size = 64
3544    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:40 (line 115) L[0]=sp + #56 L[1]=sp + #8 L[2]=#0 L[3]=_ STK[0]=sp + #8 STK[1]=#0
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=13640/0x3548}
3548    #@ShouldNotReachHere

3554    B487: #	out( N6590 ) &lt;- in( B471 )  Freq: 2.42391e-12
3554 +  spill [sp, #8] -&gt; R7	# spill size = 64
3558 +  li R11, #-187	# int, #@loadConI
355c    spill R7 -&gt; [sp, #0]	# spill size = 64
3560 +  spill R12 -&gt; [sp, #8]	# spill size = 64
3564    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:41 (line 115) L[0]=sp + #56 L[1]=sp + #8 L[2]=#0 L[3]=_ STK[0]=R8
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=13672/0x3568}
3568    #@ShouldNotReachHere

3574    B488: #	out( N6590 ) &lt;- in( B469 )  Freq: 1e-35
3574 +  li R11, #-34	# int, #@loadConI
3578    spill [sp, #8] -&gt; R8	# spill size = 64
357c +  spill R12 -&gt; [sp, #0]	# spill size = 64
3580    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:6 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #0
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=13700/0x3584}
3584    #@ShouldNotReachHere

3590    B489: #	out( N6590 ) &lt;- in( B463 )  Freq: 2.31164e-12
3590 +  li R11, #-187	# int, #@loadConI
3594    spill [sp, #8] -&gt; R8	# spill size = 64
3598 +  spill R30 -&gt; [sp, #0]	# spill size = 64
359c +  spill R31 -&gt; [sp, #72]	# spill size = 64
35a0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal::get @ bci:11 (line 164) L[0]=sp + #0 L[1]=_ L[2]=sp + #72 L[3]=_ L[4]=_ STK[0]=sp + #72
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop off=13732/0x35a4}
35a4    #@ShouldNotReachHere

35b0    B490: #	out( N6590 ) &lt;- in( B466 )  Freq: 2.31163e-12
35b0 +  spill [sp, #8] -&gt; R8	# spill size = 64
35b4 +  li R11, #-187	# int, #@loadConI
35b8    spill R31 -&gt; [sp, #8]	# spill size = 64
35bc +  spill R30 -&gt; [sp, #72]	# spill size = 64
35c0 +  spill R28 -&gt; [sp, #52]	# spill size = 32
35c4 +  spill R7 -&gt; [sp, #88]	# spill size = 64
35c8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:21 (line 436) L[0]=sp + #8 L[1]=sp + #72 L[2]=sp + #52 L[3]=sp + #88 STK[0]=sp + #88
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #72 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #56 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #32
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [88]=Oop off=13772/0x35cc}
35cc    #@ShouldNotReachHere

35d8    B491: #	out( N6590 ) &lt;- in( B442 )  Freq: 1.42163e-12
35d8     -- 	// exception oop; no code emitted, #@CreateException
35d8 +  spill R10 -&gt; [sp, #24]	# spill size = 64
35dc +  li R11, #-75	# int, #@loadConI
35e0    spill [sp, #8] -&gt; R8	# spill size = 64
35e4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:84 (line 362) L[0]=sp + #16 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_ STK[0]=sp + #24
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=13800/0x35e8}
35e8    #@ShouldNotReachHere

35f4    B492: #	out( N6590 ) &lt;- in( B443 )  Freq: 1.35411e-12
35f4     -- 	// exception oop; no code emitted, #@CreateException
35f4 +  spill R10 -&gt; [sp, #0]	# spill size = 64
35f8 +  li R11, #-75	# int, #@loadConI
35fc    spill [sp, #8] -&gt; R8	# spill size = 64
3600    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:155 (line 304) L[0]=_ L[1]=_ L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=13828/0x3604}
3604    #@ShouldNotReachHere

3610    B493: #	out( N6590 ) &lt;- in( B443 )  Freq: 1.35411e-12
3610     -- 	// exception oop; no code emitted, #@CreateException
3610 +  spill R10 -&gt; [sp, #0]	# spill size = 64
3614 +  li R11, #-75	# int, #@loadConI
3618    spill [sp, #8] -&gt; R8	# spill size = 64
361c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:139 (line 302) L[0]=_ L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop off=13856/0x3620}
3620    #@ShouldNotReachHere

362c    B494: #	out( B496 ) &lt;- in( B449 )  Freq: 4.85033e-15
362c     -- 	// exception oop; no code emitted, #@CreateException
362c +  spill R10 -&gt; R11	# spill size = 64
3630 +  j  B496	#@branch

3634    B495: #	out( B496 ) &lt;- in( B476 )  Freq: 4.85011e-11
3634     -- 	// exception oop; no code emitted, #@CreateException
3634 +  spill R10 -&gt; R11	# spill size = 64

3638    B496: #	out( B513 B514 ) &lt;- in( B494 B495 )  Freq: 4.85059e-11
3638    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [40]=Oop off=13884/0x363c}

363c    B497: #	out( N6590 ) &lt;- in( B449 )  Freq: 4.85033e-15
363c     -- 	// exception oop; no code emitted, #@CreateException
363c +  spill R10 -&gt; [sp, #0]	# spill size = 64
3640 +  li R11, #-75	# int, #@loadConI
3644    spill [sp, #8] -&gt; R8	# spill size = 64
3648    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:24 (line 54) L[0]=#ScObj0 L[1]=_ STK[0]=sp + #0
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #48, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop off=13900/0x364c}
364c    #@ShouldNotReachHere

3658    B498: #	out( N6590 ) &lt;- in( B453 )  Freq: 5.25791e-16
3658     -- 	// exception oop; no code emitted, #@CreateException
3658 +  spill R10 -&gt; [sp, #0]	# spill size = 64
365c +  li R11, #-75	# int, #@loadConI
3660    spill [sp, #8] -&gt; R8	# spill size = 64
3664    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:59 (line 352) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=_ L[5]=_ L[6]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=13928/0x3668}
3668    #@ShouldNotReachHere

3674    B499: #	out( B509 ) &lt;- in( B503 )  Freq: 5.2578e-16
3674     -- 	// exception oop; no code emitted, #@CreateException
3674 +  spill R10 -&gt; R9	# spill size = 64
3678 +  j  B509	#@branch

367c    B500: #	out( B509 ) &lt;- in( B502 )  Freq: 5.2579e-16
367c     -- 	// exception oop; no code emitted, #@CreateException
367c +  spill R10 -&gt; R9	# spill size = 64
3680 +  j  B509	#@branch

3684    B501: #	out( B512 B502 ) &lt;- in( B403 )  Freq: 5.25791e-11
3684     -- 	// exception oop; no code emitted, #@CreateException
3684 +  spill R8 -&gt; R7	# spill size = 64
3688 +  spill R10 -&gt; [sp, #32]	# spill size = 64
368c +  beq   R7, zr, B512	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

3690    B502: #	out( B500 B503 ) &lt;- in( B501 )  Freq: 5.2579e-11
3690 +  spill R7 -&gt; R11	# spill size = 64
3694    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixDirectoryStream::readLock
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:99 (line 171) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #32
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop off=13976/0x3698}

3698    B503: #	out( B499 B504 ) &lt;- in( B502 )  Freq: 5.2578e-11
        # Block is sole successor of call
3698 +  spill R10 -&gt; R11	# spill size = 64
369c    CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.concurrent.locks.Lock::unlock
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:102 (line 171) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #32
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop off=14008/0x36b8}

36b8    B504: #	out( B509 ) &lt;- in( B503 )  Freq: 5.25769e-11
        # Block is sole successor of call
36b8 +  spill [sp, #32] -&gt; R9	# spill size = 64
36bc +  j  B509	#@branch

36c0    B505: #	out( B507 ) &lt;- in( B270 )  Freq: 4.90542e-10
36c0     -- 	// exception oop; no code emitted, #@CreateException
36c0 +  j  B507	#@branch

36c4    B506: #	out( B507 ) &lt;- in( B272 )  Freq: 4.85622e-10
36c4     -- 	// exception oop; no code emitted, #@CreateException

36c4    B507: #	out( B509 ) &lt;- in( B505 B506 )  Freq: 9.76164e-10
36c4 +  spill R10 -&gt; R9	# spill size = 64
36c8 +  j  B509	#@branch

36cc    B508: #	out( B509 ) &lt;- in( B43 )  Freq: 5.25776e-06
36cc     -- 	// exception oop; no code emitted, #@CreateException
36cc +  spill R10 -&gt; R9	# spill size = 64

36d0    B509: #	out( B511 B510 ) &lt;- in( B508 B507 B500 B499 B504 )  Freq: 5.25879e-06
36d0 +  #@membar_release_lock (elided)
36d0    add R29, sp, #144	# box lock
36d4 +  spill [sp, #0] -&gt; R18	# spill size = 64
36d8 +  fastunlock R18,R29	! kills R7, R28, #@cmpFastUnlock
3750 +  far_bne RFLAGS, zr, B511	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

3758    B510: #	out( B522 B450 ) &lt;- in( B511 B509 )  Freq: 5.25879e-06
3758 +  spill R9 -&gt; R11	# spill size = 64
375c    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop off=14176/0x3760}

3760    B511: #	out( B510 ) &lt;- in( B509 )  Freq: 5.25879e-12
3760    add R11, sp, #144	# box lock
3764 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3764    spill R23 -&gt; R12	# spill size = 64
3768 +  spill [sp, #0] -&gt; R10	# spill size = 64
376c +  CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
379c +  j  B510	#@branch

37a0    B512: #	out( N6590 ) &lt;- in( B501 )  Freq: 5.32773e-17
37a0 +  li R11, #-10	# int, #@loadConI
37a4    spill [sp, #8] -&gt; R8	# spill size = 64
37a8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:99 (line 171) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #32 STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop off=14252/0x37ac}
37ac    #@ShouldNotReachHere

37b8    B513: #	out( B515 B536 B535 ) &lt;- in( B496 )  Freq: 4.85059e-16
37b8     -- 	// exception oop; no code emitted, #@CreateException
37b8 +  spill R10 -&gt; R11	# spill size = 64
37bc    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [40]=Oop off=14272/0x37c0}

37c0    B514: #	out( N6590 ) &lt;- in( B496 )  Freq: 4.85059e-16
37c0     -- 	// exception oop; no code emitted, #@CreateException
37c0 +  spill R10 -&gt; [sp, #0]	# spill size = 64
37c4 +  li R11, #-75	# int, #@loadConI
37c8    spill [sp, #8] -&gt; R8	# spill size = 64
37cc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::getAttributes @ bci:63 (line 221) L[0]=sp + #16 L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop off=14288/0x37d0}
37d0    #@ShouldNotReachHere

37dc    B515: #	out( B532 ) &lt;- in( B513 )  Freq: 4.85059e-21
37dc     -- 	// exception oop; no code emitted, #@CreateException
37dc +  j  B532	#@branch

37e0    B516: #	out( B532 ) &lt;- in( B453 )  Freq: 5.25791e-16
37e0     -- 	// exception oop; no code emitted, #@CreateException
37e0 +  j  B532	#@branch

37e4    B517: #	out( B532 ) &lt;- in( B443 )  Freq: 1.35411e-12
37e4     -- 	// exception oop; no code emitted, #@CreateException
37e4 +  j  B532	#@branch

37e8    B518: #	out( B532 ) &lt;- in( B442 )  Freq: 1.42163e-12
37e8     -- 	// exception oop; no code emitted, #@CreateException
37e8 +  j  B532	#@branch

37ec    B519: #	out( B532 ) &lt;- in( B319 )  Freq: 1.35422e-11
37ec     -- 	// exception oop; no code emitted, #@CreateException
37ec +  j  B532	#@branch

37f0    B520: #	out( B532 ) &lt;- in( B317 )  Freq: 1.3543e-11
37f0     -- 	// exception oop; no code emitted, #@CreateException
37f0 +  j  B532	#@branch

37f4    B521: #	out( B532 ) &lt;- in( B315 )  Freq: 1.42181e-11
37f4     -- 	// exception oop; no code emitted, #@CreateException
37f4 +  j  B532	#@branch

37f8    B522: #	out( B532 ) &lt;- in( B510 )  Freq: 5.25879e-11
37f8     -- 	// exception oop; no code emitted, #@CreateException
37f8 +  j  B532	#@branch

37fc    B523: #	out( B532 ) &lt;- in( B278 )  Freq: 4.71488e-10
37fc     -- 	// exception oop; no code emitted, #@CreateException
37fc +  j  B532	#@branch

3800    B524: #	out( B532 ) &lt;- in( B222 )  Freq: 1.354e-07
3800     -- 	// exception oop; no code emitted, #@CreateException
3800 +  j  B532	#@branch

3804    B525: #	out( B532 ) &lt;- in( B219 )  Freq: 1.35402e-07
3804     -- 	// exception oop; no code emitted, #@CreateException
3804 +  j  B532	#@branch

3808    B526: #	out( B532 ) &lt;- in( B212 )  Freq: 1.35405e-07
3808     -- 	// exception oop; no code emitted, #@CreateException
3808 +  j  B532	#@branch

380c    B527: #	out( B532 ) &lt;- in( B199 )  Freq: 1.35408e-07
380c     -- 	// exception oop; no code emitted, #@CreateException
380c +  j  B532	#@branch

3810    B528: #	out( B532 ) &lt;- in( B192 )  Freq: 1.42157e-07
3810     -- 	// exception oop; no code emitted, #@CreateException
3810 +  j  B532	#@branch

3814    B529: #	out( B532 ) &lt;- in( B189 )  Freq: 1.4216e-07
3814     -- 	// exception oop; no code emitted, #@CreateException
3814 +  j  B532	#@branch

3818    B530: #	out( B534 ) &lt;- in( B182 )  Freq: 1.46968e-07
3818     -- 	// exception oop; no code emitted, #@CreateException
3818 +  spill R10 -&gt; R11	# spill size = 64
381c +  j  B534	#@branch

3820    B531: #	out( B532 ) &lt;- in( B148 )  Freq: 4.71409e-06
3820     -- 	// exception oop; no code emitted, #@CreateException

3820    B532: #	out( B534 ) &lt;- in( B522 B516 B518 B529 B521 B528 B515 B517 B520 B527 B526 B525 B519 B524 B523 B531 )  Freq: 5.54059e-06
3820 +  spill R10 -&gt; R11	# spill size = 64
3824 +  j  B534	#@branch

3828    B533: #	out( B534 ) &lt;- in( B151 )  Freq: 5.13841e-06
3828     -- 	// exception oop; no code emitted, #@CreateException
3828 +  spill R10 -&gt; R11	# spill size = 64

382c    B534: #	out( N6590 ) &lt;- in( B532 B533 B530 )  Freq: 1.0826e-05
382c    # pop frame 176
	add  sp, sp, #176
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
3880 +  j rethrow_stub	#@RethrowException

3888    B535: #	out( N6590 ) &lt;- in( B513 )  Freq: 4.85059e-21
3888     -- 	// exception oop; no code emitted, #@CreateException
3888 +  spill R10 -&gt; [sp, #0]	# spill size = 64
388c +  li R11, #-75	# int, #@loadConI
3890    spill [sp, #8] -&gt; R8	# spill size = 64
3894    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:27 (line 280) L[0]=_ L[1]=_ L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=14488/0x3898}
3898    #@ShouldNotReachHere

38a4    B536: #	out( N6590 ) &lt;- in( B513 )  Freq: 4.85059e-21
38a4     -- 	// exception oop; no code emitted, #@CreateException
38a4 +  spill R10 -&gt; [sp, #0]	# spill size = 64
38a8 +  li R11, #-75	# int, #@loadConI
38ac    spill [sp, #8] -&gt; R8	# spill size = 64
38b0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:11 (line 278) L[0]=_ L[1]=sp + #40 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop off=14516/0x38b4}
38b4    #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='319'>
----------------------- MetaData before Compile_id = 319 ------------------------
{method}
 - this oop:          0x0000004096550570
 - method holder:     &apos;java/nio/file/FileTreeIterator&apos;
 - constants:         0x000000409654fe20 constant pool [128] {0x000000409654fe20} for &apos;java/nio/file/FileTreeIterator&apos; cache=0x0000004096550a20
 - access:            0xc1000002  private 
 - name:              &apos;fetchNextIfNeeded&apos;
 - signature:         &apos;()V&apos;
 - max stack:         4
 - max locals:        3
 - size of params:    1
 - method size:       13
 - highest level:     4
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x00000040139d1704
 - code size:         65
 - code start:        0x00000040965504f8
 - code end (excl):   0x0000004096550539
 - method data:       0x0000004096484b08
 - checked ex length: 0
 - linenumber start:  0x0000004096550539
 - localvar length:   3
 - localvar start:    0x000000409655054a

------------------------ OptoAssembly for Compile_id = 319 -----------------------
#
#  void ( java/nio/file/FileTreeIterator:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/nio/file/FileTreeIterator:NotNull *
# -- Old sp -- Framesize: 176 --
#r263 sp+172: in_preserve
#r262 sp+168: return address
#r261 sp+164: in_preserve
#r260 sp+160: saved fp register
#r259 sp+156: Fixed slot 3
#r258 sp+152: Fixed slot 2
#r257 sp+148: Fixed slot 1
#r256 sp+144: Fixed slot 0
#r299 sp+140: spill
#r298 sp+136: spill
#r297 sp+132: spill
#r296 sp+128: spill
#r295 sp+124: spill
#r294 sp+120: spill
#r293 sp+116: spill
#r292 sp+112: spill
#r291 sp+108: spill
#r290 sp+104: spill
#r289 sp+100: spill
#r288 sp+96: spill
#r287 sp+92: spill
#r286 sp+88: spill
#r285 sp+84: spill
#r284 sp+80: spill
#r283 sp+76: spill
#r282 sp+72: spill
#r281 sp+68: spill
#r280 sp+64: spill
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
0000    N6569: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0000    # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

0020    B1: #	out( B161 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0020    # stack bang size=176
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #176
	
003c    lwu  R7, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.next
0040    spill R11 -&gt; R9	# spill size = 64
0044 +  bne   R7, zr, B161	#@cmpP_narrowOop_imm0_branch  P=0.500454 C=5503.000000

0048    B2: #	out( B410 B3 ) &lt;- in( B1 )  Freq: 0.499546
0048 +  lwu  R28, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.walker
004c +  decode_heap_oop  R18, R28	#@decodeHeapOop
0050    lwu  R7, [R18, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker.stack
0054    NullCheck R18

0054    B3: #	out( B411 B4 ) &lt;- in( B2 )  Freq: 0.499545
0054 +  decode_heap_oop  R7, R7	#@decodeHeapOop
0058    lwu  R29, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/ArrayDeque.elements
005c    NullCheck R7

005c    B4: #	out( B412 B5 ) &lt;- in( B3 )  Freq: 0.499545
005c +  lw  R30, [R7, #12]	# int, #@loadI ! Field: java/util/ArrayDeque.head
0060 +  addw  R7, R30, zr	#@convI2L_reg_reg
0064 +  decode_heap_oop  R8, R29	#@decodeHeapOop
0068 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
006c    lwu  R28, [R8, #12]	# range, #@loadRange
0070    NullCheck R8

0070    B5: #	out( B325 B6 ) &lt;- in( B4 )  Freq: 0.499544
0070 +  add R7, R8, R7	# ptr, #@addP_reg_reg
0074 +  far_bgeu R30, R28, B325	#@far_cmpU_branch  P=0.000001 C=-1.000000

007c    B6: #	out( B161 B7 ) &lt;- in( B5 )  Freq: 0.499544
007c +  lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN
0080 +  decode_heap_oop  R24, R28	#@decodeHeapOop
0084 +  beq   R24, zr, B161	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

0088    B7: #	out( B399 B8 ) &lt;- in( B6 )  Freq: 0.499044
0088 +  lwu  R7, [R24, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
008c +  mv  R29, narrowklass: precise klass java/nio/file/FileTreeWalker$DirectoryNode: 0x00000040d09f6eb0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
009c +  far_bne  R7, R29, B399	#@far_cmpN_branch  P=0.000000 C=-1.000000

00a4    B8: #	out( B356 B9 ) &lt;- in( B7 )  Freq: 0.499044
00a4 +  # checkcastPP of R24, #@checkCastPP
00a4    lwu  R7, [R24, #28]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.iterator
00a8 +  lbu  R8, [R24, #12]	# byte, #@loadUB ! Field: java/nio/file/FileTreeWalker$DirectoryNode.skipped
00ac +  decode_heap_oop  R19, R7	#@decodeHeapOop
00b0 +  far_bne  R8, zr, B356	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2842.000000

00b8    B9: #	out( B413 B10 ) &lt;- in( B8 )  Freq: 0.499044
00b8    lwu  R28, [R19, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
00bc    NullCheck R19

00bc    B10: #	out( B326 B11 ) &lt;- in( B9 )  Freq: 0.499043
00bc +  mv  R7, narrowklass: precise klass sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator: 0x00000040d09ebac0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
00cc +  far_bne  R28, R7, B326	#@far_cmpN_branch  P=0.000001 C=-1.000000

00d4    B11: #	out( B327 B12 ) &lt;- in( B10 )  Freq: 0.499043
00d4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
00d4    ld  R7, [R23, #712]	# ptr, #@loadP
00d8 +  ld  R20, [R7]	# ptr, #@loadP
00dc +  add R29, sp, #144	# box lock
00e0 +  # checkcastPP of R19, #@checkCastPP
00e0    fastlock R19,R29	! kills R7,R28, #@cmpFastLock
0174 +  far_bne RFLAGS, zr, B327	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

017c    B12: #	out( B357 B13 ) &lt;- in( B327 B11 )  Freq: 0.499043
017c +  #@membar_acquire_lock (elided)
017c +  lwu  R7, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
0180 +  lwu  R29, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
0184 +  decode_heap_oop  R8, R7	#@decodeHeapOop
0188 +  lbu  R28, [R19, #12]	# byte, #@loadUB ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.atEof
018c +  decode_heap_oop  R7, R29	#@decodeHeapOop
0190 +  far_bne   R8, zr, B357	#@far_cmpP_imm0_branch  P=0.000000 C=2846.000000

0198    B13: #	out( B358 B14 ) &lt;- in( B12 )  Freq: 0.499043
0198 +  far_bne  R28, zr, B358	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2846.000000

01a0    B14: #	out( B414 B15 ) &lt;- in( B13 )  Freq: 0.499042
01a0    lwu  R7, [R7, #32]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream.streamLock
01a4    NullCheck R7

01a4    B15: #	out( B415 B16 ) &lt;- in( B14 )  Freq: 0.499042
01a4 +  decode_heap_oop  R7, R7	#@decodeHeapOop
01a8    lwu  R28, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock.readerLock
01ac    NullCheck R7

01ac    B16: #	out( B416 B17 ) &lt;- in( B15 )  Freq: 0.499041
01ac +  decode_heap_oop  R8, R28	#@decodeHeapOop
01b0    # checkcastPP of R8, #@checkCastPP
01b0    lwu  R7, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
01b4    NullCheck R8

01b4    B17: #	out( B328 B18 ) &lt;- in( B16 )  Freq: 0.499041
01b4 +  mv  R29, narrowklass: precise klass java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock: 0x00000040d08c1680:Constant:exact *	# compressed klass ptr, #@loadConNKlass
01c4 +  far_bne  R7, R29, B328	#@far_cmpN_branch  P=0.000001 C=-1.000000

01cc    B18: #	out( B417 B19 ) &lt;- in( B17 )  Freq: 0.49904
01cc +  # checkcastPP of R8, #@checkCastPP
01cc    lwu  R7, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock.sync
01d0 +  decode_heap_oop  R21, R7	#@decodeHeapOop
01d4    lw  R29, [R21, #16]	# int, #@loadI ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.state
01d8    NullCheck R21

01d8    B19: #	out( B370 B20 ) &lt;- in( B18 )  Freq: 0.49904
01d8 +  #@membar_acquire
	fence ir iorw
01dc +  li R7, #65535	# int, #@loadConI
01e4 +  andr  R8, R29, R7	#@andI_reg_reg
01e8 +  far_bne  R8, zr, B370	#@far_cmpI_reg_imm0_branch  P=0.000000 C=3040.000000

01f0    B20: #	out( B329 B21 ) &lt;- in( B19 )  Freq: 0.49904
01f0 +  lwu  R28, [R21, #20]	# loadN, compressed ptr, #@loadN ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.head
01f4 +  #@membar_acquire
	fence ir iorw
01f8 +  decode_heap_oop  R8, R28	#@decodeHeapOop
01fc +  srliw  R31, R29, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
0200 +  far_bne   R8, zr, B329	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0208    B21: #	out( B371 B22 ) &lt;- in( B20 )  Freq: 0.499039
0208 +  far_bge  R31, R7, B371	#@far_cmpI_branch  P=0.000000 C=3040.000000

0210    B22: #	out( B372 B23 ) &lt;- in( B21 )  Freq: 0.499039
0210 +  #@membar_release
	fence iorw ow
0214 +  li R30, #65536	# int, #@loadConI
0218 +  addw  R28, R29, R30	#@addI_reg_reg
021c +  addi  R7, R21, #16	# ptr, #@addP_reg_imm
0220    
0220 +  cmpxchg_acq [R7], R29, R28	# (int) if [R7] == R29 then [R7] &lt;-- R28
	mv R8, R8 == R29	# R8 &lt;-- (R8 == R29 ? 1 : 0), #@compareAndSwapIAcq
023c    
023c +  #@membar_acquire
	fence ir iorw
0240 +  far_beq  R8, zr, B372	#@far_cmpI_reg_imm0_branch  P=0.000000 C=3040.000000

0248    B23: #	out( B359 B24 ) &lt;- in( B22 )  Freq: 0.499039
0248 +  far_bne  R31, zr, B359	#@far_cmpI_reg_imm0_branch  P=0.000000 C=3040.000000

0250    B24: #	out( B228 B25 ) &lt;- in( B23 )  Freq: 0.499038
0250 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0250    lb  R28, [R23, #56]	# byte, #@loadB
0254 +  far_bne  R28, zr, B228	#@far_cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

025c    B25: #	out( B27 B26 ) &lt;- in( B360 B230 B228 B24 )  Freq: 0.499038
025c +  mv  R28, R21	# ptr -&gt; long, #@castP2X
0260 +  mv  R7, R20	# ptr -&gt; long, #@castP2X
0264 +  xorr  R29, R7, R28	#@xorL_reg_reg
0268 +  encode_heap_oop  R7, R20	#@encodeHeapOop
026c +  srli  R29, R29, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0270 +  sw  R7, [R21, #40]	# compressed ptr, #@storeN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
0274 +  beq  R29, zr, B27	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0278    B26: #	out( B237 B27 ) &lt;- in( B25 )  Freq: 0.498539
0278 +  srli  R28, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
027c +  mv  R29, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
0288 +  add R10, R29, R28	# ptr, #@addP_reg_reg
028c +  lb  R28, [R10]	# byte, #@loadB
0290 +  li R29, #4	# int, #@loadConI
0294 +  far_bne  R28, R29, B237	#@far_cmpI_branch  P=0.001000 C=-1.000000

029c    B27: #	out( B28 ) &lt;- in( B239 B240 B237 B26 B25 )  Freq: 0.499038
029c +  li R29, #1	# int, #@loadConI
02a0 +  sw  R29, [R21, #28]	# int, #@storeI ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReaderHoldCount

02a4    B28: #	out( B404 B29 ) &lt;- in( B27 B180 ) Loop( B28-B180 inner ) Freq: 0.526544
02a4 +  lwu  R29, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
02a8 +  decode_heap_oop  R28, R29	#@decodeHeapOop
02ac    lbu  R28, [R28, #12]	# byte, #@loadUB ! Field: volatile sun/nio/fs/UnixDirectoryStream.isClosed
02b0    NullCheck R28

02b0    B29: #	out( B350 B30 ) &lt;- in( B28 )  Freq: 0.526543
02b0 +  #@membar_acquire
	fence ir iorw
02b4 +  lwu  R29, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
02b8 +  decode_heap_oop  R29, R29	#@decodeHeapOop
02bc +  far_bne  R28, zr, B350	#@far_cmpI_reg_imm0_branch  P=0.000000 C=3040.000000

02c4    B30: #	out( B405 B31 ) &lt;- in( B29 )  Freq: 0.526543
02c4    ld  R11, [R29, #16]	# int, #@loadL ! Field: sun/nio/fs/UnixDirectoryStream.dp
02c8    NullCheck R29

02c8    B31: #	out( B403 B32 ) &lt;- in( B30 )  Freq: 0.526543
02c8 +  spill R7 -&gt; [sp, #24]	# spill size = 32
02cc +  spill R20 -&gt; [sp, #16]	# spill size = 64
02d0 +  spill R19 -&gt; [sp, #0]	# spill size = 64
02d4 +  spill R24 -&gt; [sp, #56]	# spill size = 64
02d8 +  spill R18 -&gt; [sp, #48]	# spill size = 64
02dc +  spill R9 -&gt; [sp, #8]	# spill size = 64
02e0    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect sun.nio.fs.UnixNativeDispatcher::readdir
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:52 (line 165) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=NarrowOop [48]=Oop [56]=Oop off=740/0x2e4}

02e4    B32: #	out( B406 B33 ) &lt;- in( B31 )  Freq: 0.526532
        # Block is sole successor of call
02e4 +  spill [sp, #0] -&gt; R29	# spill size = 64
02e8 +  lwu  R28, [R29, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
02ec +  spill R10 -&gt; [sp, #64]	# spill size = 64
02f0 +  decode_heap_oop  R7, R28	#@decodeHeapOop
02f4    lwu  R7, [R7, #32]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream.streamLock
02f8    NullCheck R7

02f8    B33: #	out( B407 B34 ) &lt;- in( B32 )  Freq: 0.526531
02f8 +  decode_heap_oop  R7, R7	#@decodeHeapOop
02fc    lwu  R28, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock.readerLock
0300    NullCheck R7

0300    B34: #	out( B408 B35 ) &lt;- in( B33 )  Freq: 0.526531
0300 +  decode_heap_oop  R8, R28	#@decodeHeapOop
0304    # checkcastPP of R8, #@checkCastPP
0304    lwu  R7, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0308    NullCheck R8

0308    B35: #	out( B321 B36 ) &lt;- in( B34 )  Freq: 0.52653
0308 +  mv  R28, narrowklass: precise klass java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock: 0x00000040d08c1680:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0318 +  far_bne  R7, R28, B321	#@far_cmpN_branch  P=0.000001 C=-1.000000

0320    B36: #	out( B409 B37 ) &lt;- in( B35 )  Freq: 0.52653
0320 +  # checkcastPP of R8, #@checkCastPP
0320    lwu  R28, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock.sync
0324 +  decode_heap_oop  R12, R28	#@decodeHeapOop
0328    lwu  R7, [R12, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
032c    NullCheck R12

032c    B37: #	out( B351 B38 ) &lt;- in( B36 )  Freq: 0.526529
032c +  decode_heap_oop  R8, R7	#@decodeHeapOop
0330 +  lw  R10, [R12, #28]	# int, #@loadI ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReaderHoldCount
0334    spill [sp, #16] -&gt; R30	# spill size = 64
0338 +  far_bne  R8, R30, B351	#@far_cmpP_branch  P=0.000000 C=3040.000000

0340    B38: #	out( B352 B39 ) &lt;- in( B37 )  Freq: 0.526529
0340 +  li R28, #1	# int, #@loadConI
0344 +  far_bne  R10, R28, B352	#@far_cmpI_branch  P=0.000000 C=3040.000000

034c    B39: #	out( B225 B40 ) &lt;- in( B38 )  Freq: 0.526529
034c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
034c    lb  R28, [R23, #56]	# byte, #@loadB
0350 +  far_bne  R28, zr, B225	#@far_cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0358    B40: #	out( B355 B41 ) &lt;- in( B354 B227 B225 B39 )  Freq: 0.526529
0358 +  lw  R7, [R12, #16]	# int, #@loadI ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.state
035c +  sw  rheapbase, [R12, #40]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
0360 +  #@membar_acquire
	fence ir iorw
0364 +  #@membar_release
	fence iorw ow
0364 +  li R31, #-65536	# int, #@loadConI
0368 +  addw  R10, R7, R31	#@addI_reg_reg
036c +  addi  R28, R12, #16	# ptr, #@addP_reg_imm
0370    
0370 +  cmpxchg_acq [R28], R7, R10	# (int) if [R28] == R7 then [R28] &lt;-- R10
	mv R8, R8 == R7	# R8 &lt;-- (R8 == R7 ? 1 : 0), #@compareAndSwapIAcq
038c    
038c +  #@membar_acquire
	fence ir iorw
0390 +  far_beq  R8, zr, B355	#@far_cmpI_reg_imm0_branch  P=0.000000 C=3040.000000

0398    B41: #	out( B353 B42 ) &lt;- in( B40 )  Freq: 0.526529
0398 +  li R31, #65536	# int, #@loadConI
039c +  far_bne  R7, R31, B353	#@far_cmpI_branch  P=0.000000 C=3040.000000

03a4    B42: #	out( B322 B43 ) &lt;- in( B41 )  Freq: 0.526528
03a4 +  lwu  R28, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.head
03a8 +  #@membar_acquire
	fence ir iorw
03ac +  decode_heap_oop  R8, R28	#@decodeHeapOop
03b0 +  far_bne   R8, zr, B322	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

03b8    B43: #	out( B508 B44 ) &lt;- in( B42 )  Freq: 0.526528
03b8 +  spill R30 -&gt; [sp, #72]	# spill size = 64
03bc +  spill R29 -&gt; [sp, #0]	# spill size = 64
03c0 +  mv  R11, NULL	# NULL ptr, #@loadConP0
03c4    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.util.concurrent.locks.AbstractQueuedSynchronizer::signalNext
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:12 (line 1095) L[0]=_ L[1]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [24]=NarrowOop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=968/0x3c8}

03c8    B44: #	out( B194 B45 ) &lt;- in( B43 )  Freq: 0.526517
        # Block is sole successor of call
03c8 +  spill [sp, #64] -&gt; R20	# spill size = 64
03cc +  beq   R20, zr, B194	#@cmpP_imm0_branch  P=0.026973 C=3003.000000

03d0    B45: #	out( B324 B46 ) &lt;- in( B44 )  Freq: 0.512316
03d0 +  lwu  R22, [R20, #12]	# range, #@loadRange
03d4 +  addi  R25, R20, #16	# ptr, #@addP_reg_imm
03d8    spill [sp, #0] -&gt; R19	# spill size = 64
03dc +  lwu  R28, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
03e0 +  far_bleu  R22, zr, B324	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

03e8    B46: #	out( B162 B47 ) &lt;- in( B45 )  Freq: 0.512315
03e8 +  lb  R7, [R25]	# byte, #@loadB
03ec +  decode_heap_oop  R10, R28	#@decodeHeapOop
03f0 +  li R28, #46	# int, #@loadConI
03f4 +  beq  R7, R28, B162	#@cmpI_branch  P=0.053668 C=2944.000000

03f8    B47: #	out( B418 B48 ) &lt;- in( B46 )  Freq: 0.48482
03f8    lwu  R29, [R10, #24]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream.dir
03fc    NullCheck R10

03fc    B48: #	out( B419 B49 ) &lt;- in( B47 )  Freq: 0.484819
03fc +  decode_heap_oop  R21, R29	#@decodeHeapOop
0400    lwu  R28, [R21, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
0404    NullCheck R21

0404    B49: #	out( B374 B50 ) &lt;- in( B48 )  Freq: 0.484819
0404 +  li R30, #47	# int, #@loadConI
0408 +  decode_heap_oop  R28, R28	#@decodeHeapOop
040c +  far_beq  R7, R30, B374	#@far_cmpI_branch  P=0.000000 C=2756.000000

0414    B50: #	out( B420 B51 ) &lt;- in( B49 )  Freq: 0.484819
0414    lwu  R18, [R28, #12]	# range, #@loadRange
0418    NullCheck R28

0418    B51: #	out( B364 B52 ) &lt;- in( B50 )  Freq: 0.484818
0418 +  addw  R29, R22, R18	#@addI_reg_reg
041c +  addiw  R9, R29, #1	#@addI_reg_imm
0420 +  li R7, #1048576	# int, #@loadConI
0424 +  far_bleu  R18, zr, B364	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000000 C=2756.000000

042c    B52: #	out( B375 B53 ) &lt;- in( B51 )  Freq: 0.484818
042c +  li R29, #1	# int, #@loadConI
0430 +  far_beq  R18, R29, B375	#@far_cmpI_branch  P=0.000000 C=2756.000000

0438    B53: #	out( B331 B54 ) &lt;- in( B52 )  Freq: 0.484818
0438 +  addw  R30, R22, zr	#@convI2L_reg_reg
043c +  addw  R26, R18, zr	#@convI2L_reg_reg
0440 +  far_bgtu R9, R7, B331	#@far_cmpU_branch  P=0.000001 C=-1.000000

0448    B54: #	out( B55 ) &lt;- in( B53 )  Freq: 0.484817
0448 +  add  R29, R26, R30	#@addL_reg_reg
044c +  addi  R29, R29, #1	#@addL_reg_imm

0450    B55: #	out( B336 B56 ) &lt;- in( B54 B331 )  Freq: 0.484818
0450 +  addi  R8, R29, #23	#@addL_reg_imm
0454 +  far_bltu R9, R18, B336	#@far_cmpU_branch  P=0.000001 C=-1.000000

045c    B56: #	out( B270 B57 ) &lt;- in( B55 )  Freq: 0.484817
045c +  andi  R29, R8, #-8	#@andL_reg_imm
0460    spill R29 -&gt; [sp, #104]	# spill size = 64
0464 +  far_bgtu R9, R7, B270	#@far_cmpU_branch  P=0.000001 C=-1.000000

046c    B57: #	out( B270 B58 ) &lt;- in( B56 )  Freq: 0.484817
046c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
046c    ld  R24, [R23, #288]	# ptr, #@loadP
0470 +  add R7, R24, R29	# ptr, #@addP_reg_reg
0474 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0474    ld  R29, [R23, #304]	# ptr, #@loadP
0478 +  far_bgeu  R7, R29, B270	#@far_cmpP_branch  P=0.000100 C=-1.000000

0480    B58: #	out( B59 ) &lt;- in( B57 )  Freq: 0.484768
0480 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0480    sd  R7, [R23, #288]	# ptr, #@storeP
0484 +  li R7, #1	# long, #@loadConL
0488 +  sd  R7, [R24]	# long, #@storeL
048c +  mv  R7, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
049c +  sw  R7, [R24, #8]	# compressed klass ptr, #@storeNKlass
04a0 +  sw  R9, [R24, #12]	# int, #@storeI

04a4    B59: #	out( B337 B60 ) &lt;- in( B271 B58 )  Freq: 0.484817
04a4    
04a4 +  srli  R7, R8, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
04a8 +  # checkcastPP of R24, #@checkCastPP
04a8    addi  R11, R24, #16	# ptr, #@addP_reg_imm
04ac +  far_bleu  R18, zr, B337	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

04b4    B60: #	out( B246 B61 ) &lt;- in( B59 )  Freq: 0.484817
04b4 +  addi  R10, R28, #16	# ptr, #@addP_reg_imm
04b8 +  far_blt  R18, R9, B246	#@far_cmpI_branch  P=0.001000 C=-1.000000

04c0    B61: #	out( B62 ) &lt;- in( B60 )  Freq: 0.484332
04c0 +  spill [sp, #104] -&gt; R7	# spill size = 64
04c4 +  spill R24 -&gt; R8	# spill size = 64
04c8 +  addi  R7, R7, #-16	#@addL_reg_imm
04cc    spill R30 -&gt; R24	# spill size = 64
04d0    
04d0    
04d0 +  srli  R12, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
04d4    CALL, runtime leaf nofp 0x000000401396d840	#@CallLeafNoFPDirect jlong_disjoint_arraycopy
        No JVM State Info
        # 
04d8 +  spill R24 -&gt; R30	# spill size = 64
04dc +  spill R8 -&gt; R24	# spill size = 64

04e0    B62: #	out( B332 B63 ) &lt;- in( B246 B61 B337 )  Freq: 0.484817
04e0 +  MEMBAR-store-store	#@membar_storestore
04e4 +  add R7, R24, R26	# ptr, #@addP_reg_reg
04e8 +  addiw  R8, R18, #1	#@addI_reg_imm
04ec +  far_bgeu R18, R9, B332	#@far_cmpU_branch  P=0.000001 C=-1.000000

04f4    B63: #	out( B338 B64 ) &lt;- in( B62 )  Freq: 0.484817
04f4 +  li R28, #47	# int, #@loadConI
04f8 +  sb  R28, [R7, #16]	# byte, #@storeB
04fc +  far_blt  R8, zr, B338	#@far_cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0504    B64: #	out( B66 B65 ) &lt;- in( B63 )  Freq: 0.484816
0504 +  bleu  R22, zr, B66	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

0508    B65: #	out( B66 ) &lt;- in( B64 )  Freq: 0.484816
0508 +  spill R30 -&gt; R12	# spill size = 64
050c +  addi  R11, R7, #17	# ptr, #@addP_reg_imm
0510    spill R25 -&gt; R10	# spill size = 64
0514 +  CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

0518    B66: #	out( B272 B67 ) &lt;- in( B65 B64 )  Freq: 0.484816
0518    
0518 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0518    ld  R18, [R23, #288]	# ptr, #@loadP
051c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
051c    ld  R7, [R23, #304]	# ptr, #@loadP
0520 +  addi  R28, R18, #32	# ptr, #@addP_reg_imm
0524 +  far_bgeu  R28, R7, B272	#@far_cmpP_branch  P=0.000100 C=-1.000000

052c    B67: #	out( B68 ) &lt;- in( B66 )  Freq: 0.484768
052c +  li R7, #1	# long, #@loadConL
0530 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0530    sd  R28, [R23, #288]	# ptr, #@storeP
0534 +  sd  R7, [R18]	# long, #@storeL
0538 +  mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d09ebb90:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0548 +  sw  R7, [R18, #8]	# compressed klass ptr, #@storeNKlass
054c +  sw  zr, [R18, #12]	# int, #@storeimmI0
0550 +  sw  zr, [R18, #16]	# int, #@storeimmI0
0554 +  sd  zr, [R18, #24]	# long, #@storeimmL0

0558    B68: #	out( B421 B69 ) &lt;- in( B273 B67 )  Freq: 0.484816
0558 +  encode_heap_oop  R28, R24	#@encodeHeapOop
055c +  sw  R28, [R18, #20]	# compressed ptr, #@storeN
0560    
0560 +  lwu  R7, [R21, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
0564 +  # checkcastPP of R18, #@checkCastPP
0564    sw  R7, [R18, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixPath.fs
0568 +  #@membar_release
	fence iorw ow
056c +  lwu  R28, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
0570 +  decode_heap_oop  R7, R28	#@decodeHeapOop
0574    lwu  R7, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream.filter
0578    NullCheck R7

0578    B69: #	out( B435 B70 ) &lt;- in( B68 )  Freq: 0.484816
0578 +  decode_heap_oop  R8, R7	#@decodeHeapOop
057c    lwu  R28, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0580    NullCheck R8

0580    B70: #	out( B339 B71 ) &lt;- in( B69 )  Freq: 0.484815
0580 +  mv  R7, narrowklass: precise klass java/nio/file/Files$AcceptAllFilter: 0x00000040d08c1750:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0590 +  far_bne  R28, R7, B339	#@far_cmpN_branch  P=0.000001 C=-1.000000

0598    B71: #	out( B72 ) &lt;- in( B70 )  Freq: 0.484815
0598 +  # checkcastPP of R18, #@checkCastPP

0598    B72: #	out( B231 B73 ) &lt;- in( B194 B71 )  Freq: 0.499017
0598 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0598    lb  R7, [R23, #56]	# byte, #@loadB
059c +  bne  R7, zr, B231	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

05a0    B73: #	out( B76 B74 ) &lt;- in( B361 B233 B231 B72 )  Freq: 0.499017
05a0 +  mv  R28, R19	# ptr -&gt; long, #@castP2X
05a4 +  mv  R7, R18	# ptr -&gt; long, #@castP2X
05a8 +  xorr  R7, R7, R28	#@xorL_reg_reg
05ac +  encode_heap_oop  R9, R18	#@encodeHeapOop
05b0 +  srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
05b4 +  sw  R9, [R19, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
05b8 +  beq  R7, zr, B76	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

05bc    B74: #	out( B76 B75 ) &lt;- in( B73 )  Freq: 0.498518
05bc +  beq   R18, zr, B76	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

05c0    B75: #	out( B241 B76 ) &lt;- in( B74 )  Freq: 0.498019
05c0 +  srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
05c4 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
05d0 +  add R10, R28, R7	# ptr, #@addP_reg_reg
05d4 +  lb  R28, [R10]	# byte, #@loadB
05d8 +  li R7, #4	# int, #@loadConI
05dc +  bne  R28, R7, B241	#@cmpI_branch  P=0.001000 C=-1.000000

05e0    B76: #	out( B330 B77 ) &lt;- in( B245 B75 B74 B73 )  Freq: 0.499017
05e0 +  #@membar_release_lock (elided)
05e0    add R29, sp, #144	# box lock
05e4 +  fastunlock R19,R29	! kills R7, R28, #@cmpFastUnlock
065c +  far_bne RFLAGS, zr, B330	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

0664    B77: #	out( B185 B78 ) &lt;- in( B330 B76 )  Freq: 0.499017
0664 +  beq   R9, zr, B185	#@cmpP_narrowOop_imm0_branch  P=0.029546 C=2843.000000

0668    B78: #	out( B340 B79 ) &lt;- in( B77 )  Freq: 0.484273
0668    add R29, sp, #144	# box lock
066c +  fastlock R19,R29	! kills R7,R28, #@cmpFastLock
0700 +  far_bne RFLAGS, zr, B340	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

0708    B79: #	out( B436 B80 ) &lt;- in( B340 B78 )  Freq: 0.484273
0708 +  #@membar_acquire_lock (elided)
0708 +  lwu  R28, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
070c +  decode_heap_oop  R8, R28	#@decodeHeapOop
0710    lwu  R18, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0714    NullCheck R8

0714    B80: #	out( B247 B81 ) &lt;- in( B79 )  Freq: 0.484272
0714 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0714    lb  R7, [R23, #56]	# byte, #@loadB
0718 +  bne  R7, zr, B247	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

071c    B81: #	out( B341 B82 ) &lt;- in( B365 B249 B247 B80 )  Freq: 0.484272
071c +  sw  rheapbase, [R19, #16]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
0720 +  #@membar_release_lock (elided)
0720    add R29, sp, #144	# box lock
0724 +  fastunlock R19,R29	! kills R7, R28, #@cmpFastUnlock
079c +  far_bne RFLAGS, zr, B341	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

07a4    B82: #	out( B400 B83 ) &lt;- in( B341 B81 )  Freq: 0.484272
07a4 +  mv  R14, precise klass sun/nio/fs/UnixPath: 0x00000040d09ebb90:Constant:exact *	# ptr, #@loadConP
07bc +  mv  R29, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d09ebb90:Constant:exact *	# compressed klass ptr, #@loadConNKlass
07cc +  ld  R28, [R14, #40]	# class, #@loadKlass
07d0 +  mv  R10, precise klass sun/nio/fs/BasicFileAttributesHolder: 0x00000040d81fd770:Constant:exact *	# ptr, #@loadConP
07e8 +  far_bne  R18, R29, B400	#@far_cmpN_branch  P=0.000000 C=-1.000000

07f0    B83: #	out( B333 B84 ) &lt;- in( B82 )  Freq: 0.484272
07f0 +  spill R8 -&gt; R7	# spill size = 64
07f4 +  # checkcastPP of R7, #@checkCastPP
07f4    far_beq  R28, R10, B333	#@far_cmpP_branch  P=0.000001 C=-1.000000

07fc    B84: #	out( B334 B85 ) &lt;- in( B83 )  Freq: 0.484272
07fc +  partialSubtypeCheck R15, R14, R10 == 0	#@partialSubtypeCheckVsZero
0858 +  lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
085c +  spill [sp, #48] -&gt; R29	# spill size = 64
0860 +  lwu  R31, [R29, #20]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker.linkOptions
0864 +  decode_heap_oop  R28, R28	#@decodeHeapOop
0868 +  far_beq RFLAGS, zr, B334	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

0870    B85: #	out( B422 B86 ) &lt;- in( B84 )  Freq: 0.484271
0870    lwu  R30, [R28, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileSystem.provider
0874    NullCheck R28

0874    B86: #	out( B335 B87 ) &lt;- in( B85 )  Freq: 0.484271
0874 +  decode_heap_oop  R14, R31	#@decodeHeapOop
0878 +  far_beq   R30, zr, B335	#@far_cmpP_narrowOop_imm0_branch  P=0.000001 C=-1.000000

0880    B87: #	out( B423 B88 ) &lt;- in( B86 )  Freq: 0.48427
0880    lwu  R28, [R14, #12]	# range, #@loadRange
0884    NullCheck R14

0884    B88: #	out( B96 B89 ) &lt;- in( B87 )  Freq: 0.48427
0884 +  bleu  R28, zr, B96	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.500091 C=5511.000000

0888    B89: #	out( B363 B90 ) &lt;- in( B88 )  Freq: 0.242091
0888 +  addiw  R30, R28, #-1	#@addI_reg_imm
088c +  li R12, #1000	# int, #@loadConI
0890 +  far_bgeu R30, R28, B363	#@far_cmpU_branch  P=0.000001 C=-1.000000

0898    B90: #	out( B91 ) &lt;- in( B89 )  Freq: 0.242091
0898 +  mv  R15, narrowoop: java/nio/file/LinkOption:exact *	# compressed ptr, #@loadConN
08a8 +  li R13, #0	# int, #@loadConI
08ac +  li R9, #0	# int, #@loadConI

08b0    B91: #	out( B92 ) &lt;- in( B90 B94 ) Loop( B91-B94 ) Freq: 0.484093
08b0 +  subw  R31, R28, R13	#@subI_reg_reg
08b4    CMove R31, (R28 lt R13), R31, R9	#@cmovI_cmpI
	
08bc +  CMove R31, (R31 gtu R12), R31, R12	#@cmovI_cmpU
	
08c4 +  addw  R30, R31, R13	#@addI_reg_reg

08c8    B92: #	out( B349 B93 ) &lt;- in( B91 B93 ) Loop( B92-B93 inner  strip mined) Freq: 0.96801
08c8 +  addw  R31, R13, zr	#@convI2L_reg_reg
08cc +  slli  R31, R31, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
08d0 +  add R31, R14, R31	# ptr, #@addP_reg_reg
08d4 +  lwu  R10, [R31, #16]	# loadN, compressed ptr, #@loadN
08d8 +  far_bne  R10, R15, B349	#@far_cmpN_branch  P=0.000000 C=2755.000000

08e0    B93: #	out( B92 B94 ) &lt;- in( B92 )  Freq: 0.96801
08e0 +  addiw  R13, R13, #1	#@addI_reg_imm
08e4 +  blt  R13, R30, B92	#@cmpI_loop  P=0.499909 C=2755.000000

08e8    B94: #	out( B91 B95 ) &lt;- in( B93 )  Freq: 0.484093
08e8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
08e8    ld  R16, [R23, #920]	# ptr, #@loadP
08ec +  lwu zr, [R16]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.Util::followLinks @ bci:61 (line 121) L[0]=_ L[1]=#0 L[2]=R14 L[3]=R28 L[4]=R13 L[5]=_
        # sun.nio.fs.UnixFileSystemProvider::getFileAttributeView @ bci:7 (line 120) L[0]=_ L[1]=_ L[2]=#Ptr0x00000040d8192f10 L[3]=_ L[4]=R7 L[5]=_
        # sun.nio.fs.LinuxFileSystemProvider::getFileAttributeView @ bci:48 (line 68) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:51 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=R29 L[1]=R7 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=R29 L[1]=R7 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=R29 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {t2=Oop x29=Oop c_rarg4=Oop c_rarg5=NarrowOop [8]=Oop [56]=Oop [72]=Oop off=2284/0x8ec}
08f0 +  blt  R13, R28, B91	#@cmpI_branch  P=0.499909 C=2755.000000

08f4    B95: #	out( B97 ) &lt;- in( B94 )  Freq: 0.24209
08f4 +  j  B97	#@branch

08f8    B96: #	out( B97 ) &lt;- in( B88 )  Freq: 0.242179
08f8 +  li R9, #1	# int, #@loadConI

08fc    B97: #	out( B376 B98 ) &lt;- in( B95 B96 )  Freq: 0.484269
08fc +  mv  R28, java/lang/Class:exact *	# ptr, #@loadConP
0914 +  lw  R8, [R28, #156]	# int, #@loadI ! Field: java/lang/System.allowSecurityManager (constant)
0918 +  li R31, #1	# int, #@loadConI
091c +  far_beq  R8, R31, B376	#@far_cmpI_branch  P=0.000000 C=5721.000000

0924    B98: #	out( B377 B99 ) &lt;- in( B97 )  Freq: 0.484269
0924 +  lwu  R28, [R28, #124]	# loadN, compressed ptr, #@loadN ! Field: volatile java/lang/System.security
0928 +  #@membar_acquire
	fence ir iorw
092c +  decode_heap_oop  R8, R28	#@decodeHeapOop
0930 +  far_bne   R8, zr, B377	#@far_cmpP_imm0_branch  P=0.000000 C=5538.000000

0938    B99: #	out( B274 B100 ) &lt;- in( B98 )  Freq: 0.484269
0938 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0938    ld  R10, [R23, #288]	# ptr, #@loadP
093c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
093c    ld  R28, [R23, #304]	# ptr, #@loadP
0940 +  addi  R30, R10, #128	# ptr, #@addP_reg_imm
0944 +  bgeu  R30, R28, B274	#@cmpP_branch  P=0.000100 C=-1.000000

0948    B100: #	out( B101 ) &lt;- in( B99 )  Freq: 0.48422
0948 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0948    sd  R30, [R23, #288]	# ptr, #@storeP
094c +  li R28, #1	# long, #@loadConL
0950 +  mv  R30, narrowklass: precise klass sun/nio/fs/UnixFileAttributes: 0x00000040d0457d30:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0960 +  sd  R28, [R10]	# long, #@storeL
0964 +  sw  R30, [R10, #8]	# compressed klass ptr, #@storeNKlass
0968 +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
096c +  sw  zr, [R10, #12]	# int, #@storeimmI0
0970 +  ClearArray #14, R28	#@clearArray_imm_reg

09a8    B101: #	out( B268 B102 ) &lt;- in( B275 B100 )  Freq: 0.484269
09a8    
09a8    MEMBAR-store-store	#@membar_storestore
09ac +  spill R10 -&gt; R30	# spill size = 64
09b0 +  encode_heap_oop  R11, R7	#@encodeHeapOop
09b4 +  # checkcastPP of R30, #@checkCastPP
09b4    bne  R9, zr, B268	#@cmpI_reg_imm0_branch  P=0.000363 C=2756.000000

09b8    B102: #	out( B427 B103 ) &lt;- in( B101 )  Freq: 0.484093
09b8 +  lwu  R10, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
09bc +  mv  R28, java/lang/Class:exact *	# ptr, #@loadConP
09d4 +  lwu  R31, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
09d8    spill [sp, #72] -&gt; R14	# spill size = 64
09dc +  lwu  R16, [R14, #68]	# loadN, compressed ptr, #@loadN ! Field: java/lang/Thread.threadLocals
09e0 +  lwu  R28, [R28, #116]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/NativeBuffers.threadLocal
09e4 +  decode_heap_oop  R10, R10	#@decodeHeapOop
09e8    lbu  R10, [R10, #12]	# byte, #@loadUB ! Field: sun/nio/fs/UnixFileSystem.needToResolveAgainstDefaultDirectory
09ec    NullCheck R10

09ec    B103: #	out( B379 B104 ) &lt;- in( B102 )  Freq: 0.484093
09ec +  decode_heap_oop  R12, R31	#@decodeHeapOop
09f0 +  far_bne  R10, zr, B379	#@far_cmpI_reg_imm0_branch  P=0.000000 C=2869.000000

09f8    B104: #	out( B428 B105 ) &lt;- in( B103 )  Freq: 0.484092
09f8    lwu  R15, [R12, #12]	# range, #@loadRange
09fc    NullCheck R12

09fc    B105: #	out( B380 B106 ) &lt;- in( B104 )  Freq: 0.484092
09fc +  decode_heap_oop  R16, R16	#@decodeHeapOop
0a00 +  decode_heap_oop  R17, R28	#@decodeHeapOop
0a04 +  far_bleu  R15, zr, B380	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000000 C=10257.000000

0a0c    B106: #	out( B429 B107 ) &lt;- in( B105 )  Freq: 0.484092
0a0c    lw  R31, [R17, #12]	# int, #@loadI ! Field: java/lang/ThreadLocal.threadLocalHashCode (constant)
0a10    NullCheck R17

0a10    B107: #	out( B437 B108 ) &lt;- in( B106 )  Freq: 0.484091
0a10 +  addiw  R18, R15, #1	#@addI_reg_imm
0a14    lwu  R10, [R16, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap.table
0a18    NullCheck R16

0a18    B108: #	out( B430 B109 ) &lt;- in( B107 )  Freq: 0.484091
0a18 +  decode_heap_oop  R20, R10	#@decodeHeapOop
0a1c    lwu  R19, [R20, #12]	# range, #@loadRange
0a20    NullCheck R20

0a20    B109: #	out( B343 B110 ) &lt;- in( B108 )  Freq: 0.48409
0a20 +  addiw  R10, R19, #-1	#@addI_reg_imm
0a24 +  andr  R13, R31, R10	#@andI_reg_reg
0a28 +  addw  R31, R13, zr	#@convI2L_reg_reg
0a2c +  slli  R31, R31, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0a30 +  add R31, R20, R31	# ptr, #@addP_reg_reg
0a34 +  far_bleu  R19, zr, B343	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

0a3c    B110: #	out( B438 B111 ) &lt;- in( B109 )  Freq: 0.48409
0a3c +  lwu  R10, [R31, #16]	# loadN, compressed ptr, #@loadN
0a40 +  decode_heap_oop  R19, R10	#@decodeHeapOop
0a44    lwu  R10, [R19, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
0a48    NullCheck R19

0a48    B111: #	out( B344 B112 ) &lt;- in( B110 )  Freq: 0.48409
0a48    
0a48 +  lwu  R31, [R19, #28]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap$Entry.value
0a4c +  decode_heap_oop  R31, R31	#@decodeHeapOop
0a50 +  far_bne  R10, R28, B344	#@far_cmpN_branch  P=0.000001 C=-1.000000

0a58    B112: #	out( B431 B113 ) &lt;- in( B111 )  Freq: 0.484089
0a58    lwu  R28, [R31, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0a5c    NullCheck R31

0a5c    B113: #	out( B401 B114 ) &lt;- in( B112 )  Freq: 0.484089
0a5c +  mv  R13, narrowklass: precise klass [Lsun/nio/fs/NativeBuffer;: 0x00000040d01a3a30:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0a6c +  far_bne  R28, R13, B401	#@far_cmpN_branch  P=0.000000 C=-1.000000

0a74    B114: #	out( B345 B115 ) &lt;- in( B113 )  Freq: 0.484089
0a74 +  # checkcastPP of R31, #@checkCastPP
0a74    lwu  R28, [R31, #12]	# range, #@loadRange
0a78 +  far_bleu  R28, zr, B345	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

0a80    B115: #	out( B439 B116 ) &lt;- in( B114 )  Freq: 0.484088
0a80 +  lwu  R28, [R31, #16]	# loadN, compressed ptr, #@loadN
0a84 +  decode_heap_oop  R21, R28	#@decodeHeapOop
0a88    lw  R8, [R21, #12]	# int, #@loadI ! Field: sun/nio/fs/NativeBuffer.size
0a8c    NullCheck R21

0a8c    B116: #	out( B366 B117 ) &lt;- in( B115 )  Freq: 0.484088
0a8c +  far_blt  R8, R18, B366	#@far_cmpI_branch  P=0.000000 C=2869.000000

0a94    B117: #	out( B250 B118 ) &lt;- in( B116 )  Freq: 0.484088
0a94 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0a94    lb  R13, [R23, #56]	# byte, #@loadB
0a98 +  lwu  R18, [R21, #28]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/NativeBuffer.owner
0a9c +  bne  R13, zr, B250	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0aa0    B118: #	out( B224 B119 ) &lt;- in( B367 B252 B250 B117 )  Freq: 0.484088
0aa0 +  decode_heap_oop  R10, R18	#@decodeHeapOop
0aa4 +  sw  rheapbase, [R31, #16]	# compressed ptr (rheapbase==0), #@storeImmN0
0aa8 +  ld  R24, [R21, #16]	# int, #@loadL ! Field: sun/nio/fs/NativeBuffer.address
0aac +  beq  R10, R7, B224	#@cmpP_branch  P=0.027884 C=2869.000000

0ab0    B119: #	out( B260 B120 ) &lt;- in( B118 )  Freq: 0.470589
0ab0 +  spill R7 -&gt; R18	# spill size = 64
0ab4 +  li R7, #1	# int, #@loadConI
0ab8    
0ab8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0ab8    sb  R7, [R23, #968]	# byte, #@storeB
0abc    spill R28 -&gt; [sp, #0]	# spill size = 32
0ac0    
0ac0    
0ac0    
0ac0 +  addi  R10, R12, #16	# ptr, #@addP_reg_imm
0ac4    spill R9 -&gt; R19	# spill size = 32
0ac8 +  addw  R25, R15, zr	#@convI2L_reg_reg
0acc    spill R11 -&gt; R22	# spill size = 32
0ad4 +  spill R30 -&gt; R20	# spill size = 64
0ad8 +  spill R14 -&gt; R8	# spill size = 64
0adc +  spill R29 -&gt; R9	# spill size = 64
0ae0 +  spill R25 -&gt; R12	# spill size = 64
0ae4 +  mv  R11, R24	# long -&gt; ptr, #@castX2P
0ae8    CALL, runtime leaf nofp 0x000000401396e3c0	#@CallLeafNoFPDirect unsafe_arraycopy
        No JVM State Info
        # 
0aec +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0aec    sb zr, [R23, #968]	# byte, #@storeimmB0
0af0    
0af0 +  ld  R24, [R21, #16]	# int, #@loadL ! Field: sun/nio/fs/NativeBuffer.address
0af4 +  mv  R7, R24	# long -&gt; ptr, #@castX2P
0af8 +  add R7, R7, R25	# ptr, #@addP_reg_reg
0afc +  sb zr, [R7]	# byte, #@storeimmB0
0b00 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0b00    lb  R28, [R23, #56]	# byte, #@loadB
0b04 +  bne  R28, zr, B260	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0b08    B120: #	out( B122 B121 ) &lt;- in( B373 B262 B260 B119 )  Freq: 0.470589
0b08 +  mv  R28, R21	# ptr -&gt; long, #@castP2X
0b0c    spill R18 -&gt; R7	# spill size = 64
0b10 +  mv  R29, R7	# ptr -&gt; long, #@castP2X
0b14 +  xorr  R29, R29, R28	#@xorL_reg_reg
0b18 +  srli  R29, R29, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0b1c +  sw  R22, [R21, #28]	# compressed ptr, #@storeN ! Field: sun/nio/fs/NativeBuffer.owner
0b20 +  beq  R29, zr, B122	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0b24    B121: #	out( B263 B122 ) &lt;- in( B120 )  Freq: 0.470119
0b24 +  srli  R28, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0b28 +  mv  R29, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
0b34 +  add R10, R29, R28	# ptr, #@addP_reg_reg
0b38 +  lb  R28, [R10]	# byte, #@loadB
0b3c +  li R30, #4	# int, #@loadConI
0b40 +  bne  R28, R30, B263	#@cmpI_branch  P=0.001000 C=-1.000000

0b44    B122: #	out( B123 ) &lt;- in( B267 B121 B120 )  Freq: 0.470589
0b44 +  spill R9 -&gt; R29	# spill size = 64
0b48 +  spill R19 -&gt; R9	# spill size = 32
0b4c +  spill R20 -&gt; R30	# spill size = 64
0b50 +  spill R22 -&gt; [sp, #4]	# spill size = 32

0b54    B123: #	out( B462 B124 ) &lt;- in( B224 B122 )  Freq: 0.484088
0b54 +  spill R21 -&gt; [sp, #48]	# spill size = 64
0b58 +  spill R30 -&gt; [sp, #40]	# spill size = 64
0b5c +  spill R9 -&gt; [sp, #32]	# spill size = 32
0b60 +  spill R7 -&gt; [sp, #24]	# spill size = 64
0b64 +  spill R29 -&gt; [sp, #16]	# spill size = 64
0b68 +  spill R24 -&gt; R11	# spill size = 64
0b6c +  spill R30 -&gt; R12	# spill size = 64
0b70    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect sun.nio.fs.UnixNativeDispatcher::lstat0
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:10 (line 308) L[0]=_ L[1]=_ L[2]=sp + #48 L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=NarrowOop [4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop off=2932/0xb74}

0b74    B124: #	out( B432 B125 ) &lt;- in( B123 )  Freq: 0.484078
        # Block is sole successor of call
0b74 +  mv  R7, java/lang/Class:exact *	# ptr, #@loadConP
0b8c +  lwu  R7, [R7, #116]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/NativeBuffers.threadLocal
0b90 +  lwu  R29, [R8, #68]	# loadN, compressed ptr, #@loadN ! Field: java/lang/Thread.threadLocals
0b94 +  decode_heap_oop  R30, R7	#@decodeHeapOop
0b98 +  decode_heap_oop  R31, R29	#@decodeHeapOop
0b9c    lw  R28, [R30, #12]	# int, #@loadI ! Field: java/lang/ThreadLocal.threadLocalHashCode (constant)
0ba0    NullCheck R30

0ba0    B125: #	out( B440 B126 ) &lt;- in( B124 )  Freq: 0.484078
0ba0    lwu  R29, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap.table
0ba4    NullCheck R31

0ba4    B126: #	out( B433 B127 ) &lt;- in( B125 )  Freq: 0.484077
0ba4 +  decode_heap_oop  R12, R29	#@decodeHeapOop
0ba8    lwu  R29, [R12, #12]	# range, #@loadRange
0bac    NullCheck R12

0bac    B127: #	out( B346 B128 ) &lt;- in( B126 )  Freq: 0.484077
0bac +  addiw  R11, R29, #-1	#@addI_reg_imm
0bb0 +  andr  R28, R28, R11	#@andI_reg_reg
0bb4 +  addw  R10, R28, zr	#@convI2L_reg_reg
0bb8 +  slli  R10, R10, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0bbc +  add R10, R12, R10	# ptr, #@addP_reg_reg
0bc0 +  far_bleu  R29, zr, B346	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

0bc8    B128: #	out( B441 B129 ) &lt;- in( B127 )  Freq: 0.484076
0bc8 +  lwu  R29, [R10, #16]	# loadN, compressed ptr, #@loadN
0bcc +  decode_heap_oop  R29, R29	#@decodeHeapOop
0bd0    lwu  R11, [R29, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
0bd4    NullCheck R29

0bd4    B129: #	out( B347 B130 ) &lt;- in( B128 )  Freq: 0.484076
0bd4    
0bd4 +  lwu  R10, [R29, #28]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap$Entry.value
0bd8 +  decode_heap_oop  R10, R10	#@decodeHeapOop
0bdc +  far_bne  R11, R7, B347	#@far_cmpN_branch  P=0.000001 C=-1.000000

0be4    B130: #	out( B434 B131 ) &lt;- in( B129 )  Freq: 0.484076
0be4    lwu  R28, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0be8    NullCheck R10

0be8    B131: #	out( B402 B132 ) &lt;- in( B130 )  Freq: 0.484075
0be8 +  mv  R7, narrowklass: precise klass [Lsun/nio/fs/NativeBuffer;: 0x00000040d01a3a30:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0bf8 +  far_bne  R28, R7, B402	#@far_cmpN_branch  P=0.000000 C=-1.000000

0c00    B132: #	out( B348 B133 ) &lt;- in( B131 )  Freq: 0.484075
0c00 +  # checkcastPP of R10, #@checkCastPP
0c00    lwu  R28, [R10, #12]	# range, #@loadRange
0c04 +  addi  R9, R10, #16	# ptr, #@addP_reg_imm
0c08 +  far_bleu  R28, zr, B348	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000001 C=-1.000000

0c10    B133: #	out( B368 B134 ) &lt;- in( B132 )  Freq: 0.484075
0c10 +  lwu  R7, [R9]	# loadN, compressed ptr, #@loadN
0c14 +  decode_heap_oop  R8, R7	#@decodeHeapOop
0c18 +  far_bne   R8, zr, B368	#@far_cmpP_imm0_branch  P=0.000000 C=2869.000000

0c20    B134: #	out( B253 B135 ) &lt;- in( B133 )  Freq: 0.484074
0c20 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c20    lb  R28, [R23, #56]	# byte, #@loadB
0c24 +  bne  R28, zr, B253	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0c28    B135: #	out( B137 B136 ) &lt;- in( B369 B255 B253 B134 )  Freq: 0.484074
0c28 +  mv  R7, R9	# ptr -&gt; long, #@castP2X
0c2c    spill [sp, #48] -&gt; R28	# spill size = 64
0c30 +  mv  R28, R28	# ptr -&gt; long, #@castP2X
0c30 +  xorr  R28, R28, R7	#@xorL_reg_reg
0c34 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0c38    spill [sp, #0] -&gt; R29	# spill size = 32
0c3c +  sw  R29, [R9]	# compressed ptr, #@storeN
0c40 +  beq  R28, zr, B137	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0c44    B136: #	out( B256 B137 ) &lt;- in( B135 )  Freq: 0.48359
0c44 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0c48 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
0c54 +  add R10, R28, R7	# ptr, #@addP_reg_reg
0c58 +  lb  R7, [R10]	# byte, #@loadB
0c5c +  li R29, #4	# int, #@loadConI
0c60 +  bne  R7, R29, B256	#@cmpI_branch  P=0.001000 C=-1.000000

0c64    B137: #	out( B276 B138 ) &lt;- in( B258 B259 B256 B136 B135 B269 )  Freq: 0.48425
0c64 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c64    ld  R10, [R23, #288]	# ptr, #@loadP
0c68 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c68    ld  R7, [R23, #304]	# ptr, #@loadP
0c6c +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
0c70 +  bgeu  R28, R7, B276	#@cmpP_branch  P=0.000100 C=-1.000000

0c74    B138: #	out( B139 ) &lt;- in( B137 )  Freq: 0.484202
0c74 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c74    sd  R28, [R23, #288]	# ptr, #@storeP
0c78 +  li R7, #1	# long, #@loadConL
0c7c +  mv  R28, narrowklass: precise klass sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes: 0x00000040d81f84d0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0c8c +  sd  R7, [R10]	# long, #@storeL
0c90 +  sw  R28, [R10, #8]	# compressed klass ptr, #@storeNKlass
0c94 +  sw  zr, [R10, #12]	# int, #@storeimmI0

0c98    B139: #	out( B424 B140 ) &lt;- in( B277 B138 )  Freq: 0.48425
0c98    spill [sp, #40] -&gt; R7	# spill size = 64
0c9c +  encode_heap_oop  R7, R7	#@encodeHeapOop
0ca0    
0ca0 +  # checkcastPP of R10, #@checkCastPP
0ca0    sw  R7, [R10, #12]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes.attrs
0ca4 +  #@membar_release
	fence iorw ow
0ca8 +  spill [sp, #16] -&gt; R31	# spill size = 64
0cac +  lwu  R28, [R31, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker.stack
0cb0 +  spill R10 -&gt; R12	# spill size = 64
0cb4 +  # checkcastPP of R12, #@checkCastPP
0cb4    decode_heap_oop  R7, R28	#@decodeHeapOop
0cb8    lwu  R28, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/ArrayDeque.elements
0cbc    NullCheck R7

0cbc    B140: #	out( B425 B141 ) &lt;- in( B139 )  Freq: 0.48425
0cbc +  lw  R30, [R7, #12]	# int, #@loadI ! Field: java/util/ArrayDeque.head
0cc0 +  lw  R7, [R7, #16]	# int, #@loadI ! Field: java/util/ArrayDeque.tail
0cc4 +  decode_heap_oop  R28, R28	#@decodeHeapOop
0cc8    lwu  R29, [R28, #12]	# range, #@loadRange
0ccc    NullCheck R28

0ccc    B141: #	out( B378 B142 ) &lt;- in( B140 )  Freq: 0.484249
0ccc +  subw  R7, R7, R30	#@subI_reg_reg
0cd0 +  sraiw R28, R28, 31	#@cmpLTMask_reg_reg
0cd4 +  andr  R29, R28, R29	#@andI_reg_reg
0cd8 +  addw  R8, R29, R7	#@addI_reg_reg
0cdc +  lw  R28, [R31, #12]	# int, #@loadI ! Field: java/nio/file/FileTreeWalker.maxDepth
0ce0 +  lwu  R30, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0ce4 +  mv  R7, narrowklass: precise klass sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes: 0x00000040d81f84d0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0cf4 +  far_bge  R8, R28, B378	#@far_cmpI_branch  P=0.000000 C=2750.000000

0cfc    B142: #	out( B342 B143 ) &lt;- in( B141 )  Freq: 0.484249
0cfc +  far_bne  R30, R7, B342	#@far_cmpN_branch  P=0.000001 C=-1.000000

0d04    B143: #	out( B426 B144 ) &lt;- in( B142 )  Freq: 0.484248
0d04 +  spill R12 -&gt; R30	# spill size = 64
0d08 +  # checkcastPP of R30, #@checkCastPP
0d08    lwu  R28, [R30, #12]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes.attrs
0d0c +  decode_heap_oop  R7, R28	#@decodeHeapOop
0d10    lw  R7, [R7, #12]	# int, #@loadI ! Field: sun/nio/fs/UnixFileAttributes.st_mode
0d14    NullCheck R7

0d14    B144: #	out( B195 B145 ) &lt;- in( B143 )  Freq: 0.484248
0d14 +  li R29, #61440	# int, #@loadConI
0d18 +  andr  R7, R7, R29	#@andI_reg_reg
0d1c +  li R29, #16384	# int, #@loadConI
0d20 +  beq  R7, R29, B195	#@cmpI_branch  P=0.028364 C=2750.000000

0d24    B145: #	out( B278 B146 ) &lt;- in( B144 )  Freq: 0.470513
0d24 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0d24    ld  R10, [R23, #288]	# ptr, #@loadP
0d28 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0d28    ld  R7, [R23, #304]	# ptr, #@loadP
0d2c +  addi  R28, R10, #32	# ptr, #@addP_reg_imm
0d30 +  bgeu  R28, R7, B278	#@cmpP_branch  P=0.000100 C=-1.000000

0d34    B146: #	out( B147 ) &lt;- in( B145 )  Freq: 0.470466
0d34 +  li R7, #1	# long, #@loadConL
0d38 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0d38    sd  R28, [R23, #288]	# ptr, #@storeP
0d3c +  sd  R7, [R10]	# long, #@storeL
0d40 +  mv  R7, narrowklass: precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d0a1cd70:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0d50 +  sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
0d54 +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
0d58 +  sw  zr, [R10, #12]	# int, #@storeimmI0
0d5c +  ClearArray #2, R28	#@clearArray_imm_reg

0d64    B147: #	out( B532 B148 ) &lt;- in( B279 B146 )  Freq: 0.470513
0d64    
0d64    MEMBAR-store-store	#@membar_storestore
0d68 +  spill R10 -&gt; R8	# spill size = 64
0d6c +  # checkcastPP of R8, #@checkCastPP
0d6c    mv  R12, java/nio/file/FileTreeWalker$EventType:exact *	# ptr, #@loadConP
0d84    spill R8 -&gt; R11	# spill size = 64
0d88 +  spill [sp, #24] -&gt; R13	# spill size = 64
0d8c +  spill R30 -&gt; R14	# spill size = 64
0d90 +  mv  R15, NULL	# NULL ptr, #@loadConP0
0d94    spill R31 -&gt; [sp, #0]	# spill size = 64
0d98    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeWalker$Event::&lt;init&gt;
        # java.nio.file.FileTreeWalker$Event::&lt;init&gt; @ bci:5 (line 141) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.nio.file.FileTreeWalker::visit @ bci:76 (line 289) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=R8
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #0 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [56]=Oop off=3484/0xd9c}

0d9c    B148: #	out( B149 ) &lt;- in( B147 )  Freq: 0.470503
        # Block is sole successor of call
0d9c +  spill R8 -&gt; [sp, #0]	# spill size = 64

0da0    B149: #	out( B150 ) &lt;- in( B223 B148 B193 )  Freq: 0.49898
0da0 +  mv  R8, narrowoop: java/nio/file/FileTreeWalker$EventType:exact *	# compressed ptr, #@loadConN

0db0    B150: #	out( B534 B151 ) &lt;- in( B149 B184 ) Loop( B150-B184 inner ) Freq: 0.514227
0db0    spill [sp, #0] -&gt; R11	# spill size = 64
0db4    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeWalker$Event::ioeException
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:20 (line 85) L[0]=sp + #8 L[1]=sp + #0 L[2]=_
        # OopMap {fp=NarrowOop [0]=Oop [8]=Oop off=3512/0xdb8}

0db8    B151: #	out( B323 B152 ) &lt;- in( B150 )  Freq: 0.514216
        # Block is sole successor of call
0db8 +  spill [sp, #0] -&gt; R9	# spill size = 64
0dbc +  lwu  R7, [R9, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.type
0dc0 +  bne   R10, zr, B323	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

0dc4    B152: #	out( B181 B153 ) &lt;- in( B151 )  Freq: 0.514216
0dc4 +  beq  R7, R8, B181	#@cmpN_branch  P=0.029671 C=2831.000000

0dc8    B153: #	out( B234 B154 ) &lt;- in( B152 )  Freq: 0.498958
0dc8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0dc8    lb  R28, [R23, #56]	# byte, #@loadB
0dcc +  bne  R28, zr, B234	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0dd0    B154: #	out( B155 ) &lt;- in( B153 )  Freq: 0.498459
0dd0 +  spill [sp, #8] -&gt; R18	# spill size = 64

0dd4    B155: #	out( B161 B156 ) &lt;- in( B362 B236 B234 B154 )  Freq: 0.498958
0dd4 +  mv  R7, R18	# ptr -&gt; long, #@castP2X
0dd8 +  mv  R28, R9	# ptr -&gt; long, #@castP2X
0ddc +  xorr  R28, R28, R7	#@xorL_reg_reg
0de0 +  encode_heap_oop  R29, R9	#@encodeHeapOop
0de4 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0de8 +  sw  R29, [R18, #16]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeIterator.next
0dec +  beq  R28, zr, B161	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0df0    B156: #	out( B161 B157 ) &lt;- in( B155 )  Freq: 0.498459
0df0 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0df4 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
0e00 +  add R10, R28, R7	# ptr, #@addP_reg_reg
0e04 +  lb  R28, [R10]	# byte, #@loadB
0e08 +  li R29, #4	# int, #@loadConI
0e0c +  beq  R28, R29, B161	#@cmpI_branch  P=0.999000 C=-1.000000

0e10    B157: #	out( B161 B158 ) &lt;- in( B156 )  Freq: 0.000498459
0e10 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e10    ld  R7, [R23, #64]	# int, #@loadL
0e14 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e14    ld  R28, [R23, #80]	# ptr, #@loadP
0e18 +  #@membar_volatile
	fence iorw iorw
0e1c +  lb  R29, [R10]	# byte, #@loadB
0e20 +  beq  R29, zr, B161	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

0e24    B158: #	out( B160 B159 ) &lt;- in( B157 )  Freq: 0.00024923
0e24 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
0e28 +  bne  R7, zr, B160	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

0e2c    B159: #	out( B161 ) &lt;- in( B158 )  Freq: 0.000124615
0e2c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e2c    spill R23 -&gt; R11	# spill size = 64
0e30 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
0e60 +  j  B161	#@branch

0e64    B160: #	out( B161 ) &lt;- in( B158 )  Freq: 0.000124615
0e64 +  add R28, R28, R7	# ptr, #@addP_reg_reg
0e68 +  addi  R7, R7, #-8	#@addL_reg_imm
0e6c +  sd  R10, [R28, #-8]	# ptr, #@storeP
0e70 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e70    sd  R7, [R23, #64]	# long, #@storeL

0e74    B161: #	out( N6569 ) &lt;- in( B159 B160 B157 B156 B155 B183 B6 B1 )  Freq: 0.999928
0e74    # pop frame 176
	add  sp, sp, #176
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0ed4 +  ret	// return register, #@Ret

0ed8    B162: #	out( B167 B163 ) &lt;- in( B46 )  Freq: 0.0274952
0ed8 +  li R28, #1	# int, #@loadConI
0edc +  beq  R22, R28, B167	#@cmpI_branch  P=0.506329 C=158.000000

0ee0    B163: #	out( B397 B164 ) &lt;- in( B162 )  Freq: 0.0135736
0ee0 +  li R28, #2	# int, #@loadConI
0ee4 +  far_bne  R22, R28, B397	#@far_cmpI_branch  P=0.000000 C=78.000000

0eec    B164: #	out( B389 B165 ) &lt;- in( B163 )  Freq: 0.0135736
0eec +  li R7, #1	# int, #@loadConI
0ef0 +  far_bleu R22, R7, B389	#@far_cmpU_branch  P=0.000001 C=-1.000000

0ef8    B165: #	out( B167 B166 ) &lt;- in( B164 )  Freq: 0.0135735
0ef8 +  lb  R8, [R20, #17]	# byte, #@loadB
0efc +  li R28, #46	# int, #@loadConI
0f00 +  beq  R8, R28, B167	#@cmpI_branch  P=1.000000 C=78.000000

0f04    B166: #	out( N6569 ) &lt;- in( B165 )  Freq: 6.78677e-09
0f04 +  spill [sp, #8] -&gt; R7	# spill size = 64
0f08 +  li R11, #-187	# int, #@loadConI
0f0c    spill R7 -&gt; [sp, #0]	# spill size = 64
0f10 +  spill R19 -&gt; [sp, #16]	# spill size = 64
0f14 +  spill R19 -&gt; [sp, #24]	# spill size = 64
0f18    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::isSelfOrParent @ bci:25 (line 146) L[0]=_ L[1]=_ STK[0]=R8 STK[1]=#46
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:123 (line 181) L[0]=sp + #16 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [64]=Oop off=3868/0xf1c}
0f1c    #@ShouldNotReachHere

0f28    B167: #	out( B444 B168 ) &lt;- in( B165 B162 )  Freq: 0.0274952
0f28 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0f28    spill R19 -&gt; R7	# spill size = 64
0f2c +  ld  R11, [R23, #920]	# ptr, #@loadP
0f30    spill R7 -&gt; R29	# spill size = 64
0f34 +  lwu zr, [R11]	# Safepoint: poll for GC, #@safePoint        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:182 (line 192) L[0]=R29 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=R29 STK[0]=R29 MON-BOX0=sp+144 MON-OBJ[0]=R29
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=R29 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {x29=Oop c_rarg0=Oop x19=Oop [0]=Oop [8]=Oop [24]=NarrowOop [48]=Oop [56]=Oop [72]=Oop off=3892/0xf34}
0f38    lwu  R7, [R10, #32]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream.streamLock
0f3c    NullCheck R10

0f3c    B168: #	out( B445 B169 ) &lt;- in( B167 )  Freq: 0.0274951
0f3c +  decode_heap_oop  R7, R7	#@decodeHeapOop
0f40    lwu  R28, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock.readerLock
0f44    NullCheck R7

0f44    B169: #	out( B446 B170 ) &lt;- in( B168 )  Freq: 0.0274951
0f44 +  decode_heap_oop  R8, R28	#@decodeHeapOop
0f48    # checkcastPP of R8, #@checkCastPP
0f48    lwu  R7, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0f4c    NullCheck R8

0f4c    B170: #	out( B381 B171 ) &lt;- in( B169 )  Freq: 0.0274951
0f4c +  mv  R29, narrowklass: precise klass java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock: 0x00000040d08c1680:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0f5c +  far_bne  R7, R29, B381	#@far_cmpN_branch  P=0.000001 C=-1.000000

0f64    B171: #	out( B447 B172 ) &lt;- in( B170 )  Freq: 0.027495
0f64 +  # checkcastPP of R8, #@checkCastPP
0f64    lwu  R7, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock.sync
0f68 +  decode_heap_oop  R29, R7	#@decodeHeapOop
0f6c    lw  R31, [R29, #16]	# int, #@loadI ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.state
0f70    NullCheck R29

0f70    B172: #	out( B390 B173 ) &lt;- in( B171 )  Freq: 0.027495
0f70 +  #@membar_acquire
	fence ir iorw
0f74 +  li R7, #65535	# int, #@loadConI
0f7c +  andr  R8, R31, R7	#@andI_reg_reg
0f80 +  far_bne  R8, zr, B390	#@far_cmpI_reg_imm0_branch  P=0.000000 C=3040.000000

0f88    B173: #	out( B382 B174 ) &lt;- in( B172 )  Freq: 0.027495
0f88 +  lwu  R28, [R29, #20]	# loadN, compressed ptr, #@loadN ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.head
0f8c +  #@membar_acquire
	fence ir iorw
0f90 +  decode_heap_oop  R8, R28	#@decodeHeapOop
0f94 +  srliw  R30, R31, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
0f98 +  far_bne   R8, zr, B382	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

0fa0    B174: #	out( B391 B175 ) &lt;- in( B173 )  Freq: 0.027495
0fa0 +  li R28, #65535	# int, #@loadConI
0fa8 +  far_bge  R30, R28, B391	#@far_cmpI_branch  P=0.000000 C=3040.000000

0fb0    B175: #	out( B392 B176 ) &lt;- in( B174 )  Freq: 0.027495
0fb0 +  #@membar_release
	fence iorw ow
0fb4 +  li R28, #65536	# int, #@loadConI
0fb8 +  addw  R28, R31, R28	#@addI_reg_reg
0fbc +  addi  R7, R29, #16	# ptr, #@addP_reg_imm
0fc0    
0fc0 +  cmpxchg_acq [R7], R31, R28	# (int) if [R7] == R31 then [R7] &lt;-- R28
	mv R8, R8 == R31	# R8 &lt;-- (R8 == R31 ? 1 : 0), #@compareAndSwapIAcq
0fdc    
0fdc +  #@membar_acquire
	fence ir iorw
0fe0 +  far_beq  R8, zr, B392	#@far_cmpI_reg_imm0_branch  P=0.000000 C=3040.000000

0fe8    B176: #	out( B387 B177 ) &lt;- in( B175 )  Freq: 0.0274949
0fe8 +  far_bne  R30, zr, B387	#@far_cmpI_reg_imm0_branch  P=0.000000 C=3040.000000

0ff0    B177: #	out( B280 B178 ) &lt;- in( B176 )  Freq: 0.0274949
0ff0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0ff0    lb  R28, [R23, #56]	# byte, #@loadB
0ff4 +  bne  R28, zr, B280	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0ff8    B178: #	out( B180 B179 ) &lt;- in( B388 B282 B280 B177 )  Freq: 0.0274949
0ff8 +  mv  R28, R29	# ptr -&gt; long, #@castP2X
0ffc    spill [sp, #72] -&gt; R20	# spill size = 64
1000 +  mv  R7, R20	# ptr -&gt; long, #@castP2X
1004 +  xorr  R7, R7, R28	#@xorL_reg_reg
1008 +  srli  R30, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
100c    spill [sp, #24] -&gt; R7	# spill size = 32
1010 +  sw  R7, [R29, #40]	# compressed ptr, #@storeN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
1014 +  beq  R30, zr, B180	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1018    B179: #	out( B283 B180 ) &lt;- in( B178 )  Freq: 0.0274674
1018 +  srli  R28, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
101c +  mv  R30, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1028 +  add R10, R30, R28	# ptr, #@addP_reg_reg
102c +  lb  R30, [R10]	# byte, #@loadB
1030 +  li R31, #4	# int, #@loadConI
1034 +  bne  R30, R31, B283	#@cmpI_branch  P=0.001000 C=-1.000000

1038    B180: #	out( B28 ) &lt;- in( B285 B286 B283 B179 B178 )  Freq: 0.0274949
1038 +  li R28, #1	# int, #@loadConI
103c +  sw  R28, [R29, #28]	# int, #@storeI ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReaderHoldCount
1040    spill [sp, #8] -&gt; R9	# spill size = 64
1044 +  spill [sp, #48] -&gt; R18	# spill size = 64
1048 +  spill [sp, #56] -&gt; R24	# spill size = 64
104c +  j  B28	#@branch

1050    B181: #	out( B383 B182 ) &lt;- in( B152 )  Freq: 0.0152575
1050 +  spill [sp, #8] -&gt; R28	# spill size = 64
1054 +  lwu  R7, [R28, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.walker
1058 +  decode_heap_oop  R11, R7	#@decodeHeapOop
105c +  far_beq   R11, zr, B383	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

1064    B182: #	out( B531 B183 ) &lt;- in( B181 )  Freq: 0.0152575
1064    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeWalker::next
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:57 (line 94) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=NarrowOop [8]=Oop off=4200/0x1068}

1068    B183: #	out( B161 B184 ) &lt;- in( B182 )  Freq: 0.0152572
        # Block is sole successor of call
1068 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1068    ld  R7, [R23, #920]	# ptr, #@loadP
106c +  lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:61 (line 95) L[0]=sp + #8 L[1]=R10 L[2]=_
        # OopMap {c_rarg0=Oop fp=NarrowOop [8]=Oop off=4204/0x106c}
1070 +  beq   R10, zr, B161	#@cmpP_imm0_branch  P=0.001059 C=84.000000

1074    B184: #	out( B150 ) &lt;- in( B183 )  Freq: 0.0152411
1074 +  spill R10 -&gt; [sp, #0]	# spill size = 64
1078 +  j  B150	#@branch

107c    B185: #	out( B448 B186 ) &lt;- in( B77 )  Freq: 0.0147441
107c +  spill [sp, #56] -&gt; R29	# spill size = 64
1080 +  lwu  R7, [R29, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.stream
1084 +  decode_heap_oop  R30, R7	#@decodeHeapOop
1088    lwu  R28, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
108c    NullCheck R30

108c    B186: #	out( B385 B187 ) &lt;- in( B185 )  Freq: 0.0147441
108c +  mv  R7, narrowklass: precise klass sun/nio/fs/UnixSecureDirectoryStream: 0x00000040d09ebc60:Constant:exact *	# compressed klass ptr, #@loadConNKlass
109c +  far_bne  R28, R7, B385	#@far_cmpN_branch  P=0.000001 C=-1.000000

10a4    B187: #	out( B442 B188 ) &lt;- in( B186 )  Freq: 0.014744
10a4 +  # checkcastPP of R30, #@checkCastPP
10a4    spill R29 -&gt; [sp, #0]	# spill size = 64
10a8 +  spill R30 -&gt; R11	# spill size = 64
10ac    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixSecureDirectoryStream::close
        # java.nio.file.FileTreeWalker::next @ bci:76 (line 361) L[0]=sp + #48 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [48]=Oop off=4272/0x10b0}

10b0    B188: #	out( B384 B189 ) &lt;- in( B187 )  Freq: 0.0147438
        # Block is sole successor of call
10b0 +  spill [sp, #48] -&gt; R7	# spill size = 64
10b4 +  lwu  R28, [R7, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker.stack
10b8 +  decode_heap_oop  R11, R28	#@decodeHeapOop
10bc +  far_beq   R11, zr, B384	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

10c4    B189: #	out( B530 B190 ) &lt;- in( B188 )  Freq: 0.0147437
10c4    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.ArrayDeque::removeFirst
        # java.util.ArrayDeque::pop @ bci:1 (line 593) L[0]=_
        # java.nio.file.FileTreeWalker::next @ bci:109 (line 369) L[0]=_ L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop off=4296/0x10c8}

10c8    B190: #	out( B315 B191 ) &lt;- in( B189 )  Freq: 0.0147434
        # Block is sole successor of call
10c8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
10c8    ld  R10, [R23, #288]	# ptr, #@loadP
10cc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
10cc    ld  R7, [R23, #304]	# ptr, #@loadP
10d0 +  addi  R28, R10, #32	# ptr, #@addP_reg_imm
10d4 +  bgeu  R28, R7, B315	#@cmpP_branch  P=0.000100 C=-1.000000

10d8    B191: #	out( B192 ) &lt;- in( B190 )  Freq: 0.014742
10d8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
10d8    sd  R28, [R23, #288]	# ptr, #@storeP
10dc +  li R7, #1	# long, #@loadConL
10e0 +  mv  R28, narrowklass: precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d0a1cd70:Constant:exact *	# compressed klass ptr, #@loadConNKlass
10f0 +  sd  R7, [R10]	# long, #@storeL
10f4 +  sw  R28, [R10, #8]	# compressed klass ptr, #@storeNKlass
10f8 +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
10fc +  sw  zr, [R10, #12]	# int, #@storeimmI0
1100 +  ClearArray #2, R28	#@clearArray_imm_reg

1108    B192: #	out( B529 B193 ) &lt;- in( B316 B191 )  Freq: 0.0147434
1108    
1108    MEMBAR-store-store	#@membar_storestore
110c +  spill [sp, #0] -&gt; R7	# spill size = 64
1110 +  lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.dir
1114 +  spill R10 -&gt; R8	# spill size = 64
1118 +  decode_heap_oop  R13, R28	#@decodeHeapOop
111c +  # checkcastPP of R8, #@checkCastPP
111c    mv  R12, java/nio/file/FileTreeWalker$EventType:exact *	# ptr, #@loadConP
1134    spill R8 -&gt; R11	# spill size = 64
1138 +  mv  R14, NULL	# NULL ptr, #@loadConP0
113c    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeWalker$Event::&lt;init&gt;
        # java.nio.file.FileTreeWalker::next @ bci:126 (line 370) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=R8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop off=4416/0x1140}

1140    B193: #	out( B149 ) &lt;- in( B192 )  Freq: 0.0147431
        # Block is sole successor of call
1140 +  spill R8 -&gt; [sp, #0]	# spill size = 64
1144 +  j  B149	#@branch

1148    B194: #	out( B72 ) &lt;- in( B44 )  Freq: 0.0142018
1148 +  li R28, #1	# int, #@loadConI
114c    spill [sp, #0] -&gt; R19	# spill size = 64
1150 +  sb  R28, [R19, #12]	# byte, #@storeB ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.atEof
1154 +  mv  R18, NULL	# NULL ptr, #@loadConP0
1158 +  j  B72	#@branch

115c    B195: #	out( B398 B196 ) &lt;- in( B144 )  Freq: 0.013735
115c +  lbu  R8, [R31, #16]	# byte, #@loadUB ! Field: java/nio/file/FileTreeWalker.followLinks
1160 +  far_bne  R8, zr, B398	#@far_cmpI_reg_imm0_branch  P=0.000000 C=78.000000

1168    B196: #	out( B443 B197 ) &lt;- in( B195 )  Freq: 0.013735
1168 +  spill R30 -&gt; [sp, #32]	# spill size = 64
116c +  spill [sp, #24] -&gt; R11	# spill size = 64
1170    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.nio.file.Files::newDirectoryStream
        # java.nio.file.FileTreeWalker::visit @ bci:131 (line 301) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [56]=Oop off=4468/0x1174}

1174    B197: #	out( B317 B198 ) &lt;- in( B196 )  Freq: 0.0137348
        # Block is sole successor of call
1174 +  spill R10 -&gt; R8	# spill size = 64
1178 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1178    ld  R10, [R23, #288]	# ptr, #@loadP
117c    spill [sp, #16] -&gt; R30	# spill size = 64
1180 +  lwu  R28, [R30, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker.stack
1184 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1184    ld  R29, [R23, #304]	# ptr, #@loadP
1188 +  addi  R7, R10, #32	# ptr, #@addP_reg_imm
118c +  decode_heap_oop  R31, R28	#@decodeHeapOop
1190 +  bgeu  R7, R29, B317	#@cmpP_branch  P=0.000100 C=-1.000000

1194    B198: #	out( B199 ) &lt;- in( B197 )  Freq: 0.0137334
1194 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1194    sd  R7, [R23, #288]	# ptr, #@storeP
1198 +  li R7, #1	# long, #@loadConL
119c +  sd  R7, [R10]	# long, #@storeL
11a0 +  mv  R7, narrowklass: precise klass java/nio/file/FileTreeWalker$DirectoryNode: 0x00000040d09f6eb0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
11b0 +  sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
11b4 +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
11b8 +  sw  zr, [R10, #12]	# int, #@storeimmI0
11bc    ClearArray #2, R28	#@clearArray_imm_reg
11c4    spill R31 -&gt; [sp, #40]	# spill size = 64

11c8    B199: #	out( B528 B200 ) &lt;- in( B318 B198 )  Freq: 0.0137348
11c8    
11c8 +  spill R10 -&gt; R7	# spill size = 64
11cc +  # checkcastPP of R7, #@checkCastPP
11cc    spill R7 -&gt; [sp, #48]	# spill size = 64
11d0 +  spill [sp, #32] -&gt; R11	# spill size = 64
11d4    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes::fileKey
        # java.nio.file.FileTreeWalker::visit @ bci:177 (line 311) L[0]=_ L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=R8 L[7]=_ STK[0]=sp + #40 STK[1]=sp + #48 STK[2]=sp + #48 STK[3]=sp + #24
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=4568/0x11d8}

11d8    B200: #	out( B293 B201 ) &lt;- in( B199 )  Freq: 0.0137345
        # Block is sole successor of call
11d8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
11d8    lb  R7, [R23, #56]	# byte, #@loadB
11dc    spill R10 -&gt; R9	# spill size = 64
11e0 +  bne  R7, zr, B293	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

11e4    B201: #	out( B202 ) &lt;- in( B200 )  Freq: 0.0137207
11e4 +  spill [sp, #48] -&gt; R20	# spill size = 64

11e8    B202: #	out( B204 B203 ) &lt;- in( B393 B295 B293 B201 )  Freq: 0.0137345
11e8 +  mv  R7, R20	# ptr -&gt; long, #@castP2X
11ec    spill [sp, #24] -&gt; R18	# spill size = 64
11f0 +  mv  R28, R18	# ptr -&gt; long, #@castP2X
11f4 +  xorr  R28, R28, R7	#@xorL_reg_reg
11f8 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
11fc    spill R8 -&gt; R21	# spill size = 64
1200 +  encode_heap_oop  R19, R21	#@encodeHeapOop
1204    spill R9 -&gt; R22	# spill size = 64
1208 +  encode_heap_oop  R9, R9	#@encodeHeapOop
120c    spill [sp, #4] -&gt; R30	# spill size = 32
1210 +  sw  R30, [R20, #16]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.dir
1214 +  beq  R28, zr, B204	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1218    B203: #	out( B299 B204 ) &lt;- in( B202 )  Freq: 0.0137207
1218 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
121c +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1228 +  add R10, R28, R7	# ptr, #@addP_reg_reg
122c +  lb  R28, [R10]	# byte, #@loadB
1230 +  li R7, #4	# int, #@loadConI
1234 +  bne  R28, R7, B299	#@cmpI_branch  P=0.001000 C=-1.000000

1238    B204: #	out( B287 B205 ) &lt;- in( B301 B302 B299 B203 B202 )  Freq: 0.0137345
1238 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1238    lb  R7, [R23, #56]	# byte, #@loadB
123c +  bne  R7, zr, B287	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1240    B205: #	out( B208 B206 ) &lt;- in( B394 B289 B287 B204 )  Freq: 0.0137345
1240 +  mv  R28, R20	# ptr -&gt; long, #@castP2X
1244 +  mv  R7, R22	# ptr -&gt; long, #@castP2X
1248 +  xorr  R7, R7, R28	#@xorL_reg_reg
124c +  srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
1250 +  sw  R9, [R20, #20]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.key
1254 +  beq  R7, zr, B208	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1258    B206: #	out( B208 B207 ) &lt;- in( B205 )  Freq: 0.0137207
1258 +  beq   R22, zr, B208	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

125c    B207: #	out( B303 B208 ) &lt;- in( B206 )  Freq: 0.013707
125c +  srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1260 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
126c +  add R10, R28, R7	# ptr, #@addP_reg_reg
1270 +  lb  R28, [R10]	# byte, #@loadB
1274 +  li R29, #4	# int, #@loadConI
1278 +  bne  R28, R29, B303	#@cmpI_branch  P=0.001000 C=-1.000000

127c    B208: #	out( B290 B209 ) &lt;- in( B305 B306 B303 B207 B206 B205 )  Freq: 0.0137345
127c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
127c    lb  R7, [R23, #56]	# byte, #@loadB
1280 +  bne  R7, zr, B290	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1284    B209: #	out( B212 B210 ) &lt;- in( B395 B292 B290 B208 )  Freq: 0.0137345
1284 +  mv  R28, R20	# ptr -&gt; long, #@castP2X
1288 +  mv  R7, R21	# ptr -&gt; long, #@castP2X
128c +  xorr  R7, R7, R28	#@xorL_reg_reg
1290 +  srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
1294 +  sw  R19, [R20, #24]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.stream
1298 +  beq  R7, zr, B212	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

129c    B210: #	out( B212 B211 ) &lt;- in( B209 )  Freq: 0.0137207
129c +  beq   R21, zr, B212	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

12a0    B211: #	out( B307 B212 ) &lt;- in( B210 )  Freq: 0.013707
12a0 +  srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
12a4 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
12b0 +  add R10, R28, R7	# ptr, #@addP_reg_reg
12b4 +  lb  R28, [R10]	# byte, #@loadB
12b8 +  li R7, #4	# int, #@loadConI
12bc +  bne  R28, R7, B307	#@cmpI_branch  P=0.001000 C=-1.000000

12c0    B212: #	out( B527 B213 ) &lt;- in( B309 B310 B307 B211 B210 B209 )  Freq: 0.0137345
12c0 +  spill R20 -&gt; R8	# spill size = 64
12c4 +  spill R21 -&gt; R11	# spill size = 64
12c8    CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.nio.file.DirectoryStream::iterator
        # java.nio.file.FileTreeWalker$DirectoryNode::&lt;init&gt; @ bci:21 (line 78) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=R8
        # java.nio.file.FileTreeWalker::visit @ bci:184 (line 311) L[0]=_ L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #40 STK[1]=R8
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop off=4836/0x12e4}

12e4    B213: #	out( B296 B214 ) &lt;- in( B212 )  Freq: 0.0137342
        # Block is sole successor of call
12e4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
12e4    lb  R28, [R23, #56]	# byte, #@loadB
12e8    spill R10 -&gt; R9	# spill size = 64
12ec +  bne  R28, zr, B296	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

12f0    B214: #	out( B215 ) &lt;- in( B213 )  Freq: 0.0137205
12f0 +  spill R8 -&gt; R18	# spill size = 64

12f4    B215: #	out( B218 B216 ) &lt;- in( B396 B298 B296 B214 )  Freq: 0.0137342
12f4 +  mv  R28, R18	# ptr -&gt; long, #@castP2X
12f8    spill R9 -&gt; R30	# spill size = 64
12fc +  mv  R7, R30	# ptr -&gt; long, #@castP2X
1300 +  xorr  R7, R7, R28	#@xorL_reg_reg
1304 +  encode_heap_oop  R29, R30	#@encodeHeapOop
1308 +  srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
130c +  sw  R29, [R18, #28]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.iterator
1310 +  beq  R7, zr, B218	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1314    B216: #	out( B218 B217 ) &lt;- in( B215 )  Freq: 0.0137205
1314 +  beq   R30, zr, B218	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

1318    B217: #	out( B311 B218 ) &lt;- in( B216 )  Freq: 0.0137068
1318 +  srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
131c +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1328 +  add R10, R28, R7	# ptr, #@addP_reg_reg
132c +  lb  R28, [R10]	# byte, #@loadB
1330 +  li R29, #4	# int, #@loadConI
1334 +  bne  R28, R29, B311	#@cmpI_branch  P=0.001000 C=-1.000000

1338    B218: #	out( B386 B219 ) &lt;- in( B313 B314 B311 B217 B216 B215 )  Freq: 0.0137342
1338 +  #@membar_release
	fence iorw ow
133c +  spill [sp, #40] -&gt; R7	# spill size = 64
1340 +  far_beq   R7, zr, B386	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

1348    B219: #	out( B526 B220 ) &lt;- in( B218 )  Freq: 0.0137342
1348 +  spill [sp, #40] -&gt; R11	# spill size = 64
134c +  spill R18 -&gt; R12	# spill size = 64
1350    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.ArrayDeque::addFirst
        # java.util.ArrayDeque::push @ bci:2 (line 579) L[0]=_ L[1]=_
        # java.nio.file.FileTreeWalker::visit @ bci:187 (line 311) L[0]=_ L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [32]=Oop [56]=Oop off=4948/0x1354}

1354    B220: #	out( B319 B221 ) &lt;- in( B219 )  Freq: 0.0137339
        # Block is sole successor of call
1354 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1354    ld  R10, [R23, #288]	# ptr, #@loadP
1358 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1358    ld  R7, [R23, #304]	# ptr, #@loadP
135c +  addi  R28, R10, #32	# ptr, #@addP_reg_imm
1360 +  bgeu  R28, R7, B319	#@cmpP_branch  P=0.000100 C=-1.000000

1364    B221: #	out( B222 ) &lt;- in( B220 )  Freq: 0.0137325
1364 +  li R7, #1	# long, #@loadConL
1368 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1368    sd  R28, [R23, #288]	# ptr, #@storeP
136c +  sd  R7, [R10]	# long, #@storeL
1370 +  mv  R7, narrowklass: precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d0a1cd70:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1380 +  sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
1384 +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
1388 +  sw  zr, [R10, #12]	# int, #@storeimmI0
138c +  ClearArray #2, R28	#@clearArray_imm_reg

1394    B222: #	out( B525 B223 ) &lt;- in( B320 B221 )  Freq: 0.0137339
1394    
1394    MEMBAR-store-store	#@membar_storestore
1398 +  spill R10 -&gt; R8	# spill size = 64
139c +  # checkcastPP of R8, #@checkCastPP
139c    mv  R12, java/nio/file/FileTreeWalker$EventType:exact *	# ptr, #@loadConP
13b4    spill R8 -&gt; R11	# spill size = 64
13b8 +  spill [sp, #24] -&gt; R13	# spill size = 64
13bc +  spill [sp, #32] -&gt; R14	# spill size = 64
13c0 +  mv  R15, NULL	# NULL ptr, #@loadConP0
13c4    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeWalker$Event::&lt;init&gt;
        # java.nio.file.FileTreeWalker$Event::&lt;init&gt; @ bci:5 (line 141) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.nio.file.FileTreeWalker::visit @ bci:200 (line 312) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=R8
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [56]=Oop off=5064/0x13c8}

13c8    B223: #	out( B149 ) &lt;- in( B222 )  Freq: 0.0137336
        # Block is sole successor of call
13c8 +  spill R8 -&gt; [sp, #0]	# spill size = 64
13cc +  j  B149	#@branch

13d0    B224: #	out( B123 ) &lt;- in( B118 )  Freq: 0.0134984
13d0 +  spill R14 -&gt; R8	# spill size = 64
13d4 +  spill R11 -&gt; [sp, #4]	# spill size = 32
13d8 +  spill R28 -&gt; [sp, #0]	# spill size = 32
13dc +  j  B123	#@branch

13e0    B225: #	out( B40 B226 ) &lt;- in( B39 )  Freq: 0.000526522
13e0 +  lwu  R7, [R12, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
13e4 +  decode_heap_oop  R10, R7	#@decodeHeapOop
13e8 +  far_beq   R10, zr, B40	#@far_cmpP_imm0_branch  P=0.500000 C=-1.000000

13f0    B226: #	out( B354 B227 ) &lt;- in( B225 )  Freq: 0.000263261
13f0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
13f0    ld  R7, [R23, #32]	# int, #@loadL
13f4 +  beq  R7, zr, B354	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

13f8    B227: #	out( B40 ) &lt;- in( B226 )  Freq: 0.000262998
13f8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
13f8    ld  R28, [R23, #48]	# ptr, #@loadP
13fc +  add R28, R28, R7	# ptr, #@addP_reg_reg
1400 +  addi  R7, R7, #-8	#@addL_reg_imm
1404 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1408 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1408    sd  R7, [R23, #32]	# long, #@storeL
140c +  j  B40	#@branch

1410    B228: #	out( B25 B229 ) &lt;- in( B24 )  Freq: 0.000499032
1410 +  lwu  R7, [R21, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
1414 +  decode_heap_oop  R10, R7	#@decodeHeapOop
1418 +  far_beq   R10, zr, B25	#@far_cmpP_imm0_branch  P=0.500000 C=-1.000000

1420    B229: #	out( B360 B230 ) &lt;- in( B228 )  Freq: 0.000249516
1420 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1420    ld  R7, [R23, #32]	# int, #@loadL
1424 +  beq  R7, zr, B360	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1428    B230: #	out( B25 ) &lt;- in( B229 )  Freq: 0.000249266
1428 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1428    ld  R28, [R23, #48]	# ptr, #@loadP
142c +  add R28, R28, R7	# ptr, #@addP_reg_reg
1430 +  addi  R7, R7, #-8	#@addL_reg_imm
1434 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1438 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1438    sd  R7, [R23, #32]	# long, #@storeL
143c +  j  B25	#@branch

1440    B231: #	out( B73 B232 ) &lt;- in( B72 )  Freq: 0.00049901
1440 +  lwu  R28, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
1444 +  decode_heap_oop  R10, R28	#@decodeHeapOop
1448 +  beq   R10, zr, B73	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

144c    B232: #	out( B361 B233 ) &lt;- in( B231 )  Freq: 0.000249505
144c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
144c    ld  R7, [R23, #32]	# int, #@loadL
1450 +  beq  R7, zr, B361	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1454    B233: #	out( B73 ) &lt;- in( B232 )  Freq: 0.000249256
1454 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1454    ld  R28, [R23, #48]	# ptr, #@loadP
1458 +  add R28, R28, R7	# ptr, #@addP_reg_reg
145c +  addi  R7, R7, #-8	#@addL_reg_imm
1460 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1464 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1464    sd  R7, [R23, #32]	# long, #@storeL
1468 +  j  B73	#@branch

146c    B234: #	out( B155 B235 ) &lt;- in( B153 )  Freq: 0.000498952
146c +  spill [sp, #8] -&gt; R18	# spill size = 64
1470 +  lwu  R7, [R18, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.next
1474 +  decode_heap_oop  R10, R7	#@decodeHeapOop
1478 +  beq   R10, zr, B155	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

147c    B235: #	out( B362 B236 ) &lt;- in( B234 )  Freq: 0.000249476
147c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
147c    ld  R7, [R23, #32]	# int, #@loadL
1480 +  beq  R7, zr, B362	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1484    B236: #	out( B155 ) &lt;- in( B235 )  Freq: 0.000249226
1484 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1484    ld  R28, [R23, #48]	# ptr, #@loadP
1488 +  add R28, R28, R7	# ptr, #@addP_reg_reg
148c +  addi  R7, R7, #-8	#@addL_reg_imm
1490 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1494 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1494    sd  R7, [R23, #32]	# long, #@storeL
1498 +  j  B155	#@branch

149c    B237: #	out( B27 B238 ) &lt;- in( B26 )  Freq: 0.000498539
149c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
149c    ld  R28, [R23, #64]	# int, #@loadL
14a0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
14a0    ld  R29, [R23, #80]	# ptr, #@loadP
14a4 +  #@membar_volatile
	fence iorw iorw
14a8 +  lb  R31, [R10]	# byte, #@loadB
14ac +  far_beq  R31, zr, B27	#@far_cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

14b4    B238: #	out( B240 B239 ) &lt;- in( B237 )  Freq: 0.00024927
14b4 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
14b8 +  bne  R28, zr, B240	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

14bc    B239: #	out( B27 ) &lt;- in( B238 )  Freq: 0.000124635
14bc +  spill R7 -&gt; R26	# spill size = 32
14c4    
14c4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
14c4    spill R23 -&gt; R11	# spill size = 64
14c8 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
14f8 +  spill R21 -&gt; R22	# spill size = 64
14fc +  spill R20 -&gt; R21	# spill size = 64
1500 +  spill R19 -&gt; R20	# spill size = 64
1504 +  spill R20 -&gt; R19	# spill size = 64
1508 +  spill R21 -&gt; R20	# spill size = 64
150c +  spill R22 -&gt; R21	# spill size = 64
1510 +  spill R26 -&gt; R7	# spill size = 32
1518 +  j  B27	#@branch

151c    B240: #	out( B27 ) &lt;- in( B238 )  Freq: 0.000124635
151c +  add R29, R29, R28	# ptr, #@addP_reg_reg
1520 +  addi  R28, R28, #-8	#@addL_reg_imm
1524 +  sd  R10, [R29, #-8]	# ptr, #@storeP
1528 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1528    sd  R28, [R23, #64]	# long, #@storeL
152c +  j  B27	#@branch

1530    B241: #	out( B245 B242 ) &lt;- in( B75 )  Freq: 0.000498019
1530 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1530    ld  R7, [R23, #64]	# int, #@loadL
1534 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1534    ld  R28, [R23, #80]	# ptr, #@loadP
1538 +  #@membar_volatile
	fence iorw iorw
153c +  lb  R29, [R10]	# byte, #@loadB
1540 +  beq  R29, zr, B245	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1544    B242: #	out( B244 B243 ) &lt;- in( B241 )  Freq: 0.00024901
1544 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1548 +  beq  R7, zr, B244	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

154c    B243: #	out( B245 ) &lt;- in( B242 )  Freq: 0.000124505
154c +  add R28, R28, R7	# ptr, #@addP_reg_reg
1550 +  addi  R7, R7, #-8	#@addL_reg_imm
1554 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1558 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1558    sd  R7, [R23, #64]	# long, #@storeL
155c +  j  B245	#@branch

1560    B244: #	out( B245 ) &lt;- in( B242 )  Freq: 0.000124505
1560 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1560    spill R23 -&gt; R11	# spill size = 64
1564 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 

1594    B245: #	out( B76 ) &lt;- in( B244 B243 B241 )  Freq: 0.000498019
1594    lwu  R9, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
1598 +  j  B76	#@branch

159c    B246: #	out( B62 ) &lt;- in( B60 )  Freq: 0.000484817
159c +  addi  R28, R26, #16	#@addL_reg_imm
15a0 +  srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
15a4 +  andi  R28, R28, #-8	#@andL_reg_imm
15a8 +  add R28, R24, R28	# ptr, #@addP_reg_reg
15ac +  sub  R29, R7, R29	#@subL_reg_reg
15b0    ClearArray R29, R28	#@clearArray_reg_reg
1608 +  spill R30 -&gt; [sp, #16]	# spill size = 64
160c    
160c    
160c +  spill R26 -&gt; R12	# spill size = 64
1610 +  CALL, runtime leaf nofp 0x000000401396cf00	#@CallLeafNoFPDirect arrayof_jbyte_disjoint_arraycopy
        No JVM State Info
        # 
1614 +  spill R21 -&gt; R8	# spill size = 64
1618 +  spill R18 -&gt; [sp, #0]	# spill size = 32
161c +  spill R9 -&gt; [sp, #4]	# spill size = 32
1620 +  spill R8 -&gt; R21	# spill size = 64
1624 +  spill [sp, #0] -&gt; R18	# spill size = 32
1628 +  spill [sp, #4] -&gt; R9	# spill size = 32
162c +  spill [sp, #16] -&gt; R30	# spill size = 64
1630 +  j  B62	#@branch

1634    B247: #	out( B81 B248 ) &lt;- in( B80 )  Freq: 0.000484266
1634 +  lwu  R28, [R19, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.nextEntry
1638 +  decode_heap_oop  R10, R28	#@decodeHeapOop
163c +  beq   R10, zr, B81	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1640    B248: #	out( B365 B249 ) &lt;- in( B247 )  Freq: 0.000242133
1640 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1640    ld  R7, [R23, #32]	# int, #@loadL
1644 +  beq  R7, zr, B365	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1648    B249: #	out( B81 ) &lt;- in( B248 )  Freq: 0.000241891
1648 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1648    ld  R28, [R23, #48]	# ptr, #@loadP
164c +  add R28, R28, R7	# ptr, #@addP_reg_reg
1650 +  addi  R7, R7, #-8	#@addL_reg_imm
1654 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1658 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1658    sd  R7, [R23, #32]	# long, #@storeL
165c +  j  B81	#@branch

1660    B250: #	out( B118 B251 ) &lt;- in( B117 )  Freq: 0.000484081
1660 +  lwu  R10, [R31, #16]	# loadN, compressed ptr, #@loadN
1664 +  decode_heap_oop  R10, R10	#@decodeHeapOop
1668 +  beq   R10, zr, B118	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

166c    B251: #	out( B367 B252 ) &lt;- in( B250 )  Freq: 0.000242041
166c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
166c    ld  R13, [R23, #32]	# int, #@loadL
1670 +  beq  R13, zr, B367	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1674    B252: #	out( B118 ) &lt;- in( B251 )  Freq: 0.000241799
1674 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1674    ld  R16, [R23, #48]	# ptr, #@loadP
1678 +  add R16, R16, R13	# ptr, #@addP_reg_reg
167c +  sd  R10, [R16, #-8]	# ptr, #@storeP
1680 +  addi  R10, R13, #-8	#@addL_reg_imm
1684 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1684    sd  R10, [R23, #32]	# long, #@storeL
1688 +  j  B118	#@branch

168c    B253: #	out( B135 B254 ) &lt;- in( B134 )  Freq: 0.000484068
168c +  lwu  R7, [R9]	# loadN, compressed ptr, #@loadN
1690 +  decode_heap_oop  R10, R7	#@decodeHeapOop
1694 +  beq   R10, zr, B135	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1698    B254: #	out( B369 B255 ) &lt;- in( B253 )  Freq: 0.000242034
1698 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1698    ld  R7, [R23, #32]	# int, #@loadL
169c +  beq  R7, zr, B369	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

16a0    B255: #	out( B135 ) &lt;- in( B254 )  Freq: 0.000241792
16a0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16a0    ld  R28, [R23, #48]	# ptr, #@loadP
16a4 +  add R28, R28, R7	# ptr, #@addP_reg_reg
16a8 +  addi  R7, R7, #-8	#@addL_reg_imm
16ac +  sd  R10, [R28, #-8]	# ptr, #@storeP
16b0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16b0    sd  R7, [R23, #32]	# long, #@storeL
16b4 +  j  B135	#@branch

16b8    B256: #	out( B137 B257 ) &lt;- in( B136 )  Freq: 0.00048359
16b8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16b8    ld  R7, [R23, #64]	# int, #@loadL
16bc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16bc    ld  R28, [R23, #80]	# ptr, #@loadP
16c0 +  #@membar_volatile
	fence iorw iorw
16c4 +  lb  R30, [R10]	# byte, #@loadB
16c8 +  beq  R30, zr, B137	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

16cc    B257: #	out( B259 B258 ) &lt;- in( B256 )  Freq: 0.000241795
16cc +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
16d0 +  bne  R7, zr, B259	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

16d4    B258: #	out( B137 ) &lt;- in( B257 )  Freq: 0.000120898
16d4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
16d4    spill R23 -&gt; R11	# spill size = 64
16d8 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1708 +  j  B137	#@branch

170c    B259: #	out( B137 ) &lt;- in( B257 )  Freq: 0.000120898
170c +  add R28, R28, R7	# ptr, #@addP_reg_reg
1710 +  addi  R7, R7, #-8	#@addL_reg_imm
1714 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1718 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1718    sd  R7, [R23, #64]	# long, #@storeL
171c +  j  B137	#@branch

1720    B260: #	out( B120 B261 ) &lt;- in( B119 )  Freq: 0.000470583
1720 +  lwu  R7, [R21, #28]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/NativeBuffer.owner
1724 +  decode_heap_oop  R10, R7	#@decodeHeapOop
1728 +  beq   R10, zr, B120	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

172c    B261: #	out( B373 B262 ) &lt;- in( B260 )  Freq: 0.000235292
172c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
172c    ld  R7, [R23, #32]	# int, #@loadL
1730 +  beq  R7, zr, B373	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1734    B262: #	out( B120 ) &lt;- in( B261 )  Freq: 0.000235056
1734 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1734    ld  R28, [R23, #48]	# ptr, #@loadP
1738 +  add R28, R28, R7	# ptr, #@addP_reg_reg
173c +  addi  R7, R7, #-8	#@addL_reg_imm
1740 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1744 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1744    sd  R7, [R23, #32]	# long, #@storeL
1748 +  j  B120	#@branch

174c    B263: #	out( B267 B264 ) &lt;- in( B121 )  Freq: 0.000470119
174c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
174c    ld  R28, [R23, #64]	# int, #@loadL
1750 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1750    ld  R29, [R23, #80]	# ptr, #@loadP
1754 +  #@membar_volatile
	fence iorw iorw
1758 +  lb  R31, [R10]	# byte, #@loadB
175c +  beq  R31, zr, B267	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1760    B264: #	out( B266 B265 ) &lt;- in( B263 )  Freq: 0.000235059
1760 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1764 +  beq  R28, zr, B266	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1768    B265: #	out( B267 ) &lt;- in( B264 )  Freq: 0.00011753
1768 +  add R29, R29, R28	# ptr, #@addP_reg_reg
176c +  addi  R28, R28, #-8	#@addL_reg_imm
1770 +  sd  R10, [R29, #-8]	# ptr, #@storeP
1774 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1774    sd  R28, [R23, #64]	# long, #@storeL
1778 +  j  B267	#@branch

177c    B266: #	out( B267 ) &lt;- in( B264 )  Freq: 0.00011753
177c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
177c    spill R23 -&gt; R11	# spill size = 64
1780 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
17b0 +  spill R18 -&gt; R7	# spill size = 64

17b4    B267: #	out( B122 ) &lt;- in( B266 B265 B263 )  Freq: 0.000470119
17b4 +  ld  R24, [R21, #16]	# int, #@loadL ! Field: sun/nio/fs/NativeBuffer.address
17b8 +  j  B122	#@branch

17bc    B268: #	out( B461 B269 ) &lt;- in( B101 )  Freq: 0.000175728
17bc +  spill R11 -&gt; [sp, #4]	# spill size = 32
17c0 +  spill R30 -&gt; [sp, #40]	# spill size = 64
17c4 +  spill R9 -&gt; [sp, #32]	# spill size = 32
17c8 +  spill R7 -&gt; [sp, #24]	# spill size = 64
17cc +  spill R29 -&gt; [sp, #16]	# spill size = 64
17d0 +  spill R7 -&gt; R11	# spill size = 64
17d4 +  spill R30 -&gt; R12	# spill size = 64
17d8    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect sun.nio.fs.UnixNativeDispatcher::stat
        # sun.nio.fs.UnixFileAttributes::get @ bci:14 (line 70) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop off=6108/0x17dc}

17dc    B269: #	out( B137 ) &lt;- in( B268 )  Freq: 0.000175725
        # Block is sole successor of call
17dc +  j  B137	#@branch

17e0    B270: #	out( B505 B271 ) &lt;- in( B56 B57 )  Freq: 4.8981e-05
17e0 +  spill R26 -&gt; [sp, #96]	# spill size = 64
17e4 +  spill R30 -&gt; [sp, #88]	# spill size = 64
17e8 +  spill R9 -&gt; [sp, #80]	# spill size = 32
17ec +  spill R18 -&gt; [sp, #28]	# spill size = 32
17f0 +  spill R28 -&gt; [sp, #64]	# spill size = 64
17f4 +  spill R21 -&gt; [sp, #40]	# spill size = 64
17f8 +  spill R25 -&gt; [sp, #32]	# spill size = 64
17fc +  spill R22 -&gt; [sp, #24]	# spill size = 32
1800 +  spill R20 -&gt; [sp, #16]	# spill size = 64
1804 +  mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
181c    spill R9 -&gt; R12	# spill size = 32
1820    CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::resolve @ bci:69 (line 369) L[0]=sp + #64 L[1]=sp + #16 L[2]=sp + #28 L[3]=sp + #24 L[4]=_
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #40 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [32]=Derived_oop_[16] [40]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=6180/0x1824}

1824    B271: #	out( B59 ) &lt;- in( B270 )  Freq: 4.898e-05
        # Block is sole successor of call
1824 +  spill [sp, #0] -&gt; R19	# spill size = 64
1828 +  spill [sp, #16] -&gt; R20	# spill size = 64
182c +  spill [sp, #24] -&gt; R22	# spill size = 32
1830 +  spill [sp, #32] -&gt; R25	# spill size = 64
1834 +  spill [sp, #40] -&gt; R21	# spill size = 64
1838 +  spill [sp, #64] -&gt; R28	# spill size = 64
183c +  spill [sp, #28] -&gt; R18	# spill size = 32
1840 +  spill [sp, #80] -&gt; R9	# spill size = 32
1844 +  spill [sp, #88] -&gt; R30	# spill size = 64
1848 +  spill [sp, #96] -&gt; R26	# spill size = 64
184c +  spill R10 -&gt; R24	# spill size = 64
1850 +  j  B59	#@branch

1854    B272: #	out( B506 B273 ) &lt;- in( B66 )  Freq: 4.84897e-05
1854 +  spill R24 -&gt; [sp, #16]	# spill size = 64
1858 +  spill R21 -&gt; R8	# spill size = 64
185c +  spill R19 -&gt; [sp, #0]	# spill size = 64
1860 +  mv  R11, precise klass sun/nio/fs/UnixPath: 0x00000040d09ebb90:Constant:exact *	# ptr, #@loadConP
1878    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixPath::resolve @ bci:35 (line 383) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #16
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [48]=Oop [56]=Oop [72]=Oop off=6268/0x187c}

187c    B273: #	out( B68 ) &lt;- in( B272 )  Freq: 4.84887e-05
        # Block is sole successor of call
187c +  spill [sp, #0] -&gt; R19	# spill size = 64
1880 +  spill R8 -&gt; R21	# spill size = 64
1884 +  spill [sp, #16] -&gt; R24	# spill size = 64
1888 +  spill R10 -&gt; R18	# spill size = 64
188c +  j  B68	#@branch

1890    B274: #	out( B460 B275 ) &lt;- in( B99 )  Freq: 4.84349e-05
1890 +  spill R9 -&gt; [sp, #32]	# spill size = 32
1894 +  spill R7 -&gt; [sp, #24]	# spill size = 64
1898 +  spill R29 -&gt; [sp, #16]	# spill size = 64
189c +  mv  R11, precise klass sun/nio/fs/UnixFileAttributes: 0x00000040d0457d30:Constant:exact *	# ptr, #@loadConP
18b4    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixFileAttributes::get @ bci:0 (line 68) L[0]=sp + #24 L[1]=sp + #32 L[2]=_
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [56]=Oop [72]=Oop off=6328/0x18b8}

18b8    B275: #	out( B101 ) &lt;- in( B274 )  Freq: 4.84339e-05
        # Block is sole successor of call
18b8 +  spill [sp, #16] -&gt; R29	# spill size = 64
18bc +  spill [sp, #24] -&gt; R7	# spill size = 64
18c0 +  spill [sp, #32] -&gt; R9	# spill size = 32
18c4 +  j  B101	#@branch

18c8    B276: #	out( B449 B277 ) &lt;- in( B137 )  Freq: 4.8433e-05
18c8 +  mv  R11, precise klass sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes: 0x00000040d81f84d0:Constant:exact *	# ptr, #@loadConP
18e0    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes::wrap @ bci:0 (line 274) L[0]=sp + #40
        # sun.nio.fs.UnixFileAttributes::asBasicFileAttributes @ bci:1 (line 251) L[0]=_
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:20 (line 53) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop off=6372/0x18e4}

18e4    B277: #	out( B139 ) &lt;- in( B276 )  Freq: 4.84321e-05
        # Block is sole successor of call
18e4 +  j  B139	#@branch

18e8    B278: #	out( B524 B279 ) &lt;- in( B145 )  Freq: 4.70591e-05
18e8 +  spill R30 -&gt; [sp, #0]	# spill size = 64
18ec +  mv  R11, precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d0a1cd70:Constant:exact *	# ptr, #@loadConP
1904    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.nio.file.FileTreeWalker::visit @ bci:66 (line 289) L[0]=_ L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop [56]=Oop off=6408/0x1908}

1908    B279: #	out( B147 ) &lt;- in( B278 )  Freq: 4.70582e-05
        # Block is sole successor of call
1908 +  spill [sp, #16] -&gt; R31	# spill size = 64
190c +  spill [sp, #0] -&gt; R30	# spill size = 64
1910 +  j  B147	#@branch

1914    B280: #	out( B178 B281 ) &lt;- in( B177 )  Freq: 2.74946e-05
1914 +  lwu  R7, [R29, #40]	# loadN, compressed ptr, #@loadN ! Field: java/util/concurrent/locks/ReentrantReadWriteLock$Sync.firstReader
1918 +  decode_heap_oop  R10, R7	#@decodeHeapOop
191c +  beq   R10, zr, B178	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1920    B281: #	out( B388 B282 ) &lt;- in( B280 )  Freq: 1.37473e-05
1920 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1920    ld  R7, [R23, #32]	# int, #@loadL
1924 +  far_beq  R7, zr, B388	#@far_cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

192c    B282: #	out( B178 ) &lt;- in( B281 )  Freq: 1.37335e-05
192c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
192c    ld  R28, [R23, #48]	# ptr, #@loadP
1930 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1934 +  addi  R7, R7, #-8	#@addL_reg_imm
1938 +  sd  R10, [R28, #-8]	# ptr, #@storeP
193c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
193c    sd  R7, [R23, #32]	# long, #@storeL
1940 +  j  B178	#@branch

1944    B283: #	out( B180 B284 ) &lt;- in( B179 )  Freq: 2.74674e-05
1944 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1944    ld  R28, [R23, #64]	# int, #@loadL
1948 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1948    ld  R30, [R23, #80]	# ptr, #@loadP
194c +  #@membar_volatile
	fence iorw iorw
1950 +  lb  R31, [R10]	# byte, #@loadB
1954 +  beq  R31, zr, B180	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1958    B284: #	out( B286 B285 ) &lt;- in( B283 )  Freq: 1.37337e-05
1958 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
195c +  bne  R28, zr, B286	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1960    B285: #	out( B180 ) &lt;- in( B284 )  Freq: 6.86686e-06
1960 +  spill R29 -&gt; R21	# spill size = 64
1964    
1964    
1964 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1964    spill R23 -&gt; R11	# spill size = 64
1968 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1998 +  spill [sp, #24] -&gt; R7	# spill size = 32
199c +  spill R21 -&gt; R29	# spill size = 64
19a0 +  j  B180	#@branch

19a4    B286: #	out( B180 ) &lt;- in( B284 )  Freq: 6.86686e-06
19a4 +  add R30, R30, R28	# ptr, #@addP_reg_reg
19a8 +  addi  R28, R28, #-8	#@addL_reg_imm
19ac +  sd  R10, [R30, #-8]	# ptr, #@storeP
19b0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
19b0    sd  R28, [R23, #64]	# long, #@storeL
19b4 +  j  B180	#@branch

19b8    B287: #	out( B205 B288 ) &lt;- in( B204 )  Freq: 1.37343e-05
19b8 +  lwu  R28, [R20, #20]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.key
19bc +  decode_heap_oop  R10, R28	#@decodeHeapOop
19c0 +  beq   R10, zr, B205	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

19c4    B288: #	out( B394 B289 ) &lt;- in( B287 )  Freq: 6.86715e-06
19c4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
19c4    ld  R7, [R23, #32]	# int, #@loadL
19c8 +  far_beq  R7, zr, B394	#@far_cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

19d0    B289: #	out( B205 ) &lt;- in( B288 )  Freq: 6.86028e-06
19d0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
19d0    ld  R28, [R23, #48]	# ptr, #@loadP
19d4 +  add R28, R28, R7	# ptr, #@addP_reg_reg
19d8 +  addi  R7, R7, #-8	#@addL_reg_imm
19dc +  sd  R10, [R28, #-8]	# ptr, #@storeP
19e0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
19e0    sd  R7, [R23, #32]	# long, #@storeL
19e4 +  j  B205	#@branch

19e8    B290: #	out( B209 B291 ) &lt;- in( B208 )  Freq: 1.37343e-05
19e8 +  lwu  R28, [R20, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.stream
19ec +  decode_heap_oop  R10, R28	#@decodeHeapOop
19f0 +  beq   R10, zr, B209	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

19f4    B291: #	out( B395 B292 ) &lt;- in( B290 )  Freq: 6.86715e-06
19f4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
19f4    ld  R7, [R23, #32]	# int, #@loadL
19f8 +  far_beq  R7, zr, B395	#@far_cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1a00    B292: #	out( B209 ) &lt;- in( B291 )  Freq: 6.86028e-06
1a00 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a00    ld  R28, [R23, #48]	# ptr, #@loadP
1a04 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1a08 +  addi  R7, R7, #-8	#@addL_reg_imm
1a0c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1a10 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a10    sd  R7, [R23, #32]	# long, #@storeL
1a14 +  j  B209	#@branch

1a18    B293: #	out( B202 B294 ) &lt;- in( B200 )  Freq: 1.37343e-05
1a18 +  spill [sp, #48] -&gt; R20	# spill size = 64
1a1c +  lwu  R28, [R20, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.dir
1a20 +  decode_heap_oop  R10, R28	#@decodeHeapOop
1a24 +  beq   R10, zr, B202	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1a28    B294: #	out( B393 B295 ) &lt;- in( B293 )  Freq: 6.86715e-06
1a28 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a28    ld  R7, [R23, #32]	# int, #@loadL
1a2c +  beq  R7, zr, B393	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1a30    B295: #	out( B202 ) &lt;- in( B294 )  Freq: 6.86028e-06
1a30 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a30    ld  R28, [R23, #48]	# ptr, #@loadP
1a34 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1a38 +  addi  R7, R7, #-8	#@addL_reg_imm
1a3c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1a40 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a40    sd  R7, [R23, #32]	# long, #@storeL
1a44 +  j  B202	#@branch

1a48    B296: #	out( B215 B297 ) &lt;- in( B213 )  Freq: 1.3734e-05
1a48 +  spill R8 -&gt; R18	# spill size = 64
1a4c +  lwu  R7, [R18, #28]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$DirectoryNode.iterator
1a50 +  decode_heap_oop  R10, R7	#@decodeHeapOop
1a54 +  beq   R10, zr, B215	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1a58    B297: #	out( B396 B298 ) &lt;- in( B296 )  Freq: 6.86701e-06
1a58 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a58    ld  R7, [R23, #32]	# int, #@loadL
1a5c +  far_beq  R7, zr, B396	#@far_cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1a64    B298: #	out( B215 ) &lt;- in( B297 )  Freq: 6.86015e-06
1a64 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a64    ld  R28, [R23, #48]	# ptr, #@loadP
1a68 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1a6c +  addi  R7, R7, #-8	#@addL_reg_imm
1a70 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1a74 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a74    sd  R7, [R23, #32]	# long, #@storeL
1a78 +  j  B215	#@branch

1a7c    B299: #	out( B204 B300 ) &lt;- in( B203 )  Freq: 1.37207e-05
1a7c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a7c    ld  R7, [R23, #64]	# int, #@loadL
1a80 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a80    ld  R28, [R23, #80]	# ptr, #@loadP
1a84 +  #@membar_volatile
	fence iorw iorw
1a88 +  lb  R29, [R10]	# byte, #@loadB
1a8c +  beq  R29, zr, B204	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1a90    B300: #	out( B302 B301 ) &lt;- in( B299 )  Freq: 6.86037e-06
1a90 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1a94 +  bne  R7, zr, B302	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1a98    B301: #	out( B204 ) &lt;- in( B300 )  Freq: 3.43019e-06
1a98 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a98    spill R23 -&gt; R11	# spill size = 64
1a9c +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1acc +  j  B204	#@branch

1ad0    B302: #	out( B204 ) &lt;- in( B300 )  Freq: 3.43019e-06
1ad0 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1ad4 +  addi  R7, R7, #-8	#@addL_reg_imm
1ad8 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1adc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1adc    sd  R7, [R23, #64]	# long, #@storeL
1ae0 +  j  B204	#@branch

1ae4    B303: #	out( B208 B304 ) &lt;- in( B207 )  Freq: 1.3707e-05
1ae4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ae4    ld  R7, [R23, #64]	# int, #@loadL
1ae8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ae8    ld  R28, [R23, #80]	# ptr, #@loadP
1aec +  #@membar_volatile
	fence iorw iorw
1af0 +  lb  R29, [R10]	# byte, #@loadB
1af4 +  beq  R29, zr, B208	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1af8    B304: #	out( B306 B305 ) &lt;- in( B303 )  Freq: 6.85351e-06
1af8 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1afc +  bne  R7, zr, B306	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1b00    B305: #	out( B208 ) &lt;- in( B304 )  Freq: 3.42676e-06
1b00 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b00    spill R23 -&gt; R11	# spill size = 64
1b04 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1b34 +  j  B208	#@branch

1b38    B306: #	out( B208 ) &lt;- in( B304 )  Freq: 3.42676e-06
1b38 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1b3c +  addi  R7, R7, #-8	#@addL_reg_imm
1b40 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1b44 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b44    sd  R7, [R23, #64]	# long, #@storeL
1b48 +  j  B208	#@branch

1b4c    B307: #	out( B212 B308 ) &lt;- in( B211 )  Freq: 1.3707e-05
1b4c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b4c    ld  R7, [R23, #64]	# int, #@loadL
1b50 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b50    ld  R28, [R23, #80]	# ptr, #@loadP
1b54 +  #@membar_volatile
	fence iorw iorw
1b58 +  lb  R29, [R10]	# byte, #@loadB
1b5c +  beq  R29, zr, B212	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1b60    B308: #	out( B310 B309 ) &lt;- in( B307 )  Freq: 6.85351e-06
1b60 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1b64 +  bne  R7, zr, B310	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1b68    B309: #	out( B212 ) &lt;- in( B308 )  Freq: 3.42676e-06
1b68 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b68    spill R23 -&gt; R11	# spill size = 64
1b6c +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1b9c +  j  B212	#@branch

1ba0    B310: #	out( B212 ) &lt;- in( B308 )  Freq: 3.42676e-06
1ba0 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1ba4 +  addi  R7, R7, #-8	#@addL_reg_imm
1ba8 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1bac +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1bac    sd  R7, [R23, #64]	# long, #@storeL
1bb0 +  j  B212	#@branch

1bb4    B311: #	out( B218 B312 ) &lt;- in( B217 )  Freq: 1.37068e-05
1bb4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1bb4    ld  R7, [R23, #64]	# int, #@loadL
1bb8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1bb8    ld  R28, [R23, #80]	# ptr, #@loadP
1bbc +  #@membar_volatile
	fence iorw iorw
1bc0 +  lb  R29, [R10]	# byte, #@loadB
1bc4 +  beq  R29, zr, B218	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1bc8    B312: #	out( B314 B313 ) &lt;- in( B311 )  Freq: 6.85338e-06
1bc8 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1bcc +  bne  R7, zr, B314	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1bd0    B313: #	out( B218 ) &lt;- in( B312 )  Freq: 3.42669e-06
1bd0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1bd0    spill R23 -&gt; R11	# spill size = 64
1bd4 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1c04 +  j  B218	#@branch

1c08    B314: #	out( B218 ) &lt;- in( B312 )  Freq: 3.42669e-06
1c08 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1c0c +  addi  R7, R7, #-8	#@addL_reg_imm
1c10 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1c14 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1c14    sd  R7, [R23, #64]	# long, #@storeL
1c18 +  j  B218	#@branch

1c1c    B315: #	out( B522 B316 ) &lt;- in( B190 )  Freq: 1.47459e-06
1c1c +  mv  R11, precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d0a1cd70:Constant:exact *	# ptr, #@loadConP
1c34    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.nio.file.FileTreeWalker::next @ bci:113 (line 370) L[0]=_ L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop off=7224/0x1c38}

1c38    B316: #	out( B192 ) &lt;- in( B315 )  Freq: 1.47456e-06
        # Block is sole successor of call
1c38 +  j  B192	#@branch

1c3c    B317: #	out( B521 B318 ) &lt;- in( B197 )  Freq: 1.3737e-06
1c3c +  spill R31 -&gt; [sp, #40]	# spill size = 64
1c40 +  mv  R11, precise klass java/nio/file/FileTreeWalker$DirectoryNode: 0x00000040d09f6eb0:Constant:exact *	# ptr, #@loadConP
1c58    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.nio.file.FileTreeWalker::visit @ bci:170 (line 311) L[0]=_ L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=R8 L[7]=_ STK[0]=sp + #40
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [4]=NarrowOop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop off=7260/0x1c5c}

1c5c    B318: #	out( B199 ) &lt;- in( B317 )  Freq: 1.37368e-06
        # Block is sole successor of call
1c5c +  j  B199	#@branch

1c60    B319: #	out( B520 B320 ) &lt;- in( B220 )  Freq: 1.37362e-06
1c60 +  mv  R11, precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d0a1cd70:Constant:exact *	# ptr, #@loadConP
1c78    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.nio.file.FileTreeWalker::visit @ bci:190 (line 312) L[0]=_ L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [32]=Oop [56]=Oop off=7292/0x1c7c}

1c7c    B320: #	out( B222 ) &lt;- in( B319 )  Freq: 1.37359e-06
        # Block is sole successor of call
1c7c +  j  B222	#@branch

1c80    B321: #	out( N6569 ) &lt;- in( B35 )  Freq: 5.2653e-07
1c80 +  spill [sp, #8] -&gt; R7	# spill size = 64
1c84 +  li R11, #-34	# int, #@loadConI
1c88    spill R7 -&gt; [sp, #0]	# spill size = 64
1c8c +  spill R29 -&gt; [sp, #16]	# spill size = 64
1c90 +  spill R29 -&gt; [sp, #24]	# spill size = 64
1c94    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #16 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [64]=Oop off=7320/0x1c98}
1c98    #@ShouldNotReachHere

1ca4    B322: #	out( N6569 ) &lt;- in( B42 )  Freq: 5.26528e-07
1ca4 +  spill [sp, #8] -&gt; R7	# spill size = 64
1ca8 +  li R11, #-20	# int, #@loadConI
1cac    spill R7 -&gt; [sp, #0]	# spill size = 64
1cb0 +  spill R29 -&gt; [sp, #16]	# spill size = 64
1cb4 +  spill R29 -&gt; [sp, #24]	# spill size = 64
1cb8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_assert&apos; action=&apos;make_not_entrant&apos;)
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:12 (line 1095) L[0]=_ L[1]=_ STK[0]=R8
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #16 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [64]=Oop off=7356/0x1cbc}
1cbc    #@ShouldNotReachHere

1cc8    B323: #	out( N6569 ) &lt;- in( B151 )  Freq: 5.14216e-07
1cc8 +  spill [sp, #8] -&gt; R8	# spill size = 64
1ccc +  li R11, #-20	# int, #@loadConI
1cd0    spill R10 -&gt; [sp, #8]	# spill size = 64
1cd4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_assert&apos; action=&apos;make_not_entrant&apos;)
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:23 (line 85) L[0]=R8 L[1]=sp + #0 L[2]=_ STK[0]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=7384/0x1cd8}
1cd8    #@ShouldNotReachHere

1ce4    B324: #	out( N6569 ) &lt;- in( B45 )  Freq: 5.12316e-07
1ce4 +  li R11, #-25	# int, #@loadConI
1ce8    spill [sp, #8] -&gt; R8	# spill size = 64
1cec    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;none&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::isSelfOrParent @ bci:2 (line 145) L[0]=_ L[1]=_ STK[0]=sp + #64 STK[1]=#0
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:123 (line 181) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop off=7408/0x1cf0}
1cf0    #@ShouldNotReachHere

1cfc    B325: #	out( N6569 ) &lt;- in( B5 )  Freq: 5.06178e-07
1cfc +  li R11, #-28	# int, #@loadConI
1d00    spill R9 -&gt; [sp, #0]	# spill size = 64
1d04 +  spill R18 -&gt; [sp, #8]	# spill size = 64
1d08 +  spill R30 -&gt; [sp, #16]	# spill size = 32
1d0c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ArrayDeque::elementAt @ bci:2 (line 259) L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #16
        # java.util.ArrayDeque::peekFirst @ bci:8 (line 418) L[0]=_
        # java.util.ArrayDeque::peek @ bci:1 (line 564) L[0]=_
        # java.nio.file.FileTreeWalker::next @ bci:4 (line 335) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=7440/0x1d10}
1d10    #@ShouldNotReachHere

1d1c    B326: #	out( N6569 ) &lt;- in( B10 )  Freq: 4.99043e-07
1d1c +  li R11, #-34	# int, #@loadConI
1d20    spill R9 -&gt; R8	# spill size = 64
1d24 +  spill R19 -&gt; [sp, #8]	# spill size = 64
1d28 +  spill R18 -&gt; [sp, #16]	# spill size = 64
1d2c +  spill R24 -&gt; [sp, #24]	# spill size = 64
1d30    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_ STK[0]=sp + #8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop off=7476/0x1d34}
1d34    #@ShouldNotReachHere

1d40    B327: #	out( B12 ) &lt;- in( B11 )  Freq: 4.99043e-07
1d40 +  spill R20 -&gt; [sp, #24]	# spill size = 64
1d44    
1d44    
1d44 +  spill R11 -&gt; R8	# spill size = 64
1d48 +  spill R19 -&gt; [sp, #16]	# spill size = 64
1d4c +  spill R19 -&gt; R11	# spill size = 64
1d50    
1d50    
1d50 +  spill R18 -&gt; [sp, #0]	# spill size = 64
1d54    
1d54    
1d54 +  spill R24 -&gt; [sp, #8]	# spill size = 64
1d58    
1d58    
1d58    add R12, sp, #144	# box lock
1d5c +  CALL,static 0x000000401390c140	#@CallStaticJavaDirect wrapper for: _complete_monitor_locking_Java
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:-1 (line 197) L[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=7520/0x1d60}
1d60 +  spill R8 -&gt; R9	# spill size = 64
1d64 +  spill [sp, #0] -&gt; R18	# spill size = 64
1d68 +  spill [sp, #8] -&gt; R24	# spill size = 64
1d6c +  spill [sp, #16] -&gt; R19	# spill size = 64
1d70 +  spill [sp, #24] -&gt; R20	# spill size = 64
1d74 +  j  B12	#@branch

1d78    B328: #	out( N6569 ) &lt;- in( B17 )  Freq: 4.99041e-07
1d78 +  li R11, #-34	# int, #@loadConI
1d7c    spill R9 -&gt; [sp, #0]	# spill size = 64
1d80 +  spill R19 -&gt; [sp, #16]	# spill size = 64
1d84 +  spill R19 -&gt; [sp, #24]	# spill size = 64
1d88 +  spill R18 -&gt; [sp, #48]	# spill size = 64
1d8c +  spill R24 -&gt; [sp, #56]	# spill size = 64
1d90    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #16 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop off=7572/0x1d94}
1d94    #@ShouldNotReachHere

1da0    B329: #	out( N6569 ) &lt;- in( B20 )  Freq: 4.9904e-07
1da0 +  li R11, #-20	# int, #@loadConI
1da4    spill R9 -&gt; [sp, #0]	# spill size = 64
1da8 +  spill R19 -&gt; [sp, #16]	# spill size = 64
1dac +  spill R19 -&gt; [sp, #24]	# spill size = 64
1db0 +  spill R18 -&gt; [sp, #48]	# spill size = 64
1db4 +  spill R24 -&gt; [sp, #56]	# spill size = 64
1db8 +  spill R21 -&gt; [sp, #72]	# spill size = 64
1dbc +  spill R20 -&gt; [sp, #80]	# spill size = 64
1dc0 +  spill R29 -&gt; [sp, #88]	# spill size = 32
1dc4 +  spill R31 -&gt; [sp, #92]	# spill size = 32
1dc8 +  spill R21 -&gt; [sp, #96]	# spill size = 64
1dcc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_assert&apos; action=&apos;make_not_entrant&apos;)
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::hasQueuedPredecessors @ bci:6 (line 1234) L[0]=sp + #72 L[1]=#NULL L[2]=_ L[3]=_ STK[0]=R8
        # java.util.concurrent.locks.ReentrantReadWriteLock$FairSync::readerShouldBlock @ bci:1 (line 706) L[0]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:33 (line 475) L[0]=sp + #96 L[1]=_ L[2]=sp + #80 L[3]=sp + #88 L[4]=sp + #92 L[5]=_
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #72 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #16 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [72]=Oop [80]=Oop [96]=Oop off=7632/0x1dd0}
1dd0    #@ShouldNotReachHere

1ddc    B330: #	out( B77 ) &lt;- in( B76 )  Freq: 4.99017e-07
1ddc    add R11, sp, #144	# box lock
1de0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1de0    spill R23 -&gt; R12	# spill size = 64
1de4 +  spill R19 -&gt; R10	# spill size = 64
1de8 +  CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
1e18 +  j  B77	#@branch

1e1c    B331: #	out( B55 ) &lt;- in( B53 )  Freq: 4.91256e-07
1e1c +  addw  R29, R9, zr	#@convI2L_reg_reg
1e20 +  j  B55	#@branch

1e24    B332: #	out( N6569 ) &lt;- in( B62 )  Freq: 4.91255e-07
1e24 +  spill [sp, #8] -&gt; R8	# spill size = 64
1e28 +  li R11, #-26	# int, #@loadConI
1e2c    spill R19 -&gt; [sp, #8]	# spill size = 64
1e30 +  spill R19 -&gt; [sp, #16]	# spill size = 64
1e34 +  spill R24 -&gt; [sp, #40]	# spill size = 64
1e38 +  spill R18 -&gt; [sp, #64]	# spill size = 32
1e3c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:88 (line 371) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #40 STK[1]=sp + #64 STK[2]=#47
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop [56]=Oop off=7744/0x1e40}
1e40    #@ShouldNotReachHere

1e4c    B333: #	out( B334 ) &lt;- in( B83 )  Freq: 4.90703e-07
1e4c +  spill [sp, #48] -&gt; R29	# spill size = 64

1e50    B334: #	out( N6569 ) &lt;- in( B333 B84 )  Freq: 9.81406e-07
1e50 +  spill [sp, #8] -&gt; R8	# spill size = 64
1e54 +  li R11, #-187	# int, #@loadConI
1e58    spill R29 -&gt; [sp, #8]	# spill size = 64
1e5c +  spill R29 -&gt; [sp, #24]	# spill size = 64
1e60 +  spill R7 -&gt; [sp, #32]	# spill size = 64
1e64    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::getAttributes @ bci:8 (line 206) L[0]=sp + #8 L[1]=sp + #32 L[2]=_ L[3]=_ L[4]=_ STK[0]=#1
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [56]=Oop off=7784/0x1e68}
1e68    #@ShouldNotReachHere

1e74    B335: #	out( N6569 ) &lt;- in( B86 )  Freq: 4.90702e-07
1e74 +  li R11, #-10	# int, #@loadConI
1e78    spill [sp, #8] -&gt; R8	# spill size = 64
1e7c +  spill R14 -&gt; [sp, #0]	# spill size = 64
1e80 +  spill R29 -&gt; [sp, #16]	# spill size = 64
1e84 +  spill R29 -&gt; [sp, #32]	# spill size = 64
1e88 +  spill R7 -&gt; [sp, #40]	# spill size = 64
1e8c +  spill R7 -&gt; [sp, #48]	# spill size = 64
1e90    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL STK[1]=sp + #40 STK[2]=#Ptr0x00000040d81fcac0 STK[3]=sp + #0
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=7828/0x1e94}
1e94    #@ShouldNotReachHere

1ea0    B336: #	out( N6569 ) &lt;- in( B55 )  Freq: 4.84818e-07
1ea0 +  li R11, #-52	# int, #@loadConI
1ea4    spill [sp, #8] -&gt; R8	# spill size = 64
1ea8 +  spill R21 -&gt; [sp, #40]	# spill size = 64
1eac +  spill R28 -&gt; [sp, #64]	# spill size = 64
1eb0 +  spill R20 -&gt; [sp, #72]	# spill size = 64
1eb4 +  spill R18 -&gt; [sp, #80]	# spill size = 32
1eb8 +  spill R22 -&gt; [sp, #84]	# spill size = 32
1ebc +  spill R9 -&gt; [sp, #88]	# spill size = 32
1ec0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:69 (line 369) L[0]=sp + #64 L[1]=sp + #72 L[2]=sp + #80 L[3]=sp + #84 L[4]=_ STK[0]=sp + #88
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #40 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=7876/0x1ec4}
1ec4    #@ShouldNotReachHere

1ed0    B337: #	out( B62 ) &lt;- in( B59 )  Freq: 4.84817e-07
1ed0 +  spill R11 -&gt; R28	# spill size = 64
1ed4 +  addi  R29, R7, #-2	#@addL_reg_imm
1ed8    ClearArray R29, R28	#@clearArray_reg_reg
1f30    
1f30 +  j  B62	#@branch

1f34    B338: #	out( N6569 ) &lt;- in( B63 )  Freq: 4.84817e-07
1f34 +  spill [sp, #8] -&gt; R7	# spill size = 64
1f38 +  li R11, #-52	# int, #@loadConI
1f3c    spill R7 -&gt; [sp, #0]	# spill size = 64
1f40 +  spill R19 -&gt; [sp, #16]	# spill size = 64
1f44 +  spill R19 -&gt; [sp, #24]	# spill size = 64
1f48 +  spill R21 -&gt; [sp, #64]	# spill size = 64
1f4c +  spill R20 -&gt; [sp, #80]	# spill size = 64
1f50 +  spill R24 -&gt; [sp, #88]	# spill size = 64
1f54 +  spill R22 -&gt; [sp, #96]	# spill size = 32
1f58    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:97 (line 372) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #88 STK[0]=sp + #80 STK[1]=#0 STK[2]=sp + #88 STK[3]=R8 STK[4]=sp + #96
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #64 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [64]=Oop [80]=Oop [88]=Oop off=8028/0x1f5c}
1f5c    #@ShouldNotReachHere

1f68    B339: #	out( N6569 ) &lt;- in( B70 )  Freq: 4.84815e-07
1f68 +  spill [sp, #8] -&gt; R7	# spill size = 64
1f6c +  li R11, #-34	# int, #@loadConI
1f70    spill R7 -&gt; [sp, #0]	# spill size = 64
1f74 +  spill R19 -&gt; [sp, #16]	# spill size = 64
1f78 +  spill R19 -&gt; [sp, #24]	# spill size = 64
1f7c +  spill R18 -&gt; [sp, #72]	# spill size = 64
1f80    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:159 (line 186) L[0]=sp + #16 L[1]=_ L[2]=sp + #72 L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #72
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [72]=Oop off=8068/0x1f84}
1f84    #@ShouldNotReachHere

1f90    B340: #	out( B79 ) &lt;- in( B78 )  Freq: 4.84273e-07
1f90 +  spill R19 -&gt; R8	# spill size = 64
1f94 +  spill R19 -&gt; R11	# spill size = 64
1f98    
1f98    
1f98    add R12, sp, #144	# box lock
1f9c +  CALL,static 0x000000401390c140	#@CallStaticJavaDirect wrapper for: _complete_monitor_locking_Java
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::next @ bci:-1 (line 205) L[0]=R8 L[1]=_ MON-BOX0=sp+144 MON-OBJ[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::next @ bci:1 (line 132) L[0]=_
        # java.nio.file.FileTreeWalker::next @ bci:47 (line 350) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [48]=Oop [56]=Oop [72]=Oop off=8096/0x1fa0}
1fa0 +  spill R8 -&gt; R19	# spill size = 64
1fa4 +  j  B79	#@branch

1fa8    B341: #	out( B82 ) &lt;- in( B81 )  Freq: 4.84272e-07
1fa8    add R11, sp, #144	# box lock
1fac +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1fac    spill R23 -&gt; R12	# spill size = 64
1fb0 +  spill R19 -&gt; R10	# spill size = 64
1fb4 +  CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
1fe4 +  j  B82	#@branch

1fe8    B342: #	out( N6569 ) &lt;- in( B142 )  Freq: 4.84249e-07
1fe8 +  spill [sp, #8] -&gt; R8	# spill size = 64
1fec +  li R11, #-34	# int, #@loadConI
1ff0    spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
1ff8 +  spill R12 -&gt; [sp, #32]	# spill size = 64
1ffc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:58 (line 288) L[0]=sp + #8 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #32
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [56]=Oop off=8192/0x2000}
2000    #@ShouldNotReachHere

200c    B343: #	out( N6569 ) &lt;- in( B109 )  Freq: 4.8409e-07
200c +  spill [sp, #8] -&gt; R8	# spill size = 64
2010 +  li R11, #-26	# int, #@loadConI
2014    spill R29 -&gt; [sp, #8]	# spill size = 64
2018 +  spill R29 -&gt; [sp, #24]	# spill size = 64
201c +  spill R7 -&gt; [sp, #32]	# spill size = 64
2020 +  spill R30 -&gt; [sp, #48]	# spill size = 64
2024 +  spill R20 -&gt; [sp, #64]	# spill size = 64
2028 +  spill R13 -&gt; [sp, #72]	# spill size = 32
202c +  spill R9 -&gt; [sp, #76]	# spill size = 32
2030 +  spill R7 -&gt; [sp, #80]	# spill size = 64
2034    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:18 (line 435) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #64 STK[1]=sp + #72
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #76, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #80 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop [80]=Oop off=8248/0x2038}
2038    #@ShouldNotReachHere

2044    B344: #	out( N6569 ) &lt;- in( B111 )  Freq: 4.8409e-07
2044 +  spill [sp, #8] -&gt; R8	# spill size = 64
2048 +  li R11, #-187	# int, #@loadConI
204c    spill R29 -&gt; [sp, #8]	# spill size = 64
2050 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2054 +  spill R7 -&gt; [sp, #32]	# spill size = 64
2058 +  spill R30 -&gt; [sp, #48]	# spill size = 64
205c +  spill R7 -&gt; [sp, #64]	# spill size = 64
2060 +  spill R12 -&gt; [sp, #72]	# spill size = 64
2064 +  spill R18 -&gt; [sp, #84]	# spill size = 32
2068 +  spill R16 -&gt; [sp, #96]	# spill size = 64
206c +  spill R17 -&gt; [sp, #104]	# spill size = 64
2070 +  spill R13 -&gt; [sp, #112]	# spill size = 32
2074 +  spill R19 -&gt; [sp, #120]	# spill size = 64
2078 +  spill R9 -&gt; [sp, #116]	# spill size = 32
207c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:29 (line 436) L[0]=sp + #96 L[1]=sp + #104 L[2]=sp + #112 L[3]=sp + #120 STK[0]=#0
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #104 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #32 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #116, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop [96]=Oop [104]=Oop [120]=Oop off=8320/0x2080}
2080    #@ShouldNotReachHere

208c    B345: #	out( N6569 ) &lt;- in( B114 )  Freq: 4.84089e-07
208c +  spill [sp, #8] -&gt; R8	# spill size = 64
2090 +  li R11, #-26	# int, #@loadConI
2094    spill R29 -&gt; [sp, #8]	# spill size = 64
2098 +  spill R29 -&gt; [sp, #24]	# spill size = 64
209c +  spill R7 -&gt; [sp, #32]	# spill size = 64
20a0 +  spill R30 -&gt; [sp, #48]	# spill size = 64
20a4 +  spill R31 -&gt; [sp, #64]	# spill size = 64
20a8 +  spill R9 -&gt; [sp, #72]	# spill size = 32
20ac +  spill R7 -&gt; [sp, #80]	# spill size = 64
20b0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:23 (line 75) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #64 STK[1]=#0
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #72, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #80 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop [80]=Oop off=8372/0x20b4}
20b4    #@ShouldNotReachHere

20c0    B346: #	out( N6569 ) &lt;- in( B127 )  Freq: 4.84077e-07
20c0 +  spill [sp, #8] -&gt; R8	# spill size = 64
20c4 +  li R11, #-26	# int, #@loadConI
20c8    spill R12 -&gt; [sp, #0]	# spill size = 64
20cc +  spill R28 -&gt; [sp, #8]	# spill size = 32
20d0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:18 (line 435) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #0 STK[1]=sp + #8
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop off=8404/0x20d4}
20d4    #@ShouldNotReachHere

20e0    B347: #	out( N6569 ) &lt;- in( B129 )  Freq: 4.84076e-07
20e0 +  spill [sp, #8] -&gt; R8	# spill size = 64
20e4 +  li R11, #-187	# int, #@loadConI
20e8    spill R31 -&gt; [sp, #8]	# spill size = 64
20ec +  spill R30 -&gt; [sp, #64]	# spill size = 64
20f0 +  spill R28 -&gt; [sp, #36]	# spill size = 32
20f4 +  spill R29 -&gt; [sp, #72]	# spill size = 64
20f8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:29 (line 436) L[0]=sp + #8 L[1]=sp + #64 L[2]=sp + #36 L[3]=sp + #72 STK[0]=#0
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #64 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #48 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=8444/0x20fc}
20fc    #@ShouldNotReachHere

2108    B348: #	out( N6569 ) &lt;- in( B132 )  Freq: 4.84075e-07
2108 +  li R11, #-26	# int, #@loadConI
210c    spill [sp, #8] -&gt; R8	# spill size = 64
2110 +  spill R10 -&gt; [sp, #0]	# spill size = 64
2114    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:40 (line 115) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #0 STK[1]=#0
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop off=8472/0x2118}
2118    #@ShouldNotReachHere

2124    B349: #	out( N6569 ) &lt;- in( B92 )  Freq: 4.84005e-07
2124 +  decode_heap_oop  R8, R10	#@decodeHeapOop
2128    spill [sp, #8] -&gt; R30	# spill size = 64
212c +  li R11, #-187	# int, #@loadConI
2130    spill R30 -&gt; [sp, #0]	# spill size = 64
2134 +  spill R14 -&gt; [sp, #8]	# spill size = 64
2138 +  spill R13 -&gt; [sp, #16]	# spill size = 32
213c +  spill R29 -&gt; [sp, #32]	# spill size = 64
2140 +  spill R29 -&gt; [sp, #48]	# spill size = 64
2144 +  spill R7 -&gt; [sp, #64]	# spill size = 64
2148 +  spill R7 -&gt; [sp, #72]	# spill size = 64
214c +  spill R28 -&gt; [sp, #20]	# spill size = 32
2150    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.Util::followLinks @ bci:27 (line 122) L[0]=_ L[1]=_ L[2]=sp + #8 L[3]=sp + #20 L[4]=sp + #16 L[5]=R8 STK[0]=R8 STK[1]=#Ptr0x00000040d0453230
        # sun.nio.fs.UnixFileSystemProvider::getFileAttributeView @ bci:7 (line 120) L[0]=_ L[1]=_ L[2]=#Ptr0x00000040d8192f10 L[3]=_ L[4]=sp + #64 L[5]=_
        # sun.nio.fs.LinuxFileSystemProvider::getFileAttributeView @ bci:48 (line 68) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:51 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #32 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #48 L[1]=sp + #64 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #32 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=8532/0x2154}
2154    #@ShouldNotReachHere

2160    B350: #	out( N6569 ) &lt;- in( B29 )  Freq: 2.63272e-07
2160 +  li R11, #-187	# int, #@loadConI
2164    spill R9 -&gt; R8	# spill size = 64
2168 +  spill R19 -&gt; [sp, #8]	# spill size = 64
216c +  spill R19 -&gt; [sp, #16]	# spill size = 64
2170 +  spill R28 -&gt; [sp, #40]	# spill size = 32
2174 +  spill R18 -&gt; [sp, #48]	# spill size = 64
2178 +  spill R24 -&gt; [sp, #56]	# spill size = 64
217c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream::isOpen @ bci:4 (line 83) L[0]=_ STK[0]=sp + #40
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:39 (line 164) L[0]=sp + #8 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [48]=Oop [56]=Oop off=8576/0x2180}
2180    #@ShouldNotReachHere

218c    B351: #	out( N6569 ) &lt;- in( B37 )  Freq: 2.63265e-07
218c +  spill [sp, #8] -&gt; R7	# spill size = 64
2190 +  li R11, #-187	# int, #@loadConI
2194    spill R7 -&gt; [sp, #0]	# spill size = 64
2198 +  spill R29 -&gt; [sp, #16]	# spill size = 64
219c +  spill R29 -&gt; [sp, #24]	# spill size = 64
21a0 +  spill R12 -&gt; [sp, #80]	# spill size = 64
21a4 +  spill R30 -&gt; [sp, #96]	# spill size = 64
21a8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryReleaseShared @ bci:9 (line 417) L[0]=sp + #80 L[1]=_ L[2]=sp + #96 L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #96
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:2 (line 1094) L[0]=sp + #80 L[1]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #16 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [64]=Oop [80]=Oop [96]=Oop off=8620/0x21ac}
21ac    #@ShouldNotReachHere

21b8    B352: #	out( N6569 ) &lt;- in( B38 )  Freq: 2.63265e-07
21b8 +  li R11, #-187	# int, #@loadConI
21bc    spill [sp, #8] -&gt; R8	# spill size = 64
21c0 +  spill R12 -&gt; [sp, #72]	# spill size = 64
21c4 +  spill R10 -&gt; [sp, #80]	# spill size = 32
21c8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryReleaseShared @ bci:17 (line 419) L[0]=sp + #72 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #80 STK[1]=#1
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:2 (line 1094) L[0]=sp + #72 L[1]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=8652/0x21cc}
21cc    #@ShouldNotReachHere

21d8    B353: #	out( N6569 ) &lt;- in( B41 )  Freq: 2.63264e-07
21d8 +  spill [sp, #8] -&gt; R8	# spill size = 64
21dc +  li R11, #-187	# int, #@loadConI
21e0    spill R29 -&gt; [sp, #8]	# spill size = 64
21e4 +  spill R29 -&gt; [sp, #16]	# spill size = 64
21e8 +  spill R12 -&gt; [sp, #40]	# spill size = 64
21ec +  spill R10 -&gt; [sp, #72]	# spill size = 32
21f0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryReleaseShared @ bci:134 (line 443) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #72
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:2 (line 1094) L[0]=sp + #40 L[1]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop off=8692/0x21f4}
21f4    #@ShouldNotReachHere

2200    B354: #	out( B40 ) &lt;- in( B226 )  Freq: 2.63258e-07
2200 +  spill R12 -&gt; R19	# spill size = 64
2204    
2204    
2204 +  spill R29 -&gt; R9	# spill size = 64
2208    
2208    
2208 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2208    spill R23 -&gt; R11	# spill size = 64
220c +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
223c +  spill R9 -&gt; R29	# spill size = 64
2240 +  spill [sp, #16] -&gt; R30	# spill size = 64
2244 +  spill R19 -&gt; R12	# spill size = 64
2248 +  j  B40	#@branch

224c    B355: #	out( N6569 ) &lt;- in( B40 )  Freq: 2.51069e-07
224c +  spill [sp, #8] -&gt; R7	# spill size = 64
2250 +  li R11, #-187	# int, #@loadConI
2254    spill R7 -&gt; [sp, #0]	# spill size = 64
2258 +  spill R29 -&gt; [sp, #16]	# spill size = 64
225c +  spill R29 -&gt; [sp, #24]	# spill size = 64
2260 +  spill R12 -&gt; [sp, #80]	# spill size = 64
2264 +  spill R10 -&gt; [sp, #88]	# spill size = 32
2268    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryReleaseShared @ bci:129 (line 439) L[0]=sp + #80 L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #88 STK[0]=R8
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::releaseShared @ bci:2 (line 1094) L[0]=sp + #80 L[1]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #16 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [64]=Oop [80]=Oop off=8812/0x226c}
226c    #@ShouldNotReachHere

2278    B356: #	out( N6569 ) &lt;- in( B8 )  Freq: 2.49522e-07
2278 +  li R11, #-187	# int, #@loadConI
227c    spill R9 -&gt; [sp, #0]	# spill size = 64
2280 +  spill R18 -&gt; [sp, #8]	# spill size = 64
2284 +  spill R24 -&gt; [sp, #16]	# spill size = 64
2288    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:26 (line 346) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=_ L[6]=_ STK[0]=R8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=8844/0x228c}
228c    #@ShouldNotReachHere

2298    B357: #	out( N6569 ) &lt;- in( B12 )  Freq: 2.49521e-07
2298 +  li R11, #-187	# int, #@loadConI
229c    spill R9 -&gt; [sp, #0]	# spill size = 64
22a0 +  spill R19 -&gt; [sp, #16]	# spill size = 64
22a4 +  spill R19 -&gt; [sp, #24]	# spill size = 64
22a8 +  spill R18 -&gt; [sp, #32]	# spill size = 64
22ac +  spill R24 -&gt; [sp, #40]	# spill size = 64
22b0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:4 (line 197) L[0]=sp + #24 STK[0]=R8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #32 L[1]=sp + #40 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=8884/0x22b4}
22b4    #@ShouldNotReachHere

22c0    B358: #	out( N6569 ) &lt;- in( B13 )  Freq: 2.49521e-07
22c0 +  li R11, #-187	# int, #@loadConI
22c4    spill R9 -&gt; R8	# spill size = 64
22c8 +  spill R19 -&gt; [sp, #8]	# spill size = 64
22cc +  spill R19 -&gt; [sp, #16]	# spill size = 64
22d0 +  spill R18 -&gt; [sp, #24]	# spill size = 64
22d4 +  spill R24 -&gt; [sp, #32]	# spill size = 64
22d8 +  spill R28 -&gt; [sp, #40]	# spill size = 32
22dc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:11 (line 197) L[0]=sp + #16 STK[0]=sp + #40 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #24 L[1]=sp + #32 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop off=8928/0x22e0}
22e0    #@ShouldNotReachHere

22ec    B359: #	out( N6569 ) &lt;- in( B23 )  Freq: 2.49519e-07
22ec +  li R11, #-187	# int, #@loadConI
22f0    spill R9 -&gt; R8	# spill size = 64
22f4 +  spill R19 -&gt; [sp, #8]	# spill size = 64
22f8 +  spill R19 -&gt; [sp, #16]	# spill size = 64
22fc +  spill R18 -&gt; [sp, #40]	# spill size = 64
2300 +  spill R24 -&gt; [sp, #48]	# spill size = 64
2304 +  spill R21 -&gt; [sp, #64]	# spill size = 64
2308 +  spill R20 -&gt; [sp, #72]	# spill size = 64
230c +  spill R31 -&gt; [sp, #80]	# spill size = 32
2310    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:60 (line 478) L[0]=sp + #64 L[1]=_ L[2]=sp + #72 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #80
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #64 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #8 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #40 L[1]=sp + #48 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop [64]=Oop [72]=Oop off=8980/0x2314}
2314    #@ShouldNotReachHere

2320    B360: #	out( B25 ) &lt;- in( B229 )  Freq: 2.49513e-07
2320 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2320    spill R23 -&gt; R11	# spill size = 64
2324 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2354 +  j  B25	#@branch

2358    B361: #	out( B73 ) &lt;- in( B232 )  Freq: 2.49502e-07
2358 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2358    spill R23 -&gt; R11	# spill size = 64
235c +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
238c +  j  B73	#@branch

2390    B362: #	out( B155 ) &lt;- in( B235 )  Freq: 2.49473e-07
2390 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2390    spill R23 -&gt; R11	# spill size = 64
2394 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
23c4 +  j  B155	#@branch

23c8    B363: #	out( N6569 ) &lt;- in( B89 )  Freq: 2.45306e-07
23c8 +  li R11, #-138	# int, #@loadConI
23cc    spill [sp, #8] -&gt; R8	# spill size = 64
23d0 +  spill R14 -&gt; [sp, #0]	# spill size = 64
23d4 +  spill R29 -&gt; [sp, #16]	# spill size = 64
23d8 +  spill R29 -&gt; [sp, #32]	# spill size = 64
23dc +  spill R7 -&gt; [sp, #40]	# spill size = 64
23e0 +  spill R7 -&gt; [sp, #48]	# spill size = 64
23e4 +  spill R28 -&gt; [sp, #68]	# spill size = 32
23e8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.Util::followLinks @ bci:13 (line 121) L[0]=_ L[1]=#1 L[2]=sp + #0 L[3]=sp + #68 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=sp + #68
        # sun.nio.fs.UnixFileSystemProvider::getFileAttributeView @ bci:7 (line 120) L[0]=_ L[1]=_ L[2]=#Ptr0x00000040d8192f10 L[3]=_ L[4]=sp + #40 L[5]=_
        # sun.nio.fs.LinuxFileSystemProvider::getFileAttributeView @ bci:48 (line 68) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:51 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=9196/0x23ec}
23ec    #@ShouldNotReachHere

23f8    B364: #	out( N6569 ) &lt;- in( B51 )  Freq: 2.42409e-07
23f8 +  li R11, #-187	# int, #@loadConI
23fc    spill [sp, #8] -&gt; R8	# spill size = 64
2400 +  spill R21 -&gt; [sp, #40]	# spill size = 64
2404 +  spill R28 -&gt; [sp, #64]	# spill size = 64
2408 +  spill R20 -&gt; [sp, #72]	# spill size = 64
240c +  spill R22 -&gt; [sp, #84]	# spill size = 32
2410 +  spill R18 -&gt; [sp, #88]	# spill size = 32
2414    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 361) L[0]=sp + #64 L[1]=sp + #72 L[2]=sp + #88 L[3]=sp + #84 L[4]=_ STK[0]=sp + #88
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #40 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=9240/0x2418}
2418    #@ShouldNotReachHere

2424    B365: #	out( B81 ) &lt;- in( B248 )  Freq: 2.4213e-07
2424 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2424    spill R23 -&gt; R11	# spill size = 64
2428 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2458 +  j  B81	#@branch

245c    B366: #	out( N6569 ) &lt;- in( B116 )  Freq: 2.42044e-07
245c +  spill [sp, #8] -&gt; R28	# spill size = 64
2460 +  li R11, #-187	# int, #@loadConI
2464    spill R28 -&gt; [sp, #0]	# spill size = 64
2468 +  spill R29 -&gt; [sp, #16]	# spill size = 64
246c +  spill R29 -&gt; [sp, #32]	# spill size = 64
2470 +  spill R7 -&gt; [sp, #40]	# spill size = 64
2474 +  spill R30 -&gt; [sp, #64]	# spill size = 64
2478 +  spill R7 -&gt; [sp, #72]	# spill size = 64
247c +  spill R12 -&gt; [sp, #80]	# spill size = 64
2480 +  spill R18 -&gt; [sp, #92]	# spill size = 32
2484 +  spill R31 -&gt; [sp, #96]	# spill size = 64
2488 +  spill R21 -&gt; [sp, #104]	# spill size = 64
248c +  spill R18 -&gt; [sp, #112]	# spill size = 32
2490 +  spill R9 -&gt; [sp, #116]	# spill size = 32
2494    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:34 (line 76) L[0]=sp + #112 L[1]=sp + #96 L[2]=#0 L[3]=sp + #104 STK[0]=R8 STK[1]=sp + #92
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #40 L[1]=sp + #80 L[2]=sp + #92 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #64 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #64
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #116, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop [72]=Oop [80]=Oop [96]=Oop [104]=Oop off=9368/0x2498}
2498    #@ShouldNotReachHere

24a4    B367: #	out( B118 ) &lt;- in( B251 )  Freq: 2.42038e-07
24a4 +  spill R15 -&gt; R26	# spill size = 32
24a8    
24a8 +  spill R14 -&gt; R19	# spill size = 64
24ac    
24ac    
24ac +  spill R12 -&gt; R25	# spill size = 64
24b0    
24b0    
24b0 +  spill R31 -&gt; R8	# spill size = 64
24b4    
24b4    
24b4 +  spill R21 -&gt; [sp, #16]	# spill size = 64
24b8 +  spill R30 -&gt; R21	# spill size = 64
24bc    
24bc    
24bc +  spill R9 -&gt; R22	# spill size = 32
24c0 +  spill R29 -&gt; R9	# spill size = 64
24c4    
24c4    
24c4 +  spill R28 -&gt; [sp, #0]	# spill size = 32
24c8    
24c8 +  spill R7 -&gt; R20	# spill size = 64
24cc    
24cc    
24cc +  spill R11 -&gt; R24	# spill size = 32
24d4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
24d4    spill R23 -&gt; R11	# spill size = 64
24d8 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2508 +  spill R9 -&gt; R29	# spill size = 64
250c +  spill R21 -&gt; R30	# spill size = 64
2510 +  spill R19 -&gt; R14	# spill size = 64
2514 +  spill R20 -&gt; R7	# spill size = 64
2518 +  spill R22 -&gt; R9	# spill size = 32
251c +  spill R24 -&gt; R11	# spill size = 32
2524 +  spill R25 -&gt; R12	# spill size = 64
2528 +  spill R26 -&gt; R15	# spill size = 32
252c +  spill R8 -&gt; R31	# spill size = 64
2530 +  spill [sp, #0] -&gt; R28	# spill size = 32
2534 +  spill [sp, #16] -&gt; R21	# spill size = 64
2538 +  j  B118	#@branch

253c    B368: #	out( N6569 ) &lt;- in( B133 )  Freq: 2.42037e-07
253c +  spill [sp, #8] -&gt; R7	# spill size = 64
2540 +  li R11, #-187	# int, #@loadConI
2544    spill R7 -&gt; [sp, #0]	# spill size = 64
2548 +  spill R10 -&gt; [sp, #8]	# spill size = 64
254c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:41 (line 115) L[0]=sp + #48 L[1]=sp + #8 L[2]=#0 L[3]=_ STK[0]=R8
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop off=9552/0x2550}
2550    #@ShouldNotReachHere

255c    B369: #	out( B135 ) &lt;- in( B254 )  Freq: 2.42031e-07
255c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
255c    spill R23 -&gt; R11	# spill size = 64
2560 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2590 +  j  B135	#@branch

2594    B370: #	out( N6569 ) &lt;- in( B19 )  Freq: 2.37961e-07
2594 +  li R11, #-187	# int, #@loadConI
2598    spill R9 -&gt; [sp, #0]	# spill size = 64
259c +  spill R19 -&gt; [sp, #16]	# spill size = 64
25a0 +  spill R19 -&gt; [sp, #24]	# spill size = 64
25a4 +  spill R18 -&gt; [sp, #48]	# spill size = 64
25a8 +  spill R24 -&gt; [sp, #56]	# spill size = 64
25ac +  spill R21 -&gt; [sp, #72]	# spill size = 64
25b0 +  spill R20 -&gt; [sp, #80]	# spill size = 64
25b4 +  spill R29 -&gt; [sp, #88]	# spill size = 32
25b8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:13 (line 471) L[0]=sp + #72 L[1]=_ L[2]=sp + #80 L[3]=sp + #88 L[4]=_ L[5]=_ STK[0]=R8
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #72 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #16 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [72]=Oop [80]=Oop off=9660/0x25bc}
25bc    #@ShouldNotReachHere

25c8    B371: #	out( N6569 ) &lt;- in( B21 )  Freq: 2.3796e-07
25c8 +  li R11, #-187	# int, #@loadConI
25cc    spill R9 -&gt; R8	# spill size = 64
25d0 +  spill R19 -&gt; [sp, #8]	# spill size = 64
25d4 +  spill R19 -&gt; [sp, #16]	# spill size = 64
25d8 +  spill R18 -&gt; [sp, #40]	# spill size = 64
25dc +  spill R24 -&gt; [sp, #48]	# spill size = 64
25e0 +  spill R21 -&gt; [sp, #64]	# spill size = 64
25e4 +  spill R20 -&gt; [sp, #72]	# spill size = 64
25e8 +  spill R29 -&gt; [sp, #80]	# spill size = 32
25ec +  spill R31 -&gt; [sp, #88]	# spill size = 32
25f0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:43 (line 475) L[0]=sp + #64 L[1]=_ L[2]=sp + #72 L[3]=sp + #80 L[4]=sp + #88 L[5]=_ STK[0]=sp + #88 STK[1]=#65535
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #64 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #8 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #40 L[1]=sp + #48 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop [64]=Oop [72]=Oop off=9716/0x25f4}
25f4    #@ShouldNotReachHere

2600    B372: #	out( N6569 ) &lt;- in( B22 )  Freq: 2.3796e-07
2600 +  li R11, #-187	# int, #@loadConI
2604    spill R9 -&gt; [sp, #0]	# spill size = 64
2608 +  spill R19 -&gt; [sp, #16]	# spill size = 64
260c +  spill R19 -&gt; [sp, #24]	# spill size = 64
2610 +  spill R18 -&gt; [sp, #48]	# spill size = 64
2614 +  spill R24 -&gt; [sp, #56]	# spill size = 64
2618 +  spill R21 -&gt; [sp, #72]	# spill size = 64
261c +  spill R20 -&gt; [sp, #80]	# spill size = 64
2620 +  spill R31 -&gt; [sp, #88]	# spill size = 32
2624    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:55 (line 477) L[0]=sp + #72 L[1]=_ L[2]=sp + #80 L[3]=_ L[4]=sp + #88 L[5]=_ STK[0]=R8
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #72 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #16 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [72]=Oop [80]=Oop off=9768/0x2628}
2628    #@ShouldNotReachHere

2634    B373: #	out( B120 ) &lt;- in( B261 )  Freq: 2.35289e-07
2634 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2634    spill R23 -&gt; R11	# spill size = 64
2638 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2668 +  j  B120	#@branch

266c    B374: #	out( N6569 ) &lt;- in( B49 )  Freq: 2.3118e-07
266c +  lwu  R28, [R21, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
2670 +  decode_heap_oop  R8, R28	#@decodeHeapOop
2674    spill [sp, #8] -&gt; R28	# spill size = 64
2678 +  li R11, #-187	# int, #@loadConI
267c    spill R28 -&gt; [sp, #0]	# spill size = 64
2680 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2684 +  spill R19 -&gt; [sp, #24]	# spill size = 64
2688 +  spill R21 -&gt; [sp, #64]	# spill size = 64
268c +  spill R7 -&gt; [sp, #80]	# spill size = 32
2690 +  spill R20 -&gt; [sp, #88]	# spill size = 64
2694    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:18 (line 380) L[0]=sp + #64 L[1]=#ScObj0 L[2]=sp + #88 L[3]=_ STK[0]=sp + #80 STK[1]=#47
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=R8, [path :2]=sp + #88, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [64]=Oop [88]=Oop off=9880/0x2698}
2698    #@ShouldNotReachHere

26a4    B375: #	out( N6569 ) &lt;- in( B52 )  Freq: 2.31179e-07
26a4 +  li R11, #-187	# int, #@loadConI
26a8    spill [sp, #8] -&gt; R8	# spill size = 64
26ac +  spill R21 -&gt; [sp, #40]	# spill size = 64
26b0 +  spill R28 -&gt; [sp, #64]	# spill size = 64
26b4 +  spill R20 -&gt; [sp, #72]	# spill size = 64
26b8 +  spill R22 -&gt; [sp, #84]	# spill size = 32
26bc +  spill R18 -&gt; [sp, #88]	# spill size = 32
26c0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:28 (line 364) L[0]=sp + #64 L[1]=sp + #72 L[2]=sp + #88 L[3]=sp + #84 L[4]=_ STK[0]=sp + #88 STK[1]=#1
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=sp + #40 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=9924/0x26c4}
26c4    #@ShouldNotReachHere

26d0    B376: #	out( N6569 ) &lt;- in( B97 )  Freq: 2.30918e-07
26d0 +  spill [sp, #8] -&gt; R28	# spill size = 64
26d4 +  li R11, #-187	# int, #@loadConI
26d8    spill R28 -&gt; [sp, #0]	# spill size = 64
26dc +  spill R29 -&gt; [sp, #16]	# spill size = 64
26e0 +  spill R29 -&gt; [sp, #32]	# spill size = 64
26e4 +  spill R7 -&gt; [sp, #40]	# spill size = 64
26e8 +  spill R7 -&gt; [sp, #48]	# spill size = 64
26ec +  spill R9 -&gt; [sp, #64]	# spill size = 32
26f0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.System::allowSecurityManager @ bci:4 (line 193) STK[0]=R8 STK[1]=#1
        # java.lang.System::getSecurityManager @ bci:0 (line 483)
        # sun.nio.fs.UnixPath::checkRead @ bci:0 (line 778) L[0]=sp + #40 L[1]=_
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:4 (line 49) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=9972/0x26f4}
26f4    #@ShouldNotReachHere

2700    B377: #	out( N6569 ) &lt;- in( B98 )  Freq: 2.30917e-07
2700 +  spill [sp, #8] -&gt; R28	# spill size = 64
2704 +  li R11, #-187	# int, #@loadConI
2708    spill R28 -&gt; [sp, #0]	# spill size = 64
270c +  spill R29 -&gt; [sp, #16]	# spill size = 64
2710 +  spill R29 -&gt; [sp, #32]	# spill size = 64
2714 +  spill R7 -&gt; [sp, #40]	# spill size = 64
2718 +  spill R7 -&gt; [sp, #48]	# spill size = 64
271c +  spill R9 -&gt; [sp, #64]	# spill size = 32
2720    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::checkRead @ bci:5 (line 779) L[0]=sp + #40 L[1]=R8 STK[0]=R8
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:4 (line 49) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #40 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #48 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #32 L[1]=sp + #40 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=10020/0x2724}
2724    #@ShouldNotReachHere

2730    B378: #	out( N6569 ) &lt;- in( B141 )  Freq: 2.30908e-07
2730 +  spill [sp, #8] -&gt; R7	# spill size = 64
2734 +  li R11, #-187	# int, #@loadConI
2738    spill R7 -&gt; [sp, #0]	# spill size = 64
273c +  spill R12 -&gt; [sp, #32]	# spill size = 64
2740 +  spill R28 -&gt; [sp, #40]	# spill size = 32
2744    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:53 (line 288) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ STK[0]=R8 STK[1]=sp + #40
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop [56]=Oop off=10056/0x2748}
2748    #@ShouldNotReachHere

2754    B379: #	out( N6569 ) &lt;- in( B103 )  Freq: 2.30833e-07
2754 +  spill [sp, #8] -&gt; R8	# spill size = 64
2758 +  li R11, #-187	# int, #@loadConI
275c    spill R29 -&gt; [sp, #8]	# spill size = 64
2760 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2764 +  spill R7 -&gt; [sp, #32]	# spill size = 64
2768 +  spill R30 -&gt; [sp, #48]	# spill size = 64
276c +  spill R7 -&gt; [sp, #64]	# spill size = 64
2770 +  spill R10 -&gt; [sp, #80]	# spill size = 32
2774 +  spill R9 -&gt; [sp, #84]	# spill size = 32
2778    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getByteArrayForSysCalls @ bci:7 (line 135) L[0]=sp + #32 L[1]=_ STK[0]=sp + #80
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:1 (line 37) L[0]=sp + #32 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #84, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop off=10108/0x277c}
277c    #@ShouldNotReachHere

2788    B380: #	out( N6569 ) &lt;- in( B105 )  Freq: 2.30833e-07
2788 +  spill [sp, #8] -&gt; R8	# spill size = 64
278c +  li R11, #-187	# int, #@loadConI
2790    spill R29 -&gt; [sp, #8]	# spill size = 64
2794 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2798 +  spill R7 -&gt; [sp, #32]	# spill size = 64
279c +  spill R30 -&gt; [sp, #48]	# spill size = 64
27a0 +  spill R7 -&gt; [sp, #64]	# spill size = 64
27a4 +  spill R15 -&gt; [sp, #80]	# spill size = 32
27a8 +  spill R9 -&gt; [sp, #84]	# spill size = 32
27ac    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::isEmpty @ bci:5 (line 216) L[0]=_ STK[0]=sp + #80
        # sun.nio.fs.UnixPath::getByteArrayForSysCalls @ bci:26 (line 138) L[0]=sp + #32 L[1]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:1 (line 37) L[0]=sp + #32 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #84, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop off=10160/0x27b0}
27b0    #@ShouldNotReachHere

27bc    B381: #	out( N6569 ) &lt;- in( B170 )  Freq: 2.74951e-08
27bc +  spill [sp, #8] -&gt; R7	# spill size = 64
27c0 +  li R11, #-34	# int, #@loadConI
27c4    spill R7 -&gt; [sp, #0]	# spill size = 64
27c8 +  spill R19 -&gt; [sp, #16]	# spill size = 64
27cc +  spill R19 -&gt; [sp, #24]	# spill size = 64
27d0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #16 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop off=10196/0x27d4}
27d4    #@ShouldNotReachHere

27e0    B382: #	out( N6569 ) &lt;- in( B173 )  Freq: 2.7495e-08
27e0 +  spill [sp, #8] -&gt; R7	# spill size = 64
27e4 +  li R11, #-20	# int, #@loadConI
27e8    spill R7 -&gt; [sp, #0]	# spill size = 64
27ec +  spill R19 -&gt; [sp, #16]	# spill size = 64
27f0 +  spill R19 -&gt; [sp, #24]	# spill size = 64
27f4 +  spill R29 -&gt; [sp, #80]	# spill size = 64
27f8 +  spill R31 -&gt; [sp, #88]	# spill size = 32
27fc +  spill R30 -&gt; [sp, #92]	# spill size = 32
2800 +  spill R29 -&gt; [sp, #96]	# spill size = 64
2804    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_assert&apos; action=&apos;make_not_entrant&apos;)
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::hasQueuedPredecessors @ bci:6 (line 1234) L[0]=sp + #80 L[1]=#NULL L[2]=_ L[3]=_ STK[0]=R8
        # java.util.concurrent.locks.ReentrantReadWriteLock$FairSync::readerShouldBlock @ bci:1 (line 706) L[0]=_
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:33 (line 475) L[0]=sp + #96 L[1]=_ L[2]=sp + #72 L[3]=sp + #88 L[4]=sp + #92 L[5]=_
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #80 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #16 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [72]=Oop [80]=Oop [96]=Oop off=10248/0x2808}
2808    #@ShouldNotReachHere

2814    B383: #	out( N6569 ) &lt;- in( B181 )  Freq: 1.54602e-08
2814 +  li R11, #-10	# int, #@loadConI
2818    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:57 (line 94) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # OopMap {off=10268/0x281c}
281c    #@ShouldNotReachHere

2828    B384: #	out( N6569 ) &lt;- in( B188 )  Freq: 1.49395e-08
2828 +  li R11, #-10	# int, #@loadConI
282c    spill [sp, #8] -&gt; R8	# spill size = 64
2830    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:109 (line 369) L[0]=_ L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_ STK[0]=#NULL
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop off=10292/0x2834}
2834    #@ShouldNotReachHere

2840    B385: #	out( N6569 ) &lt;- in( B186 )  Freq: 1.47441e-08
2840 +  spill [sp, #8] -&gt; R8	# spill size = 64
2844 +  li R11, #-34	# int, #@loadConI
2848    spill R30 -&gt; [sp, #8]	# spill size = 64
284c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:76 (line 361) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_ STK[0]=sp + #8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [48]=Oop [56]=Oop off=10320/0x2850}
2850    #@ShouldNotReachHere

285c    B386: #	out( N6569 ) &lt;- in( B218 )  Freq: 1.39166e-08
285c +  spill [sp, #8] -&gt; R8	# spill size = 64
2860 +  li R11, #-10	# int, #@loadConI
2864    spill R18 -&gt; [sp, #8]	# spill size = 64
2868    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:187 (line 311) L[0]=_ L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ STK[0]=#NULL STK[1]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop [56]=Oop off=10348/0x286c}
286c    #@ShouldNotReachHere

2878    B387: #	out( N6569 ) &lt;- in( B176 )  Freq: 1.37475e-08
2878 +  li R11, #-187	# int, #@loadConI
287c    spill [sp, #8] -&gt; R8	# spill size = 64
2880 +  spill R29 -&gt; [sp, #64]	# spill size = 64
2884 +  spill R30 -&gt; [sp, #80]	# spill size = 32
2888    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:60 (line 478) L[0]=sp + #64 L[1]=_ L[2]=sp + #72 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #80
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #64 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=10380/0x288c}
288c    #@ShouldNotReachHere

2898    B388: #	out( B178 ) &lt;- in( B281 )  Freq: 1.37471e-08
2898 +  spill R29 -&gt; R18	# spill size = 64
289c    
289c    
289c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
289c    spill R23 -&gt; R11	# spill size = 64
28a0 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
28d0 +  spill R18 -&gt; R29	# spill size = 64
28d4 +  j  B178	#@branch

28d8    B389: #	out( N6569 ) &lt;- in( B164 )  Freq: 1.35736e-08
28d8 +  li R11, #-25	# int, #@loadConI
28dc    spill [sp, #8] -&gt; R8	# spill size = 64
28e0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;none&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::isSelfOrParent @ bci:22 (line 146) L[0]=_ L[1]=_ STK[0]=sp + #64 STK[1]=#1
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:123 (line 181) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop off=10468/0x28e4}
28e4    #@ShouldNotReachHere

28f0    B390: #	out( N6569 ) &lt;- in( B172 )  Freq: 1.31106e-08
28f0 +  spill [sp, #8] -&gt; R7	# spill size = 64
28f4 +  li R11, #-187	# int, #@loadConI
28f8    spill R7 -&gt; [sp, #0]	# spill size = 64
28fc +  spill R19 -&gt; [sp, #16]	# spill size = 64
2900 +  spill R19 -&gt; [sp, #24]	# spill size = 64
2904 +  spill R29 -&gt; [sp, #80]	# spill size = 64
2908 +  spill R31 -&gt; [sp, #88]	# spill size = 32
290c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:13 (line 471) L[0]=sp + #80 L[1]=_ L[2]=sp + #72 L[3]=sp + #88 L[4]=_ L[5]=_ STK[0]=R8
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #80 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #16 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [72]=Oop [80]=Oop off=10512/0x2910}
2910    #@ShouldNotReachHere

291c    B391: #	out( N6569 ) &lt;- in( B174 )  Freq: 1.31106e-08
291c +  li R11, #-187	# int, #@loadConI
2920    spill [sp, #8] -&gt; R8	# spill size = 64
2924 +  spill R29 -&gt; [sp, #64]	# spill size = 64
2928 +  spill R31 -&gt; [sp, #80]	# spill size = 32
292c +  spill R30 -&gt; [sp, #88]	# spill size = 32
2930    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:43 (line 475) L[0]=sp + #64 L[1]=_ L[2]=sp + #72 L[3]=sp + #80 L[4]=sp + #88 L[5]=_ STK[0]=sp + #88 STK[1]=#65535
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #64 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=10548/0x2934}
2934    #@ShouldNotReachHere

2940    B392: #	out( N6569 ) &lt;- in( B175 )  Freq: 1.31106e-08
2940 +  spill [sp, #8] -&gt; R7	# spill size = 64
2944 +  li R11, #-187	# int, #@loadConI
2948    spill R7 -&gt; [sp, #0]	# spill size = 64
294c +  spill R19 -&gt; [sp, #16]	# spill size = 64
2950 +  spill R19 -&gt; [sp, #24]	# spill size = 64
2954 +  spill R29 -&gt; [sp, #80]	# spill size = 64
2958 +  spill R30 -&gt; [sp, #88]	# spill size = 32
295c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$Sync::tryAcquireShared @ bci:55 (line 477) L[0]=sp + #80 L[1]=_ L[2]=sp + #72 L[3]=_ L[4]=sp + #88 L[5]=_ STK[0]=R8
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::acquireShared @ bci:2 (line 1026) L[0]=sp + #80 L[1]=#1
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #16 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [72]=Oop [80]=Oop off=10592/0x2960}
2960    #@ShouldNotReachHere

296c    B393: #	out( B202 ) &lt;- in( B294 )  Freq: 6.86706e-09
296c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
296c    spill R23 -&gt; R11	# spill size = 64
2970 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
29a0 +  j  B202	#@branch

29a4    B394: #	out( B205 ) &lt;- in( B288 )  Freq: 6.86706e-09
29a4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
29a4    spill R23 -&gt; R11	# spill size = 64
29a8 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
29d8 +  j  B205	#@branch

29dc    B395: #	out( B209 ) &lt;- in( B291 )  Freq: 6.86706e-09
29dc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
29dc    spill R23 -&gt; R11	# spill size = 64
29e0 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2a10 +  j  B209	#@branch

2a14    B396: #	out( B215 ) &lt;- in( B297 )  Freq: 6.86693e-09
2a14 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
2a14    spill R23 -&gt; R11	# spill size = 64
2a18 +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
2a48 +  j  B215	#@branch

2a4c    B397: #	out( N6569 ) &lt;- in( B163 )  Freq: 6.78678e-09
2a4c +  li R11, #-187	# int, #@loadConI
2a50    spill [sp, #8] -&gt; R8	# spill size = 64
2a54 +  spill R22 -&gt; [sp, #72]	# spill size = 32
2a58    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::isSelfOrParent @ bci:17 (line 146) L[0]=_ L[1]=sp + #64 STK[0]=sp + #72 STK[1]=#2
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:123 (line 181) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop off=10844/0x2a5c}
2a5c    #@ShouldNotReachHere

2a68    B398: #	out( N6569 ) &lt;- in( B195 )  Freq: 6.54938e-09
2a68 +  spill [sp, #8] -&gt; R7	# spill size = 64
2a6c +  li R11, #-187	# int, #@loadConI
2a70    spill R7 -&gt; [sp, #0]	# spill size = 64
2a74 +  spill R30 -&gt; [sp, #32]	# spill size = 64
2a78    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:84 (line 293) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ STK[0]=R8
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop [56]=Oop off=10876/0x2a7c}
2a7c    #@ShouldNotReachHere

2a88    B399: #	out( N6569 ) &lt;- in( B7 )  Freq: 1e-35
2a88 +  li R11, #-34	# int, #@loadConI
2a8c    spill R9 -&gt; R8	# spill size = 64
2a90 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2a94 +  spill R24 -&gt; [sp, #8]	# spill size = 64
2a98    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:7 (line 335) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=sp + #8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=10908/0x2a9c}
2a9c    #@ShouldNotReachHere

2aa8    B400: #	out( N6569 ) &lt;- in( B82 )  Freq: 1e-35
2aa8 +  li R11, #-34	# int, #@loadConI
2aac    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:52 (line 350) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=_ L[6]=_ STK[0]=R8
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [48]=Oop [56]=Oop off=10928/0x2ab0}
2ab0    #@ShouldNotReachHere

2abc    B401: #	out( N6569 ) &lt;- in( B113 )  Freq: 1e-35
2abc +  spill [sp, #8] -&gt; R8	# spill size = 64
2ac0 +  li R11, #-34	# int, #@loadConI
2ac4    spill R29 -&gt; [sp, #8]	# spill size = 64
2ac8 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2acc +  spill R7 -&gt; [sp, #32]	# spill size = 64
2ad0 +  spill R30 -&gt; [sp, #48]	# spill size = 64
2ad4 +  spill R7 -&gt; [sp, #64]	# spill size = 64
2ad8 +  spill R12 -&gt; [sp, #72]	# spill size = 64
2adc +  spill R18 -&gt; [sp, #84]	# spill size = 32
2ae0 +  spill R31 -&gt; [sp, #88]	# spill size = 64
2ae4 +  spill R9 -&gt; [sp, #96]	# spill size = 32
2ae8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:6 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #88
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #32 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #96, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop [88]=Oop off=10988/0x2aec}
2aec    #@ShouldNotReachHere

2af8    B402: #	out( N6569 ) &lt;- in( B131 )  Freq: 1e-35
2af8 +  li R11, #-34	# int, #@loadConI
2afc    spill [sp, #8] -&gt; R8	# spill size = 64
2b00 +  spill R10 -&gt; [sp, #0]	# spill size = 64
2b04    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:6 (line 106) L[0]=sp + #48 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #0
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop off=11016/0x2b08}
2b08    #@ShouldNotReachHere

2b14    B403: #	out( B451 B501 B452 ) &lt;- in( B31 )  Freq: 5.26543e-06
2b14     -- 	// exception oop; no code emitted, #@CreateException
2b14 +  spill [sp, #0] -&gt; R28	# spill size = 64
2b18 +  lwu  R28, [R28, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixDirectoryStream$UnixDirectoryIterator.this$0
2b1c +  decode_heap_oop  R28, R28	#@decodeHeapOop
2b20    spill R28 -&gt; R8	# spill size = 64
2b24 +  spill R10 -&gt; R11	# spill size = 64
2b28    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:52 (line 165) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [48]=Oop [56]=Oop off=11052/0x2b2c}

2b2c    B404: #	out( N6569 ) &lt;- in( B28 )  Freq: 5.33536e-07
2b2c +  li R11, #-10	# int, #@loadConI
2b30    spill R9 -&gt; R8	# spill size = 64
2b34 +  spill R19 -&gt; [sp, #8]	# spill size = 64
2b38 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2b3c +  spill R18 -&gt; [sp, #40]	# spill size = 64
2b40 +  spill R24 -&gt; [sp, #48]	# spill size = 64
2b44    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:39 (line 164) L[0]=sp + #8 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #40 L[1]=sp + #48 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop off=11080/0x2b48}
2b48    #@ShouldNotReachHere

2b54    B405: #	out( N6569 ) &lt;- in( B30 )  Freq: 5.33535e-07
2b54 +  li R11, #-10	# int, #@loadConI
2b58    spill R9 -&gt; R8	# spill size = 64
2b5c +  spill R19 -&gt; [sp, #8]	# spill size = 64
2b60 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2b64 +  spill R18 -&gt; [sp, #40]	# spill size = 64
2b68 +  spill R24 -&gt; [sp, #48]	# spill size = 64
2b6c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:49 (line 165) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #40 L[1]=sp + #48 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop off=11120/0x2b70}
2b70    #@ShouldNotReachHere

2b7c    B406: #	out( N6569 ) &lt;- in( B32 )  Freq: 5.33524e-07
2b7c +  li R11, #-10	# int, #@loadConI
2b80    spill [sp, #8] -&gt; R8	# spill size = 64
2b84    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:60 (line 171) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop off=11144/0x2b88}
2b88    #@ShouldNotReachHere

2b94    B407: #	out( N6569 ) &lt;- in( B33 )  Freq: 5.33523e-07
2b94 +  li R11, #-10	# int, #@loadConI
2b98    spill [sp, #8] -&gt; R8	# spill size = 64
2b9c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream::readLock @ bci:4 (line 75) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:60 (line 171) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop off=11168/0x2ba0}
2ba0    #@ShouldNotReachHere

2bac    B408: #	out( N6569 ) &lt;- in( B34 )  Freq: 5.33523e-07
2bac +  li R11, #-10	# int, #@loadConI
2bb0    spill [sp, #8] -&gt; R8	# spill size = 64
2bb4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop off=11192/0x2bb8}
2bb8    #@ShouldNotReachHere

2bc4    B409: #	out( N6569 ) &lt;- in( B36 )  Freq: 5.33522e-07
2bc4 +  li R11, #-10	# int, #@loadConI
2bc8    spill [sp, #8] -&gt; R8	# spill size = 64
2bcc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::unlock @ bci:5 (line 897) L[0]=_ STK[0]=#NULL STK[1]=#1
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:63 (line 171) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop off=11216/0x2bd0}
2bd0    #@ShouldNotReachHere

2bdc    B410: #	out( N6569 ) &lt;- in( B2 )  Freq: 5.06179e-07
2bdc +  li R11, #-10	# int, #@loadConI
2be0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # OopMap {off=11236/0x2be4}
2be4    #@ShouldNotReachHere

2bf0    B411: #	out( N6569 ) &lt;- in( B3 )  Freq: 5.06179e-07
2bf0 +  li R11, #-10	# int, #@loadConI
2bf4    spill R9 -&gt; R8	# spill size = 64
2bf8 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2bfc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:4 (line 335) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=#NULL
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop off=11264/0x2c00}
2c00    #@ShouldNotReachHere

2c0c    B412: #	out( N6569 ) &lt;- in( B4 )  Freq: 5.06178e-07
2c0c +  li R11, #-10	# int, #@loadConI
2c10    spill R9 -&gt; R8	# spill size = 64
2c14 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2c18 +  spill R30 -&gt; [sp, #8]	# spill size = 32
2c1c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ArrayDeque::elementAt @ bci:2 (line 259) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=sp + #8
        # java.util.ArrayDeque::peekFirst @ bci:8 (line 418) L[0]=_
        # java.util.ArrayDeque::peek @ bci:1 (line 564) L[0]=_
        # java.nio.file.FileTreeWalker::next @ bci:4 (line 335) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop off=11296/0x2c20}
2c20    #@ShouldNotReachHere

2c2c    B413: #	out( N6569 ) &lt;- in( B9 )  Freq: 5.05671e-07
2c2c +  li R11, #-10	# int, #@loadConI
2c30    spill R9 -&gt; R8	# spill size = 64
2c34 +  spill R18 -&gt; [sp, #0]	# spill size = 64
2c38 +  spill R24 -&gt; [sp, #8]	# spill size = 64
2c3c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=#NULL L[6]=_ STK[0]=#NULL
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=11328/0x2c40}
2c40    #@ShouldNotReachHere

2c4c    B414: #	out( N6569 ) &lt;- in( B14 )  Freq: 5.05669e-07
2c4c +  li R11, #-10	# int, #@loadConI
2c50    spill R9 -&gt; R8	# spill size = 64
2c54 +  spill R19 -&gt; [sp, #8]	# spill size = 64
2c58 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2c5c +  spill R18 -&gt; [sp, #40]	# spill size = 64
2c60 +  spill R24 -&gt; [sp, #48]	# spill size = 64
2c64    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:27 (line 162) L[0]=sp + #8 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #40 L[1]=sp + #48 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop off=11368/0x2c68}
2c68    #@ShouldNotReachHere

2c74    B415: #	out( N6569 ) &lt;- in( B15 )  Freq: 5.05669e-07
2c74 +  li R11, #-10	# int, #@loadConI
2c78    spill R9 -&gt; R8	# spill size = 64
2c7c +  spill R19 -&gt; [sp, #8]	# spill size = 64
2c80 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2c84 +  spill R18 -&gt; [sp, #40]	# spill size = 64
2c88 +  spill R24 -&gt; [sp, #48]	# spill size = 64
2c8c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream::readLock @ bci:4 (line 75) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:27 (line 162) L[0]=sp + #8 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #40 L[1]=sp + #48 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop off=11408/0x2c90}
2c90    #@ShouldNotReachHere

2c9c    B416: #	out( N6569 ) &lt;- in( B16 )  Freq: 5.05668e-07
2c9c +  li R11, #-10	# int, #@loadConI
2ca0    spill R9 -&gt; R8	# spill size = 64
2ca4 +  spill R19 -&gt; [sp, #8]	# spill size = 64
2ca8 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2cac +  spill R18 -&gt; [sp, #40]	# spill size = 64
2cb0 +  spill R24 -&gt; [sp, #48]	# spill size = 64
2cb4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #8 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #40 L[1]=sp + #48 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop off=11448/0x2cb8}
2cb8    #@ShouldNotReachHere

2cc4    B417: #	out( N6569 ) &lt;- in( B18 )  Freq: 5.05667e-07
2cc4 +  li R11, #-10	# int, #@loadConI
2cc8    spill R9 -&gt; R8	# spill size = 64
2ccc +  spill R19 -&gt; [sp, #8]	# spill size = 64
2cd0 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2cd4 +  spill R18 -&gt; [sp, #40]	# spill size = 64
2cd8 +  spill R24 -&gt; [sp, #48]	# spill size = 64
2cdc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_ STK[0]=#NULL STK[1]=#1
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #8 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #40 L[1]=sp + #48 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop off=11488/0x2ce0}
2ce0    #@ShouldNotReachHere

2cec    B418: #	out( N6569 ) &lt;- in( B47 )  Freq: 4.91258e-07
2cec +  li R11, #-10	# int, #@loadConI
2cf0    spill [sp, #8] -&gt; R8	# spill size = 64
2cf4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:133 (line 182) L[0]=sp + #0 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop off=11512/0x2cf8}
2cf8    #@ShouldNotReachHere

2d04    B419: #	out( N6569 ) &lt;- in( B48 )  Freq: 4.91257e-07
2d04 +  li R11, #-10	# int, #@loadConI
2d08    spill [sp, #8] -&gt; R8	# spill size = 64
2d0c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=sp + #64
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop [64]=Oop off=11536/0x2d10}
2d10    #@ShouldNotReachHere

2d1c    B420: #	out( N6569 ) &lt;- in( B50 )  Freq: 4.91257e-07
2d1c +  li R11, #-10	# int, #@loadConI
2d20    spill [sp, #8] -&gt; R8	# spill size = 64
2d24    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::resolve @ bci:1 (line 357) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::resolve @ bci:31 (line 382) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::resolve @ bci:13 (line 387) L[0]=_ L[1]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:137 (line 182) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop off=11560/0x2d28}
2d28    #@ShouldNotReachHere

2d34    B421: #	out( N6569 ) &lt;- in( B68 )  Freq: 4.91254e-07
2d34 +  spill [sp, #8] -&gt; R8	# spill size = 64
2d38 +  li R11, #-10	# int, #@loadConI
2d3c    spill R19 -&gt; [sp, #8]	# spill size = 64
2d40 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2d44 +  spill R18 -&gt; [sp, #40]	# spill size = 64
2d48    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:145 (line 186) L[0]=sp + #8 L[1]=_ L[2]=sp + #40 L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #16 STK[0]=sp + #8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #8
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop [48]=Oop [56]=Oop off=11596/0x2d4c}
2d4c    #@ShouldNotReachHere

2d58    B422: #	out( N6569 ) &lt;- in( B85 )  Freq: 4.90702e-07
2d58 +  spill [sp, #8] -&gt; R8	# spill size = 64
2d5c +  li R11, #-10	# int, #@loadConI
2d60    spill R29 -&gt; [sp, #8]	# spill size = 64
2d64 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2d68 +  spill R7 -&gt; [sp, #32]	# spill size = 64
2d6c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::provider @ bci:6 (line 105) L[0]=_ STK[0]=#NULL
        # java.nio.file.Files::readAttributes @ bci:1 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #32 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [56]=Oop off=11632/0x2d70}
2d70    #@ShouldNotReachHere

2d7c    B423: #	out( N6569 ) &lt;- in( B87 )  Freq: 4.90701e-07
2d7c +  spill [sp, #8] -&gt; R8	# spill size = 64
2d80 +  li R11, #-10	# int, #@loadConI
2d84    spill R29 -&gt; [sp, #8]	# spill size = 64
2d88 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2d8c +  spill R7 -&gt; [sp, #32]	# spill size = 64
2d90    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.Util::followLinks @ bci:5 (line 121) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # sun.nio.fs.UnixFileSystemProvider::getFileAttributeView @ bci:7 (line 120) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # sun.nio.fs.LinuxFileSystemProvider::getFileAttributeView @ bci:48 (line 68) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:51 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #32 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [56]=Oop off=11668/0x2d94}
2d94    #@ShouldNotReachHere

2da0    B424: #	out( N6569 ) &lt;- in( B139 )  Freq: 4.9068e-07
2da0 +  spill [sp, #8] -&gt; R8	# spill size = 64
2da4 +  spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
2dac +  li R11, #-10	# int, #@loadConI
2db0    spill R12 -&gt; [sp, #16]	# spill size = 64
2db4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:42 (line 287) L[0]=sp + #8 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=sp + #16 L[5]=_ L[6]=_ L[7]=_ STK[0]=#NULL
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [56]=Oop off=11704/0x2db8}
2db8    #@ShouldNotReachHere

2dc4    B425: #	out( N6569 ) &lt;- in( B140 )  Freq: 4.9068e-07
2dc4 +  spill [sp, #8] -&gt; R8	# spill size = 64
2dc8 +  spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
2dd0 +  li R11, #-10	# int, #@loadConI
2dd4    spill R12 -&gt; [sp, #16]	# spill size = 64
2dd8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ArrayDeque::size @ bci:12 (line 649) L[0]=_ STK[0]=_ STK[1]=_ STK[2]=#NULL
        # java.nio.file.FileTreeWalker::visit @ bci:42 (line 287) L[0]=sp + #8 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=sp + #16 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [56]=Oop off=11740/0x2ddc}
2ddc    #@ShouldNotReachHere

2de8    B426: #	out( N6569 ) &lt;- in( B143 )  Freq: 4.90679e-07
2de8 +  spill [sp, #8] -&gt; R8	# spill size = 64
2dec +  spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
2df4 +  li R11, #-10	# int, #@loadConI
2df8    spill R30 -&gt; [sp, #16]	# spill size = 64
2dfc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes::isDirectory @ bci:4 (line 299) L[0]=_ STK[0]=#NULL
        # java.nio.file.FileTreeWalker::visit @ bci:58 (line 288) L[0]=sp + #8 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=sp + #16 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [56]=Oop off=11776/0x2e00}
2e00    #@ShouldNotReachHere

2e0c    B427: #	out( N6569 ) &lt;- in( B102 )  Freq: 4.90521e-07
2e0c +  spill [sp, #8] -&gt; R8	# spill size = 64
2e10 +  li R11, #-10	# int, #@loadConI
2e14    spill R29 -&gt; [sp, #8]	# spill size = 64
2e18 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2e1c +  spill R7 -&gt; [sp, #32]	# spill size = 64
2e20 +  spill R30 -&gt; [sp, #48]	# spill size = 64
2e24 +  spill R9 -&gt; [sp, #64]	# spill size = 32
2e28 +  spill R7 -&gt; [sp, #72]	# spill size = 64
2e2c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getByteArrayForSysCalls @ bci:4 (line 135) L[0]=_ L[1]=_ STK[0]=#NULL
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:1 (line 37) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [72]=Oop off=11824/0x2e30}
2e30    #@ShouldNotReachHere

2e3c    B428: #	out( N6569 ) &lt;- in( B104 )  Freq: 4.90521e-07
2e3c +  spill [sp, #8] -&gt; R8	# spill size = 64
2e40 +  li R11, #-10	# int, #@loadConI
2e44    spill R29 -&gt; [sp, #8]	# spill size = 64
2e48 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2e4c +  spill R7 -&gt; [sp, #32]	# spill size = 64
2e50 +  spill R30 -&gt; [sp, #48]	# spill size = 64
2e54 +  spill R9 -&gt; [sp, #64]	# spill size = 32
2e58 +  spill R7 -&gt; [sp, #72]	# spill size = 64
2e5c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::isEmpty @ bci:4 (line 216) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::getByteArrayForSysCalls @ bci:26 (line 138) L[0]=_ L[1]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:1 (line 37) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [72]=Oop off=11872/0x2e60}
2e60    #@ShouldNotReachHere

2e6c    B429: #	out( N6569 ) &lt;- in( B106 )  Freq: 4.9052e-07
2e6c +  spill [sp, #8] -&gt; R8	# spill size = 64
2e70 +  li R11, #-10	# int, #@loadConI
2e74    spill R29 -&gt; [sp, #8]	# spill size = 64
2e78 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2e7c +  spill R7 -&gt; [sp, #32]	# spill size = 64
2e80 +  spill R30 -&gt; [sp, #48]	# spill size = 64
2e84 +  spill R9 -&gt; [sp, #64]	# spill size = 32
2e88 +  spill R7 -&gt; [sp, #72]	# spill size = 64
2e8c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [72]=Oop off=11920/0x2e90}
2e90    #@ShouldNotReachHere

2e9c    B430: #	out( N6569 ) &lt;- in( B108 )  Freq: 4.90519e-07
2e9c +  spill [sp, #8] -&gt; R8	# spill size = 64
2ea0 +  li R11, #-10	# int, #@loadConI
2ea4    spill R29 -&gt; [sp, #8]	# spill size = 64
2ea8 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2eac +  spill R7 -&gt; [sp, #32]	# spill size = 64
2eb0 +  spill R30 -&gt; [sp, #48]	# spill size = 64
2eb4 +  spill R9 -&gt; [sp, #64]	# spill size = 32
2eb8 +  spill R7 -&gt; [sp, #72]	# spill size = 64
2ebc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:8 (line 434) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #64, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #72 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [72]=Oop off=11968/0x2ec0}
2ec0    #@ShouldNotReachHere

2ecc    B431: #	out( N6569 ) &lt;- in( B112 )  Freq: 4.90517e-07
2ecc +  spill [sp, #8] -&gt; R8	# spill size = 64
2ed0 +  li R11, #-12	# int, #@loadConI
2ed4    spill R29 -&gt; [sp, #8]	# spill size = 64
2ed8 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2edc +  spill R7 -&gt; [sp, #32]	# spill size = 64
2ee0 +  spill R30 -&gt; [sp, #48]	# spill size = 64
2ee4 +  spill R7 -&gt; [sp, #64]	# spill size = 64
2ee8 +  spill R12 -&gt; [sp, #72]	# spill size = 64
2eec +  spill R18 -&gt; [sp, #84]	# spill size = 32
2ef0 +  spill R9 -&gt; [sp, #88]	# spill size = 32
2ef4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:6 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #32 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #88, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=12024/0x2ef8}
2ef8    #@ShouldNotReachHere

2f04    B432: #	out( N6569 ) &lt;- in( B124 )  Freq: 4.90506e-07
2f04 +  li R11, #-10	# int, #@loadConI
2f08    spill [sp, #8] -&gt; R8	# spill size = 64
2f0c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop off=12048/0x2f10}
2f10    #@ShouldNotReachHere

2f1c    B433: #	out( N6569 ) &lt;- in( B126 )  Freq: 4.90505e-07
2f1c +  li R11, #-10	# int, #@loadConI
2f20    spill [sp, #8] -&gt; R8	# spill size = 64
2f24    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:8 (line 434) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop off=12072/0x2f28}
2f28    #@ShouldNotReachHere

2f34    B434: #	out( N6569 ) &lt;- in( B130 )  Freq: 4.90504e-07
2f34 +  li R11, #-12	# int, #@loadConI
2f38    spill [sp, #8] -&gt; R8	# spill size = 64
2f3c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:6 (line 106) L[0]=sp + #48 L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop off=12096/0x2f40}
2f40    #@ShouldNotReachHere

2f4c    B435: #	out( N6569 ) &lt;- in( B69 )  Freq: 2.31178e-07
2f4c +  spill [sp, #8] -&gt; R7	# spill size = 64
2f50 +  li R11, #-187	# int, #@loadConI
2f54    spill R7 -&gt; [sp, #0]	# spill size = 64
2f58 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2f5c +  spill R19 -&gt; [sp, #24]	# spill size = 64
2f60 +  spill R18 -&gt; [sp, #64]	# spill size = 64
2f64    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:148 (line 186) L[0]=sp + #16 L[1]=_ L[2]=sp + #64 L[3]=_ L[4]=_ STK[0]=R8
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #24 STK[0]=sp + #16 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #16 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [48]=Oop [56]=Oop [64]=Oop off=12136/0x2f68}
2f68    #@ShouldNotReachHere

2f74    B436: #	out( N6569 ) &lt;- in( B79 )  Freq: 2.30919e-07
2f74 +  spill [sp, #8] -&gt; R7	# spill size = 64
2f78 +  li R11, #-187	# int, #@loadConI
2f7c    spill R7 -&gt; [sp, #0]	# spill size = 64
2f80 +  spill R19 -&gt; [sp, #16]	# spill size = 64
2f84    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::next @ bci:4 (line 205) L[0]=sp + #16 L[1]=_ STK[0]=R8 MON-BOX0=sp+144 MON-OBJ[0]=sp + #16
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::next @ bci:1 (line 132) L[0]=_
        # java.nio.file.FileTreeWalker::next @ bci:47 (line 350) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [48]=Oop [56]=Oop off=12168/0x2f88}
2f88    #@ShouldNotReachHere

2f94    B437: #	out( N6569 ) &lt;- in( B107 )  Freq: 2.30833e-07
2f94 +  spill [sp, #8] -&gt; R8	# spill size = 64
2f98 +  li R11, #-187	# int, #@loadConI
2f9c    spill R29 -&gt; [sp, #8]	# spill size = 64
2fa0 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2fa4 +  spill R7 -&gt; [sp, #32]	# spill size = 64
2fa8 +  spill R30 -&gt; [sp, #48]	# spill size = 64
2fac +  spill R7 -&gt; [sp, #64]	# spill size = 64
2fb0 +  spill R12 -&gt; [sp, #72]	# spill size = 64
2fb4 +  spill R18 -&gt; [sp, #84]	# spill size = 32
2fb8 +  spill R17 -&gt; [sp, #88]	# spill size = 64
2fbc +  spill R16 -&gt; [sp, #104]	# spill size = 64
2fc0 +  spill R9 -&gt; [sp, #112]	# spill size = 32
2fc4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal::get @ bci:11 (line 164) L[0]=sp + #88 L[1]=_ L[2]=sp + #104 L[3]=_ L[4]=_ STK[0]=sp + #104
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #32 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #112, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop [88]=Oop [104]=Oop off=12232/0x2fc8}
2fc8    #@ShouldNotReachHere

2fd4    B438: #	out( N6569 ) &lt;- in( B110 )  Freq: 2.30832e-07
2fd4 +  spill [sp, #8] -&gt; R8	# spill size = 64
2fd8 +  li R11, #-187	# int, #@loadConI
2fdc    spill R29 -&gt; [sp, #8]	# spill size = 64
2fe0 +  spill R29 -&gt; [sp, #24]	# spill size = 64
2fe4 +  spill R7 -&gt; [sp, #32]	# spill size = 64
2fe8 +  spill R30 -&gt; [sp, #48]	# spill size = 64
2fec +  spill R7 -&gt; [sp, #64]	# spill size = 64
2ff0 +  spill R12 -&gt; [sp, #72]	# spill size = 64
2ff4 +  spill R18 -&gt; [sp, #84]	# spill size = 32
2ff8 +  spill R16 -&gt; [sp, #96]	# spill size = 64
2ffc +  spill R17 -&gt; [sp, #104]	# spill size = 64
3000 +  spill R13 -&gt; [sp, #112]	# spill size = 32
3004 +  spill R19 -&gt; [sp, #128]	# spill size = 64
3008 +  spill R9 -&gt; [sp, #116]	# spill size = 32
300c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:21 (line 436) L[0]=sp + #96 L[1]=sp + #104 L[2]=sp + #112 L[3]=sp + #128 STK[0]=sp + #128
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #104 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:3 (line 72) L[0]=sp + #84 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #32 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #116, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop [96]=Oop [104]=Oop [128]=Oop off=12304/0x3010}
3010    #@ShouldNotReachHere

301c    B439: #	out( N6569 ) &lt;- in( B115 )  Freq: 2.30831e-07
301c +  spill [sp, #8] -&gt; R8	# spill size = 64
3020 +  li R11, #-187	# int, #@loadConI
3024    spill R29 -&gt; [sp, #8]	# spill size = 64
3028 +  spill R29 -&gt; [sp, #24]	# spill size = 64
302c +  spill R7 -&gt; [sp, #32]	# spill size = 64
3030 +  spill R30 -&gt; [sp, #48]	# spill size = 64
3034 +  spill R7 -&gt; [sp, #64]	# spill size = 64
3038 +  spill R12 -&gt; [sp, #72]	# spill size = 64
303c +  spill R18 -&gt; [sp, #84]	# spill size = 32
3040 +  spill R31 -&gt; [sp, #88]	# spill size = 64
3044 +  spill R21 -&gt; [sp, #104]	# spill size = 64
3048 +  spill R9 -&gt; [sp, #112]	# spill size = 32
304c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.NativeBuffers::getNativeBufferFromCache @ bci:26 (line 76) L[0]=sp + #84 L[1]=sp + #88 L[2]=#0 L[3]=sp + #104 STK[0]=sp + #104
        # sun.nio.fs.UnixNativeDispatcher::copyToNativeBuffer @ bci:11 (line 39) L[0]=sp + #32 L[1]=sp + #72 L[2]=sp + #84 L[3]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:1 (line 306) L[0]=_ L[1]=sp + #48 L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #48
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #112, [file :1]=sp + #32 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #8 L[1]=sp + #64 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #24 L[1]=sp + #32 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #8 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop [88]=Oop [104]=Oop off=12368/0x3050}
3050    #@ShouldNotReachHere

305c    B440: #	out( N6569 ) &lt;- in( B125 )  Freq: 2.30826e-07
305c +  li R11, #-187	# int, #@loadConI
3060    spill [sp, #8] -&gt; R8	# spill size = 64
3064 +  spill R30 -&gt; [sp, #0]	# spill size = 64
3068 +  spill R31 -&gt; [sp, #64]	# spill size = 64
306c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal::get @ bci:11 (line 164) L[0]=sp + #0 L[1]=_ L[2]=sp + #64 L[3]=_ L[4]=_ STK[0]=sp + #64
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #48 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop off=12400/0x3070}
3070    #@ShouldNotReachHere

307c    B441: #	out( N6569 ) &lt;- in( B128 )  Freq: 2.30826e-07
307c +  spill [sp, #8] -&gt; R8	# spill size = 64
3080 +  li R11, #-187	# int, #@loadConI
3084    spill R31 -&gt; [sp, #8]	# spill size = 64
3088 +  spill R30 -&gt; [sp, #64]	# spill size = 64
308c +  spill R28 -&gt; [sp, #36]	# spill size = 32
3090 +  spill R29 -&gt; [sp, #80]	# spill size = 64
3094    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:21 (line 436) L[0]=sp + #8 L[1]=sp + #64 L[2]=sp + #36 L[3]=sp + #80 STK[0]=sp + #80
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #64 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #48 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:14 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop [80]=Oop off=12440/0x3098}
3098    #@ShouldNotReachHere

30a4    B442: #	out( B519 B491 ) &lt;- in( B187 )  Freq: 1.4744e-07
30a4     -- 	// exception oop; no code emitted, #@CreateException
30a4 +  spill R10 -&gt; R11	# spill size = 64
30a8    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::next @ bci:76 (line 361) L[0]=sp + #48 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [48]=Oop off=12460/0x30ac}

30ac    B443: #	out( B492 B493 B518 ) &lt;- in( B196 )  Freq: 1.3735e-07
30ac     -- 	// exception oop; no code emitted, #@CreateException
30ac +  spill R10 -&gt; R11	# spill size = 64
30b0    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::visit @ bci:131 (line 301) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [32]=Oop [56]=Oop off=12468/0x30b4}

30b4    B444: #	out( N6569 ) &lt;- in( B167 )  Freq: 2.78603e-08
30b4 +  li R11, #-10	# int, #@loadConI
30b8    spill [sp, #8] -&gt; R8	# spill size = 64
30bc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:27 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop off=12480/0x30c0}
30c0    #@ShouldNotReachHere

30cc    B445: #	out( N6569 ) &lt;- in( B168 )  Freq: 2.78602e-08
30cc +  li R11, #-10	# int, #@loadConI
30d0    spill [sp, #8] -&gt; R8	# spill size = 64
30d4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream::readLock @ bci:4 (line 75) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:27 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop off=12504/0x30d8}
30d8    #@ShouldNotReachHere

30e4    B446: #	out( N6569 ) &lt;- in( B169 )  Freq: 2.78602e-08
30e4 +  li R11, #-10	# int, #@loadConI
30e8    spill [sp, #8] -&gt; R8	# spill size = 64
30ec    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop off=12528/0x30f0}
30f0    #@ShouldNotReachHere

30fc    B447: #	out( N6569 ) &lt;- in( B171 )  Freq: 2.78601e-08
30fc +  li R11, #-10	# int, #@loadConI
3100    spill [sp, #8] -&gt; R8	# spill size = 64
3104    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock::lock @ bci:5 (line 738) L[0]=_ STK[0]=#NULL STK[1]=#1
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:30 (line 162) L[0]=sp + #0 L[1]=#NULL L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop off=12552/0x3108}
3108    #@ShouldNotReachHere

3114    B448: #	out( N6569 ) &lt;- in( B185 )  Freq: 1.49399e-08
3114 +  li R11, #-10	# int, #@loadConI
3118    spill [sp, #8] -&gt; R8	# spill size = 64
311c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:76 (line 361) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_ STK[0]=#NULL
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [48]=Oop [56]=Oop off=12576/0x3120}
3120    #@ShouldNotReachHere

312c    B449: #	out( B494 B497 ) &lt;- in( B276 )  Freq: 4.8433e-10
312c     -- 	// exception oop; no code emitted, #@CreateException
312c +  spill R10 -&gt; R11	# spill size = 64
3130    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:20 (line 53) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [56]=Oop off=12596/0x3134}

3134    B450: #	out( N6569 ) &lt;- in( B510 )  Freq: 5.26631e-11
3134     -- 	// exception oop; no code emitted, #@CreateException
3134 +  spill R10 -&gt; [sp, #0]	# spill size = 64
3138 +  li R11, #-75	# int, #@loadConI
313c    spill [sp, #8] -&gt; R8	# spill size = 64
3140    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:59 (line 352) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=_ L[5]=_ L[6]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop off=12612/0x3144}
3144    #@ShouldNotReachHere

3150    B451: #	out( N6569 ) &lt;- in( B403 )  Freq: 5.26543e-11
3150     -- 	// exception oop; no code emitted, #@CreateException
3150 +  spill R10 -&gt; [sp, #40]	# spill size = 64
3154 +  li R11, #-75	# int, #@loadConI
3158    spill [sp, #8] -&gt; R8	# spill size = 64
315c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:71 (line 167) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #40
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [40]=Oop [48]=Oop [56]=Oop off=12640/0x3160}
3160    #@ShouldNotReachHere

316c    B452: #	out( B454 B453 ) &lt;- in( B403 )  Freq: 5.26543e-11
316c     -- 	// exception oop; no code emitted, #@CreateException
316c +  #@membar_release_lock (elided)
316c    add R29, sp, #144	# box lock
3170 +  spill [sp, #0] -&gt; R18	# spill size = 64
3174 +  fastunlock R18,R29	! kills R28, R7, #@cmpFastUnlock
31ec +  spill R10 -&gt; R9	# spill size = 64
31f0 +  far_bne RFLAGS, zr, B454	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

31f8    B453: #	out( B517 B498 ) &lt;- in( B454 B452 )  Freq: 5.26543e-11
31f8 +  spill R18 -&gt; R8	# spill size = 64
31fc +  spill R9 -&gt; R11	# spill size = 64
3200    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=R8 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [48]=Oop [56]=Oop off=12804/0x3204}

3204    B454: #	out( B453 ) &lt;- in( B452 )  Freq: 5.26543e-17
3204    add R11, sp, #144	# box lock
3208 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3208    spill R23 -&gt; R12	# spill size = 64
320c +  spill R18 -&gt; R10	# spill size = 64
3210 +  CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
3240 +  j  B453	#@branch

3244    B455: #	out( N6569 ) &lt;- in( B476 )  Freq: 4.84308e-11
3244     -- 	// exception oop; no code emitted, #@CreateException
3244 +  spill R10 -&gt; [sp, #0]	# spill size = 64
3248 +  li R11, #-75	# int, #@loadConI
324c    spill [sp, #8] -&gt; R8	# spill size = 64
3250    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:24 (line 54) L[0]=#ScObj0 L[1]=_ STK[0]=sp + #0
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [56]=Oop off=12884/0x3254}
3254    #@ShouldNotReachHere

3260    B456: #	out( N6569 ) &lt;- in( B462 )  Freq: 4.90516e-12
3260 +  li R11, #-10	# int, #@loadConI
3264    spill [sp, #8] -&gt; R8	# spill size = 64
3268    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop [64]=Oop off=12908/0x326c}
326c    #@ShouldNotReachHere

3278    B457: #	out( N6569 ) &lt;- in( B464 )  Freq: 4.90515e-12
3278 +  li R11, #-10	# int, #@loadConI
327c    spill [sp, #8] -&gt; R8	# spill size = 64
3280    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:8 (line 434) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop [64]=Oop off=12932/0x3284}
3284    #@ShouldNotReachHere

3290    B458: #	out( N6569 ) &lt;- in( B468 )  Freq: 4.90513e-12
3290 +  li R11, #-12	# int, #@loadConI
3294    spill [sp, #8] -&gt; R8	# spill size = 64
3298    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:6 (line 106) L[0]=sp + #48 L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop off=12956/0x329c}
329c    #@ShouldNotReachHere

32a8    B459: #	out( B473 ) &lt;- in( B478 )  Freq: 2.42036e-12
32a8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
32a8    spill R23 -&gt; R11	# spill size = 64
32ac +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
32dc +  j  B473	#@branch

32e0    B460: #	out( B476 ) &lt;- in( B274 )  Freq: 4.84349e-10
32e0     -- 	// exception oop; no code emitted, #@CreateException
32e0 +  spill R10 -&gt; R11	# spill size = 64
32e4 +  j  B476	#@branch

32e8    B461: #	out( B476 ) &lt;- in( B268 )  Freq: 1.75728e-09
32e8     -- 	// exception oop; no code emitted, #@CreateException
32e8 +  spill R10 -&gt; R11	# spill size = 64
32ec +  j  B476	#@branch

32f0    B462: #	out( B456 B463 ) &lt;- in( B123 )  Freq: 4.84088e-06
32f0     -- 	// exception oop; no code emitted, #@CreateException
32f0 +  mv  R7, java/lang/Class:exact *	# ptr, #@loadConP
3308    spill R10 -&gt; [sp, #64]	# spill size = 64
330c +  lwu  R10, [R7, #116]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/NativeBuffers.threadLocal
3310 +  lwu  R7, [R8, #68]	# loadN, compressed ptr, #@loadN ! Field: java/lang/Thread.threadLocals
3314 +  decode_heap_oop  R31, R10	#@decodeHeapOop
3318 +  decode_heap_oop  R12, R7	#@decodeHeapOop
331c    lw  R28, [R31, #12]	# int, #@loadI ! Field: java/lang/ThreadLocal.threadLocalHashCode (constant)
3320    NullCheck R31

3320    B463: #	out( B489 B464 ) &lt;- in( B462 )  Freq: 4.84087e-06
3320    lwu  R7, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap.table
3324    NullCheck R12

3324    B464: #	out( B457 B465 ) &lt;- in( B463 )  Freq: 4.84087e-06
3324 +  decode_heap_oop  R29, R7	#@decodeHeapOop
3328    lwu  R30, [R29, #12]	# range, #@loadRange
332c    NullCheck R29

332c    B465: #	out( B484 B466 ) &lt;- in( B464 )  Freq: 4.84086e-06
332c +  addiw  R7, R30, #-1	#@addI_reg_imm
3330 +  andr  R7, R28, R7	#@andI_reg_reg
3334 +  addw  R28, R7, zr	#@convI2L_reg_reg
3338 +  slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
333c +  add R28, R29, R28	# ptr, #@addP_reg_reg
3340 +  bleu  R30, zr, B484	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

3344    B466: #	out( B490 B467 ) &lt;- in( B465 )  Freq: 4.84086e-06
3344 +  lwu  R29, [R28, #16]	# loadN, compressed ptr, #@loadN
3348 +  decode_heap_oop  R29, R29	#@decodeHeapOop
334c    lwu  R28, [R29, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
3350    NullCheck R29

3350    B467: #	out( B485 B468 ) &lt;- in( B466 )  Freq: 4.84086e-06
3350    
3350 +  lwu  R30, [R29, #28]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ThreadLocal$ThreadLocalMap$Entry.value
3354 +  decode_heap_oop  R30, R30	#@decodeHeapOop
3358 +  bne  R28, R10, B485	#@cmpN_branch  P=0.000001 C=-1.000000

335c    B468: #	out( B458 B469 ) &lt;- in( B467 )  Freq: 4.84085e-06
335c    lwu  R7, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
3360    NullCheck R30

3360    B469: #	out( B488 B470 ) &lt;- in( B468 )  Freq: 4.84085e-06
3360 +  mv  R29, narrowklass: precise klass [Lsun/nio/fs/NativeBuffer;: 0x00000040d01a3a30:Constant:exact *	# compressed klass ptr, #@loadConNKlass
3370 +  bne  R7, R29, B488	#@cmpN_branch  P=0.000000 C=-1.000000

3374    B470: #	out( B486 B471 ) &lt;- in( B469 )  Freq: 4.84085e-06
3374 +  # checkcastPP of R30, #@checkCastPP
3374    lwu  R7, [R30, #12]	# range, #@loadRange
3378 +  addi  R9, R30, #16	# ptr, #@addP_reg_imm
337c +  bleu  R7, zr, B486	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

3380    B471: #	out( B487 B472 ) &lt;- in( B470 )  Freq: 4.84084e-06
3380 +  lwu  R28, [R9]	# loadN, compressed ptr, #@loadN
3384 +  decode_heap_oop  R8, R28	#@decodeHeapOop
3388 +  bne   R8, zr, B487	#@cmpP_imm0_branch  P=0.000000 C=2869.000000

338c    B472: #	out( B477 B473 ) &lt;- in( B471 )  Freq: 4.84084e-06
338c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
338c    lb  R7, [R23, #56]	# byte, #@loadB
3390 +  bne  R7, zr, B477	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

3394    B473: #	out( B475 B474 ) &lt;- in( B459 B479 B477 B472 )  Freq: 4.84084e-06
3394 +  mv  R7, R9	# ptr -&gt; long, #@castP2X
3398    spill [sp, #48] -&gt; R28	# spill size = 64
339c +  mv  R28, R28	# ptr -&gt; long, #@castP2X
339c +  xorr  R28, R28, R7	#@xorL_reg_reg
33a0 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
33a4    spill [sp, #0] -&gt; R29	# spill size = 32
33a8 +  sw  R29, [R9]	# compressed ptr, #@storeN
33ac +  beq  R28, zr, B475	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

33b0    B474: #	out( B480 B475 ) &lt;- in( B473 )  Freq: 4.836e-06
33b0 +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
33b4 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
33c0 +  add R10, R28, R7	# ptr, #@addP_reg_reg
33c4 +  lb  R28, [R10]	# byte, #@loadB
33c8 +  li R29, #4	# int, #@loadConI
33cc +  bne  R28, R29, B480	#@cmpI_branch  P=0.001000 C=-1.000000

33d0    B475: #	out( B476 ) &lt;- in( B482 B483 B480 B474 B473 )  Freq: 4.84084e-06
33d0 +  spill [sp, #64] -&gt; R11	# spill size = 64

33d4    B476: #	out( B495 B455 ) &lt;- in( B460 B461 B475 )  Freq: 4.84308e-06
33d4    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [56]=Oop off=13272/0x33d8}

33d8    B477: #	out( B473 B478 ) &lt;- in( B472 )  Freq: 4.84078e-09
33d8 +  lwu  R28, [R9]	# loadN, compressed ptr, #@loadN
33dc +  decode_heap_oop  R10, R28	#@decodeHeapOop
33e0 +  beq   R10, zr, B473	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

33e4    B478: #	out( B459 B479 ) &lt;- in( B477 )  Freq: 2.42039e-09
33e4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
33e4    ld  R7, [R23, #32]	# int, #@loadL
33e8 +  beq  R7, zr, B459	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

33ec    B479: #	out( B473 ) &lt;- in( B478 )  Freq: 2.41797e-09
33ec +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
33ec    ld  R28, [R23, #48]	# ptr, #@loadP
33f0 +  add R28, R28, R7	# ptr, #@addP_reg_reg
33f4 +  addi  R7, R7, #-8	#@addL_reg_imm
33f8 +  sd  R10, [R28, #-8]	# ptr, #@storeP
33fc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
33fc    sd  R7, [R23, #32]	# long, #@storeL
3400 +  j  B473	#@branch

3404    B480: #	out( B475 B481 ) &lt;- in( B474 )  Freq: 4.836e-09
3404 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3404    ld  R7, [R23, #64]	# int, #@loadL
3408 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3408    ld  R28, [R23, #80]	# ptr, #@loadP
340c +  #@membar_volatile
	fence iorw iorw
3410 +  lb  R29, [R10]	# byte, #@loadB
3414 +  beq  R29, zr, B475	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

3418    B481: #	out( B483 B482 ) &lt;- in( B480 )  Freq: 2.418e-09
3418 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
341c +  bne  R7, zr, B483	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

3420    B482: #	out( B475 ) &lt;- in( B481 )  Freq: 1.209e-09
3420 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3420    spill R23 -&gt; R11	# spill size = 64
3424 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
3454 +  j  B475	#@branch

3458    B483: #	out( B475 ) &lt;- in( B481 )  Freq: 1.209e-09
3458 +  add R28, R28, R7	# ptr, #@addP_reg_reg
345c +  addi  R7, R7, #-8	#@addL_reg_imm
3460 +  sd  R10, [R28, #-8]	# ptr, #@storeP
3464 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
3464    sd  R7, [R23, #64]	# long, #@storeL
3468 +  j  B475	#@branch

346c    B484: #	out( N6569 ) &lt;- in( B465 )  Freq: 4.84086e-12
346c +  spill [sp, #8] -&gt; R8	# spill size = 64
3470 +  li R11, #-26	# int, #@loadConI
3474    spill R29 -&gt; [sp, #0]	# spill size = 64
3478 +  spill R7 -&gt; [sp, #8]	# spill size = 32
347c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:18 (line 435) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #0 STK[1]=sp + #8
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop [64]=Oop off=13440/0x3480}
3480    #@ShouldNotReachHere

348c    B485: #	out( N6569 ) &lt;- in( B467 )  Freq: 4.84086e-12
348c +  spill [sp, #8] -&gt; R8	# spill size = 64
3490 +  li R11, #-187	# int, #@loadConI
3494    spill R12 -&gt; [sp, #8]	# spill size = 64
3498 +  spill R31 -&gt; [sp, #72]	# spill size = 64
349c +  spill R7 -&gt; [sp, #36]	# spill size = 32
34a0 +  spill R29 -&gt; [sp, #80]	# spill size = 64
34a4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:29 (line 436) L[0]=sp + #8 L[1]=sp + #72 L[2]=sp + #36 L[3]=sp + #80 STK[0]=#0
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #72 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #48 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop [80]=Oop off=13480/0x34a8}
34a8    #@ShouldNotReachHere

34b4    B486: #	out( N6569 ) &lt;- in( B470 )  Freq: 4.84085e-12
34b4 +  li R11, #-26	# int, #@loadConI
34b8    spill [sp, #8] -&gt; R8	# spill size = 64
34bc +  spill R30 -&gt; [sp, #0]	# spill size = 64
34c0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:40 (line 115) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #0 STK[1]=#0
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop [64]=Oop off=13508/0x34c4}
34c4    #@ShouldNotReachHere

34d0    B487: #	out( N6569 ) &lt;- in( B471 )  Freq: 2.42042e-12
34d0 +  spill [sp, #8] -&gt; R7	# spill size = 64
34d4 +  li R11, #-187	# int, #@loadConI
34d8    spill R7 -&gt; [sp, #0]	# spill size = 64
34dc +  spill R30 -&gt; [sp, #8]	# spill size = 64
34e0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:41 (line 115) L[0]=sp + #48 L[1]=sp + #8 L[2]=#0 L[3]=_ STK[0]=R8
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #0 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop off=13540/0x34e4}
34e4    #@ShouldNotReachHere

34f0    B488: #	out( N6569 ) &lt;- in( B469 )  Freq: 1e-35
34f0 +  li R11, #-34	# int, #@loadConI
34f4    spill [sp, #8] -&gt; R8	# spill size = 64
34f8 +  spill R30 -&gt; [sp, #0]	# spill size = 64
34fc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:6 (line 106) L[0]=sp + #48 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #0
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop off=13568/0x3500}
3500    #@ShouldNotReachHere

350c    B489: #	out( N6569 ) &lt;- in( B463 )  Freq: 2.30831e-12
350c +  li R11, #-187	# int, #@loadConI
3510    spill [sp, #8] -&gt; R8	# spill size = 64
3514 +  spill R31 -&gt; [sp, #0]	# spill size = 64
3518 +  spill R12 -&gt; [sp, #72]	# spill size = 64
351c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal::get @ bci:11 (line 164) L[0]=sp + #0 L[1]=_ L[2]=sp + #72 L[3]=_ L[4]=_ STK[0]=sp + #72
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #48 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop off=13600/0x3520}
3520    #@ShouldNotReachHere

352c    B490: #	out( N6569 ) &lt;- in( B466 )  Freq: 2.3083e-12
352c +  spill [sp, #8] -&gt; R8	# spill size = 64
3530 +  li R11, #-187	# int, #@loadConI
3534    spill R12 -&gt; [sp, #8]	# spill size = 64
3538 +  spill R31 -&gt; [sp, #72]	# spill size = 64
353c +  spill R7 -&gt; [sp, #36]	# spill size = 32
3540 +  spill R29 -&gt; [sp, #88]	# spill size = 64
3544    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.ThreadLocal$ThreadLocalMap::getEntry @ bci:21 (line 436) L[0]=sp + #8 L[1]=sp + #72 L[2]=sp + #36 L[3]=sp + #88 STK[0]=sp + #88
        # java.lang.ThreadLocal::get @ bci:16 (line 165) L[0]=sp + #72 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.NativeBuffers::releaseNativeBuffer @ bci:3 (line 106) L[0]=sp + #48 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.NativeBuffer::release @ bci:1 (line 70) L[0]=_
        # sun.nio.fs.UnixNativeDispatcher::lstat @ bci:22 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #64
        # sun.nio.fs.UnixFileAttributes::get @ bci:22 (line 72) L[0]=_ L[1]=_ L[2]=sp + #40
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:15 (line 52) L[0]=#ScObj0 L[1]=_
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop [56]=Oop [64]=Oop [72]=Oop [88]=Oop off=13640/0x3548}
3548    #@ShouldNotReachHere

3554    B491: #	out( N6569 ) &lt;- in( B442 )  Freq: 1.4744e-12
3554     -- 	// exception oop; no code emitted, #@CreateException
3554 +  spill R10 -&gt; [sp, #16]	# spill size = 64
3558 +  li R11, #-75	# int, #@loadConI
355c    spill [sp, #8] -&gt; R8	# spill size = 64
3560    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:84 (line 362) L[0]=sp + #48 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=#NULL L[5]=_ L[6]=_ STK[0]=sp + #16
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [48]=Oop off=13668/0x3564}
3564    #@ShouldNotReachHere

3570    B492: #	out( N6569 ) &lt;- in( B443 )  Freq: 1.3735e-12
3570     -- 	// exception oop; no code emitted, #@CreateException
3570 +  spill R10 -&gt; [sp, #0]	# spill size = 64
3574 +  li R11, #-75	# int, #@loadConI
3578    spill [sp, #8] -&gt; R8	# spill size = 64
357c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:139 (line 302) L[0]=_ L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [56]=Oop off=13696/0x3580}
3580    #@ShouldNotReachHere

358c    B493: #	out( N6569 ) &lt;- in( B443 )  Freq: 1.3735e-12
358c     -- 	// exception oop; no code emitted, #@CreateException
358c +  spill R10 -&gt; [sp, #0]	# spill size = 64
3590 +  li R11, #-75	# int, #@loadConI
3594    spill [sp, #8] -&gt; R8	# spill size = 64
3598    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:155 (line 304) L[0]=_ L[1]=_ L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [56]=Oop off=13724/0x359c}
359c    #@ShouldNotReachHere

35a8    B494: #	out( B496 ) &lt;- in( B449 )  Freq: 4.8433e-15
35a8     -- 	// exception oop; no code emitted, #@CreateException
35a8 +  spill R10 -&gt; R11	# spill size = 64
35ac +  j  B496	#@branch

35b0    B495: #	out( B496 ) &lt;- in( B476 )  Freq: 4.84308e-11
35b0     -- 	// exception oop; no code emitted, #@CreateException
35b0 +  spill R10 -&gt; R11	# spill size = 64

35b4    B496: #	out( B513 B514 ) &lt;- in( B494 B495 )  Freq: 4.84357e-11
35b4    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [56]=Oop off=13752/0x35b8}

35b8    B497: #	out( N6569 ) &lt;- in( B449 )  Freq: 4.8433e-15
35b8     -- 	// exception oop; no code emitted, #@CreateException
35b8 +  spill R10 -&gt; [sp, #0]	# spill size = 64
35bc +  li R11, #-75	# int, #@loadConI
35c0    spill [sp, #8] -&gt; R8	# spill size = 64
35c4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixFileAttributeViews$Basic::readAttributes @ bci:24 (line 54) L[0]=#ScObj0 L[1]=_ STK[0]=sp + #0
        # ScObj0 sun/nio/fs/UnixFileAttributeViews$Basic={ [followLinks :0]=sp + #32, [file :1]=sp + #24 }
        # sun.nio.fs.UnixFileSystemProvider::readAttributes @ bci:57 (line 148) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.LinuxFileSystemProvider::readAttributes @ bci:31 (line 99) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::readAttributes @ bci:7 (line 1851) L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.FileTreeWalker::getAttributes @ bci:56 (line 220) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [56]=Oop off=13768/0x35c8}
35c8    #@ShouldNotReachHere

35d4    B498: #	out( N6569 ) &lt;- in( B453 )  Freq: 5.26543e-16
35d4     -- 	// exception oop; no code emitted, #@CreateException
35d4 +  spill R10 -&gt; [sp, #0]	# spill size = 64
35d8 +  li R11, #-75	# int, #@loadConI
35dc    spill [sp, #8] -&gt; R8	# spill size = 64
35e0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::next @ bci:59 (line 352) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=_ L[5]=_ L[6]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [48]=Oop [56]=Oop off=13796/0x35e4}
35e4    #@ShouldNotReachHere

35f0    B499: #	out( B509 ) &lt;- in( B503 )  Freq: 5.26531e-16
35f0     -- 	// exception oop; no code emitted, #@CreateException
35f0 +  spill R10 -&gt; R9	# spill size = 64
35f4 +  j  B509	#@branch

35f8    B500: #	out( B509 ) &lt;- in( B502 )  Freq: 5.26542e-16
35f8     -- 	// exception oop; no code emitted, #@CreateException
35f8 +  spill R10 -&gt; R9	# spill size = 64
35fc +  j  B509	#@branch

3600    B501: #	out( B512 B502 ) &lt;- in( B403 )  Freq: 5.26543e-11
3600     -- 	// exception oop; no code emitted, #@CreateException
3600 +  spill R8 -&gt; R7	# spill size = 64
3604 +  spill R10 -&gt; [sp, #32]	# spill size = 64
3608 +  beq   R7, zr, B512	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

360c    B502: #	out( B500 B503 ) &lt;- in( B501 )  Freq: 5.26542e-11
360c +  spill R7 -&gt; R11	# spill size = 64
3610    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixDirectoryStream::readLock
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:99 (line 171) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #32
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [32]=Oop [48]=Oop [56]=Oop off=13844/0x3614}

3614    B503: #	out( B499 B504 ) &lt;- in( B502 )  Freq: 5.26531e-11
        # Block is sole successor of call
3614 +  spill R10 -&gt; R11	# spill size = 64
3618    CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.concurrent.locks.Lock::unlock
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:102 (line 171) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #32
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [32]=Oop [48]=Oop [56]=Oop off=13876/0x3634}

3634    B504: #	out( B509 ) &lt;- in( B503 )  Freq: 5.26521e-11
        # Block is sole successor of call
3634 +  spill [sp, #32] -&gt; R9	# spill size = 64
3638 +  j  B509	#@branch

363c    B505: #	out( B507 ) &lt;- in( B270 )  Freq: 4.8981e-10
363c     -- 	// exception oop; no code emitted, #@CreateException
363c +  j  B507	#@branch

3640    B506: #	out( B507 ) &lt;- in( B272 )  Freq: 4.84897e-10
3640     -- 	// exception oop; no code emitted, #@CreateException

3640    B507: #	out( B509 ) &lt;- in( B505 B506 )  Freq: 9.74706e-10
3640 +  spill R10 -&gt; R9	# spill size = 64
3644 +  j  B509	#@branch

3648    B508: #	out( B509 ) &lt;- in( B43 )  Freq: 5.26528e-06
3648     -- 	// exception oop; no code emitted, #@CreateException
3648 +  spill R10 -&gt; R9	# spill size = 64

364c    B509: #	out( B511 B510 ) &lt;- in( B508 B507 B500 B499 B504 )  Freq: 5.26631e-06
364c +  #@membar_release_lock (elided)
364c    add R29, sp, #144	# box lock
3650 +  spill [sp, #0] -&gt; R18	# spill size = 64
3654 +  fastunlock R18,R29	! kills R7, R28, #@cmpFastUnlock
36cc +  far_bne RFLAGS, zr, B511	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

36d4    B510: #	out( B523 B450 ) &lt;- in( B511 B509 )  Freq: 5.26631e-06
36d4 +  spill R9 -&gt; R11	# spill size = 64
36d8    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[0]=Oop [8]=Oop [48]=Oop [56]=Oop off=14044/0x36dc}

36dc    B511: #	out( B510 ) &lt;- in( B509 )  Freq: 5.26631e-12
36dc    add R11, sp, #144	# box lock
36e0 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
36e0    spill R23 -&gt; R12	# spill size = 64
36e4 +  spill [sp, #0] -&gt; R10	# spill size = 64
36e8 +  CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
3718 +  j  B510	#@branch

371c    B512: #	out( N6569 ) &lt;- in( B501 )  Freq: 5.33534e-17
371c +  li R11, #-10	# int, #@loadConI
3720    spill [sp, #8] -&gt; R8	# spill size = 64
3724    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::readNextEntry @ bci:99 (line 171) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #32 STK[0]=#NULL
        # sun.nio.fs.UnixDirectoryStream$UnixDirectoryIterator::hasNext @ bci:16 (line 198) L[0]=sp + #0 STK[0]=sp + #0 MON-BOX0=sp+144 MON-OBJ[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:37 (line 349) L[0]=sp + #48 L[1]=sp + #56 L[2]=_ L[3]=#NULL L[4]=#NULL L[5]=sp + #0 L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [32]=Oop [48]=Oop [56]=Oop off=14120/0x3728}
3728    #@ShouldNotReachHere

3734    B513: #	out( B515 B536 B516 ) &lt;- in( B496 )  Freq: 4.84357e-16
3734     -- 	// exception oop; no code emitted, #@CreateException
3734 +  spill R10 -&gt; R11	# spill size = 64
3738    CALL,static 0x000000401390b840	#@CallStaticJavaDirect wrapper for: _rethrow_Java
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=sp + #8 L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [24]=Oop [56]=Oop off=14140/0x373c}

373c    B514: #	out( N6569 ) &lt;- in( B496 )  Freq: 4.84357e-16
373c     -- 	// exception oop; no code emitted, #@CreateException
373c +  spill R10 -&gt; [sp, #0]	# spill size = 64
3740 +  li R11, #-75	# int, #@loadConI
3744    spill [sp, #8] -&gt; R8	# spill size = 64
3748    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::getAttributes @ bci:63 (line 221) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeWalker::visit @ bci:3 (line 277) L[0]=sp + #16 L[1]=sp + #24 L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [56]=Oop off=14156/0x374c}
374c    #@ShouldNotReachHere

3758    B515: #	out( N6569 ) &lt;- in( B513 )  Freq: 4.84357e-21
3758     -- 	// exception oop; no code emitted, #@CreateException
3758 +  spill R10 -&gt; [sp, #0]	# spill size = 64
375c +  li R11, #-75	# int, #@loadConI
3760    spill [sp, #8] -&gt; R8	# spill size = 64
3764    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:27 (line 280) L[0]=_ L[1]=_ L[2]=#1 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [56]=Oop off=14184/0x3768}
3768    #@ShouldNotReachHere

3774    B516: #	out( B533 ) &lt;- in( B513 )  Freq: 4.84357e-21
3774     -- 	// exception oop; no code emitted, #@CreateException
3774 +  j  B533	#@branch

3778    B517: #	out( B533 ) &lt;- in( B453 )  Freq: 5.26543e-16
3778     -- 	// exception oop; no code emitted, #@CreateException
3778 +  j  B533	#@branch

377c    B518: #	out( B533 ) &lt;- in( B443 )  Freq: 1.3735e-12
377c     -- 	// exception oop; no code emitted, #@CreateException
377c +  j  B533	#@branch

3780    B519: #	out( B533 ) &lt;- in( B442 )  Freq: 1.4744e-12
3780     -- 	// exception oop; no code emitted, #@CreateException
3780 +  j  B533	#@branch

3784    B520: #	out( B533 ) &lt;- in( B319 )  Freq: 1.37362e-11
3784     -- 	// exception oop; no code emitted, #@CreateException
3784 +  j  B533	#@branch

3788    B521: #	out( B533 ) &lt;- in( B317 )  Freq: 1.3737e-11
3788     -- 	// exception oop; no code emitted, #@CreateException
3788 +  j  B533	#@branch

378c    B522: #	out( B533 ) &lt;- in( B315 )  Freq: 1.47459e-11
378c     -- 	// exception oop; no code emitted, #@CreateException
378c +  j  B533	#@branch

3790    B523: #	out( B533 ) &lt;- in( B510 )  Freq: 5.26631e-11
3790     -- 	// exception oop; no code emitted, #@CreateException
3790 +  j  B533	#@branch

3794    B524: #	out( B533 ) &lt;- in( B278 )  Freq: 4.70591e-10
3794     -- 	// exception oop; no code emitted, #@CreateException
3794 +  j  B533	#@branch

3798    B525: #	out( B533 ) &lt;- in( B222 )  Freq: 1.37339e-07
3798     -- 	// exception oop; no code emitted, #@CreateException
3798 +  j  B533	#@branch

379c    B526: #	out( B533 ) &lt;- in( B219 )  Freq: 1.37342e-07
379c     -- 	// exception oop; no code emitted, #@CreateException
379c +  j  B533	#@branch

37a0    B527: #	out( B533 ) &lt;- in( B212 )  Freq: 1.37345e-07
37a0     -- 	// exception oop; no code emitted, #@CreateException
37a0 +  j  B533	#@branch

37a4    B528: #	out( B533 ) &lt;- in( B199 )  Freq: 1.37348e-07
37a4     -- 	// exception oop; no code emitted, #@CreateException
37a4 +  j  B533	#@branch

37a8    B529: #	out( B533 ) &lt;- in( B192 )  Freq: 1.47434e-07
37a8     -- 	// exception oop; no code emitted, #@CreateException
37a8 +  j  B533	#@branch

37ac    B530: #	out( B533 ) &lt;- in( B189 )  Freq: 1.47437e-07
37ac     -- 	// exception oop; no code emitted, #@CreateException
37ac +  j  B533	#@branch

37b0    B531: #	out( B535 ) &lt;- in( B182 )  Freq: 1.52575e-07
37b0     -- 	// exception oop; no code emitted, #@CreateException
37b0 +  spill R10 -&gt; R11	# spill size = 64
37b4 +  j  B535	#@branch

37b8    B532: #	out( B533 ) &lt;- in( B147 )  Freq: 4.70513e-06
37b8     -- 	// exception oop; no code emitted, #@CreateException

37b8    B533: #	out( B535 ) &lt;- in( B523 B517 B519 B530 B522 B529 B516 B518 B521 B528 B527 B526 B520 B525 B524 B532 )  Freq: 5.54994e-06
37b8 +  spill R10 -&gt; R11	# spill size = 64
37bc +  j  B535	#@branch

37c0    B534: #	out( B535 ) &lt;- in( B150 )  Freq: 5.14227e-06
37c0     -- 	// exception oop; no code emitted, #@CreateException
37c0 +  spill R10 -&gt; R11	# spill size = 64

37c4    B535: #	out( N6569 ) &lt;- in( B533 B534 B531 )  Freq: 1.08448e-05
37c4    # pop frame 176
	add  sp, sp, #176
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
3818 +  j rethrow_stub	#@RethrowException

3820    B536: #	out( N6569 ) &lt;- in( B513 )  Freq: 4.84357e-21
3820     -- 	// exception oop; no code emitted, #@CreateException
3820 +  spill R10 -&gt; [sp, #0]	# spill size = 64
3824 +  li R11, #-75	# int, #@loadConI
3828    spill [sp, #8] -&gt; R8	# spill size = 64
382c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::visit @ bci:11 (line 278) L[0]=_ L[1]=sp + #24 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeWalker::next @ bci:134 (line 374) L[0]=sp + #16 L[1]=sp + #56 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # java.nio.file.FileTreeIterator::fetchNextIfNeeded @ bci:11 (line 83) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop [56]=Oop off=14384/0x3830}
3830    #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='322'>
----------------------- MetaData before Compile_id = 322 ------------------------
{method}
 - this oop:          0x00000040961646d0
 - method holder:     &apos;java/util/ImmutableCollections$SetN&apos;
 - constants:         0x00000040961639e8 constant pool [168] {0x00000040961639e8} for &apos;java/util/ImmutableCollections$SetN&apos; cache=0x0000004096164c20
 - access:            0xc1000002  private 
 - name:              &apos;probe&apos;
 - signature:         &apos;(Ljava/lang/Object;)I&apos;
 - max stack:         3
 - max locals:        4
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824bb30: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c4f5000
 - code size:         56
 - code start:        0x0000004096164658
 - code end (excl):   0x0000004096164690
 - method data:       0x00000040965ee138
 - checked ex length: 0
 - linenumber start:  0x0000004096164690
 - localvar length:   4
 - localvar start:    0x000000409616469e
 - compiled code: nmethod  13980  133       3       java.util.ImmutableCollections$SetN::probe (56 bytes)

------------------------ OptoAssembly for Compile_id = 322 -----------------------
#
#  int ( java/util/ImmutableCollections$SetN:NotNull:exact *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/ImmutableCollections$SetN:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N957: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B103 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
03c     spill R11 -&gt; [sp, #8]	# spill size = 64
040 +   spill R12 -&gt; [sp, #16]	# spill size = 64
044     lwu  R28, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
048     NullCheck R12

048     B2: #	out( B68 B3 ) &lt;- in( B1 )  Freq: 0.999999
048 +   mv  R7, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
058     spill R28 -&gt; [sp, #0]	# spill size = 32
05c +   li R11, #1	# int, #@loadConI
060 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
060     bne  R28, R7, B68	#@cmpN_branch  P=0.000977 C=-1.000000

064     B3: #	out( B22 B4 ) &lt;- in( B2 )  Freq: 0.999022
064 +   # checkcastPP of R12, #@checkCastPP
064     lw  R10, [R12, #12]	# int, #@loadI ! Field: java/lang/String.hash
068 +   bne  R10, zr, B22	#@cmpI_reg_imm0_branch  P=0.474144 C=5376.000000

06c     B4: #	out( B70 B5 ) &lt;- in( B3 )  Freq: 0.525342
06c +   lbu  R7, [R12, #17]	# byte, #@loadUB ! Field: java/lang/String.hashIsZero
070 +   li R14, #0	# int, #@loadConI
074 +   bne  R7, zr, B70	#@cmpI_reg_imm0_branch  P=0.001062 C=2826.000000

078     B5: #	out( B94 B6 ) &lt;- in( B4 )  Freq: 0.524784
078 +   lwu  R28, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
07c +   lb  R8, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
080 +   decode_heap_oop  R13, R28	#@decodeHeapOop
084 +   bne  R8, zr, B94	#@cmpI_reg_imm0_branch  P=0.000000 C=51074.000000

088     B6: #	out( B105 B7 ) &lt;- in( B5 )  Freq: 0.524784
088     lwu  R30, [R13, #12]	# range, #@loadRange
08c     NullCheck R13

08c     B7: #	out( B67 B8 ) &lt;- in( B6 )  Freq: 0.524783
08c +   bleu  R30, zr, B67	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.056079 C=18260.000000

090     B8: #	out( B86 B9 ) &lt;- in( B7 )  Freq: 0.495354
090 +   addiw  R7, R30, #-1	#@addI_reg_imm
094 +   bgeu  R7, R30, B86	#@cmpU_branch  P=0.000001 C=-1.000000

098     B9: #	out( B87 B10 ) &lt;- in( B8 )  Freq: 0.495353
098 +   addiw  R15, R30, #-3	#@addI_reg_imm
09c +   li R17, #4000	# int, #@loadConI
0a4 +   lbu  R10, [R13, #16]	# byte, #@loadUB
0a8 +   ble  R15, R11, B87	#@cmpI_branch  P=0.000001 C=-1.000000

0ac     B10: #	out( B88 B11 ) &lt;- in( B9 )  Freq: 0.495353
0ac +   slliw  R28, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0b0 +   subw  R31, R28, R10	#@subI_reg_reg
0b4 +   li R7, #4	# int, #@loadConI
0b8 +   bleu  R30, R11, B88	#@cmpU_branch  P=0.000001 C=-1.000000

0bc     B11: #	out( B89 B12 ) &lt;- in( B10 )  Freq: 0.495352
0bc +   bleu  R30, R7, B89	#@cmpU_branch  P=0.000001 C=-1.000000

0c0     B12: #	out( B13 ) &lt;- in( B11 )  Freq: 0.495352
0c0 +   li R16, #1	# int, #@loadConI

0c4     B13: #	out( B14 ) &lt;- in( B12 B15 ) Loop( B13-B15 ) Freq: 8.83313
0c4 +   subw  R28, R30, R16	#@subI_reg_reg
0c8 +   addiw  R7, R28, #-3	#@addI_reg_imm
0cc     CMove R7, (R15 lt R16), R7, R14	#@cmovI_cmpI
	
0d4 +   CMove R7, (R7 gtu R17), R7, R17	#@cmovI_cmpU
	
0dc +   addw  R18, R7, R16	#@addI_reg_reg

0e0     B14: #	out( B14 B15 ) &lt;- in( B13 B14 ) Loop( B14-B14 inner main of N87 strip mined) Freq: 157.513
0e0 +   addw  R7, R16, zr	#@convI2L_reg_reg
0e4 +   add R7, R13, R7	# ptr, #@addP_reg_reg
0e8 +   lbu  R29, [R7, #16]	# byte, #@loadUB
0ec +   addw  R31, R31, R29	#@addI_reg_reg
0f0 +   lbu  R28, [R7, #17]	# byte, #@loadUB
0f4 +   slliw  R29, R31, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0f8 +   subw  R31, R29, R31	#@subI_reg_reg
0fc +   addw  R28, R31, R28	#@addI_reg_reg
100 +   lbu  R29, [R7, #18]	# byte, #@loadUB
104 +   slliw  R10, R28, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
108 +   lbu  R31, [R7, #19]	# byte, #@loadUB
10c +   subw  R28, R10, R28	#@subI_reg_reg
110 +   addw  R7, R28, R29	#@addI_reg_reg
114 +   slliw  R29, R7, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
118 +   subw  R7, R29, R7	#@subI_reg_reg
11c +   addw  R10, R7, R31	#@addI_reg_reg
120 +   slliw  R28, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
124 +   addiw  R16, R16, #4	#@addI_reg_imm
128 +   subw  R31, R28, R10	#@subI_reg_reg
12c +   blt  R16, R18, B14	#@cmpI_loop  P=0.943921 C=17236.000000

130     B15: #	out( B13 B16 ) &lt;- in( B14 )  Freq: 8.83313
130 +   ld  R7, [R23, #920]	# ptr, #@loadP
134 +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::hashCode @ bci:37 (line 196) L[0]=_ L[1]=R10 L[2]=R13 L[3]=R30 L[4]=R16 L[5]=_
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=R12 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #8 L[1]=R12 L[2]=_ L[3]=_
        # OopMap {c_rarg2=Oop c_rarg3=Oop [8]=Oop [16]=Oop off=308/0x134}
138 +   blt  R16, R15, B13	#@cmpI_branch  P=0.943921 C=17236.000000

13c     B16: #	out( B20 B17 ) &lt;- in( B87 B15 )  Freq: 0.495352
13c +   bge  R16, R30, B20	#@cmpI_branch  P=0.500000 C=-1.000000

140     B17: #	out( B95 B18 ) &lt;- in( B16 )  Freq: 0.247676
140 +   # castII of R16, #@castII
140     bgeu  R16, R30, B95	#@cmpU_branch  P=0.000001 C=-1.000000

144     B18: #	out( B96 B19 ) &lt;- in( B17 )  Freq: 0.247676
144 +   spill R16 -&gt; R28	# spill size = 32
148 +   # castII of R28, #@castII
148     bgeu  R28, R30, B96	#@cmpU_branch  P=0.000001 C=-1.000000

14c     B19: #	out( B19 B20 ) &lt;- in( B18 B19 ) Loop( B19-B19 inner post of N842) Freq: 0.495351
14c +   addw  R7, R16, zr	#@convI2L_reg_reg
150 +   add R7, R13, R7	# ptr, #@addP_reg_reg
154 +   slliw  R29, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
158 +   lbu  R7, [R7, #16]	# byte, #@loadUB
15c +   subw  R28, R29, R10	#@subI_reg_reg
160 +   addiw  R16, R16, #1	#@addI_reg_imm
164 +   addw  R10, R28, R7	#@addI_reg_reg
168 +   blt  R16, R30, B19	#@cmpI_loop  P=0.500000 C=17236.000000

16c     B20: #	out( B67 B21 ) &lt;- in( B19 B16 )  Freq: 0.495352
16c +   beq  R10, zr, B67	#@cmpI_reg_imm0_branch  P=0.000354 C=2823.000000

170     B21: #	out( B22 ) &lt;- in( B20 )  Freq: 0.495176
170 +   sw  R10, [R12, #12]	# int, #@storeI ! Field: java/lang/String.hash

174     B22: #	out( B104 B23 ) &lt;- in( B21 B67 B70 B3 B69 )  Freq: 0.999996
174     spill [sp, #8] -&gt; R7	# spill size = 64
178 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$SetN.elements (constant)
17c +   decode_heap_oop  R29, R28	#@decodeHeapOop
180     lwu  R30, [R29, #12]	# range, #@loadRange
184     NullCheck R29

184     B23: #	out( B83 B24 ) &lt;- in( B22 )  Freq: 0.999995
184 +   bleu  R30, zr, B83	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

188     B24: #	out( B65 B25 ) &lt;- in( B23 )  Freq: 0.999994
188 +   remw  R8, R10, R30	#@modI
18c +   xorr  R7, R8, R30	#@xorI_reg_reg
190 +   blt  R7, zr, B65	#@cmpI_reg_imm0_branch  P=0.127333 C=5411.000000

194     B25: #	out( B82 B26 ) &lt;- in( B24 B66 )  Freq: 0.999994
194 +   addw  R7, R8, zr	#@convI2L_reg_reg
198 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
19c +   add R18, R29, R7	# ptr, #@addP_reg_reg
1a0 +   bgeu  R8, R30, B82	#@cmpU_branch  P=0.000001 C=-1.000000

1a4     B26: #	out( B39 B27 ) &lt;- in( B25 )  Freq: 0.999993
1a4 +   lwu  R7, [R18, #16]	# loadN, compressed ptr, #@loadN
1a8 +   decode_heap_oop  R13, R7	#@decodeHeapOop
1ac +   beq   R13, zr, B39	#@cmpP_imm0_branch  P=0.333442 C=15352.000000

1b0     B27: #	out( B72 B28 ) &lt;- in( B26 )  Freq: 0.666553
1b0 +   mv  R28, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1c0     spill [sp, #0] -&gt; R7	# spill size = 32
1c4 +   bne  R7, R28, B72	#@cmpN_branch  P=0.000098 C=-1.000000

1c8     B28: #	out( B50 B29 ) &lt;- in( B27 )  Freq: 0.666488
1c8 +   spill [sp, #16] -&gt; R12	# spill size = 64
1cc +   lwu  R28, [R13, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
1d0 +   # checkcastPP of R12, #@checkCastPP
1d0     lb  R31, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
1d4 +   mv  R7, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1e4 +   beq  R12, R13, B50	#@cmpP_branch  P=0.000001 C=5338.000000

1e8     B29: #	out( B102 B30 ) &lt;- in( B28 )  Freq: 0.666488
1e8 +   bne  R28, R7, B102	#@cmpN_branch  P=0.000000 C=-1.000000

1ec     B30: #	out( B91 B31 ) &lt;- in( B29 )  Freq: 0.666488
1ec +   # checkcastPP of R13, #@checkCastPP
1ec     lb  R28, [R13, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
1f0 +   bne  R31, R28, B91	#@cmpI_branch  P=0.000000 C=4992.000000

1f4     B31: #	out( B85 B32 ) &lt;- in( B30 )  Freq: 0.666487
1f4 +   lwu  R28, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
1f8 +   decode_heap_oop  R15, R28	#@decodeHeapOop
1fc +   lwu  R10, [R13, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
200 +   beq   R15, zr, B85	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

204     B32: #	out( B84 B33 ) &lt;- in( B31 )  Freq: 0.666487
204 +   decode_heap_oop  R7, R10	#@decodeHeapOop
208 +   lwu  R16, [R15, #12]	# range, #@loadRange
20c +   beq   R7, zr, B84	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

210     B33: #	out( B35 B34 ) &lt;- in( B32 )  Freq: 0.666486
210 +   lwu  R28, [R7, #12]	# range, #@loadRange
214 +   addiw  R17, R8, #1	#@addI_reg_imm
218 +   addi  R9, R15, #16	# ptr, #@addP_reg_imm
21c +   bne  R16, R28, B35	#@cmpI_branch  P=0.001000 C=-1.000000

220     B34: #	out( B63 B35 ) &lt;- in( B33 )  Freq: 0.66582
220 +   spill R16 -&gt; R14	# spill size = 32
224 +   addi  R13, R7, #16	# ptr, #@addP_reg_imm
228     spill R9 -&gt; R11	# spill size = 64
22c +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
2bc +   bne  R10, zr, B63	#@cmpI_reg_imm0_branch  P=0.000000 C=10233.000000

2c0     B35: #	out( B92 B36 ) &lt;- in( B34 B33 )  Freq: 0.666486
2c0 +   beq  R17, R30, B92	#@cmpI_branch  P=0.000000 C=10233.000000

2c4     B36: #	out( B80 B37 ) &lt;- in( B35 )  Freq: 0.666485
2c4 +   bgeu  R17, R30, B80	#@cmpU_branch  P=0.000001 C=-1.000000

2c8     B37: #	out( B40 B38 ) &lt;- in( B36 )  Freq: 0.666485
2c8 +   lwu  R28, [R18, #20]	# loadN, compressed ptr, #@loadN
2cc +   decode_heap_oop  R13, R28	#@decodeHeapOop
2d0 +   bne   R13, zr, B40	#@cmpP_imm0_branch  P=0.666558 C=10233.000000

2d4     B38: #	out( B39 ) &lt;- in( B37 )  Freq: 0.222234
2d4 +   spill R17 -&gt; R8	# spill size = 32

2d8     B39: #	out( N957 ) &lt;- in( B38 B54 B79 B26 )  Freq: 0.999983
2d8 +   li R28, #-1	# int, #@loadConI
2dc +   subw  R10, R28, R8	#@subI_reg_reg
2e0     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
2f8 +   ret	// return register, #@Ret

2fc     B40: #	out( B49 B41 ) &lt;- in( B37 )  Freq: 0.444251
2fc +   lwu  R7, [R13, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
300 +   mv  R10, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
310 +   beq  R12, R13, B49	#@cmpP_branch  P=0.000001 C=5338.000000

314     B41: #	out( B101 B42 ) &lt;- in( B40 )  Freq: 0.44425
314 +   bne  R7, R10, B101	#@cmpN_branch  P=0.000000 C=-1.000000

318     B42: #	out( B90 B43 ) &lt;- in( B41 )  Freq: 0.44425
318 +   # checkcastPP of R13, #@checkCastPP
318     lwu  R7, [R13, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
31c +   lb  R28, [R13, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
320 +   decode_heap_oop  R7, R7	#@decodeHeapOop
324 +   bne  R31, R28, B90	#@cmpI_branch  P=0.000000 C=4992.000000

328     B43: #	out( B85 B44 ) &lt;- in( B42 )  Freq: 0.44425
328 +   beq   R15, zr, B85	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

32c     B44: #	out( B84 B45 ) &lt;- in( B43 )  Freq: 0.44425
32c +   beq   R7, zr, B84	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

330     B45: #	out( B47 B46 ) &lt;- in( B44 )  Freq: 0.444249
330 +   lwu  R28, [R7, #12]	# range, #@loadRange
334 +   addiw  R8, R8, #2	#@addI_reg_imm
338 +   bne  R16, R28, B47	#@cmpI_branch  P=0.001000 C=-1.000000

33c     B46: #	out( B62 B47 ) &lt;- in( B45 )  Freq: 0.443805
33c +   spill R16 -&gt; R14	# spill size = 32
340 +   addi  R13, R7, #16	# ptr, #@addP_reg_imm
344     spill R9 -&gt; R11	# spill size = 64
348 +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
3d8 +   bne  R10, zr, B62	#@cmpI_reg_imm0_branch  P=0.000000 C=10233.000000

3dc     B47: #	out( B93 B48 ) &lt;- in( B46 B45 )  Freq: 0.444249
3dc +   beq  R8, R30, B93	#@cmpI_branch  P=0.000000 C=10233.000000

3e0     B48: #	out( B53 ) &lt;- in( B47 )  Freq: 0.444249
3e0 +   ld  R7, [R23, #920]	# ptr, #@loadP
3e4 +   mv  R18, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
3f4 +   j  B53	#@branch

3f8     B49: #	out( B50 ) &lt;- in( B40 )  Freq: 4.5015e-07
3f8 +   spill R17 -&gt; R8	# spill size = 32

3fc     B50: #	out( B63 ) &lt;- in( B28 B49 B55 )  Freq: 2.02534e-06
3fc +   li R10, #1	# int, #@loadConI
400 +   j  B63	#@branch
        nop 	# 6 bytes pad for loops and calls

410     B51: #	out( B93 B52 ) &lt;- in( B60 B59 ) top-of-loop Freq: 0.888052
410 +   addiw  R8, R8, #1	#@addI_reg_imm
414 +   beq  R8, R30, B93	#@cmpI_branch  P=0.000000 C=10233.000000

418     B52: #	out( B53 ) &lt;- in( B51 )  Freq: 0.888052
418 +   ld  R7, [R23, #920]	# ptr, #@loadP

41c     B53: #	out( B81 B54 ) &lt;- in( B48 B52 ) Loop( B53-B52 inner partial_peel ) Freq: 1.3323
41c +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.util.ImmutableCollections$SetN::probe @ bci:53 (line 1017) L[0]=sp + #8 L[1]=sp + #16 L[2]=R8 L[3]=_
        # OopMap {x29=Oop c_rarg2=Oop c_rarg5=Oop x9=Derived_oop_c_rarg5 [8]=Oop [16]=Oop off=1052/0x41c}
420 +   addw  R7, R8, zr	#@convI2L_reg_reg
424 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
428 +   add R7, R29, R7	# ptr, #@addP_reg_reg
42c +   bgeu  R8, R30, B81	#@cmpU_branch  P=0.000001 C=-1.000000

430     B54: #	out( B39 B55 ) &lt;- in( B53 )  Freq: 1.3323
430 +   lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN
434 +   decode_heap_oop  R13, R7	#@decodeHeapOop
438 +   beq   R13, zr, B39	#@cmpP_imm0_branch  P=0.333442 C=10233.000000

43c     B55: #	out( B50 B56 ) &lt;- in( B54 )  Freq: 0.888055
43c +   lwu  R28, [R13, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
440 +   beq  R12, R13, B50	#@cmpP_branch  P=0.000001 C=5338.000000

444     B56: #	out( B102 B57 ) &lt;- in( B55 )  Freq: 0.888054
444 +   bne  R28, R18, B102	#@cmpN_branch  P=0.000000 C=-1.000000

448     B57: #	out( B91 B58 ) &lt;- in( B56 )  Freq: 0.888054
448 +   # checkcastPP of R13, #@checkCastPP
448     lwu  R7, [R13, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
44c +   lb  R28, [R13, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
450 +   decode_heap_oop  R7, R7	#@decodeHeapOop
454 +   bne  R31, R28, B91	#@cmpI_branch  P=0.000000 C=4992.000000

458     B58: #	out( B84 B59 ) &lt;- in( B57 )  Freq: 0.888053
458 +   beq   R7, zr, B84	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

45c     B59: #	out( B51 B60 ) &lt;- in( B58 )  Freq: 0.888052
45c +   lwu  R10, [R7, #12]	# range, #@loadRange
460 +   bne  R16, R10, B51	#@cmpI_branch  P=0.001000 C=-1.000000

464     B60: #	out( B51 B61 ) &lt;- in( B59 )  Freq: 0.887164
464 +   spill R16 -&gt; R14	# spill size = 32
468 +   addi  R13, R7, #16	# ptr, #@addP_reg_imm
46c     spill R9 -&gt; R11	# spill size = 64
470 +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
500 +   beq  R10, zr, B51	#@cmpI_reg_imm0_branch  P=1.000000 C=10233.000000

504     B61: #	out( B62 ) &lt;- in( B60 )  Freq: 4.23033e-07
504 +   spill R8 -&gt; R17	# spill size = 32

508     B62: #	out( B63 ) &lt;- in( B46 B61 )  Freq: 6.34656e-07
508 +   spill R17 -&gt; R8	# spill size = 32

50c     B63: #	out( B64 ) &lt;- in( B50 B34 B62 )  Freq: 2.97748e-06
50c +   spill R10 -&gt; [sp, #0]	# spill size = 32

510     B64: #	out( N957 ) &lt;- in( B63 B99 )  Freq: 2.97757e-06
510 +   li R11, #-187	# int, #@loadConI
514     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:34 (line 1012) L[0]=sp + #8 L[1]=sp + #16 L[2]=R8 L[3]=_ STK[0]=sp + #0
        # OopMap {[8]=Oop [16]=Oop off=1304/0x518}
518     #@ShouldNotReachHere

524     B65: #	out( B97 B66 ) &lt;- in( B24 )  Freq: 0.127332
524 +   addw  R28, R8, R30	#@addI_reg_reg
528 +   beq  R8, zr, B97	#@cmpI_reg_imm0_branch  P=0.000000 C=689.000000

52c     B66: #	out( B25 ) &lt;- in( B65 )  Freq: 0.127332
52c +   spill R28 -&gt; R8	# spill size = 32
530 +   j  B25	#@branch

534     B67: #	out( B22 ) &lt;- in( B20 B7 )  Freq: 0.0296047
534 +   sb  R11, [R12, #17]	# byte, #@storeB ! Field: java/lang/String.hashIsZero
538 +   li R10, #0	# int, #@loadConI
53c +   j  B22	#@branch

540     B68: #	out( B107 B69 ) &lt;- in( B2 )  Freq: 0.00097674
540 +   spill R12 -&gt; R11	# spill size = 64
544 +   spill R12 -&gt; R8	# spill size = 64
548     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #8 L[1]=R8 L[2]=_ L[3]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=1380/0x564}

564     B69: #	out( B22 ) &lt;- in( B68 )  Freq: 0.000976721
        # Block is sole successor of call
564 +   j  B22	#@branch

568     B70: #	out( B22 ) &lt;- in( B4 )  Freq: 0.000557687
568 +   li R10, #0	# int, #@loadConI
56c +   j  B22	#@branch

570     B71: #	out( B73 ) &lt;- in( B78 ) top-of-loop Freq: 0.000130245
570 +   spill R10 -&gt; R8	# spill size = 32
574 +   j  B73	#@branch

578     B72: #	out( B73 ) &lt;- in( B27 )  Freq: 6.51567e-05
578 +   spill R13 -&gt; R12	# spill size = 64

57c     B73: #	out( B106 B74 ) &lt;- in( B72 B71 ) Loop( B73-B71 inner ) Freq: 0.000195403
57c +   spill [sp, #16] -&gt; R11	# spill size = 64
580     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::equals
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=sp + #8 L[1]=sp + #16 L[2]=R8 L[3]=_
        # OopMap {[8]=Oop [16]=Oop off=1436/0x59c}

59c     B74: #	out( B99 B75 ) &lt;- in( B73 )  Freq: 0.000195399
        # Block is sole successor of call
59c +   spill [sp, #8] -&gt; R7	# spill size = 64
5a0 +   lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$SetN.elements (constant)
5a4 +   decode_heap_oop  R29, R7	#@decodeHeapOop
5a8 +   bne  R10, zr, B99	#@cmpI_reg_imm0_branch  P=0.000000 C=10233.000000

5ac     B75: #	out( B109 B76 ) &lt;- in( B74 )  Freq: 0.000195399
5ac     lwu  R30, [R29, #12]	# range, #@loadRange
5b0     NullCheck R29

5b0     B76: #	out( B100 B77 ) &lt;- in( B75 )  Freq: 0.000195399
5b0 +   addiw  R10, R8, #1	#@addI_reg_imm
5b4 +   beq  R10, R30, B100	#@cmpI_branch  P=0.000000 C=10233.000000

5b8     B77: #	out( B98 B78 ) &lt;- in( B76 )  Freq: 0.000195399
5b8 +   ld  R31, [R23, #920]	# ptr, #@loadP
5bc     spill [sp, #8] -&gt; R7	# spill size = 64
5c0 +   lwu zr, [R31]	# Safepoint: poll for GC, #@safePoint        # java.util.ImmutableCollections$SetN::probe @ bci:53 (line 1017) L[0]=R7 L[1]=sp + #16 L[2]=R10 L[3]=_
        # OopMap {t2=Oop x29=Oop [8]=Oop [16]=Oop off=1472/0x5c0}
5c4 +   bgeu  R10, R30, B98	#@cmpU_branch  P=0.000001 C=-1.000000

5c8     B78: #	out( B71 B79 ) &lt;- in( B77 )  Freq: 0.000195399
5c8 +   addw  R7, R8, zr	#@convI2L_reg_reg
5cc +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
5d0 +   add R7, R29, R7	# ptr, #@addP_reg_reg
5d4 +   lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN
5d8 +   decode_heap_oop  R12, R7	#@decodeHeapOop
5dc +   bne   R12, zr, B71	#@cmpP_imm0_branch  P=0.666558 C=10233.000000

5e0     B79: #	out( B39 ) &lt;- in( B78 )  Freq: 6.51541e-05
5e0 +   spill R10 -&gt; R8	# spill size = 32
5e4 +   j  B39	#@branch

5e8     B80: #	out( B81 ) &lt;- in( B36 )  Freq: 6.75336e-07
5e8 +   spill R17 -&gt; R8	# spill size = 32

5ec     B81: #	out( N957 ) &lt;- in( B80 B53 B98 )  Freq: 2.02553e-06
5ec +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
5f4 +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
5fc +   li R11, #-28	# int, #@loadConI
600     spill R29 -&gt; [sp, #16]	# spill size = 64
604     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:18 (line 1009) L[0]=sp + #0 L[1]=sp + #8 L[2]=R8 L[3]=_ STK[0]=sp + #16 STK[1]=R8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=1544/0x608}
608     #@ShouldNotReachHere

614     B82: #	out( N957 ) &lt;- in( B25 )  Freq: 1.01327e-06
614 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
61c +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
624 +   li R11, #-28	# int, #@loadConI
628     spill R29 -&gt; [sp, #16]	# spill size = 64
62c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:18 (line 1009) L[0]=sp + #0 L[1]=sp + #8 L[2]=R8 L[3]=_ STK[0]=sp + #16 STK[1]=R8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=1584/0x630}
630     #@ShouldNotReachHere

63c     B83: #	out( N957 ) &lt;- in( B23 )  Freq: 9.99995e-07
63c +   li R11, #-122	# int, #@loadConI
640     spill R10 -&gt; R8	# spill size = 32
644     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;div0_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.Math::floorMod @ bci:2 (line 1342) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8 STK[1]=#0
        # java.util.ImmutableCollections$SetN::probe @ bci:9 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=1608/0x648}
648     #@ShouldNotReachHere

654     B84: #	out( N957 ) &lt;- in( B32 B58 B44 )  Freq: 2.02533e-06
654     #@ShouldNotReachHere

660     B85: #	out( N957 ) &lt;- in( B31 B43 )  Freq: 1.12549e-06
660     #@ShouldNotReachHere

66c     B86: #	out( N957 ) &lt;- in( B8 )  Freq: 5.01932e-07
66c +   spill [sp, #8] -&gt; R8	# spill size = 64
670 +   li R11, #-138	# int, #@loadConI
674     spill R12 -&gt; [sp, #8]	# spill size = 64
678 +   spill R13 -&gt; [sp, #16]	# spill size = 64
67c +   spill R30 -&gt; [sp, #28]	# spill size = 32
680     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:13 (line 196) L[0]=_ L[1]=#0 L[2]=sp + #16 L[3]=sp + #28 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=sp + #28
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=sp + #8 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=1668/0x684}
684     #@ShouldNotReachHere

690     B87: #	out( B16 ) &lt;- in( B9 )  Freq: 5.01931e-07
690 +   li R16, #1	# int, #@loadConI
694 +   j  B16	#@branch

698     B88: #	out( N957 ) &lt;- in( B10 )  Freq: 4.95353e-07
698     #@ShouldNotReachHere

6a4     B89: #	out( N957 ) &lt;- in( B11 )  Freq: 4.95352e-07
6a4     #@ShouldNotReachHere

6b0     B90: #	out( B91 ) &lt;- in( B42 )  Freq: 2.22125e-07
6b0 +   spill R17 -&gt; R8	# spill size = 32

6b4     B91: #	out( N957 ) &lt;- in( B30 B90 B57 )  Freq: 9.99396e-07
6b4 +   li R11, #-187	# int, #@loadConI
6b8     spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
6c0 +   spill R12 -&gt; [sp, #16]	# spill size = 64
6c4 +   spill R13 -&gt; [sp, #24]	# spill size = 64
6c8 +   spill R31 -&gt; [sp, #32]	# spill size = 32
6cc +   spill R28 -&gt; [sp, #36]	# spill size = 32
6d0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #16 L[1]=_ L[2]=sp + #24 STK[0]=sp + #32 STK[1]=sp + #36
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=sp + #0 L[1]=sp + #16 L[2]=R8 L[3]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop off=1748/0x6d4}
6d4     #@ShouldNotReachHere

6e0     B92: #	out( B93 ) &lt;- in( B35 )  Freq: 3.17805e-07
6e0 +   spill R17 -&gt; R8	# spill size = 32

6e4     B93: #	out( N957 ) &lt;- in( B92 B47 B51 B100 )  Freq: 9.53189e-07
6e4 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
6ec +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
6f4 +   li R11, #-187	# int, #@loadConI
6f8     spill R30 -&gt; [sp, #20]	# spill size = 32
6fc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:48 (line 1014) L[0]=sp + #0 L[1]=sp + #8 L[2]=R8 L[3]=_ STK[0]=R8 STK[1]=sp + #20
        # OopMap {[0]=Oop [8]=Oop off=1792/0x700}
700     #@ShouldNotReachHere

70c     B94: #	out( N957 ) &lt;- in( B5 )  Freq: 2.62392e-07
70c +   li R11, #-187	# int, #@loadConI
710     spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
718 +   spill R12 -&gt; [sp, #16]	# spill size = 64
71c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=R8
        # java.lang.String::hashCode @ bci:17 (line 2337) L[0]=sp + #16 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # OopMap {[0]=Oop [16]=Oop off=1824/0x720}
720     #@ShouldNotReachHere

72c     B95: #	out( N957 ) &lt;- in( B17 )  Freq: 2.50965e-07
72c     #@ShouldNotReachHere

738     B96: #	out( N957 ) &lt;- in( B18 )  Freq: 2.50965e-07
738     #@ShouldNotReachHere

744     B97: #	out( N957 ) &lt;- in( B65 )  Freq: 6.07169e-08
744 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
74c +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
754 +   li R11, #-187	# int, #@loadConI
758     spill R30 -&gt; [sp, #16]	# spill size = 32
75c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.Math::floorMod @ bci:11 (line 1344) L[0]=_ L[1]=sp + #16 L[2]=R8 STK[0]=R8
        # java.util.ImmutableCollections$SetN::probe @ bci:9 (line 1007) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=_
        # OopMap {[0]=Oop [8]=Oop off=1888/0x760}
760     #@ShouldNotReachHere

76c     B98: #	out( B81 ) &lt;- in( B77 )  Freq: 1.97994e-10
76c +   spill R10 -&gt; R8	# spill size = 32
770 +   j  B81	#@branch

774     B99: #	out( B64 ) &lt;- in( B74 )  Freq: 9.31737e-11
774 +   spill R10 -&gt; [sp, #0]	# spill size = 32
778 +   j  B64	#@branch

77c     B100: #	out( B93 ) &lt;- in( B76 )  Freq: 9.31735e-11
77c +   spill R10 -&gt; R8	# spill size = 32
780 +   j  B93	#@branch

784     B101: #	out( B102 ) &lt;- in( B41 )  Freq: 1e-35
784 +   spill R17 -&gt; R8	# spill size = 32

788     B102: #	out( N957 ) &lt;- in( B29 B101 B56 )  Freq: 1e-35
788 +   li R11, #-34	# int, #@loadConI
78c     spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
794 +   spill R12 -&gt; [sp, #16]	# spill size = 64
798 +   spill R13 -&gt; [sp, #32]	# spill size = 64
79c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #16 L[1]=sp + #32 L[2]=_ STK[0]=sp + #32
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=sp + #0 L[1]=sp + #16 L[2]=R8 L[3]=_
        # OopMap {[0]=Oop [16]=Oop [32]=Oop off=1952/0x7a0}
7a0     #@ShouldNotReachHere

7ac     B103: #	out( N957 ) &lt;- in( B1 )  Freq: 1.01328e-06
7ac +   li R11, #-10	# int, #@loadConI
7b0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # OopMap {off=1972/0x7b4}
7b4     #@ShouldNotReachHere

7c0     B104: #	out( N957 ) &lt;- in( B22 )  Freq: 1.01328e-06
7c0 +   li R11, #-10	# int, #@loadConI
7c4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:8 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=1992/0x7c8}
7c8     #@ShouldNotReachHere

7d4     B105: #	out( N957 ) &lt;- in( B6 )  Freq: 5.31752e-07
7d4 +   li R11, #-10	# int, #@loadConI
7d8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:5 (line 196) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=_ L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=2012/0x7dc}
7dc     #@ShouldNotReachHere

7e8     B106: #	out( B108 ) &lt;- in( B73 )  Freq: 1.95403e-09
7e8      -- 	// exception oop; no code emitted, #@CreateException
7e8 +   spill R10 -&gt; R11	# spill size = 64
7ec +   j  B108	#@branch

7f0     B107: #	out( B108 ) &lt;- in( B68 )  Freq: 9.7674e-09
7f0      -- 	// exception oop; no code emitted, #@CreateException
7f0 +   spill R10 -&gt; R11	# spill size = 64

7f4     B108: #	out( N957 ) &lt;- in( B107 B106 )  Freq: 1.17214e-08
7f4     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
800 +   j rethrow_stub	#@RethrowException

808     B109: #	out( N957 ) &lt;- in( B75 )  Freq: 1.97994e-10
808 +   li R11, #-10	# int, #@loadConI
80c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:47 (line 1014) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=2064/0x810}
810     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='323'>
----------------------- MetaData before Compile_id = 323 ------------------------
{method}
 - this oop:          0x00000040961e96b0
 - method holder:     &apos;java/lang/CharacterDataLatin1&apos;
 - constants:         0x00000040961e89b8 constant pool [130] {0x00000040961e89b8} for &apos;java/lang/CharacterDataLatin1&apos; cache=0x00000040961eb818
 - access:            0x81000000  
 - name:              &apos;isJavaIdentifierStart&apos;
 - signature:         &apos;(I)Z&apos;
 - max stack:         3
 - max locals:        3
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      27
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b960: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c4fdd00
 - code size:         23
 - code start:        0x00000040961e9668
 - code end (excl):   0x00000040961e967f
 - method data:       0x0000004096482808
 - checked ex length: 0
 - linenumber start:  0x00000040961e967f
 - localvar length:   3
 - localvar start:    0x00000040961e968a
 - compiled code: nmethod  14027  157       3       java.lang.CharacterDataLatin1::isJavaIdentifierStart (23 bytes)

------------------------ OptoAssembly for Compile_id = 323 -----------------------
#
#  bool ( java/lang/CharacterDataLatin1:NotNull *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/CharacterDataLatin1:NotNull *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N51: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B4 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     li R28, #65535	# int, #@loadConI
044 +   andr  R28, R12, R28	#@andI_reg_reg
048 +   addw  R7, R28, zr	#@convI2L_reg_reg
04c +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
050 +   mv  R29, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1157 address=0x00000040d07cfa00&gt; *	# ptr, #@loadConP
068 +   add R7, R29, R7	# ptr, #@addP_reg_reg
06c +   li R29, #256	# int, #@loadConI
070 +   bgeu  R28, R29, B4	#@cmpU_branch  P=0.000001 C=-1.000000

074     B2: #	out( B5 B3 ) &lt;- in( B1 )  Freq: 0.999999
074 +   lw  R28, [R7, #16]	# int, #@loadI
078 +   li R7, #28672	# int, #@loadConI
07c +   andr  R8, R28, R7	#@andI_reg_reg
080 +   li R7, #20480	# int, #@loadConI
084 +   blt  R8, R7, B5	#@cmpI_branch  P=0.000000 C=5375.000000

088     B3: #	out( N51 ) &lt;- in( B2 )  Freq: 0.999999
088 +   li R10, #1	# int, #@loadConI
08c     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0a4 +   ret	// return register, #@Ret

0a8     B4: #	out( N51 ) &lt;- in( B1 )  Freq: 1.01328e-06
0a8 +   li R11, #-28	# int, #@loadConI
0ac     spill R28 -&gt; R8	# spill size = 32
0b0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.CharacterDataLatin1::getProperties @ bci:7 (line 74) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#Ptr0x00000040d07cfa00 STK[1]=R8
        # java.lang.CharacterDataLatin1::isJavaIdentifierStart @ bci:2 (line 115) L[0]=_ L[1]=_ L[2]=_
        # OopMap {off=180/0xb4}
0b4     #@ShouldNotReachHere

0c0     B5: #	out( N51 ) &lt;- in( B2 )  Freq: 4.99999e-07
0c0 +   li R11, #-187	# int, #@loadConI
0c4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.CharacterDataLatin1::isJavaIdentifierStart @ bci:14 (line 116) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8 STK[1]=#20480
        # OopMap {off=200/0xc8}
0c8 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='324'>
----------------------- MetaData before Compile_id = 324 ------------------------
{method}
 - this oop:          0x0000004096503df8
 - method holder:     &apos;java/util/concurrent/locks/ReentrantReadWriteLock$Sync&apos;
 - constants:         0x0000004096503508 constant pool [193] {0x0000004096503508} for &apos;java/util/concurrent/locks/ReentrantReadWriteLock$Sync&apos; cache=0x0000004096509398
 - access:            0x81000008  static 
 - name:              &apos;exclusiveCount&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         3
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b790: 0xa i2c: 0x00000040139d7540 c2i: 0x00000040139d7584 c2iUV: 0x00000040139d7550
 - compiled entry     0x000000400c508ec0
 - code size:         5
 - code start:        0x0000004096503de0
 - code end (excl):   0x0000004096503de5
 - method data:       0x0000004096487b18
 - checked ex length: 0
 - linenumber start:  0x0000004096503de5
 - localvar length:   1
 - localvar start:    0x0000004096503dea
 - compiled code: nmethod  14051  182       3       java.util.concurrent.locks.ReentrantReadWriteLock$Sync::exclusiveCount (5 bytes)

------------------------ OptoAssembly for Compile_id = 324 -----------------------
#
#  int ( int )
#
#r012 c_rarg1   : parm 0: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N1: #	out( B1 ) &lt;- in( B1 )  Freq: 1

000     B1: #	out( N1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
01c     li R7, #65535	# int, #@loadConI
024 +   andr  R10, R11, R7	#@andI_reg_reg
028     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
040 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='327'>
----------------------- MetaData before Compile_id = 327 ------------------------
{method}
 - this oop:          0x00000040965e8a98
 - method holder:     &apos;jdk/internal/module/Checks&apos;
 - constants:         0x00000040965e7798 constant pool [250] {0x00000040965e7798} for &apos;jdk/internal/module/Checks&apos; cache=0x00000040965e8ce8
 - access:            0xc100000a  private static 
 - name:              &apos;isJavaIdentifier&apos;
 - signature:         &apos;(Ljava/lang/String;)Z&apos;
 - max stack:         3
 - max locals:        4
 - size of params:    1
 - method size:       13
 - highest level:     4
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c574480
 - code size:         76
 - code start:        0x00000040965e8a08
 - code end (excl):   0x00000040965e8a54
 - method data:       0x0000004096482320
 - checked ex length: 0
 - linenumber start:  0x00000040965e8a54
 - localvar length:   4
 - localvar start:    0x00000040965e8a66
 - compiled code: nmethod  14248  321       3       jdk.internal.module.Checks::isJavaIdentifier (76 bytes)

------------------------ OptoAssembly for Compile_id = 327 -----------------------
#
#  bool ( java/lang/String:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:exact *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B41 B42 B35 B36 B33 B43 B37 B40 B34 B30 B32 B39 B28 B31 B38 )  Freq: 1

000     B1: #	out( B41 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
01c     spill R11 -&gt; [sp, #0]	# spill size = 64
020     lwu  R28, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
024     NullCheck R11

024     B2: #	out( B42 B3 ) &lt;- in( B1 )  Freq: 0.999999
024 +   decode_heap_oop  R7, R28	#@decodeHeapOop
028     lwu  R8, [R7, #12]	# range, #@loadRange
02c     NullCheck R7

02c     B3: #	out( B35 B4 ) &lt;- in( B2 )  Freq: 0.999998
02c +   bleu  R8, zr, B35	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=8567.000000

030     B4: #	out( B40 B5 ) &lt;- in( B3 )  Freq: 0.999997
030 +   mv  R11, java/util/ImmutableCollections$SetN:exact *	# ptr, #@loadConP
048     spill [sp, #0] -&gt; R12	# spill size = 64
04c     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.ImmutableCollections$SetN::probe
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=80/0x50}

050     B5: #	out( B36 B6 ) &lt;- in( B4 )  Freq: 0.999977
        # Block is sole successor of call
050 +   spill [sp, #0] -&gt; R7	# spill size = 64
054 +   lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
058 +   spill [sp, #0] -&gt; R28	# spill size = 64
05c +   lb  R30, [R28, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
060 +   decode_heap_oop  R14, R7	#@decodeHeapOop
064 +   bge  R10, zr, B36	#@cmpI_reg_imm0_branch  P=0.000000 C=8452.000000

068     B6: #	out( B33 B7 ) &lt;- in( B5 )  Freq: 0.999977
068 +   bne  R30, zr, B33	#@cmpI_reg_imm0_branch  P=0.000000 C=56642.000000

06c     B7: #	out( B43 B8 ) &lt;- in( B6 )  Freq: 0.999977
06c     lwu  R12, [R14, #12]	# range, #@loadRange
070     NullCheck R14

070     B8: #	out( B37 B9 ) &lt;- in( B7 )  Freq: 0.999976
070 +   bleu  R12, zr, B37	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=30867.000000

074     B9: #	out( B34 B10 ) &lt;- in( B8 )  Freq: 0.999975
074 +   lbu  R29, [R14, #16]	# byte, #@loadUB
078 +   addw  R7, R29, zr	#@convI2L_reg_reg
07c +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
080 +   mv  R11, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1215 address=0x00000040d053c530&gt; *	# ptr, #@loadConP
098 +   add R7, R11, R7	# ptr, #@addP_reg_reg
09c +   lw  R28, [R7, #16]	# int, #@loadI
0a0 +   li R7, #28672	# int, #@loadConI
0a4 +   andr  R8, R28, R7	#@andI_reg_reg
0a8 +   li R28, #20480	# int, #@loadConI
0ac +   sraw  R13, R12, R30	#@rShiftI_reg_reg
0b0 +   li R10, #1	# int, #@loadConI
0b4 +   blt  R8, R28, B34	#@cmpI_branch  P=0.000000 C=5376.000000

0b8     B10: #	out( B28 B11 ) &lt;- in( B9 )  Freq: 0.999975
0b8 +   ble  R13, R10, B28	#@cmpI_branch  P=0.216418 C=37848.000000

0bc     B11: #	out( B30 B12 ) &lt;- in( B10 )  Freq: 0.783562
0bc +   bleu  R12, R10, B30	#@cmpU_branch  P=0.000001 C=-1.000000

0c0     B12: #	out( B30 B13 ) &lt;- in( B11 )  Freq: 0.783561
0c0 +   li R7, #-2147483648	# int, #@loadConI
0c4 +   addiw  R15, R13, #-1	#@addI_reg_imm
0c8     CMove R15, (R13 lt R15), R15, R7	#@cmovI_cmpI
	
0d0 +   addw  R28, R13, zr	#@convI2L_reg_reg
0d4 +   addw  R30, R12, zr	#@convI2L_reg_reg
0d8 +   addi  R28, R28, #-1	#@addL_reg_imm
0dc +   li R7, #2	# int, #@loadConI
0e0 +   li R29, #0	# int, #@loadConI
0e4 +   bgeu  R28, R30, B30	#@cmpUL_branch  P=0.000001 C=-1.000000

0e8     B13: #	out( B29 B14 ) &lt;- in( B12 )  Freq: 0.78356
0e8 +   lbu  R30, [R14, #17]	# byte, #@loadUB2L
0ec +   slli  R30, R30, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0f0 +   add R30, R11, R30	# ptr, #@addP_reg_reg
0f4 +   lw  R30, [R30, #16]	# int, #@loadI
0f8 +   li R31, #12288	# int, #@loadConI
0fc +   andr  R16, R30, R31	#@andI_reg_reg
100 +   li R28, #2000	# int, #@loadConI
104 +   beq  R16, zr, B29	#@cmpI_reg_imm0_branch  P=0.000034 C=29658.000000

108     B14: #	out( B23 B15 ) &lt;- in( B13 )  Freq: 0.783534
108 +   ble  R15, R7, B23	#@cmpI_branch  P=0.000001 C=-1.000000

10c     B15: #	out( B31 B16 ) &lt;- in( B14 )  Freq: 0.783533
10c +   li R30, #3	# int, #@loadConI
110 +   bleu  R12, R7, B31	#@cmpU_branch  P=0.000001 C=-1.000000

114     B16: #	out( B32 B17 ) &lt;- in( B15 )  Freq: 0.783532
114 +   bleu  R12, R30, B32	#@cmpU_branch  P=0.000001 C=-1.000000

118     B17: #	out( B18 ) &lt;- in( B16 )  Freq: 0.783531
118 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP

118     B18: #	out( B19 ) &lt;- in( B17 B22 ) Loop( B18-B22 ) Freq: 3.61637
118 +   subw  R16, R15, R7	#@subI_reg_reg
11c     CMove R16, (R15 lt R7), R16, R29	#@cmovI_cmpI
	
124 +   CMove R16, (R16 gtu R28), R16, R28	#@cmovI_cmpU
	
12c +   addw  R17, R16, R7	#@addI_reg_reg

130     B19: #	out( B29 B20 ) &lt;- in( B18 B21 ) Loop( B19-B21 inner main of N176 strip mined) Freq: 16.706
130 +   addw  R30, R7, zr	#@convI2L_reg_reg
134 +   add R30, R14, R30	# ptr, #@addP_reg_reg
138 +   lbu  R16, [R30, #16]	# byte, #@loadUB2L
13c +   lbu  R30, [R30, #17]	# byte, #@loadUB2L
140 +   slli  R16, R16, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
144 +   slli  R30, R30, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
148 +   add R16, R11, R16	# ptr, #@addP_reg_reg
14c +   add R30, R11, R30	# ptr, #@addP_reg_reg
150 +   lw  R9, [R16, #16]	# int, #@loadI
154 +   lw  R30, [R30, #16]	# int, #@loadI
158 +   andr  R9, R9, R31	#@andI_reg_reg
15c +   andr  R30, R30, R31	#@andI_reg_reg
160 +   beq  R9, zr, B29	#@cmpI_reg_imm0_branch  P=0.000034 C=29658.000000

164     B20: #	out( B29 B21 ) &lt;- in( B19 )  Freq: 16.7054
164 +   beq  R30, zr, B29	#@cmpI_reg_imm0_branch  P=0.000034 C=29658.000000

168     B21: #	out( B19 B22 ) &lt;- in( B20 )  Freq: 16.7049
168 +   addiw  R7, R7, #2	#@addI_reg_imm
16c +   blt  R7, R17, B19	#@cmpI_loop  P=0.783582 C=29657.000000

170     B22: #	out( B18 B23 ) &lt;- in( B21 )  Freq: 3.61524
170 +   ld  R30, [R23, #920]	# ptr, #@loadP
174 +   lwu zr, [R30]	# Safepoint: poll for GC, #@safePoint        # jdk.internal.module.Checks::isJavaIdentifier @ bci:71 (line 185) L[0]=sp + #0 L[1]=_ L[2]=R7 L[3]=_
        # OopMap {c_rarg1=Oop c_rarg4=Oop [0]=Oop off=372/0x174}
178 +   blt  R7, R15, B18	#@cmpI_branch  P=0.783582 C=29657.000000

17c     B23: #	out( B28 B24 ) &lt;- in( B14 B22 )  Freq: 0.782405
17c +   bge  R7, R13, B28	#@cmpI_branch  P=0.500000 C=-1.000000

180     B24: #	out( B38 B25 ) &lt;- in( B23 )  Freq: 0.391202
180 +   # castII of R7, #@castII
180     bgeu  R7, R12, B38	#@cmpU_branch  P=0.000001 C=-1.000000

184     B25: #	out( B39 B26 ) &lt;- in( B24 )  Freq: 0.391202
184 +   spill R7 -&gt; R29	# spill size = 32
188 +   # castII of R29, #@castII
188     bgeu  R29, R12, B39	#@cmpU_branch  P=0.000001 C=-1.000000

18c     B26: #	out( B29 B27 ) &lt;- in( B25 B27 ) Loop( B26-B27 inner post of N1096) Freq: 0.782377
18c +   addw  R28, R7, zr	#@convI2L_reg_reg
190 +   add R28, R14, R28	# ptr, #@addP_reg_reg
194 +   lbu  R28, [R28, #16]	# byte, #@loadUB2L
198 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
19c +   add R28, R11, R28	# ptr, #@addP_reg_reg
1a0 +   lw  R28, [R28, #16]	# int, #@loadI
1a4 +   andr  R29, R28, R31	#@andI_reg_reg
1a8 +   beq  R29, zr, B29	#@cmpI_reg_imm0_branch  P=0.000034 C=29658.000000

1ac     B27: #	out( B26 B28 ) &lt;- in( B26 )  Freq: 0.782351
1ac +   addiw  R7, R7, #1	#@addI_reg_imm
1b0 +   blt  R7, R13, B26	#@cmpI_loop  P=0.500000 C=29657.000000

1b4     B28: #	out( N1 ) &lt;- in( B29 B23 B10 B27 )  Freq: 0.999971
1b4     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
1cc +   ret	// return register, #@Ret

1d0     B29: #	out( B28 ) &lt;- in( B26 B20 B13 B19 )  Freq: 0.00118
1d0 +   li R10, #0	# int, #@loadConI
1d4 +   j  B28	#@branch

1d8     B30: #	out( N1 ) &lt;- in( B12 B11 )  Freq: 1.57753e-06
1d8 +   spill [sp, #0] -&gt; R8	# spill size = 64
1dc +   li R11, #-138	# int, #@loadConI
1e0     spill R13 -&gt; [sp, #0]	# spill size = 32
1e4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:46 (line 180) L[0]=R8 L[1]=_ L[2]=#1 L[3]=_ STK[0]=#1 STK[1]=sp + #0
        # OopMap {fp=Oop off=488/0x1e8}
1e8     #@ShouldNotReachHere

1f4     B31: #	out( N1 ) &lt;- in( B15 )  Freq: 7.83533e-07
1f4     #@ShouldNotReachHere

200     B32: #	out( N1 ) &lt;- in( B16 )  Freq: 7.83532e-07
200     #@ShouldNotReachHere

20c     B33: #	out( N1 ) &lt;- in( B6 )  Freq: 4.99988e-07
20c +   li R11, #-187	# int, #@loadConI
210     spill R28 -&gt; [sp, #8]	# spill size = 64
214 +   spill R30 -&gt; [sp, #16]	# spill size = 32
218     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #16
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=sp + #0 L[1]=#0
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #0 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop [8]=Oop off=540/0x21c}
21c     #@ShouldNotReachHere

228     B34: #	out( N1 ) &lt;- in( B9 )  Freq: 4.99988e-07
228 +   li R11, #-187	# int, #@loadConI
22c     spill R29 -&gt; [sp, #8]	# spill size = 32
230     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.CharacterDataLatin1::isJavaIdentifierStart @ bci:14 (line 116) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8 STK[1]=#20480
        # java.lang.Character::isJavaIdentifierStart @ bci:5 (line 10070) L[0]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:28 (line 176) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=564/0x234}
234     #@ShouldNotReachHere

240     B35: #	out( N1 ) &lt;- in( B3 )  Freq: 4.76836e-07
240 +   li R11, #-187	# int, #@loadConI
244     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isEmpty @ bci:5 (line 1487) L[0]=_ STK[0]=R8
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=584/0x248}
248     #@ShouldNotReachHere

254     B36: #	out( N1 ) &lt;- in( B5 )  Freq: 4.76826e-07
254 +   li R11, #-187	# int, #@loadConI
258     spill R28 -&gt; R8	# spill size = 64
25c +   spill R10 -&gt; [sp, #0]	# spill size = 32
260     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::contains @ bci:17 (line 938) L[0]=_ L[1]=_ STK[0]=sp + #0
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop off=612/0x264}
264     #@ShouldNotReachHere

270     B37: #	out( N1 ) &lt;- in( B8 )  Freq: 4.76825e-07
270 +   li R11, #-187	# int, #@loadConI
274     spill R14 -&gt; R8	# spill size = 64
278 +   spill R12 -&gt; [sp, #16]	# spill size = 32
27c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:7 (line 47) L[0]=R8 L[1]=#0 STK[0]=#0 STK[1]=sp + #16
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #0 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop [0]=Oop off=640/0x280}
280     #@ShouldNotReachHere

28c     B38: #	out( N1 ) &lt;- in( B24 )  Freq: 3.96397e-07
28c     #@ShouldNotReachHere

298     B39: #	out( N1 ) &lt;- in( B25 )  Freq: 3.96397e-07
298     #@ShouldNotReachHere

2a4     B40: #	out( N1 ) &lt;- in( B4 )  Freq: 9.99997e-06
2a4      -- 	// exception oop; no code emitted, #@CreateException
2a4 +   spill R10 -&gt; R11	# spill size = 64
2a8 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
2b4 +   j rethrow_stub	#@RethrowException

2bc     B41: #	out( N1 ) &lt;- in( B1 )  Freq: 1.01328e-06
2bc +   li R11, #-10	# int, #@loadConI
2c0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # OopMap {off=708/0x2c4}
2c4     #@ShouldNotReachHere

2d0     B42: #	out( N1 ) &lt;- in( B2 )  Freq: 1.01328e-06
2d0 +   li R11, #-10	# int, #@loadConI
2d4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::isEmpty @ bci:4 (line 1487) L[0]=_ STK[0]=#NULL
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=728/0x2d8}
2d8     #@ShouldNotReachHere

2e4     B43: #	out( N1 ) &lt;- in( B7 )  Freq: 1.01326e-06
2e4 +   li R11, #-10	# int, #@loadConI
2e8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::charAt @ bci:6 (line 47) L[0]=_ L[1]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=748/0x2ec}
2ec     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='328'>
----------------------- MetaData before Compile_id = 328 ------------------------
{method}
 - this oop:          0x0000004096506980
 - method holder:     &apos;java/util/concurrent/locks/AbstractQueuedSynchronizer&apos;
 - constants:         0x0000004096505498 constant pool [349] {0x0000004096505498} for &apos;java/util/concurrent/locks/AbstractQueuedSynchronizer&apos; cache=0x0000004096508bb8
 - access:            0x8100000a  private static 
 - name:              &apos;signalNext&apos;
 - signature:         &apos;(Ljava/util/concurrent/locks/AbstractQueuedSynchronizer$Node;)V&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c50a000
 - code size:         34
 - code start:        0x0000004096506938
 - code end (excl):   0x000000409650695a
 - method data:       0x00000040964882d8
 - checked ex length: 0
 - linenumber start:  0x000000409650695a
 - localvar length:   2
 - localvar start:    0x0000004096506966
 - compiled code: nmethod  14359  185       3       java.util.concurrent.locks.AbstractQueuedSynchronizer::signalNext (34 bytes)

------------------------ OptoAssembly for Compile_id = 328 -----------------------
#
#  void ( java/util/concurrent/locks/AbstractQueuedSynchronizer$Node * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/concurrent/locks/AbstractQueuedSynchronizer$Node *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B3 B2 )  Freq: 1

000     B1: #	out( B3 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     bne   R11, zr, B3	#@cmpP_imm0_branch  P=0.000000 C=5375.000000

020     B2: #	out( N1 ) &lt;- in( B1 )  Freq: 1
020     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
038 +   ret	// return register, #@Ret

03c     B3: #	out( N1 ) &lt;- in( B1 )  Freq: 4.76837e-07
03c +   spill R11 -&gt; [sp, #0]	# spill size = 64
040 +   li R11, #-187	# int, #@loadConI
044     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::signalNext @ bci:1 (line 609) L[0]=sp + #0 L[1]=_ STK[0]=sp + #0
        # OopMap {[0]=Oop off=72/0x48}
048 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='329'>
----------------------- MetaData before Compile_id = 329 ------------------------
{method}
 - this oop:          0x00000040965563c0
 - method holder:     &apos;java/nio/file/FileTreeWalker$Event&apos;
 - constants:         0x00000040965560a0 constant pool [51] {0x00000040965560a0} for &apos;java/nio/file/FileTreeWalker$Event&apos; cache=0x00000040965568c8
 - access:            0x81000002  private 
 - name:              &apos;&lt;init&gt;&apos;
 - signature:         &apos;(Ljava/nio/file/FileTreeWalker$EventType;Ljava/nio/file/Path;Ljava/nio/file/attribute/BasicFileAttributes;Ljava/io/IOException;)V&apos;
 - max stack:         3
 - max locals:        5
 - size of params:    5
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x00000040083246c0: 0xbbbbb i2c: 0x0000004013936140 c2i: 0x0000004013936194 c2iUV: 0x0000004013936160
 - compiled entry     0x000000400c510480
 - code size:         26
 - code start:        0x0000004096556358
 - code end (excl):   0x0000004096556372
 - method data:       0x000000409648c1c0
 - checked ex length: 0
 - linenumber start:  0x0000004096556372
 - localvar length:   5
 - localvar start:    0x0000004096556382
 - compiled code: nmethod  14471  202       3       java.nio.file.FileTreeWalker$Event::&lt;init&gt; (26 bytes)

------------------------ OptoAssembly for Compile_id = 329 -----------------------
#
#  void ( java/nio/file/FileTreeWalker$Event:NotNull *, java/nio/file/FileTreeWalker$EventType:exact *, java/nio/file/Path *, java/nio/file/attribute/BasicFileAttributes *, java/io/IOException * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/nio/file/FileTreeWalker$Event:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/nio/file/FileTreeWalker$EventType:exact *
#r016 c_rarg3:c_rarg3   : parm 2: java/nio/file/Path *
#r018 c_rarg4:c_rarg4   : parm 3: java/nio/file/attribute/BasicFileAttributes *
#r020 c_rarg5:c_rarg5   : parm 4: java/io/IOException *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N579: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B19 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c      -- 	// R23=Thread::current(), empty, #@tlsLoadP
03c     lb  R7, [R23, #56]	# byte, #@loadB
040     spill R15 -&gt; R20	# spill size = 64
044 +   spill R14 -&gt; R18	# spill size = 64
048 +   spill R13 -&gt; R19	# spill size = 64
04c +   spill R12 -&gt; R9	# spill size = 64
050 +   bne  R7, zr, B19	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

054     B2: #	out( B3 ) &lt;- in( B1 )  Freq: 0.999
054 +   spill R11 -&gt; R21	# spill size = 64

058     B3: #	out( B6 B4 ) &lt;- in( B47 B21 B19 B2 )  Freq: 1
058 +   mv  R7, R21	# ptr -&gt; long, #@castP2X
05c     spill R9 -&gt; R30	# spill size = 64
060 +   mv  R28, R30	# ptr -&gt; long, #@castP2X
064 +   xorr  R28, R28, R7	#@xorL_reg_reg
068 +   srli  R29, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
06c +   encode_heap_oop  R22, R19	#@encodeHeapOop
070 +   encode_heap_oop  R28, R30	#@encodeHeapOop
074     spill R18 -&gt; R25	# spill size = 64
078 +   encode_heap_oop  R18, R18	#@encodeHeapOop
07c     spill R19 -&gt; R26	# spill size = 64
080 +   encode_heap_oop  R19, R20	#@encodeHeapOop
084 +   li R24, #4	# int, #@loadConI
088 +   mv  R9, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
094 +   sw  R28, [R21, #12]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$Event.type
098 +   beq  R29, zr, B6	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

09c     B4: #	out( B6 B5 ) &lt;- in( B3 )  Freq: 0.999
09c +   beq   R30, zr, B6	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

0a0     B5: #	out( B31 B6 ) &lt;- in( B4 )  Freq: 0.998001
0a0 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0a4 +   add R10, R9, R7	# ptr, #@addP_reg_reg
0a8 +   lb  R28, [R10]	# byte, #@loadB
0ac +   bne  R28, R24, B31	#@cmpI_branch  P=0.001000 C=-1.000000

0b0     B6: #	out( B22 B7 ) &lt;- in( B33 B34 B31 B5 B4 B3 )  Freq: 1
0b0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0b0     lb  R7, [R23, #56]	# byte, #@loadB
0b4 +   bne  R7, zr, B22	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0b8     B7: #	out( B10 B8 ) &lt;- in( B48 B24 B22 B6 )  Freq: 1
0b8 +   mv  R7, R21	# ptr -&gt; long, #@castP2X
0bc +   mv  R28, R26	# ptr -&gt; long, #@castP2X
0c0 +   xorr  R28, R28, R7	#@xorL_reg_reg
0c4 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0c8 +   sw  R22, [R21, #16]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$Event.file
0cc +   beq  R28, zr, B10	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0d0     B8: #	out( B10 B9 ) &lt;- in( B7 )  Freq: 0.999
0d0 +   beq   R26, zr, B10	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

0d4     B9: #	out( B35 B10 ) &lt;- in( B8 )  Freq: 0.998001
0d4 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0d8 +   add R10, R9, R7	# ptr, #@addP_reg_reg
0dc +   lb  R28, [R10]	# byte, #@loadB
0e0 +   bne  R28, R24, B35	#@cmpI_branch  P=0.001000 C=-1.000000

0e4     B10: #	out( B25 B11 ) &lt;- in( B37 B38 B35 B9 B8 B7 )  Freq: 1
0e4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e4     lb  R7, [R23, #56]	# byte, #@loadB
0e8 +   bne  R7, zr, B25	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0ec     B11: #	out( B14 B12 ) &lt;- in( B49 B27 B25 B10 )  Freq: 1
0ec +   mv  R7, R21	# ptr -&gt; long, #@castP2X
0f0 +   mv  R28, R25	# ptr -&gt; long, #@castP2X
0f4 +   xorr  R28, R28, R7	#@xorL_reg_reg
0f8 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0fc +   sw  R18, [R21, #20]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$Event.attrs
100 +   beq  R28, zr, B14	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

104     B12: #	out( B14 B13 ) &lt;- in( B11 )  Freq: 0.999
104 +   beq   R25, zr, B14	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

108     B13: #	out( B39 B14 ) &lt;- in( B12 )  Freq: 0.998001
108 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
10c +   add R10, R9, R7	# ptr, #@addP_reg_reg
110 +   lb  R28, [R10]	# byte, #@loadB
114 +   bne  R28, R24, B39	#@cmpI_branch  P=0.001000 C=-1.000000

118     B14: #	out( B28 B15 ) &lt;- in( B41 B42 B39 B13 B12 B11 )  Freq: 1
118 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
118     lb  R7, [R23, #56]	# byte, #@loadB
11c +   bne  R7, zr, B28	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

120     B15: #	out( B18 B16 ) &lt;- in( B50 B30 B28 B14 )  Freq: 1
120 +   mv  R7, R21	# ptr -&gt; long, #@castP2X
124 +   mv  R28, R20	# ptr -&gt; long, #@castP2X
128 +   xorr  R28, R28, R7	#@xorL_reg_reg
12c +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
130 +   sw  R19, [R21, #24]	# compressed ptr, #@storeN ! Field: java/nio/file/FileTreeWalker$Event.ioe
134 +   beq  R28, zr, B18	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

138     B16: #	out( B18 B17 ) &lt;- in( B15 )  Freq: 0.999
138 +   beq   R20, zr, B18	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

13c     B17: #	out( B43 B18 ) &lt;- in( B16 )  Freq: 0.998001
13c +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
140 +   add R10, R9, R7	# ptr, #@addP_reg_reg
144 +   lb  R28, [R10]	# byte, #@loadB
148 +   bne  R28, R24, B43	#@cmpI_branch  P=0.001000 C=-1.000000

14c     B18: #	out( N579 ) &lt;- in( B45 B46 B43 B17 B16 B15 )  Freq: 1
14c +   #@membar_release
	fence iorw ow
150 +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
168 +   ret	// return register, #@Ret

16c     B19: #	out( B3 B20 ) &lt;- in( B1 )  Freq: 0.000999987
16c +   lwu  R28, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.type
170 +   decode_heap_oop  R10, R28	#@decodeHeapOop
174     spill R11 -&gt; R21	# spill size = 64
178 +   beq   R10, zr, B3	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

17c     B20: #	out( B47 B21 ) &lt;- in( B19 )  Freq: 0.000499994
17c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
17c     ld  R7, [R23, #32]	# int, #@loadL
180 +   beq  R7, zr, B47	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

184     B21: #	out( B3 ) &lt;- in( B20 )  Freq: 0.000499494
184 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
184     ld  R28, [R23, #48]	# ptr, #@loadP
188 +   add R28, R28, R7	# ptr, #@addP_reg_reg
18c +   addi  R7, R7, #-8	#@addL_reg_imm
190 +   sd  R10, [R28, #-8]	# ptr, #@storeP
194 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
194     sd  R7, [R23, #32]	# long, #@storeL
198 +   j  B3	#@branch

19c     B22: #	out( B7 B23 ) &lt;- in( B6 )  Freq: 0.000999987
19c +   lwu  R28, [R21, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.file
1a0 +   decode_heap_oop  R10, R28	#@decodeHeapOop
1a4 +   beq   R10, zr, B7	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1a8     B23: #	out( B48 B24 ) &lt;- in( B22 )  Freq: 0.000499994
1a8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a8     ld  R7, [R23, #32]	# int, #@loadL
1ac +   beq  R7, zr, B48	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1b0     B24: #	out( B7 ) &lt;- in( B23 )  Freq: 0.000499494
1b0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b0     ld  R28, [R23, #48]	# ptr, #@loadP
1b4 +   add R28, R28, R7	# ptr, #@addP_reg_reg
1b8 +   addi  R7, R7, #-8	#@addL_reg_imm
1bc +   sd  R10, [R28, #-8]	# ptr, #@storeP
1c0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1c0     sd  R7, [R23, #32]	# long, #@storeL
1c4 +   j  B7	#@branch

1c8     B25: #	out( B11 B26 ) &lt;- in( B10 )  Freq: 0.000999987
1c8 +   lwu  R28, [R21, #20]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.attrs
1cc +   decode_heap_oop  R10, R28	#@decodeHeapOop
1d0 +   beq   R10, zr, B11	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1d4     B26: #	out( B49 B27 ) &lt;- in( B25 )  Freq: 0.000499994
1d4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1d4     ld  R7, [R23, #32]	# int, #@loadL
1d8 +   beq  R7, zr, B49	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1dc     B27: #	out( B11 ) &lt;- in( B26 )  Freq: 0.000499494
1dc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1dc     ld  R28, [R23, #48]	# ptr, #@loadP
1e0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
1e4 +   addi  R7, R7, #-8	#@addL_reg_imm
1e8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
1ec +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ec     sd  R7, [R23, #32]	# long, #@storeL
1f0 +   j  B11	#@branch

1f4     B28: #	out( B15 B29 ) &lt;- in( B14 )  Freq: 0.000999987
1f4 +   lwu  R28, [R21, #24]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.ioe
1f8 +   decode_heap_oop  R10, R28	#@decodeHeapOop
1fc +   beq   R10, zr, B15	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

200     B29: #	out( B50 B30 ) &lt;- in( B28 )  Freq: 0.000499994
200 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
200     ld  R7, [R23, #32]	# int, #@loadL
204 +   beq  R7, zr, B50	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

208     B30: #	out( B15 ) &lt;- in( B29 )  Freq: 0.000499494
208 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
208     ld  R28, [R23, #48]	# ptr, #@loadP
20c +   add R28, R28, R7	# ptr, #@addP_reg_reg
210 +   addi  R7, R7, #-8	#@addL_reg_imm
214 +   sd  R10, [R28, #-8]	# ptr, #@storeP
218 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
218     sd  R7, [R23, #32]	# long, #@storeL
21c +   j  B15	#@branch

220     B31: #	out( B6 B32 ) &lt;- in( B5 )  Freq: 0.000998001
220 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
220     ld  R7, [R23, #64]	# int, #@loadL
224 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
224     ld  R28, [R23, #80]	# ptr, #@loadP
228 +   #@membar_volatile
	fence iorw iorw
22c +   lb  R29, [R10]	# byte, #@loadB
230 +   beq  R29, zr, B6	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

234     B32: #	out( B34 B33 ) &lt;- in( B31 )  Freq: 0.000499001
234 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
238 +   bne  R7, zr, B34	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

23c     B33: #	out( B6 ) &lt;- in( B32 )  Freq: 0.0002495
23c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
23c     spill R23 -&gt; R11	# spill size = 64
240 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
270 +   j  B6	#@branch

274     B34: #	out( B6 ) &lt;- in( B32 )  Freq: 0.0002495
274 +   add R28, R28, R7	# ptr, #@addP_reg_reg
278 +   addi  R7, R7, #-8	#@addL_reg_imm
27c +   sd  R10, [R28, #-8]	# ptr, #@storeP
280 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
280     sd  R7, [R23, #64]	# long, #@storeL
284 +   j  B6	#@branch

288     B35: #	out( B10 B36 ) &lt;- in( B9 )  Freq: 0.000998001
288 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
288     ld  R7, [R23, #64]	# int, #@loadL
28c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
28c     ld  R28, [R23, #80]	# ptr, #@loadP
290 +   #@membar_volatile
	fence iorw iorw
294 +   lb  R29, [R10]	# byte, #@loadB
298 +   beq  R29, zr, B10	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

29c     B36: #	out( B38 B37 ) &lt;- in( B35 )  Freq: 0.000499001
29c +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
2a0 +   bne  R7, zr, B38	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

2a4     B37: #	out( B10 ) &lt;- in( B36 )  Freq: 0.0002495
2a4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2a4     spill R23 -&gt; R11	# spill size = 64
2a8 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
2d8 +   j  B10	#@branch

2dc     B38: #	out( B10 ) &lt;- in( B36 )  Freq: 0.0002495
2dc +   add R28, R28, R7	# ptr, #@addP_reg_reg
2e0 +   addi  R7, R7, #-8	#@addL_reg_imm
2e4 +   sd  R10, [R28, #-8]	# ptr, #@storeP
2e8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2e8     sd  R7, [R23, #64]	# long, #@storeL
2ec +   j  B10	#@branch

2f0     B39: #	out( B14 B40 ) &lt;- in( B13 )  Freq: 0.000998001
2f0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2f0     ld  R7, [R23, #64]	# int, #@loadL
2f4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2f4     ld  R28, [R23, #80]	# ptr, #@loadP
2f8 +   #@membar_volatile
	fence iorw iorw
2fc +   lb  R29, [R10]	# byte, #@loadB
300 +   beq  R29, zr, B14	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

304     B40: #	out( B42 B41 ) &lt;- in( B39 )  Freq: 0.000499001
304 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
308 +   bne  R7, zr, B42	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

30c     B41: #	out( B14 ) &lt;- in( B40 )  Freq: 0.0002495
30c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
30c     spill R23 -&gt; R11	# spill size = 64
310 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
340 +   j  B14	#@branch

344     B42: #	out( B14 ) &lt;- in( B40 )  Freq: 0.0002495
344 +   add R28, R28, R7	# ptr, #@addP_reg_reg
348 +   addi  R7, R7, #-8	#@addL_reg_imm
34c +   sd  R10, [R28, #-8]	# ptr, #@storeP
350 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
350     sd  R7, [R23, #64]	# long, #@storeL
354 +   j  B14	#@branch

358     B43: #	out( B18 B44 ) &lt;- in( B17 )  Freq: 0.000998001
358 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
358     ld  R7, [R23, #64]	# int, #@loadL
35c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
35c     ld  R28, [R23, #80]	# ptr, #@loadP
360 +   #@membar_volatile
	fence iorw iorw
364 +   lb  R29, [R10]	# byte, #@loadB
368 +   beq  R29, zr, B18	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

36c     B44: #	out( B46 B45 ) &lt;- in( B43 )  Freq: 0.000499001
36c +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
370 +   bne  R7, zr, B46	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

374     B45: #	out( B18 ) &lt;- in( B44 )  Freq: 0.0002495
374 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
374     spill R23 -&gt; R11	# spill size = 64
378 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
3a8 +   j  B18	#@branch

3ac     B46: #	out( B18 ) &lt;- in( B44 )  Freq: 0.0002495
3ac +   add R28, R28, R7	# ptr, #@addP_reg_reg
3b0 +   addi  R7, R7, #-8	#@addL_reg_imm
3b4 +   sd  R10, [R28, #-8]	# ptr, #@storeP
3b8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3b8     sd  R7, [R23, #64]	# long, #@storeL
3bc +   j  B18	#@branch

3c0     B47: #	out( B3 ) &lt;- in( B20 )  Freq: 4.99987e-07
3c0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3c0     spill R23 -&gt; R11	# spill size = 64
3c4 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
3f4 +   j  B3	#@branch

3f8     B48: #	out( B7 ) &lt;- in( B23 )  Freq: 4.99987e-07
3f8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3f8     spill R23 -&gt; R11	# spill size = 64
3fc +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
42c +   j  B7	#@branch

430     B49: #	out( B11 ) &lt;- in( B26 )  Freq: 4.99987e-07
430 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
430     spill R23 -&gt; R11	# spill size = 64
434 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
464 +   j  B11	#@branch

468     B50: #	out( B15 ) &lt;- in( B29 )  Freq: 4.99987e-07
468 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
468     spill R23 -&gt; R11	# spill size = 64
46c +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
49c +   j  B15	#@branch

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='330'>
----------------------- MetaData before Compile_id = 330 ------------------------
{method}
 - this oop:          0x000000409600c560
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;replace&apos;
 - signature:         &apos;(CC)Ljava/lang/String;&apos;
 - max stack:         4
 - max locals:        4
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x0000004008316ed0: 0xbaa i2c: 0x0000004013945bc0 c2i: 0x0000004013945c0c c2iUV: 0x0000004013945bd8
 - compiled entry     0x000000400c4f7340
 - code size:         42
 - code start:        0x000000409600c4f8
 - code end (excl):   0x000000409600c522
 - method data:       0x00000040965ee6e8
 - checked ex length: 0
 - linenumber start:  0x000000409600c522
 - localvar length:   4
 - localvar start:    0x000000409600c52e
 - compiled code: nmethod  14513  137       3       java.lang.String::replace (42 bytes)

------------------------ OptoAssembly for Compile_id = 330 -----------------------
#
#  java/lang/String:exact * ( java/lang/String:NotNull:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N79: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B8 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
040 +   lb  R28, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
044     spill R11 -&gt; R8	# spill size = 64
048 +   beq  R12, R13, B8	#@cmpI_branch  P=0.000000 C=5375.000000

04c     B2: #	out( B7 B3 ) &lt;- in( B1 )  Freq: 1
04c +   bne  R28, zr, B7	#@cmpI_reg_imm0_branch  P=0.000000 C=65142.000000

050     B3: #	out( B9 B4 ) &lt;- in( B2 )  Freq: 0.999999
050 +   decode_heap_oop  R11, R7	#@decodeHeapOop
054     CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringLatin1::replace
        # java.lang.String::replace @ bci:18 (line 2801) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop off=88/0x58}

058     B4: #	out( B6 B5 ) &lt;- in( B3 )  Freq: 0.999979
        # Block is sole successor of call
058 +   beq   R10, zr, B6	#@cmpP_imm0_branch  P=0.000744 C=5375.000000

05c     B5: #	out( N79 ) &lt;- in( B4 B6 )  Freq: 0.999979
05c     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
074 +   ret	// return register, #@Ret

078     B6: #	out( B5 ) &lt;- in( B4 )  Freq: 0.000744148
078 +   spill R8 -&gt; R10	# spill size = 64
07c +   j  B5	#@branch

080     B7: #	out( N79 ) &lt;- in( B2 )  Freq: 5e-07
080 +   li R11, #-187	# int, #@loadConI
084     spill R12 -&gt; [sp, #0]	# spill size = 32
088 +   spill R13 -&gt; [sp, #4]	# spill size = 32
08c +   spill R28 -&gt; [sp, #8]	# spill size = 32
090     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #8
        # java.lang.String::replace @ bci:6 (line 2801) L[0]=R8 L[1]=sp + #0 L[2]=sp + #4 L[3]=_
        # OopMap {fp=Oop off=148/0x94}
094     #@ShouldNotReachHere

0a0     B8: #	out( N79 ) &lt;- in( B1 )  Freq: 4.76837e-07
0a0 +   li R11, #-187	# int, #@loadConI
0a4     spill R12 -&gt; [sp, #8]	# spill size = 32
0a8 +   spill R13 -&gt; [sp, #12]	# spill size = 32
0ac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:2 (line 2800) L[0]=R8 L[1]=sp + #8 L[2]=sp + #12 L[3]=_ STK[0]=sp + #8 STK[1]=sp + #12
        # OopMap {fp=Oop off=176/0xb0}
0b0     #@ShouldNotReachHere

0bc     B9: #	out( N79 ) &lt;- in( B3 )  Freq: 9.99999e-06
0bc      -- 	// exception oop; no code emitted, #@CreateException
0bc +   spill R10 -&gt; R11	# spill size = 64
0c0 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
0cc +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='331'>
----------------------- MetaData before Compile_id = 331 ------------------------
{method}
 - this oop:          0x0000004096550648
 - method holder:     &apos;java/nio/file/FileTreeIterator&apos;
 - constants:         0x000000409654fe20 constant pool [128] {0x000000409654fe20} for &apos;java/nio/file/FileTreeIterator&apos; cache=0x0000004096550a20
 - access:            0x81000001  public 
 - name:              &apos;hasNext&apos;
 - signature:         &apos;()Z&apos;
 - max stack:         3
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      5
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c520240
 - code size:         35
 - code start:        0x0000004096550608
 - code end (excl):   0x000000409655062b
 - method data:       0x0000004096490dd0
 - checked ex length: 0
 - linenumber start:  0x000000409655062b
 - localvar length:   1
 - localvar start:    0x000000409655063a
 - compiled code: nmethod  14546  220       3       java.nio.file.FileTreeIterator::hasNext (35 bytes)

------------------------ OptoAssembly for Compile_id = 331 -----------------------
#
#  bool ( java/nio/file/FileTreeIterator:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/nio/file/FileTreeIterator:NotNull *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N71: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B7 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.walker
040 +   spill R11 -&gt; R8	# spill size = 64
044 +   decode_heap_oop  R7, R7	#@decodeHeapOop
048     lbu  R7, [R7, #17]	# byte, #@loadUB ! Field: java/nio/file/FileTreeWalker.closed
04c     NullCheck R7

04c     B2: #	out( B5 B3 ) &lt;- in( B1 )  Freq: 0.999999
04c +   bne  R7, zr, B5	#@cmpI_reg_imm0_branch  P=0.000000 C=10746.000000

050     B3: #	out( B6 B4 ) &lt;- in( B2 )  Freq: 0.999999
050     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeIterator::fetchNextIfNeeded
        # java.nio.file.FileTreeIterator::hasNext @ bci:19 (line 103) L[0]=R8
        # OopMap {fp=Oop off=84/0x54}

054     B4: #	out( N71 ) &lt;- in( B3 )  Freq: 0.999978
        # Block is sole successor of call
054 +   lwu  R28, [R8, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.next
058 +   decode_heap_oop  R7, R28	#@decodeHeapOop
05c +   snez  R10, R7	#@convP2Bool
060     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
078 +   ret	// return register, #@Ret

07c     B5: #	out( N71 ) &lt;- in( B2 )  Freq: 4.99999e-07
07c +   li R11, #-187	# int, #@loadConI
080     spill R7 -&gt; [sp, #0]	# spill size = 32
084     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::isOpen @ bci:4 (line 412) L[0]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeIterator::hasNext @ bci:4 (line 101) L[0]=R8
        # OopMap {fp=Oop off=136/0x88}
088     #@ShouldNotReachHere

094     B6: #	out( N71 ) &lt;- in( B3 )  Freq: 9.99998e-06
094      -- 	// exception oop; no code emitted, #@CreateException
094 +   spill R10 -&gt; R11	# spill size = 64
098 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
0a4 +   j rethrow_stub	#@RethrowException

0ac     B7: #	out( N71 ) &lt;- in( B1 )  Freq: 1.01328e-06
0ac +   li R11, #-10	# int, #@loadConI
0b0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeIterator::hasNext @ bci:4 (line 101) L[0]=_ STK[0]=#NULL
        # OopMap {off=180/0xb4}
0b4 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='332'>
----------------------- MetaData before Compile_id = 332 ------------------------
{method}
 - this oop:          0x0000004096550738
 - method holder:     &apos;java/nio/file/FileTreeIterator&apos;
 - constants:         0x000000409654fe20 constant pool [128] {0x000000409654fe20} for &apos;java/nio/file/FileTreeIterator&apos; cache=0x0000004096550a20
 - access:            0x81000001  public 
 - name:              &apos;next&apos;
 - signature:         &apos;()Ljava/nio/file/FileTreeWalker$Event;&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      7
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c54c380
 - code size:         49
 - code start:        0x00000040965506e0
 - code end (excl):   0x0000004096550711
 - method data:       0x0000004096492330
 - checked ex length: 0
 - linenumber start:  0x0000004096550711
 - localvar length:   2
 - localvar start:    0x000000409655071e
 - compiled code: nmethod  14570  270       3       java.nio.file.FileTreeIterator::next (49 bytes)

------------------------ OptoAssembly for Compile_id = 332 -----------------------
#
#  java/nio/file/FileTreeWalker$Event * ( java/nio/file/FileTreeIterator:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/nio/file/FileTreeIterator:NotNull *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N133: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B14 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.walker
040 +   spill R11 -&gt; R8	# spill size = 64
044 +   decode_heap_oop  R7, R7	#@decodeHeapOop
048     lbu  R7, [R7, #17]	# byte, #@loadUB ! Field: java/nio/file/FileTreeWalker.closed
04c     NullCheck R7

04c     B2: #	out( B10 B3 ) &lt;- in( B1 )  Freq: 0.999999
04c +   bne  R7, zr, B10	#@cmpI_reg_imm0_branch  P=0.000000 C=10750.000000

050     B3: #	out( B13 B4 ) &lt;- in( B2 )  Freq: 0.999999
050     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeIterator::fetchNextIfNeeded
        # java.nio.file.FileTreeIterator::next @ bci:19 (line 111) L[0]=R8 L[1]=_
        # OopMap {fp=Oop off=84/0x54}

054     B4: #	out( B12 B5 ) &lt;- in( B3 )  Freq: 0.999978
        # Block is sole successor of call
054 +   lwu  R28, [R8, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.next
058 +   decode_heap_oop  R9, R28	#@decodeHeapOop
05c +   beq   R9, zr, B12	#@cmpP_imm0_branch  P=0.000000 C=5374.000000

060     B5: #	out( B7 B6 ) &lt;- in( B4 )  Freq: 0.999978
060 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
060     lb  R7, [R23, #56]	# byte, #@loadB
064 +   bne  R7, zr, B7	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

068     B6: #	out( N133 ) &lt;- in( B11 B9 B7 B5 )  Freq: 0.999978
068 +   sw  rheapbase, [R8, #16]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/nio/file/FileTreeIterator.next
06c     spill R9 -&gt; R10	# spill size = 64
070 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
088 +   ret	// return register, #@Ret

08c     B7: #	out( B6 B8 ) &lt;- in( B5 )  Freq: 0.000999965
08c +   lwu  R28, [R8, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.next
090 +   decode_heap_oop  R10, R28	#@decodeHeapOop
094 +   beq   R10, zr, B6	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

098     B8: #	out( B11 B9 ) &lt;- in( B7 )  Freq: 0.000499983
098 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
098     ld  R7, [R23, #32]	# int, #@loadL
09c +   beq  R7, zr, B11	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0a0     B9: #	out( B6 ) &lt;- in( B8 )  Freq: 0.000499483
0a0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0a0     ld  R28, [R23, #48]	# ptr, #@loadP
0a4 +   add R28, R28, R7	# ptr, #@addP_reg_reg
0a8 +   addi  R7, R7, #-8	#@addL_reg_imm
0ac +   sd  R10, [R28, #-8]	# ptr, #@storeP
0b0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0b0     sd  R7, [R23, #32]	# long, #@storeL
0b4 +   j  B6	#@branch

0b8     B10: #	out( N133 ) &lt;- in( B2 )  Freq: 4.99999e-07
0b8 +   li R11, #-187	# int, #@loadConI
0bc     spill R7 -&gt; [sp, #0]	# spill size = 32
0c0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::isOpen @ bci:4 (line 412) L[0]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeIterator::next @ bci:4 (line 109) L[0]=R8 L[1]=_
        # OopMap {fp=Oop off=196/0xc4}
0c4     #@ShouldNotReachHere

0d0     B11: #	out( B6 ) &lt;- in( B8 )  Freq: 4.99976e-07
0d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0d0     spill R23 -&gt; R11	# spill size = 64
0d4 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
104 +   j  B6	#@branch

108     B12: #	out( N133 ) &lt;- in( B4 )  Freq: 4.76827e-07
108 +   li R11, #-187	# int, #@loadConI
10c     spill R9 -&gt; [sp, #0]	# spill size = 64
110     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeIterator::next @ bci:26 (line 112) L[0]=R8 L[1]=_ STK[0]=sp + #0
        # OopMap {fp=Oop [0]=Oop off=276/0x114}
114     #@ShouldNotReachHere

120     B13: #	out( N133 ) &lt;- in( B3 )  Freq: 9.99998e-06
120      -- 	// exception oop; no code emitted, #@CreateException
120 +   spill R10 -&gt; R11	# spill size = 64
124 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
130 +   j rethrow_stub	#@RethrowException

138     B14: #	out( N133 ) &lt;- in( B1 )  Freq: 1.01328e-06
138 +   li R11, #-10	# int, #@loadConI
13c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeIterator::next @ bci:4 (line 109) L[0]=_ L[1]=_ STK[0]=#NULL
        # OopMap {off=320/0x140}
140     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='333'>
----------------------- MetaData before Compile_id = 333 ------------------------
{method}
 - this oop:          0x00000040965508a0
 - method holder:     &apos;java/nio/file/FileTreeIterator&apos;
 - constants:         0x000000409654fe20 constant pool [128] {0x000000409654fe20} for &apos;java/nio/file/FileTreeIterator&apos; cache=0x0000004096550a20
 - access:            0x81001041  public volatile synthetic 
 - name:              &apos;next&apos;
 - signature:         &apos;()Ljava/lang/Object;&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      6
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c524e80
 - code size:         5
 - code start:        0x0000004096550888
 - code end (excl):   0x000000409655088d
 - method data:       0x0000004096492180
 - checked ex length: 0
 - linenumber start:  0x000000409655088d
 - localvar length:   1
 - localvar start:    0x0000004096550892
 - compiled code: nmethod  14597  228       3       java.nio.file.FileTreeIterator::next (5 bytes)

------------------------ OptoAssembly for Compile_id = 333 -----------------------
#
#  java/lang/Object * ( java/nio/file/FileTreeIterator:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/nio/file/FileTreeIterator:NotNull *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N133: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B14 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.walker
040 +   spill R11 -&gt; R8	# spill size = 64
044 +   decode_heap_oop  R7, R7	#@decodeHeapOop
048     lbu  R7, [R7, #17]	# byte, #@loadUB ! Field: java/nio/file/FileTreeWalker.closed
04c     NullCheck R7

04c     B2: #	out( B10 B3 ) &lt;- in( B1 )  Freq: 0.999999
04c +   bne  R7, zr, B10	#@cmpI_reg_imm0_branch  P=0.000000 C=10751.000000

050     B3: #	out( B13 B4 ) &lt;- in( B2 )  Freq: 0.999999
050     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.nio.file.FileTreeIterator::fetchNextIfNeeded
        # java.nio.file.FileTreeIterator::next @ bci:19 (line 111) L[0]=R8 L[1]=_
        # java.nio.file.FileTreeIterator::next @ bci:1 (line 50) L[0]=_
        # OopMap {fp=Oop off=84/0x54}

054     B4: #	out( B12 B5 ) &lt;- in( B3 )  Freq: 0.999978
        # Block is sole successor of call
054 +   lwu  R28, [R8, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.next
058 +   decode_heap_oop  R9, R28	#@decodeHeapOop
05c +   beq   R9, zr, B12	#@cmpP_imm0_branch  P=0.000000 C=5375.000000

060     B5: #	out( B7 B6 ) &lt;- in( B4 )  Freq: 0.999978
060 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
060     lb  R7, [R23, #56]	# byte, #@loadB
064 +   bne  R7, zr, B7	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

068     B6: #	out( N133 ) &lt;- in( B11 B9 B7 B5 )  Freq: 0.999978
068 +   sw  rheapbase, [R8, #16]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/nio/file/FileTreeIterator.next
06c     spill R9 -&gt; R10	# spill size = 64
070 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
088 +   ret	// return register, #@Ret

08c     B7: #	out( B6 B8 ) &lt;- in( B5 )  Freq: 0.000999965
08c +   lwu  R28, [R8, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeIterator.next
090 +   decode_heap_oop  R10, R28	#@decodeHeapOop
094 +   beq   R10, zr, B6	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

098     B8: #	out( B11 B9 ) &lt;- in( B7 )  Freq: 0.000499983
098 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
098     ld  R7, [R23, #32]	# int, #@loadL
09c +   beq  R7, zr, B11	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0a0     B9: #	out( B6 ) &lt;- in( B8 )  Freq: 0.000499483
0a0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0a0     ld  R28, [R23, #48]	# ptr, #@loadP
0a4 +   add R28, R28, R7	# ptr, #@addP_reg_reg
0a8 +   addi  R7, R7, #-8	#@addL_reg_imm
0ac +   sd  R10, [R28, #-8]	# ptr, #@storeP
0b0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0b0     sd  R7, [R23, #32]	# long, #@storeL
0b4 +   j  B6	#@branch

0b8     B10: #	out( N133 ) &lt;- in( B2 )  Freq: 4.99999e-07
0b8 +   li R11, #-187	# int, #@loadConI
0bc     spill R7 -&gt; [sp, #0]	# spill size = 32
0c0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeWalker::isOpen @ bci:4 (line 412) L[0]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeIterator::next @ bci:4 (line 109) L[0]=R8 L[1]=_
        # java.nio.file.FileTreeIterator::next @ bci:1 (line 50) L[0]=_
        # OopMap {fp=Oop off=196/0xc4}
0c4     #@ShouldNotReachHere

0d0     B11: #	out( B6 ) &lt;- in( B8 )  Freq: 4.99976e-07
0d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0d0     spill R23 -&gt; R11	# spill size = 64
0d4 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
104 +   j  B6	#@branch

108     B12: #	out( N133 ) &lt;- in( B4 )  Freq: 4.76827e-07
108 +   li R11, #-187	# int, #@loadConI
10c     spill R9 -&gt; [sp, #0]	# spill size = 64
110     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.nio.file.FileTreeIterator::next @ bci:26 (line 112) L[0]=R8 L[1]=_ STK[0]=sp + #0
        # java.nio.file.FileTreeIterator::next @ bci:1 (line 50) L[0]=_
        # OopMap {fp=Oop [0]=Oop off=276/0x114}
114     #@ShouldNotReachHere

120     B13: #	out( N133 ) &lt;- in( B3 )  Freq: 9.99998e-06
120      -- 	// exception oop; no code emitted, #@CreateException
120 +   spill R10 -&gt; R11	# spill size = 64
124 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
130 +   j rethrow_stub	#@RethrowException

138     B14: #	out( N133 ) &lt;- in( B1 )  Freq: 1.01328e-06
138 +   li R11, #-10	# int, #@loadConI
13c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.FileTreeIterator::next @ bci:4 (line 109) L[0]=_ L[1]=_ STK[0]=#NULL
        # java.nio.file.FileTreeIterator::next @ bci:1 (line 50) L[0]=_
        # OopMap {off=320/0x140}
140     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='334'>
----------------------- MetaData before Compile_id = 334 ------------------------
{method}
 - this oop:          0x00000040965e6108
 - method holder:     &apos;java/util/stream/ReferencePipeline$2$1&apos;
 - constants:         0x00000040965e5c18 constant pool [69] {0x00000040965e5c18} for &apos;java/util/stream/ReferencePipeline$2$1&apos; cache=0x00000040965e61d8
 - access:            0x81000001  public 
 - name:              &apos;accept&apos;
 - signature:         &apos;(Ljava/lang/Object;)V&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      7
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824bb30: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c525440
 - code size:         27
 - code start:        0x00000040965e60c8
 - code end (excl):   0x00000040965e60e3
 - method data:       0x0000004096492570
 - checked ex length: 0
 - linenumber start:  0x00000040965e60e3
 - localvar length:   2
 - localvar start:    0x00000040965e60ec
 - compiled code: nmethod  14752  229       3       java.util.stream.ReferencePipeline$2$1::accept (27 bytes)

------------------------ OptoAssembly for Compile_id = 334 -----------------------
#
#  void ( java/util/stream/ReferencePipeline$2$1:NotNull *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/stream/ReferencePipeline$2$1:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 112 --
#r263 sp+108: in_preserve
#r262 sp+104: return address
#r261 sp+100: in_preserve
#r260 sp+96: saved fp register
#r259 sp+92: pad2, stack alignment
#r258 sp+88: pad2, stack alignment
#r257 sp+84: Fixed slot 1
#r256 sp+80: Fixed slot 0
#r283 sp+76: spill
#r282 sp+72: spill
#r281 sp+68: spill
#r280 sp+64: spill
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N742: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B59 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=112
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #112
	
03c     lwu  R7, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$2$1.this$1
040 +   spill R12 -&gt; [sp, #8]	# spill size = 64
044 +   spill R11 -&gt; [sp, #0]	# spill size = 64
048 +   decode_heap_oop  R7, R7	#@decodeHeapOop
04c     lwu  R28, [R7, #52]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$2.val$predicate
050     NullCheck R7

050     B2: #	out( B60 B3 ) &lt;- in( B1 )  Freq: 0.999999
050 +   decode_heap_oop  R8, R28	#@decodeHeapOop
054     lwu  R7, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
058     NullCheck R8

058     B3: #	out( B43 B4 ) &lt;- in( B2 )  Freq: 0.999998
058 +   mv  R29, narrowklass: precise klass java/nio/file/Files$$Lambda$6+0x00000008000180e8: 0x00000040d012dab0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
068 +   bne  R7, R29, B43	#@cmpN_branch  P=0.000001 C=-1.000000

06c     B4: #	out( B61 B5 ) &lt;- in( B3 )  Freq: 0.999997
06c +   # checkcastPP of R8, #@checkCastPP
06c     lwu  R7, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/Files$$Lambda$6+0x00000008000180e8.arg$1 (constant)
070 +   decode_heap_oop  R30, R7	#@decodeHeapOop
074     lwu  R28, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
078     NullCheck R12

078     B5: #	out( B56 B6 ) &lt;- in( B4 )  Freq: 0.999996
078 +   mv  R7, narrowklass: precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d0132ba0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
088 +   bne  R28, R7, B56	#@cmpN_branch  P=0.000000 C=-1.000000

08c     B6: #	out( B62 B7 ) &lt;- in( B5 )  Freq: 0.999996
08c +   spill R12 -&gt; R7	# spill size = 64
090 +   # checkcastPP of R7, #@checkCastPP
090     lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.file
094     spill R7 -&gt; [sp, #48]	# spill size = 64
098 +   lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.attrs
09c +   decode_heap_oop  R31, R28	#@decodeHeapOop
0a0 +   decode_heap_oop  R7, R7	#@decodeHeapOop
0a4     lwu  R28, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0a8     NullCheck R30

0a8     B7: #	out( B44 B8 ) &lt;- in( B6 )  Freq: 0.999995
0a8 +   mv  R29, narrowklass: precise klass jdk/internal/module/ModulePath$$Lambda$4+0x000000080003fd28: 0x00000040d04f5890:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0b8 +   bne  R28, R29, B44	#@cmpN_branch  P=0.000001 C=-1.000000

0bc     B8: #	out( B63 B9 ) &lt;- in( B7 )  Freq: 0.999994
0bc +   # checkcastPP of R30, #@checkCastPP
0bc     lwu  R29, [R30, #12]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/module/ModulePath$$Lambda$4+0x000000080003fd28.arg$1 (constant)
0c0 +   decode_heap_oop  R29, R29	#@decodeHeapOop
0c4     lwu  R28, [R31, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0c8     NullCheck R31

0c8     B9: #	out( B57 B10 ) &lt;- in( B8 )  Freq: 0.999993
0c8 +   mv  R30, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d04f95f0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0d8 +   bne  R28, R30, B57	#@cmpN_branch  P=0.000000 C=-1.000000

0dc     B10: #	out( B64 B11 ) &lt;- in( B9 )  Freq: 0.999993
0dc +   # checkcastPP of R31, #@checkCastPP
0dc     spill R31 -&gt; [sp, #16]	# spill size = 64
0e0     lwu  R28, [R7, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0e4     NullCheck R7

0e4     B11: #	out( B58 B12 ) &lt;- in( B10 )  Freq: 0.999992
0e4 +   mv  R30, narrowklass: precise klass sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes: 0x00000040d04f96c0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0f4 +   bne  R28, R30, B58	#@cmpN_branch  P=0.000000 C=-1.000000

0f8     B12: #	out( B42 B13 ) &lt;- in( B11 )  Freq: 0.999992
0f8 +   # checkcastPP of R7, #@checkCastPP
0f8     lwu  R28, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes.attrs
0fc +   decode_heap_oop  R28, R28	#@decodeHeapOop
100 +   beq   R29, zr, B42	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

104     B13: #	out( B65 B14 ) &lt;- in( B12 )  Freq: 0.999991
104     lw  R28, [R28, #12]	# int, #@loadI ! Field: sun/nio/fs/UnixFileAttributes.st_mode
108     NullCheck R28

108     B14: #	out( B39 B15 ) &lt;- in( B13 )  Freq: 0.99999
108 +   li R7, #61440	# int, #@loadConI
10c +   andr  R28, R28, R7	#@andI_reg_reg
110 +   li R7, #32768	# int, #@loadConI
114 +   bne  R28, R7, B39	#@cmpI_branch  P=0.030140 C=5375.000000

118     B15: #	out( B66 B16 ) &lt;- in( B14 )  Freq: 0.969851
118 +   lwu  R28, [R31, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
11c +   mv  R7, java/lang/Class:exact *	# ptr, #@loadConP
134 +   lw  R8, [R7, #156]	# int, #@loadI ! Field: java/lang/System.allowSecurityManager (constant)
138 +   decode_heap_oop  R28, R28	#@decodeHeapOop
13c     lwu  R28, [R28, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileSystem.provider
140     NullCheck R28

140     B16: #	out( B45 B17 ) &lt;- in( B15 )  Freq: 0.96985
140 +   beq   R28, zr, B45	#@cmpP_narrowOop_imm0_branch  P=0.000001 C=-1.000000

144     B17: #	out( B50 B18 ) &lt;- in( B16 )  Freq: 0.969849
144 +   li R28, #1	# int, #@loadConI
148 +   beq  R8, R28, B50	#@cmpI_branch  P=0.000000 C=8384.000000

14c     B18: #	out( B51 B19 ) &lt;- in( B17 )  Freq: 0.969848
14c +   lwu  R28, [R7, #124]	# loadN, compressed ptr, #@loadN ! Field: volatile java/lang/System.security
150 +   #@membar_acquire
	fence ir iorw
154 +   decode_heap_oop  R8, R28	#@decodeHeapOop
158 +   bne   R8, zr, B51	#@cmpP_imm0_branch  P=0.000000 C=8201.000000

15c     B19: #	out( B72 B20 ) &lt;- in( B18 )  Freq: 0.969848
15c +   spill R31 -&gt; R11	# spill size = 64
160     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getFileName @ bci:1 (line 255) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [48]=Oop off=356/0x164}

164     B20: #	out( B68 B21 ) &lt;- in( B19 )  Freq: 0.969828
        # Block is sole successor of call
164 +   spill [sp, #16] -&gt; R7	# spill size = 64
168 +   lwu  R7, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
16c +   #@membar_acquire
	fence ir iorw
170 +   decode_heap_oop  R7, R7	#@decodeHeapOop
174     lwu  R28, [R7, #12]	# range, #@loadRange
178     NullCheck R7

178     B21: #	out( B52 B22 ) &lt;- in( B20 )  Freq: 0.969827
178 +   bleu  R28, zr, B52	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=5192.000000

17c     B22: #	out( B53 B23 ) &lt;- in( B21 )  Freq: 0.969827
17c +   li R29, #1	# int, #@loadConI
180 +   beq  R28, R29, B53	#@cmpI_branch  P=0.000000 C=5192.000000

184     B23: #	out( B69 B24 ) &lt;- in( B22 )  Freq: 0.969826
184 +   spill [sp, #16] -&gt; R7	# spill size = 64
188 +   lwu  R29, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
18c +   #@membar_acquire
	fence ir iorw
190 +   decode_heap_oop  R31, R29	#@decodeHeapOop
194 +   addw  R30, R28, zr	#@convI2L_reg_reg
198 +   lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
19c +   slli  R29, R30, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
1a0 +   addiw  R8, R28, #-1	#@addI_reg_imm
1a4     lwu  R30, [R31, #12]	# range, #@loadRange
1a8     NullCheck R31

1a8     B24: #	out( B46 B25 ) &lt;- in( B23 )  Freq: 0.969825
1a8 +   add R28, R31, R29	# ptr, #@addP_reg_reg
1ac +   decode_heap_oop  R29, R7	#@decodeHeapOop
1b0 +   bgeu  R8, R30, B46	#@cmpU_branch  P=0.000001 C=-1.000000

1b4     B25: #	out( B70 B26 ) &lt;- in( B24 )  Freq: 0.969824
1b4     lwu  R19, [R29, #12]	# range, #@loadRange
1b8     NullCheck R29

1b8     B26: #	out( B47 B27 ) &lt;- in( B25 )  Freq: 0.969823
1b8 +   lw  R8, [R28, #12]	# int, #@loadI
1bc +   subw  R18, R19, R8	#@subI_reg_reg
1c0 +   li R7, #1048576	# int, #@loadConI
1c4 +   addw  R30, R8, zr	#@convI2L_reg_reg
1c8 +   addw  R12, R18, zr	#@convI2L_reg_reg
1cc +   bgtu  R18, R7, B47	#@cmpU_branch  P=0.000001 C=-1.000000

1d0     B27: #	out( B28 ) &lt;- in( B26 )  Freq: 0.969822
1d0 +   addw  R28, R19, zr	#@convI2L_reg_reg
1d4 +   sub  R28, R28, R30	#@subL_reg_reg

1d8     B28: #	out( B49 B29 ) &lt;- in( B27 B47 )  Freq: 0.969823
1d8 +   blt  R8, zr, B49	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

1dc     B29: #	out( B40 B30 ) &lt;- in( B28 )  Freq: 0.969822
1dc +   bgtu  R18, R7, B40	#@cmpU_branch  P=0.000001 C=-1.000000

1e0     B30: #	out( B40 B31 ) &lt;- in( B29 )  Freq: 0.969821
1e0 +   addi  R7, R28, #23	#@addL_reg_imm
1e4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1e4     ld  R9, [R23, #288]	# ptr, #@loadP
1e8 +   andi  R7, R7, #-8	#@andL_reg_imm
1ec +   ld  R28, [R23, #304]	# ptr, #@loadP
1f0 +   add R7, R9, R7	# ptr, #@addP_reg_reg
1f4 +   bgeu  R7, R28, B40	#@cmpP_branch  P=0.000100 C=-1.000000

1f8     B31: #	out( B32 ) &lt;- in( B30 )  Freq: 0.969724
1f8 +   sd  R7, [R23, #288]	# ptr, #@storeP
1fc +   li R7, #1	# long, #@loadConL
200 +   sd  R7, [R9]	# long, #@storeL
204 +   mv  R7, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
214 +   sw  R7, [R9, #8]	# compressed klass ptr, #@storeNKlass
218 +   sw  R18, [R9, #12]	# int, #@storeI

21c     B32: #	out( B34 B33 ) &lt;- in( B41 B31 )  Freq: 0.969822
21c     
21c +   # checkcastPP of R9, #@checkCastPP
21c     addi  R20, R9, #16	# ptr, #@addP_reg_imm
220 +   beq  R19, R8, B34	#@cmpI_branch  P=0.000001 C=-1.000000

224     B33: #	out( B34 ) &lt;- in( B32 )  Freq: 0.969821
224 +   add R7, R29, R30	# ptr, #@addP_reg_reg
228     spill R20 -&gt; R11	# spill size = 64
22c +   addi  R10, R7, #16	# ptr, #@addP_reg_imm
230 +   CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

234     B34: #	out( B54 B35 ) &lt;- in( B33 B32 )  Freq: 0.969822
234     
234     beq  R19, R8, B54	#@cmpI_branch  P=0.000000 C=12920.000000

238     B35: #	out( B55 B36 ) &lt;- in( B34 )  Freq: 0.969822
238 +   lb  R8, [R20]	# byte, #@loadB
23c +   li R7, #46	# int, #@loadConI
240 +   beq  R8, R7, B55	#@cmpI_branch  P=0.000000 C=5192.000000

244     B36: #	out( B67 B37 ) &lt;- in( B35 B73 )  Freq: 0.96983
244 +   spill [sp, #0] -&gt; R7	# spill size = 64
248 +   lwu  R7, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/Sink$ChainedReference.downstream
24c +   decode_heap_oop  R29, R7	#@decodeHeapOop
250     lwu  R28, [R29, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
254     NullCheck R29

254     B37: #	out( B48 B38 ) &lt;- in( B36 )  Freq: 0.969829
254 +   mv  R7, narrowklass: precise klass java/util/stream/ReferencePipeline$3$1: 0x00000040d012db80:Constant:exact *	# compressed klass ptr, #@loadConNKlass
264 +   bne  R28, R7, B48	#@cmpN_branch  P=0.000001 C=-1.000000

268     B38: #	out( B75 B39 ) &lt;- in( B37 )  Freq: 0.969828
268 +   # checkcastPP of R29, #@checkCastPP
268     spill R29 -&gt; R11	# spill size = 64
26c +   spill [sp, #48] -&gt; R12	# spill size = 64
270     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.stream.ReferencePipeline$3$1::accept
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:21 (line 179) L[0]=_ L[1]=_
        # OopMap {off=628/0x274}

274     B39: #	out( N742 ) &lt;- in( B38 B14 )  Freq: 0.999948
274     # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
28c +   ret	// return register, #@Ret

290     B40: #	out( B71 B41 ) &lt;- in( B29 B30 )  Freq: 9.79809e-05
290 +   spill R12 -&gt; [sp, #40]	# spill size = 64
294 +   spill R30 -&gt; [sp, #64]	# spill size = 64
298 +   spill R29 -&gt; [sp, #56]	# spill size = 64
29c +   spill R18 -&gt; [sp, #36]	# spill size = 32
2a0 +   spill R19 -&gt; [sp, #32]	# spill size = 32
2a4 +   spill [sp, #16] -&gt; [sp, #24]	# spill size = 64
2ac +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
2c4     spill R18 -&gt; R12	# spill size = 32
2c8     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getFileName @ bci:60 (line 269) L[0]=sp + #24 L[1]=_ L[2]=R8 L[3]=sp + #36 L[4]=_
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [24]=Oop [48]=Oop [56]=Oop off=716/0x2cc}

2cc     B41: #	out( B32 ) &lt;- in( B40 )  Freq: 9.7979e-05
        # Block is sole successor of call
2cc +   spill [sp, #24] -&gt; [sp, #16]	# spill size = 64
2d4 +   spill [sp, #32] -&gt; R19	# spill size = 32
2d8 +   spill [sp, #36] -&gt; R18	# spill size = 32
2dc +   spill [sp, #40] -&gt; R12	# spill size = 64
2e0 +   spill R10 -&gt; R9	# spill size = 64
2e4 +   spill [sp, #56] -&gt; R29	# spill size = 64
2e8 +   spill [sp, #64] -&gt; R30	# spill size = 64
2ec +   j  B32	#@branch

2f0     B42: #	out( N742 ) &lt;- in( B12 )  Freq: 1.01327e-06
2f0 +   li R11, #-10	# int, #@loadConI
2f4     spill R31 -&gt; R8	# spill size = 64
2f8 +   spill R7 -&gt; [sp, #0]	# spill size = 64
2fc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL STK[1]=R8 STK[2]=sp + #0
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=768/0x300}
300     #@ShouldNotReachHere

30c     B43: #	out( N742 ) &lt;- in( B3 )  Freq: 9.99998e-07
30c +   li R11, #-34	# int, #@loadConI
310     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8 STK[0]=R8 STK[1]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=788/0x314}
314     #@ShouldNotReachHere

320     B44: #	out( N742 ) &lt;- in( B7 )  Freq: 9.99995e-07
320 +   spill [sp, #0] -&gt; R8	# spill size = 64
324 +   li R11, #-34	# int, #@loadConI
328     spill R12 -&gt; [sp, #0]	# spill size = 64
32c +   spill R30 -&gt; [sp, #8]	# spill size = 64
330 +   spill R31 -&gt; [sp, #16]	# spill size = 64
334 +   spill R7 -&gt; [sp, #24]	# spill size = 64
338     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_ STK[0]=sp + #8 STK[1]=sp + #16 STK[2]=sp + #24
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=828/0x33c}
33c     #@ShouldNotReachHere

348     B45: #	out( N742 ) &lt;- in( B16 )  Freq: 9.82728e-07
348 +   spill [sp, #0] -&gt; R8	# spill size = 64
34c +   li R11, #-10	# int, #@loadConI
350     spill R12 -&gt; [sp, #0]	# spill size = 64
354     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_ STK[0]=#NULL STK[1]=sp + #16
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=856/0x358}
358     #@ShouldNotReachHere

364     B46: #	out( N742 ) &lt;- in( B24 )  Freq: 9.82704e-07
364 +   li R11, #-28	# int, #@loadConI
368     spill R31 -&gt; [sp, #24]	# spill size = 64
36c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:49 (line 267) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #24 STK[1]=R8
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop off=880/0x370}
370     #@ShouldNotReachHere

37c     B47: #	out( B28 ) &lt;- in( B26 )  Freq: 9.82702e-07
37c +   spill R12 -&gt; R28	# spill size = 64
380 +   j  B28	#@branch

384     B48: #	out( N742 ) &lt;- in( B37 )  Freq: 9.69829e-07
384 +   li R11, #-34	# int, #@loadConI
388     spill R29 -&gt; R8	# spill size = 64
38c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:21 (line 179) L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #48
        # OopMap {fp=Oop [48]=Oop off=912/0x390}
390     #@ShouldNotReachHere

39c     B49: #	out( N742 ) &lt;- in( B28 )  Freq: 9.69823e-07
39c +   li R11, #-52	# int, #@loadConI
3a0     spill R18 -&gt; [sp, #28]	# spill size = 32
3a4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:60 (line 269) L[0]=sp + #16 L[1]=_ L[2]=R8 L[3]=sp + #28 L[4]=_ STK[0]=sp + #28
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=936/0x3a8}
3a8     #@ShouldNotReachHere

3b4     B50: #	out( N742 ) &lt;- in( B17 )  Freq: 4.6246e-07
3b4 +   li R11, #-187	# int, #@loadConI
3b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.System::allowSecurityManager @ bci:4 (line 193) STK[0]=R8 STK[1]=#1
        # java.lang.System::getSecurityManager @ bci:0 (line 483)
        # sun.nio.fs.UnixPath::checkRead @ bci:0 (line 778) L[0]=sp + #16 L[1]=_
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:6 (line 352) L[0]=_ L[1]=_ L[2]=sp + #16 L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=956/0x3bc}
3bc     #@ShouldNotReachHere

3c8     B51: #	out( N742 ) &lt;- in( B18 )  Freq: 4.6246e-07
3c8 +   li R11, #-187	# int, #@loadConI
3cc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::checkRead @ bci:5 (line 779) L[0]=sp + #16 L[1]=R8 STK[0]=R8
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:6 (line 352) L[0]=_ L[1]=_ L[2]=sp + #16 L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=976/0x3d0}
3d0     #@ShouldNotReachHere

3dc     B52: #	out( N742 ) &lt;- in( B21 )  Freq: 4.6245e-07
3dc +   spill [sp, #0] -&gt; R8	# spill size = 64
3e0 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
3e8 +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
3f0 +   li R11, #-187	# int, #@loadConI
3f4     spill R28 -&gt; [sp, #20]	# spill size = 32
3f8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:11 (line 260) L[0]=sp + #8 L[1]=sp + #20 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #20
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=1020/0x3fc}
3fc     #@ShouldNotReachHere

408     B53: #	out( N742 ) &lt;- in( B22 )  Freq: 4.62449e-07
408 +   spill [sp, #0] -&gt; R8	# spill size = 64
40c +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
414 +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
41c +   li R11, #-187	# int, #@loadConI
420     spill R28 -&gt; [sp, #20]	# spill size = 32
424     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:18 (line 264) L[0]=sp + #8 L[1]=sp + #20 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #20 STK[1]=#1
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=1064/0x428}
428     #@ShouldNotReachHere

434     B54: #	out( N742 ) &lt;- in( B34 )  Freq: 4.62447e-07
434 +   spill [sp, #16] -&gt; R7	# spill size = 64
438 +   lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
43c +   decode_heap_oop  R8, R7	#@decodeHeapOop
440 +   li R11, #-187	# int, #@loadConI
444     spill R18 -&gt; [sp, #16]	# spill size = 32
448 +   spill R9 -&gt; [sp, #24]	# spill size = 64
44c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::isEmpty @ bci:5 (line 216) L[0]=_ STK[0]=sp + #16
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:21 (line 358) L[0]=_ L[1]=_ L[2]=_ L[3]=#ScObj0 L[4]=_
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=R8, [path :2]=sp + #24, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop off=1104/0x450}
450     #@ShouldNotReachHere

45c     B55: #	out( N742 ) &lt;- in( B35 )  Freq: 4.62447e-07
45c +   li R11, #-187	# int, #@loadConI
460     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:51 (line 363) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=R8 STK[1]=#46
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop off=1124/0x464}
464     #@ShouldNotReachHere

470     B56: #	out( N742 ) &lt;- in( B5 )  Freq: 1e-35
470 +   li R11, #-34	# int, #@loadConI
474     spill [sp, #0] -&gt; R8	# spill size = 64
478 +   spill R30 -&gt; [sp, #16]	# spill size = 64
47c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:5 L[0]=_ L[1]=_ STK[0]=sp + #16 STK[1]=sp + #8
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=1152/0x480}
480     #@ShouldNotReachHere

48c     B57: #	out( N742 ) &lt;- in( B9 )  Freq: 1e-35
48c +   spill [sp, #0] -&gt; R8	# spill size = 64
490 +   li R11, #-34	# int, #@loadConI
494     spill R12 -&gt; [sp, #0]	# spill size = 64
498 +   spill R7 -&gt; [sp, #8]	# spill size = 64
49c +   spill R29 -&gt; [sp, #16]	# spill size = 64
4a0 +   spill R31 -&gt; [sp, #24]	# spill size = 64
4a4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:5 L[0]=_ L[1]=_ L[2]=sp + #8 STK[0]=sp + #16 STK[1]=sp + #24
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=1192/0x4a8}
4a8     #@ShouldNotReachHere

4b4     B58: #	out( N742 ) &lt;- in( B11 )  Freq: 1e-35
4b4 +   spill [sp, #0] -&gt; R8	# spill size = 64
4b8 +   li R11, #-34	# int, #@loadConI
4bc     spill R12 -&gt; [sp, #0]	# spill size = 64
4c0 +   spill R29 -&gt; [sp, #8]	# spill size = 64
4c4 +   spill R7 -&gt; [sp, #24]	# spill size = 64
4c8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:9 L[0]=_ L[1]=_ L[2]=_ STK[0]=sp + #8 STK[1]=sp + #16 STK[2]=sp + #24
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=1228/0x4cc}
4cc     #@ShouldNotReachHere

4d8     B59: #	out( N742 ) &lt;- in( B1 )  Freq: 1.01328e-06
4d8 +   li R11, #-10	# int, #@loadConI
4dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:4 (line 178) L[0]=_ L[1]=_ STK[0]=#NULL
        # OopMap {off=1248/0x4e0}
4e0     #@ShouldNotReachHere

4ec     B60: #	out( N742 ) &lt;- in( B2 )  Freq: 1.01328e-06
4ec +   li R11, #-10	# int, #@loadConI
4f0     spill R12 -&gt; R8	# spill size = 64
4f4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8
        # OopMap {fp=Oop off=1272/0x4f8}
4f8     #@ShouldNotReachHere

504     B61: #	out( N742 ) &lt;- in( B4 )  Freq: 1.01328e-06
504 +   spill [sp, #0] -&gt; R8	# spill size = 64
508 +   li R11, #-12	# int, #@loadConI
50c     spill R12 -&gt; [sp, #0]	# spill size = 64
510 +   spill R30 -&gt; [sp, #8]	# spill size = 64
514     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:5 L[0]=_ L[1]=_ STK[0]=sp + #8 STK[1]=#NULL
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=1304/0x518}
518     #@ShouldNotReachHere

524     B62: #	out( N742 ) &lt;- in( B6 )  Freq: 1.01327e-06
524 +   li R11, #-10	# int, #@loadConI
528     spill R31 -&gt; R8	# spill size = 64
52c +   spill R7 -&gt; [sp, #0]	# spill size = 64
530     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8 STK[2]=sp + #0
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=1332/0x534}
534     #@ShouldNotReachHere

540     B63: #	out( N742 ) &lt;- in( B8 )  Freq: 1.01327e-06
540 +   spill [sp, #0] -&gt; R8	# spill size = 64
544 +   li R11, #-12	# int, #@loadConI
548     spill R12 -&gt; [sp, #0]	# spill size = 64
54c +   spill R7 -&gt; [sp, #8]	# spill size = 64
550 +   spill R29 -&gt; [sp, #16]	# spill size = 64
554     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:5 L[0]=_ L[1]=_ L[2]=sp + #8 STK[0]=sp + #16 STK[1]=#NULL
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=1368/0x558}
558     #@ShouldNotReachHere

564     B64: #	out( N742 ) &lt;- in( B10 )  Freq: 1.01327e-06
564 +   spill [sp, #0] -&gt; R8	# spill size = 64
568 +   li R11, #-12	# int, #@loadConI
56c     spill R12 -&gt; [sp, #0]	# spill size = 64
570 +   spill R29 -&gt; [sp, #8]	# spill size = 64
574     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:9 L[0]=_ L[1]=_ L[2]=_ STK[0]=sp + #8 STK[1]=sp + #16 STK[2]=#NULL
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=1400/0x578}
578     #@ShouldNotReachHere

584     B65: #	out( N742 ) &lt;- in( B13 )  Freq: 1.01327e-06
584 +   li R11, #-10	# int, #@loadConI
588     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes::isRegularFile @ bci:4 (line 295) L[0]=_ STK[0]=#NULL
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:1 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=_ L[1]=_
        # OopMap {off=1420/0x58c}
58c     #@ShouldNotReachHere

598     B66: #	out( N742 ) &lt;- in( B15 )  Freq: 9.82729e-07
598 +   li R11, #-10	# int, #@loadConI
59c     spill [sp, #0] -&gt; R8	# spill size = 64
5a0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::provider @ bci:6 (line 105) L[0]=_ STK[0]=#NULL
        # java.nio.file.Files::isHidden @ bci:1 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=1444/0x5a4}
5a4     #@ShouldNotReachHere

5b0     B67: #	out( N742 ) &lt;- in( B36 )  Freq: 9.82709e-07
5b0 +   li R11, #-10	# int, #@loadConI
5b4     spill [sp, #48] -&gt; R8	# spill size = 64
5b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:21 (line 179) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8
        # OopMap {fp=Oop off=1468/0x5bc}
5bc     #@ShouldNotReachHere

5c8     B68: #	out( N742 ) &lt;- in( B20 )  Freq: 9.82707e-07
5c8 +   li R11, #-10	# int, #@loadConI
5cc     spill [sp, #0] -&gt; R8	# spill size = 64
5d0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:8 (line 257) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=1492/0x5d4}
5d4     #@ShouldNotReachHere

5e0     B69: #	out( N742 ) &lt;- in( B23 )  Freq: 9.82705e-07
5e0 +   li R11, #-10	# int, #@loadConI
5e4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:49 (line 267) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop off=1512/0x5e8}
5e8     #@ShouldNotReachHere

5f4     B70: #	out( N742 ) &lt;- in( B25 )  Freq: 9.82703e-07
5f4 +   li R11, #-10	# int, #@loadConI
5f8     spill [sp, #0] -&gt; R8	# spill size = 64
5fc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:55 (line 268) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=1536/0x600}
600     #@ShouldNotReachHere

60c     B71: #	out( B73 ) &lt;- in( B40 )  Freq: 9.79809e-10
60c      -- 	// exception oop; no code emitted, #@CreateException
60c +   lwu  R7, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
610 +   j  B73	#@branch

614     B72: #	out( B73 ) &lt;- in( B19 )  Freq: 9.69848e-06
614      -- 	// exception oop; no code emitted, #@CreateException
614 +   lwu  R7, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass

618     B73: #	out( B36 B74 ) &lt;- in( B72 B71 )  Freq: 9.69946e-06
618 +   mv  R29, narrowklass: precise klass java/io/IOException: 0x00000040d81cd670:Constant:exact *	# compressed klass ptr, #@loadConNKlass
628 +   beq  R7, R29, B36	#@cmpN_branch  P=0.900000 C=-1.000000

62c     B74: #	out( B76 ) &lt;- in( B73 )  Freq: 9.69946e-07
62c +   spill R10 -&gt; R11	# spill size = 64
630 +   j  B76	#@branch

634     B75: #	out( B76 ) &lt;- in( B38 )  Freq: 9.69828e-06
634      -- 	// exception oop; no code emitted, #@CreateException
634 +   spill R10 -&gt; R11	# spill size = 64

638     B76: #	out( N742 ) &lt;- in( B74 B75 )  Freq: 1.06682e-05
638     # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
644 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='335'>
----------------------- MetaData before Compile_id = 335 ------------------------
{method}
 - this oop:          0x00000040963fae58
 - method holder:     &apos;sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes&apos;
 - constants:         0x00000040963fa698 constant pool [66] {0x00000040963fa698} for &apos;sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes&apos; cache=0x00000040963fb270
 - access:            0x81000001  public 
 - name:              &apos;isRegularFile&apos;
 - signature:         &apos;()Z&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      14
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c527080
 - code size:         8
 - code start:        0x00000040963fae38
 - code end (excl):   0x00000040963fae40
 - method data:       0x0000004096493660
 - checked ex length: 0
 - linenumber start:  0x00000040963fae40
 - localvar length:   1
 - localvar start:    0x00000040963fae4a
 - compiled code: nmethod  14800  230       3       sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes::isRegularFile (8 bytes)

------------------------ OptoAssembly for Compile_id = 335 -----------------------
#
#  bool ( sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes:NotNull *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N44: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B6 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     lwu  R28, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes.attrs
040 +   decode_heap_oop  R7, R28	#@decodeHeapOop
044     lw  R7, [R7, #12]	# int, #@loadI ! Field: sun/nio/fs/UnixFileAttributes.st_mode
048     NullCheck R7

048     B2: #	out( B5 B3 ) &lt;- in( B1 )  Freq: 0.999999
048 +   li R29, #61440	# int, #@loadConI
04c +   andr  R7, R7, R29	#@andI_reg_reg
050 +   li R29, #32768	# int, #@loadConI
054 +   bne  R7, R29, B5	#@cmpI_branch  P=0.030140 C=5375.000000

058     B3: #	out( B4 ) &lt;- in( B2 )  Freq: 0.969859
058 +   li R10, #1	# int, #@loadConI

05c     B4: #	out( N44 ) &lt;- in( B5 B3 )  Freq: 0.999999
05c     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
074 +   ret	// return register, #@Ret

078     B5: #	out( B4 ) &lt;- in( B2 )  Freq: 0.0301395
078 +   li R10, #0	# int, #@loadConI
07c +   j  B4	#@branch

080     B6: #	out( N44 ) &lt;- in( B1 )  Freq: 1.01328e-06
080 +   li R11, #-10	# int, #@loadConI
084     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes::isRegularFile @ bci:4 (line 295) L[0]=_ STK[0]=#NULL
        # OopMap {off=136/0x88}
088 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='336'>
----------------------- MetaData before Compile_id = 336 ------------------------
{method}
 - this oop:          0x000000409600ffc0
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000008  static 
 - name:              &apos;checkBoundsOffCount&apos;
 - signature:         &apos;(III)V&apos;
 - max stack:         5
 - max locals:        3
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x0000004008318650: 0xaaa i2c: 0x0000004013943c40 c2i: 0x0000004013943c8c c2iUV: 0x0000004013943c58
 - compiled entry     0x000000400c510cc0
 - code size:         64
 - code start:        0x000000409600ff50
 - code end (excl):   0x000000409600ff90
 - method data:       0x000000409648c348
 - checked ex length: 0
 - linenumber start:  0x000000409600ff90
 - localvar length:   3
 - localvar start:    0x000000409600ff9a
 - compiled code: nmethod  14813  203       3       java.lang.String::checkBoundsOffCount (64 bytes)

------------------------ OptoAssembly for Compile_id = 336 -----------------------
#
#  void ( int, int, int )
#
#r012 c_rarg1   : parm 0: int
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B5 B6 B7 B4 )  Freq: 1

000     B1: #	out( B5 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     subw  R28, R13, R12	#@subI_reg_reg
020 +   blt  R11, zr, B5	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

024     B2: #	out( B6 B3 ) &lt;- in( B1 )  Freq: 1
024 +   blt  R12, zr, B6	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

028     B3: #	out( B7 B4 ) &lt;- in( B2 )  Freq: 0.999999
028 +   bgt  R11, R28, B7	#@cmpI_branch  P=0.000000 C=5375.000000

02c     B4: #	out( N1 ) &lt;- in( B3 )  Freq: 0.999999
02c     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
044 +   ret	// return register, #@Ret

048     B5: #	out( N1 ) &lt;- in( B1 )  Freq: 5e-07
048 +   spill R11 -&gt; [sp, #8]	# spill size = 32
04c +   spill R12 -&gt; [sp, #0]	# spill size = 32
050 +   spill R13 -&gt; [sp, #4]	# spill size = 32
054 +   li R11, #-187	# int, #@loadConI
058     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsOffCount @ bci:1 (line 4583) L[0]=sp + #8 L[1]=sp + #0 L[2]=sp + #4 STK[0]=sp + #8
        # OopMap {off=92/0x5c}
05c     #@ShouldNotReachHere

068     B6: #	out( N1 ) &lt;- in( B2 )  Freq: 5e-07
068 +   spill R11 -&gt; R8	# spill size = 32
06c +   spill R13 -&gt; [sp, #4]	# spill size = 32
070 +   spill R12 -&gt; [sp, #8]	# spill size = 32
074 +   li R11, #-187	# int, #@loadConI
078     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsOffCount @ bci:5 (line 4583) L[0]=R8 L[1]=sp + #8 L[2]=sp + #4 STK[0]=sp + #8
        # OopMap {off=124/0x7c}
07c     #@ShouldNotReachHere

088     B7: #	out( N1 ) &lt;- in( B3 )  Freq: 4.76837e-07
088 +   spill R11 -&gt; [sp, #8]	# spill size = 32
08c +   spill R12 -&gt; [sp, #0]	# spill size = 32
090 +   spill R13 -&gt; [sp, #4]	# spill size = 32
094 +   spill R28 -&gt; [sp, #12]	# spill size = 32
098 +   li R11, #-187	# int, #@loadConI
09c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsOffCount @ bci:12 (line 4583) L[0]=sp + #8 L[1]=sp + #0 L[2]=sp + #4 STK[0]=sp + #8 STK[1]=sp + #12
        # OopMap {off=160/0xa0}
0a0 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='337'>
----------------------- MetaData before Compile_id = 337 ------------------------
{method}
 - this oop:          0x0000004096009968
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;&lt;init&gt;&apos;
 - signature:         &apos;([BLjava/nio/charset/Charset;)V&apos;
 - max stack:         6
 - max locals:        3
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x00000040083172b0: 0xbbb i2c: 0x0000004013944dc0 c2i: 0x0000004013944e0c c2iUV: 0x0000004013944dd8
 - compiled entry     0x000000400c528600
 - code size:         10
 - code start:        0x0000004096009930
 - code end (excl):   0x000000409600993a
 - method data:       0x00000040964844c0
 - checked ex length: 0
 - linenumber start:  0x000000409600993a
 - localvar length:   3
 - localvar start:    0x0000004096009942
 - compiled code: nmethod  14828  233       3       java.lang.String::&lt;init&gt; (10 bytes)

------------------------ OptoAssembly for Compile_id = 337 -----------------------
#
#  void ( java/lang/String:NotNull:exact *, byte[int:&gt;=0]:exact *, sun/nio/cs/UTF_8:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: byte[int:&gt;=0]:exact *
#r016 c_rarg3:c_rarg3   : parm 2: sun/nio/cs/UTF_8:exact *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N48: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B5 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     spill R13 -&gt; R15	# spill size = 64
040     lwu  R14, [R12, #12]	# range, #@loadRange
044     NullCheck R12

044     B2: #	out( B4 B3 ) &lt;- in( B1 )  Freq: 0.999999
044 +   li R13, #0	# int, #@loadConI
048     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.String::&lt;init&gt;
        # java.lang.String::&lt;init&gt; @ bci:6 (line 1380) L[0]=_ L[1]=_ L[2]=_
        # OopMap {off=76/0x4c}

04c     B3: #	out( N48 ) &lt;- in( B2 )  Freq: 0.999979
        # Block is sole successor of call
04c     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

068     B4: #	out( N48 ) &lt;- in( B2 )  Freq: 9.99999e-06
068      -- 	// exception oop; no code emitted, #@CreateException
068 +   spill R10 -&gt; R11	# spill size = 64
06c +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
078 +   j rethrow_stub	#@RethrowException

080     B5: #	out( N48 ) &lt;- in( B1 )  Freq: 1.01328e-06
080 +   li R11, #-10	# int, #@loadConI
084     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::&lt;init&gt; @ bci:4 (line 1380) L[0]=_ L[1]=_ L[2]=_ STK[0]=_ STK[1]=_ STK[2]=_ STK[3]=#NULL
        # OopMap {off=136/0x88}
088 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='338'>
----------------------- MetaData before Compile_id = 338 ------------------------
{method}
 - this oop:          0x0000004096006b50
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0xc1000001  public 
 - name:              &apos;&lt;init&gt;&apos;
 - signature:         &apos;([BIILjava/nio/charset/Charset;)V&apos;
 - max stack:         7
 - max locals:        11
 - size of params:    5
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x0000004008321330: 0xbbaab i2c: 0x0000004013941240 c2i: 0x0000004013941294 c2iUV: 0x0000004013941260
 - compiled entry     0x000000400c54f440
 - code size:         813
 - code start:        0x0000004096006680
 - code end (excl):   0x00000040960069ad
 - method data:       0x00000040964939a0
 - checked ex length: 0
 - linenumber start:  0x00000040960069ad
 - localvar length:   25
 - localvar start:    0x0000004096006a22
 - compiled code: nmethod  14963  272       3       java.lang.String::&lt;init&gt; (813 bytes)

------------------------ OptoAssembly for Compile_id = 338 -----------------------
#
#  void ( java/lang/String:NotNull:exact *, byte[int:&gt;=0]:exact *, int, int, sun/nio/cs/UTF_8:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: byte[int:&gt;=0]:exact *
#r016 c_rarg3   : parm 2: int
#r018 c_rarg4   : parm 3: int
#r020 c_rarg5:c_rarg5   : parm 4: sun/nio/cs/UTF_8:exact *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N754: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B74 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
03c     spill R14 -&gt; [sp, #28]	# spill size = 32
040 +   spill R13 -&gt; [sp, #24]	# spill size = 32
044 +   spill R12 -&gt; [sp, #16]	# spill size = 64
048 +   spill R11 -&gt; [sp, #0]	# spill size = 64
04c +   beq   R15, zr, B74	#@cmpP_imm0_branch  P=0.000000 C=24058.000000

050     B2: #	out( B77 B3 ) &lt;- in( B1 )  Freq: 1
050     lwu  R7, [R12, #12]	# range, #@loadRange
054     NullCheck R12

054     B3: #	out( B69 B4 ) &lt;- in( B2 )  Freq: 0.999999
054 +   addw  R12, R13, R14	#@addI_reg_reg
058 +   subw  R8, R7, R14	#@subI_reg_reg
05c +   mv  R28, sun/nio/cs/UTF_8:exact *	# ptr, #@loadConP
074 +   blt  R13, zr, B69	#@cmpI_reg_imm0_branch  P=0.000000 C=5376.000000

078     B4: #	out( B70 B5 ) &lt;- in( B3 )  Freq: 0.999998
078 +   blt  R14, zr, B70	#@cmpI_reg_imm0_branch  P=0.000000 C=5376.000000

07c     B5: #	out( B75 B6 ) &lt;- in( B4 )  Freq: 0.999998
07c +   bgt  R13, R8, B75	#@cmpI_branch  P=0.000000 C=5376.000000

080     B6: #	out( B76 B7 ) &lt;- in( B5 )  Freq: 0.999997
080 +   beq  R14, zr, B76	#@cmpI_reg_imm0_branch  P=0.000000 C=5351.000000

084     B7: #	out( B71 B8 ) &lt;- in( B6 )  Freq: 0.999997
084 +   bne  R15, R28, B71	#@cmpP_branch  P=0.000000 C=5351.000000

088     B8: #	out( B30 B9 ) &lt;- in( B7 )  Freq: 0.999996
088 +   bge  R13, R12, B30	#@cmpI_branch  P=0.053171 C=98418.000000

08c     B9: #	out( B63 B10 ) &lt;- in( B8 )  Freq: 0.946825
08c +   addw  R28, R12, zr	#@convI2L_reg_reg
090 +   addw  R29, R7, zr	#@convI2L_reg_reg
094 +   addi  R28, R28, #-1	#@addL_reg_imm
098 +   bgeu  R13, R7, B63	#@cmpU_branch  P=0.000001 C=-1.000000

09c     B10: #	out( B63 B11 ) &lt;- in( B9 )  Freq: 0.946824
09c +   bgeu  R28, R29, B63	#@cmpUL_branch  P=0.000001 C=-1.000000

0a0     B11: #	out( B12 ) &lt;- in( B10 )  Freq: 0.946823
0a0 +   addiw  R29, R13, #1	#@addI_reg_imm
0a4     spill R13 -&gt; R28	# spill size = 32

0a8     B12: #	out( B68 B13 ) &lt;- in( B11 B14 ) Loop( B12-B14 inner pre of N639) Freq: 1.89365
0a8 +   addw  R30, R28, zr	#@convI2L_reg_reg
0ac     spill [sp, #16] -&gt; R31	# spill size = 64
0b0 +   add R30, R31, R30	# ptr, #@addP_reg_reg
0b4 +   lb  R31, [R30, #16]	# byte, #@loadB
0b8 +   blt  R31, zr, B68	#@cmpI_reg_imm0_branch  P=0.000000 C=93185.000000

0bc     B13: #	out( B15 B14 ) &lt;- in( B12 )  Freq: 1.89364
0bc +   addiw  R31, R28, #1	#@addI_reg_imm
0c0 +   bge  R31, R29, B15	#@cmpI_loop  P=0.500000 C=93185.000000

0c4     B14: #	out( B12 ) &lt;- in( B13 )  Freq: 0.946822
0c4 +   spill R31 -&gt; R28	# spill size = 32
0c8 +   j  B12	#@branch

0cc     B15: #	out( B64 B16 ) &lt;- in( B13 )  Freq: 0.946822
0cc +   li R29, #-2147483648	# int, #@loadConI
0d0 +   addiw  R16, R12, #-3	#@addI_reg_imm
0d4     CMove R16, (R12 lt R16), R16, R29	#@cmovI_cmpI
	
0dc +   bge  R31, R16, B64	#@cmpI_branch  P=0.000001 C=-1.000000

0e0     B16: #	out( B65 B17 ) &lt;- in( B15 )  Freq: 0.946821
0e0 +   li R14, #0	# int, #@loadConI
0e4 +   li R15, #4000	# int, #@loadConI
0ec     spill R31 -&gt; R13	# spill size = 32
0f0 +   addiw  R29, R28, #4	#@addI_reg_imm
0f4 +   # castII of R13, #@castII
0f4     bgeu  R13, R7, B65	#@cmpU_branch  P=0.000001 C=-1.000000

0f8     B17: #	out( B66 B18 ) &lt;- in( B16 )  Freq: 0.94682
0f8 +   bgeu  R31, R7, B66	#@cmpU_branch  P=0.000001 C=-1.000000

0fc     B18: #	out( B67 B19 ) &lt;- in( B17 )  Freq: 0.946819
0fc +   bgeu  R29, R7, B67	#@cmpU_branch  P=0.000001 C=-1.000000

100     B19: #	out( B20 ) &lt;- in( B18 B25 ) Loop( B19-B25 ) Freq: 17.7956
100 +   subw  R28, R16, R13	#@subI_reg_reg
104     CMove R28, (R16 lt R13), R28, R14	#@cmovI_cmpI
	
10c +   CMove R28, (R28 gtu R15), R28, R15	#@cmovI_cmpU
	
114 +   addw  R29, R28, R13	#@addI_reg_reg
        nop 	# 4 bytes pad for loops and calls

120     B20: #	out( B53 B21 ) &lt;- in( B19 B24 ) Loop( B20-B24 inner main of N132 strip mined) Freq: 334.674
120 +   addw  R28, R13, zr	#@convI2L_reg_reg
124     spill [sp, #16] -&gt; R30	# spill size = 64
128 +   add R28, R30, R28	# ptr, #@addP_reg_reg
12c +   lb  R30, [R28, #16]	# byte, #@loadB
130 +   lb  R31, [R28, #19]	# byte, #@loadB
134 +   lb  R10, [R28, #18]	# byte, #@loadB
138 +   lb  R11, [R28, #17]	# byte, #@loadB
13c +   blt  R30, zr, B53	#@cmpI_reg_imm0_branch  P=0.000000 C=93185.000000

140     B21: #	out( B56 B22 ) &lt;- in( B20 )  Freq: 334.674
140 +   blt  R11, zr, B56	#@cmpI_reg_imm0_branch  P=0.000000 C=93185.000000

144     B22: #	out( B54 B23 ) &lt;- in( B21 )  Freq: 334.674
144 +   blt  R10, zr, B54	#@cmpI_reg_imm0_branch  P=0.000000 C=93185.000000

148     B23: #	out( B57 B24 ) &lt;- in( B22 )  Freq: 334.674
148 +   blt  R31, zr, B57	#@cmpI_reg_imm0_branch  P=0.000000 C=93185.000000

14c     B24: #	out( B20 B25 ) &lt;- in( B23 )  Freq: 334.674
14c +   addiw  R13, R13, #4	#@addI_reg_imm
150 +   blt  R13, R29, B20	#@cmpI_loop  P=0.946829 C=93185.000000

154     B25: #	out( B19 B26 ) &lt;- in( B24 )  Freq: 17.795
154 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
154     ld  R31, [R23, #920]	# ptr, #@loadP
158 +   lwu zr, [R31]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringCoding::hasNegatives @ bci:20 (line 39) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #28 L[3]=R13
        # java.lang.String::&lt;init&gt; @ bci:59 (line 528) L[0]=sp + #0 L[1]=sp + #16 L[2]=sp + #24 L[3]=sp + #28 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_
        # OopMap {[0]=Oop [16]=Oop off=344/0x158}
15c +   blt  R13, R16, B19	#@cmpI_branch  P=0.946829 C=93185.000000

160     B26: #	out( B30 B27 ) &lt;- in( B64 B25 )  Freq: 0.946181
160 +   bge  R13, R12, B30	#@cmpI_branch  P=0.500000 C=-1.000000

164     B27: #	out( B73 B28 ) &lt;- in( B26 )  Freq: 0.473091
164 +   # castII of R13, #@castII
164     bgeu  R13, R7, B73	#@cmpU_branch  P=0.000001 C=-1.000000

168     B28: #	out( B58 B29 ) &lt;- in( B27 B29 ) Loop( B28-B29 inner post of N639) Freq: 0.94618
168 +   addw  R28, R13, zr	#@convI2L_reg_reg
16c     spill [sp, #16] -&gt; R29	# spill size = 64
170 +   add R28, R29, R28	# ptr, #@addP_reg_reg
174 +   lb  R31, [R28, #16]	# byte, #@loadB
178 +   blt  R31, zr, B58	#@cmpI_reg_imm0_branch  P=0.000000 C=93185.000000

17c     B29: #	out( B28 B30 ) &lt;- in( B28 )  Freq: 0.946179
17c +   addiw  R13, R13, #1	#@addI_reg_imm
180 +   blt  R13, R12, B28	#@cmpI_loop  P=0.500000 C=93185.000000

184     B30: #	out( B31 B31 ) &lt;- in( B26 B8 B29 )  Freq: 0.999351
184 +   spill [sp, #24] -&gt; R28	# spill size = 32
188 +   subw  R29, R7, R28	#@subI_reg_reg
18c     spill [sp, #28] -&gt; R8	# spill size = 32
190 +   CMove R8, (R29 lt R8), R8, R29	#@cmovI_cmpI
	
198 +   li R30, #1048576	# int, #@loadConI
19c +   addw  R28, R28, R8	#@addI_reg_reg
1a0     spill [sp, #28] -&gt; R31	# spill size = 32
1a4 +   addw  R29, R31, zr	#@convI2L_reg_reg
1a8 +   bleu  R31, R30, B31	#@cmpU_branch  P=0.999999 C=-1.000000

1ac     B31: #	out( B62 B32 ) &lt;- in( B30 B30 )  Freq: 0.999351
1ac +   bltu  R7, R28, B62	#@cmpU_branch  P=0.000001 C=-1.000000

1b0     B32: #	out( B62 B33 ) &lt;- in( B31 )  Freq: 0.99935
1b0 +   bltu  R31, R8, B62	#@cmpU_branch  P=0.000001 C=-1.000000

1b4     B33: #	out( B62 B34 ) &lt;- in( B32 )  Freq: 0.999349
1b4 +   blt  R8, zr, B62	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

1b8     B34: #	out( B59 B35 ) &lt;- in( B33 )  Freq: 0.999348
1b8 +   addi  R29, R29, #23	#@addL_reg_imm
1bc +   bgtu  R31, R30, B59	#@cmpU_branch  P=0.000001 C=-1.000000

1c0     B35: #	out( B59 B36 ) &lt;- in( B34 )  Freq: 0.999347
1c0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1c0     ld  R9, [R23, #288]	# ptr, #@loadP
1c4 +   andi  R7, R29, #-8	#@andL_reg_imm
1c8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1c8     ld  R28, [R23, #304]	# ptr, #@loadP
1cc +   add R7, R9, R7	# ptr, #@addP_reg_reg
1d0 +   bgeu  R7, R28, B59	#@cmpP_branch  P=0.000100 C=-1.000000

1d4     B36: #	out( B37 ) &lt;- in( B35 )  Freq: 0.999247
1d4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1d4     sd  R7, [R23, #288]	# ptr, #@storeP
1d8 +   li R7, #1	# long, #@loadConL
1dc +   sd  R7, [R9]	# long, #@storeL
1e0 +   mv  R7, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1f0 +   sw  R7, [R9, #8]	# compressed klass ptr, #@storeNKlass
1f4 +   sw  R31, [R9, #12]	# int, #@storeI

1f8     B37: #	out( B61 B38 ) &lt;- in( B60 B36 )  Freq: 0.999348
1f8     
1f8 +   srli  R7, R29, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
1fc +   # checkcastPP of R9, #@checkCastPP
1fc     addi  R11, R9, #16	# ptr, #@addP_reg_imm
200 +   encode_heap_oop  R19, R9	#@encodeHeapOop
204 +   beq  R8, zr, B61	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

208     B38: #	out( B45 B39 ) &lt;- in( B37 )  Freq: 0.999347
208 +   spill [sp, #24] -&gt; R28	# spill size = 32
20c +   addw  R28, R28, zr	#@convI2L_reg_reg
210     spill [sp, #16] -&gt; R29	# spill size = 64
214 +   add R28, R29, R28	# ptr, #@addP_reg_reg
218 +   addw  R12, R8, zr	#@convI2L_reg_reg
21c +   addi  R10, R28, #16	# ptr, #@addP_reg_imm
220     spill [sp, #28] -&gt; R29	# spill size = 32
224 +   blt  R8, R29, B45	#@cmpI_branch  P=0.001000 C=-1.000000

228     B39: #	out( B40 ) &lt;- in( B38 B45 )  Freq: 0.999347
228 +   CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

22c     B40: #	out( B46 B41 ) &lt;- in( B39 B61 )  Freq: 0.999348
22c     MEMBAR-store-store	#@membar_storestore
230 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
230     lb  R28, [R23, #56]	# byte, #@loadB
234 +   bne  R28, zr, B46	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

238     B41: #	out( B42 ) &lt;- in( B40 )  Freq: 0.998349
238 +   spill [sp, #0] -&gt; R18	# spill size = 64

23c     B42: #	out( B44 B43 ) &lt;- in( B72 B48 B46 B41 )  Freq: 0.999348
23c +   mv  R7, R18	# ptr -&gt; long, #@castP2X
240 +   mv  R28, R9	# ptr -&gt; long, #@castP2X
244 +   xorr  R28, R28, R7	#@xorL_reg_reg
248 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
24c +   sw  R19, [R18, #20]	# compressed ptr, #@storeN ! Field: java/lang/String.value (constant)
250 +   beq  R28, zr, B44	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

254     B43: #	out( B49 B44 ) &lt;- in( B42 )  Freq: 0.998349
254 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
258 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
264 +   add R10, R28, R7	# ptr, #@addP_reg_reg
268 +   lb  R7, [R10]	# byte, #@loadB
26c +   li R29, #4	# int, #@loadConI
270 +   bne  R7, R29, B49	#@cmpI_branch  P=0.001000 C=-1.000000

274     B44: #	out( N754 ) &lt;- in( B51 B52 B49 B43 B42 )  Freq: 0.999348
274 +   sb zr, [R18, #16]	# byte, #@storeimmB0 ! Field: java/lang/String.coder (constant)
278 +   #@membar_release
	fence iorw ow
27c +   #@membar_release
	fence iorw ow
27c +   # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
294 +   ret	// return register, #@Ret

298     B45: #	out( B39 ) &lt;- in( B38 )  Freq: 0.000999347
298 +   addi  R28, R12, #16	#@addL_reg_imm
29c +   srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
2a0 +   andi  R28, R28, #-8	#@andL_reg_imm
2a4 +   add R28, R9, R28	# ptr, #@addP_reg_reg
2a8 +   sub  R29, R7, R29	#@subL_reg_reg
2ac +   ClearArray R29, R28	#@clearArray_reg_reg
304     j  B39	#@branch

308     B46: #	out( B42 B47 ) &lt;- in( B40 )  Freq: 0.000999335
308 +   spill [sp, #0] -&gt; R18	# spill size = 64
30c +   lwu  R7, [R18, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
310 +   decode_heap_oop  R10, R7	#@decodeHeapOop
314 +   beq   R10, zr, B42	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

318     B47: #	out( B72 B48 ) &lt;- in( B46 )  Freq: 0.000499668
318 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
318     ld  R7, [R23, #32]	# int, #@loadL
31c +   beq  R7, zr, B72	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

320     B48: #	out( B42 ) &lt;- in( B47 )  Freq: 0.000499168
320 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
320     ld  R28, [R23, #48]	# ptr, #@loadP
324 +   add R28, R28, R7	# ptr, #@addP_reg_reg
328 +   addi  R7, R7, #-8	#@addL_reg_imm
32c +   sd  R10, [R28, #-8]	# ptr, #@storeP
330 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
330     sd  R7, [R23, #32]	# long, #@storeL
334 +   j  B42	#@branch

338     B49: #	out( B44 B50 ) &lt;- in( B43 )  Freq: 0.000998349
338 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
338     ld  R7, [R23, #64]	# int, #@loadL
33c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
33c     ld  R28, [R23, #80]	# ptr, #@loadP
340 +   #@membar_volatile
	fence iorw iorw
344 +   lb  R29, [R10]	# byte, #@loadB
348 +   beq  R29, zr, B44	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

34c     B50: #	out( B52 B51 ) &lt;- in( B49 )  Freq: 0.000499174
34c +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
350 +   bne  R7, zr, B52	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

354     B51: #	out( B44 ) &lt;- in( B50 )  Freq: 0.000249587
354 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
354     spill R23 -&gt; R11	# spill size = 64
358 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
388 +   j  B44	#@branch

38c     B52: #	out( B44 ) &lt;- in( B50 )  Freq: 0.000249587
38c +   add R28, R28, R7	# ptr, #@addP_reg_reg
390 +   addi  R7, R7, #-8	#@addL_reg_imm
394 +   sd  R10, [R28, #-8]	# ptr, #@storeP
398 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
398     sd  R7, [R23, #64]	# long, #@storeL
39c +   j  B44	#@branch

3a0     B53: #	out( B55 ) &lt;- in( B20 )  Freq: 0.000159585
3a0 +   spill R30 -&gt; R10	# spill size = 32
3a4 +   j  B55	#@branch

3a8     B54: #	out( B55 ) &lt;- in( B22 )  Freq: 0.000159585
3a8 +   addiw  R13, R13, #2	#@addI_reg_imm

3ac     B55: #	out( B58 ) &lt;- in( B53 B54 )  Freq: 0.00031917
3ac     spill R10 -&gt; R31	# spill size = 32
3b0 +   j  B58	#@branch

3b4     B56: #	out( B58 ) &lt;- in( B21 )  Freq: 0.000159585
3b4 +   addiw  R13, R13, #1	#@addI_reg_imm
3b8     spill R11 -&gt; R31	# spill size = 32
3bc +   j  B58	#@branch

3c0     B57: #	out( B58 ) &lt;- in( B23 )  Freq: 0.000159585
3c0 +   addiw  R13, R13, #3	#@addI_reg_imm

3c4     B58: #	out( N754 ) &lt;- in( B28 B68 B55 B56 B57 )  Freq: 0.000639694
3c4 +   li R11, #-187	# int, #@loadConI
3c8     spill [sp, #0] -&gt; R8	# spill size = 64
3cc +   spill R13 -&gt; [sp, #32]	# spill size = 32
3d0 +   spill R31 -&gt; [sp, #36]	# spill size = 32
3d4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringCoding::hasNegatives @ bci:12 (line 40) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #28 L[3]=sp + #32 STK[0]=sp + #36
        # java.lang.String::&lt;init&gt; @ bci:59 (line 528) L[0]=R8 L[1]=sp + #16 L[2]=sp + #24 L[3]=sp + #28 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_
        # OopMap {fp=Oop [16]=Oop off=984/0x3d8}
3d8     #@ShouldNotReachHere

3e4     B59: #	out( B78 B60 ) &lt;- in( B34 B35 )  Freq: 0.000100964
3e4 +   spill R29 -&gt; [sp, #32]	# spill size = 64
3e8 +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
400     spill [sp, #28] -&gt; R12	# spill size = 32
404     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # java.util.Arrays::copyOfRange @ bci:41 (line 3822) L[0]=sp + #16 L[1]=sp + #24 L[2]=_ L[3]=sp + #28 L[4]=_
        # java.lang.String::&lt;init&gt; @ bci:71 (line 529) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ STK[0]=sp + #0
        # OopMap {[0]=Oop [16]=Oop off=1032/0x408}

408     B60: #	out( B37 ) &lt;- in( B59 )  Freq: 0.000100962
        # Block is sole successor of call
408 +   spill R10 -&gt; R9	# spill size = 64
40c +   spill [sp, #32] -&gt; R29	# spill size = 64
410 +   j  B37	#@branch

414     B61: #	out( B40 ) &lt;- in( B37 )  Freq: 1.01262e-06
414 +   spill R11 -&gt; R28	# spill size = 64
418 +   addi  R29, R7, #-2	#@addL_reg_imm
41c     ClearArray R29, R28	#@clearArray_reg_reg
474     
474 +   j  B40	#@branch

478     B62: #	out( N754 ) &lt;- in( B33 B31 B32 )  Freq: 2.99805e-06
478 +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
480 +   li R11, #-52	# int, #@loadConI
484     spill [sp, #0] -&gt; R8	# spill size = 64
488 +   spill [sp, #24] -&gt; [sp, #16]	# spill size = 32
490     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # java.util.Arrays::copyOfRange @ bci:41 (line 3822) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=sp + #28 L[4]=_ STK[0]=sp + #28
        # java.lang.String::&lt;init&gt; @ bci:71 (line 529) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ STK[0]=R8
        # OopMap {fp=Oop [8]=Oop off=1172/0x494}
494     #@ShouldNotReachHere

4a0     B63: #	out( N754 ) &lt;- in( B10 B9 )  Freq: 1.9188e-06
4a0 +   li R11, #-138	# int, #@loadConI
4a4     spill [sp, #0] -&gt; R8	# spill size = 64
4a8 +   spill R12 -&gt; [sp, #40]	# spill size = 32
4ac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringCoding::hasNegatives @ bci:6 (line 39) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #28 L[3]=sp + #24 STK[0]=sp + #24 STK[1]=sp + #40
        # java.lang.String::&lt;init&gt; @ bci:59 (line 528) L[0]=R8 L[1]=sp + #16 L[2]=sp + #24 L[3]=sp + #28 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_
        # OopMap {fp=Oop [16]=Oop off=1200/0x4b0}
4b0     #@ShouldNotReachHere

4bc     B64: #	out( B26 ) &lt;- in( B15 )  Freq: 9.59395e-07
4bc +   spill R31 -&gt; R13	# spill size = 32
4c0 +   j  B26	#@branch

4c4     B65: #	out( N754 ) &lt;- in( B16 )  Freq: 9.59394e-07
4c4     #@ShouldNotReachHere

4d0     B66: #	out( N754 ) &lt;- in( B17 )  Freq: 9.59393e-07
4d0     #@ShouldNotReachHere

4dc     B67: #	out( N754 ) &lt;- in( B18 )  Freq: 9.59392e-07
4dc     #@ShouldNotReachHere

4e8     B68: #	out( B58 ) &lt;- in( B12 )  Freq: 9.02961e-07
4e8 +   spill R28 -&gt; R13	# spill size = 32
4ec +   j  B58	#@branch

4f0     B69: #	out( N754 ) &lt;- in( B3 )  Freq: 4.99999e-07
4f0 +   spill [sp, #0] -&gt; R8	# spill size = 64
4f4 +   spill [sp, #16] -&gt; [sp, #0]	# spill size = 64
4fc +   li R11, #-187	# int, #@loadConI
500     spill R13 -&gt; [sp, #16]	# spill size = 32
504 +   spill R14 -&gt; [sp, #20]	# spill size = 32
508 +   spill R15 -&gt; [sp, #32]	# spill size = 64
50c +   spill R7 -&gt; [sp, #28]	# spill size = 32
510     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsOffCount @ bci:1 (line 4583) L[0]=sp + #24 L[1]=sp + #20 L[2]=sp + #28 STK[0]=sp + #16
        # java.lang.String::&lt;init&gt; @ bci:14 (line 523) L[0]=R8 L[1]=sp + #0 L[2]=sp + #16 L[3]=sp + #20 L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_
        # OopMap {fp=Oop [0]=Oop [32]=Oop off=1300/0x514}
514     #@ShouldNotReachHere

520     B70: #	out( N754 ) &lt;- in( B4 )  Freq: 4.99999e-07
520 +   spill [sp, #0] -&gt; R8	# spill size = 64
524 +   spill [sp, #16] -&gt; [sp, #0]	# spill size = 64
52c +   li R11, #-187	# int, #@loadConI
530     spill R13 -&gt; [sp, #16]	# spill size = 32
534 +   spill R14 -&gt; [sp, #20]	# spill size = 32
538 +   spill R14 -&gt; [sp, #24]	# spill size = 32
53c +   spill R15 -&gt; [sp, #32]	# spill size = 64
540 +   spill R7 -&gt; [sp, #28]	# spill size = 32
544     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsOffCount @ bci:5 (line 4583) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #28 STK[0]=sp + #20
        # java.lang.String::&lt;init&gt; @ bci:14 (line 523) L[0]=R8 L[1]=sp + #0 L[2]=sp + #16 L[3]=sp + #20 L[4]=sp + #32 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_
        # OopMap {fp=Oop [0]=Oop [32]=Oop off=1352/0x548}
548     #@ShouldNotReachHere

554     B71: #	out( N754 ) &lt;- in( B7 )  Freq: 4.99998e-07
554 +   spill [sp, #0] -&gt; R8	# spill size = 64
558 +   li R11, #-187	# int, #@loadConI
55c     spill [sp, #16] -&gt; [sp, #0]	# spill size = 64
564 +   spill R13 -&gt; [sp, #8]	# spill size = 32
568 +   spill R14 -&gt; [sp, #12]	# spill size = 32
56c +   spill R15 -&gt; [sp, #24]	# spill size = 64
570     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::&lt;init&gt; @ bci:47 (line 527) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #12 L[4]=sp + #24 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ STK[0]=sp + #24 STK[1]=#Ptr0x00000040d827d340
        # OopMap {fp=Oop [0]=Oop [24]=Oop off=1396/0x574}
574     #@ShouldNotReachHere

580     B72: #	out( B42 ) &lt;- in( B47 )  Freq: 4.99661e-07
580 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
580     spill R23 -&gt; R11	# spill size = 64
584 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
5b4 +   j  B42	#@branch

5b8     B73: #	out( N754 ) &lt;- in( B27 )  Freq: 4.79373e-07
5b8     #@ShouldNotReachHere

5c4     B74: #	out( N754 ) &lt;- in( B1 )  Freq: 4.76837e-07
5c4 +   spill [sp, #0] -&gt; R8	# spill size = 64
5c8 +   li R11, #-187	# int, #@loadConI
5cc     spill R12 -&gt; [sp, #0]	# spill size = 64
5d0 +   spill R13 -&gt; [sp, #8]	# spill size = 32
5d4 +   spill R14 -&gt; [sp, #12]	# spill size = 32
5d8 +   spill R15 -&gt; [sp, #24]	# spill size = 64
5dc +   spill R15 -&gt; [sp, #32]	# spill size = 64
5e0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.Objects::requireNonNull @ bci:1 (line 208) L[0]=sp + #32 STK[0]=sp + #24
        # java.lang.String::&lt;init&gt; @ bci:6 (line 522) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #12 L[4]=sp + #24 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_
        # OopMap {fp=Oop [0]=Oop [24]=Oop [32]=Oop off=1508/0x5e4}
5e4     #@ShouldNotReachHere

5f0     B75: #	out( N754 ) &lt;- in( B5 )  Freq: 4.76836e-07
5f0 +   li R11, #-187	# int, #@loadConI
5f4     spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
5fc +   spill R15 -&gt; [sp, #40]	# spill size = 64
600 +   spill R7 -&gt; [sp, #36]	# spill size = 32
604     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsOffCount @ bci:12 (line 4583) L[0]=sp + #24 L[1]=sp + #28 L[2]=sp + #36 STK[0]=sp + #24 STK[1]=R8
        # java.lang.String::&lt;init&gt; @ bci:14 (line 523) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #24 L[3]=sp + #28 L[4]=sp + #40 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_
        # OopMap {[0]=Oop [8]=Oop [40]=Oop off=1544/0x608}
608     #@ShouldNotReachHere

614     B76: #	out( N754 ) &lt;- in( B6 )  Freq: 4.76836e-07
614 +   spill [sp, #0] -&gt; R8	# spill size = 64
618 +   spill [sp, #16] -&gt; [sp, #0]	# spill size = 64
620 +   li R11, #-187	# int, #@loadConI
624     spill R13 -&gt; [sp, #8]	# spill size = 32
628 +   spill R14 -&gt; [sp, #16]	# spill size = 32
62c +   spill R15 -&gt; [sp, #24]	# spill size = 64
630     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::&lt;init&gt; @ bci:18 (line 524) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #24 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ STK[0]=sp + #16
        # OopMap {fp=Oop [0]=Oop [24]=Oop off=1588/0x634}
634     #@ShouldNotReachHere

640     B77: #	out( N754 ) &lt;- in( B2 )  Freq: 1.01328e-06
640 +   li R11, #-10	# int, #@loadConI
644     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::&lt;init&gt; @ bci:13 (line 523) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ STK[0]=_ STK[1]=_ STK[2]=#NULL
        # OopMap {off=1608/0x648}
648     #@ShouldNotReachHere

654     B78: #	out( N754 ) &lt;- in( B59 )  Freq: 1.00964e-09
654      -- 	// exception oop; no code emitted, #@CreateException
654 +   spill R10 -&gt; R11	# spill size = 64
658 +   # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
664 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='339'>
----------------------- MetaData before Compile_id = 339 ------------------------
{method}
 - this oop:          0x0000004096307e80
 - method holder:     &apos;jdk/internal/module/ModulePath&apos;
 - constants:         0x0000004096302d28 constant pool [1026]/operands[112] {0x0000004096302d28} for &apos;jdk/internal/module/ModulePath&apos; cache=0x0000004096308cb8
 - access:            0x81000002  private 
 - name:              &apos;toPackageName&apos;
 - signature:         &apos;(Ljava/nio/file/Path;Ljava/lang/String;)Ljava/util/Optional;&apos;
 - max stack:         4
 - max locals:        6
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x00000040083172b0: 0xbbb i2c: 0x0000004013944dc0 c2i: 0x0000004013944e0c c2iUV: 0x0000004013944dd8
 - compiled entry     0x000000400c55d340
 - code size:         133
 - code start:        0x0000004096307d90
 - code end (excl):   0x0000004096307e15
 - method data:       0x0000004096497c98
 - checked ex length: 0
 - linenumber start:  0x0000004096307e15
 - localvar length:   7
 - localvar start:    0x0000004096307e28
 - compiled code: nmethod  15531  276       3       jdk.internal.module.ModulePath::toPackageName (133 bytes)

------------------------ OptoAssembly for Compile_id = 339 -----------------------
#
#  java/util/Optional:exact * ( jdk/internal/module/ModulePath:NotNull *, java/nio/file/Path *, java/lang/String:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: jdk/internal/module/ModulePath:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/nio/file/Path *
#r016 c_rarg3:c_rarg3   : parm 2: java/lang/String:exact *
# -- Old sp -- Framesize: 96 --
#r263 sp+92: in_preserve
#r262 sp+88: return address
#r261 sp+84: in_preserve
#r260 sp+80: saved fp register
#r259 sp+76: pad2, stack alignment
#r258 sp+72: pad2, stack alignment
#r257 sp+68: Fixed slot 1
#r256 sp+64: Fixed slot 0
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
0000    N2589: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0000    # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

0020    B1: #	out( B244 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0020    # stack bang size=96
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #96
	
003c    spill R13 -&gt; [sp, #0]	# spill size = 64
0040    lwu  R28, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0044    NullCheck R12

0044    B2: #	out( B203 B3 ) &lt;- in( B1 )  Freq: 0.999999
0044 +  mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d06f96b0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0054 +  far_bne  R28, R7, B203	#@far_cmpN_branch  P=0.000001 C=-1.000000

005c    B3: #	out( B272 B4 ) &lt;- in( B2 )  Freq: 0.999998
005c +  # checkcastPP of R12, #@checkCastPP
005c    spill R12 -&gt; [sp, #8]	# spill size = 64
0060 +  spill R12 -&gt; R11	# spill size = 64
0064 +  spill R12 -&gt; R8	# spill size = 64
0068    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 276) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=R8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=108/0x6c}

006c    B4: #	out( B245 B5 ) &lt;- in( B3 )  Freq: 0.999978
        # Block is sole successor of call
006c +  lwu  R28, [R8, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0070 +  #@membar_acquire
	fence ir iorw
0074 +  decode_heap_oop  R7, R28	#@decodeHeapOop
0078    lwu  R30, [R7, #12]	# range, #@loadRange
007c    NullCheck R7

007c    B5: #	out( B222 B6 ) &lt;- in( B4 )  Freq: 0.999977
007c +  far_bleu  R30, zr, B222	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000000 C=5374.000000

0084    B6: #	out( B246 B7 ) &lt;- in( B5 )  Freq: 0.999976
0084 +  lwu  R7, [R8, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0088 +  decode_heap_oop  R31, R7	#@decodeHeapOop
008c +  addw  R28, R30, zr	#@convI2L_reg_reg
0090 +  #@membar_acquire
	fence ir iorw
0094 +  slli  R7, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0098 +  addiw  R8, R30, #-1	#@addI_reg_imm
009c    lwu  R29, [R31, #12]	# range, #@loadRange
00a0    NullCheck R31

00a0    B7: #	out( B199 B8 ) &lt;- in( B6 )  Freq: 0.999975
00a0 +  add R7, R31, R7	# ptr, #@addP_reg_reg
00a4 +  far_bgeu R8, R29, B199	#@far_cmpU_branch  P=0.000001 C=-1.000000

00ac    B8: #	out( B140 B9 ) &lt;- in( B7 )  Freq: 0.999974
00ac +  lw  R8, [R7, #12]	# int, #@loadI
00b0 +  addiw  R29, R8, #-1	#@addI_reg_imm
00b4 +  ble  R29, zr, B140	#@cmpI_reg_imm0_branch  P=0.001489 C=5374.000000

00b8    B9: #	out( B200 B10 ) &lt;- in( B8 )  Freq: 0.998486
00b8 +  spill [sp, #8] -&gt; R7	# spill size = 64
00bc +  lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
00c0 +  li R28, #1048576	# int, #@loadConI
00c4 +  decode_heap_oop  R10, R7	#@decodeHeapOop
00c8 +  far_bgtu R29, R28, B200	#@far_cmpU_branch  P=0.000001 C=-1.000000

00d0    B10: #	out( B11 ) &lt;- in( B9 )  Freq: 0.998485
00d0 +  addw  R7, R8, zr	#@convI2L_reg_reg
00d4 +  addi  R7, R7, #-1	#@addL_reg_imm

00d8    B11: #	out( B247 B12 ) &lt;- in( B10 B200 )  Freq: 0.998486
00d8    lwu  R31, [R10, #12]	# range, #@loadRange
00dc    NullCheck R10

00dc    B12: #	out( B204 B13 ) &lt;- in( B11 )  Freq: 0.998485
00dc +  addi  R30, R7, #23	#@addL_reg_imm
00e0 +  far_bltu R31, R29, B204	#@far_cmpU_branch  P=0.000001 C=-1.000000

00e8    B13: #	out( B168 B14 ) &lt;- in( B12 )  Freq: 0.998484
00e8 +  andi  R31, R30, #-8	#@andL_reg_imm
00ec +  far_bgtu R29, R28, B168	#@far_cmpU_branch  P=0.000001 C=-1.000000

00f4    B14: #	out( B168 B15 ) &lt;- in( B13 )  Freq: 0.998483
00f4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
00f4    ld  R9, [R23, #288]	# ptr, #@loadP
00f8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
00f8    ld  R28, [R23, #304]	# ptr, #@loadP
00fc +  add R7, R9, R31	# ptr, #@addP_reg_reg
0100 +  far_bgeu  R7, R28, B168	#@far_cmpP_branch  P=0.000100 C=-1.000000

0108    B15: #	out( B16 ) &lt;- in( B14 )  Freq: 0.998383
0108 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0108    sd  R7, [R23, #288]	# ptr, #@storeP
010c +  li R7, #1	# long, #@loadConL
0110 +  sd  R7, [R9]	# long, #@storeL
0114 +  mv  R7, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0124 +  sw  R7, [R9, #8]	# compressed klass ptr, #@storeNKlass
0128 +  sw  R29, [R9, #12]	# int, #@storeI

012c    B16: #	out( B201 B17 ) &lt;- in( B169 B15 )  Freq: 0.998484
012c    
012c +  li R28, #1	# int, #@loadConI
0130 +  srli  R7, R30, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
0134 +  # checkcastPP of R9, #@checkCastPP
0134    addi  R11, R9, #16	# ptr, #@addP_reg_imm
0138 +  encode_heap_oop  R18, R9	#@encodeHeapOop
013c +  # castII of R8, #@castII
013c    far_beq  R8, R28, B201	#@far_cmpI_branch  P=0.000001 C=-1.000000

0144    B17: #	out( B158 B18 ) &lt;- in( B16 )  Freq: 0.998483
0144 +  addiw  R30, R8, #-1	#@addI_reg_imm
0148 +  addi  R10, R10, #16	# ptr, #@addP_reg_imm
014c +  blt  R30, R29, B158	#@cmpI_branch  P=0.001000 C=-1.000000

0150    B18: #	out( B19 ) &lt;- in( B17 )  Freq: 0.997484
0150 +  addi  R7, R31, #-16	#@addL_reg_imm
0154 +  srli  R12, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
0158 +  CALL, runtime leaf nofp 0x000000401396d840	#@CallLeafNoFPDirect jlong_disjoint_arraycopy
        No JVM State Info
        # 

015c    B19: #	out( B166 B20 ) &lt;- in( B158 B18 B201 )  Freq: 0.998484
015c    MEMBAR-store-store	#@membar_storestore
0160 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0160    ld  R31, [R23, #288]	# ptr, #@loadP
0164 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0164    ld  R7, [R23, #304]	# ptr, #@loadP
0168 +  addi  R28, R31, #32	# ptr, #@addP_reg_imm
016c +  far_bgeu  R28, R7, B166	#@far_cmpP_branch  P=0.000100 C=-1.000000

0174    B20: #	out( B21 ) &lt;- in( B19 )  Freq: 0.998384
0174 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0174    sd  R28, [R23, #288]	# ptr, #@storeP
0178 +  li R7, #1	# long, #@loadConL
017c +  mv  R28, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d06f96b0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
018c +  sd  R7, [R31]	# long, #@storeL
0190 +  sw  R28, [R31, #8]	# compressed klass ptr, #@storeNKlass
0194 +  sw  zr, [R31, #12]	# int, #@storeimmI0
0198 +  sw  zr, [R31, #16]	# int, #@storeimmI0
019c +  sd  zr, [R31, #24]	# long, #@storeimmL0

01a0    B21: #	out( B22 ) &lt;- in( B167 B20 )  Freq: 0.998484
01a0 +  sw  R18, [R31, #20]	# compressed ptr, #@storeN
01a4    
01a4    spill [sp, #8] -&gt; R7	# spill size = 64
01a8 +  lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
01ac +  # checkcastPP of R31, #@checkCastPP
01ac    sw  R7, [R31, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixPath.fs

01b0    B22: #	out( B142 B23 ) &lt;- in( B141 B21 )  Freq: 0.999972
01b0 +  mv  R11, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
01c0 +  # checkcastPP of R31, #@checkCastPP
01c0    beq   R31, zr, B142	#@cmpP_imm0_branch  P=0.001489 C=5374.000000

01c4    B23: #	out( B205 B24 ) &lt;- in( B22 )  Freq: 0.998484
01c4 +  lwu  R28, [R31, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
01c8 +  mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d06f96b0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
01d8 +  far_bne  R28, R7, B205	#@far_cmpN_branch  P=0.000001 C=-1.000000

01e0    B24: #	out( B212 B25 ) &lt;- in( B23 )  Freq: 0.998483
01e0 +  # checkcastPP of R31, #@checkCastPP
01e0    lwu  R28, [R31, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
01e4 +  #@membar_acquire
	fence ir iorw
01e8 +  decode_heap_oop  R8, R28	#@decodeHeapOop
01ec +  far_bne   R8, zr, B212	#@far_cmpP_imm0_branch  P=0.000000 C=5379.000000

01f4    B25: #	out( B170 B26 ) &lt;- in( B24 )  Freq: 0.998482
01f4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
01f4    ld  R10, [R23, #288]	# ptr, #@loadP
01f8 +  lwu  R29, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
01fc +  lwu  R7, [R31, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
0200 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0200    ld  R28, [R23, #304]	# ptr, #@loadP
0204 +  addi  R30, R10, #24	# ptr, #@addP_reg_imm
0208 +  decode_heap_oop  R12, R29	#@decodeHeapOop
020c +  decode_heap_oop  R8, R7	#@decodeHeapOop
0210 +  far_bgeu  R30, R28, B170	#@far_cmpP_branch  P=0.000100 C=-1.000000

0218    B26: #	out( B27 ) &lt;- in( B25 )  Freq: 0.998382
0218 +  li R7, #1	# long, #@loadConL
021c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
021c    sd  R30, [R23, #288]	# ptr, #@storeP
0220 +  sd  R7, [R10]	# long, #@storeL
0224 +  sw  R11, [R10, #8]	# compressed klass ptr, #@storeNKlass
0228 +  sw  zr, [R10, #12]	# int, #@storeimmI0
022c +  sd  zr, [R10, #16]	# long, #@storeimmL0

0230    B27: #	out( B248 B28 ) &lt;- in( B171 B26 )  Freq: 0.998482
0230    
0230 +  MEMBAR-store-store	#@membar_storestore
0234 +  # checkcastPP of R10, #@checkCastPP
0234    lwu  R14, [R12, #12]	# range, #@loadRange
0238    NullCheck R12

0238    B28: #	out( B270 B29 ) &lt;- in( B27 )  Freq: 0.998481
0238 +  spill R10 -&gt; [sp, #16]	# spill size = 64
023c +  spill R31 -&gt; [sp, #8]	# spill size = 64
0240 +  li R13, #0	# int, #@loadConI
0244    spill R10 -&gt; R11	# spill size = 64
0248 +  mv  R15, sun/nio/cs/UTF_8:exact *	# ptr, #@loadConP
0260    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.String::&lt;init&gt;
        # java.lang.String::&lt;init&gt; @ bci:6 (line 1380) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.Util::toString @ bci:8 (line 63) L[0]=_ STK[0]=sp + #16
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=sp + #8 STK[0]=sp + #8 STK[1]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=612/0x264}

0264    B29: #	out( B202 B30 ) &lt;- in( B28 )  Freq: 0.998461
        # Block is sole successor of call
0264 +  far_beq   R8, zr, B202	#@far_cmpP_imm0_branch  P=0.000001 C=-1.000000

026c    B30: #	out( B159 B31 ) &lt;- in( B29 )  Freq: 0.99846
026c +  #@membar_release
	fence iorw ow
0270 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0270    lb  R28, [R23, #56]	# byte, #@loadB
0274 +  bne  R28, zr, B159	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0278    B31: #	out( B32 ) &lt;- in( B30 )  Freq: 0.997462
0278 +  spill [sp, #8] -&gt; R9	# spill size = 64

027c    B32: #	out( B34 B33 ) &lt;- in( B217 B161 B159 B31 )  Freq: 0.99846
027c +  mv  R7, R9	# ptr -&gt; long, #@castP2X
0280    spill [sp, #16] -&gt; R29	# spill size = 64
0284 +  mv  R28, R29	# ptr -&gt; long, #@castP2X
0288 +  xorr  R28, R28, R7	#@xorL_reg_reg
028c +  encode_heap_oop  R29, R29	#@encodeHeapOop
0290 +  srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0294 +  sw  R29, [R9, #24]	# compressed ptr, #@storeN ! Field: volatile sun/nio/fs/UnixPath.stringValue
0298 +  beq  R28, zr, B34	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

029c    B33: #	out( B162 B34 ) &lt;- in( B32 )  Freq: 0.997462
029c +  srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
02a0 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
02ac +  add R10, R28, R7	# ptr, #@addP_reg_reg
02b0 +  lb  R28, [R10]	# byte, #@loadB
02b4 +  li R29, #4	# int, #@loadConI
02b8 +  bne  R28, R29, B162	#@cmpI_branch  P=0.001000 C=-1.000000

02bc    B34: #	out( B249 B35 ) &lt;- in( B164 B165 B162 B33 B32 )  Freq: 0.99846
02bc +  #@membar_volatile
	fence iorw iorw
02c0 +  lwu  R7, [R9, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
02c4 +  #@membar_acquire
	fence ir iorw
02c8 +  decode_heap_oop  R30, R7	#@decodeHeapOop
02cc    lwu  R28, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
02d0    NullCheck R30

02d0    B35: #	out( B250 B36 ) &lt;- in( B34 )  Freq: 0.998459
02d0 +  spill [sp, #0] -&gt; R29	# spill size = 64
02d4    lwu  R7, [R29, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
02d8    NullCheck R29

02d8    B36: #	out( B251 B37 ) &lt;- in( B35 )  Freq: 0.998458
02d8 +  decode_heap_oop  R31, R7	#@decodeHeapOop
02dc +  decode_heap_oop  R11, R28	#@decodeHeapOop
02e0    lwu  R28, [R11, #12]	# range, #@loadRange
02e4    NullCheck R11

02e4    B37: #	out( B252 B38 ) &lt;- in( B36 )  Freq: 0.998457
02e4 +  lb  R13, [R30, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
02e8 +  sraw  R10, R28, R13	#@rShiftI_reg_reg
02ec    lwu  R12, [R31, #12]	# range, #@loadRange
02f0    NullCheck R31

02f0    B38: #	out( B213 B39 ) &lt;- in( B37 )  Freq: 0.998456
02f0 +  lb  R14, [R29, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
02f4 +  sraw  R8, R12, R14	#@rShiftI_reg_reg
02f8 +  far_ble  R8, zr, B213	#@far_cmpI_reg_imm0_branch  P=0.000000 C=5330.000000

0300    B39: #	out( B214 B40 ) &lt;- in( B38 )  Freq: 0.998456
0300 +  li R7, #1	# int, #@loadConI
0304 +  far_bne  R8, R7, B214	#@far_cmpI_branch  P=0.000000 C=5330.000000

030c    B40: #	out( B215 B41 ) &lt;- in( B39 )  Freq: 0.998455
030c +  far_bne  R14, zr, B215	#@far_cmpI_reg_imm0_branch  P=0.000000 C=66755.000000

0314    B41: #	out( B223 B42 ) &lt;- in( B40 )  Freq: 0.998455
0314 +  far_bleu  R12, zr, B223	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000000 C=33969.000000

031c    B42: #	out( B224 B43 ) &lt;- in( B41 )  Freq: 0.998454
031c +  lbu  R12, [R31, #16]	# byte, #@loadUB
0320 +  li R28, #46	# int, #@loadConI
0324 +  far_beq  R12, R28, B224	#@far_cmpI_branch  P=0.000000 C=5376.000000

032c    B43: #	out( B216 B44 ) &lt;- in( B42 )  Freq: 0.998454
032c +  far_bne  R13, zr, B216	#@far_cmpI_reg_imm0_branch  P=0.000000 C=66755.000000

0334    B44: #	out( B269 B45 ) &lt;- in( B43 )  Freq: 0.998453
0334 +  spill R30 -&gt; R8	# spill size = 64
0338 +  li R13, #46	# int, #@loadConI
033c    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringLatin1::replace
        # java.lang.String::replace @ bci:18 (line 2801) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # java.lang.String::replace @ bci:63 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop off=832/0x340}

0340    B45: #	out( B47 B46 ) &lt;- in( B44 )  Freq: 0.998433
        # Block is sole successor of call
0340 +  beq   R10, zr, B47	#@cmpP_imm0_branch  P=0.000744 C=5376.000000

0344    B46: #	out( B47 ) &lt;- in( B45 )  Freq: 0.997691
0344 +  spill R10 -&gt; R8	# spill size = 64

0348    B47: #	out( B218 B48 ) &lt;- in( B46 B45 )  Freq: 0.998433
0348 +  lwu  R16, [R8, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
034c +  lb  R15, [R8, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0350    spill R8 -&gt; R14	# spill size = 64
0354 +  decode_heap_oop  R8, R16	#@decodeHeapOop
0358 +  far_bne  R15, zr, B218	#@far_cmpI_reg_imm0_branch  P=0.000000 C=66755.000000

0360    B48: #	out( B253 B49 ) &lt;- in( B47 )  Freq: 0.998433
0360    lwu  R12, [R8, #12]	# range, #@loadRange
0364    NullCheck R8

0364    B49: #	out( B225 B50 ) &lt;- in( B48 )  Freq: 0.998432
0364 +  far_bleu  R12, zr, B225	#@far_cmpUEqNeLeGt_imm0_branch  P=0.000000 C=5375.000000

036c    B50: #	out( B52 B51 ) &lt;- in( B49 )  Freq: 0.998431
036c +  li R13, #46	# int, #@loadConI
0370 +  addi  R11, R8, #16	# ptr, #@addP_reg_imm
0374    StringUTF16 IndexOf char[] R11,R12,R13 -&gt; R10
0624 +  li R28, #-1	# int, #@loadConI
0628 +  bne  R10, R28, B52	#@cmpI_branch  P=0.705438 C=17229.000000

062c    B51: #	out( B62 ) &lt;- in( B50 )  Freq: 0.294099
062c +  li R29, #2	# int, #@loadConI
0630 +  li R30, #0	# int, #@loadConI
0634 +  j  B62	#@branch

0638    B52: #	out( B100 ) &lt;- in( B50 )  Freq: 0.704332
0638 +  li R31, #2	# int, #@loadConI
063c +  li R12, #0	# int, #@loadConI
0640 +  j  B100	#@branch

0644    B53: #	out( B54 ) &lt;- in( B120 )  Freq: 0.517388
0644 +  spill [sp, #8] -&gt; R13	# spill size = 32

0648    B54: #	out( B191 B55 ) &lt;- in( B133 B53 B138 ) top-of-loop Freq: 2.39055
0648 +  spill [sp, #16] -&gt; R10	# spill size = 32
064c +  addiw  R30, R10, #1	#@addI_reg_imm
0650 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0650    ld  R7, [R23, #920]	# ptr, #@loadP
0654 +  lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # jdk.internal.module.Checks::isTypeName @ bci:35 (line 135) L[0]=sp + #0 L[1]=_ L[2]=R30 L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {[0]=Oop off=1620/0x654}
0658 +  spill [sp, #0] -&gt; R17	# spill size = 64
065c +  lwu  R16, [R17, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0660 +  lb  R31, [R17, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0664 +  decode_heap_oop  R14, R16	#@decodeHeapOop
0668 +  bne  R31, zr, B191	#@cmpI_reg_imm0_branch  P=0.000000 C=66755.000000

066c    B55: #	out( B243 B56 ) &lt;- in( B54 )  Freq: 2.39055
066c    lwu  R8, [R14, #12]	# range, #@loadRange
0670    NullCheck R14

0670    B56: #	out( B198 B57 ) &lt;- in( B55 )  Freq: 2.39055
0670 +  subw  R28, R8, R10	#@subI_reg_reg
0674 +  addiw  R12, R28, #-1	#@addI_reg_imm
0678 +  bgeu  R30, R8, B198	#@cmpU_branch  P=0.000000 C=5375.000000

067c    B57: #	out( B176 B58 ) &lt;- in( B56 )  Freq: 2.39055
067c +  blt  R12, zr, B176	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0680    B58: #	out( B60 B59 ) &lt;- in( B57 )  Freq: 2.39055
0680 +  spill R31 -&gt; R28	# spill size = 32
0684 +  addw  R31, R10, zr	#@convI2L_reg_reg
0688 +  add R31, R14, R31	# ptr, #@addP_reg_reg
068c +  addi  R11, R31, #17	# ptr, #@addP_reg_imm
0690    spill R10 -&gt; R7	# spill size = 32
0694 +  spill R13 -&gt; R29	# spill size = 32
0698 +  li R13, #46	# int, #@loadConI
069c    StringUTF16 IndexOf char[] R11,R12,R13 -&gt; R10
094c +  blt  R10, zr, B60	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0950    B59: #	out( B60 ) &lt;- in( B58 )  Freq: 2.38816
0950 +  addw  R31, R7, R10	#@addI_reg_reg
0954 +  addiw  R10, R31, #1	#@addI_reg_imm

0958    B60: #	out( B99 B61 ) &lt;- in( B59 B58 )  Freq: 2.39055
0958 +  li R31, #-1	# int, #@loadConI
095c +  bne  R10, R31, B99	#@cmpI_branch  P=0.705438 C=12154.000000

0960    B61: #	out( B62 ) &lt;- in( B60 )  Freq: 0.704163
0960 +  spill R17 -&gt; R14	# spill size = 64
0964 +  spill R28 -&gt; R15	# spill size = 32

0968    B62: #	out( B219 B63 ) &lt;- in( B61 B51 )  Freq: 0.998262
0968 +  decode_heap_oop  R11, R16	#@decodeHeapOop
096c +  lwu  R28, [R11, #12]	# range, #@loadRange
0970 +  sraw  R8, R28, R15	#@rShiftI_reg_reg
0974 +  blt  R30, zr, B219	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

0978    B63: #	out( B226 B64 ) &lt;- in( B62 )  Freq: 0.998262
0978 +  bgt  R30, R8, B226	#@cmpI_branch  P=0.000000 C=5375.000000

097c    B64: #	out( B66 B65 ) &lt;- in( B63 )  Freq: 0.998261
097c +  bne  R30, zr, B66	#@cmpI_reg_imm0_branch  P=0.627790 C=5376.000000

0980    B65: #	out( B70 ) &lt;- in( B64 )  Freq: 0.371563
0980 +  spill R14 -&gt; R10	# spill size = 64
0984 +  j  B70	#@branch

0988    B66: #	out( B232 B67 ) &lt;- in( B64 )  Freq: 0.626699
0988 +  subw  R13, R8, R30	#@subI_reg_reg
098c +  far_bne  R15, zr, B232	#@far_cmpI_reg_imm0_branch  P=0.000000 C=66755.000000

0994    B67: #	out( B267 B68 ) &lt;- in( B66 )  Freq: 0.626698
0994 +  spill R29 -&gt; [sp, #0]	# spill size = 32
0998 +  spill R14 -&gt; R8	# spill size = 64
099c +  spill R30 -&gt; R12	# spill size = 32
09a0    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringLatin1::newString
        # java.lang.String::substring @ bci:41 (line 2707) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isTypeName @ bci:40 (line 136) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=2468/0x9a4}

09a4    B68: #	out( B211 B69 ) &lt;- in( B67 )  Freq: 0.626686
        # Block is sole successor of call
09a4 +  beq   R10, zr, B211	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

09a8    B69: #	out( B70 ) &lt;- in( B68 )  Freq: 0.626685
09a8 +  spill R8 -&gt; R14	# spill size = 64
09ac +  spill [sp, #0] -&gt; R29	# spill size = 32

09b0    B70: #	out( B254 B71 ) &lt;- in( B65 B69 )  Freq: 0.998248
09b0 +  lwu  R28, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
09b4 +  decode_heap_oop  R7, R28	#@decodeHeapOop
09b8    lwu  R8, [R7, #12]	# range, #@loadRange
09bc    NullCheck R7

09bc    B71: #	out( B227 B72 ) &lt;- in( B70 )  Freq: 0.998247
09bc +  bleu  R8, zr, B227	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=8568.000000

09c0    B72: #	out( B268 B73 ) &lt;- in( B71 )  Freq: 0.998246
09c0 +  spill R10 -&gt; R8	# spill size = 64
09c4 +  spill R29 -&gt; [sp, #8]	# spill size = 32
09c8 +  spill R14 -&gt; [sp, #0]	# spill size = 64
09cc +  mv  R11, java/util/ImmutableCollections$SetN:exact *	# ptr, #@loadConP
09e4    spill R10 -&gt; R12	# spill size = 64
09e8    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.ImmutableCollections$SetN::probe
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {fp=Oop [0]=Oop off=2540/0x9ec}

09ec    B73: #	out( B228 B74 ) &lt;- in( B72 )  Freq: 0.998226
        # Block is sole successor of call
09ec +  spill R8 -&gt; R30	# spill size = 64
09f0 +  lwu  R7, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
09f4 +  lb  R28, [R30, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
09f8 +  decode_heap_oop  R12, R7	#@decodeHeapOop
09fc +  bge  R10, zr, B228	#@cmpI_reg_imm0_branch  P=0.000000 C=8453.000000

0a00    B74: #	out( B220 B75 ) &lt;- in( B73 )  Freq: 0.998226
0a00 +  bne  R28, zr, B220	#@cmpI_reg_imm0_branch  P=0.000000 C=66755.000000

0a04    B75: #	out( B255 B76 ) &lt;- in( B74 )  Freq: 0.998225
0a04    lwu  R31, [R12, #12]	# range, #@loadRange
0a08    NullCheck R12

0a08    B76: #	out( B229 B77 ) &lt;- in( B75 )  Freq: 0.998224
0a08 +  bleu  R31, zr, B229	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=33969.000000

0a0c    B77: #	out( B221 B78 ) &lt;- in( B76 )  Freq: 0.998224
0a0c +  lbu  R14, [R12, #16]	# byte, #@loadUB
0a10 +  addw  R7, R14, zr	#@convI2L_reg_reg
0a14 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0a18 +  mv  R10, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058bea0&gt; *	# ptr, #@loadConP
0a30 +  mv  R29, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058bea0&gt; *	# ptr, #@loadConP
0a48 +  add R7, R10, R7	# ptr, #@addP_reg_reg
0a4c +  sraw  R10, R31, R28	#@rShiftI_reg_reg
0a50 +  lw  R29, [R7, #16]	# int, #@loadI
0a54 +  li R28, #28672	# int, #@loadConI
0a58 +  li R7, #20480	# int, #@loadConI
0a5c +  andr  R8, R29, R28	#@andI_reg_reg
0a60 +  blt  R8, R7, B221	#@cmpI_branch  P=0.000000 C=5376.000000

0a64    B78: #	out( B95 B79 ) &lt;- in( B77 )  Freq: 0.998223
0a64 +  li R28, #1	# int, #@loadConI
0a68 +  ble  R10, R28, B95	#@cmpI_branch  P=0.216422 C=37852.000000

0a6c    B79: #	out( B208 B80 ) &lt;- in( B78 )  Freq: 0.782186
0a6c +  li R7, #1	# int, #@loadConI
0a70 +  bleu  R31, R7, B208	#@cmpU_branch  P=0.000001 C=-1.000000

0a74    B80: #	out( B208 B81 ) &lt;- in( B79 )  Freq: 0.782185
0a74 +  li R28, #-2147483648	# int, #@loadConI
0a78 +  addiw  R11, R10, #-1	#@addI_reg_imm
0a7c    CMove R11, (R10 lt R11), R11, R28	#@cmovI_cmpI
	
0a84 +  addw  R7, R10, zr	#@convI2L_reg_reg
0a88 +  addw  R28, R31, zr	#@convI2L_reg_reg
0a8c +  addi  R7, R7, #-1	#@addL_reg_imm
0a90 +  bgeu  R7, R28, B208	#@cmpUL_branch  P=0.000001 C=-1.000000

0a94    B81: #	out( B157 B82 ) &lt;- in( B80 )  Freq: 0.782184
0a94 +  lbu  R7, [R12, #17]	# byte, #@loadUB2L
0a98 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0a9c +  mv  R29, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058bea0&gt; *	# ptr, #@loadConP
0ab4 +  mv  R28, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058bea0&gt; *	# ptr, #@loadConP
0acc +  add R7, R29, R7	# ptr, #@addP_reg_reg
0ad0 +  lw  R28, [R7, #16]	# int, #@loadI
0ad4 +  li R7, #12288	# int, #@loadConI
0ad8 +  andr  R7, R28, R7	#@andI_reg_reg
0adc +  beq  R7, zr, B157	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

0ae0    B82: #	out( B90 B83 ) &lt;- in( B81 )  Freq: 0.782158
0ae0 +  spill [sp, #8] -&gt; R29	# spill size = 32
0ae4 +  ble  R11, R29, B90	#@cmpI_branch  P=0.000001 C=-1.000000

0ae8    B83: #	out( B209 B84 ) &lt;- in( B82 )  Freq: 0.782157
0ae8 +  bleu  R31, R29, B209	#@cmpU_branch  P=0.000001 C=-1.000000

0aec    B84: #	out( B210 B85 ) &lt;- in( B83 )  Freq: 0.782156
0aec +  li R28, #3	# int, #@loadConI
0af0 +  bleu  R31, R28, B210	#@cmpU_branch  P=0.000001 C=-1.000000

0af4    B85: #	out( B86 ) &lt;- in( B84 B89 ) Loop( B85-B89 ) Freq: 3.60996
0af4 +  li R7, #0	# int, #@loadConI
0af8 +  subw  R28, R11, R29	#@subI_reg_reg
0afc    CMove R28, (R11 lt R29), R28, R7	#@cmovI_cmpI
	
0b04 +  li R7, #2000	# int, #@loadConI
0b08 +  li R13, #2000	# int, #@loadConI
0b0c    CMove R28, (R28 gtu R13), R28, R7	#@cmovI_cmpU
	
0b14 +  addw  R14, R28, R29	#@addI_reg_reg
        nop 	# 4 bytes pad for loops and calls

0b20    B86: #	out( B157 B87 ) &lt;- in( B85 B88 ) Loop( B86-B88 inner main of N1157 strip mined) Freq: 16.6761
0b20 +  addw  R7, R29, zr	#@convI2L_reg_reg
0b24 +  add R7, R12, R7	# ptr, #@addP_reg_reg
0b28 +  lbu  R28, [R7, #16]	# byte, #@loadUB2L
0b2c +  lbu  R7, [R7, #17]	# byte, #@loadUB2L
0b30 +  slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0b34 +  mv  R15, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058bea0&gt; *	# ptr, #@loadConP
0b4c +  mv  R13, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058bea0&gt; *	# ptr, #@loadConP
0b64 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0b68 +  add R28, R15, R28	# ptr, #@addP_reg_reg
0b6c +  add R7, R15, R7	# ptr, #@addP_reg_reg
0b70 +  lw  R28, [R28, #16]	# int, #@loadI
0b74 +  lw  R13, [R7, #16]	# int, #@loadI
0b78 +  li R15, #12288	# int, #@loadConI
0b7c +  andr  R7, R28, R15	#@andI_reg_reg
0b80 +  li R28, #12288	# int, #@loadConI
0b84 +  andr  R13, R13, R28	#@andI_reg_reg
0b88 +  beq  R7, zr, B157	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

0b8c    B87: #	out( B157 B88 ) &lt;- in( B86 )  Freq: 16.6756
0b8c +  beq  R13, zr, B157	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

0b90    B88: #	out( B86 B89 ) &lt;- in( B87 )  Freq: 16.675
0b90 +  addiw  R29, R29, #2	#@addI_reg_imm
0b94 +  blt  R29, R14, B86	#@cmpI_loop  P=0.783578 C=29660.000000

0b98    B89: #	out( B85 B90 ) &lt;- in( B88 )  Freq: 3.60883
0b98 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0b98    ld  R13, [R23, #920]	# ptr, #@loadP
0b9c +  lwu zr, [R13]	# Safepoint: poll for GC, #@safePoint        # jdk.internal.module.Checks::isJavaIdentifier @ bci:71 (line 185) L[0]=R30 L[1]=_ L[2]=R29 L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {x30=Oop c_rarg2=Oop [0]=Oop off=2972/0xb9c}
0ba0 +  blt  R29, R11, B85	#@cmpI_branch  P=0.783578 C=29660.000000

0ba4    B90: #	out( B95 B91 ) &lt;- in( B82 B89 )  Freq: 0.781031
0ba4 +  bge  R29, R10, B95	#@cmpI_branch  P=0.500000 C=-1.000000

0ba8    B91: #	out( B230 B92 ) &lt;- in( B90 )  Freq: 0.390516
0ba8 +  # castII of R29, #@castII
0ba8    bgeu  R29, R31, B230	#@cmpU_branch  P=0.000001 C=-1.000000

0bac    B92: #	out( B231 B93 ) &lt;- in( B91 )  Freq: 0.390515
0bac +  spill R29 -&gt; R7	# spill size = 32
0bb0 +  # castII of R7, #@castII
0bb0    bgeu  R7, R31, B231	#@cmpU_branch  P=0.000001 C=-1.000000

0bb4    B93: #	out( B157 B94 ) &lt;- in( B92 B94 ) Loop( B93-B94 inner post of N1668) Freq: 0.781003
0bb4 +  addw  R7, R29, zr	#@convI2L_reg_reg
0bb8 +  add R7, R12, R7	# ptr, #@addP_reg_reg
0bbc +  lbu  R7, [R7, #16]	# byte, #@loadUB2L
0bc0 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0bc4 +  mv  R30, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058bea0&gt; *	# ptr, #@loadConP
0bdc +  mv  R28, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058bea0&gt; *	# ptr, #@loadConP
0bf4 +  add R7, R30, R7	# ptr, #@addP_reg_reg
0bf8 +  lw  R28, [R7, #16]	# int, #@loadI
0bfc +  li R30, #12288	# int, #@loadConI
0c00 +  andr  R7, R28, R30	#@andI_reg_reg
0c04 +  beq  R7, zr, B157	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

0c08    B94: #	out( B93 B95 ) &lt;- in( B93 )  Freq: 0.780977
0c08 +  addiw  R29, R29, #1	#@addI_reg_imm
0c0c +  blt  R29, R10, B93	#@cmpI_loop  P=0.500000 C=29660.000000

0c10    B95: #	out( B172 B96 ) &lt;- in( B90 B78 B94 )  Freq: 0.997041
0c10 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c10    ld  R10, [R23, #288]	# ptr, #@loadP
0c14 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c14    ld  R7, [R23, #304]	# ptr, #@loadP
0c18 +  addi  R28, R10, #16	# ptr, #@addP_reg_imm
0c1c +  bgeu  R28, R7, B172	#@cmpP_branch  P=0.000100 C=-1.000000

0c20    B96: #	out( B97 ) &lt;- in( B95 )  Freq: 0.996942
0c20 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c20    sd  R28, [R23, #288]	# ptr, #@storeP
0c24 +  li R7, #1	# long, #@loadConL
0c28 +  mv  R28, narrowklass: precise klass java/util/Optional: 0x00000040d06f89c0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0c38 +  sd  R7, [R10]	# long, #@storeL
0c3c +  sw  R28, [R10, #8]	# compressed klass ptr, #@storeNKlass
0c40 +  sw  zr, [R10, #12]	# int, #@storeimmI0

0c44    B97: #	out( B98 ) &lt;- in( B173 B96 )  Freq: 0.997041
0c44    spill [sp, #0] -&gt; R7	# spill size = 64
0c48 +  encode_heap_oop  R7, R7	#@encodeHeapOop
0c4c    
0c4c +  # checkcastPP of R10, #@checkCastPP
0c4c    sw  R7, [R10, #12]	# compressed ptr, #@storeN ! Field: java/util/Optional.value
0c50 +  #@membar_release
	fence iorw ow

0c54    B98: #	out( N2589 ) &lt;- in( B97 B157 )  Freq: 0.999708
0c54    # pop frame 96
	add  sp, sp, #96
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0c6c +  ret	// return register, #@Ret

0c70    B99: #	out( B100 ) &lt;- in( B60 )  Freq: 1.68638
0c70 +  spill R17 -&gt; R14	# spill size = 64
0c74 +  spill R29 -&gt; R31	# spill size = 32
0c78 +  spill R30 -&gt; R12	# spill size = 32

0c7c    B100: #	out( B240 B101 ) &lt;- in( B52 B99 ) Loop( B100-B99 ) Freq: 2.39076
0c7c +  decode_heap_oop  R11, R16	#@decodeHeapOop
0c80    lwu  R28, [R11, #12]	# range, #@loadRange
0c84    NullCheck R11

0c84    B101: #	out( B188 B102 ) &lt;- in( B100 )  Freq: 2.39076
0c84 +  lb  R29, [R14, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0c88 +  sraw  R8, R28, R29	#@rShiftI_reg_reg
0c8c +  blt  R12, zr, B188	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

0c90    B102: #	out( B193 B103 ) &lt;- in( B101 )  Freq: 2.39076
0c90 +  bgt  R12, R10, B193	#@cmpI_branch  P=0.000000 C=5375.000000

0c94    B103: #	out( B194 B104 ) &lt;- in( B102 )  Freq: 2.39076
0c94 +  bgt  R10, R8, B194	#@cmpI_branch  P=0.000000 C=5375.000000

0c98    B104: #	out( B107 B105 ) &lt;- in( B103 )  Freq: 2.39076
0c98 +  bne  R12, zr, B107	#@cmpI_reg_imm0_branch  P=0.627790 C=5376.000000

0c9c    B105: #	out( B139 B106 ) &lt;- in( B104 )  Freq: 0.889863
0c9c +  beq  R10, R8, B139	#@cmpI_branch  P=0.011494 C=2001.000000

0ca0    B106: #	out( B108 ) &lt;- in( B105 )  Freq: 0.879635
0ca0 +  li R12, #0	# int, #@loadConI
0ca4    spill R10 -&gt; R13	# spill size = 32
0ca8 +  j  B108	#@branch

0cac    B107: #	out( B108 ) &lt;- in( B104 )  Freq: 1.50089
0cac +  subw  R13, R10, R12	#@subI_reg_reg

0cb0    B108: #	out( B192 B109 ) &lt;- in( B106 B107 )  Freq: 2.38053
0cb0 +  bne  R29, zr, B192	#@cmpI_reg_imm0_branch  P=0.000000 C=66755.000000

0cb4    B109: #	out( B275 B110 ) &lt;- in( B108 )  Freq: 2.38053
0cb4 +  spill R10 -&gt; [sp, #4]	# spill size = 32
0cb8 +  spill R31 -&gt; [sp, #0]	# spill size = 32
0cbc +  spill R14 -&gt; R8	# spill size = 64
0cc0    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringLatin1::newString
        # java.lang.String::substring @ bci:41 (line 2707) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=R8 L[1]=sp + #4 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=3268/0xcc4}

0cc4    B110: #	out( B175 B111 ) &lt;- in( B109 )  Freq: 2.38048
        # Block is sole successor of call
0cc4 +  beq   R10, zr, B175	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

0cc8    B111: #	out( B112 ) &lt;- in( B110 )  Freq: 2.38048
0cc8 +  spill R10 -&gt; R29	# spill size = 64
0ccc +  spill R8 -&gt; R14	# spill size = 64
0cd0 +  spill [sp, #0] -&gt; R31	# spill size = 32
0cd4 +  spill [sp, #4] -&gt; R10	# spill size = 32

0cd8    B112: #	out( B241 B113 ) &lt;- in( B139 B111 )  Freq: 2.39071
0cd8 +  lwu  R28, [R29, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0cdc +  decode_heap_oop  R7, R28	#@decodeHeapOop
0ce0    lwu  R8, [R7, #12]	# range, #@loadRange
0ce4    NullCheck R7

0ce4    B113: #	out( B195 B114 ) &lt;- in( B112 )  Freq: 2.3907
0ce4 +  bleu  R8, zr, B195	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=8568.000000

0ce8    B114: #	out( B274 B115 ) &lt;- in( B113 )  Freq: 2.3907
0ce8 +  spill R29 -&gt; R8	# spill size = 64
0cec +  spill R10 -&gt; [sp, #16]	# spill size = 32
0cf0 +  spill R31 -&gt; [sp, #8]	# spill size = 32
0cf4 +  spill R14 -&gt; [sp, #0]	# spill size = 64
0cf8 +  mv  R11, java/util/ImmutableCollections$SetN:exact *	# ptr, #@loadConP
0d10    spill R29 -&gt; R12	# spill size = 64
0d14    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.ImmutableCollections$SetN::probe
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {fp=Oop [0]=Oop off=3352/0xd18}

0d18    B115: #	out( B196 B116 ) &lt;- in( B114 )  Freq: 2.39065
        # Block is sole successor of call
0d18 +  spill R8 -&gt; R31	# spill size = 64
0d1c +  lwu  R7, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0d20 +  lb  R28, [R31, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0d24 +  decode_heap_oop  R12, R7	#@decodeHeapOop
0d28 +  bge  R10, zr, B196	#@cmpI_reg_imm0_branch  P=0.000000 C=8453.000000

0d2c    B116: #	out( B189 B117 ) &lt;- in( B115 )  Freq: 2.39065
0d2c +  bne  R28, zr, B189	#@cmpI_reg_imm0_branch  P=0.000000 C=66755.000000

0d30    B117: #	out( B242 B118 ) &lt;- in( B116 )  Freq: 2.39065
0d30    lwu  R29, [R12, #12]	# range, #@loadRange
0d34    NullCheck R12

0d34    B118: #	out( B197 B119 ) &lt;- in( B117 )  Freq: 2.39065
0d34 +  bleu  R29, zr, B197	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=33969.000000

0d38    B119: #	out( B190 B120 ) &lt;- in( B118 )  Freq: 2.39065
0d38 +  lbu  R13, [R12, #16]	# byte, #@loadUB
0d3c +  addw  R7, R13, zr	#@convI2L_reg_reg
0d40 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0d44 +  mv  R10, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058bea0&gt; *	# ptr, #@loadConP
0d5c +  mv  R30, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058bea0&gt; *	# ptr, #@loadConP
0d74 +  add R7, R10, R7	# ptr, #@addP_reg_reg
0d78 +  lw  R30, [R7, #16]	# int, #@loadI
0d7c +  sraw  R10, R29, R28	#@rShiftI_reg_reg
0d80 +  li R7, #28672	# int, #@loadConI
0d84 +  li R28, #20480	# int, #@loadConI
0d88 +  andr  R8, R30, R7	#@andI_reg_reg
0d8c +  blt  R8, R28, B190	#@cmpI_branch  P=0.000000 C=5376.000000

0d90    B120: #	out( B53 B121 ) &lt;- in( B119 )  Freq: 2.39065
0d90 +  li R7, #1	# int, #@loadConI
0d94 +  ble  R10, R7, B53	#@cmpI_branch  P=0.216422 C=37852.000000

0d98    B121: #	out( B177 B122 ) &lt;- in( B120 )  Freq: 1.87326
0d98 +  addw  R7, R10, zr	#@convI2L_reg_reg
0d9c +  li R11, #1	# int, #@loadConI
0da0 +  addw  R28, R29, zr	#@convI2L_reg_reg
0da4 +  addi  R7, R7, #-1	#@addL_reg_imm
0da8 +  bleu  R29, R11, B177	#@cmpU_branch  P=0.000001 C=-1.000000

0dac    B122: #	out( B177 B123 ) &lt;- in( B121 )  Freq: 1.87326
0dac +  bgeu  R7, R28, B177	#@cmpUL_branch  P=0.000001 C=-1.000000

0db0    B123: #	out( B174 B124 ) &lt;- in( B122 )  Freq: 1.87325
0db0 +  lbu  R7, [R12, #17]	# byte, #@loadUB2L
0db4 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0db8 +  mv  R30, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058bea0&gt; *	# ptr, #@loadConP
0dd0 +  mv  R28, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058bea0&gt; *	# ptr, #@loadConP
0de8 +  add R7, R30, R7	# ptr, #@addP_reg_reg
0dec +  lw  R28, [R7, #16]	# int, #@loadI
0df0 +  li R7, #12288	# int, #@loadConI
0df4 +  andr  R28, R28, R7	#@andI_reg_reg
0df8 +  beq  R28, zr, B174	#@cmpI_reg_imm0_branch  P=0.000001 C=29661.000000

0dfc    B124: #	out( B178 B125 ) &lt;- in( B123 )  Freq: 1.87325
0dfc +  li R28, #-2147483648	# int, #@loadConI
0e00 +  addiw  R11, R10, #-1	#@addI_reg_imm
0e04    CMove R11, (R10 lt R11), R11, R28	#@cmovI_cmpI
	
0e0c +  spill [sp, #8] -&gt; R13	# spill size = 32
0e10 +  ble  R11, R13, B178	#@cmpI_branch  P=0.000001 C=-1.000000

0e14    B125: #	out( B179 B126 ) &lt;- in( B124 )  Freq: 1.87325
0e14 +  bleu  R29, R13, B179	#@cmpU_branch  P=0.000001 C=-1.000000

0e18    B126: #	out( B180 B127 ) &lt;- in( B125 )  Freq: 1.87325
0e18 +  li R7, #3	# int, #@loadConI
0e1c +  bleu  R29, R7, B180	#@cmpU_branch  P=0.000001 C=-1.000000

0e20    B127: #	out( B128 ) &lt;- in( B126 )  Freq: 1.87325
0e20 +  li R15, #2	# int, #@loadConI

0e24    B128: #	out( B129 ) &lt;- in( B127 B132 ) Loop( B128-B132 ) Freq: 8.65524
0e24 +  li R30, #0	# int, #@loadConI
0e28 +  subw  R7, R11, R15	#@subI_reg_reg
0e2c    CMove R7, (R11 lt R15), R7, R30	#@cmovI_cmpI
	
0e34 +  li R14, #2000	# int, #@loadConI
0e38 +  li R28, #2000	# int, #@loadConI
0e3c    CMove R7, (R7 gtu R28), R7, R14	#@cmovI_cmpU
	
0e44 +  addw  R7, R7, R15	#@addI_reg_reg
        nop 	# 4 bytes pad for loops and calls

0e50    B129: #	out( B174 B130 ) &lt;- in( B128 B131 ) Loop( B129-B131 inner main of N993 strip mined) Freq: 39.9922
0e50 +  addw  R28, R15, zr	#@convI2L_reg_reg
0e54 +  add R28, R12, R28	# ptr, #@addP_reg_reg
0e58 +  lbu  R30, [R28, #16]	# byte, #@loadUB2L
0e5c +  lbu  R28, [R28, #17]	# byte, #@loadUB2L
0e60 +  slli  R30, R30, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0e64 +  mv  R16, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058bea0&gt; *	# ptr, #@loadConP
0e7c +  mv  R14, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058bea0&gt; *	# ptr, #@loadConP
0e94 +  slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0e98 +  add R30, R16, R30	# ptr, #@addP_reg_reg
0e9c +  add R28, R16, R28	# ptr, #@addP_reg_reg
0ea0 +  lw  R14, [R28, #16]	# int, #@loadI
0ea4 +  lw  R30, [R30, #16]	# int, #@loadI
0ea8 +  li R28, #12288	# int, #@loadConI
0eac +  li R16, #12288	# int, #@loadConI
0eb0 +  andr  R28, R30, R28	#@andI_reg_reg
0eb4 +  andr  R14, R14, R16	#@andI_reg_reg
0eb8 +  beq  R28, zr, B174	#@cmpI_reg_imm0_branch  P=0.000001 C=29661.000000

0ebc    B130: #	out( B174 B131 ) &lt;- in( B129 )  Freq: 39.9921
0ebc +  beq  R14, zr, B174	#@cmpI_reg_imm0_branch  P=0.000001 C=29661.000000

0ec0    B131: #	out( B129 B132 ) &lt;- in( B130 )  Freq: 39.9921
0ec0 +  addiw  R15, R15, #2	#@addI_reg_imm
0ec4 +  blt  R15, R7, B129	#@cmpI_loop  P=0.783578 C=29660.000000

0ec8    B132: #	out( B128 B133 ) &lt;- in( B131 )  Freq: 8.65516
0ec8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0ec8    ld  R28, [R23, #920]	# ptr, #@loadP
0ecc +  lwu zr, [R28]	# Safepoint: poll for GC, #@safePoint        # jdk.internal.module.Checks::isJavaIdentifier @ bci:71 (line 185) L[0]=R31 L[1]=_ L[2]=R15 L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {xmethod=Oop c_rarg2=Oop [0]=Oop off=3788/0xecc}
0ed0 +  blt  R15, R11, B128	#@cmpI_branch  P=0.783578 C=29660.000000

0ed4    B133: #	out( B54 B134 ) &lt;- in( B178 B132 )  Freq: 1.87317
0ed4 +  bge  R15, R10, B54	#@cmpI_branch  P=0.500000 C=-1.000000

0ed8    B134: #	out( B206 B135 ) &lt;- in( B133 )  Freq: 0.936584
0ed8 +  # castII of R15, #@castII
0ed8    bgeu  R15, R29, B206	#@cmpU_branch  P=0.000001 C=-1.000000

0edc    B135: #	out( B207 B136 ) &lt;- in( B134 )  Freq: 0.936583
0edc +  spill R15 -&gt; R7	# spill size = 32
0ee0 +  # castII of R7, #@castII
0ee0    bgeu  R7, R29, B207	#@cmpU_branch  P=0.000001 C=-1.000000

0ee4    B136: #	out( B174 B137 ) &lt;- in( B135 B137 ) Loop( B136-B137 inner post of N1657) Freq: 1.87316
0ee4 +  addw  R7, R15, zr	#@convI2L_reg_reg
0ee8 +  add R7, R12, R7	# ptr, #@addP_reg_reg
0eec +  lbu  R7, [R7, #16]	# byte, #@loadUB2L
0ef0 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0ef4 +  mv  R29, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058bea0&gt; *	# ptr, #@loadConP
0f0c +  mv  R28, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1323 address=0x00000040d058bea0&gt; *	# ptr, #@loadConP
0f24 +  add R7, R29, R7	# ptr, #@addP_reg_reg
0f28 +  lw  R28, [R7, #16]	# int, #@loadI
0f2c +  li R7, #12288	# int, #@loadConI
0f30 +  andr  R7, R28, R7	#@andI_reg_reg
0f34 +  beq  R7, zr, B174	#@cmpI_reg_imm0_branch  P=0.000001 C=29661.000000

0f38    B137: #	out( B136 B138 ) &lt;- in( B136 )  Freq: 1.87316
0f38 +  addiw  R15, R15, #1	#@addI_reg_imm
0f3c +  blt  R15, R10, B136	#@cmpI_loop  P=0.500000 C=29660.000000

0f40    B138: #	out( B54 ) &lt;- in( B137 )  Freq: 0.93658
0f40 +  j  B54	#@branch

0f44    B139: #	out( B112 ) &lt;- in( B105 )  Freq: 0.0102283
0f44 +  spill R14 -&gt; R29	# spill size = 64
0f48 +  j  B112	#@branch

0f4c    B140: #	out( B264 B141 ) &lt;- in( B8 )  Freq: 0.00148859
0f4c +  spill [sp, #8] -&gt; R11	# spill size = 64
0f50 +  spill R11 -&gt; R8	# spill size = 64
0f54    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::getRoot
        # sun.nio.fs.UnixPath::getParent @ bci:32 (line 286) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=R8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=3928/0xf58}

0f58    B141: #	out( B22 ) &lt;- in( B140 )  Freq: 0.00148856
        # Block is sole successor of call
0f58 +  spill R10 -&gt; R31	# spill size = 64
0f5c +  j  B22	#@branch

0f60    B142: #	out( B238 B143 ) &lt;- in( B22 )  Freq: 0.00148858
0f60 +  spill [sp, #8] -&gt; R7	# spill size = 64
0f64 +  lwu  R28, [R7, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
0f68 +  #@membar_acquire
	fence ir iorw
0f6c +  decode_heap_oop  R8, R28	#@decodeHeapOop
0f70 +  bne   R8, zr, B238	#@cmpP_imm0_branch  P=0.000000 C=5379.000000

0f74    B143: #	out( B233 B144 ) &lt;- in( B142 )  Freq: 0.00148858
0f74 +  spill [sp, #8] -&gt; R28	# spill size = 64
0f78 +  lwu  R29, [R28, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
0f7c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0f7c    ld  R10, [R23, #288]	# ptr, #@loadP
0f80 +  lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
0f84 +  decode_heap_oop  R8, R29	#@decodeHeapOop
0f88 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0f88    ld  R28, [R23, #304]	# ptr, #@loadP
0f8c +  addi  R30, R10, #24	# ptr, #@addP_reg_imm
0f90 +  decode_heap_oop  R29, R7	#@decodeHeapOop
0f94 +  bgeu  R30, R28, B233	#@cmpP_branch  P=0.000100 C=-1.000000

0f98    B144: #	out( B145 ) &lt;- in( B143 )  Freq: 0.00148844
0f98 +  li R7, #1	# long, #@loadConL
0f9c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0f9c    sd  R30, [R23, #288]	# ptr, #@storeP
0fa0 +  sd  R7, [R10]	# long, #@storeL
0fa4 +  sw  R11, [R10, #8]	# compressed klass ptr, #@storeNKlass
0fa8 +  sw  zr, [R10, #12]	# int, #@storeimmI0
0fac +  sd  zr, [R10, #16]	# long, #@storeimmL0

0fb0    B145: #	out( B256 B146 ) &lt;- in( B234 B144 )  Freq: 0.00148858
0fb0    
0fb0 +  MEMBAR-store-store	#@membar_storestore
0fb4 +  spill R10 -&gt; R7	# spill size = 64
0fb8 +  # checkcastPP of R7, #@checkCastPP
0fb8    lwu  R14, [R29, #12]	# range, #@loadRange
0fbc    NullCheck R29

0fbc    B146: #	out( B265 B147 ) &lt;- in( B145 )  Freq: 0.00148858
0fbc +  spill R7 -&gt; [sp, #16]	# spill size = 64
0fc0 +  spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
0fc8 +  spill [sp, #16] -&gt; R11	# spill size = 64
0fcc +  li R13, #0	# int, #@loadConI
0fd0    spill R29 -&gt; R12	# spill size = 64
0fd4 +  mv  R15, sun/nio/cs/UTF_8:exact *	# ptr, #@loadConP
0fec    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.String::&lt;init&gt;
        # java.lang.String::&lt;init&gt; @ bci:6 (line 1380) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.Util::toString @ bci:8 (line 63) L[0]=_ STK[0]=sp + #16
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=sp + #0 STK[0]=sp + #0 STK[1]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:35 (line 747) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=4080/0xff0}

0ff0    B147: #	out( B235 B148 ) &lt;- in( B146 )  Freq: 0.00148855
        # Block is sole successor of call
0ff0 +  beq   R8, zr, B235	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

0ff4    B148: #	out( B181 B149 ) &lt;- in( B147 )  Freq: 0.00148855
0ff4 +  #@membar_release
	fence iorw ow
0ff8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
0ff8    lb  R7, [R23, #56]	# byte, #@loadB
0ffc +  bne  R7, zr, B181	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1000    B149: #	out( B150 ) &lt;- in( B148 )  Freq: 0.00148706
1000 +  spill [sp, #0] -&gt; R9	# spill size = 64

1004    B150: #	out( B152 B151 ) &lt;- in( B239 B183 B181 B149 )  Freq: 0.00148855
1004 +  mv  R28, R9	# ptr -&gt; long, #@castP2X
1008    spill [sp, #16] -&gt; R29	# spill size = 64
100c +  mv  R7, R29	# ptr -&gt; long, #@castP2X
1010 +  xorr  R7, R7, R28	#@xorL_reg_reg
1014 +  encode_heap_oop  R30, R29	#@encodeHeapOop
1018 +  srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
101c +  sw  R30, [R9, #24]	# compressed ptr, #@storeN ! Field: volatile sun/nio/fs/UnixPath.stringValue
1020 +  beq  R7, zr, B152	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1024    B151: #	out( B184 B152 ) &lt;- in( B150 )  Freq: 0.00148706
1024 +  srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1028 +  mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1034 +  add R10, R28, R7	# ptr, #@addP_reg_reg
1038 +  lb  R7, [R10]	# byte, #@loadB
103c +  li R29, #4	# int, #@loadConI
1040 +  bne  R7, R29, B184	#@cmpI_branch  P=0.001000 C=-1.000000

1044    B152: #	out( B236 B153 ) &lt;- in( B186 B187 B184 B151 B150 )  Freq: 0.00148855
1044 +  #@membar_volatile
	fence iorw iorw
1048 +  lwu  R28, [R9, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
104c +  #@membar_acquire
	fence ir iorw
1050 +  decode_heap_oop  R8, R28	#@decodeHeapOop
1054 +  beq   R8, zr, B236	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

1058    B153: #	out( B263 B154 ) &lt;- in( B152 )  Freq: 0.00148855
1058 +  mv  R12, java/lang/String:exact *	# ptr, #@loadConP
1070    spill R8 -&gt; R11	# spill size = 64
1074    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.String::endsWith
        # jdk.internal.module.ModulePath::toPackageName @ bci:47 (line 748) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=4216/0x1078}

1078    B154: #	out( B157 B155 ) &lt;- in( B153 )  Freq: 0.00148852
        # Block is sole successor of call
1078 +  beq  R10, zr, B157	#@cmpI_reg_imm0_branch  P=0.100000 C=-1.000000

107c    B155: #	out( B262 B156 ) &lt;- in( B154 )  Freq: 0.00133967
107c +  mv  R12, java/lang/String:exact *	# ptr, #@loadConP
1094    spill R8 -&gt; R11	# spill size = 64
1098    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.String::equals
        # jdk.internal.module.ModulePath::toPackageName @ bci:57 (line 748) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=4252/0x109c}

109c    B156: #	out( B237 B157 ) &lt;- in( B155 )  Freq: 0.00133964
        # Block is sole successor of call
109c +  beq  R10, zr, B237	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

10a0    B157: #	out( B98 ) &lt;- in( B93 B87 B81 B86 B156 B154 )  Freq: 0.00266639
10a0 +  mv  R10, java/util/Optional:exact *	# ptr, #@loadConP
10b8 +  j  B98	#@branch

10bc    B158: #	out( B19 ) &lt;- in( B17 )  Freq: 0.000998483
10bc +  addw  R30, R8, zr	#@convI2L_reg_reg
10c0 +  addi  R28, R30, #15	#@addL_reg_imm
10c4 +  srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
10c8 +  andi  R28, R28, #-8	#@andL_reg_imm
10cc +  add R28, R9, R28	# ptr, #@addP_reg_reg
10d0 +  sub  R29, R7, R29	#@subL_reg_reg
10d4    ClearArray R29, R28	#@clearArray_reg_reg
112c +  addi  R12, R30, #-1	#@addL_reg_imm
1130    CALL, runtime leaf nofp 0x000000401396cf00	#@CallLeafNoFPDirect arrayof_jbyte_disjoint_arraycopy
        No JVM State Info
        # 
1134 +  j  B19	#@branch

1138    B159: #	out( B32 B160 ) &lt;- in( B30 )  Freq: 0.000998447
1138 +  spill [sp, #8] -&gt; R9	# spill size = 64
113c +  lwu  R7, [R9, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
1140 +  decode_heap_oop  R10, R7	#@decodeHeapOop
1144 +  beq   R10, zr, B32	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

1148    B160: #	out( B217 B161 ) &lt;- in( B159 )  Freq: 0.000499224
1148 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1148    ld  R7, [R23, #32]	# int, #@loadL
114c +  beq  R7, zr, B217	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1150    B161: #	out( B32 ) &lt;- in( B160 )  Freq: 0.000498725
1150 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1150    ld  R28, [R23, #48]	# ptr, #@loadP
1154 +  add R28, R28, R7	# ptr, #@addP_reg_reg
1158 +  addi  R7, R7, #-8	#@addL_reg_imm
115c +  sd  R10, [R28, #-8]	# ptr, #@storeP
1160 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1160    sd  R7, [R23, #32]	# long, #@storeL
1164 +  j  B32	#@branch

1168    B162: #	out( B34 B163 ) &lt;- in( B33 )  Freq: 0.000997462
1168 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1168    ld  R7, [R23, #64]	# int, #@loadL
116c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
116c    ld  R28, [R23, #80]	# ptr, #@loadP
1170 +  #@membar_volatile
	fence iorw iorw
1174 +  lb  R29, [R10]	# byte, #@loadB
1178 +  beq  R29, zr, B34	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

117c    B163: #	out( B165 B164 ) &lt;- in( B162 )  Freq: 0.000498731
117c +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1180 +  bne  R7, zr, B165	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1184    B164: #	out( B34 ) &lt;- in( B163 )  Freq: 0.000249365
1184 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1184    spill R23 -&gt; R11	# spill size = 64
1188 +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
11b8 +  j  B34	#@branch

11bc    B165: #	out( B34 ) &lt;- in( B163 )  Freq: 0.000249365
11bc +  add R28, R28, R7	# ptr, #@addP_reg_reg
11c0 +  addi  R7, R7, #-8	#@addL_reg_imm
11c4 +  sd  R10, [R28, #-8]	# ptr, #@storeP
11c8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
11c8    sd  R7, [R23, #64]	# long, #@storeL
11cc +  j  B34	#@branch

11d0    B166: #	out( B260 B167 ) &lt;- in( B19 )  Freq: 9.9865e-05
11d0 +  spill R18 -&gt; [sp, #24]	# spill size = 32
11d4 +  spill R9 -&gt; [sp, #16]	# spill size = 64
11d8 +  spill [sp, #8] -&gt; R8	# spill size = 64
11dc +  mv  R11, precise klass sun/nio/fs/UnixPath: 0x00000040d06f96b0:Constant:exact *	# ptr, #@loadConP
11f4    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixPath::getParent @ bci:51 (line 290) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #16
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=R8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=NarrowOop off=4600/0x11f8}

11f8    B167: #	out( B21 ) &lt;- in( B166 )  Freq: 9.9863e-05
        # Block is sole successor of call
11f8 +  spill [sp, #24] -&gt; R18	# spill size = 32
11fc +  spill R10 -&gt; R31	# spill size = 64
1200 +  j  B21	#@branch

1204    B168: #	out( B261 B169 ) &lt;- in( B13 B14 )  Freq: 0.000100877
1204 +  spill R31 -&gt; [sp, #40]	# spill size = 64
1208 +  spill R30 -&gt; [sp, #32]	# spill size = 64
120c +  spill R10 -&gt; [sp, #24]	# spill size = 64
1210 +  spill R29 -&gt; [sp, #16]	# spill size = 32
1214 +  mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
122c    spill R29 -&gt; R12	# spill size = 32
1230    CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=sp + #8 L[1]=_ L[2]=sp + #16 L[3]=_
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=sp + #8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {[0]=Oop [8]=Oop [24]=Oop off=4660/0x1234}

1234    B169: #	out( B16 ) &lt;- in( B168 )  Freq: 0.000100875
        # Block is sole successor of call
1234 +  spill R10 -&gt; R9	# spill size = 64
1238 +  spill [sp, #16] -&gt; R29	# spill size = 32
123c +  spill [sp, #24] -&gt; R10	# spill size = 64
1240 +  spill [sp, #32] -&gt; R30	# spill size = 64
1244 +  spill [sp, #40] -&gt; R31	# spill size = 64
1248 +  j  B16	#@branch

124c    B170: #	out( B259 B171 ) &lt;- in( B25 )  Freq: 9.98648e-05
124c +  spill R12 -&gt; [sp, #16]	# spill size = 64
1250 +  spill R31 -&gt; [sp, #8]	# spill size = 64
1254 +  mv  R11, precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# ptr, #@loadConP
126c    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.Util::toString @ bci:0 (line 63) L[0]=sp + #16
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=sp + #8 STK[0]=sp + #8 STK[1]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=4720/0x1270}

1270    B171: #	out( B27 ) &lt;- in( B170 )  Freq: 9.98628e-05
        # Block is sole successor of call
1270 +  spill [sp, #8] -&gt; R31	# spill size = 64
1274 +  spill [sp, #16] -&gt; R12	# spill size = 64
1278 +  j  B27	#@branch

127c    B172: #	out( B258 B173 ) &lt;- in( B95 )  Freq: 9.97207e-05
127c +  mv  R11, precise klass java/util/Optional: 0x00000040d06f89c0:Constant:exact *	# ptr, #@loadConP
1294    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.Optional::of @ bci:0 (line 113) L[0]=sp + #0
        # jdk.internal.module.ModulePath::toPackageName @ bci:125 (line 758) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {[0]=Oop off=4760/0x1298}

1298    B173: #	out( B97 ) &lt;- in( B172 )  Freq: 9.97187e-05
        # Block is sole successor of call
1298 +  j  B97	#@branch

129c    B174: #	out( N2589 ) &lt;- in( B136 B130 B123 B129 )  Freq: 8.48426e-05
129c +  li R11, #-187	# int, #@loadConI
12a0    spill [sp, #0] -&gt; R8	# spill size = 64
12a4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # jdk.internal.module.Checks::isTypeName @ bci:26 (line 132) L[0]=R8 L[1]=sp + #16 L[2]=_ L[3]=_ STK[0]=#0
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=4776/0x12a8}
12a8    #@ShouldNotReachHere

12b4    B175: #	out( N2589 ) &lt;- in( B110 )  Freq: 2.41209e-06
12b4 +  li R11, #-10	# int, #@loadConI
12b8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=4796/0x12bc}
12bc    #@ShouldNotReachHere

12c8    B176: #	out( N2589 ) &lt;- in( B57 )  Freq: 2.39055e-06
12c8 +  li R11, #-50	# int, #@loadConI
12cc    spill R14 -&gt; [sp, #24]	# spill size = 64
12d0 +  spill R30 -&gt; [sp, #20]	# spill size = 32
12d4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::indexOf @ bci:32 (line 213) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #24 STK[1]=#46 STK[2]=sp + #20 STK[3]=R8
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=sp + #0 L[1]=_ L[2]=sp + #20 L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {[0]=Oop [24]=Oop off=4824/0x12d8}
12d8    #@ShouldNotReachHere

12e4    B177: #	out( N2589 ) &lt;- in( B122 B121 )  Freq: 3.77139e-06
12e4 +  spill [sp, #16] -&gt; R28	# spill size = 32
12e8 +  li R11, #-138	# int, #@loadConI
12ec    spill [sp, #0] -&gt; R8	# spill size = 64
12f0 +  spill R28 -&gt; [sp, #8]	# spill size = 32
12f4 +  spill R31 -&gt; [sp, #16]	# spill size = 64
12f8 +  spill R10 -&gt; [sp, #12]	# spill size = 32
12fc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:46 (line 180) L[0]=sp + #16 L[1]=_ L[2]=#1 L[3]=_ STK[0]=#1 STK[1]=sp + #12
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop [16]=Oop off=4864/0x1300}
1300    #@ShouldNotReachHere

130c    B178: #	out( B133 ) &lt;- in( B124 )  Freq: 1.89813e-06
130c +  li R15, #2	# int, #@loadConI
1310 +  j  B133	#@branch

1314    B179: #	out( N2589 ) &lt;- in( B125 )  Freq: 1.87325e-06
1314    #@ShouldNotReachHere

1320    B180: #	out( N2589 ) &lt;- in( B126 )  Freq: 1.87325e-06
1320    #@ShouldNotReachHere

132c    B181: #	out( B150 B182 ) &lt;- in( B148 )  Freq: 1.48853e-06
132c +  spill [sp, #0] -&gt; R9	# spill size = 64
1330 +  lwu  R28, [R9, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
1334 +  decode_heap_oop  R10, R28	#@decodeHeapOop
1338 +  beq   R10, zr, B150	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

133c    B182: #	out( B239 B183 ) &lt;- in( B181 )  Freq: 7.44266e-07
133c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
133c    ld  R7, [R23, #32]	# int, #@loadL
1340 +  beq  R7, zr, B239	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1344    B183: #	out( B150 ) &lt;- in( B182 )  Freq: 7.43522e-07
1344 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1344    ld  R28, [R23, #48]	# ptr, #@loadP
1348 +  add R28, R28, R7	# ptr, #@addP_reg_reg
134c +  addi  R7, R7, #-8	#@addL_reg_imm
1350 +  sd  R10, [R28, #-8]	# ptr, #@storeP
1354 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1354    sd  R7, [R23, #32]	# long, #@storeL
1358 +  j  B150	#@branch

135c    B184: #	out( B152 B185 ) &lt;- in( B151 )  Freq: 1.48706e-06
135c +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
135c    ld  R7, [R23, #64]	# int, #@loadL
1360 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1360    ld  R28, [R23, #80]	# ptr, #@loadP
1364 +  #@membar_volatile
	fence iorw iorw
1368 +  lb  R30, [R10]	# byte, #@loadB
136c +  beq  R30, zr, B152	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1370    B185: #	out( B187 B186 ) &lt;- in( B184 )  Freq: 7.43531e-07
1370 +  storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1374 +  bne  R7, zr, B187	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1378    B186: #	out( B152 ) &lt;- in( B185 )  Freq: 3.71766e-07
1378 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1378    spill R23 -&gt; R11	# spill size = 64
137c +  CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
13ac +  j  B152	#@branch

13b0    B187: #	out( B152 ) &lt;- in( B185 )  Freq: 3.71766e-07
13b0 +  add R28, R28, R7	# ptr, #@addP_reg_reg
13b4 +  addi  R7, R7, #-8	#@addL_reg_imm
13b8 +  sd  R10, [R28, #-8]	# ptr, #@storeP
13bc +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
13bc    sd  R7, [R23, #64]	# long, #@storeL
13c0 +  j  B152	#@branch

13c4    B188: #	out( N2589 ) &lt;- in( B101 )  Freq: 1.19538e-06
13c4 +  li R11, #-187	# int, #@loadConI
13c8    spill R14 -&gt; [sp, #8]	# spill size = 64
13cc +  spill R14 -&gt; [sp, #24]	# spill size = 64
13d0 +  spill R10 -&gt; [sp, #20]	# spill size = 32
13d4 +  spill R10 -&gt; [sp, #32]	# spill size = 32
13d8 +  spill R12 -&gt; [sp, #40]	# spill size = 32
13dc +  spill R12 -&gt; [sp, #44]	# spill size = 32
13e0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:1 (line 4598) L[0]=sp + #44 L[1]=sp + #20 L[2]=R8 STK[0]=sp + #40
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #8 L[1]=sp + #40 L[2]=sp + #32 L[3]=R8 L[4]=_
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=sp + #24 L[1]=sp + #20 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #8 L[5]=_
        # OopMap {[8]=Oop [24]=Oop off=5092/0x13e4}
13e4    #@ShouldNotReachHere

13f0    B189: #	out( N2589 ) &lt;- in( B116 )  Freq: 1.19533e-06
13f0 +  spill [sp, #16] -&gt; R7	# spill size = 32
13f4 +  li R11, #-187	# int, #@loadConI
13f8    spill [sp, #0] -&gt; R8	# spill size = 64
13fc +  spill R7 -&gt; [sp, #8]	# spill size = 32
1400 +  spill R31 -&gt; [sp, #24]	# spill size = 64
1404 +  spill R31 -&gt; [sp, #32]	# spill size = 64
1408 +  spill R28 -&gt; [sp, #12]	# spill size = 32
140c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #12
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=sp + #24 L[1]=#0
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #32 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=sp + #24 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop [24]=Oop [32]=Oop off=5136/0x1410}
1410    #@ShouldNotReachHere

141c    B190: #	out( N2589 ) &lt;- in( B119 )  Freq: 1.19532e-06
141c +  li R11, #-187	# int, #@loadConI
1420    spill R31 -&gt; [sp, #24]	# spill size = 64
1424 +  spill R13 -&gt; [sp, #20]	# spill size = 32
1428    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.CharacterDataLatin1::isJavaIdentifierStart @ bci:14 (line 116) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8 STK[1]=#20480
        # java.lang.Character::isJavaIdentifierStart @ bci:5 (line 10070) L[0]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:28 (line 176) L[0]=sp + #24 L[1]=sp + #20 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {[0]=Oop [24]=Oop off=5164/0x142c}
142c    #@ShouldNotReachHere

1438    B191: #	out( N2589 ) &lt;- in( B54 )  Freq: 1.19528e-06
1438 +  li R11, #-187	# int, #@loadConI
143c    spill R17 -&gt; [sp, #8]	# spill size = 64
1440 +  spill R30 -&gt; [sp, #20]	# spill size = 32
1444 +  spill R31 -&gt; [sp, #24]	# spill size = 32
1448    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #24
        # java.lang.String::indexOf @ bci:1 (line 2416) L[0]=sp + #0 L[1]=#46 L[2]=sp + #20
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=sp + #0 L[1]=_ L[2]=sp + #20 L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #8 L[5]=_
        # OopMap {[0]=Oop [8]=Oop off=5196/0x144c}
144c    #@ShouldNotReachHere

1458    B192: #	out( N2589 ) &lt;- in( B108 )  Freq: 1.19026e-06
1458 +  li R11, #-187	# int, #@loadConI
145c    spill R14 -&gt; [sp, #0]	# spill size = 64
1460 +  spill R10 -&gt; [sp, #8]	# spill size = 32
1464 +  spill R14 -&gt; [sp, #16]	# spill size = 64
1468 +  spill R12 -&gt; [sp, #12]	# spill size = 32
146c +  spill R13 -&gt; [sp, #24]	# spill size = 32
1470 +  spill R29 -&gt; [sp, #28]	# spill size = 32
1474    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #28
        # java.lang.String::substring @ bci:28 (line 2707) L[0]=sp + #0 L[1]=sp + #12 L[2]=_ L[3]=_ L[4]=sp + #24
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=sp + #16 L[1]=sp + #8 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {[0]=Oop [16]=Oop off=5240/0x1478}
1478    #@ShouldNotReachHere

1484    B193: #	out( N2589 ) &lt;- in( B102 )  Freq: 1.14e-06
1484 +  li R11, #-187	# int, #@loadConI
1488    spill R14 -&gt; [sp, #8]	# spill size = 64
148c +  spill R14 -&gt; [sp, #24]	# spill size = 64
1490 +  spill R10 -&gt; [sp, #20]	# spill size = 32
1494 +  spill R10 -&gt; [sp, #32]	# spill size = 32
1498 +  spill R12 -&gt; [sp, #44]	# spill size = 32
149c +  spill R12 -&gt; [sp, #48]	# spill size = 32
14a0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:6 (line 4598) L[0]=sp + #48 L[1]=sp + #20 L[2]=R8 STK[0]=sp + #44 STK[1]=sp + #20
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #8 L[1]=sp + #44 L[2]=sp + #32 L[3]=R8 L[4]=_
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=sp + #24 L[1]=sp + #20 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #8 L[5]=_
        # OopMap {[8]=Oop [24]=Oop off=5284/0x14a4}
14a4    #@ShouldNotReachHere

14b0    B194: #	out( N2589 ) &lt;- in( B103 )  Freq: 1.14e-06
14b0 +  li R11, #-187	# int, #@loadConI
14b4    spill R14 -&gt; [sp, #8]	# spill size = 64
14b8 +  spill R14 -&gt; [sp, #24]	# spill size = 64
14bc +  spill R10 -&gt; [sp, #20]	# spill size = 32
14c0 +  spill R10 -&gt; [sp, #32]	# spill size = 32
14c4 +  spill R12 -&gt; [sp, #44]	# spill size = 32
14c8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:11 (line 4598) L[0]=sp + #44 L[1]=sp + #20 L[2]=R8 STK[0]=sp + #20 STK[1]=R8
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #8 L[1]=sp + #44 L[2]=sp + #32 L[3]=R8 L[4]=_
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=sp + #24 L[1]=sp + #20 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #8 L[5]=_
        # OopMap {[8]=Oop [24]=Oop off=5324/0x14cc}
14cc    #@ShouldNotReachHere

14d8    B195: #	out( N2589 ) &lt;- in( B113 )  Freq: 1.13998e-06
14d8 +  li R11, #-187	# int, #@loadConI
14dc    spill R14 -&gt; [sp, #8]	# spill size = 64
14e0 +  spill R10 -&gt; [sp, #16]	# spill size = 32
14e4 +  spill R29 -&gt; [sp, #24]	# spill size = 64
14e8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isEmpty @ bci:5 (line 1487) L[0]=_ STK[0]=R8
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=sp + #24 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #8 L[5]=_
        # OopMap {[8]=Oop [24]=Oop off=5356/0x14ec}
14ec    #@ShouldNotReachHere

14f8    B196: #	out( N2589 ) &lt;- in( B115 )  Freq: 1.13995e-06
14f8 +  spill [sp, #16] -&gt; R28	# spill size = 32
14fc +  li R11, #-187	# int, #@loadConI
1500    spill [sp, #0] -&gt; R8	# spill size = 64
1504 +  spill R28 -&gt; [sp, #8]	# spill size = 32
1508 +  spill R31 -&gt; [sp, #16]	# spill size = 64
150c +  spill R10 -&gt; [sp, #12]	# spill size = 32
1510    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::contains @ bci:17 (line 938) L[0]=_ L[1]=_ STK[0]=sp + #12
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop [16]=Oop off=5396/0x1514}
1514    #@ShouldNotReachHere

1520    B197: #	out( N2589 ) &lt;- in( B118 )  Freq: 1.13995e-06
1520 +  spill [sp, #16] -&gt; R28	# spill size = 32
1524 +  li R11, #-187	# int, #@loadConI
1528    spill [sp, #0] -&gt; R8	# spill size = 64
152c +  spill R28 -&gt; [sp, #8]	# spill size = 32
1530 +  spill R31 -&gt; [sp, #24]	# spill size = 64
1534 +  spill R12 -&gt; [sp, #32]	# spill size = 64
1538 +  spill R29 -&gt; [sp, #12]	# spill size = 32
153c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:7 (line 47) L[0]=sp + #32 L[1]=#0 STK[0]=#0 STK[1]=sp + #12
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #24 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=sp + #24 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop [24]=Oop [32]=Oop off=5440/0x1540}
1540    #@ShouldNotReachHere

154c    B198: #	out( N2589 ) &lt;- in( B56 )  Freq: 1.1399e-06
154c +  li R11, #-27	# int, #@loadConI
1550    spill R14 -&gt; [sp, #24]	# spill size = 64
1554 +  spill R30 -&gt; [sp, #20]	# spill size = 32
1558 +  spill R30 -&gt; [sp, #32]	# spill size = 32
155c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::indexOf @ bci:13 (line 207) L[0]=sp + #24 L[1]=#46 L[2]=sp + #32 L[3]=R8 STK[0]=sp + #20
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=sp + #0 L[1]=_ L[2]=sp + #20 L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {[0]=Oop [24]=Oop off=5472/0x1560}
1560    #@ShouldNotReachHere

156c    B199: #	out( N2589 ) &lt;- in( B7 )  Freq: 1.01325e-06
156c +  li R11, #-28	# int, #@loadConI
1570    spill R31 -&gt; [sp, #24]	# spill size = 64
1574    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:23 (line 283) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #24 STK[1]=R8
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=sp + #8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {[0]=Oop [8]=Oop [24]=Oop off=5496/0x1578}
1578    #@ShouldNotReachHere

1584    B200: #	out( B11 ) &lt;- in( B9 )  Freq: 1.01174e-06
1584 +  addw  R7, R29, zr	#@convI2L_reg_reg
1588 +  j  B11	#@branch

158c    B201: #	out( B19 ) &lt;- in( B16 )  Freq: 1.01174e-06
158c +  spill R11 -&gt; R28	# spill size = 64
1590 +  addi  R29, R7, #-2	#@addL_reg_imm
1594    ClearArray R29, R28	#@clearArray_reg_reg
15ec    
15ec +  j  B19	#@branch

15f0    B202: #	out( N2589 ) &lt;- in( B29 )  Freq: 1.01172e-06
15f0 +  li R11, #-10	# int, #@loadConI
15f4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::toString @ bci:19 (line 757) L[0]=_ STK[0]=_ STK[1]=#NULL STK[2]=sp + #16
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {[16]=Oop off=5624/0x15f8}
15f8    #@ShouldNotReachHere

1604    B203: #	out( N2589 ) &lt;- in( B2 )  Freq: 9.99999e-07
1604 +  li R11, #-34	# int, #@loadConI
1608    spill R12 -&gt; [sp, #8]	# spill size = 64
160c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=sp + #8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #8
        # OopMap {[0]=Oop [8]=Oop off=5648/0x1610}
1610    #@ShouldNotReachHere

161c    B204: #	out( N2589 ) &lt;- in( B12 )  Freq: 9.98485e-07
161c +  li R11, #-52	# int, #@loadConI
1620    spill [sp, #8] -&gt; R8	# spill size = 64
1624 +  spill R29 -&gt; [sp, #20]	# spill size = 32
1628    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=R8 L[1]=_ L[2]=sp + #20 L[3]=_ STK[0]=sp + #20
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=R8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=5676/0x162c}
162c    #@ShouldNotReachHere

1638    B205: #	out( N2589 ) &lt;- in( B23 )  Freq: 9.98484e-07
1638 +  li R11, #-34	# int, #@loadConI
163c    spill R31 -&gt; R8	# spill size = 64
1640    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_ STK[0]=R8
        # OopMap {fp=Oop [0]=Oop off=5700/0x1644}
1644    #@ShouldNotReachHere

1650    B206: #	out( N2589 ) &lt;- in( B134 )  Freq: 9.49021e-07
1650    #@ShouldNotReachHere

165c    B207: #	out( N2589 ) &lt;- in( B135 )  Freq: 9.4902e-07
165c    #@ShouldNotReachHere

1668    B208: #	out( N2589 ) &lt;- in( B80 B79 )  Freq: 1.57476e-06
1668 +  spill [sp, #0] -&gt; R8	# spill size = 64
166c +  li R11, #-138	# int, #@loadConI
1670    spill R30 -&gt; [sp, #0]	# spill size = 64
1674 +  spill R10 -&gt; [sp, #8]	# spill size = 32
1678    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:46 (line 180) L[0]=sp + #0 L[1]=_ L[2]=#1 L[3]=_ STK[0]=#1 STK[1]=sp + #8
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop [0]=Oop off=5756/0x167c}
167c    #@ShouldNotReachHere

1688    B209: #	out( N2589 ) &lt;- in( B83 )  Freq: 7.82157e-07
1688    #@ShouldNotReachHere

1694    B210: #	out( N2589 ) &lt;- in( B84 )  Freq: 7.82156e-07
1694    #@ShouldNotReachHere

16a0    B211: #	out( N2589 ) &lt;- in( B68 )  Freq: 6.35007e-07
16a0 +  li R11, #-10	# int, #@loadConI
16a4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=5800/0x16a8}
16a8    #@ShouldNotReachHere

16b4    B212: #	out( N2589 ) &lt;- in( B24 )  Freq: 4.99241e-07
16b4 +  li R11, #-187	# int, #@loadConI
16b8    spill R31 -&gt; [sp, #8]	# spill size = 64
16bc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::toString @ bci:4 (line 756) L[0]=sp + #8 STK[0]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=5824/0x16c0}
16c0    #@ShouldNotReachHere

16cc    B213: #	out( N2589 ) &lt;- in( B38 )  Freq: 4.99228e-07
16cc +  li R11, #-187	# int, #@loadConI
16d0    spill R30 -&gt; [sp, #0]	# spill size = 64
16d4 +  spill R29 -&gt; [sp, #8]	# spill size = 64
16d8 +  spill R10 -&gt; [sp, #16]	# spill size = 32
16dc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:36 (line 2959) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=sp + #8 L[4]=#Ptr0x00000040d06fc3f0 L[5]=sp + #16 L[6]=R8 L[7]=#1 L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {[0]=Oop [8]=Oop off=5856/0x16e0}
16e0    #@ShouldNotReachHere

16ec    B214: #	out( N2589 ) &lt;- in( B39 )  Freq: 4.99228e-07
16ec +  li R11, #-187	# int, #@loadConI
16f0    spill R30 -&gt; [sp, #0]	# spill size = 64
16f4 +  spill R29 -&gt; [sp, #8]	# spill size = 64
16f8 +  spill R10 -&gt; [sp, #16]	# spill size = 32
16fc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:42 (line 2960) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=sp + #8 L[4]=#Ptr0x00000040d06fc3f0 L[5]=sp + #16 L[6]=R8 L[7]=#1 L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=R8 STK[1]=#1
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {[0]=Oop [8]=Oop off=5888/0x1700}
1700    #@ShouldNotReachHere

170c    B215: #	out( N2589 ) &lt;- in( B40 )  Freq: 4.99228e-07
170c +  li R11, #-187	# int, #@loadConI
1710    spill R30 -&gt; R8	# spill size = 64
1714 +  spill R14 -&gt; [sp, #8]	# spill size = 32
1718    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #8
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=sp + #0 L[1]=#0
        # java.lang.String::replace @ bci:54 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=#Ptr0x00000040d06fc3f0 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=5916/0x171c}
171c    #@ShouldNotReachHere

1728    B216: #	out( N2589 ) &lt;- in( B43 )  Freq: 4.99227e-07
1728 +  li R11, #-187	# int, #@loadConI
172c    spill R30 -&gt; R8	# spill size = 64
1730 +  spill R12 -&gt; [sp, #0]	# spill size = 32
1734 +  spill R13 -&gt; [sp, #4]	# spill size = 32
1738    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #4
        # java.lang.String::replace @ bci:6 (line 2801) L[0]=R8 L[1]=sp + #0 L[2]=#46 L[3]=_
        # java.lang.String::replace @ bci:63 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop off=5948/0x173c}
173c    #@ShouldNotReachHere

1748    B217: #	out( B32 ) &lt;- in( B160 )  Freq: 4.99217e-07
1748 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
1748    spill R23 -&gt; R11	# spill size = 64
174c +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
177c +  j  B32	#@branch

1780    B218: #	out( N2589 ) &lt;- in( B47 )  Freq: 4.99217e-07
1780 +  li R11, #-187	# int, #@loadConI
1784    spill R14 -&gt; R8	# spill size = 64
1788 +  spill R15 -&gt; [sp, #16]	# spill size = 32
178c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #16
        # java.lang.String::indexOf @ bci:1 (line 2416) L[0]=R8 L[1]=#46 L[2]=#0
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=R8 L[1]=_ L[2]=#0 L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=6032/0x1790}
1790    #@ShouldNotReachHere

179c    B219: #	out( N2589 ) &lt;- in( B62 )  Freq: 4.99131e-07
179c +  li R11, #-187	# int, #@loadConI
17a0    spill R14 -&gt; [sp, #8]	# spill size = 64
17a4 +  spill R30 -&gt; [sp, #20]	# spill size = 32
17a8 +  spill R30 -&gt; [sp, #24]	# spill size = 32
17ac    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:1 (line 4598) L[0]=sp + #24 L[1]=R8 L[2]=R8 STK[0]=sp + #20
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #8 L[1]=sp + #20 L[2]=R8 L[3]=R8 L[4]=_
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isTypeName @ bci:40 (line 136) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #8 L[5]=_
        # OopMap {[8]=Oop off=6064/0x17b0}
17b0    #@ShouldNotReachHere

17bc    B220: #	out( N2589 ) &lt;- in( B74 )  Freq: 4.99113e-07
17bc +  li R11, #-187	# int, #@loadConI
17c0    spill [sp, #0] -&gt; R8	# spill size = 64
17c4 +  spill R30 -&gt; [sp, #8]	# spill size = 64
17c8 +  spill R30 -&gt; [sp, #16]	# spill size = 64
17cc +  spill R28 -&gt; [sp, #24]	# spill size = 32
17d0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #24
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=sp + #8 L[1]=#0
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #16 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=6100/0x17d4}
17d4    #@ShouldNotReachHere

17e0    B221: #	out( N2589 ) &lt;- in( B77 )  Freq: 4.99112e-07
17e0 +  li R11, #-187	# int, #@loadConI
17e4    spill R30 -&gt; [sp, #8]	# spill size = 64
17e8 +  spill R14 -&gt; [sp, #16]	# spill size = 32
17ec    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.CharacterDataLatin1::isJavaIdentifierStart @ bci:14 (line 116) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8 STK[1]=#20480
        # java.lang.Character::isJavaIdentifierStart @ bci:5 (line 10070) L[0]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:28 (line 176) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {[0]=Oop [8]=Oop off=6128/0x17f0}
17f0    #@ShouldNotReachHere

17fc    B222: #	out( N2589 ) &lt;- in( B5 )  Freq: 4.76826e-07
17fc +  li R11, #-187	# int, #@loadConI
1800    spill R30 -&gt; [sp, #20]	# spill size = 32
1804    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:11 (line 279) L[0]=R8 L[1]=sp + #20 L[2]=_ L[3]=_ STK[0]=sp + #20
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=R8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=6152/0x1808}
1808    #@ShouldNotReachHere

1814    B223: #	out( N2589 ) &lt;- in( B41 )  Freq: 4.761e-07
1814 +  li R11, #-187	# int, #@loadConI
1818    spill R30 -&gt; R8	# spill size = 64
181c +  spill R31 -&gt; [sp, #0]	# spill size = 64
1820 +  spill R12 -&gt; [sp, #8]	# spill size = 32
1824    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:7 (line 47) L[0]=sp + #0 L[1]=#0 STK[0]=#0 STK[1]=sp + #8
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.String::replace @ bci:54 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=#Ptr0x00000040d06fc3f0 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=6184/0x1828}
1828    #@ShouldNotReachHere

1834    B224: #	out( N2589 ) &lt;- in( B42 )  Freq: 4.761e-07
1834 +  li R11, #-187	# int, #@loadConI
1838    spill R30 -&gt; R8	# spill size = 64
183c +  spill R12 -&gt; [sp, #4]	# spill size = 32
1840    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:2 (line 2800) L[0]=R8 L[1]=sp + #4 L[2]=#46 L[3]=_ STK[0]=sp + #4 STK[1]=#46
        # java.lang.String::replace @ bci:63 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop off=6212/0x1844}
1844    #@ShouldNotReachHere

1850    B225: #	out( N2589 ) &lt;- in( B49 )  Freq: 4.76089e-07
1850 +  li R11, #-187	# int, #@loadConI
1854    spill R14 -&gt; [sp, #8]	# spill size = 64
1858 +  spill R12 -&gt; [sp, #20]	# spill size = 32
185c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::indexOf @ bci:23 (line 209) L[0]=R8 L[1]=#46 L[2]=#0 L[3]=sp + #20 STK[0]=#0 STK[1]=sp + #20
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=sp + #8 L[1]=_ L[2]=#0 L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #8 L[5]=_
        # OopMap {fp=Oop [8]=Oop off=6240/0x1860}
1860    #@ShouldNotReachHere

186c    B226: #	out( N2589 ) &lt;- in( B63 )  Freq: 4.76008e-07
186c +  li R11, #-187	# int, #@loadConI
1870    spill R14 -&gt; [sp, #8]	# spill size = 64
1874 +  spill R30 -&gt; [sp, #20]	# spill size = 32
1878 +  spill R30 -&gt; [sp, #24]	# spill size = 32
187c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:6 (line 4598) L[0]=sp + #24 L[1]=R8 L[2]=R8 STK[0]=sp + #20 STK[1]=R8
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #8 L[1]=sp + #20 L[2]=R8 L[3]=R8 L[4]=_
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isTypeName @ bci:40 (line 136) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #8 L[5]=_
        # OopMap {[8]=Oop off=6272/0x1880}
1880    #@ShouldNotReachHere

188c    B227: #	out( N2589 ) &lt;- in( B71 )  Freq: 4.76001e-07
188c +  li R11, #-187	# int, #@loadConI
1890    spill R14 -&gt; [sp, #0]	# spill size = 64
1894 +  spill R10 -&gt; [sp, #8]	# spill size = 64
1898    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isEmpty @ bci:5 (line 1487) L[0]=_ STK[0]=R8
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {[0]=Oop [8]=Oop off=6300/0x189c}
189c    #@ShouldNotReachHere

18a8    B228: #	out( N2589 ) &lt;- in( B73 )  Freq: 4.75991e-07
18a8 +  spill [sp, #0] -&gt; R8	# spill size = 64
18ac +  li R11, #-187	# int, #@loadConI
18b0    spill R30 -&gt; [sp, #0]	# spill size = 64
18b4 +  spill R10 -&gt; [sp, #8]	# spill size = 32
18b8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::contains @ bci:17 (line 938) L[0]=_ L[1]=_ STK[0]=sp + #8
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop [0]=Oop off=6332/0x18bc}
18bc    #@ShouldNotReachHere

18c8    B229: #	out( N2589 ) &lt;- in( B76 )  Freq: 4.7599e-07
18c8 +  li R11, #-187	# int, #@loadConI
18cc    spill [sp, #0] -&gt; R8	# spill size = 64
18d0 +  spill R30 -&gt; [sp, #8]	# spill size = 64
18d4 +  spill R12 -&gt; [sp, #16]	# spill size = 64
18d8 +  spill R31 -&gt; [sp, #24]	# spill size = 32
18dc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:7 (line 47) L[0]=sp + #16 L[1]=#0 STK[0]=#0 STK[1]=sp + #24
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #8 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=6368/0x18e0}
18e0    #@ShouldNotReachHere

18ec    B230: #	out( N2589 ) &lt;- in( B91 )  Freq: 3.95701e-07
18ec    #@ShouldNotReachHere

18f8    B231: #	out( N2589 ) &lt;- in( B92 )  Freq: 3.95701e-07
18f8    #@ShouldNotReachHere

1904    B232: #	out( N2589 ) &lt;- in( B66 )  Freq: 3.13349e-07
1904 +  li R11, #-187	# int, #@loadConI
1908    spill R14 -&gt; [sp, #0]	# spill size = 64
190c +  spill R30 -&gt; [sp, #8]	# spill size = 32
1910 +  spill R13 -&gt; [sp, #12]	# spill size = 32
1914 +  spill R15 -&gt; [sp, #16]	# spill size = 32
1918    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #16
        # java.lang.String::substring @ bci:28 (line 2707) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=_ L[4]=sp + #12
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isTypeName @ bci:40 (line 136) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=sp + #0 L[5]=_
        # OopMap {[0]=Oop off=6428/0x191c}
191c    #@ShouldNotReachHere

1928    B233: #	out( B257 B234 ) &lt;- in( B143 )  Freq: 1.48883e-07
1928 +  spill R29 -&gt; [sp, #16]	# spill size = 64
192c +  spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
1934 +  mv  R11, precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# ptr, #@loadConP
194c    CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.Util::toString @ bci:0 (line 63) L[0]=sp + #16
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=sp + #0 STK[0]=sp + #0 STK[1]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:35 (line 747) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=6480/0x1950}

1950    B234: #	out( B145 ) &lt;- in( B233 )  Freq: 1.4888e-07
        # Block is sole successor of call
1950 +  spill [sp, #16] -&gt; R29	# spill size = 64
1954 +  j  B145	#@branch

1958    B235: #	out( N2589 ) &lt;- in( B147 )  Freq: 1.50832e-09
1958 +  li R11, #-10	# int, #@loadConI
195c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::toString @ bci:19 (line 757) L[0]=_ STK[0]=_ STK[1]=#NULL STK[2]=sp + #16
        # jdk.internal.module.ModulePath::toPackageName @ bci:35 (line 747) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {[16]=Oop off=6496/0x1960}
1960    #@ShouldNotReachHere

196c    B236: #	out( N2589 ) &lt;- in( B152 )  Freq: 1.50832e-09
196c +  li R11, #-10	# int, #@loadConI
1970    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:47 (line 748) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL STK[1]=#Ptr0x00000040d06fd450
        # OopMap {off=6516/0x1974}
1974    #@ShouldNotReachHere

1980    B237: #	out( N2589 ) &lt;- in( B156 )  Freq: 1.35743e-09
1980 +  li R11, #238	# int, #@loadConI
1984    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos; index=&apos;238&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:63 (line 749) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=6536/0x1988}
1988    #@ShouldNotReachHere

1994    B238: #	out( N2589 ) &lt;- in( B142 )  Freq: 7.44292e-10
1994 +  li R11, #-187	# int, #@loadConI
1998    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::toString @ bci:4 (line 756) L[0]=sp + #8 STK[0]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:35 (line 747) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [8]=Oop off=6556/0x199c}
199c    #@ShouldNotReachHere

19a8    B239: #	out( B150 ) &lt;- in( B182 )  Freq: 7.44257e-10
19a8 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
19a8    spill R23 -&gt; R11	# spill size = 64
19ac +  CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
19dc +  j  B150	#@branch

19e0    B240: #	out( N2589 ) &lt;- in( B100 )  Freq: 2.42251e-06
19e0 +  li R11, #-10	# int, #@loadConI
19e4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::substring @ bci:1 (line 2701) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6632/0x19e8}
19e8    #@ShouldNotReachHere

19f4    B241: #	out( N2589 ) &lt;- in( B112 )  Freq: 2.42245e-06
19f4 +  li R11, #-10	# int, #@loadConI
19f8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::isEmpty @ bci:4 (line 1487) L[0]=_ STK[0]=#NULL
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6652/0x19fc}
19fc    #@ShouldNotReachHere

1a08    B242: #	out( N2589 ) &lt;- in( B117 )  Freq: 2.4224e-06
1a08 +  li R11, #-10	# int, #@loadConI
1a0c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::charAt @ bci:6 (line 47) L[0]=_ L[1]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6672/0x1a10}
1a10    #@ShouldNotReachHere

1a1c    B243: #	out( N2589 ) &lt;- in( B55 )  Freq: 2.4223e-06
1a1c +  li R11, #-10	# int, #@loadConI
1a20    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::indexOf @ bci:10 (line 206) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6692/0x1a24}
1a24    #@ShouldNotReachHere

1a30    B244: #	out( N2589 ) &lt;- in( B1 )  Freq: 1.01328e-06
1a30 +  li R11, #-10	# int, #@loadConI
1a34    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # OopMap {off=6712/0x1a38}
1a38    #@ShouldNotReachHere

1a44    B245: #	out( N2589 ) &lt;- in( B4 )  Freq: 1.01326e-06
1a44 +  li R11, #-10	# int, #@loadConI
1a48    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:8 (line 278) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6732/0x1a4c}
1a4c    #@ShouldNotReachHere

1a58    B246: #	out( N2589 ) &lt;- in( B6 )  Freq: 1.01326e-06
1a58 +  li R11, #-10	# int, #@loadConI
1a5c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:23 (line 283) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6752/0x1a60}
1a60    #@ShouldNotReachHere

1a6c    B247: #	out( N2589 ) &lt;- in( B11 )  Freq: 1.01174e-06
1a6c +  li R11, #-12	# int, #@loadConI
1a70    spill [sp, #8] -&gt; R8	# spill size = 64
1a74 +  spill R29 -&gt; [sp, #20]	# spill size = 32
1a78    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=R8 L[1]=_ L[2]=sp + #20 L[3]=_ STK[0]=sp + #20
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=R8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=6780/0x1a7c}
1a7c    #@ShouldNotReachHere

1a88    B248: #	out( N2589 ) &lt;- in( B27 )  Freq: 1.01174e-06
1a88 +  li R11, #-10	# int, #@loadConI
1a8c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::&lt;init&gt; @ bci:4 (line 1380) L[0]=_ L[1]=_ L[2]=_ STK[0]=_ STK[1]=_ STK[2]=_ STK[3]=#NULL
        # sun.nio.fs.Util::toString @ bci:8 (line 63) L[0]=_ STK[0]=_
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=_ STK[0]=_ STK[1]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6800/0x1a90}
1a90    #@ShouldNotReachHere

1a9c    B249: #	out( N2589 ) &lt;- in( B34 )  Freq: 1.01172e-06
1a9c +  li R11, #-10	# int, #@loadConI
1aa0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL STK[1]=sp + #0 STK[2]=#Ptr0x00000040d06fc3f0
        # OopMap {[0]=Oop off=6820/0x1aa4}
1aa4    #@ShouldNotReachHere

1ab0    B250: #	out( N2589 ) &lt;- in( B35 )  Freq: 1.01172e-06
1ab0 +  li R11, #-10	# int, #@loadConI
1ab4    spill R30 -&gt; R8	# spill size = 64
1ab8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::replace @ bci:1 (line 2953) L[0]=R8 L[1]=_ L[2]=#Ptr0x00000040d06fc3f0 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=#NULL
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop off=6844/0x1abc}
1abc    #@ShouldNotReachHere

1ac8    B251: #	out( N2589 ) &lt;- in( B36 )  Freq: 1.01172e-06
1ac8 +  li R11, #-10	# int, #@loadConI
1acc    spill R30 -&gt; R8	# spill size = 64
1ad0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::replace @ bci:16 (line 2955) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=#Ptr0x00000040d06fc3f0 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=6868/0x1ad4}
1ad4    #@ShouldNotReachHere

1ae0    B252: #	out( N2589 ) &lt;- in( B37 )  Freq: 1.01172e-06
1ae0 +  li R11, #-10	# int, #@loadConI
1ae4    spill R30 -&gt; R8	# spill size = 64
1ae8 +  spill R10 -&gt; [sp, #8]	# spill size = 32
1aec    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::replace @ bci:22 (line 2956) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=#Ptr0x00000040d06fc3f0 L[5]=sp + #8 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=6896/0x1af0}
1af0    #@ShouldNotReachHere

1afc    B253: #	out( N2589 ) &lt;- in( B48 )  Freq: 1.01169e-06
1afc +  li R11, #-10	# int, #@loadConI
1b00    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::indexOf @ bci:10 (line 206) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6916/0x1b04}
1b04    #@ShouldNotReachHere

1b10    B254: #	out( N2589 ) &lt;- in( B70 )  Freq: 1.0115e-06
1b10 +  li R11, #-10	# int, #@loadConI
1b14    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::isEmpty @ bci:4 (line 1487) L[0]=_ STK[0]=#NULL
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6936/0x1b18}
1b18    #@ShouldNotReachHere

1b24    B255: #	out( N2589 ) &lt;- in( B75 )  Freq: 1.01148e-06
1b24 +  li R11, #-10	# int, #@loadConI
1b28    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::charAt @ bci:6 (line 47) L[0]=_ L[1]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6956/0x1b2c}
1b2c    #@ShouldNotReachHere

1b38    B256: #	out( N2589 ) &lt;- in( B145 )  Freq: 1.50835e-09
1b38 +  li R11, #-10	# int, #@loadConI
1b3c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::&lt;init&gt; @ bci:4 (line 1380) L[0]=_ L[1]=_ L[2]=_ STK[0]=_ STK[1]=_ STK[2]=_ STK[3]=#NULL
        # sun.nio.fs.Util::toString @ bci:8 (line 63) L[0]=_ STK[0]=_
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=_ STK[0]=_ STK[1]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:35 (line 747) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=6976/0x1b40}
1b40    #@ShouldNotReachHere

1b4c    B257: #	out( B266 ) &lt;- in( B233 )  Freq: 1.48883e-12
1b4c     -- 	// exception oop; no code emitted, #@CreateException
1b4c +  j  B266	#@branch

1b50    B258: #	out( B276 ) &lt;- in( B172 )  Freq: 9.97207e-10
1b50     -- 	// exception oop; no code emitted, #@CreateException
1b50 +  spill R10 -&gt; R11	# spill size = 64
1b54 +  j  B276	#@branch

1b58    B259: #	out( B271 ) &lt;- in( B170 )  Freq: 9.98648e-10
1b58     -- 	// exception oop; no code emitted, #@CreateException
1b58 +  j  B271	#@branch

1b5c    B260: #	out( B273 ) &lt;- in( B166 )  Freq: 9.98649e-10
1b5c     -- 	// exception oop; no code emitted, #@CreateException
1b5c +  j  B273	#@branch

1b60    B261: #	out( B273 ) &lt;- in( B168 )  Freq: 1.00877e-09
1b60     -- 	// exception oop; no code emitted, #@CreateException
1b60 +  j  B273	#@branch

1b64    B262: #	out( B276 ) &lt;- in( B155 )  Freq: 1.33967e-08
1b64     -- 	// exception oop; no code emitted, #@CreateException
1b64 +  spill R10 -&gt; R11	# spill size = 64
1b68 +  j  B276	#@branch

1b6c    B263: #	out( B276 ) &lt;- in( B153 )  Freq: 1.48855e-08
1b6c     -- 	// exception oop; no code emitted, #@CreateException
1b6c +  spill R10 -&gt; R11	# spill size = 64
1b70 +  j  B276	#@branch

1b74    B264: #	out( B273 ) &lt;- in( B140 )  Freq: 1.48859e-08
1b74     -- 	// exception oop; no code emitted, #@CreateException
1b74 +  j  B273	#@branch

1b78    B265: #	out( B266 ) &lt;- in( B146 )  Freq: 1.48858e-08
1b78     -- 	// exception oop; no code emitted, #@CreateException

1b78    B266: #	out( B276 ) &lt;- in( B257 B265 )  Freq: 1.48873e-08
1b78 +  spill R10 -&gt; R11	# spill size = 64
1b7c +  j  B276	#@branch

1b80    B267: #	out( B276 ) &lt;- in( B67 )  Freq: 6.26698e-06
1b80     -- 	// exception oop; no code emitted, #@CreateException
1b80 +  spill R10 -&gt; R11	# spill size = 64
1b84 +  j  B276	#@branch

1b88    B268: #	out( B276 ) &lt;- in( B72 )  Freq: 9.98246e-06
1b88     -- 	// exception oop; no code emitted, #@CreateException
1b88 +  spill R10 -&gt; R11	# spill size = 64
1b8c +  j  B276	#@branch

1b90    B269: #	out( B276 ) &lt;- in( B44 )  Freq: 9.98453e-06
1b90     -- 	// exception oop; no code emitted, #@CreateException
1b90 +  spill R10 -&gt; R11	# spill size = 64
1b94 +  j  B276	#@branch

1b98    B270: #	out( B271 ) &lt;- in( B28 )  Freq: 9.98481e-06
1b98     -- 	// exception oop; no code emitted, #@CreateException

1b98    B271: #	out( B276 ) &lt;- in( B259 B270 )  Freq: 9.98581e-06
1b98 +  spill R10 -&gt; R11	# spill size = 64
1b9c +  j  B276	#@branch

1ba0    B272: #	out( B273 ) &lt;- in( B3 )  Freq: 9.99998e-06
1ba0     -- 	// exception oop; no code emitted, #@CreateException

1ba0    B273: #	out( B276 ) &lt;- in( B272 B264 B261 B260 )  Freq: 1.00169e-05
1ba0 +  spill R10 -&gt; R11	# spill size = 64
1ba4 +  j  B276	#@branch

1ba8    B274: #	out( B276 ) &lt;- in( B114 )  Freq: 2.3907e-05
1ba8     -- 	// exception oop; no code emitted, #@CreateException
1ba8 +  spill R10 -&gt; R11	# spill size = 64
1bac +  j  B276	#@branch

1bb0    B275: #	out( B276 ) &lt;- in( B109 )  Freq: 2.38053e-05
1bb0     -- 	// exception oop; no code emitted, #@CreateException
1bb0 +  spill R10 -&gt; R11	# spill size = 64

1bb4    B276: #	out( N2589 ) &lt;- in( B273 B266 B263 B262 B271 B269 B275 B274 B267 B268 B258 )  Freq: 9.39931e-05
1bb4    # pop frame 96
	add  sp, sp, #96
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
1bc0 +  j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='340'>
----------------------- MetaData before Compile_id = 340 ------------------------
{method}
 - this oop:          0x00000040962b78b0
 - method holder:     &apos;sun/nio/fs/UnixPath&apos;
 - constants:         0x00000040962b5440 constant pool [472] {0x00000040962b5440} for &apos;sun/nio/fs/UnixPath&apos; cache=0x00000040962ba1a0
 - access:            0x81000001  public 
 - name:              &apos;getParent&apos;
 - signature:         &apos;()Lsun/nio/fs/UnixPath;&apos;
 - max stack:         6
 - max locals:        4
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      18
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c5609c0
 - code size:         64
 - code start:        0x00000040962b7830
 - code end (excl):   0x00000040962b7870
 - method data:       0x00000040964982e8
 - checked ex length: 0
 - linenumber start:  0x00000040962b7870
 - localvar length:   4
 - localvar start:    0x00000040962b787e
 - compiled code: nmethod  15698  277       3       sun.nio.fs.UnixPath::getParent (64 bytes)

------------------------ OptoAssembly for Compile_id = 340 -----------------------
#
#  sun/nio/fs/UnixPath * ( sun/nio/fs/UnixPath:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixPath:NotNull *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N375: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B39 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
03c     spill R11 -&gt; [sp, #0]	# spill size = 64
040     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 276) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=68/0x44}

044     B2: #	out( B33 B3 ) &lt;- in( B1 )  Freq: 0.99998
        # Block is sole successor of call
044 +   spill [sp, #0] -&gt; R7	# spill size = 64
048 +   lwu  R28, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
04c +   #@membar_acquire
	fence ir iorw
050 +   decode_heap_oop  R7, R28	#@decodeHeapOop
054     lwu  R29, [R7, #12]	# range, #@loadRange
058     NullCheck R7

058     B3: #	out( B32 B4 ) &lt;- in( B2 )  Freq: 0.999979
058 +   bleu  R29, zr, B32	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=5374.000000

05c     B4: #	out( B34 B5 ) &lt;- in( B3 )  Freq: 0.999978
05c +   spill [sp, #0] -&gt; R7	# spill size = 64
060 +   lwu  R7, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
064 +   decode_heap_oop  R30, R7	#@decodeHeapOop
068 +   addw  R28, R29, zr	#@convI2L_reg_reg
06c +   #@membar_acquire
	fence ir iorw
070 +   slli  R7, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
074 +   addiw  R8, R29, #-1	#@addI_reg_imm
078     lwu  R29, [R30, #12]	# range, #@loadRange
07c     NullCheck R30

07c     B5: #	out( B28 B6 ) &lt;- in( B4 )  Freq: 0.999977
07c +   add R7, R30, R7	# ptr, #@addP_reg_reg
080 +   bgeu  R8, R29, B28	#@cmpU_branch  P=0.000001 C=-1.000000

084     B6: #	out( B21 B7 ) &lt;- in( B5 )  Freq: 0.999976
084 +   lw  R8, [R7, #12]	# int, #@loadI
088 +   addiw  R28, R8, #-1	#@addI_reg_imm
08c +   ble  R28, zr, B21	#@cmpI_reg_imm0_branch  P=0.001489 C=5374.000000

090     B7: #	out( B29 B8 ) &lt;- in( B6 )  Freq: 0.998488
090 +   spill [sp, #0] -&gt; R7	# spill size = 64
094 +   lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
098 +   li R29, #1048576	# int, #@loadConI
09c +   decode_heap_oop  R31, R7	#@decodeHeapOop
0a0 +   bgtu  R28, R29, B29	#@cmpU_branch  P=0.000001 C=-1.000000

0a4     B8: #	out( B9 ) &lt;- in( B7 )  Freq: 0.998487
0a4 +   addw  R7, R8, zr	#@convI2L_reg_reg
0a8 +   addi  R7, R7, #-1	#@addL_reg_imm

0ac     B9: #	out( B35 B10 ) &lt;- in( B8 B29 )  Freq: 0.998488
0ac     lwu  R30, [R31, #12]	# range, #@loadRange
0b0     NullCheck R31

0b0     B10: #	out( B31 B11 ) &lt;- in( B9 )  Freq: 0.998487
0b0 +   addi  R10, R7, #23	#@addL_reg_imm
0b4 +   bltu  R30, R28, B31	#@cmpU_branch  P=0.000001 C=-1.000000

0b8     B11: #	out( B26 B12 ) &lt;- in( B10 )  Freq: 0.998486
0b8 +   andi  R12, R10, #-8	#@andL_reg_imm
0bc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0bc     bgtu  R28, R29, B26	#@cmpU_branch  P=0.000001 C=-1.000000

0c0     B12: #	out( B26 B13 ) &lt;- in( B11 )  Freq: 0.998485
0c0 +   ld  R9, [R23, #288]	# ptr, #@loadP
0c4 +   ld  R29, [R23, #304]	# ptr, #@loadP
0c8 +   add R7, R9, R12	# ptr, #@addP_reg_reg
0cc +   bgeu  R7, R29, B26	#@cmpP_branch  P=0.000100 C=-1.000000

0d0     B13: #	out( B14 ) &lt;- in( B12 )  Freq: 0.998385
0d0 +   sd  R7, [R23, #288]	# ptr, #@storeP
0d4 +   li R7, #1	# long, #@loadConL
0d8 +   mv  R29, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0e8 +   sd  R7, [R9]	# long, #@storeL
0ec +   sw  R29, [R9, #8]	# compressed klass ptr, #@storeNKlass
0f0 +   sw  R28, [R9, #12]	# int, #@storeI

0f4     B14: #	out( B30 B15 ) &lt;- in( B27 B13 )  Freq: 0.998486
0f4 +   srli  R7, R10, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
0f8     
0f8 +   # checkcastPP of R9, #@checkCastPP
0f8     encode_heap_oop  R10, R9	#@encodeHeapOop
0fc +   li R29, #1	# int, #@loadConI
100 +   # castII of R8, #@castII
100     addi  R11, R9, #16	# ptr, #@addP_reg_imm
104     spill R10 -&gt; [sp, #16]	# spill size = 32
108 +   beq  R8, R29, B30	#@cmpI_branch  P=0.000001 C=-1.000000

10c     B15: #	out( B23 B16 ) &lt;- in( B14 )  Freq: 0.998485
10c +   addiw  R30, R8, #-1	#@addI_reg_imm
110 +   addi  R10, R31, #16	# ptr, #@addP_reg_imm
114 +   blt  R30, R28, B23	#@cmpI_branch  P=0.001000 C=-1.000000

118     B16: #	out( B17 ) &lt;- in( B15 )  Freq: 0.997486
118 +   addi  R7, R12, #-16	#@addL_reg_imm
11c +   srli  R12, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
120 +   CALL, runtime leaf nofp 0x000000401396d840	#@CallLeafNoFPDirect jlong_disjoint_arraycopy
        No JVM State Info
        # 

124     B17: #	out( B24 B18 ) &lt;- in( B23 B16 B30 )  Freq: 0.998486
124     MEMBAR-store-store	#@membar_storestore
128 +   ld  R10, [R23, #288]	# ptr, #@loadP
12c +   ld  R7, [R23, #304]	# ptr, #@loadP
130 +   addi  R28, R10, #32	# ptr, #@addP_reg_imm
134 +   bgeu  R28, R7, B24	#@cmpP_branch  P=0.000100 C=-1.000000

138     B18: #	out( B19 ) &lt;- in( B17 )  Freq: 0.998386
138 +   li R7, #1	# long, #@loadConL
13c +   sd  R28, [R23, #288]	# ptr, #@storeP
140 +   sd  R7, [R10]	# long, #@storeL
144 +   mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d0672560:Constant:exact *	# compressed klass ptr, #@loadConNKlass
154 +   sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
158 +   sw  zr, [R10, #12]	# int, #@storeimmI0
15c +   sw  zr, [R10, #16]	# int, #@storeimmI0
160 +   sd  zr, [R10, #24]	# long, #@storeimmL0

164     B19: #	out( B20 ) &lt;- in( B25 B18 )  Freq: 0.998486
164     spill [sp, #16] -&gt; R7	# spill size = 32
168 +   sw  R7, [R10, #20]	# compressed ptr, #@storeN
16c     
16c     spill [sp, #0] -&gt; R7	# spill size = 64
170 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
174 +   # checkcastPP of R10, #@checkCastPP
174     sw  R28, [R10, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixPath.fs
178 +   #@membar_release
	fence iorw ow

17c     B20: #	out( N375 ) &lt;- in( B22 B19 )  Freq: 0.999974
17c     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
194 +   ret	// return register, #@Ret

198     B21: #	out( B38 B22 ) &lt;- in( B6 )  Freq: 0.00148859
198 +   spill [sp, #0] -&gt; R11	# spill size = 64
19c     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::getRoot
        # sun.nio.fs.UnixPath::getParent @ bci:32 (line 286) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=416/0x1a0}

1a0     B22: #	out( B20 ) &lt;- in( B21 )  Freq: 0.00148856
        # Block is sole successor of call
1a0 +   j  B20	#@branch

1a4     B23: #	out( B17 ) &lt;- in( B15 )  Freq: 0.000998485
1a4 +   addw  R30, R8, zr	#@convI2L_reg_reg
1a8 +   addi  R28, R30, #15	#@addL_reg_imm
1ac +   srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
1b0 +   andi  R28, R28, #-8	#@andL_reg_imm
1b4 +   add R28, R9, R28	# ptr, #@addP_reg_reg
1b8 +   sub  R29, R7, R29	#@subL_reg_reg
1bc     ClearArray R29, R28	#@clearArray_reg_reg
214 +   addi  R12, R30, #-1	#@addL_reg_imm
218     CALL, runtime leaf nofp 0x000000401396cf00	#@CallLeafNoFPDirect arrayof_jbyte_disjoint_arraycopy
        No JVM State Info
        # 
21c +   j  B17	#@branch

220     B24: #	out( B36 B25 ) &lt;- in( B17 )  Freq: 9.98652e-05
220 +   mv  R11, precise klass sun/nio/fs/UnixPath: 0x00000040d0672560:Constant:exact *	# ptr, #@loadConP
238     spill [sp, #0] -&gt; R8	# spill size = 64
23c +   spill R9 -&gt; [sp, #8]	# spill size = 64
240     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixPath::getParent @ bci:51 (line 290) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=NarrowOop off=580/0x244}

244     B25: #	out( B19 ) &lt;- in( B24 )  Freq: 9.98632e-05
        # Block is sole successor of call
244 +   j  B19	#@branch

248     B26: #	out( B37 B27 ) &lt;- in( B11 B12 )  Freq: 0.000100877
248 +   spill R12 -&gt; [sp, #32]	# spill size = 64
24c +   spill R10 -&gt; [sp, #24]	# spill size = 64
250 +   spill R31 -&gt; [sp, #16]	# spill size = 64
254 +   spill R28 -&gt; [sp, #8]	# spill size = 32
258 +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
270     spill R28 -&gt; R12	# spill size = 32
274     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=sp + #0 L[1]=_ L[2]=sp + #8 L[3]=_
        # OopMap {[0]=Oop [16]=Oop off=632/0x278}

278     B27: #	out( B14 ) &lt;- in( B26 )  Freq: 0.000100875
        # Block is sole successor of call
278 +   spill R10 -&gt; R9	# spill size = 64
27c +   spill [sp, #8] -&gt; R28	# spill size = 32
280 +   spill [sp, #16] -&gt; R31	# spill size = 64
284 +   spill [sp, #24] -&gt; R10	# spill size = 64
288 +   spill [sp, #32] -&gt; R12	# spill size = 64
28c +   j  B14	#@branch

290     B28: #	out( N375 ) &lt;- in( B5 )  Freq: 1.01326e-06
290 +   li R11, #-28	# int, #@loadConI
294     spill R30 -&gt; [sp, #8]	# spill size = 64
298     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:23 (line 283) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #8 STK[1]=R8
        # OopMap {[0]=Oop [8]=Oop off=668/0x29c}
29c     #@ShouldNotReachHere

2a8     B29: #	out( B9 ) &lt;- in( B7 )  Freq: 1.01175e-06
2a8 +   addw  R7, R28, zr	#@convI2L_reg_reg
2ac +   j  B9	#@branch

2b0     B30: #	out( B17 ) &lt;- in( B14 )  Freq: 1.01174e-06
2b0 +   spill R11 -&gt; R28	# spill size = 64
2b4 +   addi  R29, R7, #-2	#@addL_reg_imm
2b8     ClearArray R29, R28	#@clearArray_reg_reg
310     
310 +   j  B17	#@branch

314     B31: #	out( N375 ) &lt;- in( B10 )  Freq: 9.98487e-07
314 +   spill [sp, #0] -&gt; R8	# spill size = 64
318 +   li R11, #-52	# int, #@loadConI
31c     spill R28 -&gt; [sp, #4]	# spill size = 32
320     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=R8 L[1]=_ L[2]=sp + #4 L[3]=_ STK[0]=sp + #4
        # OopMap {fp=Oop off=804/0x324}
324     #@ShouldNotReachHere

330     B32: #	out( N375 ) &lt;- in( B3 )  Freq: 4.76827e-07
330 +   spill [sp, #0] -&gt; R8	# spill size = 64
334 +   li R11, #-187	# int, #@loadConI
338     spill R29 -&gt; [sp, #4]	# spill size = 32
33c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:11 (line 279) L[0]=R8 L[1]=sp + #4 L[2]=_ L[3]=_ STK[0]=sp + #4
        # OopMap {fp=Oop off=832/0x340}
340     #@ShouldNotReachHere

34c     B33: #	out( N375 ) &lt;- in( B2 )  Freq: 1.01326e-06
34c +   li R11, #-10	# int, #@loadConI
350     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:8 (line 278) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # OopMap {off=852/0x354}
354     #@ShouldNotReachHere

360     B34: #	out( N375 ) &lt;- in( B4 )  Freq: 1.01326e-06
360 +   li R11, #-10	# int, #@loadConI
364     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:23 (line 283) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL STK[1]=R8
        # OopMap {off=872/0x368}
368     #@ShouldNotReachHere

374     B35: #	out( N375 ) &lt;- in( B9 )  Freq: 1.01175e-06
374 +   spill [sp, #0] -&gt; R8	# spill size = 64
378 +   li R11, #-12	# int, #@loadConI
37c     spill R28 -&gt; [sp, #4]	# spill size = 32
380     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=R8 L[1]=_ L[2]=sp + #4 L[3]=_ STK[0]=sp + #4
        # OopMap {fp=Oop off=900/0x384}
384     #@ShouldNotReachHere

390     B36: #	out( B40 ) &lt;- in( B24 )  Freq: 9.98652e-10
390      -- 	// exception oop; no code emitted, #@CreateException
390 +   spill R10 -&gt; R11	# spill size = 64
394 +   j  B40	#@branch

398     B37: #	out( B40 ) &lt;- in( B26 )  Freq: 1.00877e-09
398      -- 	// exception oop; no code emitted, #@CreateException
398 +   spill R10 -&gt; R11	# spill size = 64
39c +   j  B40	#@branch

3a0     B38: #	out( B40 ) &lt;- in( B21 )  Freq: 1.48859e-08
3a0      -- 	// exception oop; no code emitted, #@CreateException
3a0 +   spill R10 -&gt; R11	# spill size = 64
3a4 +   j  B40	#@branch

3a8     B39: #	out( B40 ) &lt;- in( B1 )  Freq: 1e-05
3a8      -- 	// exception oop; no code emitted, #@CreateException
3a8 +   spill R10 -&gt; R11	# spill size = 64

3ac     B40: #	out( N375 ) &lt;- in( B39 B38 B37 B36 )  Freq: 1.00169e-05
3ac     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
3b8 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='341'>
----------------------- MetaData before Compile_id = 341 ------------------------
{method}
 - this oop:          0x0000004096592288
 - method holder:     &apos;java/nio/file/Files$$Lambda$7+0x00000008000191b8&apos;
 - constants:         0x0000004096592040 constant pool [23] {0x0000004096592040} for &apos;java/nio/file/Files$$Lambda$7+0x00000008000191b8&apos; cache=0x0000004096592318
 - access:            0x81000001  public 
 - name:              &apos;apply&apos;
 - signature:         &apos;(Ljava/lang/Object;)Ljava/lang/Object;&apos;
 - max stack:         2
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824bb30: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c52d3c0
 - code size:         8
 - code start:        0x0000004096592280
 - code end (excl):   0x0000004096592288
 - method data:       0x0000004096496338
 - checked ex length: 0
 - localvar length:   0
 - compiled code: nmethod  15722  241       3       java.nio.file.Files$$Lambda$7/0x00000008000191b8::apply (8 bytes)

------------------------ OptoAssembly for Compile_id = 341 -----------------------
#
#  java/lang/Object * ( java/nio/file/Files$$Lambda$7+0x00000008000191b8:NotNull:exact *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/nio/file/Files$$Lambda$7+0x00000008000191b8:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N44: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B5 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     lwu  R28, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
040     NullCheck R12

040     B2: #	out( B4 B3 ) &lt;- in( B1 )  Freq: 0.999999
040 +   mv  R7, narrowklass: precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d8328b40:Constant:exact *	# compressed klass ptr, #@loadConNKlass
050 +   bne  R28, R7, B4	#@cmpN_branch  P=0.000000 C=-1.000000

054     B3: #	out( N44 ) &lt;- in( B2 )  Freq: 0.999999
054 +   # checkcastPP of R12, #@checkCastPP
054     lwu  R28, [R12, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.file
058 +   decode_heap_oop  R10, R28	#@decodeHeapOop
05c     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
074 +   ret	// return register, #@Ret

078     B4: #	out( N44 ) &lt;- in( B2 )  Freq: 1e-35
078 +   li R11, #-34	# int, #@loadConI
07c     spill R12 -&gt; R8	# spill size = 64
080     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files$$Lambda$7/0x00000008000191b8::apply @ bci:1 L[0]=_ L[1]=_ STK[0]=R8
        # OopMap {fp=Oop off=132/0x84}
084     #@ShouldNotReachHere

090     B5: #	out( N44 ) &lt;- in( B1 )  Freq: 1.01328e-06
090 +   li R11, #-12	# int, #@loadConI
094     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.nio.file.Files$$Lambda$7/0x00000008000191b8::apply @ bci:1 L[0]=_ L[1]=_ STK[0]=#NULL
        # OopMap {off=152/0x98}
098 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='342'>
----------------------- MetaData before Compile_id = 342 ------------------------
{method}
 - this oop:          0x00000040965c0348
 - method holder:     &apos;jdk/internal/module/ModulePath$$Lambda$8+0x000000080001dd80&apos;
 - constants:         0x00000040965c00c0 constant pool [28] {0x00000040965c00c0} for &apos;jdk/internal/module/ModulePath$$Lambda$8+0x000000080001dd80&apos; cache=0x00000040965c03d8
 - access:            0x81000001  public 
 - name:              &apos;apply&apos;
 - signature:         &apos;(Ljava/lang/Object;)Ljava/lang/Object;&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824bb30: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c52dac0
 - code size:         12
 - code start:        0x00000040965c0338
 - code end (excl):   0x00000040965c0344
 - method data:       0x00000040964966b0
 - checked ex length: 0
 - localvar length:   0
 - compiled code: nmethod  15742  242       3       jdk.internal.module.ModulePath$$Lambda$8/0x000000080001dd80::apply (12 bytes)

------------------------ OptoAssembly for Compile_id = 342 -----------------------
#
#  java/lang/Object * ( jdk/internal/module/ModulePath$$Lambda$8+0x000000080001dd80:NotNull:exact *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: jdk/internal/module/ModulePath$$Lambda$8+0x000000080001dd80:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N97: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B10 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/module/ModulePath$$Lambda$8+0x000000080001dd80.arg$1 (constant)
040 +   decode_heap_oop  R11, R7	#@decodeHeapOop
044     lwu  R28, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
048     NullCheck R12

048     B2: #	out( B8 B3 ) &lt;- in( B1 )  Freq: 0.999999
048 +   mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d01ee000:Constant:exact *	# compressed klass ptr, #@loadConNKlass
058 +   bne  R28, R7, B8	#@cmpN_branch  P=0.000000 C=-1.000000

05c     B3: #	out( B11 B4 ) &lt;- in( B2 )  Freq: 0.999999
05c +   # checkcastPP of R12, #@checkCastPP
05c     lwu  R28, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
060     NullCheck R11

060     B4: #	out( B7 B5 ) &lt;- in( B3 )  Freq: 0.999998
060 +   bne  R28, R7, B7	#@cmpN_branch  P=0.000001 C=-1.000000

064     B5: #	out( B9 B6 ) &lt;- in( B4 )  Freq: 0.999997
064 +   # checkcastPP of R11, #@checkCastPP
064     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::relativize
        # sun.nio.fs.UnixPath::relativize @ bci:2 (line 43) L[0]=_ L[1]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$8 @ bci:2 (line 670) L[0]=_ L[1]=_
        # jdk.internal.module.ModulePath$$Lambda$8/0x000000080001dd80::apply @ bci:8 L[0]=_ L[1]=_
        # OopMap {off=104/0x68}

068     B6: #	out( N97 ) &lt;- in( B5 )  Freq: 0.999977
        # Block is sole successor of call
068 +   # checkcastPP of R10, #@checkCastPP
068     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
080 +   ret	// return register, #@Ret

084     B7: #	out( N97 ) &lt;- in( B4 )  Freq: 9.99998e-07
084 +   spill R11 -&gt; R8	# spill size = 64
088 +   spill R12 -&gt; [sp, #0]	# spill size = 64
08c +   li R11, #-34	# int, #@loadConI
090     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::lambda$explodedPackages$8 @ bci:2 (line 670) L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #0
        # jdk.internal.module.ModulePath$$Lambda$8/0x000000080001dd80::apply @ bci:8 L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=148/0x94}
094     #@ShouldNotReachHere

0a0     B8: #	out( N97 ) &lt;- in( B2 )  Freq: 1e-35
0a0 +   spill R11 -&gt; R8	# spill size = 64
0a4 +   spill R12 -&gt; [sp, #0]	# spill size = 64
0a8 +   li R11, #-34	# int, #@loadConI
0ac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$8/0x000000080001dd80::apply @ bci:5 L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop off=176/0xb0}
0b0     #@ShouldNotReachHere

0bc     B9: #	out( N97 ) &lt;- in( B5 )  Freq: 9.99997e-06
0bc      -- 	// exception oop; no code emitted, #@CreateException
0bc +   spill R10 -&gt; R11	# spill size = 64
0c0 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
0cc +   j rethrow_stub	#@RethrowException

0d4     B10: #	out( N97 ) &lt;- in( B1 )  Freq: 1.01328e-06
0d4 +   spill R11 -&gt; R8	# spill size = 64
0d8 +   li R11, #-12	# int, #@loadConI
0dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.module.ModulePath$$Lambda$8/0x000000080001dd80::apply @ bci:5 L[0]=_ L[1]=_ STK[0]=R8 STK[1]=#NULL
        # OopMap {fp=Oop off=224/0xe0}
0e0     #@ShouldNotReachHere

0ec     B11: #	out( N97 ) &lt;- in( B3 )  Freq: 1.01328e-06
0ec +   li R11, #-10	# int, #@loadConI
0f0     spill R12 -&gt; R8	# spill size = 64
0f4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::lambda$explodedPackages$8 @ bci:2 (line 670) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8
        # jdk.internal.module.ModulePath$$Lambda$8/0x000000080001dd80::apply @ bci:8 L[0]=_ L[1]=_
        # OopMap {fp=Oop off=248/0xf8}
0f8 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='343'>
----------------------- MetaData before Compile_id = 343 ------------------------
{method}
 - this oop:          0x00000040965c2418
 - method holder:     &apos;jdk/internal/module/ModulePath$$Lambda$9+0x000000080001dfd8&apos;
 - constants:         0x00000040965c2168 constant pool [32] {0x00000040965c2168} for &apos;jdk/internal/module/ModulePath$$Lambda$9+0x000000080001dfd8&apos; cache=0x00000040965c24a8
 - access:            0x81000001  public 
 - name:              &apos;apply&apos;
 - signature:         &apos;(Ljava/lang/Object;)Ljava/lang/Object;&apos;
 - max stack:         4
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824bb30: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c52fb40
 - code size:         16
 - code start:        0x00000040965c2408
 - code end (excl):   0x00000040965c2418
 - method data:       0x00000040964978f0
 - checked ex length: 0
 - localvar length:   0
 - compiled code: nmethod  15762  244       3       jdk.internal.module.ModulePath$$Lambda$9/0x000000080001dfd8::apply (16 bytes)

------------------------ OptoAssembly for Compile_id = 343 -----------------------
#
#  java/lang/Object * ( jdk/internal/module/ModulePath$$Lambda$9+0x000000080001dfd8:NotNull:exact *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: jdk/internal/module/ModulePath$$Lambda$9+0x000000080001dfd8:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N83: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B9 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/module/ModulePath$$Lambda$9+0x000000080001dfd8.arg$1 (constant)
040 +   lwu  R29, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/module/ModulePath$$Lambda$9+0x000000080001dfd8.arg$2 (constant)
044 +   decode_heap_oop  R11, R7	#@decodeHeapOop
048 +   decode_heap_oop  R13, R29	#@decodeHeapOop
04c     lwu  R7, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
050     NullCheck R12

050     B2: #	out( B7 B3 ) &lt;- in( B1 )  Freq: 0.999999
050 +   mv  R29, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d0647350:Constant:exact *	# compressed klass ptr, #@loadConNKlass
060 +   bne  R7, R29, B7	#@cmpN_branch  P=0.000000 C=-1.000000

064     B3: #	out( B6 B4 ) &lt;- in( B2 )  Freq: 0.999999
064 +   # checkcastPP of R12, #@checkCastPP
064     beq   R11, zr, B6	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

068     B4: #	out( B8 B5 ) &lt;- in( B3 )  Freq: 0.999998
068     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect jdk.internal.module.ModulePath::toPackageName
        # jdk.internal.module.ModulePath::lambda$explodedPackages$9 @ bci:3 (line 671) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$9/0x000000080001dfd8::apply @ bci:12 L[0]=_ L[1]=_
        # OopMap {off=108/0x6c}

06c     B5: #	out( N83 ) &lt;- in( B4 )  Freq: 0.999978
        # Block is sole successor of call
06c     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
084 +   ret	// return register, #@Ret

088     B6: #	out( N83 ) &lt;- in( B3 )  Freq: 1.01328e-06
088 +   li R11, #-10	# int, #@loadConI
08c     spill R13 -&gt; R8	# spill size = 64
090 +   spill R12 -&gt; [sp, #0]	# spill size = 64
094     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$9/0x000000080001dfd8::apply @ bci:12 L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8 STK[2]=sp + #0
        # OopMap {fp=Oop [0]=Oop off=152/0x98}
098     #@ShouldNotReachHere

0a4     B7: #	out( N83 ) &lt;- in( B2 )  Freq: 1e-35
0a4 +   spill R11 -&gt; R8	# spill size = 64
0a8 +   spill R13 -&gt; [sp, #0]	# spill size = 64
0ac +   spill R12 -&gt; [sp, #8]	# spill size = 64
0b0 +   li R11, #-34	# int, #@loadConI
0b4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$9/0x000000080001dfd8::apply @ bci:9 L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #0 STK[2]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=184/0xb8}
0b8     #@ShouldNotReachHere

0c4     B8: #	out( N83 ) &lt;- in( B4 )  Freq: 9.99998e-06
0c4      -- 	// exception oop; no code emitted, #@CreateException
0c4 +   spill R10 -&gt; R11	# spill size = 64
0c8 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
0d4 +   j rethrow_stub	#@RethrowException

0dc     B9: #	out( N83 ) &lt;- in( B1 )  Freq: 1.01328e-06
0dc +   spill R11 -&gt; R8	# spill size = 64
0e0 +   spill R13 -&gt; [sp, #0]	# spill size = 64
0e4 +   li R11, #-12	# int, #@loadConI
0e8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.module.ModulePath$$Lambda$9/0x000000080001dfd8::apply @ bci:9 L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #0 STK[2]=#NULL
        # OopMap {fp=Oop [0]=Oop off=236/0xec}
0ec +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='351'>
----------------------- MetaData before Compile_id = 351 ------------------------
{method}
 - this oop:          0x00000040961646d0
 - method holder:     &apos;java/util/ImmutableCollections$SetN&apos;
 - constants:         0x00000040961639e8 constant pool [168] {0x00000040961639e8} for &apos;java/util/ImmutableCollections$SetN&apos; cache=0x0000004096164c20
 - access:            0xc1000002  private 
 - name:              &apos;probe&apos;
 - signature:         &apos;(Ljava/lang/Object;)I&apos;
 - max stack:         3
 - max locals:        4
 - size of params:    2
 - method size:       13
 - highest level:     4
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824bb30: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c578800
 - code size:         56
 - code start:        0x0000004096164658
 - code end (excl):   0x0000004096164690
 - method data:       0x00000040965ee138
 - checked ex length: 0
 - linenumber start:  0x0000004096164690
 - localvar length:   4
 - localvar start:    0x000000409616469e
 - compiled code: nmethod  16211  349       3       java.util.ImmutableCollections$SetN::probe (56 bytes)

------------------------ OptoAssembly for Compile_id = 351 -----------------------
#
#  int ( java/util/ImmutableCollections$SetN:NotNull:exact *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/ImmutableCollections$SetN:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N851: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B93 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
03c     spill R11 -&gt; [sp, #8]	# spill size = 64
040 +   spill R12 -&gt; [sp, #16]	# spill size = 64
044     lwu  R7, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
048     NullCheck R12

048     B2: #	out( B56 B3 ) &lt;- in( B1 )  Freq: 0.999999
048 +   spill R7 -&gt; [sp, #0]	# spill size = 32
04c +   mv  R7, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
05c +   li R30, #0	# int, #@loadConI
060     spill [sp, #0] -&gt; R28	# spill size = 32
064 +   li R11, #1	# int, #@loadConI
068 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
068     bne  R28, R7, B56	#@cmpN_branch  P=0.000488 C=-1.000000

06c     B3: #	out( B22 B4 ) &lt;- in( B2 )  Freq: 0.999511
06c +   spill R12 -&gt; R14	# spill size = 64
070 +   # checkcastPP of R14, #@checkCastPP
070     lw  R10, [R14, #12]	# int, #@loadI ! Field: java/lang/String.hash
074 +   bne  R10, zr, B22	#@cmpI_reg_imm0_branch  P=0.474144 C=5376.000000

078     B4: #	out( B55 B5 ) &lt;- in( B3 )  Freq: 0.525598
078 +   lbu  R28, [R14, #17]	# byte, #@loadUB ! Field: java/lang/String.hashIsZero
07c +   bne  R28, zr, B55	#@cmpI_reg_imm0_branch  P=0.001062 C=2826.000000

080     B5: #	out( B85 B6 ) &lt;- in( B4 )  Freq: 0.52504
080 +   lwu  R7, [R14, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
084 +   lb  R8, [R14, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
088 +   decode_heap_oop  R29, R7	#@decodeHeapOop
08c +   bne  R8, zr, B85	#@cmpI_reg_imm0_branch  P=0.000000 C=68009.000000

090     B6: #	out( B95 B7 ) &lt;- in( B5 )  Freq: 0.52504
090     lwu  R8, [R29, #12]	# range, #@loadRange
094     NullCheck R29

094     B7: #	out( B54 B8 ) &lt;- in( B6 )  Freq: 0.52504
094 +   bleu  R8, zr, B54	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.056079 C=18260.000000

098     B8: #	out( B78 B9 ) &lt;- in( B7 )  Freq: 0.495596
098 +   addiw  R28, R8, #-1	#@addI_reg_imm
09c +   bgeu  R28, R8, B78	#@cmpU_branch  P=0.000001 C=-1.000000

0a0     B9: #	out( B79 B10 ) &lt;- in( B8 )  Freq: 0.495595
0a0 +   addiw  R13, R8, #-3	#@addI_reg_imm
0a4 +   li R12, #4000	# int, #@loadConI
0ac +   lbu  R10, [R29, #16]	# byte, #@loadUB
0b0 +   ble  R13, R11, B79	#@cmpI_branch  P=0.000001 C=-1.000000

0b4     B10: #	out( B80 B11 ) &lt;- in( B9 )  Freq: 0.495595
0b4 +   slliw  R7, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0b8 +   subw  R31, R7, R10	#@subI_reg_reg
0bc +   li R28, #4	# int, #@loadConI
0c0 +   bleu  R8, R11, B80	#@cmpU_branch  P=0.000001 C=-1.000000

0c4     B11: #	out( B81 B12 ) &lt;- in( B10 )  Freq: 0.495594
0c4 +   bleu  R8, R28, B81	#@cmpU_branch  P=0.000001 C=-1.000000

0c8     B12: #	out( B13 ) &lt;- in( B11 )  Freq: 0.495594
0c8 +   li R15, #1	# int, #@loadConI

0cc     B13: #	out( B14 ) &lt;- in( B12 B15 ) Loop( B13-B15 ) Freq: 8.83745
0cc +   subw  R7, R8, R15	#@subI_reg_reg
0d0 +   addiw  R28, R7, #-3	#@addI_reg_imm
0d4     CMove R28, (R13 lt R15), R28, R30	#@cmovI_cmpI
	
0dc +   CMove R28, (R28 gtu R12), R28, R12	#@cmovI_cmpU
	
0e4 +   addw  R9, R28, R15	#@addI_reg_reg
        nop 	# 4 bytes pad for loops and calls

0f0     B14: #	out( B14 B15 ) &lt;- in( B13 B14 ) Loop( B14-B14 inner main of N84 strip mined) Freq: 157.59
0f0 +   addw  R7, R15, zr	#@convI2L_reg_reg
0f4 +   add R7, R29, R7	# ptr, #@addP_reg_reg
0f8 +   lbu  R28, [R7, #16]	# byte, #@loadUB
0fc +   addw  R28, R31, R28	#@addI_reg_reg
100 +   lbu  R16, [R7, #17]	# byte, #@loadUB
104 +   slliw  R10, R28, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
108 +   subw  R28, R10, R28	#@subI_reg_reg
10c +   addw  R10, R28, R16	#@addI_reg_reg
110 +   lbu  R31, [R7, #18]	# byte, #@loadUB
114 +   slliw  R28, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
118 +   subw  R10, R28, R10	#@subI_reg_reg
11c +   addw  R31, R10, R31	#@addI_reg_reg
120 +   lbu  R7, [R7, #19]	# byte, #@loadUB
124 +   slliw  R28, R31, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
128 +   subw  R31, R28, R31	#@subI_reg_reg
12c +   addw  R10, R31, R7	#@addI_reg_reg
130 +   slliw  R7, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
134 +   addiw  R15, R15, #4	#@addI_reg_imm
138 +   subw  R31, R7, R10	#@subI_reg_reg
13c +   blt  R15, R9, B14	#@cmpI_loop  P=0.943921 C=17236.000000

140     B15: #	out( B13 B16 ) &lt;- in( B14 )  Freq: 8.83745
140 +   ld  R16, [R23, #920]	# ptr, #@loadP
144 +   lwu zr, [R16]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::hashCode @ bci:37 (line 196) L[0]=_ L[1]=R10 L[2]=R29 L[3]=R8 L[4]=R15 L[5]=_
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=R14 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #8 L[1]=R14 L[2]=_ L[3]=_
        # OopMap {x29=Oop c_rarg4=Oop [8]=Oop [16]=Oop off=324/0x144}
148 +   blt  R15, R13, B13	#@cmpI_branch  P=0.943921 C=17236.000000

14c     B16: #	out( B20 B17 ) &lt;- in( B79 B15 )  Freq: 0.495594
14c +   bge  R15, R8, B20	#@cmpI_branch  P=0.500000 C=-1.000000

150     B17: #	out( B86 B18 ) &lt;- in( B16 )  Freq: 0.247797
150 +   # castII of R15, #@castII
150     bgeu  R15, R8, B86	#@cmpU_branch  P=0.000001 C=-1.000000

154     B18: #	out( B87 B19 ) &lt;- in( B17 )  Freq: 0.247797
154 +   spill R15 -&gt; R28	# spill size = 32
158 +   # castII of R28, #@castII
158     bgeu  R28, R8, B87	#@cmpU_branch  P=0.000001 C=-1.000000

15c     B19: #	out( B19 B20 ) &lt;- in( B18 B19 ) Loop( B19-B19 inner post of N849) Freq: 0.495593
15c +   addw  R7, R15, zr	#@convI2L_reg_reg
160 +   add R7, R29, R7	# ptr, #@addP_reg_reg
164 +   slliw  R30, R10, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
168 +   lbu  R7, [R7, #16]	# byte, #@loadUB
16c +   subw  R28, R30, R10	#@subI_reg_reg
170 +   addiw  R15, R15, #1	#@addI_reg_imm
174 +   addw  R10, R28, R7	#@addI_reg_reg
178 +   blt  R15, R8, B19	#@cmpI_loop  P=0.500000 C=17236.000000

17c     B20: #	out( B54 B21 ) &lt;- in( B19 B16 )  Freq: 0.495594
17c +   beq  R10, zr, B54	#@cmpI_reg_imm0_branch  P=0.000354 C=2823.000000

180     B21: #	out( B22 ) &lt;- in( B20 )  Freq: 0.495418
180 +   sw  R10, [R14, #12]	# int, #@storeI ! Field: java/lang/String.hash

184     B22: #	out( B94 B23 ) &lt;- in( B21 B54 B55 B3 B57 )  Freq: 0.999996
184     spill [sp, #8] -&gt; R7	# spill size = 64
188 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$SetN.elements (constant)
18c +   decode_heap_oop  R31, R28	#@decodeHeapOop
190     lwu  R7, [R31, #12]	# range, #@loadRange
194     NullCheck R31

194     B23: #	out( B69 B24 ) &lt;- in( B22 )  Freq: 0.999995
194 +   bleu  R7, zr, B69	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

198     B24: #	out( B52 B25 ) &lt;- in( B23 )  Freq: 0.999994
198 +   remw  R8, R10, R7	#@modI
19c +   xorr  R28, R8, R7	#@xorI_reg_reg
1a0 +   blt  R28, zr, B52	#@cmpI_reg_imm0_branch  P=0.080904 C=10531.000000

1a4     B25: #	out( B68 B26 ) &lt;- in( B24 B53 )  Freq: 0.999994
1a4 +   addw  R28, R8, zr	#@convI2L_reg_reg
1a8 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
1ac +   add R28, R31, R28	# ptr, #@addP_reg_reg
1b0 +   bgeu  R8, R7, B68	#@cmpU_branch  P=0.000001 C=-1.000000

1b4     B26: #	out( B51 B27 ) &lt;- in( B25 )  Freq: 0.999993
1b4 +   lwu  R28, [R28, #16]	# loadN, compressed ptr, #@loadN
1b8 +   decode_heap_oop  R10, R28	#@decodeHeapOop
1bc +   beq   R10, zr, B51	#@cmpP_imm0_branch  P=0.437888 C=23385.000000

1c0     B27: #	out( B58 B28 ) &lt;- in( B26 )  Freq: 0.562109
1c0 +   mv  R29, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1d0     spill [sp, #0] -&gt; R30	# spill size = 32
1d4 +   bne  R30, R29, B58	#@cmpN_branch  P=0.000152 C=-1.000000

1d8     B28: #	out( B70 B29 ) &lt;- in( B27 )  Freq: 0.562023
1d8 +   spill [sp, #16] -&gt; R12	# spill size = 64
1dc +   lwu  R29, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
1e0 +   # checkcastPP of R12, #@checkCastPP
1e0     lb  R15, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
1e4 +   mv  R28, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1f4 +   beq  R12, R10, B70	#@cmpP_branch  P=0.000001 C=5338.000000

1f8     B29: #	out( B91 B30 ) &lt;- in( B28 )  Freq: 0.562022
1f8 +   bne  R29, R28, B91	#@cmpN_branch  P=0.000000 C=-1.000000

1fc     B30: #	out( B82 B31 ) &lt;- in( B29 )  Freq: 0.562022
1fc +   # checkcastPP of R10, #@checkCastPP
1fc     lb  R29, [R10, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
200 +   bne  R15, R29, B82	#@cmpI_branch  P=0.000000 C=4992.000000

204     B31: #	out( B77 B32 ) &lt;- in( B30 )  Freq: 0.562022
204 +   lwu  R28, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
208 +   decode_heap_oop  R16, R28	#@decodeHeapOop
20c +   lwu  R10, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
210 +   beq   R16, zr, B77	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

214     B32: #	out( B74 B33 ) &lt;- in( B31 )  Freq: 0.562022
214 +   decode_heap_oop  R29, R10	#@decodeHeapOop
218 +   lwu  R28, [R16, #12]	# range, #@loadRange
21c +   addiw  R30, R8, #1	#@addI_reg_imm
220 +   beq   R29, zr, B74	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

224     B33: #	out( B35 B34 ) &lt;- in( B32 )  Freq: 0.562021
224 +   lwu  R10, [R29, #12]	# range, #@loadRange
228 +   addi  R17, R16, #16	# ptr, #@addP_reg_imm
22c +   bne  R28, R10, B35	#@cmpI_branch  P=0.001000 C=-1.000000

230     B34: #	out( B72 B35 ) &lt;- in( B33 )  Freq: 0.561459
230 +   spill R28 -&gt; R14	# spill size = 32
234 +   addi  R13, R29, #16	# ptr, #@addP_reg_imm
238     spill R17 -&gt; R11	# spill size = 64
23c +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
2cc +   bne  R10, zr, B72	#@cmpI_reg_imm0_branch  P=0.000000 C=13145.000000

2d0     B35: #	out( B67 B36 ) &lt;- in( B34 B33 )  Freq: 0.562021
2d0 +   beq  R30, R7, B67	#@cmpI_branch  P=0.000076 C=13146.000000

2d4     B36: #	out( B75 B37 ) &lt;- in( B67 B35 )  Freq: 0.562021
2d4 +   addw  R29, R30, zr	#@convI2L_reg_reg
2d8 +   slli  R29, R29, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
2dc +   add R29, R31, R29	# ptr, #@addP_reg_reg
2e0 +   bgeu  R30, R7, B75	#@cmpU_branch  P=0.000001 C=-1.000000

2e4     B37: #	out( B50 B38 ) &lt;- in( B36 )  Freq: 0.56202
2e4 +   lwu  R10, [R29, #16]	# loadN, compressed ptr, #@loadN
2e8 +   decode_heap_oop  R10, R10	#@decodeHeapOop
2ec +   beq   R10, zr, B50	#@cmpP_imm0_branch  P=0.437888 C=13146.000000

2f0     B38: #	out( B40 ) &lt;- in( B37 )  Freq: 0.315919
2f0 +   mv  R9, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
300 +   j  B40	#@branch
        nop 	# 6 bytes pad for loops and calls

310     B39: #	out( B40 ) &lt;- in( B48 ) top-of-loop Freq: 0.405538
310 +   spill R8 -&gt; R30	# spill size = 32

314     B40: #	out( B71 B41 ) &lt;- in( B38 B39 ) Loop( B40-B39 inner ) Freq: 0.721457
314 +   lwu  R11, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
318 +   beq  R12, R10, B71	#@cmpP_branch  P=0.000001 C=5338.000000

31c     B41: #	out( B92 B42 ) &lt;- in( B40 )  Freq: 0.721456
31c +   bne  R11, R9, B92	#@cmpN_branch  P=0.000000 C=-1.000000

320     B42: #	out( B83 B43 ) &lt;- in( B41 )  Freq: 0.721456
320 +   # checkcastPP of R10, #@checkCastPP
320     lwu  R11, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
324 +   lb  R29, [R10, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
328 +   decode_heap_oop  R11, R11	#@decodeHeapOop
32c +   bne  R15, R29, B83	#@cmpI_branch  P=0.000000 C=4992.000000

330     B43: #	out( B74 B44 ) &lt;- in( B42 )  Freq: 0.721456
330 +   beq   R11, zr, B74	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

334     B44: #	out( B46 B45 ) &lt;- in( B43 )  Freq: 0.721455
334 +   lwu  R10, [R11, #12]	# range, #@loadRange
338 +   addiw  R8, R30, #1	#@addI_reg_imm
33c +   bne  R28, R10, B46	#@cmpI_branch  P=0.001000 C=-1.000000

340     B45: #	out( B84 B46 ) &lt;- in( B44 )  Freq: 0.720734
340 +   addi  R13, R11, #16	# ptr, #@addP_reg_imm
344     spill R28 -&gt; R14	# spill size = 32
348 +   spill R17 -&gt; R11	# spill size = 64
34c +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
3dc +   bne  R10, zr, B84	#@cmpI_reg_imm0_branch  P=0.000000 C=13145.000000

3e0     B46: #	out( B66 B47 ) &lt;- in( B45 B44 )  Freq: 0.721455
3e0 +   beq  R8, R7, B66	#@cmpI_branch  P=0.000076 C=13146.000000

3e4     B47: #	out( B76 B48 ) &lt;- in( B66 B46 )  Freq: 0.721455
3e4 +   ld  R29, [R23, #920]	# ptr, #@loadP
3e8 +   lwu zr, [R29]	# Safepoint: poll for GC, #@safePoint        # java.util.ImmutableCollections$SetN::probe @ bci:53 (line 1017) L[0]=sp + #8 L[1]=sp + #16 L[2]=R8 L[3]=_
        # OopMap {xmethod=Oop c_rarg2=Oop c_rarg6=Oop c_rarg7=Derived_oop_c_rarg6 [8]=Oop [16]=Oop off=1000/0x3e8}
3ec +   addw  R29, R8, zr	#@convI2L_reg_reg
3f0 +   slli  R29, R29, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
3f4 +   add R29, R31, R29	# ptr, #@addP_reg_reg
3f8 +   bgeu  R8, R7, B76	#@cmpU_branch  P=0.000001 C=-1.000000

3fc     B48: #	out( B39 B49 ) &lt;- in( B47 )  Freq: 0.721454
3fc +   lwu  R29, [R29, #16]	# loadN, compressed ptr, #@loadN
400 +   decode_heap_oop  R10, R29	#@decodeHeapOop
404 +   bne   R10, zr, B39	#@cmpP_imm0_branch  P=0.562112 C=13146.000000

408     B49: #	out( B51 ) &lt;- in( B48 )  Freq: 0.315916
408 +   j  B51	#@branch

40c     B50: #	out( B51 ) &lt;- in( B37 )  Freq: 0.246102
40c +   spill R30 -&gt; R8	# spill size = 32

410     B51: #	out( N851 ) &lt;- in( B50 B49 B65 B26 )  Freq: 0.999987
410 +   li R28, #-1	# int, #@loadConI
414 +   subw  R10, R28, R8	#@subI_reg_reg
418     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
430 +   ret	// return register, #@Ret

434     B52: #	out( B88 B53 ) &lt;- in( B24 )  Freq: 0.0809035
434 +   addw  R29, R8, R7	#@addI_reg_reg
438 +   beq  R8, zr, B88	#@cmpI_reg_imm0_branch  P=0.000000 C=852.000000

43c     B53: #	out( B25 ) &lt;- in( B52 )  Freq: 0.0809035
43c +   spill R29 -&gt; R8	# spill size = 32
440 +   j  B25	#@branch

444     B54: #	out( B22 ) &lt;- in( B20 B7 )  Freq: 0.0296192
444 +   sb  R11, [R14, #17]	# byte, #@storeB ! Field: java/lang/String.hashIsZero
448 +   li R10, #0	# int, #@loadConI
44c +   j  B22	#@branch

450     B55: #	out( B22 ) &lt;- in( B4 )  Freq: 0.00055796
450 +   li R10, #0	# int, #@loadConI
454 +   j  B22	#@branch

458     B56: #	out( B96 B57 ) &lt;- in( B2 )  Freq: 0.00048834
458 +   spill R12 -&gt; R11	# spill size = 64
45c +   spill R12 -&gt; R8	# spill size = 64
460     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #8 L[1]=R8 L[2]=_ L[3]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=1148/0x47c}

47c     B57: #	out( B22 ) &lt;- in( B56 )  Freq: 0.000488331
        # Block is sole successor of call
47c +   j  B22	#@branch

480     B58: #	out( B59 ) &lt;- in( B27 )  Freq: 8.55364e-05
480 +   spill R10 -&gt; R12	# spill size = 64
        nop 	# 6 bytes pad for loops and calls

490     B59: #	out( B97 B60 ) &lt;- in( B58 B64 ) Loop( B59-B64 inner ) Freq: 0.000195338
490 +   spill [sp, #16] -&gt; R11	# spill size = 64
494     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::equals
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=sp + #8 L[1]=sp + #16 L[2]=R8 L[3]=_
        # OopMap {[8]=Oop [16]=Oop off=1200/0x4b0}

4b0     B60: #	out( B90 B61 ) &lt;- in( B59 )  Freq: 0.000195334
        # Block is sole successor of call
4b0 +   spill [sp, #8] -&gt; R7	# spill size = 64
4b4 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$SetN.elements (constant)
4b8 +   decode_heap_oop  R31, R28	#@decodeHeapOop
4bc +   bne  R10, zr, B90	#@cmpI_reg_imm0_branch  P=0.000000 C=13145.000000

4c0     B61: #	out( B99 B62 ) &lt;- in( B60 )  Freq: 0.000195334
4c0     lwu  R30, [R31, #12]	# range, #@loadRange
4c4     NullCheck R31

4c4     B62: #	out( B89 B63 ) &lt;- in( B61 )  Freq: 0.000195333
4c4 +   addiw  R8, R8, #1	#@addI_reg_imm
4c8 +   beq  R8, R30, B89	#@cmpI_branch  P=0.000076 C=13146.000000

4cc     B63: #	out( B76 B64 ) &lt;- in( B89 B62 )  Freq: 0.000195333
4cc +   ld  R10, [R23, #920]	# ptr, #@loadP
4d0 +   lwu zr, [R10]	# Safepoint: poll for GC, #@safePoint        # java.util.ImmutableCollections$SetN::probe @ bci:53 (line 1017) L[0]=R7 L[1]=sp + #16 L[2]=R8 L[3]=_
        # OopMap {t2=Oop xmethod=Oop [8]=Oop [16]=Oop off=1232/0x4d0}
4d4 +   bgeu  R8, R30, B76	#@cmpU_branch  P=0.000001 C=-1.000000

4d8     B64: #	out( B59 B65 ) &lt;- in( B63 )  Freq: 0.000195333
4d8 +   addw  R7, R8, zr	#@convI2L_reg_reg
4dc +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
4e0 +   add R7, R31, R7	# ptr, #@addP_reg_reg
4e4 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN
4e8 +   decode_heap_oop  R12, R28	#@decodeHeapOop
4ec +   bne   R12, zr, B59	#@cmpP_imm0_branch  P=0.562112 C=13146.000000

4f0     B65: #	out( B51 ) &lt;- in( B64 )  Freq: 8.5534e-05
4f0 +   j  B51	#@branch

4f4     B66: #	out( B47 ) &lt;- in( B46 )  Freq: 5.48706e-05
4f4 +   li R8, #0	# int, #@loadConI
4f8 +   j  B47	#@branch

4fc     B67: #	out( B36 ) &lt;- in( B35 )  Freq: 4.27448e-05
4fc +   li R30, #0	# int, #@loadConI
500 +   j  B36	#@branch

504     B68: #	out( N851 ) &lt;- in( B25 )  Freq: 1.01327e-06
504 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
50c +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
514 +   li R11, #-28	# int, #@loadConI
518     spill R31 -&gt; [sp, #16]	# spill size = 64
51c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:18 (line 1009) L[0]=sp + #0 L[1]=sp + #8 L[2]=R8 L[3]=_ STK[0]=sp + #16 STK[1]=R8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=1312/0x520}
520     #@ShouldNotReachHere

52c     B69: #	out( N851 ) &lt;- in( B23 )  Freq: 9.99995e-07
52c +   li R11, #-122	# int, #@loadConI
530     spill R10 -&gt; R8	# spill size = 32
534     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;div0_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.Math::floorMod @ bci:2 (line 1342) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8 STK[1]=#0
        # java.util.ImmutableCollections$SetN::probe @ bci:9 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=1336/0x538}
538     #@ShouldNotReachHere

544     B70: #	out( B71 ) &lt;- in( B28 )  Freq: 5.69486e-07
544 +   spill R8 -&gt; R30	# spill size = 32

548     B71: #	out( B72 ) &lt;- in( B70 B40 )  Freq: 1.30052e-06
548 +   li R10, #1	# int, #@loadConI
54c     spill R30 -&gt; R8	# spill size = 32

550     B72: #	out( B73 ) &lt;- in( B71 B34 B84 )  Freq: 1.91192e-06
550 +   spill R10 -&gt; [sp, #0]	# spill size = 32

554     B73: #	out( N851 ) &lt;- in( B72 B90 )  Freq: 1.91201e-06
554 +   li R11, #-187	# int, #@loadConI
558     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:34 (line 1012) L[0]=sp + #8 L[1]=sp + #16 L[2]=R8 L[3]=_ STK[0]=sp + #0
        # OopMap {[8]=Oop [16]=Oop off=1372/0x55c}
55c     #@ShouldNotReachHere

568     B74: #	out( N851 ) &lt;- in( B32 B43 )  Freq: 1.30052e-06
568     #@ShouldNotReachHere

574     B75: #	out( B76 ) &lt;- in( B36 )  Freq: 5.69484e-07
574 +   spill R30 -&gt; R8	# spill size = 32

578     B76: #	out( N851 ) &lt;- in( B75 B47 B63 )  Freq: 1.30072e-06
578 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
580 +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
588 +   li R11, #-28	# int, #@loadConI
58c     spill R31 -&gt; [sp, #16]	# spill size = 64
590     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:18 (line 1009) L[0]=sp + #0 L[1]=sp + #8 L[2]=R8 L[3]=_ STK[0]=sp + #16 STK[1]=R8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=1428/0x594}
594     #@ShouldNotReachHere

5a0     B77: #	out( N851 ) &lt;- in( B31 )  Freq: 5.69485e-07
5a0     #@ShouldNotReachHere

5ac     B78: #	out( N851 ) &lt;- in( B8 )  Freq: 5.02177e-07
5ac +   li R11, #-138	# int, #@loadConI
5b0     spill R29 -&gt; [sp, #0]	# spill size = 64
5b4 +   spill R14 -&gt; [sp, #24]	# spill size = 64
5b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:13 (line 196) L[0]=_ L[1]=#0 L[2]=sp + #0 L[3]=R8 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=R8
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=sp + #24 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #8 L[1]=sp + #24 L[2]=_ L[3]=_
        # OopMap {[0]=Oop [8]=Oop [24]=Oop off=1468/0x5bc}
5bc     #@ShouldNotReachHere

5c8     B79: #	out( B16 ) &lt;- in( B9 )  Freq: 5.02176e-07
5c8 +   li R15, #1	# int, #@loadConI
5cc +   j  B16	#@branch

5d0     B80: #	out( N851 ) &lt;- in( B10 )  Freq: 4.95595e-07
5d0     #@ShouldNotReachHere

5dc     B81: #	out( N851 ) &lt;- in( B11 )  Freq: 4.95594e-07
5dc     #@ShouldNotReachHere

5e8     B82: #	out( B83 ) &lt;- in( B30 )  Freq: 2.81011e-07
5e8 +   spill R8 -&gt; R30	# spill size = 32

5ec     B83: #	out( N851 ) &lt;- in( B82 B42 )  Freq: 6.41739e-07
5ec +   spill [sp, #8] -&gt; R8	# spill size = 64
5f0 +   li R11, #-187	# int, #@loadConI
5f4     spill R30 -&gt; [sp, #8]	# spill size = 32
5f8 +   spill R12 -&gt; [sp, #16]	# spill size = 64
5fc +   spill R10 -&gt; [sp, #24]	# spill size = 64
600 +   spill R15 -&gt; [sp, #12]	# spill size = 32
604 +   spill R29 -&gt; [sp, #32]	# spill size = 32
608     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #16 L[1]=_ L[2]=sp + #24 STK[0]=sp + #12 STK[1]=sp + #32
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=R8 L[1]=sp + #16 L[2]=sp + #8 L[3]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop off=1548/0x60c}
60c     #@ShouldNotReachHere

618     B84: #	out( B72 ) &lt;- in( B45 )  Freq: 3.43673e-07
618 +   spill R30 -&gt; R8	# spill size = 32
61c +   j  B72	#@branch

620     B85: #	out( N851 ) &lt;- in( B5 )  Freq: 2.6252e-07
620 +   li R11, #-187	# int, #@loadConI
624     spill R14 -&gt; [sp, #16]	# spill size = 64
628     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=R8
        # java.lang.String::hashCode @ bci:17 (line 2337) L[0]=sp + #16 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #8 L[1]=sp + #16 L[2]=_ L[3]=_
        # OopMap {[8]=Oop [16]=Oop off=1580/0x62c}
62c     #@ShouldNotReachHere

638     B86: #	out( N851 ) &lt;- in( B17 )  Freq: 2.51088e-07
638     #@ShouldNotReachHere

644     B87: #	out( N851 ) &lt;- in( B18 )  Freq: 2.51087e-07
644     #@ShouldNotReachHere

650     B88: #	out( N851 ) &lt;- in( B52 )  Freq: 3.85778e-08
650 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
658 +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
660 +   li R11, #-187	# int, #@loadConI
664     spill R7 -&gt; [sp, #16]	# spill size = 32
668     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.Math::floorMod @ bci:11 (line 1344) L[0]=_ L[1]=sp + #16 L[2]=R8 STK[0]=R8
        # java.util.ImmutableCollections$SetN::probe @ bci:9 (line 1007) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=_
        # OopMap {[0]=Oop [8]=Oop off=1644/0x66c}
66c     #@ShouldNotReachHere

678     B89: #	out( B63 ) &lt;- in( B62 )  Freq: 1.48562e-08
678 +   li R8, #0	# int, #@loadConI
67c +   j  B63	#@branch

680     B90: #	out( B73 ) &lt;- in( B60 )  Freq: 9.31424e-11
680 +   spill R10 -&gt; [sp, #0]	# spill size = 32
684 +   j  B73	#@branch

688     B91: #	out( B92 ) &lt;- in( B29 )  Freq: 1e-35
688 +   spill R8 -&gt; R30	# spill size = 32

68c     B92: #	out( N851 ) &lt;- in( B91 B41 )  Freq: 1e-35
68c +   spill [sp, #8] -&gt; R8	# spill size = 64
690 +   li R11, #-34	# int, #@loadConI
694     spill R30 -&gt; [sp, #8]	# spill size = 32
698 +   spill R12 -&gt; [sp, #16]	# spill size = 64
69c +   spill R10 -&gt; [sp, #32]	# spill size = 64
6a0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #16 L[1]=sp + #32 L[2]=_ STK[0]=sp + #32
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=R8 L[1]=sp + #16 L[2]=sp + #8 L[3]=_
        # OopMap {fp=Oop [16]=Oop [32]=Oop off=1700/0x6a4}
6a4     #@ShouldNotReachHere

6b0     B93: #	out( N851 ) &lt;- in( B1 )  Freq: 1.01328e-06
6b0 +   li R11, #-10	# int, #@loadConI
6b4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # OopMap {off=1720/0x6b8}
6b8     #@ShouldNotReachHere

6c4     B94: #	out( N851 ) &lt;- in( B22 )  Freq: 1.01328e-06
6c4 +   li R11, #-10	# int, #@loadConI
6c8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:8 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=1740/0x6cc}
6cc     #@ShouldNotReachHere

6d8     B95: #	out( N851 ) &lt;- in( B6 )  Freq: 5.32012e-07
6d8 +   li R11, #-10	# int, #@loadConI
6dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:5 (line 196) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=_ L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=1760/0x6e0}
6e0     #@ShouldNotReachHere

6ec     B96: #	out( B98 ) &lt;- in( B56 )  Freq: 4.8834e-09
6ec      -- 	// exception oop; no code emitted, #@CreateException
6ec +   spill R10 -&gt; R11	# spill size = 64
6f0 +   j  B98	#@branch

6f4     B97: #	out( B98 ) &lt;- in( B59 )  Freq: 1.95338e-09
6f4      -- 	// exception oop; no code emitted, #@CreateException
6f4 +   spill R10 -&gt; R11	# spill size = 64

6f8     B98: #	out( N851 ) &lt;- in( B96 B97 )  Freq: 6.83678e-09
6f8     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
704 +   j rethrow_stub	#@RethrowException

70c     B99: #	out( N851 ) &lt;- in( B61 )  Freq: 1.97927e-10
70c +   li R11, #-10	# int, #@loadConI
710     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:47 (line 1014) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=1812/0x714}
714     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='398'>
----------------------- MetaData before Compile_id = 398 ------------------------
{method}
 - this oop:          0x00000040962b9ef8
 - method holder:     &apos;sun/nio/fs/UnixPath&apos;
 - constants:         0x00000040962b5440 constant pool [472] {0x00000040962b5440} for &apos;sun/nio/fs/UnixPath&apos; cache=0x00000040962ba1a0
 - access:            0x81001041  public volatile synthetic 
 - name:              &apos;getFileSystem&apos;
 - signature:         &apos;()Ljava/nio/file/FileSystem;&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      31
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4ff400
 - code size:         5
 - code start:        0x00000040962b9ee0
 - code end (excl):   0x00000040962b9ee5
 - method data:       0x0000004096483888
 - checked ex length: 0
 - linenumber start:  0x00000040962b9ee5
 - localvar length:   1
 - localvar start:    0x00000040962b9eea
 - compiled code: nmethod  16782  164       3       sun.nio.fs.UnixPath::getFileSystem (5 bytes)

------------------------ OptoAssembly for Compile_id = 398 -----------------------
#
#  sun/nio/fs/LinuxFileSystem * ( sun/nio/fs/UnixPath:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixPath:NotNull *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N16: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N16 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     lwu  R28, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
040 +   decode_heap_oop  R10, R28	#@decodeHeapOop
044     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
05c +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='399'>
----------------------- MetaData before Compile_id = 399 ------------------------
{method}
 - this oop:          0x00000040962e4308
 - method holder:     &apos;java/nio/file/Files&apos;
 - constants:         0x00000040962e1770 constant pool [1157]/operands[42] {0x00000040962e1770} for &apos;java/nio/file/Files&apos; cache=0x00000040962e97c0
 - access:            0x8100000a  private static 
 - name:              &apos;provider&apos;
 - signature:         &apos;(Ljava/nio/file/Path;)Ljava/nio/file/spi/FileSystemProvider;&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4ff840
 - code size:         10
 - code start:        0x00000040962e42e8
 - code end (excl):   0x00000040962e42f2
 - method data:       0x0000004096483a38
 - checked ex length: 0
 - linenumber start:  0x00000040962e42f2
 - localvar length:   1
 - localvar start:    0x00000040962e42fa
 - compiled code: nmethod  16821  165       3       java.nio.file.Files::provider (10 bytes)

------------------------ OptoAssembly for Compile_id = 399 -----------------------
#
#  sun/nio/fs/LinuxFileSystemProvider * ( java/nio/file/Path * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/nio/file/Path *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N1: #	out( B1 ) &lt;- in( B6 B5 B7 B4 )  Freq: 1

000     B1: #	out( B6 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
01c     lwu  R7, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
020     NullCheck R11

020     B2: #	out( B5 B3 ) &lt;- in( B1 )  Freq: 0.999999
020 +   mv  R29, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d05a8600:Constant:exact *	# compressed klass ptr, #@loadConNKlass
030 +   bne  R7, R29, B5	#@cmpN_branch  P=0.000001 C=-1.000000

034     B3: #	out( B7 B4 ) &lt;- in( B2 )  Freq: 0.999998
034 +   # checkcastPP of R11, #@checkCastPP
034     lwu  R7, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
038 +   decode_heap_oop  R7, R7	#@decodeHeapOop
03c     lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileSystem.provider
040     NullCheck R7

040     B4: #	out( N1 ) &lt;- in( B3 )  Freq: 0.999997
040 +   decode_heap_oop  R10, R28	#@decodeHeapOop
044     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
05c +   ret	// return register, #@Ret

060     B5: #	out( N1 ) &lt;- in( B2 )  Freq: 9.99999e-07
060 +   spill R11 -&gt; R8	# spill size = 64
064 +   li R11, #-34	# int, #@loadConI
068     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::provider @ bci:1 (line 105) L[0]=_ STK[0]=R8
        # OopMap {fp=Oop off=108/0x6c}
06c     #@ShouldNotReachHere

078     B6: #	out( N1 ) &lt;- in( B1 )  Freq: 1.01328e-06
078 +   li R11, #-10	# int, #@loadConI
07c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::provider @ bci:1 (line 105) L[0]=_ STK[0]=#NULL
        # OopMap {off=128/0x80}
080     #@ShouldNotReachHere

08c     B7: #	out( N1 ) &lt;- in( B3 )  Freq: 1.01328e-06
08c +   li R11, #-10	# int, #@loadConI
090     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::provider @ bci:6 (line 105) L[0]=_ STK[0]=#NULL
        # OopMap {off=148/0x94}
094 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='407'>
----------------------- MetaData before Compile_id = 407 ------------------------
{method}
 - this oop:          0x000000409611ffc8
 - method holder:     &apos;java/lang/Character&apos;
 - constants:         0x000000409611d860 constant pool [576] {0x000000409611d860} for &apos;java/lang/Character&apos; cache=0x00000040961e65e8
 - access:            0x81000009  public static 
 - name:              &apos;charCount&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         3
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b790: 0xa i2c: 0x00000040139d7540 c2i: 0x00000040139d7584 c2iUV: 0x00000040139d7550
 - compiled entry     0x000000400c4ef240
 - code size:         12
 - code start:        0x000000409611ffa8
 - code end (excl):   0x000000409611ffb4
 - method data:       0x00000040965eca50
 - checked ex length: 0
 - linenumber start:  0x000000409611ffb4
 - localvar length:   1
 - localvar start:    0x000000409611ffba
 - compiled code: nmethod  16867  115       3       java.lang.Character::charCount (12 bytes)

------------------------ OptoAssembly for Compile_id = 407 -----------------------
#
#  int ( int )
#
#r012 c_rarg1   : parm 0: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N1: #	out( B1 ) &lt;- in( B3 B2 )  Freq: 1

000     B1: #	out( B3 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
01c     li R7, #65536	# int, #@loadConI
020 +   bge  R11, R7, B3	#@cmpI_branch  P=0.000000 C=40191.000000

024     B2: #	out( N1 ) &lt;- in( B1 )  Freq: 1
024 +   li R10, #1	# int, #@loadConI
028     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
040 +   ret	// return register, #@Ret

044     B3: #	out( N1 ) &lt;- in( B1 )  Freq: 4.76837e-07
044 +   spill R11 -&gt; R8	# spill size = 32
048 +   li R11, #-187	# int, #@loadConI
04c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.Character::charCount @ bci:3 (line 8862) L[0]=_ STK[0]=R8 STK[1]=#65536
        # OopMap {off=80/0x50}
050 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='408'>
----------------------- MetaData before Compile_id = 408 ------------------------
{method}
 - this oop:          0x000000409600c1a8
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;substring&apos;
 - signature:         &apos;(I)Ljava/lang/String;&apos;
 - max stack:         4
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b960: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c5345c0
 - code size:         10
 - code start:        0x000000409600c178
 - code end (excl):   0x000000409600c182
 - method data:       0x000000409649aa40
 - checked ex length: 0
 - linenumber start:  0x000000409600c182
 - localvar length:   2
 - localvar start:    0x000000409600c18e
 - compiled code: nmethod  16891  249       3       java.lang.String::substring (10 bytes)

------------------------ OptoAssembly for Compile_id = 408 -----------------------
#
#  java/lang/String:exact * ( java/lang/String:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N110: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B12 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
040 +   spill R11 -&gt; R10	# spill size = 64
044 +   decode_heap_oop  R11, R7	#@decodeHeapOop
048     lwu  R28, [R11, #12]	# range, #@loadRange
04c     NullCheck R11

04c     B2: #	out( B8 B3 ) &lt;- in( B1 )  Freq: 0.999999
04c +   lb  R7, [R10, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
050 +   sraw  R8, R28, R7	#@rShiftI_reg_reg
054 +   blt  R12, zr, B8	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

058     B3: #	out( B9 B4 ) &lt;- in( B2 )  Freq: 0.999999
058 +   bgt  R12, R8, B9	#@cmpI_branch  P=0.000000 C=5375.000000

05c     B4: #	out( B7 B5 ) &lt;- in( B3 )  Freq: 0.999998
05c +   beq  R12, zr, B7	#@cmpI_reg_imm0_branch  P=0.372210 C=5376.000000

060     B5: #	out( B10 B6 ) &lt;- in( B4 )  Freq: 0.627789
060 +   subw  R13, R8, R12	#@subI_reg_reg
064 +   bne  R7, zr, B10	#@cmpI_reg_imm0_branch  P=0.000000 C=71048.000000

068     B6: #	out( B11 B7 ) &lt;- in( B5 )  Freq: 0.627789
068     CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringLatin1::newString
        # java.lang.String::substring @ bci:41 (line 2707) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # OopMap {off=108/0x6c}

06c     B7: #	out( N110 ) &lt;- in( B4 B6 )  Freq: 0.999985
06c     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
084 +   ret	// return register, #@Ret

088     B8: #	out( N110 ) &lt;- in( B2 )  Freq: 4.99999e-07
088 +   li R11, #-187	# int, #@loadConI
08c     spill R10 -&gt; [sp, #0]	# spill size = 64
090 +   spill R12 -&gt; [sp, #12]	# spill size = 32
094 +   spill R12 -&gt; [sp, #16]	# spill size = 32
098     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:1 (line 4598) L[0]=sp + #16 L[1]=R8 L[2]=R8 STK[0]=sp + #12
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #0 L[1]=sp + #12 L[2]=R8 L[3]=R8 L[4]=_
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # OopMap {[0]=Oop off=156/0x9c}
09c     #@ShouldNotReachHere

0a8     B9: #	out( N110 ) &lt;- in( B3 )  Freq: 4.76836e-07
0a8 +   li R11, #-187	# int, #@loadConI
0ac     spill R10 -&gt; [sp, #0]	# spill size = 64
0b0 +   spill R12 -&gt; [sp, #12]	# spill size = 32
0b4 +   spill R12 -&gt; [sp, #16]	# spill size = 32
0b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:6 (line 4598) L[0]=sp + #16 L[1]=R8 L[2]=R8 STK[0]=sp + #12 STK[1]=R8
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #0 L[1]=sp + #12 L[2]=R8 L[3]=R8 L[4]=_
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # OopMap {[0]=Oop off=188/0xbc}
0bc     #@ShouldNotReachHere

0c8     B10: #	out( N110 ) &lt;- in( B5 )  Freq: 3.13894e-07
0c8 +   li R11, #-187	# int, #@loadConI
0cc     spill R10 -&gt; R8	# spill size = 64
0d0 +   spill R12 -&gt; [sp, #0]	# spill size = 32
0d4 +   spill R13 -&gt; [sp, #4]	# spill size = 32
0d8 +   spill R7 -&gt; [sp, #8]	# spill size = 32
0dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #8
        # java.lang.String::substring @ bci:28 (line 2707) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=sp + #4
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=224/0xe0}
0e0     #@ShouldNotReachHere

0ec     B11: #	out( N110 ) &lt;- in( B6 )  Freq: 6.27789e-06
0ec      -- 	// exception oop; no code emitted, #@CreateException
0ec +   spill R10 -&gt; R11	# spill size = 64
0f0 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
0fc +   j rethrow_stub	#@RethrowException

104     B12: #	out( N110 ) &lt;- in( B1 )  Freq: 1.01328e-06
104 +   li R11, #-10	# int, #@loadConI
108     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::substring @ bci:3 (line 2675) L[0]=_ L[1]=_ STK[0]=_ STK[1]=_
        # OopMap {off=268/0x10c}
10c     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='429'>
----------------------- MetaData before Compile_id = 429 ------------------------
{method}
 - this oop:          0x000000409615df98
 - method holder:     &apos;java/util/Objects&apos;
 - constants:         0x000000409615d300 constant pool [151] {0x000000409615d300} for &apos;java/util/Objects&apos; cache=0x000000409615e9e0
 - access:            0x81000009  public static 
 - name:              &apos;requireNonNull&apos;
 - signature:         &apos;(Ljava/lang/Object;)Ljava/lang/Object;&apos;
 - max stack:         3
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4aeb40
 - code size:         14
 - code start:        0x000000409615df68
 - code end (excl):   0x000000409615df76
 - method data:       0x00000040963c4fb0
 - checked ex length: 0
 - linenumber start:  0x000000409615df76
 - localvar length:   1
 - localvar start:    0x000000409615df80
 - compiled code: nmethod  17219   11       3       java.util.Objects::requireNonNull (14 bytes)

------------------------ OptoAssembly for Compile_id = 429 -----------------------
#
#  java/lang/Object * ( java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/Object *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B3 B2 )  Freq: 1

000     B1: #	out( B3 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     spill R11 -&gt; R10	# spill size = 64
020 +   beq   R11, zr, B3	#@cmpP_imm0_branch  P=0.000000 C=24831.000000

024     B2: #	out( N1 ) &lt;- in( B1 )  Freq: 1
024     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
03c +   ret	// return register, #@Ret

040     B3: #	out( N1 ) &lt;- in( B1 )  Freq: 4.76837e-07
040 +   li R11, #-187	# int, #@loadConI
044     spill R10 -&gt; [sp, #0]	# spill size = 64
048     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.Objects::requireNonNull @ bci:1 (line 208) L[0]=sp + #0 STK[0]=sp + #0
        # OopMap {[0]=Oop off=76/0x4c}
04c +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='434'>
----------------------- MetaData before Compile_id = 434 ------------------------
{method}
 - this oop:          0x00000040962b9ce8
 - method holder:     &apos;sun/nio/fs/UnixPath&apos;
 - constants:         0x00000040962b5440 constant pool [472] {0x00000040962b5440} for &apos;sun/nio/fs/UnixPath&apos; cache=0x00000040962ba1a0
 - access:            0x81001041  public volatile synthetic 
 - name:              &apos;getParent&apos;
 - signature:         &apos;()Ljava/nio/file/Path;&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      19
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c530300
 - code size:         5
 - code start:        0x00000040962b9cd0
 - code end (excl):   0x00000040962b9cd5
 - method data:       0x0000004096498138
 - checked ex length: 0
 - linenumber start:  0x00000040962b9cd5
 - localvar length:   1
 - localvar start:    0x00000040962b9cda
 - compiled code: nmethod  17395  245       3       sun.nio.fs.UnixPath::getParent (5 bytes)

------------------------ OptoAssembly for Compile_id = 434 -----------------------
#
#  java/nio/file/Path * ( sun/nio/fs/UnixPath:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixPath:NotNull *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N376: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B39 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
03c     spill R11 -&gt; [sp, #0]	# spill size = 64
040     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 276) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # OopMap {[0]=Oop off=68/0x44}

044     B2: #	out( B33 B3 ) &lt;- in( B1 )  Freq: 0.99998
        # Block is sole successor of call
044 +   spill [sp, #0] -&gt; R7	# spill size = 64
048 +   lwu  R28, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
04c +   #@membar_acquire
	fence ir iorw
050 +   decode_heap_oop  R7, R28	#@decodeHeapOop
054     lwu  R29, [R7, #12]	# range, #@loadRange
058     NullCheck R7

058     B3: #	out( B32 B4 ) &lt;- in( B2 )  Freq: 0.999979
058 +   bleu  R29, zr, B32	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=5375.000000

05c     B4: #	out( B34 B5 ) &lt;- in( B3 )  Freq: 0.999978
05c +   spill [sp, #0] -&gt; R7	# spill size = 64
060 +   lwu  R7, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
064 +   decode_heap_oop  R30, R7	#@decodeHeapOop
068 +   addw  R28, R29, zr	#@convI2L_reg_reg
06c +   #@membar_acquire
	fence ir iorw
070 +   slli  R7, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
074 +   addiw  R8, R29, #-1	#@addI_reg_imm
078     lwu  R29, [R30, #12]	# range, #@loadRange
07c     NullCheck R30

07c     B5: #	out( B28 B6 ) &lt;- in( B4 )  Freq: 0.999977
07c +   add R7, R30, R7	# ptr, #@addP_reg_reg
080 +   bgeu  R8, R29, B28	#@cmpU_branch  P=0.000001 C=-1.000000

084     B6: #	out( B21 B7 ) &lt;- in( B5 )  Freq: 0.999976
084 +   lw  R8, [R7, #12]	# int, #@loadI
088 +   addiw  R28, R8, #-1	#@addI_reg_imm
08c +   ble  R28, zr, B21	#@cmpI_reg_imm0_branch  P=0.001488 C=5375.000000

090     B7: #	out( B29 B8 ) &lt;- in( B6 )  Freq: 0.998488
090 +   spill [sp, #0] -&gt; R7	# spill size = 64
094 +   lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
098 +   li R29, #1048576	# int, #@loadConI
09c +   decode_heap_oop  R31, R7	#@decodeHeapOop
0a0 +   bgtu  R28, R29, B29	#@cmpU_branch  P=0.000001 C=-1.000000

0a4     B8: #	out( B9 ) &lt;- in( B7 )  Freq: 0.998487
0a4 +   addw  R7, R8, zr	#@convI2L_reg_reg
0a8 +   addi  R7, R7, #-1	#@addL_reg_imm

0ac     B9: #	out( B35 B10 ) &lt;- in( B8 B29 )  Freq: 0.998488
0ac     lwu  R30, [R31, #12]	# range, #@loadRange
0b0     NullCheck R31

0b0     B10: #	out( B31 B11 ) &lt;- in( B9 )  Freq: 0.998487
0b0 +   addi  R10, R7, #23	#@addL_reg_imm
0b4 +   bltu  R30, R28, B31	#@cmpU_branch  P=0.000001 C=-1.000000

0b8     B11: #	out( B26 B12 ) &lt;- in( B10 )  Freq: 0.998486
0b8 +   andi  R12, R10, #-8	#@andL_reg_imm
0bc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0bc     bgtu  R28, R29, B26	#@cmpU_branch  P=0.000001 C=-1.000000

0c0     B12: #	out( B26 B13 ) &lt;- in( B11 )  Freq: 0.998485
0c0 +   ld  R9, [R23, #288]	# ptr, #@loadP
0c4 +   ld  R29, [R23, #304]	# ptr, #@loadP
0c8 +   add R7, R9, R12	# ptr, #@addP_reg_reg
0cc +   bgeu  R7, R29, B26	#@cmpP_branch  P=0.000100 C=-1.000000

0d0     B13: #	out( B14 ) &lt;- in( B12 )  Freq: 0.998385
0d0 +   sd  R7, [R23, #288]	# ptr, #@storeP
0d4 +   li R7, #1	# long, #@loadConL
0d8 +   mv  R29, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0e8 +   sd  R7, [R9]	# long, #@storeL
0ec +   sw  R29, [R9, #8]	# compressed klass ptr, #@storeNKlass
0f0 +   sw  R28, [R9, #12]	# int, #@storeI

0f4     B14: #	out( B30 B15 ) &lt;- in( B27 B13 )  Freq: 0.998486
0f4 +   srli  R7, R10, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
0f8     
0f8 +   # checkcastPP of R9, #@checkCastPP
0f8     encode_heap_oop  R10, R9	#@encodeHeapOop
0fc +   li R29, #1	# int, #@loadConI
100 +   # castII of R8, #@castII
100     addi  R11, R9, #16	# ptr, #@addP_reg_imm
104     spill R10 -&gt; [sp, #16]	# spill size = 32
108 +   beq  R8, R29, B30	#@cmpI_branch  P=0.000001 C=-1.000000

10c     B15: #	out( B23 B16 ) &lt;- in( B14 )  Freq: 0.998485
10c +   addiw  R30, R8, #-1	#@addI_reg_imm
110 +   addi  R10, R31, #16	# ptr, #@addP_reg_imm
114 +   blt  R30, R28, B23	#@cmpI_branch  P=0.001000 C=-1.000000

118     B16: #	out( B17 ) &lt;- in( B15 )  Freq: 0.997487
118 +   addi  R7, R12, #-16	#@addL_reg_imm
11c +   srli  R12, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
120 +   CALL, runtime leaf nofp 0x000000401396d840	#@CallLeafNoFPDirect jlong_disjoint_arraycopy
        No JVM State Info
        # 

124     B17: #	out( B24 B18 ) &lt;- in( B23 B16 B30 )  Freq: 0.998486
124     MEMBAR-store-store	#@membar_storestore
128 +   ld  R10, [R23, #288]	# ptr, #@loadP
12c +   ld  R7, [R23, #304]	# ptr, #@loadP
130 +   addi  R28, R10, #32	# ptr, #@addP_reg_imm
134 +   bgeu  R28, R7, B24	#@cmpP_branch  P=0.000100 C=-1.000000

138     B18: #	out( B19 ) &lt;- in( B17 )  Freq: 0.998386
138 +   li R7, #1	# long, #@loadConL
13c +   sd  R28, [R23, #288]	# ptr, #@storeP
140 +   sd  R7, [R10]	# long, #@storeL
144 +   mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d01ed460:Constant:exact *	# compressed klass ptr, #@loadConNKlass
154 +   sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
158 +   sw  zr, [R10, #12]	# int, #@storeimmI0
15c +   sw  zr, [R10, #16]	# int, #@storeimmI0
160 +   sd  zr, [R10, #24]	# long, #@storeimmL0

164     B19: #	out( B20 ) &lt;- in( B25 B18 )  Freq: 0.998486
164     spill [sp, #16] -&gt; R7	# spill size = 32
168 +   sw  R7, [R10, #20]	# compressed ptr, #@storeN
16c     
16c     spill [sp, #0] -&gt; R7	# spill size = 64
170 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
174 +   # checkcastPP of R10, #@checkCastPP
174     sw  R28, [R10, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixPath.fs
178 +   #@membar_release
	fence iorw ow

17c     B20: #	out( N376 ) &lt;- in( B22 B19 )  Freq: 0.999974
17c     # checkcastPP of R10, #@checkCastPP
17c     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
194 +   ret	// return register, #@Ret

198     B21: #	out( B38 B22 ) &lt;- in( B6 )  Freq: 0.00148835
198 +   spill [sp, #0] -&gt; R11	# spill size = 64
19c     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::getRoot
        # sun.nio.fs.UnixPath::getParent @ bci:32 (line 286) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # OopMap {off=416/0x1a0}

1a0     B22: #	out( B20 ) &lt;- in( B21 )  Freq: 0.00148832
        # Block is sole successor of call
1a0 +   j  B20	#@branch

1a4     B23: #	out( B17 ) &lt;- in( B15 )  Freq: 0.000998485
1a4 +   addw  R30, R8, zr	#@convI2L_reg_reg
1a8 +   addi  R28, R30, #15	#@addL_reg_imm
1ac +   srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
1b0 +   andi  R28, R28, #-8	#@andL_reg_imm
1b4 +   add R28, R9, R28	# ptr, #@addP_reg_reg
1b8 +   sub  R29, R7, R29	#@subL_reg_reg
1bc     ClearArray R29, R28	#@clearArray_reg_reg
214 +   addi  R12, R30, #-1	#@addL_reg_imm
218     CALL, runtime leaf nofp 0x000000401396cf00	#@CallLeafNoFPDirect arrayof_jbyte_disjoint_arraycopy
        No JVM State Info
        # 
21c +   j  B17	#@branch

220     B24: #	out( B36 B25 ) &lt;- in( B17 )  Freq: 9.98652e-05
220 +   mv  R11, precise klass sun/nio/fs/UnixPath: 0x00000040d01ed460:Constant:exact *	# ptr, #@loadConP
238     spill [sp, #0] -&gt; R8	# spill size = 64
23c +   spill R9 -&gt; [sp, #8]	# spill size = 64
240     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixPath::getParent @ bci:51 (line 290) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #8
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=NarrowOop off=580/0x244}

244     B25: #	out( B19 ) &lt;- in( B24 )  Freq: 9.98632e-05
        # Block is sole successor of call
244 +   j  B19	#@branch

248     B26: #	out( B37 B27 ) &lt;- in( B11 B12 )  Freq: 0.000100877
248 +   spill R12 -&gt; [sp, #32]	# spill size = 64
24c +   spill R10 -&gt; [sp, #24]	# spill size = 64
250 +   spill R31 -&gt; [sp, #16]	# spill size = 64
254 +   spill R28 -&gt; [sp, #8]	# spill size = 32
258 +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
270     spill R28 -&gt; R12	# spill size = 32
274     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=sp + #0 L[1]=_ L[2]=sp + #8 L[3]=_
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # OopMap {[0]=Oop [16]=Oop off=632/0x278}

278     B27: #	out( B14 ) &lt;- in( B26 )  Freq: 0.000100875
        # Block is sole successor of call
278 +   spill R10 -&gt; R9	# spill size = 64
27c +   spill [sp, #8] -&gt; R28	# spill size = 32
280 +   spill [sp, #16] -&gt; R31	# spill size = 64
284 +   spill [sp, #24] -&gt; R10	# spill size = 64
288 +   spill [sp, #32] -&gt; R12	# spill size = 64
28c +   j  B14	#@branch

290     B28: #	out( N376 ) &lt;- in( B5 )  Freq: 1.01326e-06
290 +   li R11, #-28	# int, #@loadConI
294     spill R30 -&gt; [sp, #8]	# spill size = 64
298     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:23 (line 283) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #8 STK[1]=R8
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # OopMap {[0]=Oop [8]=Oop off=668/0x29c}
29c     #@ShouldNotReachHere

2a8     B29: #	out( B9 ) &lt;- in( B7 )  Freq: 1.01175e-06
2a8 +   addw  R7, R28, zr	#@convI2L_reg_reg
2ac +   j  B9	#@branch

2b0     B30: #	out( B17 ) &lt;- in( B14 )  Freq: 1.01174e-06
2b0 +   spill R11 -&gt; R28	# spill size = 64
2b4 +   addi  R29, R7, #-2	#@addL_reg_imm
2b8     ClearArray R29, R28	#@clearArray_reg_reg
310     
310 +   j  B17	#@branch

314     B31: #	out( N376 ) &lt;- in( B10 )  Freq: 9.98487e-07
314 +   spill [sp, #0] -&gt; R8	# spill size = 64
318 +   li R11, #-52	# int, #@loadConI
31c     spill R28 -&gt; [sp, #4]	# spill size = 32
320     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=R8 L[1]=_ L[2]=sp + #4 L[3]=_ STK[0]=sp + #4
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # OopMap {fp=Oop off=804/0x324}
324     #@ShouldNotReachHere

330     B32: #	out( N376 ) &lt;- in( B3 )  Freq: 4.76827e-07
330 +   spill [sp, #0] -&gt; R8	# spill size = 64
334 +   li R11, #-187	# int, #@loadConI
338     spill R29 -&gt; [sp, #4]	# spill size = 32
33c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:11 (line 279) L[0]=R8 L[1]=sp + #4 L[2]=_ L[3]=_ STK[0]=sp + #4
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # OopMap {fp=Oop off=832/0x340}
340     #@ShouldNotReachHere

34c     B33: #	out( N376 ) &lt;- in( B2 )  Freq: 1.01326e-06
34c +   li R11, #-10	# int, #@loadConI
350     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:8 (line 278) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # OopMap {off=852/0x354}
354     #@ShouldNotReachHere

360     B34: #	out( N376 ) &lt;- in( B4 )  Freq: 1.01326e-06
360 +   li R11, #-10	# int, #@loadConI
364     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:23 (line 283) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # OopMap {off=872/0x368}
368     #@ShouldNotReachHere

374     B35: #	out( N376 ) &lt;- in( B9 )  Freq: 1.01175e-06
374 +   spill [sp, #0] -&gt; R8	# spill size = 64
378 +   li R11, #-12	# int, #@loadConI
37c     spill R28 -&gt; [sp, #4]	# spill size = 32
380     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=R8 L[1]=_ L[2]=sp + #4 L[3]=_ STK[0]=sp + #4
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # OopMap {fp=Oop off=900/0x384}
384     #@ShouldNotReachHere

390     B36: #	out( B40 ) &lt;- in( B24 )  Freq: 9.98652e-10
390      -- 	// exception oop; no code emitted, #@CreateException
390 +   spill R10 -&gt; R11	# spill size = 64
394 +   j  B40	#@branch

398     B37: #	out( B40 ) &lt;- in( B26 )  Freq: 1.00877e-09
398      -- 	// exception oop; no code emitted, #@CreateException
398 +   spill R10 -&gt; R11	# spill size = 64
39c +   j  B40	#@branch

3a0     B38: #	out( B40 ) &lt;- in( B21 )  Freq: 1.48835e-08
3a0      -- 	// exception oop; no code emitted, #@CreateException
3a0 +   spill R10 -&gt; R11	# spill size = 64
3a4 +   j  B40	#@branch

3a8     B39: #	out( B40 ) &lt;- in( B1 )  Freq: 1e-05
3a8      -- 	// exception oop; no code emitted, #@CreateException
3a8 +   spill R10 -&gt; R11	# spill size = 64

3ac     B40: #	out( N376 ) &lt;- in( B39 B38 B37 B36 )  Freq: 1.00169e-05
3ac     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
3b8 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='435'>
----------------------- MetaData before Compile_id = 435 ------------------------
{method}
 - this oop:          0x000000409600cb30
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0xc1000001  public 
 - name:              &apos;replace&apos;
 - signature:         &apos;(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Ljava/lang/String;&apos;
 - max stack:         10
 - max locals:        12
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x00000040083172b0: 0xbbb i2c: 0x0000004013944dc0 c2i: 0x0000004013944e0c c2iUV: 0x0000004013944dd8
 - compiled entry     0x000000400c539700
 - code size:         258
 - code start:        0x000000409600c928
 - code end (excl):   0x000000409600ca2a
 - method data:       0x000000409649b648
 - checked ex length: 0
 - linenumber start:  0x000000409600ca2a
 - localvar length:   17
 - localvar start:    0x000000409600ca58
 - compiled code: nmethod  17481  254   !   3       java.lang.String::replace (258 bytes)

------------------------ OptoAssembly for Compile_id = 435 -----------------------
#
#  java/lang/String:exact * ( java/lang/String:NotNull:exact *, java/lang/CharSequence *, java/lang/CharSequence * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/CharSequence *
#r016 c_rarg3:c_rarg3   : parm 2: java/lang/CharSequence *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N331: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B33 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
03c     spill R11 -&gt; [sp, #0]	# spill size = 64
040     lwu  R7, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
044     NullCheck R12

044     B2: #	out( B21 B3 ) &lt;- in( B1 )  Freq: 0.999999
044 +   mv  R29, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
054 +   bne  R7, R29, B21	#@cmpN_branch  P=0.000001 C=-1.000000

058     B3: #	out( B34 B4 ) &lt;- in( B2 )  Freq: 0.999998
058 +   # checkcastPP of R12, #@checkCastPP
058     lwu  R7, [R13, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
05c     NullCheck R13

05c     B4: #	out( B22 B5 ) &lt;- in( B3 )  Freq: 0.999997
05c +   bne  R7, R29, B22	#@cmpN_branch  P=0.000001 C=-1.000000

060     B5: #	out( B35 B6 ) &lt;- in( B4 )  Freq: 0.999996
060 +   lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
064 +   lwu  R28, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
068 +   # checkcastPP of R13, #@checkCastPP
068     lwu  R29, [R13, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
06c +   decode_heap_oop  R11, R7	#@decodeHeapOop
070 +   decode_heap_oop  R30, R28	#@decodeHeapOop
074 +   decode_heap_oop  R29, R29	#@decodeHeapOop
078     lwu  R28, [R11, #12]	# range, #@loadRange
07c     NullCheck R11

07c     B6: #	out( B36 B7 ) &lt;- in( B5 )  Freq: 0.999995
07c +   spill [sp, #0] -&gt; R7	# spill size = 64
080 +   lb  R10, [R7, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
084 +   sraw  R15, R28, R10	#@rShiftI_reg_reg
088     lwu  R28, [R30, #12]	# range, #@loadRange
08c     NullCheck R30

08c     B7: #	out( B37 B8 ) &lt;- in( B6 )  Freq: 0.999994
08c +   lb  R31, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
090 +   sraw  R14, R28, R31	#@rShiftI_reg_reg
094     lwu  R16, [R29, #12]	# range, #@loadRange
098     NullCheck R29

098     B8: #	out( B23 B9 ) &lt;- in( B7 )  Freq: 0.999993
098 +   lb  R9, [R13, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
09c +   sraw  R8, R16, R9	#@rShiftI_reg_reg
0a0 +   li R7, #1	# int, #@loadConI
0a4 +   ble  R14, zr, B23	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

0a8     B9: #	out( B24 B10 ) &lt;- in( B8 )  Freq: 0.999992
0a8 +   bne  R14, R7, B24	#@cmpI_branch  P=0.000000 C=5375.000000

0ac     B10: #	out( B25 B11 ) &lt;- in( B9 )  Freq: 0.999992
0ac +   bne  R8, R7, B25	#@cmpI_branch  P=0.000000 C=5375.000000

0b0     B11: #	out( B26 B12 ) &lt;- in( B10 )  Freq: 0.999991
0b0 +   bne  R31, zr, B26	#@cmpI_reg_imm0_branch  P=0.000000 C=74703.000000

0b4     B12: #	out( B29 B13 ) &lt;- in( B11 )  Freq: 0.999991
0b4 +   bleu  R28, zr, B29	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=37812.000000

0b8     B13: #	out( B27 B14 ) &lt;- in( B12 )  Freq: 0.999991
0b8 +   lbu  R12, [R30, #16]	# byte, #@loadUB
0bc +   bne  R9, zr, B27	#@cmpI_reg_imm0_branch  P=0.000000 C=74703.000000

0c0     B14: #	out( B30 B15 ) &lt;- in( B13 )  Freq: 0.99999
0c0 +   bleu  R16, zr, B30	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=37812.000000

0c4     B15: #	out( B31 B16 ) &lt;- in( B14 )  Freq: 0.99999
0c4 +   lbu  R13, [R29, #16]	# byte, #@loadUB
0c8 +   beq  R12, R13, B31	#@cmpI_branch  P=0.000000 C=5376.000000

0cc     B16: #	out( B28 B17 ) &lt;- in( B15 )  Freq: 0.999989
0cc +   bne  R10, zr, B28	#@cmpI_reg_imm0_branch  P=0.000000 C=74703.000000

0d0     B17: #	out( B32 B18 ) &lt;- in( B16 )  Freq: 0.999989
0d0     CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringLatin1::replace
        # java.lang.String::replace @ bci:18 (line 2801) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # java.lang.String::replace @ bci:63 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # OopMap {[0]=Oop off=212/0xd4}

0d4     B18: #	out( B20 B19 ) &lt;- in( B17 )  Freq: 0.999969
        # Block is sole successor of call
0d4 +   beq   R10, zr, B20	#@cmpP_imm0_branch  P=0.000744 C=5376.000000

0d8     B19: #	out( N331 ) &lt;- in( B18 B20 )  Freq: 0.999969
0d8     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0f0 +   ret	// return register, #@Ret

0f4     B20: #	out( B19 ) &lt;- in( B18 )  Freq: 0.000744021
0f4 +   spill [sp, #0] -&gt; R10	# spill size = 64
0f8 +   j  B19	#@branch

0fc     B21: #	out( N331 ) &lt;- in( B2 )  Freq: 9.99999e-07
0fc +   spill [sp, #0] -&gt; R8	# spill size = 64
100 +   li R11, #-34	# int, #@loadConI
104     spill R13 -&gt; [sp, #0]	# spill size = 64
108 +   spill R12 -&gt; [sp, #8]	# spill size = 64
10c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::replace @ bci:1 (line 2953) L[0]=R8 L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=272/0x110}
110     #@ShouldNotReachHere

11c     B22: #	out( N331 ) &lt;- in( B4 )  Freq: 9.99997e-07
11c +   spill [sp, #0] -&gt; R8	# spill size = 64
120 +   li R11, #-34	# int, #@loadConI
124     spill R12 -&gt; [sp, #0]	# spill size = 64
128 +   spill R13 -&gt; [sp, #8]	# spill size = 64
12c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::replace @ bci:8 (line 2954) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=304/0x130}
130     #@ShouldNotReachHere

13c     B23: #	out( N331 ) &lt;- in( B8 )  Freq: 4.99996e-07
13c +   li R11, #-187	# int, #@loadConI
140     spill R12 -&gt; [sp, #8]	# spill size = 64
144 +   spill R13 -&gt; [sp, #16]	# spill size = 64
148 +   spill R15 -&gt; [sp, #24]	# spill size = 32
14c +   spill R14 -&gt; [sp, #32]	# spill size = 32
150     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:36 (line 2959) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=sp + #8 L[4]=sp + #16 L[5]=sp + #24 L[6]=sp + #32 L[7]=R8 L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=sp + #32
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=340/0x154}
154     #@ShouldNotReachHere

160     B24: #	out( N331 ) &lt;- in( B9 )  Freq: 4.99996e-07
160 +   li R11, #-187	# int, #@loadConI
164     spill R12 -&gt; [sp, #8]	# spill size = 64
168 +   spill R13 -&gt; [sp, #16]	# spill size = 64
16c +   spill R15 -&gt; [sp, #24]	# spill size = 32
170 +   spill R14 -&gt; [sp, #32]	# spill size = 32
174     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:42 (line 2960) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=sp + #8 L[4]=sp + #16 L[5]=sp + #24 L[6]=sp + #32 L[7]=R8 L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=sp + #32 STK[1]=#1
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=376/0x178}
178     #@ShouldNotReachHere

184     B25: #	out( N331 ) &lt;- in( B10 )  Freq: 4.99996e-07
184 +   li R11, #-187	# int, #@loadConI
188     spill R12 -&gt; [sp, #8]	# spill size = 64
18c +   spill R13 -&gt; [sp, #16]	# spill size = 64
190 +   spill R15 -&gt; [sp, #24]	# spill size = 32
194     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:48 (line 2960) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=sp + #8 L[4]=sp + #16 L[5]=sp + #24 L[6]=#1 L[7]=R8 L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=R8 STK[1]=#1
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=408/0x198}
198     #@ShouldNotReachHere

1a4     B26: #	out( N331 ) &lt;- in( B11 )  Freq: 4.99996e-07
1a4 +   li R11, #-187	# int, #@loadConI
1a8     spill R13 -&gt; R8	# spill size = 64
1ac +   spill R12 -&gt; [sp, #8]	# spill size = 64
1b0 +   spill R31 -&gt; [sp, #16]	# spill size = 32
1b4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #16
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=sp + #8 L[1]=#0
        # java.lang.String::replace @ bci:54 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=440/0x1b8}
1b8     #@ShouldNotReachHere

1c4     B27: #	out( N331 ) &lt;- in( B13 )  Freq: 4.99995e-07
1c4 +   spill [sp, #0] -&gt; R8	# spill size = 64
1c8 +   li R11, #-187	# int, #@loadConI
1cc     spill R13 -&gt; [sp, #0]	# spill size = 64
1d0 +   spill R12 -&gt; [sp, #8]	# spill size = 32
1d4 +   spill R9 -&gt; [sp, #12]	# spill size = 32
1d8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #12
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=sp + #0 L[1]=#0
        # java.lang.String::replace @ bci:60 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=R8 STK[1]=sp + #8
        # OopMap {fp=Oop [0]=Oop off=476/0x1dc}
1dc     #@ShouldNotReachHere

1e8     B28: #	out( N331 ) &lt;- in( B16 )  Freq: 4.99995e-07
1e8 +   spill [sp, #0] -&gt; R8	# spill size = 64
1ec +   li R11, #-187	# int, #@loadConI
1f0     spill R12 -&gt; [sp, #0]	# spill size = 32
1f4 +   spill R13 -&gt; [sp, #4]	# spill size = 32
1f8 +   spill R10 -&gt; [sp, #8]	# spill size = 32
1fc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #8
        # java.lang.String::replace @ bci:6 (line 2801) L[0]=R8 L[1]=sp + #0 L[2]=sp + #4 L[3]=_
        # java.lang.String::replace @ bci:63 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # OopMap {fp=Oop off=512/0x200}
200     #@ShouldNotReachHere

20c     B29: #	out( N331 ) &lt;- in( B12 )  Freq: 4.76833e-07
20c +   li R11, #-187	# int, #@loadConI
210     spill R13 -&gt; R8	# spill size = 64
214 +   spill R30 -&gt; [sp, #8]	# spill size = 64
218 +   spill R28 -&gt; [sp, #16]	# spill size = 32
21c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:7 (line 47) L[0]=sp + #8 L[1]=#0 STK[0]=#0 STK[1]=sp + #16
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.String::replace @ bci:54 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=544/0x220}
220     #@ShouldNotReachHere

22c     B30: #	out( N331 ) &lt;- in( B14 )  Freq: 4.76832e-07
22c +   spill [sp, #0] -&gt; R8	# spill size = 64
230 +   li R11, #-187	# int, #@loadConI
234     spill R12 -&gt; [sp, #0]	# spill size = 32
238 +   spill R29 -&gt; [sp, #8]	# spill size = 64
23c +   spill R16 -&gt; [sp, #4]	# spill size = 32
240     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:7 (line 47) L[0]=sp + #8 L[1]=#0 STK[0]=#0 STK[1]=sp + #4
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.String::replace @ bci:60 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=R8 STK[1]=sp + #0
        # OopMap {fp=Oop [8]=Oop off=580/0x244}
244     #@ShouldNotReachHere

250     B31: #	out( N331 ) &lt;- in( B15 )  Freq: 4.76832e-07
250 +   li R11, #-187	# int, #@loadConI
254     spill [sp, #0] -&gt; R8	# spill size = 64
258 +   spill R12 -&gt; [sp, #8]	# spill size = 32
25c +   spill R13 -&gt; [sp, #12]	# spill size = 32
260     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:2 (line 2800) L[0]=R8 L[1]=sp + #8 L[2]=sp + #12 L[3]=_ STK[0]=sp + #8 STK[1]=sp + #12
        # java.lang.String::replace @ bci:63 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # OopMap {fp=Oop off=612/0x264}
264     #@ShouldNotReachHere

270     B32: #	out( N331 ) &lt;- in( B17 )  Freq: 9.99989e-06
270      -- 	// exception oop; no code emitted, #@CreateException
270 +   spill R10 -&gt; R11	# spill size = 64
274 +   # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
280 +   j rethrow_stub	#@RethrowException

288     B33: #	out( N331 ) &lt;- in( B1 )  Freq: 1.01328e-06
288 +   spill [sp, #0] -&gt; R8	# spill size = 64
28c +   li R11, #-10	# int, #@loadConI
290     spill R13 -&gt; [sp, #0]	# spill size = 64
294     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::replace @ bci:1 (line 2953) L[0]=R8 L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=#NULL
        # OopMap {fp=Oop [0]=Oop off=664/0x298}
298     #@ShouldNotReachHere

2a4     B34: #	out( N331 ) &lt;- in( B3 )  Freq: 1.01328e-06
2a4 +   spill [sp, #0] -&gt; R8	# spill size = 64
2a8 +   li R11, #-10	# int, #@loadConI
2ac     spill R12 -&gt; [sp, #0]	# spill size = 64
2b0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::replace @ bci:8 (line 2954) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=#NULL
        # OopMap {fp=Oop [0]=Oop off=692/0x2b4}
2b4     #@ShouldNotReachHere

2c0     B35: #	out( N331 ) &lt;- in( B5 )  Freq: 1.01327e-06
2c0 +   spill [sp, #0] -&gt; R8	# spill size = 64
2c4 +   li R11, #-10	# int, #@loadConI
2c8     spill R12 -&gt; [sp, #0]	# spill size = 64
2cc +   spill R13 -&gt; [sp, #8]	# spill size = 64
2d0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::replace @ bci:16 (line 2955) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=sp + #8 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=724/0x2d4}
2d4     #@ShouldNotReachHere

2e0     B36: #	out( N331 ) &lt;- in( B6 )  Freq: 1.01327e-06
2e0 +   li R11, #-10	# int, #@loadConI
2e4     spill R7 -&gt; R8	# spill size = 64
2e8 +   spill R12 -&gt; [sp, #0]	# spill size = 64
2ec +   spill R13 -&gt; [sp, #8]	# spill size = 64
2f0 +   spill R15 -&gt; [sp, #16]	# spill size = 32
2f4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::replace @ bci:22 (line 2956) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=sp + #8 L[5]=sp + #16 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=760/0x2f8}
2f8     #@ShouldNotReachHere

304     B37: #	out( N331 ) &lt;- in( B7 )  Freq: 1.01327e-06
304 +   li R11, #-10	# int, #@loadConI
308     spill R7 -&gt; R8	# spill size = 64
30c +   spill R12 -&gt; [sp, #0]	# spill size = 64
310 +   spill R13 -&gt; [sp, #8]	# spill size = 64
314 +   spill R15 -&gt; [sp, #16]	# spill size = 32
318 +   spill R14 -&gt; [sp, #20]	# spill size = 32
31c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::replace @ bci:29 (line 2957) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=sp + #8 L[5]=sp + #16 L[6]=sp + #20 L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=800/0x320}
320     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='436'>
----------------------- MetaData before Compile_id = 436 ------------------------
{method}
 - this oop:          0x000000409633a4f0
 - method holder:     &apos;java/util/Optional&apos;
 - constants:         0x0000004096339bb0 constant pool [185] {0x0000004096339bb0} for &apos;java/util/Optional&apos; cache=0x000000409633b518
 - access:            0x81000009  public static 
 - name:              &apos;of&apos;
 - signature:         &apos;(Ljava/lang/Object;)Ljava/util/Optional;&apos;
 - max stack:         4
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c535280
 - code size:         12
 - code start:        0x000000409633a4c8
 - code end (excl):   0x000000409633a4d4
 - method data:       0x000000409649ad98
 - checked ex length: 0
 - linenumber start:  0x000000409633a4d4
 - localvar length:   1
 - localvar start:    0x000000409633a4e0
 - compiled code: nmethod  17520  251       3       java.util.Optional::of (12 bytes)

------------------------ OptoAssembly for Compile_id = 436 -----------------------
#
#  java/util/Optional:exact * ( java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/Object *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B13 B6 B14 )  Freq: 1

000     B1: #	out( B11 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
01c      -- 	// R23=Thread::current(), empty, #@tlsLoadP
01c     ld  R9, [R23, #288]	# ptr, #@loadP
020 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
020     ld  R7, [R23, #304]	# ptr, #@loadP
024 +   addi  R28, R9, #16	# ptr, #@addP_reg_imm
028     spill R11 -&gt; R8	# spill size = 64
02c +   bgeu  R28, R7, B11	#@cmpP_branch  P=0.000100 C=-1.000000

030     B2: #	out( B3 ) &lt;- in( B1 )  Freq: 0.9999
030 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
030     sd  R28, [R23, #288]	# ptr, #@storeP
034 +   li R7, #1	# long, #@loadConL
038 +   mv  R28, narrowklass: precise klass java/util/Optional: 0x00000040d021d540:Constant:exact *	# compressed klass ptr, #@loadConNKlass
048 +   sd  R7, [R9]	# long, #@storeL
04c +   sw  R28, [R9, #8]	# compressed klass ptr, #@storeNKlass
050 +   sw  zr, [R9, #12]	# int, #@storeimmI0

054     B3: #	out( B13 B4 ) &lt;- in( B12 B2 )  Freq: 1
054     
054     spill R8 -&gt; R29	# spill size = 64
058 +   # checkcastPP of R9, #@checkCastPP
058     beq   R29, zr, B13	#@cmpP_imm0_branch  P=0.000000 C=24948.000000

05c     B4: #	out( B6 B5 ) &lt;- in( B3 )  Freq: 1
05c +   mv  R7, R9	# ptr -&gt; long, #@castP2X
060 +   mv  R28, R29	# ptr -&gt; long, #@castP2X
064 +   xorr  R28, R28, R7	#@xorL_reg_reg
068 +   encode_heap_oop  R29, R29	#@encodeHeapOop
06c +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
070 +   sw  R29, [R9, #12]	# compressed ptr, #@storeN ! Field: java/util/Optional.value
074 +   beq  R28, zr, B6	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

078     B5: #	out( B7 B6 ) &lt;- in( B4 )  Freq: 0.999
078 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
07c +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
088 +   add R10, R28, R7	# ptr, #@addP_reg_reg
08c +   lb  R28, [R10]	# byte, #@loadB
090 +   li R7, #4	# int, #@loadConI
094 +   bne  R28, R7, B7	#@cmpI_branch  P=0.001000 C=-1.000000

098     B6: #	out( N1 ) &lt;- in( B9 B10 B7 B5 B4 )  Freq: 1
098 +   #@membar_release
	fence iorw ow
09c +   spill R9 -&gt; R10	# spill size = 64
0a0 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0b8 +   ret	// return register, #@Ret

0bc     B7: #	out( B6 B8 ) &lt;- in( B5 )  Freq: 0.000999
0bc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0bc     ld  R7, [R23, #64]	# int, #@loadL
0c0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c0     ld  R28, [R23, #80]	# ptr, #@loadP
0c4 +   #@membar_volatile
	fence iorw iorw
0c8 +   lb  R30, [R10]	# byte, #@loadB
0cc +   beq  R30, zr, B6	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

0d0     B8: #	out( B10 B9 ) &lt;- in( B7 )  Freq: 0.0004995
0d0 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
0d4 +   bne  R7, zr, B10	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

0d8     B9: #	out( B6 ) &lt;- in( B8 )  Freq: 0.00024975
0d8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0d8     spill R23 -&gt; R11	# spill size = 64
0dc +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
10c +   j  B6	#@branch

110     B10: #	out( B6 ) &lt;- in( B8 )  Freq: 0.00024975
110 +   add R28, R28, R7	# ptr, #@addP_reg_reg
114 +   addi  R7, R7, #-8	#@addL_reg_imm
118 +   sd  R10, [R28, #-8]	# ptr, #@storeP
11c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
11c     sd  R7, [R23, #64]	# long, #@storeL
120 +   j  B6	#@branch

124     B11: #	out( B14 B12 ) &lt;- in( B1 )  Freq: 0.000100017
124 +   mv  R11, precise klass java/util/Optional: 0x00000040d021d540:Constant:exact *	# ptr, #@loadConP
13c     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.Optional::of @ bci:0 (line 113) L[0]=R8
        # OopMap {fp=Oop off=320/0x140}

140     B12: #	out( B3 ) &lt;- in( B11 )  Freq: 0.000100015
        # Block is sole successor of call
140 +   spill R10 -&gt; R9	# spill size = 64
144 +   j  B3	#@branch

148     B13: #	out( N1 ) &lt;- in( B3 )  Freq: 4.76837e-07
148 +   li R11, #-187	# int, #@loadConI
14c     spill R9 -&gt; [sp, #0]	# spill size = 64
150 +   spill R29 -&gt; [sp, #16]	# spill size = 64
154     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.Objects::requireNonNull @ bci:1 (line 208) L[0]=sp + #16 STK[0]=sp + #16
        # java.util.Optional::of @ bci:5 (line 113) L[0]=_ STK[0]=sp + #0 STK[1]=sp + #0
        # OopMap {[0]=Oop [16]=Oop off=344/0x158}
158     #@ShouldNotReachHere

164     B14: #	out( N1 ) &lt;- in( B11 )  Freq: 1.00017e-09
164      -- 	// exception oop; no code emitted, #@CreateException
164 +   spill R10 -&gt; R11	# spill size = 64
168 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
174 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='438'>
----------------------- MetaData before Compile_id = 438 ------------------------
{method}
 - this oop:          0x00000040961fb118
 - method holder:     &apos;java/io/BufferedInputStream&apos;
 - constants:         0x00000040961fa4f0 constant pool [155] {0x00000040961fa4f0} for &apos;java/io/BufferedInputStream&apos; cache=0x00000040961fc6e8
 - access:            0x81000021  public synchronized 
 - name:              &apos;read&apos;
 - signature:         &apos;()I&apos;
 - max stack:         6
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      7
 - i2i entry:         0x00000040138cd040
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c505cc0
 - code size:         49
 - code start:        0x00000040961fb0c8
 - code end (excl):   0x00000040961fb0f9
 - method data:       0x0000004096486b50
 - checked ex length: 1
 - checked ex start:  0x00000040961fb114
 - linenumber start:  0x00000040961fb0f9
 - localvar length:   1
 - localvar start:    0x00000040961fb106
 - compiled code: nmethod  17616  175  s    3       java.io.BufferedInputStream::read (49 bytes)

------------------------ OptoAssembly for Compile_id = 438 -----------------------
#
#  int ( java/io/BufferedInputStream:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/io/BufferedInputStream:NotNull *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: Fixed slot 3
#r258 sp+24: Fixed slot 2
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N231: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B12 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     add R29, sp, #16	# box lock
040 +   fastlock R11,R29	! kills R28,R7, #@cmpFastLock
0d4 +   spill R11 -&gt; [sp, #0]	# spill size = 64
0d8 +   far_bne RFLAGS, zr, B12	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

0e0     B2: #	out( B7 B3 ) &lt;- in( B12 B1 )  Freq: 1
0e0 +   #@membar_acquire_lock (elided)
0e0 +   spill [sp, #0] -&gt; R7	# spill size = 64
0e4 +   lw  R28, [R7, #20]	# int, #@loadI ! Field: java/io/BufferedInputStream.pos
0e8 +   lw  R7, [R7, #16]	# int, #@loadI ! Field: java/io/BufferedInputStream.count
0ec +   bge  R28, R7, B7	#@cmpI_branch  P=0.004651 C=5375.000000

0f0     B3: #	out( B15 B4 ) &lt;- in( B8 B2 )  Freq: 0.997674
0f0 +   spill [sp, #0] -&gt; R7	# spill size = 64
0f4 +   lwu  R28, [R7, #32]	# loadN, compressed ptr, #@loadN ! Field: volatile java/io/BufferedInputStream.buf
0f8 +   #@membar_acquire
	fence ir iorw
0fc +   lw  R31, [R7, #20]	# int, #@loadI ! Field: java/io/BufferedInputStream.pos
100 +   decode_heap_oop  R8, R28	#@decodeHeapOop
104     lwu  R7, [R8, #12]	# range, #@loadRange
108     NullCheck R8

108     B4: #	out( B11 B5 ) &lt;- in( B3 )  Freq: 0.997674
108 +   addiw  R29, R31, #1	#@addI_reg_imm
10c     spill [sp, #0] -&gt; R28	# spill size = 64
110 +   sw  R29, [R28, #20]	# int, #@storeI ! Field: java/io/BufferedInputStream.pos
114 +   bgeu  R31, R7, B11	#@cmpU_branch  P=0.000001 C=-1.000000

118     B5: #	out( B13 B6 ) &lt;- in( B4 )  Freq: 0.997673
118 +   addw  R7, R31, zr	#@convI2L_reg_reg
11c +   add R7, R8, R7	# ptr, #@addP_reg_reg
120 +   lbu  R9, [R7, #16]	# byte, #@loadUB
124 +   #@membar_release_lock (elided)
124     add R29, sp, #16	# box lock
128 +   spill [sp, #0] -&gt; R30	# spill size = 64
12c +   fastunlock R30,R29	! kills R28, R7, #@cmpFastUnlock
1a4 +   far_bne RFLAGS, zr, B13	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

1ac     B6: #	out( N231 ) &lt;- in( B10 B13 B5 )  Freq: 0.999998
1ac +   spill R9 -&gt; R10	# spill size = 32
1b0 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
1c8 +   ret	// return register, #@Ret

1cc     B7: #	out( B16 B8 ) &lt;- in( B2 )  Freq: 0.00465119
1cc +   spill [sp, #0] -&gt; R11	# spill size = 64
1d0 +   spill R11 -&gt; R8	# spill size = 64
1d4     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.io.BufferedInputStream::fill
        # java.io.BufferedInputStream::read @ bci:12 (line 263) L[0]=R8 MON-BOX0=sp+16 MON-OBJ[0]=R8
        # OopMap {fp=Oop [0]=Oop off=472/0x1d8}

1d8     B8: #	out( B3 B9 ) &lt;- in( B7 )  Freq: 0.0046511
        # Block is sole successor of call
1d8 +   lw  R28, [R8, #20]	# int, #@loadI ! Field: java/io/BufferedInputStream.pos
1dc +   lw  R7, [R8, #16]	# int, #@loadI ! Field: java/io/BufferedInputStream.count
1e0 +   blt  R28, R7, B3	#@cmpI_branch  P=0.500000 C=-1.000000

1e4     B9: #	out( B14 B10 ) &lt;- in( B8 )  Freq: 0.00232555
1e4 +   #@membar_release_lock (elided)
1e4     add R29, sp, #16	# box lock
1e8 +   fastunlock R8,R29	! kills R28, R7, #@cmpFastUnlock
260 +   far_bne RFLAGS, zr, B14	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

268     B10: #	out( B6 ) &lt;- in( B14 B9 )  Freq: 0.00232555
268 +   li R9, #-1	# int, #@loadConI
26c +   j  B6	#@branch

270     B11: #	out( N231 ) &lt;- in( B4 )  Freq: 1.01092e-06
270 +   li R11, #-28	# int, #@loadConI
274     spill R31 -&gt; [sp, #8]	# spill size = 32
278     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.io.BufferedInputStream::read @ bci:43 (line 267) L[0]=_ STK[0]=R8 STK[1]=sp + #8 MON-BOX0=sp+16 MON-OBJ[0]=sp + #0
        # OopMap {fp=Oop [0]=Oop off=636/0x27c}
27c     #@ShouldNotReachHere

288     B12: #	out( B2 ) &lt;- in( B1 )  Freq: 1e-06
288     add R12, sp, #16	# box lock
28c +   spill R11 -&gt; R8	# spill size = 64
290 +   CALL,static 0x000000401390c140	#@CallStaticJavaDirect wrapper for: _complete_monitor_locking_Java
        # java.io.BufferedInputStream::read @ bci:-1 (line 262) L[0]=R8 MON-BOX0=sp+16 MON-OBJ[0]=R8
        # OopMap {fp=Oop [0]=Oop off=660/0x294}
294 +   j  B2	#@branch

298     B13: #	out( B6 ) &lt;- in( B5 )  Freq: 9.97673e-07
298     add R11, sp, #16	# box lock
29c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
29c     spill R23 -&gt; R12	# spill size = 64
2a0 +   spill R30 -&gt; R10	# spill size = 64
2a4 +   CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
2d4 +   j  B6	#@branch

2d8     B14: #	out( B10 ) &lt;- in( B9 )  Freq: 2.32555e-09
2d8     add R11, sp, #16	# box lock
2dc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2dc     spill R23 -&gt; R12	# spill size = 64
2e0 +   spill R8 -&gt; R10	# spill size = 64
2e4 +   CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
314 +   j  B10	#@branch

318     B15: #	out( N231 ) &lt;- in( B3 )  Freq: 4.75728e-07
318 +   li R11, #-187	# int, #@loadConI
31c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.io.BufferedInputStream::getBufIfOpen @ bci:6 (line 167) L[0]=_ L[1]=R8 STK[0]=R8
        # java.io.BufferedInputStream::read @ bci:29 (line 267) L[0]=sp + #0 MON-BOX0=sp+16 MON-OBJ[0]=sp + #0
        # OopMap {fp=Oop [0]=Oop off=800/0x320}
320     #@ShouldNotReachHere

32c     B16: #	out( B18 B17 ) &lt;- in( B7 )  Freq: 4.65119e-08
32c      -- 	// exception oop; no code emitted, #@CreateException
32c +   #@membar_release_lock (elided)
32c     add R29, sp, #16	# box lock
330 +   fastunlock R8,R29	! kills R7, R28, #@cmpFastUnlock
3a8 +   spill R10 -&gt; R9	# spill size = 64
3ac +   far_bne RFLAGS, zr, B18	#@far_cmpFlag_branch  P=0.000001 C=-1.000000

3b4     B17: #	out( N231 ) &lt;- in( B18 B16 )  Freq: 4.65119e-08
3b4 +   spill R9 -&gt; R11	# spill size = 64
3b8 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
3c4 +   j rethrow_stub	#@RethrowException

3cc     B18: #	out( B17 ) &lt;- in( B16 )  Freq: 4.65119e-14
3cc     add R11, sp, #16	# box lock
3d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3d0     spill R23 -&gt; R12	# spill size = 64
3d4 +   spill R8 -&gt; R10	# spill size = 64
3d8 +   CALL, runtime leaf 0x0000004003a18104	#@CallLeafDirect complete_monitor_unlocking_C
        No JVM State Info
        # 
408 +   j  B17	#@branch

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='443'>
----------------------- MetaData before Compile_id = 443 ------------------------
{method}
 - this oop:          0x00000040962b74d8
 - method holder:     &apos;sun/nio/fs/UnixPath&apos;
 - constants:         0x00000040962b5440 constant pool [472] {0x00000040962b5440} for &apos;sun/nio/fs/UnixPath&apos; cache=0x00000040962ba1a0
 - access:            0xc1000002  private 
 - name:              &apos;hasDotOrDotDot&apos;
 - signature:         &apos;()Z&apos;
 - max stack:         3
 - max locals:        4
 - size of params:    1
 - method size:       13
 - highest level:     4
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c5ade00
 - code size:         69
 - code start:        0x00000040962b7450
 - code end (excl):   0x00000040962b7495
 - method data:       0x0000004096487860
 - checked ex length: 0
 - linenumber start:  0x00000040962b7495
 - localvar length:   4
 - localvar start:    0x00000040962b74a6
 - compiled code: nmethod  17986  442       3       sun.nio.fs.UnixPath::hasDotOrDotDot (69 bytes)

------------------------ OptoAssembly for Compile_id = 443 -----------------------
#
#  bool ( sun/nio/fs/UnixPath:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: sun/nio/fs/UnixPath:NotNull *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N533: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B54 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     spill R11 -&gt; R8	# spill size = 64
040     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getNameCount @ bci:1 (line 295) L[0]=R8
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:1 (line 227) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop off=68/0x44}

044     B2: #	out( B51 B3 ) &lt;- in( B1 )  Freq: 0.99998
        # Block is sole successor of call
044 +   spill R8 -&gt; R19	# spill size = 64
048 +   lwu  R28, [R19, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
04c +   #@membar_acquire
	fence ir iorw
050 +   decode_heap_oop  R7, R28	#@decodeHeapOop
054     lwu  R28, [R7, #12]	# range, #@loadRange
058     NullCheck R7

058     B3: #	out( B31 B4 ) &lt;- in( B2 )  Freq: 0.999979
058 +   bleu  R28, zr, B31	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.088024 C=46533.000000

05c     B4: #	out( B5 ) &lt;- in( B3 )  Freq: 0.911957
05c +   li R29, #0	# int, #@loadConI
060 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
060     li R9, #0	# int, #@loadConI
064     spill R29 -&gt; [sp, #28]	# spill size = 32
        nop 	# 4 bytes pad for loops and calls

070     B5: #	out( B55 B6 ) &lt;- in( B4 B26 ) Loop( B5-B26 inner ) Freq: 10.3506
070 +   spill R9 -&gt; [sp, #0]	# spill size = 32
074 +   spill R28 -&gt; [sp, #8]	# spill size = 32
078 +   spill R19 -&gt; R8	# spill size = 64
07c +   spill R19 -&gt; R11	# spill size = 64
080     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getName @ bci:1 (line 301) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=R8 L[1]=sp + #8 L[2]=sp + #0 L[3]=_
        # OopMap {fp=Oop off=132/0x84}

084     B6: #	out( B46 B7 ) &lt;- in( B5 )  Freq: 10.3504
        # Block is sole successor of call
084 +   spill R8 -&gt; R19	# spill size = 64
088 +   lwu  R7, [R19, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
08c +   #@membar_acquire
	fence ir iorw
090 +   decode_heap_oop  R7, R7	#@decodeHeapOop
094     lwu  R8, [R7, #12]	# range, #@loadRange
098     NullCheck R7

098     B7: #	out( B43 B8 ) &lt;- in( B6 )  Freq: 10.3503
098 +   spill [sp, #0] -&gt; R18	# spill size = 32
09c +   bge  R18, R8, B43	#@cmpI_branch  P=0.000000 C=5376.000000

0a0     B8: #	out( B47 B9 ) &lt;- in( B7 )  Freq: 10.3503
0a0 +   lwu  R28, [R19, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0a4 +   #@membar_acquire
	fence ir iorw
0a8 +   decode_heap_oop  R8, R28	#@decodeHeapOop
0ac     lwu  R7, [R8, #12]	# range, #@loadRange
0b0     NullCheck R8

0b0     B9: #	out( B40 B10 ) &lt;- in( B8 )  Freq: 10.3503
0b0 +   bgeu  R18, R7, B40	#@cmpU_branch  P=0.000001 C=-1.000000

0b4     B10: #	out( B48 B11 ) &lt;- in( B9 )  Freq: 10.3503
0b4 +   addw  R7, R18, zr	#@convI2L_reg_reg
0b8 +   slli  R29, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0bc +   lwu  R28, [R19, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0c0 +   add R7, R8, R29	# ptr, #@addP_reg_reg
0c4 +   lw  R7, [R7, #16]	# int, #@loadI
0c8 +   decode_heap_oop  R28, R28	#@decodeHeapOop
0cc +   #@membar_acquire
	fence ir iorw
0d0     lwu  R28, [R28, #12]	# range, #@loadRange
0d4     NullCheck R28

0d4     B11: #	out( B29 B12 ) &lt;- in( B10 )  Freq: 10.3503
0d4 +   addiw  R30, R28, #-1	#@addI_reg_imm
0d8 +   addiw  R9, R18, #1	#@addI_reg_imm
0dc +   beq  R18, R30, B29	#@cmpI_branch  P=0.084635 C=5376.000000

0e0     B12: #	out( B50 B13 ) &lt;- in( B11 )  Freq: 9.4743
0e0 +   lwu  R28, [R19, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
0e4 +   #@membar_acquire
	fence ir iorw
0e8 +   decode_heap_oop  R8, R28	#@decodeHeapOop
0ec     lwu  R30, [R8, #12]	# range, #@loadRange
0f0     NullCheck R8

0f0     B13: #	out( B42 B14 ) &lt;- in( B12 )  Freq: 9.47429
0f0 +   bgeu  R9, R30, B42	#@cmpU_branch  P=0.000001 C=-1.000000

0f4     B14: #	out( B15 ) &lt;- in( B13 )  Freq: 9.47428
0f4 +   add R28, R8, R29	# ptr, #@addP_reg_reg
0f8 +   lw  R28, [R28, #20]	# int, #@loadI
0fc +   subw  R29, R28, R7	#@subI_reg_reg
100 +   addiw  R20, R29, #-1	#@addI_reg_imm

104     B15: #	out( B16 B16 ) &lt;- in( B14 B30 )  Freq: 10.3503
104 +   lwu  R28, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
108 +   decode_heap_oop  R8, R28	#@decodeHeapOop
10c +   li R30, #1048576	# int, #@loadConI
110 +   addw  R28, R20, zr	#@convI2L_reg_reg
114 +   bleu  R20, R30, B16	#@cmpU_branch  P=0.999999 C=-1.000000

118     B16: #	out( B49 B17 ) &lt;- in( B15 B15 )  Freq: 10.3503
118     lwu  R30, [R8, #12]	# range, #@loadRange
11c     NullCheck R8

11c     B17: #	out( B41 B18 ) &lt;- in( B16 )  Freq: 10.3503
11c +   addw  R29, R20, R7	#@addI_reg_reg
120 +   blt  R7, zr, B41	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

124     B18: #	out( B41 B19 ) &lt;- in( B17 )  Freq: 10.3503
124 +   bltu  R30, R29, B41	#@cmpU_branch  P=0.000001 C=-1.000000

128     B19: #	out( B38 B20 ) &lt;- in( B18 )  Freq: 10.3503
128 +   li R29, #1048576	# int, #@loadConI
12c +   bgtu  R20, R29, B38	#@cmpU_branch  P=0.000001 C=-1.000000

130     B20: #	out( B38 B21 ) &lt;- in( B19 )  Freq: 10.3502
130 +   addi  R28, R28, #23	#@addL_reg_imm
134 +   ld  R21, [R23, #288]	# ptr, #@loadP
138 +   andi  R28, R28, #-8	#@andL_reg_imm
13c +   ld  R29, [R23, #304]	# ptr, #@loadP
140 +   add R28, R21, R28	# ptr, #@addP_reg_reg
144 +   bgeu  R28, R29, B38	#@cmpP_branch  P=0.000100 C=-1.000000

148     B21: #	out( B22 ) &lt;- in( B20 )  Freq: 10.3492
148 +   sd  R28, [R23, #288]	# ptr, #@storeP
14c +   li R28, #1	# long, #@loadConL
150 +   mv  R29, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
160 +   sd  R28, [R21]	# long, #@storeL
164 +   sw  R29, [R21, #8]	# compressed klass ptr, #@storeNKlass
168 +   sw  R20, [R21, #12]	# int, #@storeI

16c     B22: #	out( B24 B23 ) &lt;- in( B39 B21 )  Freq: 10.3503
16c     
16c +   # checkcastPP of R21, #@checkCastPP
16c     addi  R22, R21, #16	# ptr, #@addP_reg_imm
170 +   # castII of R20, #@castII
170     beq  R20, zr, B24	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

174     B23: #	out( B24 ) &lt;- in( B22 )  Freq: 10.3502
174 +   addw  R7, R7, zr	#@convI2L_reg_reg
178 +   add R7, R8, R7	# ptr, #@addP_reg_reg
17c +   addw  R12, R20, zr	#@convI2L_reg_reg
180     spill R22 -&gt; R11	# spill size = 64
184 +   addi  R10, R7, #16	# ptr, #@addP_reg_imm
188 +   CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

18c     B24: #	out( B35 B25 ) &lt;- in( B23 B22 )  Freq: 10.3503
18c     
18c     li R28, #1	# int, #@loadConI
190 +   beq  R20, R28, B35	#@cmpI_branch  P=0.000730 C=42438.000000

194     B25: #	out( B32 B26 ) &lt;- in( B36 B24 )  Freq: 10.3495
194 +   li R28, #2	# int, #@loadConI
198 +   beq  R20, R28, B32	#@cmpI_branch  P=0.005844 C=42438.000000

19c     B26: #	out( B5 B27 ) &lt;- in( B25 B33 )  Freq: 10.3495
19c +   spill [sp, #8] -&gt; R28	# spill size = 32
1a0 +   blt  R9, R28, B5	#@cmpI_loop  P=0.911976 C=42438.000000

1a4     B27: #	out( B28 ) &lt;- in( B26 )  Freq: 0.910999
1a4 +   spill [sp, #28] -&gt; R10	# spill size = 32

1a8     B28: #	out( N533 ) &lt;- in( B37 B27 B31 )  Freq: 0.999777
1a8     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
1c0 +   ret	// return register, #@Ret

1c4     B29: #	out( B52 B30 ) &lt;- in( B11 )  Freq: 0.876003
1c4 +   lwu  R28, [R19, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
1c8 +   decode_heap_oop  R28, R28	#@decodeHeapOop
1cc     lwu  R29, [R28, #12]	# range, #@loadRange
1d0     NullCheck R28

1d0     B30: #	out( B15 ) &lt;- in( B29 )  Freq: 0.876002
1d0 +   subw  R20, R29, R7	#@subI_reg_reg
1d4 +   j  B15	#@branch

1d8     B31: #	out( B28 ) &lt;- in( B3 )  Freq: 0.0880217
1d8 +   li R10, #0	# int, #@loadConI
1dc +   j  B28	#@branch

1e0     B32: #	out( B44 B33 ) &lt;- in( B25 )  Freq: 0.0604806
1e0 +   beq  R20, zr, B44	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

1e4     B33: #	out( B26 B34 ) &lt;- in( B32 )  Freq: 0.0604805
1e4 +   lb  R8, [R22]	# byte, #@loadB
1e8 +   li R7, #46	# int, #@loadConI
1ec +   bne  R8, R7, B26	#@cmpI_branch  P=1.000000 C=248.000000

1f0     B34: #	out( N533 ) &lt;- in( B33 )  Freq: 2.88394e-08
1f0 +   li R11, #-187	# int, #@loadConI
1f4     spill R19 -&gt; [sp, #0]	# spill size = 64
1f8 +   spill R18 -&gt; [sp, #12]	# spill size = 32
1fc +   spill R21 -&gt; [sp, #16]	# spill size = 64
200     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:48 (line 232) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #12 L[3]=sp + #16 STK[0]=R8 STK[1]=#46
        # OopMap {[0]=Oop [16]=Oop off=516/0x204}
204     #@ShouldNotReachHere

210     B35: #	out( B45 B36 ) &lt;- in( B24 )  Freq: 0.00756039
210 +   beq  R20, zr, B45	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

214     B36: #	out( B25 B37 ) &lt;- in( B35 )  Freq: 0.00756039
214 +   lb  R7, [R22]	# byte, #@loadB
218 +   li R28, #46	# int, #@loadConI
21c +   bne  R7, R28, B25	#@cmpI_branch  P=0.900000 C=-1.000000

220     B37: #	out( B28 ) &lt;- in( B36 )  Freq: 0.000756039
220 +   li R10, #1	# int, #@loadConI
224 +   j  B28	#@branch

228     B38: #	out( B53 B39 ) &lt;- in( B19 B20 )  Freq: 0.00104568
228 +   spill R20 -&gt; [sp, #24]	# spill size = 32
22c +   spill R9 -&gt; [sp, #20]	# spill size = 32
230 +   spill R7 -&gt; [sp, #16]	# spill size = 32
234 +   spill R18 -&gt; [sp, #12]	# spill size = 32
238 +   spill R19 -&gt; [sp, #0]	# spill size = 64
23c +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
254     spill R20 -&gt; R12	# spill size = 32
258     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #0 L[1]=_ L[2]=sp + #16 L[3]=sp + #24 L[4]=_
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #12 L[3]=_
        # OopMap {fp=Oop [0]=Oop off=604/0x25c}

25c     B39: #	out( B22 ) &lt;- in( B38 )  Freq: 0.00104566
        # Block is sole successor of call
25c +   spill [sp, #0] -&gt; R19	# spill size = 64
260 +   spill [sp, #12] -&gt; R18	# spill size = 32
264 +   spill [sp, #16] -&gt; R7	# spill size = 32
268 +   spill [sp, #20] -&gt; R9	# spill size = 32
26c +   spill [sp, #24] -&gt; R20	# spill size = 32
270 +   spill R10 -&gt; R21	# spill size = 64
274 +   j  B22	#@branch

278     B40: #	out( N533 ) &lt;- in( B9 )  Freq: 1.04878e-05
278 +   li R11, #-28	# int, #@loadConI
27c     spill R19 -&gt; [sp, #16]	# spill size = 64
280 +   spill R18 -&gt; [sp, #24]	# spill size = 32
284 +   spill R18 -&gt; [sp, #28]	# spill size = 32
288     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:38 (line 307) L[0]=sp + #16 L[1]=sp + #28 L[2]=_ L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #24
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #16 L[1]=sp + #8 L[2]=sp + #24 L[3]=_
        # OopMap {fp=Oop [16]=Oop off=652/0x28c}
28c     #@ShouldNotReachHere

298     B41: #	out( N533 ) &lt;- in( B17 B18 )  Freq: 2.07005e-05
298 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 32
2a0 +   li R11, #-52	# int, #@loadConI
2a4     spill R18 -&gt; [sp, #4]	# spill size = 32
2a8 +   spill R19 -&gt; [sp, #8]	# spill size = 64
2ac +   spill R7 -&gt; [sp, #16]	# spill size = 32
2b0 +   spill R20 -&gt; [sp, #24]	# spill size = 32
2b4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #8 L[1]=_ L[2]=sp + #16 L[3]=sp + #24 L[4]=_ STK[0]=sp + #24
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #8 L[1]=sp + #0 L[2]=sp + #4 L[3]=_
        # OopMap {[8]=Oop off=696/0x2b8}
2b8     #@ShouldNotReachHere

2c4     B42: #	out( N533 ) &lt;- in( B13 )  Freq: 9.6001e-06
2c4 +   li R11, #-28	# int, #@loadConI
2c8     spill R18 -&gt; [sp, #12]	# spill size = 32
2cc +   spill R19 -&gt; [sp, #16]	# spill size = 64
2d0 +   spill R9 -&gt; [sp, #24]	# spill size = 32
2d4 +   spill R7 -&gt; [sp, #28]	# spill size = 32
2d8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:69 (line 312) L[0]=sp + #16 L[1]=_ L[2]=sp + #28 L[3]=_ L[4]=_ STK[0]=R8 STK[1]=sp + #24
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #16 L[1]=sp + #8 L[2]=sp + #12 L[3]=_
        # OopMap {fp=Oop [16]=Oop off=732/0x2dc}
2dc     #@ShouldNotReachHere

2e8     B43: #	out( N533 ) &lt;- in( B7 )  Freq: 4.93543e-06
2e8 +   li R11, #-187	# int, #@loadConI
2ec     spill R19 -&gt; [sp, #16]	# spill size = 64
2f0 +   spill R18 -&gt; [sp, #24]	# spill size = 32
2f4 +   spill R18 -&gt; [sp, #28]	# spill size = 32
2f8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:22 (line 304) L[0]=sp + #16 L[1]=sp + #28 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #24 STK[1]=R8
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #16 L[1]=sp + #8 L[2]=sp + #24 L[3]=_
        # OopMap {[16]=Oop off=764/0x2fc}
2fc     #@ShouldNotReachHere

308     B44: #	out( N533 ) &lt;- in( B32 )  Freq: 6.12837e-08
308 +   li R11, #-28	# int, #@loadConI
30c     spill R19 -&gt; R8	# spill size = 64
310 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 32
318 +   spill R18 -&gt; [sp, #4]	# spill size = 32
31c +   spill R21 -&gt; [sp, #16]	# spill size = 64
320     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:45 (line 232) L[0]=R8 L[1]=sp + #0 L[2]=sp + #4 L[3]=sp + #16 STK[0]=sp + #16 STK[1]=#0
        # OopMap {fp=Oop [16]=Oop off=804/0x324}
324     #@ShouldNotReachHere

330     B45: #	out( N533 ) &lt;- in( B35 )  Freq: 7.66079e-09
330 +   li R11, #-28	# int, #@loadConI
334     spill R19 -&gt; R8	# spill size = 64
338 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 32
340 +   spill R18 -&gt; [sp, #4]	# spill size = 32
344 +   spill R21 -&gt; [sp, #16]	# spill size = 64
348     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:29 (line 230) L[0]=R8 L[1]=sp + #0 L[2]=sp + #4 L[3]=sp + #16 STK[0]=sp + #16 STK[1]=#0
        # OopMap {fp=Oop [16]=Oop off=844/0x34c}
34c     #@ShouldNotReachHere

358     B46: #	out( N533 ) &lt;- in( B6 )  Freq: 1.04878e-05
358 +   li R11, #-10	# int, #@loadConI
35c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:21 (line 304) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=864/0x360}
360     #@ShouldNotReachHere

36c     B47: #	out( N533 ) &lt;- in( B8 )  Freq: 1.04878e-05
36c +   li R11, #-10	# int, #@loadConI
370     spill R18 -&gt; R8	# spill size = 32
374     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:38 (line 307) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=888/0x378}
378     #@ShouldNotReachHere

384     B48: #	out( N533 ) &lt;- in( B10 )  Freq: 1.04878e-05
384 +   li R11, #-10	# int, #@loadConI
388     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:45 (line 309) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=_ STK[1]=#NULL
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=908/0x38c}
38c     #@ShouldNotReachHere

398     B49: #	out( N533 ) &lt;- in( B16 )  Freq: 1.04877e-05
398 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 32
3a0 +   li R11, #-12	# int, #@loadConI
3a4     spill R18 -&gt; [sp, #4]	# spill size = 32
3a8 +   spill R19 -&gt; [sp, #8]	# spill size = 64
3ac +   spill R7 -&gt; [sp, #16]	# spill size = 32
3b0 +   spill R20 -&gt; [sp, #24]	# spill size = 32
3b4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:76 (line 316) L[0]=sp + #8 L[1]=_ L[2]=sp + #16 L[3]=sp + #24 L[4]=_ STK[0]=sp + #24
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=sp + #8 L[1]=sp + #0 L[2]=sp + #4 L[3]=_
        # OopMap {[8]=Oop off=952/0x3b8}
3b8     #@ShouldNotReachHere

3c4     B50: #	out( N533 ) &lt;- in( B12 )  Freq: 9.60011e-06
3c4 +   li R11, #-10	# int, #@loadConI
3c8     spill R9 -&gt; R8	# spill size = 32
3cc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:69 (line 312) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=976/0x3d0}
3d0     #@ShouldNotReachHere

3dc     B51: #	out( N533 ) &lt;- in( B2 )  Freq: 1.01326e-06
3dc +   li R11, #-10	# int, #@loadConI
3e0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getNameCount @ bci:8 (line 296) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:1 (line 227) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=996/0x3e4}
3e4     #@ShouldNotReachHere

3f0     B52: #	out( N533 ) &lt;- in( B29 )  Freq: 8.87635e-07
3f0 +   li R11, #-10	# int, #@loadConI
3f4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getName @ bci:55 (line 310) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::hasDotOrDotDot @ bci:14 (line 229) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=1016/0x3f8}
3f8     #@ShouldNotReachHere

404     B53: #	out( B56 ) &lt;- in( B38 )  Freq: 1.04568e-08
404      -- 	// exception oop; no code emitted, #@CreateException
404 +   j  B56	#@branch

408     B54: #	out( B57 ) &lt;- in( B1 )  Freq: 1e-05
408      -- 	// exception oop; no code emitted, #@CreateException
408 +   spill R10 -&gt; R11	# spill size = 64
40c +   j  B57	#@branch

410     B55: #	out( B56 ) &lt;- in( B5 )  Freq: 0.000103506
410      -- 	// exception oop; no code emitted, #@CreateException

410     B56: #	out( B57 ) &lt;- in( B55 B53 )  Freq: 0.000103516
410 +   spill R10 -&gt; R11	# spill size = 64

414     B57: #	out( N533 ) &lt;- in( B54 B56 )  Freq: 0.000113516
414     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
420 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='452'>
----------------------- MetaData before Compile_id = 452 ------------------------
{method}
 - this oop:          0x00000040965e87c0
 - method holder:     &apos;jdk/internal/module/Checks&apos;
 - constants:         0x00000040965e7798 constant pool [250] {0x00000040965e7798} for &apos;jdk/internal/module/Checks&apos; cache=0x00000040965e8ce8
 - access:            0xc100000a  private static 
 - name:              &apos;isTypeName&apos;
 - signature:         &apos;(Ljava/lang/String;)Z&apos;
 - max stack:         4
 - max locals:        4
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c572ac0
 - code size:         49
 - code start:        0x00000040965e8740
 - code end (excl):   0x00000040965e8771
 - method data:       0x000000409649d1c8
 - checked ex length: 0
 - linenumber start:  0x00000040965e8771
 - localvar length:   5
 - localvar start:    0x00000040965e8782
 - compiled code: nmethod  18429  297       3       jdk.internal.module.Checks::isTypeName (49 bytes)

------------------------ OptoAssembly for Compile_id = 452 -----------------------
#
#  bool ( java/lang/String:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:exact *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
0000    N1: #	out( B1 ) &lt;- in( B138 B117 B139 B121 B100 B115 B126 B134 B101 B106 B107 B105 B95 B135 B108 B109 B102 B136 B110 B112 B103 B97 B113 B127 B141 B125 B30 B120 B119 B44 B104 B137 B111 B133 B96 B114 B118 B122 B128 B116 B140 B123 B124 B99 )  Freq: 1

0000    B1: #	out( B138 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
0000    # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
001c    spill R11 -&gt; R30	# spill size = 64
0020    lb  R17, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0024    NullCheck R11

0024    B2: #	out( B117 B3 ) &lt;- in( B1 )  Freq: 0.999999
0024 +  lwu  R15, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0028 +  decode_heap_oop  R8, R15	#@decodeHeapOop
002c +  bne  R17, zr, B117	#@cmpI_reg_imm0_branch  P=0.000000 C=91997.000000

0030    B3: #	out( B139 B4 ) &lt;- in( B2 )  Freq: 0.999999
0030    lwu  R12, [R8, #12]	# range, #@loadRange
0034    NullCheck R8

0034    B4: #	out( B121 B5 ) &lt;- in( B3 )  Freq: 0.999997
0034 +  bleu  R12, zr, B121	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=5375.000000

0038    B5: #	out( B31 B6 ) &lt;- in( B4 )  Freq: 0.999997
0038 +  li R13, #46	# int, #@loadConI
003c +  addi  R11, R8, #16	# ptr, #@addP_reg_imm
0040    StringUTF16 IndexOf char[] R11,R12,R13 -&gt; R10
02f0 +  li R7, #-1	# int, #@loadConI
02f4 +   -- 	// R23=Thread::current(), empty, #@tlsLoadP
02f4    bne  R10, R7, B31	#@cmpI_branch  P=0.747718 C=32428.000000

02f8    B6: #	out( B7 ) &lt;- in( B5 )  Freq: 0.252281
02f8 +  li R16, #0	# int, #@loadConI
02fc +  li R29, #1	# int, #@loadConI
0300 +  li R14, #2	# int, #@loadConI
0304 +  li R9, #0	# int, #@loadConI

0308    B7: #	out( B118 B8 ) &lt;- in( B62 B6 )  Freq: 0.996408
0308 +  decode_heap_oop  R11, R15	#@decodeHeapOop
030c +  lwu  R7, [R11, #12]	# range, #@loadRange
0310 +  sraw  R8, R7, R17	#@rShiftI_reg_reg
0314 +  blt  R9, zr, B118	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

0318    B8: #	out( B122 B9 ) &lt;- in( B7 )  Freq: 0.996408
0318 +  bgt  R9, R8, B122	#@cmpI_branch  P=0.000000 C=5375.000000

031c    B9: #	out( B11 B10 ) &lt;- in( B8 )  Freq: 0.996407
031c +  bne  R9, zr, B11	#@cmpI_reg_imm0_branch  P=0.627790 C=5376.000000

0320    B10: #	out( B15 ) &lt;- in( B9 )  Freq: 0.370873
0320 +  spill R30 -&gt; R10	# spill size = 64
0324 +  j  B15	#@branch

0328    B11: #	out( B128 B12 ) &lt;- in( B9 )  Freq: 0.625535
0328 +  subw  R13, R8, R9	#@subI_reg_reg
032c +  bne  R17, zr, B128	#@cmpI_reg_imm0_branch  P=0.000000 C=91997.000000

0330    B12: #	out( B129 B13 ) &lt;- in( B11 )  Freq: 0.625534
0330 +  spill R9 -&gt; R12	# spill size = 32
0334 +  spill R14 -&gt; [sp, #4]	# spill size = 32
0338 +  spill R29 -&gt; [sp, #0]	# spill size = 32
033c +  spill R16 -&gt; R8	# spill size = 32
0340    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringLatin1::newString
        # java.lang.String::substring @ bci:41 (line 2707) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isTypeName @ bci:40 (line 136) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=836/0x344}

0344    B13: #	out( B116 B14 ) &lt;- in( B12 )  Freq: 0.625522
        # Block is sole successor of call
0344 +  beq   R10, zr, B116	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

0348    B14: #	out( B15 ) &lt;- in( B13 )  Freq: 0.625521
0348 +  spill R8 -&gt; R16	# spill size = 32
034c +  spill [sp, #0] -&gt; R29	# spill size = 32
0350 +  spill [sp, #4] -&gt; R14	# spill size = 32

0354    B15: #	out( B140 B16 ) &lt;- in( B10 B14 )  Freq: 0.996394
0354 +  lwu  R28, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0358 +  decode_heap_oop  R7, R28	#@decodeHeapOop
035c    lwu  R8, [R7, #12]	# range, #@loadRange
0360    NullCheck R7

0360    B16: #	out( B123 B17 ) &lt;- in( B15 )  Freq: 0.996393
0360 +  bleu  R8, zr, B123	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=8622.000000

0364    B17: #	out( B130 B18 ) &lt;- in( B16 )  Freq: 0.996392
0364 +  spill R10 -&gt; R8	# spill size = 64
0368 +  spill R14 -&gt; [sp, #8]	# spill size = 32
036c +  spill R29 -&gt; [sp, #4]	# spill size = 32
0370 +  spill R16 -&gt; [sp, #0]	# spill size = 32
0374 +  mv  R11, java/util/ImmutableCollections$SetN:exact *	# ptr, #@loadConP
038c    spill R10 -&gt; R12	# spill size = 64
0390    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.ImmutableCollections$SetN::probe
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop off=916/0x394}

0394    B18: #	out( B124 B19 ) &lt;- in( B17 )  Freq: 0.996372
        # Block is sole successor of call
0394 +  spill R8 -&gt; R30	# spill size = 64
0398 +  lwu  R7, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
039c +  lb  R28, [R30, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
03a0 +  decode_heap_oop  R13, R7	#@decodeHeapOop
03a4 +  bge  R10, zr, B124	#@cmpI_reg_imm0_branch  P=0.000000 C=8485.000000

03a8    B19: #	out( B119 B20 ) &lt;- in( B18 )  Freq: 0.996372
03a8 +  bne  R28, zr, B119	#@cmpI_reg_imm0_branch  P=0.000000 C=91997.000000

03ac    B20: #	out( B141 B21 ) &lt;- in( B19 )  Freq: 0.996371
03ac    lwu  R31, [R13, #12]	# range, #@loadRange
03b0    NullCheck R13

03b0    B21: #	out( B125 B22 ) &lt;- in( B20 )  Freq: 0.99637
03b0 +  bleu  R31, zr, B125	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=38842.000000

03b4    B22: #	out( B120 B23 ) &lt;- in( B21 )  Freq: 0.99637
03b4 +  lbu  R15, [R13, #16]	# byte, #@loadUB
03b8 +  addw  R7, R15, zr	#@convI2L_reg_reg
03bc +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
03c0 +  mv  R10, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d8148310&gt; *	# ptr, #@loadConP
03d8 +  mv  R29, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d8148310&gt; *	# ptr, #@loadConP
03f0 +  add R7, R10, R7	# ptr, #@addP_reg_reg
03f4 +  sraw  R12, R31, R28	#@rShiftI_reg_reg
03f8 +  lw  R29, [R7, #16]	# int, #@loadI
03fc +  li R28, #28672	# int, #@loadConI
0400 +  li R7, #20480	# int, #@loadConI
0404 +  andr  R8, R29, R28	#@andI_reg_reg
0408 +  blt  R8, R7, B120	#@cmpI_branch  P=0.000000 C=5376.000000

040c    B23: #	out( B43 B24 ) &lt;- in( B22 )  Freq: 0.996369
040c +  spill [sp, #4] -&gt; R11	# spill size = 32
0410 +  ble  R12, R11, B43	#@cmpI_branch  P=0.216422 C=37852.000000

0414    B24: #	out( B114 B25 ) &lt;- in( B23 )  Freq: 0.780733
0414 +  bleu  R31, R11, B114	#@cmpU_branch  P=0.000001 C=-1.000000

0418    B25: #	out( B114 B26 ) &lt;- in( B24 )  Freq: 0.780732
0418 +  li R28, #-2147483648	# int, #@loadConI
041c +  addiw  R10, R12, #-1	#@addI_reg_imm
0420    CMove R10, (R12 lt R10), R10, R28	#@cmovI_cmpI
	
0428 +  addw  R7, R12, zr	#@convI2L_reg_reg
042c +  addw  R28, R31, zr	#@convI2L_reg_reg
0430 +  addi  R7, R7, #-1	#@addL_reg_imm
0434 +  bgeu  R7, R28, B114	#@cmpUL_branch  P=0.000001 C=-1.000000

0438    B26: #	out( B93 B27 ) &lt;- in( B25 )  Freq: 0.780732
0438 +  lbu  R7, [R13, #17]	# byte, #@loadUB2L
043c +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0440 +  mv  R29, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d8148310&gt; *	# ptr, #@loadConP
0458 +  mv  R28, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d8148310&gt; *	# ptr, #@loadConP
0470 +  add R7, R29, R7	# ptr, #@addP_reg_reg
0474 +  lw  R7, [R7, #16]	# int, #@loadI
0478 +  li R28, #12288	# int, #@loadConI
047c +  andr  R28, R7, R28	#@andI_reg_reg
0480 +  beq  R28, zr, B93	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

0484    B27: #	out( B38 B28 ) &lt;- in( B26 )  Freq: 0.780705
0484 +  spill [sp, #8] -&gt; R29	# spill size = 32
0488 +  ble  R10, R29, B38	#@cmpI_branch  P=0.000001 C=-1.000000

048c    B28: #	out( B115 B29 ) &lt;- in( B27 )  Freq: 0.780705
048c +  bleu  R31, R29, B115	#@cmpU_branch  P=0.000001 C=-1.000000

0490    B29: #	out( B33 B30 ) &lt;- in( B28 )  Freq: 0.780704
0490 +  li R28, #3	# int, #@loadConI
0494 +  bgtu  R31, R28, B33	#@cmpU_branch  P=0.999999 C=-1.000000

0498    B30: #	out( N1 ) &lt;- in( B29 )  Freq: 7.80704e-07
0498    #@ShouldNotReachHere

04a4    B31: #	out( B63 ) &lt;- in( B5 )  Freq: 0.747716
04a4 +  li R16, #0	# int, #@loadConI
04a8 +  li R29, #1	# int, #@loadConI
04ac +  li R14, #2	# int, #@loadConI
04b0 +  li R9, #0	# int, #@loadConI
04b4 +  j  B63	#@branch

04b8    B32: #	out( B33 ) &lt;- in( B37 ) top-of-loop Freq: 2.82255
04b8 +  spill R14 -&gt; [sp, #0]	# spill size = 32

04bc    B33: #	out( B34 ) &lt;- in( B29 B32 ) Loop( B33-B32 ) Freq: 3.60325
04bc +  spill [sp, #0] -&gt; R14	# spill size = 32
04c0 +  subw  R7, R10, R29	#@subI_reg_reg
04c4    CMove R7, (R10 lt R29), R7, R14	#@cmovI_cmpI
	
04cc +  li R16, #2000	# int, #@loadConI
04d0 +  li R28, #2000	# int, #@loadConI
04d4    CMove R7, (R7 gtu R28), R7, R16	#@cmovI_cmpU
	
04dc +  addw  R16, R7, R29	#@addI_reg_reg

04e0    B34: #	out( B93 B35 ) &lt;- in( B33 B36 ) Loop( B34-B36 inner main of N405 strip mined) Freq: 16.6452
04e0 +  addw  R7, R29, zr	#@convI2L_reg_reg
04e4 +  add R7, R13, R7	# ptr, #@addP_reg_reg
04e8 +  lbu  R28, [R7, #16]	# byte, #@loadUB2L
04ec +  lbu  R7, [R7, #17]	# byte, #@loadUB2L
04f0 +  slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
04f4 +  mv  R17, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d8148310&gt; *	# ptr, #@loadConP
050c +  mv  R15, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d8148310&gt; *	# ptr, #@loadConP
0524 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0528 +  add R28, R17, R28	# ptr, #@addP_reg_reg
052c +  add R7, R17, R7	# ptr, #@addP_reg_reg
0530 +  lw  R15, [R7, #16]	# int, #@loadI
0534 +  lw  R28, [R28, #16]	# int, #@loadI
0538 +  li R7, #12288	# int, #@loadConI
053c +  li R17, #12288	# int, #@loadConI
0540 +  andr  R7, R28, R7	#@andI_reg_reg
0544 +  andr  R15, R15, R17	#@andI_reg_reg
0548 +  beq  R7, zr, B93	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

054c    B35: #	out( B93 B36 ) &lt;- in( B34 )  Freq: 16.6446
054c +  beq  R15, zr, B93	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

0550    B36: #	out( B34 B37 ) &lt;- in( B35 )  Freq: 16.644
0550 +  addiw  R29, R29, #2	#@addI_reg_imm
0554 +  blt  R29, R16, B34	#@cmpI_loop  P=0.783578 C=29660.000000

0558    B37: #	out( B32 B38 ) &lt;- in( B36 )  Freq: 3.60213
0558 +  ld  R15, [R23, #920]	# ptr, #@loadP
055c +  lwu zr, [R15]	# Safepoint: poll for GC, #@safePoint        # jdk.internal.module.Checks::isJavaIdentifier @ bci:71 (line 185) L[0]=R30 L[1]=_ L[2]=R29 L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {x30=Oop c_rarg3=Oop off=1372/0x55c}
0560 +  blt  R29, R10, B32	#@cmpI_branch  P=0.783578 C=29660.000000

0564    B38: #	out( B43 B39 ) &lt;- in( B27 B37 )  Freq: 0.779581
0564 +  bge  R29, R12, B43	#@cmpI_branch  P=0.500000 C=-1.000000

0568    B39: #	out( B126 B40 ) &lt;- in( B38 )  Freq: 0.38979
0568 +  # castII of R29, #@castII
0568    bgeu  R29, R31, B126	#@cmpU_branch  P=0.000001 C=-1.000000

056c    B40: #	out( B127 B41 ) &lt;- in( B39 )  Freq: 0.38979
056c +  spill R29 -&gt; R7	# spill size = 32
0570 +  # castII of R7, #@castII
0570    bgeu  R7, R31, B127	#@cmpU_branch  P=0.000001 C=-1.000000

0574    B41: #	out( B93 B42 ) &lt;- in( B40 B42 ) Loop( B41-B42 inner post of N839) Freq: 0.779553
0574 +  addw  R7, R29, zr	#@convI2L_reg_reg
0578 +  add R7, R13, R7	# ptr, #@addP_reg_reg
057c +  lbu  R7, [R7, #16]	# byte, #@loadUB2L
0580 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0584 +  mv  R30, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d8148310&gt; *	# ptr, #@loadConP
059c +  mv  R28, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d8148310&gt; *	# ptr, #@loadConP
05b4 +  add R7, R30, R7	# ptr, #@addP_reg_reg
05b8 +  lw  R28, [R7, #16]	# int, #@loadI
05bc +  li R7, #12288	# int, #@loadConI
05c0 +  andr  R7, R28, R7	#@andI_reg_reg
05c4 +  beq  R7, zr, B93	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

05c8    B42: #	out( B41 B43 ) &lt;- in( B41 )  Freq: 0.779526
05c8 +  addiw  R29, R29, #1	#@addI_reg_imm
05cc +  blt  R29, R12, B41	#@cmpI_loop  P=0.500000 C=29660.000000

05d0    B43: #	out( B44 ) &lt;- in( B93 B38 B23 B42 )  Freq: 0.996365
05d0 +  spill R11 -&gt; R16	# spill size = 32

05d4    B44: #	out( N1 ) &lt;- in( B54 B48 B94 B47 B43 )  Freq: 0.99985
05d4 +  spill R16 -&gt; R10	# spill size = 32
05d8 +  # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
05f0 +  ret	// return register, #@Ret

05f4    B45: #	out( B46 ) &lt;- in( B50 ) top-of-loop Freq: 8.36562
05f4 +  spill R16 -&gt; [sp, #8]	# spill size = 32

05f8    B46: #	out( B47 ) &lt;- in( B91 B45 ) Loop( B46-B45 ) Freq: 10.6795
05f8 +  spill [sp, #8] -&gt; R16	# spill size = 32
05fc +  subw  R28, R11, R15	#@subI_reg_reg
0600    CMove R28, (R11 lt R15), R28, R16	#@cmovI_cmpI
	
0608 +  li R17, #2000	# int, #@loadConI
060c +  li R7, #2000	# int, #@loadConI
0610    CMove R28, (R28 gtu R7), R28, R17	#@cmovI_cmpU
	
0618 +  addw  R7, R28, R15	#@addI_reg_reg
        nop 	# 2 bytes pad for loops and calls

0620    B47: #	out( B44 B48 ) &lt;- in( B46 B49 ) Loop( B47-B49 inner main of N168 strip mined) Freq: 49.3337
0620 +  addw  R28, R15, zr	#@convI2L_reg_reg
0624 +  add R28, R10, R28	# ptr, #@addP_reg_reg
0628 +  lbu  R12, [R28, #16]	# byte, #@loadUB2L
062c +  lbu  R28, [R28, #17]	# byte, #@loadUB2L
0630 +  slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0634 +  mv  R9, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d8148310&gt; *	# ptr, #@loadConP
064c +  mv  R17, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d8148310&gt; *	# ptr, #@loadConP
0664 +  slli  R12, R12, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0668 +  add R28, R9, R28	# ptr, #@addP_reg_reg
066c +  add R12, R9, R12	# ptr, #@addP_reg_reg
0670 +  lw  R17, [R12, #16]	# int, #@loadI
0674 +  lw  R28, [R28, #16]	# int, #@loadI
0678 +  li R12, #12288	# int, #@loadConI
067c +  li R9, #12288	# int, #@loadConI
0680 +  andr  R17, R17, R12	#@andI_reg_reg
0684 +  andr  R28, R28, R9	#@andI_reg_reg
0688 +  beq  R17, zr, B44	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

068c    B48: #	out( B44 B49 ) &lt;- in( B47 )  Freq: 49.3321
068c +  beq  R28, zr, B44	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

0690    B49: #	out( B47 B50 ) &lt;- in( B48 )  Freq: 49.3304
0690 +  addiw  R15, R15, #2	#@addI_reg_imm
0694 +  blt  R15, R7, B47	#@cmpI_loop  P=0.783578 C=29660.000000

0698    B50: #	out( B45 B51 ) &lt;- in( B49 )  Freq: 10.6762
0698 +  ld  R28, [R23, #920]	# ptr, #@loadP
069c +  lwu zr, [R28]	# Safepoint: poll for GC, #@safePoint        # jdk.internal.module.Checks::isJavaIdentifier @ bci:71 (line 185) L[0]=R30 L[1]=_ L[2]=R15 L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=sp + #0 L[1]=sp + #20 L[2]=_ L[3]=_
        # OopMap {x30=Oop c_rarg0=Oop [0]=Oop off=1692/0x69c}
06a0 +  blt  R15, R11, B45	#@cmpI_branch  P=0.783578 C=29660.000000

06a4    B51: #	out( B56 B52 ) &lt;- in( B98 B50 )  Freq: 2.31056
06a4 +  bge  R15, R13, B56	#@cmpI_branch  P=0.500000 C=-1.000000

06a8    B52: #	out( B112 B53 ) &lt;- in( B51 )  Freq: 1.15528
06a8 +  # castII of R15, #@castII
06a8    bgeu  R15, R31, B112	#@cmpU_branch  P=0.000001 C=-1.000000

06ac    B53: #	out( B113 B54 ) &lt;- in( B52 )  Freq: 1.15528
06ac +  spill R15 -&gt; R28	# spill size = 32
06b0 +  # castII of R28, #@castII
06b0    bgeu  R28, R31, B113	#@cmpU_branch  P=0.000001 C=-1.000000

06b4    B54: #	out( B44 B55 ) &lt;- in( B53 B55 ) Loop( B54-B55 inner post of N828) Freq: 2.31048
06b4 +  addw  R7, R15, zr	#@convI2L_reg_reg
06b8 +  add R7, R10, R7	# ptr, #@addP_reg_reg
06bc +  lbu  R7, [R7, #16]	# byte, #@loadUB2L
06c0 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
06c4 +  mv  R30, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d8148310&gt; *	# ptr, #@loadConP
06dc +  mv  R28, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d8148310&gt; *	# ptr, #@loadConP
06f4 +  add R7, R30, R7	# ptr, #@addP_reg_reg
06f8 +  lw  R7, [R7, #16]	# int, #@loadI
06fc +  li R28, #12288	# int, #@loadConI
0700 +  andr  R28, R7, R28	#@andI_reg_reg
0704 +  beq  R28, zr, B44	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

0708    B55: #	out( B54 B56 ) &lt;- in( B54 )  Freq: 2.3104
0708 +  addiw  R15, R15, #1	#@addI_reg_imm
070c +  blt  R15, R13, B54	#@cmpI_loop  P=0.500000 C=29660.000000

0710    B56: #	out( B104 B57 ) &lt;- in( B51 B84 B55 )  Freq: 2.94959
0710 +  spill [sp, #20] -&gt; R31	# spill size = 32
0714 +  addiw  R9, R31, #1	#@addI_reg_imm
0718 +  ld  R28, [R23, #920]	# ptr, #@loadP
071c +  lwu zr, [R28]	# Safepoint: poll for GC, #@safePoint        # jdk.internal.module.Checks::isTypeName @ bci:35 (line 135) L[0]=sp + #0 L[1]=_ L[2]=R9 L[3]=_
        # OopMap {[0]=Oop off=1820/0x71c}
0720 +  spill [sp, #0] -&gt; R30	# spill size = 64
0724 +  lwu  R15, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0728 +  lb  R17, [R30, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
072c +  decode_heap_oop  R28, R15	#@decodeHeapOop
0730 +  bne  R17, zr, B104	#@cmpI_reg_imm0_branch  P=0.000000 C=91997.000000

0734    B57: #	out( B137 B58 ) &lt;- in( B56 )  Freq: 2.94959
0734    lwu  R8, [R28, #12]	# range, #@loadRange
0738    NullCheck R28

0738    B58: #	out( B111 B59 ) &lt;- in( B57 )  Freq: 2.94959
0738 +  subw  R7, R8, R31	#@subI_reg_reg
073c +  addiw  R12, R7, #-1	#@addI_reg_imm
0740 +  bgeu  R9, R8, B111	#@cmpU_branch  P=0.000000 C=5375.000000

0744    B59: #	out( B96 B60 ) &lt;- in( B58 )  Freq: 2.94959
0744 +  blt  R12, zr, B96	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0748    B60: #	out( B62 B61 ) &lt;- in( B59 )  Freq: 2.94958
0748 +  addw  R7, R31, zr	#@convI2L_reg_reg
074c +  add R7, R28, R7	# ptr, #@addP_reg_reg
0750 +  addi  R11, R7, #17	# ptr, #@addP_reg_imm
0754 +  li R13, #46	# int, #@loadConI
0758    StringUTF16 IndexOf char[] R11,R12,R13 -&gt; R10
0a08 +  blt  R10, zr, B62	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0a0c    B61: #	out( B62 ) &lt;- in( B60 )  Freq: 2.94663
0a0c +  addw  R28, R31, R10	#@addI_reg_reg
0a10 +  addiw  R10, R28, #1	#@addI_reg_imm

0a14    B62: #	out( B7 B63 ) &lt;- in( B61 B60 )  Freq: 2.94958
0a14 +  li R28, #-1	# int, #@loadConI
0a18 +  beq  R10, R28, B7	#@cmpI_branch  P=0.252282 C=24237.000000

0a1c    B63: #	out( B134 B64 ) &lt;- in( B31 B62 ) Loop( B63-B62 ) Freq: 2.95323
0a1c +  decode_heap_oop  R11, R15	#@decodeHeapOop
0a20    lwu  R28, [R11, #12]	# range, #@loadRange
0a24    NullCheck R11

0a24    B64: #	out( B101 B65 ) &lt;- in( B63 )  Freq: 2.95323
0a24 +  lb  R7, [R30, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0a28 +  sraw  R8, R28, R7	#@rShiftI_reg_reg
0a2c +  blt  R9, zr, B101	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

0a30    B65: #	out( B106 B66 ) &lt;- in( B64 )  Freq: 2.95323
0a30 +  bgt  R9, R10, B106	#@cmpI_branch  P=0.000000 C=5375.000000

0a34    B66: #	out( B107 B67 ) &lt;- in( B65 )  Freq: 2.95323
0a34 +  bgt  R10, R8, B107	#@cmpI_branch  P=0.000000 C=5375.000000

0a38    B67: #	out( B70 B68 ) &lt;- in( B66 )  Freq: 2.95322
0a38 +  bne  R9, zr, B70	#@cmpI_reg_imm0_branch  P=0.627790 C=5376.000000

0a3c    B68: #	out( B92 B69 ) &lt;- in( B67 )  Freq: 1.09922
0a3c +  beq  R10, R8, B92	#@cmpI_branch  P=0.011494 C=2001.000000

0a40    B69: #	out( B71 ) &lt;- in( B68 )  Freq: 1.08658
0a40 +  li R9, #0	# int, #@loadConI
0a44    spill R10 -&gt; R13	# spill size = 32
0a48 +  j  B71	#@branch

0a4c    B70: #	out( B71 ) &lt;- in( B67 )  Freq: 1.85401
0a4c +  subw  R13, R10, R9	#@subI_reg_reg

0a50    B71: #	out( B105 B72 ) &lt;- in( B69 B70 )  Freq: 2.94059
0a50 +  bne  R7, zr, B105	#@cmpI_reg_imm0_branch  P=0.000000 C=91997.000000

0a54    B72: #	out( B132 B73 ) &lt;- in( B71 )  Freq: 2.94059
0a54 +  spill R10 -&gt; [sp, #12]	# spill size = 32
0a58 +  spill R9 -&gt; R12	# spill size = 32
0a5c +  spill R14 -&gt; [sp, #8]	# spill size = 32
0a60 +  spill R29 -&gt; [sp, #4]	# spill size = 32
0a64 +  spill R16 -&gt; [sp, #0]	# spill size = 32
0a68 +  spill R30 -&gt; R8	# spill size = 64
0a6c    CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringLatin1::newString
        # java.lang.String::substring @ bci:41 (line 2707) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=R8 L[1]=sp + #12 L[2]=_ L[3]=_
        # OopMap {fp=Oop off=2672/0xa70}

0a70    B73: #	out( B95 B74 ) &lt;- in( B72 )  Freq: 2.94053
        # Block is sole successor of call
0a70 +  beq   R10, zr, B95	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

0a74    B74: #	out( B75 ) &lt;- in( B73 )  Freq: 2.94053
0a74 +  spill R10 -&gt; R31	# spill size = 64
0a78 +  spill R8 -&gt; R30	# spill size = 64
0a7c +  spill [sp, #0] -&gt; R16	# spill size = 32
0a80 +  spill [sp, #4] -&gt; R29	# spill size = 32
0a84 +  spill [sp, #8] -&gt; R14	# spill size = 32
0a88 +  spill [sp, #12] -&gt; R10	# spill size = 32

0a8c    B75: #	out( B135 B76 ) &lt;- in( B92 B74 )  Freq: 2.95316
0a8c +  lwu  R28, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0a90 +  decode_heap_oop  R7, R28	#@decodeHeapOop
0a94    lwu  R8, [R7, #12]	# range, #@loadRange
0a98    NullCheck R7

0a98    B76: #	out( B108 B77 ) &lt;- in( B75 )  Freq: 2.95316
0a98 +  bleu  R8, zr, B108	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=8622.000000

0a9c    B77: #	out( B131 B78 ) &lt;- in( B76 )  Freq: 2.95316
0a9c +  spill R31 -&gt; R8	# spill size = 64
0aa0 +  spill R10 -&gt; [sp, #20]	# spill size = 32
0aa4 +  spill R14 -&gt; [sp, #16]	# spill size = 32
0aa8 +  spill R29 -&gt; [sp, #12]	# spill size = 32
0aac +  spill R16 -&gt; [sp, #8]	# spill size = 32
0ab0 +  spill R30 -&gt; [sp, #0]	# spill size = 64
0ab4 +  mv  R11, java/util/ImmutableCollections$SetN:exact *	# ptr, #@loadConP
0acc    spill R31 -&gt; R12	# spill size = 64
0ad0    CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.ImmutableCollections$SetN::probe
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=sp + #0 L[1]=sp + #20 L[2]=_ L[3]=_
        # OopMap {fp=Oop [0]=Oop off=2772/0xad4}

0ad4    B78: #	out( B109 B79 ) &lt;- in( B77 )  Freq: 2.9531
        # Block is sole successor of call
0ad4 +  spill R8 -&gt; R30	# spill size = 64
0ad8 +  lwu  R7, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0adc +  lb  R28, [R30, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0ae0    spill R10 -&gt; R29	# spill size = 32
0ae4 +  decode_heap_oop  R10, R7	#@decodeHeapOop
0ae8 +  bge  R29, zr, B109	#@cmpI_reg_imm0_branch  P=0.000000 C=8485.000000

0aec    B79: #	out( B102 B80 ) &lt;- in( B78 )  Freq: 2.9531
0aec +  bne  R28, zr, B102	#@cmpI_reg_imm0_branch  P=0.000000 C=91997.000000

0af0    B80: #	out( B136 B81 ) &lt;- in( B79 )  Freq: 2.9531
0af0    lwu  R31, [R10, #12]	# range, #@loadRange
0af4    NullCheck R10

0af4    B81: #	out( B110 B82 ) &lt;- in( B80 )  Freq: 2.95309
0af4 +  bleu  R31, zr, B110	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=38842.000000

0af8    B82: #	out( B103 B83 ) &lt;- in( B81 )  Freq: 2.95309
0af8 +  lbu  R12, [R10, #16]	# byte, #@loadUB
0afc +  addw  R7, R12, zr	#@convI2L_reg_reg
0b00 +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0b04 +  mv  R11, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d8148310&gt; *	# ptr, #@loadConP
0b1c +  mv  R29, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d8148310&gt; *	# ptr, #@loadConP
0b34 +  add R7, R11, R7	# ptr, #@addP_reg_reg
0b38 +  sraw  R13, R31, R28	#@rShiftI_reg_reg
0b3c +  lw  R29, [R7, #16]	# int, #@loadI
0b40 +  li R28, #28672	# int, #@loadConI
0b44 +  li R7, #20480	# int, #@loadConI
0b48 +  andr  R8, R29, R28	#@andI_reg_reg
0b4c +  blt  R8, R7, B103	#@cmpI_branch  P=0.000000 C=5376.000000

0b50    B83: #	out( B85 B84 ) &lt;- in( B82 )  Freq: 2.95309
0b50 +  spill [sp, #12] -&gt; R29	# spill size = 32
0b54 +  bgt  R13, R29, B85	#@cmpI_branch  P=0.783578 C=37852.000000

0b58    B84: #	out( B56 ) &lt;- in( B83 )  Freq: 0.639113
0b58 +  spill [sp, #8] -&gt; R16	# spill size = 32
0b5c +  spill [sp, #16] -&gt; R14	# spill size = 32
0b60 +  j  B56	#@branch

0b64    B85: #	out( B97 B86 ) &lt;- in( B83 )  Freq: 2.31398
0b64 +  bleu  R31, R29, B97	#@cmpU_branch  P=0.000001 C=-1.000000

0b68    B86: #	out( B97 B87 ) &lt;- in( B85 )  Freq: 2.31397
0b68 +  li R28, #-2147483648	# int, #@loadConI
0b6c +  addiw  R11, R13, #-1	#@addI_reg_imm
0b70    CMove R11, (R13 lt R11), R11, R28	#@cmovI_cmpI
	
0b78 +  addw  R7, R13, zr	#@convI2L_reg_reg
0b7c +  addw  R28, R31, zr	#@convI2L_reg_reg
0b80 +  addi  R7, R7, #-1	#@addL_reg_imm
0b84 +  bgeu  R7, R28, B97	#@cmpUL_branch  P=0.000001 C=-1.000000

0b88    B87: #	out( B94 B88 ) &lt;- in( B86 )  Freq: 2.31397
0b88 +  lbu  R7, [R10, #17]	# byte, #@loadUB2L
0b8c +  slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0b90 +  mv  R12, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d8148310&gt; *	# ptr, #@loadConP
0ba8 +  mv  R28, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1239 address=0x00000040d8148310&gt; *	# ptr, #@loadConP
0bc0 +  add R7, R12, R7	# ptr, #@addP_reg_reg
0bc4 +  lw  R28, [R7, #16]	# int, #@loadI
0bc8 +  li R7, #12288	# int, #@loadConI
0bcc +  andr  R7, R28, R7	#@andI_reg_reg
0bd0 +  beq  R7, zr, B94	#@cmpI_reg_imm0_branch  P=0.000034 C=29661.000000

0bd4    B88: #	out( B98 B89 ) &lt;- in( B87 )  Freq: 2.31389
0bd4 +  spill [sp, #16] -&gt; R14	# spill size = 32
0bd8 +  ble  R11, R14, B98	#@cmpI_branch  P=0.000001 C=-1.000000

0bdc    B89: #	out( B99 B90 ) &lt;- in( B88 )  Freq: 2.31389
0bdc +  bleu  R31, R14, B99	#@cmpU_branch  P=0.000001 C=-1.000000

0be0    B90: #	out( B100 B91 ) &lt;- in( B89 )  Freq: 2.31389
0be0 +  li R28, #3	# int, #@loadConI
0be4 +  bleu  R31, R28, B100	#@cmpU_branch  P=0.000001 C=-1.000000

0be8    B91: #	out( B46 ) &lt;- in( B90 )  Freq: 2.31389
0be8 +  li R15, #2	# int, #@loadConI
0bec +  j  B46	#@branch

0bf0    B92: #	out( B75 ) &lt;- in( B68 )  Freq: 0.0126347
0bf0 +  spill R30 -&gt; R31	# spill size = 64
0bf4 +  j  B75	#@branch

0bf8    B93: #	out( B43 ) &lt;- in( B41 B35 B26 B34 )  Freq: 0.00117571
0bf8 +  li R11, #0	# int, #@loadConI
0bfc +  j  B43	#@branch

0c00    B94: #	out( B44 ) &lt;- in( B87 )  Freq: 7.80647e-05
0c00 +  spill [sp, #8] -&gt; R16	# spill size = 32
0c04 +  j  B44	#@branch

0c08    B95: #	out( N1 ) &lt;- in( B73 )  Freq: 2.97958e-06
0c08 +  li R11, #-10	# int, #@loadConI
0c0c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=3088/0xc10}
0c10    #@ShouldNotReachHere

0c1c    B96: #	out( N1 ) &lt;- in( B59 )  Freq: 2.94959e-06
0c1c +  li R11, #-50	# int, #@loadConI
0c20    spill R28 -&gt; [sp, #16]	# spill size = 64
0c24 +  spill R9 -&gt; [sp, #12]	# spill size = 32
0c28    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::indexOf @ bci:32 (line 213) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #16 STK[1]=#46 STK[2]=sp + #12 STK[3]=R8
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=sp + #0 L[1]=_ L[2]=sp + #12 L[3]=_
        # OopMap {[0]=Oop [16]=Oop off=3116/0xc2c}
0c2c    #@ShouldNotReachHere

0c38    B97: #	out( N1 ) &lt;- in( B86 B85 )  Freq: 4.65868e-06
0c38 +  spill [sp, #0] -&gt; R8	# spill size = 64
0c3c +  li R11, #-138	# int, #@loadConI
0c40    spill R30 -&gt; [sp, #8]	# spill size = 64
0c44 +  spill R13 -&gt; [sp, #4]	# spill size = 32
0c48    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:46 (line 180) L[0]=sp + #8 L[1]=_ L[2]=#1 L[3]=_ STK[0]=#1 STK[1]=sp + #4
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=R8 L[1]=sp + #20 L[2]=_ L[3]=_
        # OopMap {fp=Oop [8]=Oop off=3148/0xc4c}
0c4c    #@ShouldNotReachHere

0c58    B98: #	out( B51 ) &lt;- in( B88 )  Freq: 2.34462e-06
0c58 +  li R15, #2	# int, #@loadConI
0c5c    spill [sp, #8] -&gt; R16	# spill size = 32
0c60 +  j  B51	#@branch

0c64    B99: #	out( N1 ) &lt;- in( B89 )  Freq: 2.31389e-06
0c64    #@ShouldNotReachHere

0c70    B100: #	out( N1 ) &lt;- in( B90 )  Freq: 2.31389e-06
0c70    #@ShouldNotReachHere

0c7c    B101: #	out( N1 ) &lt;- in( B64 )  Freq: 1.47661e-06
0c7c +  li R11, #-187	# int, #@loadConI
0c80    spill R30 -&gt; [sp, #16]	# spill size = 64
0c84 +  spill R10 -&gt; [sp, #12]	# spill size = 32
0c88 +  spill R10 -&gt; [sp, #24]	# spill size = 32
0c8c +  spill R9 -&gt; [sp, #32]	# spill size = 32
0c90 +  spill R9 -&gt; [sp, #36]	# spill size = 32
0c94    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:1 (line 4598) L[0]=sp + #36 L[1]=sp + #12 L[2]=R8 STK[0]=sp + #32
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #16 L[1]=sp + #32 L[2]=sp + #24 L[3]=R8 L[4]=_
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=sp + #16 L[1]=sp + #12 L[2]=_ L[3]=_
        # OopMap {[16]=Oop off=3224/0xc98}
0c98    #@ShouldNotReachHere

0ca4    B102: #	out( N1 ) &lt;- in( B79 )  Freq: 1.47655e-06
0ca4 +  spill [sp, #0] -&gt; R8	# spill size = 64
0ca8 +  spill [sp, #20] -&gt; [sp, #0]	# spill size = 32
0cb0 +  li R11, #-187	# int, #@loadConI
0cb4    spill R30 -&gt; [sp, #16]	# spill size = 64
0cb8 +  spill R30 -&gt; [sp, #24]	# spill size = 64
0cbc +  spill R28 -&gt; [sp, #4]	# spill size = 32
0cc0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #4
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=sp + #16 L[1]=#0
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #24 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop off=3268/0xcc4}
0cc4    #@ShouldNotReachHere

0cd0    B103: #	out( N1 ) &lt;- in( B82 )  Freq: 1.47655e-06
0cd0 +  spill [sp, #20] -&gt; [sp, #8]	# spill size = 32
0cd8 +  li R11, #-187	# int, #@loadConI
0cdc    spill R30 -&gt; [sp, #16]	# spill size = 64
0ce0 +  spill R12 -&gt; [sp, #12]	# spill size = 32
0ce4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.CharacterDataLatin1::isJavaIdentifierStart @ bci:14 (line 116) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8 STK[1]=#20480
        # java.lang.Character::isJavaIdentifierStart @ bci:5 (line 10070) L[0]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:28 (line 176) L[0]=sp + #16 L[1]=sp + #12 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=_
        # OopMap {[0]=Oop [16]=Oop off=3304/0xce8}
0ce8    #@ShouldNotReachHere

0cf4    B104: #	out( N1 ) &lt;- in( B56 )  Freq: 1.4748e-06
0cf4 +  li R11, #-187	# int, #@loadConI
0cf8    spill R9 -&gt; [sp, #12]	# spill size = 32
0cfc +  spill R17 -&gt; [sp, #16]	# spill size = 32
0d00    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #16
        # java.lang.String::indexOf @ bci:1 (line 2416) L[0]=sp + #0 L[1]=#46 L[2]=sp + #12
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=sp + #0 L[1]=_ L[2]=sp + #12 L[3]=_
        # OopMap {[0]=Oop off=3332/0xd04}
0d04    #@ShouldNotReachHere

0d10    B105: #	out( N1 ) &lt;- in( B71 )  Freq: 1.47029e-06
0d10 +  li R11, #-187	# int, #@loadConI
0d14    spill R10 -&gt; [sp, #0]	# spill size = 32
0d18 +  spill R30 -&gt; [sp, #8]	# spill size = 64
0d1c +  spill R9 -&gt; [sp, #4]	# spill size = 32
0d20 +  spill R13 -&gt; [sp, #16]	# spill size = 32
0d24 +  spill R7 -&gt; [sp, #20]	# spill size = 32
0d28    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #20
        # java.lang.String::substring @ bci:28 (line 2707) L[0]=sp + #8 L[1]=sp + #4 L[2]=_ L[3]=_ L[4]=sp + #16
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=sp + #8 L[1]=sp + #0 L[2]=_ L[3]=_
        # OopMap {[8]=Oop off=3372/0xd2c}
0d2c    #@ShouldNotReachHere

0d38    B106: #	out( N1 ) &lt;- in( B65 )  Freq: 1.40821e-06
0d38 +  li R11, #-187	# int, #@loadConI
0d3c    spill R30 -&gt; [sp, #16]	# spill size = 64
0d40 +  spill R10 -&gt; [sp, #12]	# spill size = 32
0d44 +  spill R10 -&gt; [sp, #24]	# spill size = 32
0d48 +  spill R9 -&gt; [sp, #36]	# spill size = 32
0d4c +  spill R9 -&gt; [sp, #40]	# spill size = 32
0d50    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:6 (line 4598) L[0]=sp + #40 L[1]=sp + #12 L[2]=R8 STK[0]=sp + #36 STK[1]=sp + #12
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #16 L[1]=sp + #36 L[2]=sp + #24 L[3]=R8 L[4]=_
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=sp + #16 L[1]=sp + #12 L[2]=_ L[3]=_
        # OopMap {[16]=Oop off=3412/0xd54}
0d54    #@ShouldNotReachHere

0d60    B107: #	out( N1 ) &lt;- in( B66 )  Freq: 1.40821e-06
0d60 +  li R11, #-187	# int, #@loadConI
0d64    spill R30 -&gt; [sp, #16]	# spill size = 64
0d68 +  spill R10 -&gt; [sp, #12]	# spill size = 32
0d6c +  spill R10 -&gt; [sp, #24]	# spill size = 32
0d70 +  spill R9 -&gt; [sp, #36]	# spill size = 32
0d74    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:11 (line 4598) L[0]=sp + #36 L[1]=sp + #12 L[2]=R8 STK[0]=sp + #12 STK[1]=R8
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #16 L[1]=sp + #36 L[2]=sp + #24 L[3]=R8 L[4]=_
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=sp + #16 L[1]=sp + #12 L[2]=_ L[3]=_
        # OopMap {[16]=Oop off=3448/0xd78}
0d78    #@ShouldNotReachHere

0d84    B108: #	out( N1 ) &lt;- in( B76 )  Freq: 1.40818e-06
0d84 +  li R11, #-187	# int, #@loadConI
0d88    spill R30 -&gt; [sp, #0]	# spill size = 64
0d8c +  spill R10 -&gt; [sp, #8]	# spill size = 32
0d90 +  spill R31 -&gt; [sp, #16]	# spill size = 64
0d94    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isEmpty @ bci:5 (line 1487) L[0]=_ STK[0]=R8
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=_
        # OopMap {[0]=Oop [16]=Oop off=3480/0xd98}
0d98    #@ShouldNotReachHere

0da4    B109: #	out( N1 ) &lt;- in( B78 )  Freq: 1.40815e-06
0da4 +  spill [sp, #0] -&gt; R8	# spill size = 64
0da8 +  li R11, #-187	# int, #@loadConI
0dac    spill R30 -&gt; [sp, #8]	# spill size = 64
0db0 +  spill R29 -&gt; [sp, #4]	# spill size = 32
0db4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::contains @ bci:17 (line 938) L[0]=_ L[1]=_ STK[0]=sp + #4
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=R8 L[1]=sp + #20 L[2]=_ L[3]=_
        # OopMap {fp=Oop [8]=Oop off=3512/0xdb8}
0db8    #@ShouldNotReachHere

0dc4    B110: #	out( N1 ) &lt;- in( B81 )  Freq: 1.40814e-06
0dc4 +  spill [sp, #0] -&gt; R8	# spill size = 64
0dc8 +  spill [sp, #20] -&gt; [sp, #0]	# spill size = 32
0dd0 +  li R11, #-187	# int, #@loadConI
0dd4    spill R30 -&gt; [sp, #16]	# spill size = 64
0dd8 +  spill R10 -&gt; [sp, #24]	# spill size = 64
0ddc +  spill R31 -&gt; [sp, #4]	# spill size = 32
0de0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:7 (line 47) L[0]=sp + #24 L[1]=#0 STK[0]=#0 STK[1]=sp + #4
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=sp + #16 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop off=3556/0xde4}
0de4    #@ShouldNotReachHere

0df0    B111: #	out( N1 ) &lt;- in( B58 )  Freq: 1.40647e-06
0df0 +  li R11, #-27	# int, #@loadConI
0df4    spill R28 -&gt; [sp, #16]	# spill size = 64
0df8 +  spill R9 -&gt; [sp, #12]	# spill size = 32
0dfc +  spill R9 -&gt; [sp, #24]	# spill size = 32
0e00    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::indexOf @ bci:13 (line 207) L[0]=sp + #16 L[1]=#46 L[2]=sp + #24 L[3]=R8 STK[0]=sp + #12
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=sp + #0 L[1]=_ L[2]=sp + #12 L[3]=_
        # OopMap {[0]=Oop [16]=Oop off=3588/0xe04}
0e04    #@ShouldNotReachHere

0e10    B112: #	out( N1 ) &lt;- in( B52 )  Freq: 1.17062e-06
0e10    #@ShouldNotReachHere

0e1c    B113: #	out( N1 ) &lt;- in( B53 )  Freq: 1.17062e-06
0e1c    #@ShouldNotReachHere

0e28    B114: #	out( N1 ) &lt;- in( B25 B24 )  Freq: 1.57183e-06
0e28 +  li R11, #-138	# int, #@loadConI
0e2c    spill R30 -&gt; R8	# spill size = 64
0e30 +  spill R12 -&gt; [sp, #0]	# spill size = 32
0e34    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:46 (line 180) L[0]=R8 L[1]=_ L[2]=#1 L[3]=_ STK[0]=#1 STK[1]=sp + #0
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop off=3640/0xe38}
0e38    #@ShouldNotReachHere

0e44    B115: #	out( N1 ) &lt;- in( B28 )  Freq: 7.80705e-07
0e44    #@ShouldNotReachHere

0e50    B116: #	out( N1 ) &lt;- in( B13 )  Freq: 6.33828e-07
0e50 +  li R11, #-10	# int, #@loadConI
0e54    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=3672/0xe58}
0e58    #@ShouldNotReachHere

0e64    B117: #	out( N1 ) &lt;- in( B2 )  Freq: 4.99999e-07
0e64 +  li R11, #-187	# int, #@loadConI
0e68    spill R30 -&gt; [sp, #0]	# spill size = 64
0e6c +  spill R17 -&gt; [sp, #8]	# spill size = 32
0e70    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #8
        # java.lang.String::indexOf @ bci:1 (line 2416) L[0]=sp + #0 L[1]=#46 L[2]=#0
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=sp + #0 L[1]=_ L[2]=#0 L[3]=_
        # OopMap {[0]=Oop off=3700/0xe74}
0e74    #@ShouldNotReachHere

0e80    B118: #	out( N1 ) &lt;- in( B7 )  Freq: 4.98204e-07
0e80 +  li R11, #-187	# int, #@loadConI
0e84    spill R30 -&gt; [sp, #0]	# spill size = 64
0e88 +  spill R9 -&gt; [sp, #12]	# spill size = 32
0e8c +  spill R9 -&gt; [sp, #16]	# spill size = 32
0e90    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:1 (line 4598) L[0]=sp + #16 L[1]=R8 L[2]=R8 STK[0]=sp + #12
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #0 L[1]=sp + #12 L[2]=R8 L[3]=R8 L[4]=_
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isTypeName @ bci:40 (line 136) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=3732/0xe94}
0e94    #@ShouldNotReachHere

0ea0    B119: #	out( N1 ) &lt;- in( B19 )  Freq: 4.98186e-07
0ea0 +  li R11, #-187	# int, #@loadConI
0ea4    spill R28 -&gt; [sp, #16]	# spill size = 32
0ea8    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #16
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=R8 L[1]=#0
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=R8 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop off=3756/0xeac}
0eac    #@ShouldNotReachHere

0eb8    B120: #	out( N1 ) &lt;- in( B22 )  Freq: 4.98185e-07
0eb8 +  li R11, #-187	# int, #@loadConI
0ebc    spill R30 -&gt; [sp, #0]	# spill size = 64
0ec0 +  spill R15 -&gt; [sp, #8]	# spill size = 32
0ec4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.CharacterDataLatin1::isJavaIdentifierStart @ bci:14 (line 116) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8 STK[1]=#20480
        # java.lang.Character::isJavaIdentifierStart @ bci:5 (line 10070) L[0]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:28 (line 176) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=3784/0xec8}
0ec8    #@ShouldNotReachHere

0ed4    B121: #	out( N1 ) &lt;- in( B4 )  Freq: 4.76836e-07
0ed4 +  li R11, #-187	# int, #@loadConI
0ed8    spill R30 -&gt; [sp, #0]	# spill size = 64
0edc +  spill R12 -&gt; [sp, #12]	# spill size = 32
0ee0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::indexOf @ bci:23 (line 209) L[0]=R8 L[1]=#46 L[2]=#0 L[3]=sp + #12 STK[0]=#0 STK[1]=sp + #12
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=sp + #0 L[1]=_ L[2]=#0 L[3]=_
        # OopMap {fp=Oop [0]=Oop off=3812/0xee4}
0ee4    #@ShouldNotReachHere

0ef0    B122: #	out( N1 ) &lt;- in( B8 )  Freq: 4.75124e-07
0ef0 +  li R11, #-187	# int, #@loadConI
0ef4    spill R30 -&gt; [sp, #0]	# spill size = 64
0ef8 +  spill R9 -&gt; [sp, #12]	# spill size = 32
0efc +  spill R9 -&gt; [sp, #16]	# spill size = 32
0f00    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkBoundsBeginEnd @ bci:6 (line 4598) L[0]=sp + #16 L[1]=R8 L[2]=R8 STK[0]=sp + #12 STK[1]=R8
        # java.lang.String::substring @ bci:8 (line 2702) L[0]=sp + #0 L[1]=sp + #12 L[2]=R8 L[3]=R8 L[4]=_
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isTypeName @ bci:40 (line 136) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=3844/0xf04}
0f04    #@ShouldNotReachHere

0f10    B123: #	out( N1 ) &lt;- in( B16 )  Freq: 4.75117e-07
0f10 +  li R11, #-187	# int, #@loadConI
0f14    spill R10 -&gt; [sp, #0]	# spill size = 64
0f18    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isEmpty @ bci:5 (line 1487) L[0]=_ STK[0]=R8
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {[0]=Oop off=3868/0xf1c}
0f1c    #@ShouldNotReachHere

0f28    B124: #	out( N1 ) &lt;- in( B18 )  Freq: 4.75107e-07
0f28 +  li R11, #-187	# int, #@loadConI
0f2c    spill R10 -&gt; [sp, #0]	# spill size = 32
0f30    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN::contains @ bci:17 (line 938) L[0]=_ L[1]=_ STK[0]=sp + #0
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:11 (line 172) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop off=3892/0xf34}
0f34    #@ShouldNotReachHere

0f40    B125: #	out( N1 ) &lt;- in( B21 )  Freq: 4.75106e-07
0f40 +  li R11, #-187	# int, #@loadConI
0f44    spill R13 -&gt; [sp, #8]	# spill size = 64
0f48 +  spill R31 -&gt; [sp, #16]	# spill size = 32
0f4c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:7 (line 47) L[0]=sp + #8 L[1]=#0 STK[0]=#0 STK[1]=sp + #16
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=R8 L[1]=#0 L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop [8]=Oop off=3920/0xf50}
0f50    #@ShouldNotReachHere

0f5c    B126: #	out( N1 ) &lt;- in( B39 )  Freq: 3.94966e-07
0f5c    #@ShouldNotReachHere

0f68    B127: #	out( N1 ) &lt;- in( B40 )  Freq: 3.94966e-07
0f68    #@ShouldNotReachHere

0f74    B128: #	out( N1 ) &lt;- in( B11 )  Freq: 3.12767e-07
0f74 +  li R11, #-187	# int, #@loadConI
0f78    spill R30 -&gt; R8	# spill size = 64
0f7c +  spill R9 -&gt; [sp, #0]	# spill size = 32
0f80 +  spill R13 -&gt; [sp, #4]	# spill size = 32
0f84 +  spill R17 -&gt; [sp, #8]	# spill size = 32
0f88    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #8
        # java.lang.String::substring @ bci:28 (line 2707) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_ L[4]=sp + #4
        # java.lang.String::substring @ bci:6 (line 2675) L[0]=_ L[1]=_
        # jdk.internal.module.Checks::isTypeName @ bci:40 (line 136) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {fp=Oop off=3980/0xf8c}
0f8c    #@ShouldNotReachHere

0f98    B129: #	out( B133 ) &lt;- in( B12 )  Freq: 6.25534e-06
0f98     -- 	// exception oop; no code emitted, #@CreateException
0f98 +  spill R10 -&gt; R11	# spill size = 64
0f9c +  j  B133	#@branch

0fa0    B130: #	out( B133 ) &lt;- in( B17 )  Freq: 9.96392e-06
0fa0     -- 	// exception oop; no code emitted, #@CreateException
0fa0 +  spill R10 -&gt; R11	# spill size = 64
0fa4 +  j  B133	#@branch

0fa8    B131: #	out( B133 ) &lt;- in( B77 )  Freq: 2.95316e-05
0fa8     -- 	// exception oop; no code emitted, #@CreateException
0fa8 +  spill R10 -&gt; R11	# spill size = 64
0fac +  j  B133	#@branch

0fb0    B132: #	out( B133 ) &lt;- in( B72 )  Freq: 2.94059e-05
0fb0     -- 	// exception oop; no code emitted, #@CreateException
0fb0 +  spill R10 -&gt; R11	# spill size = 64

0fb4    B133: #	out( N1 ) &lt;- in( B132 B131 B129 B130 )  Freq: 7.51567e-05
0fb4    # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
0fc0 +  j rethrow_stub	#@RethrowException

0fc8    B134: #	out( N1 ) &lt;- in( B63 )  Freq: 2.99245e-06
0fc8 +  li R11, #-10	# int, #@loadConI
0fcc    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::substring @ bci:1 (line 2701) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # jdk.internal.module.Checks::isTypeName @ bci:18 (line 131) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=4048/0xfd0}
0fd0    #@ShouldNotReachHere

0fdc    B135: #	out( N1 ) &lt;- in( B75 )  Freq: 2.99238e-06
0fdc +  li R11, #-10	# int, #@loadConI
0fe0    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::isEmpty @ bci:4 (line 1487) L[0]=_ STK[0]=#NULL
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=4068/0xfe4}
0fe4    #@ShouldNotReachHere

0ff0    B136: #	out( N1 ) &lt;- in( B80 )  Freq: 2.99231e-06
0ff0 +  li R11, #-10	# int, #@loadConI
0ff4    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::charAt @ bci:6 (line 47) L[0]=_ L[1]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:23 (line 132) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=4088/0xff8}
0ff8    #@ShouldNotReachHere

1004    B137: #	out( N1 ) &lt;- in( B57 )  Freq: 2.98876e-06
1004 +  li R11, #-10	# int, #@loadConI
1008    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::indexOf @ bci:10 (line 206) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=4108/0x100c}
100c    #@ShouldNotReachHere

1018    B138: #	out( N1 ) &lt;- in( B1 )  Freq: 1.01328e-06
1018 +  li R11, #-10	# int, #@loadConI
101c    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL STK[1]=#46 STK[2]=#0
        # OopMap {off=4128/0x1020}
1020    #@ShouldNotReachHere

102c    B139: #	out( N1 ) &lt;- in( B3 )  Freq: 1.01328e-06
102c +  li R11, #-10	# int, #@loadConI
1030    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::indexOf @ bci:10 (line 206) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.Checks::isTypeName @ bci:6 (line 130) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=4148/0x1034}
1034    #@ShouldNotReachHere

1040    B140: #	out( N1 ) &lt;- in( B15 )  Freq: 1.00962e-06
1040 +  li R11, #-10	# int, #@loadConI
1044    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::isEmpty @ bci:4 (line 1487) L[0]=_ STK[0]=#NULL
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:1 (line 172) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=4168/0x1048}
1048    #@ShouldNotReachHere

1054    B141: #	out( N1 ) &lt;- in( B20 )  Freq: 1.0096e-06
1054 +  li R11, #-10	# int, #@loadConI
1058    CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::charAt @ bci:6 (line 47) L[0]=_ L[1]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.Character::codePointAt @ bci:2 (line 8910) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isJavaIdentifier @ bci:23 (line 175) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # jdk.internal.module.Checks::isTypeName @ bci:45 (line 137) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # OopMap {off=4188/0x105c}
105c    #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='456'>
----------------------- MetaData before Compile_id = 456 ------------------------
{method}
 - this oop:          0x0000004096307e80
 - method holder:     &apos;jdk/internal/module/ModulePath&apos;
 - constants:         0x0000004096302d28 constant pool [1026]/operands[112] {0x0000004096302d28} for &apos;jdk/internal/module/ModulePath&apos; cache=0x0000004096308cb8
 - access:            0x81000002  private 
 - name:              &apos;toPackageName&apos;
 - signature:         &apos;(Ljava/nio/file/Path;Ljava/lang/String;)Ljava/util/Optional;&apos;
 - max stack:         4
 - max locals:        6
 - size of params:    3
 - method size:       13
 - highest level:     4
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x00000040083172b0: 0xbbb i2c: 0x0000004013944dc0 c2i: 0x0000004013944e0c c2iUV: 0x0000004013944dd8
 - compiled entry     0x000000400c5a9b40
 - code size:         133
 - code start:        0x0000004096307d90
 - code end (excl):   0x0000004096307e15
 - method data:       0x0000004096497c98
 - checked ex length: 0
 - linenumber start:  0x0000004096307e15
 - localvar length:   7
 - localvar start:    0x0000004096307e28
 - compiled code: nmethod  18975  437       3       jdk.internal.module.ModulePath::toPackageName (133 bytes)

------------------------ OptoAssembly for Compile_id = 456 -----------------------
#
#  java/util/Optional:exact * ( jdk/internal/module/ModulePath:NotNull *, java/nio/file/Path *, java/lang/String:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: jdk/internal/module/ModulePath:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/nio/file/Path *
#r016 c_rarg3:c_rarg3   : parm 2: java/lang/String:exact *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1413: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B123 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
03c     spill R13 -&gt; [sp, #0]	# spill size = 64
040     lwu  R28, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
044     NullCheck R12

044     B2: #	out( B108 B3 ) &lt;- in( B1 )  Freq: 0.999999
044 +   mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d08862d0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
054 +   bne  R28, R7, B108	#@cmpN_branch  P=0.000001 C=-1.000000

058     B3: #	out( B146 B4 ) &lt;- in( B2 )  Freq: 0.999998
058 +   # checkcastPP of R12, #@checkCastPP
058     spill R12 -&gt; [sp, #8]	# spill size = 64
05c +   spill R12 -&gt; R11	# spill size = 64
060 +   spill R12 -&gt; R8	# spill size = 64
064     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 276) L[0]=R8 L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=R8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=104/0x68}

068     B4: #	out( B124 B5 ) &lt;- in( B3 )  Freq: 0.999978
        # Block is sole successor of call
068 +   lwu  R28, [R8, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
06c +   #@membar_acquire
	fence ir iorw
070 +   decode_heap_oop  R7, R28	#@decodeHeapOop
074     lwu  R30, [R7, #12]	# range, #@loadRange
078     NullCheck R7

078     B5: #	out( B117 B6 ) &lt;- in( B4 )  Freq: 0.999977
078 +   bleu  R30, zr, B117	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=5375.000000

07c     B6: #	out( B125 B7 ) &lt;- in( B5 )  Freq: 0.999976
07c +   lwu  R7, [R8, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
080 +   decode_heap_oop  R31, R7	#@decodeHeapOop
084 +   addw  R28, R30, zr	#@convI2L_reg_reg
088 +   #@membar_acquire
	fence ir iorw
08c +   slli  R7, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
090 +   addiw  R8, R30, #-1	#@addI_reg_imm
094     lwu  R29, [R31, #12]	# range, #@loadRange
098     NullCheck R31

098     B7: #	out( B104 B8 ) &lt;- in( B6 )  Freq: 0.999975
098 +   add R7, R31, R7	# ptr, #@addP_reg_reg
09c +   bgeu  R8, R29, B104	#@cmpU_branch  P=0.000001 C=-1.000000

0a0     B8: #	out( B68 B9 ) &lt;- in( B7 )  Freq: 0.999974
0a0 +   spill [sp, #8] -&gt; R28	# spill size = 64
0a4 +   lwu  R28, [R28, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
0a8 +   lw  R8, [R7, #12]	# int, #@loadI
0ac +   decode_heap_oop  R31, R28	#@decodeHeapOop
0b0 +   addiw  R28, R8, #-1	#@addI_reg_imm
0b4 +   ble  R28, zr, B68	#@cmpI_reg_imm0_branch  P=0.001488 C=5375.000000

0b8     B9: #	out( B105 B10 ) &lt;- in( B8 )  Freq: 0.998486
0b8 +   li R29, #1048576	# int, #@loadConI
0bc +   bgtu  R28, R29, B105	#@cmpU_branch  P=0.000001 C=-1.000000

0c0     B10: #	out( B11 ) &lt;- in( B9 )  Freq: 0.998485
0c0 +   addw  R7, R8, zr	#@convI2L_reg_reg
0c4 +   addi  R7, R7, #-1	#@addL_reg_imm

0c8     B11: #	out( B126 B12 ) &lt;- in( B10 B105 )  Freq: 0.998486
0c8     lwu  R30, [R31, #12]	# range, #@loadRange
0cc     NullCheck R31

0cc     B12: #	out( B109 B13 ) &lt;- in( B11 )  Freq: 0.998485
0cc +   addi  R10, R7, #23	#@addL_reg_imm
0d0 +   bltu  R30, R28, B109	#@cmpU_branch  P=0.000001 C=-1.000000

0d4     B13: #	out( B89 B14 ) &lt;- in( B12 )  Freq: 0.998484
0d4 +   andi  R12, R10, #-8	#@andL_reg_imm
0d8 +   bgtu  R28, R29, B89	#@cmpU_branch  P=0.000001 C=-1.000000

0dc     B14: #	out( B89 B15 ) &lt;- in( B13 )  Freq: 0.998483
0dc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0dc     ld  R9, [R23, #288]	# ptr, #@loadP
0e0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e0     ld  R29, [R23, #304]	# ptr, #@loadP
0e4 +   add R7, R9, R12	# ptr, #@addP_reg_reg
0e8 +   bgeu  R7, R29, B89	#@cmpP_branch  P=0.000100 C=-1.000000

0ec     B15: #	out( B16 ) &lt;- in( B14 )  Freq: 0.998383
0ec +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0ec     sd  R7, [R23, #288]	# ptr, #@storeP
0f0 +   li R7, #1	# long, #@loadConL
0f4 +   mv  R29, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
104 +   sd  R7, [R9]	# long, #@storeL
108 +   sw  R29, [R9, #8]	# compressed klass ptr, #@storeNKlass
10c +   sw  R28, [R9, #12]	# int, #@storeI

110     B16: #	out( B106 B17 ) &lt;- in( B90 B15 )  Freq: 0.998484
110     
110 +   li R30, #1	# int, #@loadConI
114 +   srli  R7, R10, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
118 +   # checkcastPP of R9, #@checkCastPP
118     addi  R11, R9, #16	# ptr, #@addP_reg_imm
11c +   encode_heap_oop  R19, R9	#@encodeHeapOop
120 +   # castII of R8, #@castII
120     beq  R8, R30, B106	#@cmpI_branch  P=0.000001 C=-1.000000

124     B17: #	out( B78 B18 ) &lt;- in( B16 )  Freq: 0.998483
124 +   addiw  R29, R8, #-1	#@addI_reg_imm
128 +   addi  R10, R31, #16	# ptr, #@addP_reg_imm
12c +   blt  R29, R28, B78	#@cmpI_branch  P=0.001000 C=-1.000000

130     B18: #	out( B19 ) &lt;- in( B17 )  Freq: 0.997485
130 +   addi  R7, R12, #-16	#@addL_reg_imm
134 +   srli  R12, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
138 +   CALL, runtime leaf nofp 0x000000401396d840	#@CallLeafNoFPDirect jlong_disjoint_arraycopy
        No JVM State Info
        # 

13c     B19: #	out( B87 B20 ) &lt;- in( B78 B18 B106 )  Freq: 0.998484
13c     MEMBAR-store-store	#@membar_storestore
140 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
140     ld  R12, [R23, #288]	# ptr, #@loadP
144 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
144     ld  R7, [R23, #304]	# ptr, #@loadP
148 +   addi  R28, R12, #32	# ptr, #@addP_reg_imm
14c +   bgeu  R28, R7, B87	#@cmpP_branch  P=0.000100 C=-1.000000

150     B20: #	out( B21 ) &lt;- in( B19 )  Freq: 0.998384
150 +   li R7, #1	# long, #@loadConL
154 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
154     sd  R28, [R23, #288]	# ptr, #@storeP
158 +   sd  R7, [R12]	# long, #@storeL
15c +   mv  R7, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d08862d0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
16c +   sw  R7, [R12, #8]	# compressed klass ptr, #@storeNKlass
170 +   sw  zr, [R12, #12]	# int, #@storeimmI0
174 +   sw  zr, [R12, #16]	# int, #@storeimmI0
178 +   sd  zr, [R12, #24]	# long, #@storeimmL0

17c     B21: #	out( B22 ) &lt;- in( B88 B20 )  Freq: 0.998484
17c +   sw  R19, [R12, #20]	# compressed ptr, #@storeN
180     
180     spill [sp, #8] -&gt; R7	# spill size = 64
184 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
188 +   # checkcastPP of R12, #@checkCastPP
188     sw  R28, [R12, #16]	# compressed ptr, #@storeN ! Field: sun/nio/fs/UnixPath.fs

18c     B22: #	out( B53 B23 ) &lt;- in( B74 B21 )  Freq: 0.999972
18c +   mv  R31, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
19c +   # checkcastPP of R12, #@checkCastPP
19c     beq   R12, zr, B53	#@cmpP_imm0_branch  P=0.013055 C=10494.000000

1a0     B23: #	out( B110 B24 ) &lt;- in( B22 )  Freq: 0.986918
1a0 +   lwu  R7, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
1a4 +   mv  R29, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d08862d0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1b4 +   bne  R7, R29, B110	#@cmpN_branch  P=0.000001 C=-1.000000

1b8     B24: #	out( B111 B25 ) &lt;- in( B23 )  Freq: 0.986917
1b8 +   # checkcastPP of R12, #@checkCastPP
1b8     lwu  R7, [R12, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
1bc +   #@membar_acquire
	fence ir iorw
1c0 +   decode_heap_oop  R8, R7	#@decodeHeapOop
1c4 +   bne   R8, zr, B111	#@cmpP_imm0_branch  P=0.000000 C=10534.000000

1c8     B25: #	out( B91 B26 ) &lt;- in( B24 )  Freq: 0.986916
1c8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1c8     ld  R10, [R23, #288]	# ptr, #@loadP
1cc +   lwu  R7, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
1d0 +   lwu  R28, [R12, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
1d4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1d4     ld  R29, [R23, #304]	# ptr, #@loadP
1d8 +   addi  R30, R10, #24	# ptr, #@addP_reg_imm
1dc +   decode_heap_oop  R13, R7	#@decodeHeapOop
1e0 +   decode_heap_oop  R8, R28	#@decodeHeapOop
1e4 +   bgeu  R30, R29, B91	#@cmpP_branch  P=0.000100 C=-1.000000

1e8     B26: #	out( B27 ) &lt;- in( B25 )  Freq: 0.986818
1e8 +   li R7, #1	# long, #@loadConL
1ec +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ec     sd  R30, [R23, #288]	# ptr, #@storeP
1f0 +   sd  R7, [R10]	# long, #@storeL
1f4 +   sw  R31, [R10, #8]	# compressed klass ptr, #@storeNKlass
1f8 +   sw  zr, [R10, #12]	# int, #@storeimmI0
1fc +   sd  zr, [R10, #16]	# long, #@storeimmL0

200     B27: #	out( B127 B28 ) &lt;- in( B92 B26 )  Freq: 0.986916
200     
200 +   MEMBAR-store-store	#@membar_storestore
204 +   # checkcastPP of R10, #@checkCastPP
204     lwu  R14, [R13, #12]	# range, #@loadRange
208     NullCheck R13

208     B28: #	out( B148 B29 ) &lt;- in( B27 )  Freq: 0.986915
208 +   spill R12 -&gt; [sp, #8]	# spill size = 64
20c +   spill R13 -&gt; R12	# spill size = 64
210 +   spill R10 -&gt; [sp, #16]	# spill size = 64
214 +   li R13, #0	# int, #@loadConI
218     spill R10 -&gt; R11	# spill size = 64
21c +   mv  R15, sun/nio/cs/UTF_8:exact *	# ptr, #@loadConP
234     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.String::&lt;init&gt;
        # java.lang.String::&lt;init&gt; @ bci:6 (line 1380) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.Util::toString @ bci:8 (line 63) L[0]=_ STK[0]=sp + #16
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=sp + #8 STK[0]=sp + #8 STK[1]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=568/0x238}

238     B29: #	out( B107 B30 ) &lt;- in( B28 )  Freq: 0.986895
        # Block is sole successor of call
238 +   beq   R8, zr, B107	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

23c     B30: #	out( B79 B31 ) &lt;- in( B29 )  Freq: 0.986894
23c +   #@membar_release
	fence iorw ow
240 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
240     lb  R7, [R23, #56]	# byte, #@loadB
244 +   bne  R7, zr, B79	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

248     B31: #	out( B32 ) &lt;- in( B30 )  Freq: 0.985908
248 +   spill [sp, #8] -&gt; R9	# spill size = 64

24c     B32: #	out( B34 B33 ) &lt;- in( B116 B81 B79 B31 )  Freq: 0.986894
24c +   mv  R7, R9	# ptr -&gt; long, #@castP2X
250     spill [sp, #16] -&gt; R29	# spill size = 64
254 +   mv  R28, R29	# ptr -&gt; long, #@castP2X
258 +   xorr  R28, R28, R7	#@xorL_reg_reg
25c +   encode_heap_oop  R30, R29	#@encodeHeapOop
260 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
264 +   sw  R30, [R9, #24]	# compressed ptr, #@storeN ! Field: volatile sun/nio/fs/UnixPath.stringValue
268 +   beq  R28, zr, B34	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

26c     B33: #	out( B82 B34 ) &lt;- in( B32 )  Freq: 0.985908
26c +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
270 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
27c +   add R10, R28, R7	# ptr, #@addP_reg_reg
280 +   lb  R7, [R10]	# byte, #@loadB
284 +   li R28, #4	# int, #@loadConI
288 +   bne  R7, R28, B82	#@cmpI_branch  P=0.001000 C=-1.000000

28c     B34: #	out( B128 B35 ) &lt;- in( B84 B85 B82 B33 B32 )  Freq: 0.986894
28c +   #@membar_volatile
	fence iorw iorw
290 +   lwu  R28, [R9, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
294 +   decode_heap_oop  R7, R28	#@decodeHeapOop
298 +   #@membar_acquire
	fence ir iorw
29c     spill R7 -&gt; [sp, #8]	# spill size = 64
2a0     lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
2a4     NullCheck R7

2a4     B35: #	out( B129 B36 ) &lt;- in( B34 )  Freq: 0.986893
2a4 +   spill [sp, #0] -&gt; R28	# spill size = 64
2a8     lwu  R29, [R28, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
2ac     NullCheck R28

2ac     B36: #	out( B130 B37 ) &lt;- in( B35 )  Freq: 0.986892
2ac +   decode_heap_oop  R11, R7	#@decodeHeapOop
2b0 +   decode_heap_oop  R30, R29	#@decodeHeapOop
2b4     lwu  R7, [R11, #12]	# range, #@loadRange
2b8     NullCheck R11

2b8     B37: #	out( B131 B38 ) &lt;- in( B36 )  Freq: 0.986891
2b8 +   spill [sp, #8] -&gt; R29	# spill size = 64
2bc +   lb  R31, [R29, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
2c0 +   sraw  R7, R7, R31	#@rShiftI_reg_reg
2c4     lwu  R12, [R30, #12]	# range, #@loadRange
2c8     NullCheck R30

2c8     B38: #	out( B112 B39 ) &lt;- in( B37 )  Freq: 0.98689
2c8 +   lb  R13, [R28, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
2cc +   sraw  R8, R12, R13	#@rShiftI_reg_reg
2d0 +   ble  R8, zr, B112	#@cmpI_reg_imm0_branch  P=0.000000 C=5376.000000

2d4     B39: #	out( B113 B40 ) &lt;- in( B38 )  Freq: 0.98689
2d4 +   li R29, #1	# int, #@loadConI
2d8 +   bne  R8, R29, B113	#@cmpI_branch  P=0.000000 C=5376.000000

2dc     B40: #	out( B114 B41 ) &lt;- in( B39 )  Freq: 0.98689
2dc +   bne  R13, zr, B114	#@cmpI_reg_imm0_branch  P=0.000000 C=93736.000000

2e0     B41: #	out( B118 B42 ) &lt;- in( B40 )  Freq: 0.986889
2e0 +   bleu  R12, zr, B118	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=39572.000000

2e4     B42: #	out( B119 B43 ) &lt;- in( B41 )  Freq: 0.986889
2e4 +   lbu  R12, [R30, #16]	# byte, #@loadUB
2e8 +   li R13, #46	# int, #@loadConI
2ec +   beq  R12, R13, B119	#@cmpI_branch  P=0.000000 C=5376.000000

2f0     B43: #	out( B115 B44 ) &lt;- in( B42 )  Freq: 0.986888
2f0 +   bne  R31, zr, B115	#@cmpI_reg_imm0_branch  P=0.000000 C=93736.000000

2f4     B44: #	out( B150 B45 ) &lt;- in( B43 )  Freq: 0.986888
2f4     CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringLatin1::replace
        # java.lang.String::replace @ bci:18 (line 2801) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_
        # java.lang.String::replace @ bci:63 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {[8]=Oop off=760/0x2f8}

2f8     B45: #	out( B86 B46 ) &lt;- in( B44 )  Freq: 0.986868
        # Block is sole successor of call
2f8 +   beq   R10, zr, B86	#@cmpP_imm0_branch  P=0.000744 C=5376.000000

2fc     B46: #	out( B47 ) &lt;- in( B45 )  Freq: 0.986134
2fc +   spill R10 -&gt; R8	# spill size = 64

300     B47: #	out( B151 B48 ) &lt;- in( B46 B86 )  Freq: 0.986868
300 +   spill R8 -&gt; R11	# spill size = 64
304     CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect jdk.internal.module.Checks::isTypeName
        # jdk.internal.module.Checks::isPackageName @ bci:1 (line 79) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:117 (line 757) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=776/0x308}

308     B48: #	out( B67 B49 ) &lt;- in( B47 )  Freq: 0.986848
        # Block is sole successor of call
308 +   beq  R10, zr, B67	#@cmpI_reg_imm0_branch  P=0.001545 C=10357.000000

30c     B49: #	out( B93 B50 ) &lt;- in( B48 )  Freq: 0.985324
30c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
30c     ld  R10, [R23, #288]	# ptr, #@loadP
310 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
310     ld  R7, [R23, #304]	# ptr, #@loadP
314 +   addi  R28, R10, #16	# ptr, #@addP_reg_imm
318 +   bgeu  R28, R7, B93	#@cmpP_branch  P=0.000100 C=-1.000000

31c     B50: #	out( B51 ) &lt;- in( B49 )  Freq: 0.985225
31c +   li R7, #1	# long, #@loadConL
320 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
320     sd  R28, [R23, #288]	# ptr, #@storeP
324 +   sd  R7, [R10]	# long, #@storeL
328 +   mv  R7, narrowklass: precise klass java/util/Optional: 0x00000040d08855e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
338 +   sw  R7, [R10, #8]	# compressed klass ptr, #@storeNKlass
33c +   sw  zr, [R10, #12]	# int, #@storeimmI0

340     B51: #	out( B52 ) &lt;- in( B94 B50 )  Freq: 0.985324
340 +   encode_heap_oop  R28, R8	#@encodeHeapOop
344     
344 +   # checkcastPP of R10, #@checkCastPP
344     sw  R28, [R10, #12]	# compressed ptr, #@storeN ! Field: java/util/Optional.value
348 +   #@membar_release
	fence iorw ow

34c     B52: #	out( N1413 ) &lt;- in( B51 B67 )  Freq: 0.999902
34c     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
364 +   ret	// return register, #@Ret

368     B53: #	out( B121 B54 ) &lt;- in( B22 )  Freq: 0.0130547
368 +   spill [sp, #8] -&gt; R7	# spill size = 64
36c +   lwu  R28, [R7, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
370 +   #@membar_acquire
	fence ir iorw
374 +   decode_heap_oop  R8, R28	#@decodeHeapOop
378 +   bne   R8, zr, B121	#@cmpP_imm0_branch  P=0.000000 C=10534.000000

37c     B54: #	out( B102 B55 ) &lt;- in( B53 )  Freq: 0.0130547
37c +   spill [sp, #8] -&gt; R28	# spill size = 64
380 +   lwu  R29, [R28, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
384 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
384     ld  R10, [R23, #288]	# ptr, #@loadP
388 +   lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
38c +   decode_heap_oop  R8, R29	#@decodeHeapOop
390 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
390     ld  R28, [R23, #304]	# ptr, #@loadP
394 +   addi  R30, R10, #24	# ptr, #@addP_reg_imm
398 +   decode_heap_oop  R29, R7	#@decodeHeapOop
39c +   bgeu  R30, R28, B102	#@cmpP_branch  P=0.000100 C=-1.000000

3a0     B55: #	out( B56 ) &lt;- in( B54 )  Freq: 0.0130534
3a0 +   li R7, #1	# long, #@loadConL
3a4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3a4     sd  R30, [R23, #288]	# ptr, #@storeP
3a8 +   sd  R7, [R10]	# long, #@storeL
3ac +   sw  R31, [R10, #8]	# compressed klass ptr, #@storeNKlass
3b0 +   sw  zr, [R10, #12]	# int, #@storeimmI0
3b4 +   sd  zr, [R10, #16]	# long, #@storeimmL0

3b8     B56: #	out( B132 B57 ) &lt;- in( B103 B55 )  Freq: 0.0130547
3b8     
3b8 +   MEMBAR-store-store	#@membar_storestore
3bc +   spill R10 -&gt; R7	# spill size = 64
3c0 +   # checkcastPP of R7, #@checkCastPP
3c0     lwu  R14, [R29, #12]	# range, #@loadRange
3c4     NullCheck R29

3c4     B57: #	out( B144 B58 ) &lt;- in( B56 )  Freq: 0.0130547
3c4 +   spill R7 -&gt; [sp, #16]	# spill size = 64
3c8 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
3d0 +   spill [sp, #16] -&gt; R11	# spill size = 64
3d4 +   li R13, #0	# int, #@loadConI
3d8     spill R29 -&gt; R12	# spill size = 64
3dc +   mv  R15, sun/nio/cs/UTF_8:exact *	# ptr, #@loadConP
3f4     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.String::&lt;init&gt;
        # java.lang.String::&lt;init&gt; @ bci:6 (line 1380) L[0]=_ L[1]=_ L[2]=_
        # sun.nio.fs.Util::toString @ bci:8 (line 63) L[0]=_ STK[0]=sp + #16
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=sp + #0 STK[0]=sp + #0 STK[1]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:35 (line 747) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=1016/0x3f8}

3f8     B58: #	out( B120 B59 ) &lt;- in( B57 )  Freq: 0.0130544
        # Block is sole successor of call
3f8 +   beq   R8, zr, B120	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

3fc     B59: #	out( B95 B60 ) &lt;- in( B58 )  Freq: 0.0130544
3fc +   #@membar_release
	fence iorw ow
400 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
400     lb  R7, [R23, #56]	# byte, #@loadB
404 +   bne  R7, zr, B95	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

408     B60: #	out( B61 ) &lt;- in( B59 )  Freq: 0.0130414
408 +   spill [sp, #0] -&gt; R9	# spill size = 64

40c     B61: #	out( B63 B62 ) &lt;- in( B122 B97 B95 B60 )  Freq: 0.0130544
40c +   mv  R28, R9	# ptr -&gt; long, #@castP2X
410     spill [sp, #16] -&gt; R29	# spill size = 64
414 +   mv  R7, R29	# ptr -&gt; long, #@castP2X
418 +   xorr  R7, R7, R28	#@xorL_reg_reg
41c +   encode_heap_oop  R30, R29	#@encodeHeapOop
420 +   srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
424 +   sw  R30, [R9, #24]	# compressed ptr, #@storeN ! Field: volatile sun/nio/fs/UnixPath.stringValue
428 +   beq  R7, zr, B63	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

42c     B62: #	out( B98 B63 ) &lt;- in( B61 )  Freq: 0.0130414
42c +   srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
430 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
43c +   add R10, R28, R7	# ptr, #@addP_reg_reg
440 +   lb  R7, [R10]	# byte, #@loadB
444 +   li R29, #4	# int, #@loadConI
448 +   bne  R7, R29, B98	#@cmpI_branch  P=0.001000 C=-1.000000

44c     B63: #	out( B133 B64 ) &lt;- in( B100 B101 B98 B62 B61 )  Freq: 0.0130544
44c +   #@membar_volatile
	fence iorw iorw
450 +   lwu  R28, [R9, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
454 +   #@membar_acquire
	fence ir iorw
458 +   decode_heap_oop  R8, R28	#@decodeHeapOop
45c     lwu  R7, [R8, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
460     NullCheck R8

460     B64: #	out( B134 B65 ) &lt;- in( B63 )  Freq: 0.0130544
460 +   decode_heap_oop  R7, R7	#@decodeHeapOop
464     lwu  R28, [R7, #12]	# range, #@loadRange
468     NullCheck R7

468     B65: #	out( B143 B66 ) &lt;- in( B64 )  Freq: 0.0130544
468 +   lb  R7, [R8, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
46c +   sraw  R28, R28, R7	#@rShiftI_reg_reg
470 +   addiw  R13, R28, #-6	#@addI_reg_imm
474 +   mv  R12, java/lang/String:exact *	# ptr, #@loadConP
48c     spill R8 -&gt; R11	# spill size = 64
490     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.String::startsWith
        # java.lang.String::endsWith @ bci:11 (line 2310) L[0]=_ L[1]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:47 (line 748) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=1172/0x494}

494     B66: #	out( B75 B67 ) &lt;- in( B65 )  Freq: 0.0130541
        # Block is sole successor of call
494 +   bne  R10, zr, B75	#@cmpI_reg_imm0_branch  P=0.109489 C=137.000000

498     B67: #	out( B52 ) &lt;- in( B48 B76 B66 )  Freq: 0.0145786
498 +   mv  R10, java/util/Optional:exact *	# ptr, #@loadConP
4b0 +   j  B52	#@branch

4b4     B68: #	out( B135 B69 ) &lt;- in( B8 )  Freq: 0.00148835
4b4     lwu  R7, [R31, #12]	# range, #@loadRange
4b8     NullCheck R31

4b8     B69: #	out( B73 B70 ) &lt;- in( B68 )  Freq: 0.00148835
4b8 +   bleu  R7, zr, B73	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.500000 C=-1.000000

4bc     B70: #	out( B73 B71 ) &lt;- in( B69 )  Freq: 0.000744174
4bc +   lb  R28, [R31, #16]	# byte, #@loadB
4c0 +   li R7, #47	# int, #@loadConI
4c4 +   bne  R28, R7, B73	#@cmpI_branch  P=0.900000 C=-1.000000

4c8     B71: #	out( B136 B72 ) &lt;- in( B70 )  Freq: 7.44174e-05
4c8 +   spill [sp, #8] -&gt; R7	# spill size = 64
4cc +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
4d0 +   decode_heap_oop  R7, R28	#@decodeHeapOop
4d4     lwu  R7, [R7, #24]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileSystem.rootDirectory
4d8     NullCheck R7

4d8     B72: #	out( B74 ) &lt;- in( B71 )  Freq: 7.44173e-05
4d8 +   decode_heap_oop  R7, R7	#@decodeHeapOop
4dc +   j  B74	#@branch

4e0     B73: #	out( B74 ) &lt;- in( B70 B69 )  Freq: 0.00141393
4e0 +   mv  R7, NULL	# NULL ptr, #@loadConP0

4e4     B74: #	out( B22 ) &lt;- in( B72 B73 )  Freq: 0.00148835
4e4     spill R7 -&gt; R12	# spill size = 64
4e8 +   j  B22	#@branch

4ec     B75: #	out( B142 B76 ) &lt;- in( B66 )  Freq: 0.00142929
4ec +   mv  R12, java/lang/String:exact *	# ptr, #@loadConP
504     spill R8 -&gt; R11	# spill size = 64
508     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.String::equals
        # jdk.internal.module.ModulePath::toPackageName @ bci:57 (line 748) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=1292/0x50c}

50c     B76: #	out( B67 B77 ) &lt;- in( B75 )  Freq: 0.00142926
        # Block is sole successor of call
50c +   bne  R10, zr, B67	#@cmpI_reg_imm0_branch  P=0.999999 C=-1.000000

510     B77: #	out( N1413 ) &lt;- in( B76 )  Freq: 1.44824e-09
510 +   li R11, #238	# int, #@loadConI
514     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos; index=&apos;238&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:63 (line 749) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=R8 L[5]=_
        # OopMap {fp=Oop off=1304/0x518}
518     #@ShouldNotReachHere

524     B78: #	out( B19 ) &lt;- in( B17 )  Freq: 0.000998483
524 +   addw  R30, R8, zr	#@convI2L_reg_reg
528 +   addi  R28, R30, #15	#@addL_reg_imm
52c +   srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
530 +   andi  R28, R28, #-8	#@andL_reg_imm
534 +   add R28, R9, R28	# ptr, #@addP_reg_reg
538 +   sub  R29, R7, R29	#@subL_reg_reg
53c     ClearArray R29, R28	#@clearArray_reg_reg
594 +   addi  R12, R30, #-1	#@addL_reg_imm
598     CALL, runtime leaf nofp 0x000000401396cf00	#@CallLeafNoFPDirect arrayof_jbyte_disjoint_arraycopy
        No JVM State Info
        # 
59c +   j  B19	#@branch

5a0     B79: #	out( B32 B80 ) &lt;- in( B30 )  Freq: 0.000986882
5a0 +   spill [sp, #8] -&gt; R9	# spill size = 64
5a4 +   lwu  R28, [R9, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
5a8 +   decode_heap_oop  R10, R28	#@decodeHeapOop
5ac +   beq   R10, zr, B32	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

5b0     B80: #	out( B116 B81 ) &lt;- in( B79 )  Freq: 0.000493441
5b0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5b0     ld  R7, [R23, #32]	# int, #@loadL
5b4 +   beq  R7, zr, B116	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

5b8     B81: #	out( B32 ) &lt;- in( B80 )  Freq: 0.000492947
5b8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5b8     ld  R28, [R23, #48]	# ptr, #@loadP
5bc +   add R28, R28, R7	# ptr, #@addP_reg_reg
5c0 +   addi  R7, R7, #-8	#@addL_reg_imm
5c4 +   sd  R10, [R28, #-8]	# ptr, #@storeP
5c8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5c8     sd  R7, [R23, #32]	# long, #@storeL
5cc +   j  B32	#@branch

5d0     B82: #	out( B34 B83 ) &lt;- in( B33 )  Freq: 0.000985908
5d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5d0     ld  R7, [R23, #64]	# int, #@loadL
5d4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5d4     ld  R28, [R23, #80]	# ptr, #@loadP
5d8 +   #@membar_volatile
	fence iorw iorw
5dc +   lb  R30, [R10]	# byte, #@loadB
5e0 +   beq  R30, zr, B34	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

5e4     B83: #	out( B85 B84 ) &lt;- in( B82 )  Freq: 0.000492954
5e4 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
5e8 +   bne  R7, zr, B85	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

5ec     B84: #	out( B34 ) &lt;- in( B83 )  Freq: 0.000246477
5ec +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5ec     spill R23 -&gt; R11	# spill size = 64
5f0 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
620 +   j  B34	#@branch

624     B85: #	out( B34 ) &lt;- in( B83 )  Freq: 0.000246477
624 +   add R28, R28, R7	# ptr, #@addP_reg_reg
628 +   addi  R7, R7, #-8	#@addL_reg_imm
62c +   sd  R10, [R28, #-8]	# ptr, #@storeP
630 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
630     sd  R7, [R23, #64]	# long, #@storeL
634 +   j  B34	#@branch

638     B86: #	out( B47 ) &lt;- in( B45 )  Freq: 0.000734274
638 +   spill [sp, #8] -&gt; R8	# spill size = 64
63c +   j  B47	#@branch

640     B87: #	out( B140 B88 ) &lt;- in( B19 )  Freq: 9.9865e-05
640 +   spill R19 -&gt; [sp, #24]	# spill size = 32
644 +   spill R9 -&gt; [sp, #16]	# spill size = 64
648 +   spill [sp, #8] -&gt; R8	# spill size = 64
64c +   mv  R11, precise klass sun/nio/fs/UnixPath: 0x00000040d08862d0:Constant:exact *	# ptr, #@loadConP
664     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.UnixPath::getParent @ bci:51 (line 290) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #16
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=R8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=NarrowOop off=1640/0x668}

668     B88: #	out( B21 ) &lt;- in( B87 )  Freq: 9.9863e-05
        # Block is sole successor of call
668 +   spill [sp, #24] -&gt; R19	# spill size = 32
66c +   spill R10 -&gt; R12	# spill size = 64
670 +   j  B21	#@branch

674     B89: #	out( B141 B90 ) &lt;- in( B13 B14 )  Freq: 0.000100877
674 +   spill R12 -&gt; [sp, #40]	# spill size = 64
678 +   spill R10 -&gt; [sp, #32]	# spill size = 64
67c +   spill R31 -&gt; [sp, #24]	# spill size = 64
680 +   spill R28 -&gt; [sp, #16]	# spill size = 32
684 +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
69c     spill R28 -&gt; R12	# spill size = 32
6a0     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=sp + #8 L[1]=_ L[2]=sp + #16 L[3]=_
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=sp + #8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {[0]=Oop [8]=Oop [24]=Oop off=1700/0x6a4}

6a4     B90: #	out( B16 ) &lt;- in( B89 )  Freq: 0.000100875
        # Block is sole successor of call
6a4 +   spill R10 -&gt; R9	# spill size = 64
6a8 +   spill [sp, #16] -&gt; R28	# spill size = 32
6ac +   spill [sp, #24] -&gt; R31	# spill size = 64
6b0 +   spill [sp, #32] -&gt; R10	# spill size = 64
6b4 +   spill [sp, #40] -&gt; R12	# spill size = 64
6b8 +   j  B16	#@branch

6bc     B91: #	out( B139 B92 ) &lt;- in( B25 )  Freq: 9.8708e-05
6bc +   spill R13 -&gt; [sp, #16]	# spill size = 64
6c0 +   spill R12 -&gt; [sp, #8]	# spill size = 64
6c4 +   mv  R11, precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# ptr, #@loadConP
6dc     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.Util::toString @ bci:0 (line 63) L[0]=sp + #16
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=sp + #8 STK[0]=sp + #8 STK[1]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=1760/0x6e0}

6e0     B92: #	out( B27 ) &lt;- in( B91 )  Freq: 9.8706e-05
        # Block is sole successor of call
6e0 +   spill [sp, #8] -&gt; R12	# spill size = 64
6e4 +   spill [sp, #16] -&gt; R13	# spill size = 64
6e8 +   j  B27	#@branch

6ec     B93: #	out( B138 B94 ) &lt;- in( B49 )  Freq: 9.85487e-05
6ec +   mv  R11, precise klass java/util/Optional: 0x00000040d08855e0:Constant:exact *	# ptr, #@loadConP
704     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.Optional::of @ bci:0 (line 113) L[0]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:125 (line 758) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop off=1800/0x708}

708     B94: #	out( B51 ) &lt;- in( B93 )  Freq: 9.85467e-05
        # Block is sole successor of call
708 +   j  B51	#@branch

70c     B95: #	out( B61 B96 ) &lt;- in( B59 )  Freq: 1.30543e-05
70c +   spill [sp, #0] -&gt; R9	# spill size = 64
710 +   lwu  R28, [R9, #24]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.stringValue
714 +   decode_heap_oop  R10, R28	#@decodeHeapOop
718 +   beq   R10, zr, B61	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

71c     B96: #	out( B122 B97 ) &lt;- in( B95 )  Freq: 6.52713e-06
71c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
71c     ld  R7, [R23, #32]	# int, #@loadL
720 +   beq  R7, zr, B122	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

724     B97: #	out( B61 ) &lt;- in( B96 )  Freq: 6.5206e-06
724 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
724     ld  R28, [R23, #48]	# ptr, #@loadP
728 +   add R28, R28, R7	# ptr, #@addP_reg_reg
72c +   addi  R7, R7, #-8	#@addL_reg_imm
730 +   sd  R10, [R28, #-8]	# ptr, #@storeP
734 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
734     sd  R7, [R23, #32]	# long, #@storeL
738 +   j  B61	#@branch

73c     B98: #	out( B63 B99 ) &lt;- in( B62 )  Freq: 1.30414e-05
73c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
73c     ld  R7, [R23, #64]	# int, #@loadL
740 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
740     ld  R28, [R23, #80]	# ptr, #@loadP
744 +   #@membar_volatile
	fence iorw iorw
748 +   lb  R30, [R10]	# byte, #@loadB
74c +   beq  R30, zr, B63	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

750     B99: #	out( B101 B100 ) &lt;- in( B98 )  Freq: 6.52069e-06
750 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
754 +   bne  R7, zr, B101	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

758     B100: #	out( B63 ) &lt;- in( B99 )  Freq: 3.26034e-06
758 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
758     spill R23 -&gt; R11	# spill size = 64
75c +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
78c +   j  B63	#@branch

790     B101: #	out( B63 ) &lt;- in( B99 )  Freq: 3.26034e-06
790 +   add R28, R28, R7	# ptr, #@addP_reg_reg
794 +   addi  R7, R7, #-8	#@addL_reg_imm
798 +   sd  R10, [R28, #-8]	# ptr, #@storeP
79c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
79c     sd  R7, [R23, #64]	# long, #@storeL
7a0 +   j  B63	#@branch

7a4     B102: #	out( B137 B103 ) &lt;- in( B54 )  Freq: 1.30569e-06
7a4 +   spill R29 -&gt; [sp, #16]	# spill size = 64
7a8 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
7b0 +   mv  R11, precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# ptr, #@loadConP
7c8     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # sun.nio.fs.Util::toString @ bci:0 (line 63) L[0]=sp + #16
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=sp + #0 STK[0]=sp + #0 STK[1]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:35 (line 747) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=1996/0x7cc}

7cc     B103: #	out( B56 ) &lt;- in( B102 )  Freq: 1.30566e-06
        # Block is sole successor of call
7cc +   spill [sp, #16] -&gt; R29	# spill size = 64
7d0 +   j  B56	#@branch

7d4     B104: #	out( N1413 ) &lt;- in( B7 )  Freq: 1.01325e-06
7d4 +   li R11, #-28	# int, #@loadConI
7d8     spill R31 -&gt; [sp, #24]	# spill size = 64
7dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:23 (line 283) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #24 STK[1]=R8
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=sp + #8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {[0]=Oop [8]=Oop [24]=Oop off=2016/0x7e0}
7e0     #@ShouldNotReachHere

7ec     B105: #	out( B11 ) &lt;- in( B9 )  Freq: 1.01174e-06
7ec +   addw  R7, R28, zr	#@convI2L_reg_reg
7f0 +   j  B11	#@branch

7f4     B106: #	out( B19 ) &lt;- in( B16 )  Freq: 1.01174e-06
7f4 +   spill R11 -&gt; R28	# spill size = 64
7f8 +   addi  R29, R7, #-2	#@addL_reg_imm
7fc     ClearArray R29, R28	#@clearArray_reg_reg
854     
854 +   j  B19	#@branch

858     B107: #	out( N1413 ) &lt;- in( B29 )  Freq: 1e-06
858 +   li R11, #-10	# int, #@loadConI
85c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::toString @ bci:19 (line 757) L[0]=_ STK[0]=_ STK[1]=#NULL STK[2]=sp + #16
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {[16]=Oop off=2144/0x860}
860     #@ShouldNotReachHere

86c     B108: #	out( N1413 ) &lt;- in( B2 )  Freq: 9.99999e-07
86c +   li R11, #-34	# int, #@loadConI
870     spill R12 -&gt; [sp, #8]	# spill size = 64
874     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=sp + #8 L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #8
        # OopMap {[0]=Oop [8]=Oop off=2168/0x878}
878     #@ShouldNotReachHere

884     B109: #	out( N1413 ) &lt;- in( B12 )  Freq: 9.98485e-07
884 +   li R11, #-52	# int, #@loadConI
888     spill [sp, #0] -&gt; R8	# spill size = 64
88c +   spill R28 -&gt; [sp, #20]	# spill size = 32
890     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=sp + #8 L[1]=_ L[2]=sp + #20 L[3]=_ STK[0]=sp + #20
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=sp + #8 L[2]=R8 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [8]=Oop off=2196/0x894}
894     #@ShouldNotReachHere

8a0     B110: #	out( N1413 ) &lt;- in( B23 )  Freq: 9.86918e-07
8a0 +   spill [sp, #0] -&gt; R8	# spill size = 64
8a4 +   li R11, #-34	# int, #@loadConI
8a8     spill R12 -&gt; [sp, #0]	# spill size = 64
8ac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=R8 L[3]=_ L[4]=_ L[5]=_ STK[0]=sp + #0
        # OopMap {fp=Oop [0]=Oop off=2224/0x8b0}
8b0     #@ShouldNotReachHere

8bc     B111: #	out( N1413 ) &lt;- in( B24 )  Freq: 4.93458e-07
8bc +   li R11, #-187	# int, #@loadConI
8c0     spill R12 -&gt; [sp, #8]	# spill size = 64
8c4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::toString @ bci:4 (line 756) L[0]=sp + #8 STK[0]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=sp + #0 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=2248/0x8c8}
8c8     #@ShouldNotReachHere

8d4     B112: #	out( N1413 ) &lt;- in( B38 )  Freq: 4.93445e-07
8d4 +   li R11, #-187	# int, #@loadConI
8d8     spill R7 -&gt; [sp, #16]	# spill size = 32
8dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:36 (line 2959) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=#Ptr0x00000040d0889010 L[5]=sp + #16 L[6]=R8 L[7]=#1 L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {[0]=Oop [8]=Oop off=2272/0x8e0}
8e0     #@ShouldNotReachHere

8ec     B113: #	out( N1413 ) &lt;- in( B39 )  Freq: 4.93445e-07
8ec +   li R11, #-187	# int, #@loadConI
8f0     spill R7 -&gt; [sp, #16]	# spill size = 32
8f4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:42 (line 2960) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=#Ptr0x00000040d0889010 L[5]=sp + #16 L[6]=R8 L[7]=#1 L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=R8 STK[1]=#1
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {[0]=Oop [8]=Oop off=2296/0x8f8}
8f8     #@ShouldNotReachHere

904     B114: #	out( N1413 ) &lt;- in( B40 )  Freq: 4.93445e-07
904 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
90c +   li R11, #-187	# int, #@loadConI
910     spill R28 -&gt; R8	# spill size = 64
914 +   spill R13 -&gt; [sp, #8]	# spill size = 32
918     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #8
        # java.lang.String::charAt @ bci:1 (line 1509) L[0]=R8 L[1]=#0
        # java.lang.String::replace @ bci:54 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=#Ptr0x00000040d0889010 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=sp + #0
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=2332/0x91c}
91c     #@ShouldNotReachHere

928     B115: #	out( N1413 ) &lt;- in( B43 )  Freq: 4.93444e-07
928 +   li R11, #-187	# int, #@loadConI
92c     spill [sp, #8] -&gt; R8	# spill size = 64
930 +   spill R12 -&gt; [sp, #0]	# spill size = 32
934 +   spill R31 -&gt; [sp, #4]	# spill size = 32
938     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #4
        # java.lang.String::replace @ bci:6 (line 2801) L[0]=R8 L[1]=sp + #0 L[2]=#46 L[3]=_
        # java.lang.String::replace @ bci:63 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop off=2364/0x93c}
93c     #@ShouldNotReachHere

948     B116: #	out( B32 ) &lt;- in( B80 )  Freq: 4.93435e-07
948 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
948     spill R23 -&gt; R11	# spill size = 64
94c +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
97c +   j  B32	#@branch

980     B117: #	out( N1413 ) &lt;- in( B5 )  Freq: 4.76826e-07
980 +   li R11, #-187	# int, #@loadConI
984     spill [sp, #0] -&gt; R8	# spill size = 64
988 +   spill R30 -&gt; [sp, #20]	# spill size = 32
98c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:11 (line 279) L[0]=sp + #8 L[1]=sp + #20 L[2]=_ L[3]=_ STK[0]=sp + #20
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=sp + #8 L[2]=R8 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [8]=Oop off=2448/0x990}
990     #@ShouldNotReachHere

99c     B118: #	out( N1413 ) &lt;- in( B41 )  Freq: 4.70585e-07
99c +   spill [sp, #8] -&gt; R8	# spill size = 64
9a0 +   li R11, #-187	# int, #@loadConI
9a4     spill R30 -&gt; [sp, #0]	# spill size = 64
9a8 +   spill R12 -&gt; [sp, #8]	# spill size = 32
9ac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::charAt @ bci:7 (line 47) L[0]=sp + #0 L[1]=#0 STK[0]=#0 STK[1]=sp + #8
        # java.lang.String::charAt @ bci:12 (line 1510) L[0]=_ L[1]=_
        # java.lang.String::replace @ bci:54 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=#Ptr0x00000040d0889010 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=2480/0x9b0}
9b0     #@ShouldNotReachHere

9bc     B119: #	out( N1413 ) &lt;- in( B42 )  Freq: 4.70585e-07
9bc +   li R11, #-187	# int, #@loadConI
9c0     spill [sp, #8] -&gt; R8	# spill size = 64
9c4 +   spill R12 -&gt; [sp, #4]	# spill size = 32
9c8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::replace @ bci:2 (line 2800) L[0]=R8 L[1]=sp + #4 L[2]=#46 L[3]=_ STK[0]=sp + #4 STK[1]=#46
        # java.lang.String::replace @ bci:63 (line 2961) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop off=2508/0x9cc}
9cc     #@ShouldNotReachHere

9d8     B120: #	out( N1413 ) &lt;- in( B58 )  Freq: 1.32278e-08
9d8 +   li R11, #-10	# int, #@loadConI
9dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::toString @ bci:19 (line 757) L[0]=_ STK[0]=_ STK[1]=#NULL STK[2]=sp + #16
        # jdk.internal.module.ModulePath::toPackageName @ bci:35 (line 747) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {[16]=Oop off=2528/0x9e0}
9e0     #@ShouldNotReachHere

9ec     B121: #	out( N1413 ) &lt;- in( B53 )  Freq: 6.52736e-09
9ec +   li R11, #-187	# int, #@loadConI
9f0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::toString @ bci:4 (line 756) L[0]=sp + #8 STK[0]=R8
        # jdk.internal.module.ModulePath::toPackageName @ bci:35 (line 747) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [8]=Oop off=2548/0x9f4}
9f4     #@ShouldNotReachHere

a00     B122: #	out( B61 ) &lt;- in( B96 )  Freq: 6.52705e-09
a00 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
a00     spill R23 -&gt; R11	# spill size = 64
a04 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
a34 +   j  B61	#@branch

a38     B123: #	out( N1413 ) &lt;- in( B1 )  Freq: 1.01328e-06
a38 +   li R11, #-10	# int, #@loadConI
a3c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # OopMap {off=2624/0xa40}
a40     #@ShouldNotReachHere

a4c     B124: #	out( N1413 ) &lt;- in( B4 )  Freq: 1.01326e-06
a4c +   li R11, #-10	# int, #@loadConI
a50     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:8 (line 278) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=2644/0xa54}
a54     #@ShouldNotReachHere

a60     B125: #	out( N1413 ) &lt;- in( B6 )  Freq: 1.01326e-06
a60 +   li R11, #-10	# int, #@loadConI
a64     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:23 (line 283) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=2664/0xa68}
a68     #@ShouldNotReachHere

a74     B126: #	out( N1413 ) &lt;- in( B11 )  Freq: 1.01174e-06
a74 +   li R11, #-12	# int, #@loadConI
a78     spill [sp, #0] -&gt; R8	# spill size = 64
a7c +   spill R28 -&gt; [sp, #20]	# spill size = 32
a80     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getParent @ bci:37 (line 288) L[0]=sp + #8 L[1]=_ L[2]=sp + #20 L[3]=_ STK[0]=sp + #20
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=sp + #8 L[2]=R8 L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [8]=Oop off=2692/0xa84}
a84     #@ShouldNotReachHere

a90     B127: #	out( N1413 ) &lt;- in( B27 )  Freq: 1.00002e-06
a90 +   li R11, #-10	# int, #@loadConI
a94     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::&lt;init&gt; @ bci:4 (line 1380) L[0]=_ L[1]=_ L[2]=_ STK[0]=_ STK[1]=_ STK[2]=_ STK[3]=#NULL
        # sun.nio.fs.Util::toString @ bci:8 (line 63) L[0]=_ STK[0]=_
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=_ STK[0]=_ STK[1]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:101 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=2712/0xa98}
a98     #@ShouldNotReachHere

aa4     B128: #	out( N1413 ) &lt;- in( B34 )  Freq: 9.99999e-07
aa4 +   li R11, #-10	# int, #@loadConI
aa8     spill [sp, #0] -&gt; R8	# spill size = 64
aac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL STK[1]=R8 STK[2]=#Ptr0x00000040d0889010
        # OopMap {fp=Oop off=2736/0xab0}
ab0     #@ShouldNotReachHere

abc     B129: #	out( N1413 ) &lt;- in( B35 )  Freq: 9.99998e-07
abc +   li R11, #-10	# int, #@loadConI
ac0     spill [sp, #8] -&gt; R8	# spill size = 64
ac4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::replace @ bci:1 (line 2953) L[0]=R8 L[1]=_ L[2]=#Ptr0x00000040d0889010 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ STK[0]=#NULL
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop off=2760/0xac8}
ac8     #@ShouldNotReachHere

ad4     B130: #	out( N1413 ) &lt;- in( B36 )  Freq: 9.99997e-07
ad4 +   li R11, #-10	# int, #@loadConI
ad8     spill R28 -&gt; R8	# spill size = 64
adc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::replace @ bci:16 (line 2955) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=R8 L[4]=#Ptr0x00000040d0889010 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [8]=Oop off=2784/0xae0}
ae0     #@ShouldNotReachHere

aec     B131: #	out( N1413 ) &lt;- in( B37 )  Freq: 9.99996e-07
aec +   li R11, #-10	# int, #@loadConI
af0     spill R28 -&gt; R8	# spill size = 64
af4 +   spill R29 -&gt; [sp, #0]	# spill size = 64
af8 +   spill R7 -&gt; [sp, #8]	# spill size = 32
afc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::replace @ bci:22 (line 2956) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=R8 L[4]=#Ptr0x00000040d0889010 L[5]=sp + #8 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:110 (line 756) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {fp=Oop [0]=Oop off=2816/0xb00}
b00     #@ShouldNotReachHere

b0c     B132: #	out( N1413 ) &lt;- in( B56 )  Freq: 1.32281e-08
b0c +   li R11, #-10	# int, #@loadConI
b10     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::&lt;init&gt; @ bci:4 (line 1380) L[0]=_ L[1]=_ L[2]=_ STK[0]=_ STK[1]=_ STK[2]=_ STK[3]=#NULL
        # sun.nio.fs.Util::toString @ bci:8 (line 63) L[0]=_ STK[0]=_
        # sun.nio.fs.UnixPath::toString @ bci:16 (line 757) L[0]=_ STK[0]=_ STK[1]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:35 (line 747) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=2836/0xb14}
b14     #@ShouldNotReachHere

b20     B133: #	out( N1413 ) &lt;- in( B63 )  Freq: 1.32278e-08
b20 +   li R11, #-10	# int, #@loadConI
b24     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath::toPackageName @ bci:47 (line 748) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL STK[1]=#Ptr0x00000040d088a070
        # OopMap {off=2856/0xb28}
b28     #@ShouldNotReachHere

b34     B134: #	out( N1413 ) &lt;- in( B64 )  Freq: 1.32278e-08
b34 +   li R11, #-10	# int, #@loadConI
b38     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # java.lang.String::endsWith @ bci:3 (line 2310) L[0]=_ L[1]=_ STK[0]=_ STK[1]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:47 (line 748) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=2876/0xb3c}
b3c     #@ShouldNotReachHere

b48     B135: #	out( N1413 ) &lt;- in( B68 )  Freq: 1.50811e-09
b48 +   li R11, #-10	# int, #@loadConI
b4c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getRoot @ bci:4 (line 246) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::getParent @ bci:32 (line 286) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=2896/0xb50}
b50     #@ShouldNotReachHere

b5c     B136: #	out( N1413 ) &lt;- in( B71 )  Freq: 7.54056e-11
b5c +   li R11, #-10	# int, #@loadConI
b60     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getRoot @ bci:23 (line 247) L[0]=_ STK[0]=#NULL
        # sun.nio.fs.UnixPath::getParent @ bci:32 (line 286) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # sun.nio.fs.UnixPath::getParent @ bci:1 (line 43) L[0]=_
        # jdk.internal.module.ModulePath::toPackageName @ bci:24 (line 745) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # OopMap {off=2916/0xb64}
b64     #@ShouldNotReachHere

b70     B137: #	out( B145 ) &lt;- in( B102 )  Freq: 1.30569e-11
b70      -- 	// exception oop; no code emitted, #@CreateException
b70 +   j  B145	#@branch

b74     B138: #	out( B152 ) &lt;- in( B93 )  Freq: 9.85487e-10
b74      -- 	// exception oop; no code emitted, #@CreateException
b74 +   spill R10 -&gt; R11	# spill size = 64
b78 +   j  B152	#@branch

b7c     B139: #	out( B149 ) &lt;- in( B91 )  Freq: 9.8708e-10
b7c      -- 	// exception oop; no code emitted, #@CreateException
b7c +   j  B149	#@branch

b80     B140: #	out( B147 ) &lt;- in( B87 )  Freq: 9.9865e-10
b80      -- 	// exception oop; no code emitted, #@CreateException
b80 +   j  B147	#@branch

b84     B141: #	out( B147 ) &lt;- in( B89 )  Freq: 1.00877e-09
b84      -- 	// exception oop; no code emitted, #@CreateException
b84 +   j  B147	#@branch

b88     B142: #	out( B152 ) &lt;- in( B75 )  Freq: 1.42929e-08
b88      -- 	// exception oop; no code emitted, #@CreateException
b88 +   spill R10 -&gt; R11	# spill size = 64
b8c +   j  B152	#@branch

b90     B143: #	out( B152 ) &lt;- in( B65 )  Freq: 1.30544e-07
b90      -- 	// exception oop; no code emitted, #@CreateException
b90 +   spill R10 -&gt; R11	# spill size = 64
b94 +   j  B152	#@branch

b98     B144: #	out( B145 ) &lt;- in( B57 )  Freq: 1.30547e-07
b98      -- 	// exception oop; no code emitted, #@CreateException

b98     B145: #	out( B152 ) &lt;- in( B137 B144 )  Freq: 1.3056e-07
b98 +   spill R10 -&gt; R11	# spill size = 64
b9c +   j  B152	#@branch

ba0     B146: #	out( B147 ) &lt;- in( B3 )  Freq: 9.99998e-06
ba0      -- 	// exception oop; no code emitted, #@CreateException

ba0     B147: #	out( B152 ) &lt;- in( B146 B141 B140 )  Freq: 1.0002e-05
ba0 +   spill R10 -&gt; R11	# spill size = 64
ba4 +   j  B152	#@branch

ba8     B148: #	out( B149 ) &lt;- in( B28 )  Freq: 9.86915e-06
ba8      -- 	// exception oop; no code emitted, #@CreateException

ba8     B149: #	out( B152 ) &lt;- in( B139 B148 )  Freq: 9.87014e-06
ba8 +   spill R10 -&gt; R11	# spill size = 64
bac +   j  B152	#@branch

bb0     B150: #	out( B152 ) &lt;- in( B44 )  Freq: 9.86888e-06
bb0      -- 	// exception oop; no code emitted, #@CreateException
bb0 +   spill R10 -&gt; R11	# spill size = 64
bb4 +   j  B152	#@branch

bb8     B151: #	out( B152 ) &lt;- in( B47 )  Freq: 9.86868e-06
bb8      -- 	// exception oop; no code emitted, #@CreateException
bb8 +   spill R10 -&gt; R11	# spill size = 64

bbc     B152: #	out( N1413 ) &lt;- in( B147 B145 B143 B142 B149 B150 B151 B138 )  Freq: 3.98861e-05
bbc     # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
bc8 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='472'>
----------------------- MetaData before Compile_id = 472 ------------------------
{method}
 - this oop:          0x00000040961a1da0
 - method holder:     &apos;java/util/HashMap&apos;
 - constants:         0x000000409619f4e0 constant pool [610] {0x000000409619f4e0} for &apos;java/util/HashMap&apos; cache=0x00000040961a4fd8
 - access:            0xc1000010  final 
 - name:              &apos;putVal&apos;
 - signature:         &apos;(ILjava/lang/Object;Ljava/lang/Object;ZZ)Ljava/lang/Object;&apos;
 - max stack:         8
 - max locals:        13
 - size of params:    6
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400832ee20: 0xbabbaa i2c: 0x0000004013930340 c2i: 0x0000004013930398 c2iUV: 0x0000004013930364
 - compiled entry     0x000000400c502880
 - code size:         300
 - code start:        0x00000040961a1b70
 - code end (excl):   0x00000040961a1c9c
 - method data:       0x0000004096485328
 - checked ex length: 0
 - linenumber start:  0x00000040961a1c9c
 - localvar length:   18
 - localvar start:    0x00000040961a1cc4
 - compiled code: nmethod  20062  172       3       java.util.HashMap::putVal (300 bytes)

------------------------ OptoAssembly for Compile_id = 472 -----------------------
#
#  java/lang/Object * ( java/util/HashMap:NotNull *, int, java/lang/Object *, java/lang/Object *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/HashMap:NotNull *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3:c_rarg3   : parm 2: java/lang/Object *
#r018 c_rarg4:c_rarg4   : parm 3: java/lang/Object *
#r020 c_rarg5   : parm 4: int
#r022 c_rarg6   : parm 5: int
# -- Old sp -- Framesize: 112 --
#r263 sp+108: in_preserve
#r262 sp+104: return address
#r261 sp+100: in_preserve
#r260 sp+96: saved fp register
#r259 sp+92: pad2, stack alignment
#r258 sp+88: pad2, stack alignment
#r257 sp+84: Fixed slot 1
#r256 sp+80: Fixed slot 0
#r283 sp+76: spill
#r282 sp+72: spill
#r281 sp+68: spill
#r280 sp+64: spill
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1360: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B60 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=112
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #112
	
03c     lwu  R28, [R11, #36]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap.table
040 +   decode_heap_oop  R9, R28	#@decodeHeapOop
044     spill R16 -&gt; [sp, #24]	# spill size = 32
048 +   spill R15 -&gt; [sp, #28]	# spill size = 32
04c +   spill R14 -&gt; [sp, #32]	# spill size = 64
050 +   spill R13 -&gt; [sp, #16]	# spill size = 64
054 +   spill R12 -&gt; [sp, #8]	# spill size = 32
058 +   spill R11 -&gt; [sp, #0]	# spill size = 64
05c +   beq   R9, zr, B60	#@cmpP_imm0_branch  P=0.174698 C=5375.000000

060     B2: #	out( B92 B3 ) &lt;- in( B1 )  Freq: 0.825302
060 +   lwu  R7, [R9, #12]	# range, #@loadRange
064 +   bleu  R7, zr, B92	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=4436.000000

068     B3: #	out( B90 B4 ) &lt;- in( B62 B2 )  Freq: 0.999996
068 +   addiw  R28, R7, #-1	#@addI_reg_imm
06c     spill [sp, #8] -&gt; R20	# spill size = 32
070 +   andr  R12, R28, R20	#@andI_reg_reg
074 +   addw  R28, R12, zr	#@convI2L_reg_reg
078 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
07c +   add R28, R9, R28	# ptr, #@addP_reg_reg
080 +   addi  R8, R28, #16	# ptr, #@addP_reg_imm
084 +   ble  R7, zr, B90	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

088     B4: #	out( B33 B5 ) &lt;- in( B3 )  Freq: 0.999995
088 +   lwu  R28, [R8]	# loadN, compressed ptr, #@loadN
08c +   decode_heap_oop  R29, R28	#@decodeHeapOop
090     spill [sp, #16] -&gt; R28	# spill size = 64
094 +   encode_heap_oop  R30, R28	#@encodeHeapOop
098     spill [sp, #32] -&gt; R19	# spill size = 64
09c +   encode_heap_oop  R18, R19	#@encodeHeapOop
0a0 +   li R31, #1	# long, #@loadConL
0a4 +   mv  R10, narrowklass: precise klass java/util/HashMap$Node: 0x00000040d07fa990:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0b4 +   beq   R29, zr, B33	#@cmpP_imm0_branch  P=0.511070 C=5375.000000

0b8     B5: #	out( B41 B6 ) &lt;- in( B4 )  Freq: 0.488928
0b8 +   lw  R12, [R29, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
0bc +   li R7, #0	# int, #@loadConI
0c0 +   beq  R12, R20, B41	#@cmpI_branch  P=0.443515 C=2629.000000

0c4     B6: #	out( B93 B7 ) &lt;- in( B5 )  Freq: 0.272081
0c4 +   lwu  R11, [R29, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
0c8 +   lwu  R13, [R29, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0cc +   decode_heap_oop  R22, R11	#@decodeHeapOop
0d0 +   mv  R11, narrowklass: precise klass java/util/HashMap$TreeNode: 0x00000040d07fefa0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0e0 +   beq  R13, R11, B93	#@cmpN_branch  P=0.000001 C=-1.000000

0e4     B7: #	out( B16 B8 ) &lt;- in( B6 )  Freq: 0.272081
0e4 +   bne   R22, zr, B16	#@cmpP_imm0_branch  P=0.620164 C=1706.000000

0e8     B8: #	out( B9 ) &lt;- in( B7 )  Freq: 0.103346
0e8 +   li R21, #0	# int, #@loadConI
0ec     spill R29 -&gt; R22	# spill size = 64

0f0     B9: #	out( B88 B10 ) &lt;- in( B18 B8 )  Freq: 0.120575
0f0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0f0     ld  R24, [R23, #288]	# ptr, #@loadP
0f4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0f4     ld  R7, [R23, #304]	# ptr, #@loadP
0f8 +   addi  R29, R24, #32	# ptr, #@addP_reg_imm
0fc +   bgeu  R29, R7, B88	#@cmpP_branch  P=0.000100 C=-1.000000

100     B10: #	out( B11 ) &lt;- in( B9 )  Freq: 0.120563
100 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
100     sd  R29, [R23, #288]	# ptr, #@storeP
104 +   sd  R31, [R24]	# long, #@storeL
108 +   sw  R10, [R24, #8]	# compressed klass ptr, #@storeNKlass
10c +   sd  zr, [R24, #24]	# long, #@storeimmL0

110     B11: #	out( B79 B12 ) &lt;- in( B89 B10 )  Freq: 0.120575
110 +   sw  R20, [R24, #12]	# int, #@storeI
114 +   sw  R30, [R24, #16]	# compressed ptr, #@storeN
118 +   sw  R18, [R24, #20]	# compressed ptr, #@storeN
11c     
11c +   #@membar_release
	fence iorw ow
120 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
120     lb  R28, [R23, #56]	# byte, #@loadB
124 +   # checkcastPP of R24, #@checkCastPP
124     bne  R28, zr, B79	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

128     B12: #	out( B14 B13 ) &lt;- in( B109 B81 B79 B11 )  Freq: 0.120575
128 +   mv  R7, R22	# ptr -&gt; long, #@castP2X
12c +   mv  R28, R24	# ptr -&gt; long, #@castP2X
130 +   xorr  R28, R28, R7	#@xorL_reg_reg
134 +   encode_heap_oop  R29, R24	#@encodeHeapOop
138 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
13c +   li R18, #7	# int, #@loadConI
140 +   sw  R29, [R22, #24]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.next
144 +   beq  R28, zr, B14	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

148     B13: #	out( B82 B14 ) &lt;- in( B12 )  Freq: 0.120454
148 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
14c +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
158 +   add R10, R28, R7	# ptr, #@addP_reg_reg
15c +   lb  R28, [R10]	# byte, #@loadB
160 +   li R7, #4	# int, #@loadConI
164 +   bne  R28, R7, B82	#@cmpI_branch  P=0.001000 C=-1.000000

168     B14: #	out( B39 B15 ) &lt;- in( B84 B85 B82 B13 B12 )  Freq: 0.120575
168 +   blt  R21, R18, B39	#@cmpI_branch  P=1.000000 C=648.000000

16c     B15: #	out( N1360 ) &lt;- in( B14 )  Freq: 5.74946e-08
16c +   spill [sp, #0] -&gt; R8	# spill size = 64
170 +   spill [sp, #28] -&gt; R28	# spill size = 32
174 +   spill [sp, #24] -&gt; R7	# spill size = 32
178 +   li R11, #-187	# int, #@loadConI
17c     spill R20 -&gt; [sp, #0]	# spill size = 32
180 +   spill R19 -&gt; [sp, #8]	# spill size = 64
184 +   spill R28 -&gt; [sp, #4]	# spill size = 32
188 +   spill R7 -&gt; [sp, #16]	# spill size = 32
18c +   spill R9 -&gt; [sp, #24]	# spill size = 64
190 +   spill R21 -&gt; [sp, #20]	# spill size = 32
194     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:162 (line 641) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=sp + #8 L[4]=sp + #4 L[5]=sp + #16 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=_ STK[0]=sp + #20 STK[1]=#7
        # OopMap {fp=Oop [8]=Oop [24]=Oop off=408/0x198}
198     #@ShouldNotReachHere

1a4     B16: #	out( B17 ) &lt;- in( B7 )  Freq: 0.168735
1a4 +   li R21, #0	# int, #@loadConI

1a8     B17: #	out( B20 B18 ) &lt;- in( B16 B19 ) Loop( B17-B19 inner ) Freq: 0.196865
1a8 +   lw  R11, [R22, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
1ac +   beq  R11, R20, B20	#@cmpI_branch  P=0.769594 C=1059.000000

1b0     B18: #	out( B9 B19 ) &lt;- in( B17 )  Freq: 0.0453588
1b0 +   addiw  R21, R21, #1	#@addI_reg_imm
1b4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b4     ld  R29, [R23, #920]	# ptr, #@loadP
1b8 +   lwu zr, [R29]	# Safepoint: poll for GC, #@safePoint        # java.util.HashMap::putVal @ bci:219 (line 638) L[0]=sp + #0 L[1]=R20 L[2]=R28 L[3]=R19 L[4]=sp + #28 L[5]=sp + #24 L[6]=R9 L[7]=R22 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=R21
        # OopMap {x28=Oop x30=NarrowOop x9=Oop x18=NarrowOop x19=Oop xbcp=Oop [0]=Oop off=440/0x1b8}
1bc +   lwu  R29, [R22, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
1c0 +   decode_heap_oop  R29, R29	#@decodeHeapOop
1c4 +   beq   R29, zr, B9	#@cmpP_imm0_branch  P=0.379836 C=244.000000

1c8     B19: #	out( B17 ) &lt;- in( B18 )  Freq: 0.0281299
1c8 +   spill R29 -&gt; R22	# spill size = 64
1cc +   j  B17	#@branch

1d0     B20: #	out( B107 B21 ) &lt;- in( B17 )  Freq: 0.151506
1d0 +   lwu  R29, [R22, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
1d4 +   decode_heap_oop  R10, R29	#@decodeHeapOop
1d8 +   beq  R10, R28, B107	#@cmpP_branch  P=0.000000 C=815.000000

1dc     B21: #	out( B116 B22 ) &lt;- in( B20 )  Freq: 0.151506
1dc     lwu  R30, [R28, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
1e0     NullCheck R28

1e0     B22: #	out( B102 B23 ) &lt;- in( B21 )  Freq: 0.151506
1e0 +   mv  R29, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1f0 +   bne  R30, R29, B102	#@cmpN_branch  P=0.000001 C=-1.000000

1f4     B23: #	out( B53 B24 ) &lt;- in( B22 )  Freq: 0.151506
1f4 +   spill R28 -&gt; R12	# spill size = 64
1f8 +   # checkcastPP of R12, #@checkCastPP
1f8     beq  R12, R10, B53	#@cmpP_branch  P=0.064818 C=5338.000000

1fc     B24: #	out( B114 B25 ) &lt;- in( B23 )  Freq: 0.141685
1fc     lwu  R29, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
200     NullCheck R10

200     B25: #	out( B110 B26 ) &lt;- in( B24 )  Freq: 0.141685
200 +   mv  R31, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
210 +   lwu  R28, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
214 +   lb  R30, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
218 +   bne  R29, R31, B110	#@cmpN_branch  P=0.000000 C=-1.000000

21c     B26: #	out( B108 B27 ) &lt;- in( B25 )  Freq: 0.141685
21c +   # checkcastPP of R10, #@checkCastPP
21c     lb  R8, [R10, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
220 +   lwu  R29, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
224 +   decode_heap_oop  R28, R28	#@decodeHeapOop
228 +   bne  R30, R8, B108	#@cmpI_branch  P=0.000000 C=4992.000000

22c     B27: #	out( B103 B28 ) &lt;- in( B26 )  Freq: 0.141685
22c +   beq   R28, zr, B103	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

230     B28: #	out( B104 B29 ) &lt;- in( B27 )  Freq: 0.141685
230 +   decode_heap_oop  R29, R29	#@decodeHeapOop
234 +   lwu  R14, [R28, #12]	# range, #@loadRange
238 +   beq   R29, zr, B104	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

23c     B29: #	out( B32 B30 ) &lt;- in( B28 )  Freq: 0.141685
23c +   lwu  R30, [R29, #12]	# range, #@loadRange
240 +   bne  R14, R30, B32	#@cmpI_branch  P=0.000001 C=-1.000000

244     B30: #	out( B53 B31 ) &lt;- in( B29 )  Freq: 0.141685
244 +   addi  R13, R29, #16	# ptr, #@addP_reg_imm
248 +   addi  R11, R28, #16	# ptr, #@addP_reg_imm
24c     String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
2dc +   bne  R10, zr, B53	#@cmpI_reg_imm0_branch  P=1.000000 C=815.000000

2e0     B31: #	out( B32 ) &lt;- in( B30 )  Freq: 6.75605e-08
2e0 +   spill R10 -&gt; R7	# spill size = 32

2e4     B32: #	out( N1360 ) &lt;- in( B31 B29 )  Freq: 2.09245e-07
2e4 +   spill [sp, #0] -&gt; R8	# spill size = 64
2e8 +   spill [sp, #28] -&gt; R28	# spill size = 32
2ec +   spill [sp, #24] -&gt; R29	# spill size = 32
2f0 +   li R11, #-187	# int, #@loadConI
2f4     spill R20 -&gt; [sp, #0]	# spill size = 32
2f8 +   spill R19 -&gt; [sp, #8]	# spill size = 64
2fc +   spill R28 -&gt; [sp, #4]	# spill size = 32
300 +   spill R29 -&gt; [sp, #16]	# spill size = 32
304 +   spill R9 -&gt; [sp, #24]	# spill size = 64
308 +   spill R22 -&gt; [sp, #32]	# spill size = 64
30c +   spill R7 -&gt; [sp, #20]	# spill size = 32
310 +   spill R12 -&gt; [sp, #40]	# spill size = 64
314 +   spill R21 -&gt; [sp, #48]	# spill size = 32
318     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:206 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #40 L[3]=sp + #8 L[4]=sp + #4 L[5]=sp + #16 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #32 L[11]=_ L[12]=sp + #48 STK[0]=sp + #20
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [40]=Oop off=796/0x31c}
31c     #@ShouldNotReachHere

328     B33: #	out( B86 B34 ) &lt;- in( B4 )  Freq: 0.511067
328 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
328     ld  R21, [R23, #288]	# ptr, #@loadP
32c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
32c     ld  R7, [R23, #304]	# ptr, #@loadP
330 +   addi  R29, R21, #32	# ptr, #@addP_reg_imm
334 +   bgeu  R29, R7, B86	#@cmpP_branch  P=0.000100 C=-1.000000

338     B34: #	out( B35 ) &lt;- in( B33 )  Freq: 0.511016
338 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
338     sd  R29, [R23, #288]	# ptr, #@storeP
33c +   sd  R31, [R21]	# long, #@storeL
340 +   sw  R10, [R21, #8]	# compressed klass ptr, #@storeNKlass
344 +   sd  zr, [R21, #24]	# long, #@storeimmL0

348     B35: #	out( B91 B36 ) &lt;- in( B87 B34 )  Freq: 0.511067
348 +   sw  R20, [R21, #12]	# int, #@storeI
34c +   sw  R30, [R21, #16]	# compressed ptr, #@storeN
350 +   sw  R18, [R21, #20]	# compressed ptr, #@storeN
354     
354 +   #@membar_release
	fence iorw ow
358 +   lwu  R7, [R9, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
35c +   mv  R29, narrowklass: precise klass [Ljava/util/HashMap$Node;: 0x00000040d07fd760:Constant:exact *	# compressed klass ptr, #@loadConNKlass
36c +   # checkcastPP of R21, #@checkCastPP
36c     bne  R7, R29, B91	#@cmpN_branch  P=0.000001 C=-1.000000

370     B36: #	out( B65 B37 ) &lt;- in( B35 )  Freq: 0.511067
370 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
370     lb  R7, [R23, #56]	# byte, #@loadB
374 +   bne  R7, zr, B65	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

378     B37: #	out( B39 B38 ) &lt;- in( B94 B67 B65 B36 )  Freq: 0.511067
378 +   mv  R7, R8	# ptr -&gt; long, #@castP2X
37c +   mv  R28, R21	# ptr -&gt; long, #@castP2X
380 +   xorr  R28, R28, R7	#@xorL_reg_reg
384 +   encode_heap_oop  R30, R21	#@encodeHeapOop
388 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
38c +   sw  R30, [R8]	# compressed ptr, #@storeN
390 +   beq  R28, zr, B39	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

394     B38: #	out( B68 B39 ) &lt;- in( B37 )  Freq: 0.510556
394 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
398 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
3a4 +   add R10, R28, R7	# ptr, #@addP_reg_reg
3a8 +   lb  R7, [R10]	# byte, #@loadB
3ac +   li R29, #4	# int, #@loadConI
3b0 +   bne  R7, R29, B68	#@cmpI_branch  P=0.001000 C=-1.000000

3b4     B39: #	out( B63 B40 ) &lt;- in( B14 B70 B71 B68 B38 B37 )  Freq: 0.631642
3b4 +   spill [sp, #0] -&gt; R28	# spill size = 64
3b8 +   lw  R29, [R28, #24]	# int, #@loadI ! Field: java/util/HashMap.modCount
3bc     spill [sp, #0] -&gt; R7	# spill size = 64
3c0 +   lw  R7, [R7, #20]	# int, #@loadI ! Field: java/util/HashMap.size
3c4 +   addiw  R30, R29, #1	#@addI_reg_imm
3c8 +   addiw  R7, R7, #1	#@addI_reg_imm
3cc +   lw  R28, [R28, #28]	# int, #@loadI ! Field: java/util/HashMap.threshold
3d0     spill [sp, #0] -&gt; R29	# spill size = 64
3d4 +   sw  R30, [R29, #24]	# int, #@storeI ! Field: java/util/HashMap.modCount
3d8 +   sw  R7, [R29, #20]	# int, #@storeI ! Field: java/util/HashMap.size
3dc +   bgt  R7, R28, B63	#@cmpI_branch  P=0.039776 C=3394.000000

3e0     B40: #	out( B59 ) &lt;- in( B64 B39 )  Freq: 0.631641
3e0 +   mv  R10, NULL	# NULL ptr, #@loadConP0
3e4 +   j  B59	#@branch

3e8     B41: #	out( B105 B42 ) &lt;- in( B5 )  Freq: 0.216847
3e8 +   lwu  R31, [R29, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
3ec +   decode_heap_oop  R31, R31	#@decodeHeapOop
3f0 +   beq  R31, R28, B105	#@cmpP_branch  P=0.000000 C=1166.000000

3f4     B42: #	out( B115 B43 ) &lt;- in( B41 )  Freq: 0.216847
3f4     lwu  R30, [R28, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
3f8     NullCheck R28

3f8     B43: #	out( B95 B44 ) &lt;- in( B42 )  Freq: 0.216846
3f8 +   mv  R11, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
408 +   bne  R30, R11, B95	#@cmpN_branch  P=0.000001 C=-1.000000

40c     B44: #	out( B52 B45 ) &lt;- in( B43 )  Freq: 0.216846
40c +   spill R28 -&gt; R12	# spill size = 64
410 +   # checkcastPP of R12, #@checkCastPP
410     beq  R12, R31, B52	#@cmpP_branch  P=0.064818 C=5338.000000

414     B45: #	out( B112 B46 ) &lt;- in( B44 )  Freq: 0.202791
414     lwu  R28, [R31, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
418     NullCheck R31

418     B46: #	out( B111 B47 ) &lt;- in( B45 )  Freq: 0.20279
418 +   mv  R10, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
428 +   lwu  R11, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
42c +   lb  R30, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
430 +   bne  R28, R10, B111	#@cmpN_branch  P=0.000000 C=-1.000000

434     B47: #	out( B106 B48 ) &lt;- in( B46 )  Freq: 0.20279
434 +   # checkcastPP of R31, #@checkCastPP
434     lb  R28, [R31, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
438 +   lwu  R13, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
43c +   decode_heap_oop  R10, R11	#@decodeHeapOop
440 +   bne  R30, R28, B106	#@cmpI_branch  P=0.000000 C=4992.000000

444     B48: #	out( B96 B49 ) &lt;- in( B47 )  Freq: 0.20279
444 +   beq   R10, zr, B96	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

448     B49: #	out( B97 B50 ) &lt;- in( B48 )  Freq: 0.20279
448 +   decode_heap_oop  R28, R13	#@decodeHeapOop
44c +   lwu  R14, [R10, #12]	# range, #@loadRange
450 +   beq   R28, zr, B97	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

454     B50: #	out( B99 B51 ) &lt;- in( B49 )  Freq: 0.20279
454 +   lwu  R31, [R28, #12]	# range, #@loadRange
458 +   bne  R14, R31, B99	#@cmpI_branch  P=0.000001 C=-1.000000

45c     B51: #	out( B98 B52 ) &lt;- in( B50 )  Freq: 0.20279
45c +   addi  R13, R28, #16	# ptr, #@addP_reg_imm
460 +   addi  R11, R10, #16	# ptr, #@addP_reg_imm
464     String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
4f4 +   beq  R10, zr, B98	#@cmpI_reg_imm0_branch  P=0.000000 C=1166.000000

4f8     B52: #	out( B53 ) &lt;- in( B44 B51 )  Freq: 0.216845
4f8 +   spill R29 -&gt; R22	# spill size = 64

4fc     B53: #	out( B101 B54 ) &lt;- in( B52 B23 B30 )  Freq: 0.36835
4fc +   lwu  R28, [R22, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.value
500 +   decode_heap_oop  R9, R28	#@decodeHeapOop
504     spill [sp, #28] -&gt; R7	# spill size = 32
508 +   bne  R7, zr, B101	#@cmpI_reg_imm0_branch  P=0.000000 C=1980.000000

50c     B54: #	out( B72 B55 ) &lt;- in( B53 )  Freq: 0.36835
50c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
50c     lb  R7, [R23, #56]	# byte, #@loadB
510 +   bne  R7, zr, B72	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

514     B55: #	out( B58 B56 ) &lt;- in( B100 B74 B72 B54 )  Freq: 0.36835
514 +   mv  R7, R22	# ptr -&gt; long, #@castP2X
518 +   mv  R28, R19	# ptr -&gt; long, #@castP2X
51c +   xorr  R28, R28, R7	#@xorL_reg_reg
520 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
524 +   sw  R18, [R22, #20]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.value
528 +   beq  R28, zr, B58	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

52c     B56: #	out( B58 B57 ) &lt;- in( B55 )  Freq: 0.367982
52c +   beq   R19, zr, B58	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

530     B57: #	out( B75 B58 ) &lt;- in( B56 )  Freq: 0.367614
530 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
534 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
540 +   add R10, R28, R7	# ptr, #@addP_reg_reg
544 +   lb  R28, [R10]	# byte, #@loadB
548 +   li R29, #4	# int, #@loadConI
54c +   bne  R28, R29, B75	#@cmpI_branch  P=0.001000 C=-1.000000

550     B58: #	out( B59 ) &lt;- in( B77 B78 B75 B57 B56 B55 )  Freq: 0.36835
550 +   spill R9 -&gt; R10	# spill size = 64

554     B59: #	out( N1360 ) &lt;- in( B58 B40 )  Freq: 0.999991
554     # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
56c +   ret	// return register, #@Ret

570     B60: #	out( B120 B61 ) &lt;- in( B1 )  Freq: 0.174698
570     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:20 (line 627) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #16 L[3]=sp + #32 L[4]=sp + #28 L[5]=sp + #24 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {[0]=Oop [16]=Oop [32]=Oop off=1396/0x574}

574     B61: #	out( B113 B62 ) &lt;- in( B60 )  Freq: 0.174694
        # Block is sole successor of call
574 +   spill R10 -&gt; R9	# spill size = 64
578     lwu  R7, [R10, #12]	# range, #@loadRange
57c     NullCheck R10

57c     B62: #	out( B3 ) &lt;- in( B61 )  Freq: 0.174694
57c +   j  B3	#@branch

580     B63: #	out( B119 B64 ) &lt;- in( B39 )  Freq: 0.0251242
580 +   spill [sp, #0] -&gt; R11	# spill size = 64
584     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:288 (line 661) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=sp + #24 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {[0]=Oop off=1416/0x588}

588     B64: #	out( B40 ) &lt;- in( B63 )  Freq: 0.0251237
        # Block is sole successor of call
588 +   j  B40	#@branch

58c     B65: #	out( B37 B66 ) &lt;- in( B36 )  Freq: 0.00051106
58c +   lwu  R28, [R8]	# loadN, compressed ptr, #@loadN
590 +   decode_heap_oop  R10, R28	#@decodeHeapOop
594 +   beq   R10, zr, B37	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

598     B66: #	out( B94 B67 ) &lt;- in( B65 )  Freq: 0.00025553
598 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
598     ld  R7, [R23, #32]	# int, #@loadL
59c +   beq  R7, zr, B94	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

5a0     B67: #	out( B37 ) &lt;- in( B66 )  Freq: 0.000255275
5a0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5a0     ld  R28, [R23, #48]	# ptr, #@loadP
5a4 +   add R28, R28, R7	# ptr, #@addP_reg_reg
5a8 +   addi  R7, R7, #-8	#@addL_reg_imm
5ac +   sd  R10, [R28, #-8]	# ptr, #@storeP
5b0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5b0     sd  R7, [R23, #32]	# long, #@storeL
5b4 +   j  B37	#@branch

5b8     B68: #	out( B39 B69 ) &lt;- in( B38 )  Freq: 0.000510556
5b8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5b8     ld  R7, [R23, #64]	# int, #@loadL
5bc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5bc     ld  R28, [R23, #80]	# ptr, #@loadP
5c0 +   #@membar_volatile
	fence iorw iorw
5c4 +   lb  R30, [R10]	# byte, #@loadB
5c8 +   beq  R30, zr, B39	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

5cc     B69: #	out( B71 B70 ) &lt;- in( B68 )  Freq: 0.000255278
5cc +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
5d0 +   bne  R7, zr, B71	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

5d4     B70: #	out( B39 ) &lt;- in( B69 )  Freq: 0.000127639
5d4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5d4     spill R23 -&gt; R11	# spill size = 64
5d8 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
608 +   j  B39	#@branch

60c     B71: #	out( B39 ) &lt;- in( B69 )  Freq: 0.000127639
60c +   add R28, R28, R7	# ptr, #@addP_reg_reg
610 +   addi  R7, R7, #-8	#@addL_reg_imm
614 +   sd  R10, [R28, #-8]	# ptr, #@storeP
618 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
618     sd  R7, [R23, #64]	# long, #@storeL
61c +   j  B39	#@branch

620     B72: #	out( B55 B73 ) &lt;- in( B54 )  Freq: 0.000368345
620 +   lwu  R28, [R22, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.value
624 +   decode_heap_oop  R10, R28	#@decodeHeapOop
628 +   beq   R10, zr, B55	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

62c     B73: #	out( B100 B74 ) &lt;- in( B72 )  Freq: 0.000184173
62c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
62c     ld  R7, [R23, #32]	# int, #@loadL
630 +   beq  R7, zr, B100	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

634     B74: #	out( B55 ) &lt;- in( B73 )  Freq: 0.000183988
634 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
634     ld  R28, [R23, #48]	# ptr, #@loadP
638 +   add R28, R28, R7	# ptr, #@addP_reg_reg
63c +   addi  R7, R7, #-8	#@addL_reg_imm
640 +   sd  R10, [R28, #-8]	# ptr, #@storeP
644 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
644     sd  R7, [R23, #32]	# long, #@storeL
648 +   j  B55	#@branch

64c     B75: #	out( B58 B76 ) &lt;- in( B57 )  Freq: 0.000367614
64c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
64c     ld  R7, [R23, #64]	# int, #@loadL
650 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
650     ld  R28, [R23, #80]	# ptr, #@loadP
654 +   #@membar_volatile
	fence iorw iorw
658 +   lb  R29, [R10]	# byte, #@loadB
65c +   beq  R29, zr, B58	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

660     B76: #	out( B78 B77 ) &lt;- in( B75 )  Freq: 0.000183807
660 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
664 +   bne  R7, zr, B78	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

668     B77: #	out( B58 ) &lt;- in( B76 )  Freq: 9.19034e-05
668 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
668     spill R23 -&gt; R11	# spill size = 64
66c +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
69c +   j  B58	#@branch

6a0     B78: #	out( B58 ) &lt;- in( B76 )  Freq: 9.19034e-05
6a0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
6a4 +   addi  R7, R7, #-8	#@addL_reg_imm
6a8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
6ac +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6ac     sd  R7, [R23, #64]	# long, #@storeL
6b0 +   j  B58	#@branch

6b4     B79: #	out( B12 B80 ) &lt;- in( B11 )  Freq: 0.000120573
6b4 +   lwu  R7, [R22, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
6b8 +   decode_heap_oop  R10, R7	#@decodeHeapOop
6bc +   beq   R10, zr, B12	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

6c0     B80: #	out( B109 B81 ) &lt;- in( B79 )  Freq: 6.02867e-05
6c0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6c0     ld  R7, [R23, #32]	# int, #@loadL
6c4 +   beq  R7, zr, B109	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

6c8     B81: #	out( B12 ) &lt;- in( B80 )  Freq: 6.02264e-05
6c8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6c8     ld  R28, [R23, #48]	# ptr, #@loadP
6cc +   add R28, R28, R7	# ptr, #@addP_reg_reg
6d0 +   addi  R7, R7, #-8	#@addL_reg_imm
6d4 +   sd  R10, [R28, #-8]	# ptr, #@storeP
6d8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6d8     sd  R7, [R23, #32]	# long, #@storeL
6dc +   j  B12	#@branch

6e0     B82: #	out( B14 B83 ) &lt;- in( B13 )  Freq: 0.000120454
6e0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6e0     ld  R7, [R23, #64]	# int, #@loadL
6e4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6e4     ld  R28, [R23, #80]	# ptr, #@loadP
6e8 +   #@membar_volatile
	fence iorw iorw
6ec +   lb  R29, [R10]	# byte, #@loadB
6f0 +   beq  R29, zr, B14	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

6f4     B83: #	out( B85 B84 ) &lt;- in( B82 )  Freq: 6.02272e-05
6f4 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
6f8 +   bne  R7, zr, B85	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

6fc     B84: #	out( B14 ) &lt;- in( B83 )  Freq: 3.01136e-05
6fc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6fc     spill R23 -&gt; R11	# spill size = 64
700 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
730 +   j  B14	#@branch

734     B85: #	out( B14 ) &lt;- in( B83 )  Freq: 3.01136e-05
734 +   add R28, R28, R7	# ptr, #@addP_reg_reg
738 +   addi  R7, R7, #-8	#@addL_reg_imm
73c +   sd  R10, [R28, #-8]	# ptr, #@storeP
740 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
740     sd  R7, [R23, #64]	# long, #@storeL
744 +   j  B14	#@branch

748     B86: #	out( B118 B87 ) &lt;- in( B33 )  Freq: 5.11152e-05
748 +   spill [sp, #0] -&gt; [sp, #16]	# spill size = 64
750 +   spill R18 -&gt; [sp, #48]	# spill size = 32
754 +   spill R30 -&gt; [sp, #44]	# spill size = 32
758 +   spill R12 -&gt; [sp, #40]	# spill size = 32
75c +   spill R9 -&gt; [sp, #32]	# spill size = 64
760 +   spill R20 -&gt; [sp, #28]	# spill size = 32
764 +   mv  R11, precise klass java/util/HashMap$Node: 0x00000040d07fa990:Constant:exact *	# ptr, #@loadConP
77c     spill R28 -&gt; [sp, #0]	# spill size = 64
780 +   spill R19 -&gt; [sp, #8]	# spill size = 64
784     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #28 L[2]=sp + #0 L[3]=sp + #8 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:56 (line 629) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=sp + #24 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #32 STK[1]=sp + #40
        # OopMap {fp=Derived_oop_[32] [0]=Oop [8]=Oop [16]=Oop [32]=Oop [44]=NarrowOop [48]=NarrowOop off=1928/0x788}

788     B87: #	out( B35 ) &lt;- in( B86 )  Freq: 5.11142e-05
        # Block is sole successor of call
788 +   spill [sp, #16] -&gt; [sp, #0]	# spill size = 64
790 +   spill [sp, #28] -&gt; R20	# spill size = 32
794 +   spill [sp, #32] -&gt; R9	# spill size = 64
798 +   spill [sp, #40] -&gt; R12	# spill size = 32
79c +   spill [sp, #44] -&gt; R30	# spill size = 32
7a0 +   spill [sp, #48] -&gt; R18	# spill size = 32
7a4 +   spill R10 -&gt; R21	# spill size = 64
7a8 +   j  B35	#@branch

7ac     B88: #	out( B117 B89 ) &lt;- in( B9 )  Freq: 1.20595e-05
7ac +   spill R21 -&gt; [sp, #44]	# spill size = 32
7b0 +   spill R22 -&gt; [sp, #48]	# spill size = 64
7b4 +   spill R18 -&gt; [sp, #40]	# spill size = 32
7b8 +   spill R30 -&gt; [sp, #12]	# spill size = 32
7bc +   spill R9 -&gt; [sp, #32]	# spill size = 64
7c0 +   spill R19 -&gt; [sp, #16]	# spill size = 64
7c4 +   spill R20 -&gt; [sp, #8]	# spill size = 32
7c8 +   mv  R11, precise klass java/util/HashMap$Node: 0x00000040d07fa990:Constant:exact *	# ptr, #@loadConP
7e0     spill R28 -&gt; R8	# spill size = 64
7e4     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #8 L[2]=R8 L[3]=sp + #16 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:152 (line 640) L[0]=sp + #0 L[1]=sp + #8 L[2]=_ L[3]=sp + #16 L[4]=sp + #28 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=sp + #44 STK[0]=sp + #48
        # OopMap {fp=Oop [0]=Oop [12]=NarrowOop [16]=Oop [32]=Oop [40]=NarrowOop [48]=Oop off=2024/0x7e8}

7e8     B89: #	out( B11 ) &lt;- in( B88 )  Freq: 1.20593e-05
        # Block is sole successor of call
7e8 +   spill [sp, #8] -&gt; R20	# spill size = 32
7ec +   spill [sp, #16] -&gt; R19	# spill size = 64
7f0 +   spill [sp, #32] -&gt; R9	# spill size = 64
7f4 +   spill [sp, #12] -&gt; R30	# spill size = 32
7f8 +   spill [sp, #40] -&gt; R18	# spill size = 32
7fc +   spill [sp, #48] -&gt; R22	# spill size = 64
800 +   spill [sp, #44] -&gt; R21	# spill size = 32
804 +   spill R10 -&gt; R24	# spill size = 64
808 +   j  B11	#@branch

80c     B90: #	out( N1360 ) &lt;- in( B3 )  Freq: 9.99996e-07
80c +   spill [sp, #0] -&gt; R8	# spill size = 64
810 +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
818 +   spill [sp, #28] -&gt; R28	# spill size = 32
81c +   li R11, #-28	# int, #@loadConI
820     spill R20 -&gt; [sp, #0]	# spill size = 32
824 +   spill [sp, #32] -&gt; [sp, #16]	# spill size = 64
82c +   spill R28 -&gt; [sp, #4]	# spill size = 32
830 +   spill R9 -&gt; [sp, #40]	# spill size = 64
834 +   spill R12 -&gt; [sp, #48]	# spill size = 32
838     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.HashMap::putVal @ bci:40 (line 628) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #40 L[7]=_ L[8]=_ L[9]=sp + #48 L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #40 STK[1]=sp + #48
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop off=2108/0x83c}
83c     #@ShouldNotReachHere

848     B91: #	out( N1360 ) &lt;- in( B35 )  Freq: 5.11067e-07
848 +   spill [sp, #0] -&gt; R8	# spill size = 64
84c +   li R11, #-42	# int, #@loadConI
850     spill R9 -&gt; [sp, #8]	# spill size = 64
854 +   spill R12 -&gt; [sp, #4]	# spill size = 32
858 +   spill R21 -&gt; [sp, #16]	# spill size = 64
85c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;array_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:59 (line 629) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=sp + #24 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #8 STK[1]=sp + #4 STK[2]=sp + #16
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=2144/0x860}
860     #@ShouldNotReachHere

86c     B92: #	out( N1360 ) &lt;- in( B2 )  Freq: 3.93535e-07
86c +   spill [sp, #0] -&gt; R8	# spill size = 64
870 +   li R11, #-187	# int, #@loadConI
874     spill R12 -&gt; [sp, #0]	# spill size = 32
878 +   spill R13 -&gt; [sp, #8]	# spill size = 64
87c +   spill R14 -&gt; [sp, #16]	# spill size = 64
880 +   spill R15 -&gt; [sp, #4]	# spill size = 32
884 +   spill R9 -&gt; [sp, #32]	# spill size = 64
888 +   spill R7 -&gt; [sp, #40]	# spill size = 32
88c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:16 (line 626) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=sp + #40 L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #40
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop off=2192/0x890}
890     #@ShouldNotReachHere

89c     B93: #	out( N1360 ) &lt;- in( B6 )  Freq: 2.75694e-07
89c +   spill [sp, #0] -&gt; R8	# spill size = 64
8a0 +   li R11, #-187	# int, #@loadConI
8a4     spill R20 -&gt; [sp, #0]	# spill size = 32
8a8 +   spill R28 -&gt; [sp, #8]	# spill size = 64
8ac +   spill R19 -&gt; [sp, #16]	# spill size = 64
8b0 +   spill R9 -&gt; [sp, #32]	# spill size = 64
8b4 +   spill R29 -&gt; [sp, #40]	# spill size = 64
8b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:109 (line 635) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #28 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#1
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop off=2236/0x8bc}
8bc     #@ShouldNotReachHere

8c8     B94: #	out( B37 ) &lt;- in( B66 )  Freq: 2.55527e-07
8c8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8c8     spill R23 -&gt; R11	# spill size = 64
8cc +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
8fc +   j  B37	#@branch

900     B95: #	out( N1360 ) &lt;- in( B43 )  Freq: 2.16846e-07
900 +   spill [sp, #0] -&gt; R8	# spill size = 64
904 +   li R11, #-34	# int, #@loadConI
908     spill R20 -&gt; [sp, #0]	# spill size = 32
90c +   spill R19 -&gt; [sp, #16]	# spill size = 64
910 +   spill R9 -&gt; [sp, #32]	# spill size = 64
914 +   spill R29 -&gt; [sp, #40]	# spill size = 64
918 +   spill R28 -&gt; [sp, #48]	# spill size = 64
91c +   spill R31 -&gt; [sp, #56]	# spill size = 64
920     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #28 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #48 STK[1]=sp + #56
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=2340/0x924}
924     #@ShouldNotReachHere

930     B96: #	out( N1360 ) &lt;- in( B48 )  Freq: 2.05483e-07
930     #@ShouldNotReachHere

93c     B97: #	out( N1360 ) &lt;- in( B49 )  Freq: 2.05483e-07
93c     #@ShouldNotReachHere

948     B98: #	out( B99 ) &lt;- in( B51 )  Freq: 9.66977e-08
948 +   spill R10 -&gt; R7	# spill size = 32

94c     B99: #	out( N1360 ) &lt;- in( B98 B50 )  Freq: 2.99488e-07
94c +   spill [sp, #0] -&gt; R8	# spill size = 64
950 +   spill [sp, #28] -&gt; R30	# spill size = 32
954 +   li R11, #-187	# int, #@loadConI
958     spill R20 -&gt; [sp, #0]	# spill size = 32
95c +   spill R12 -&gt; [sp, #8]	# spill size = 64
960 +   spill R19 -&gt; [sp, #16]	# spill size = 64
964 +   spill R30 -&gt; [sp, #4]	# spill size = 32
968 +   spill R9 -&gt; [sp, #32]	# spill size = 64
96c +   spill R29 -&gt; [sp, #40]	# spill size = 64
970 +   spill R7 -&gt; [sp, #28]	# spill size = 32
974     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:94 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #28
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop off=2424/0x978}
978     #@ShouldNotReachHere

984     B100: #	out( B55 ) &lt;- in( B73 )  Freq: 1.8417e-07
984 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
984     spill R23 -&gt; R11	# spill size = 64
988 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
9b8 +   j  B55	#@branch

9bc     B101: #	out( N1360 ) &lt;- in( B53 )  Freq: 1.75643e-07
9bc +   spill [sp, #0] -&gt; R8	# spill size = 64
9c0 +   li R11, #-187	# int, #@loadConI
9c4     spill R19 -&gt; [sp, #0]	# spill size = 64
9c8 +   spill R22 -&gt; [sp, #8]	# spill size = 64
9cc +   spill R9 -&gt; [sp, #16]	# spill size = 64
9d0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:236 (line 653) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #8 L[11]=_ L[12]=sp + #16 STK[0]=sp + #28
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=2516/0x9d4}
9d4     #@ShouldNotReachHere

9e0     B102: #	out( N1360 ) &lt;- in( B22 )  Freq: 1.51506e-07
9e0 +   spill [sp, #0] -&gt; R8	# spill size = 64
9e4 +   spill [sp, #28] -&gt; R29	# spill size = 32
9e8 +   li R11, #-34	# int, #@loadConI
9ec     spill R20 -&gt; [sp, #0]	# spill size = 32
9f0 +   spill R19 -&gt; [sp, #16]	# spill size = 64
9f4 +   spill R29 -&gt; [sp, #4]	# spill size = 32
9f8 +   spill R9 -&gt; [sp, #32]	# spill size = 64
9fc +   spill R22 -&gt; [sp, #40]	# spill size = 64
a00 +   spill R28 -&gt; [sp, #48]	# spill size = 64
a04 +   spill R21 -&gt; [sp, #28]	# spill size = 32
a08 +   spill R10 -&gt; [sp, #56]	# spill size = 64
a0c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=_ L[12]=sp + #28 STK[0]=sp + #48 STK[1]=sp + #56
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=2576/0xa10}
a10     #@ShouldNotReachHere

a1c     B103: #	out( N1360 ) &lt;- in( B27 )  Freq: 1.43566e-07
a1c     #@ShouldNotReachHere

a28     B104: #	out( N1360 ) &lt;- in( B28 )  Freq: 1.43566e-07
a28     #@ShouldNotReachHere

a34     B105: #	out( N1360 ) &lt;- in( B41 )  Freq: 1.03401e-07
a34 +   spill [sp, #0] -&gt; R8	# spill size = 64
a38 +   li R11, #-187	# int, #@loadConI
a3c     spill R20 -&gt; [sp, #0]	# spill size = 32
a40 +   spill R19 -&gt; [sp, #16]	# spill size = 64
a44 +   spill R9 -&gt; [sp, #32]	# spill size = 64
a48 +   spill R29 -&gt; [sp, #40]	# spill size = 64
a4c +   spill R31 -&gt; [sp, #56]	# spill size = 64
a50 +   spill R28 -&gt; [sp, #64]	# spill size = 64
a54     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:81 (line 632) L[0]=R8 L[1]=sp + #0 L[2]=sp + #64 L[3]=sp + #16 L[4]=sp + #28 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=sp + #56 L[12]=_ STK[0]=sp + #56 STK[1]=sp + #64
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=2648/0xa58}
a58     #@ShouldNotReachHere

a64     B106: #	out( N1360 ) &lt;- in( B47 )  Freq: 1.01395e-07
a64 +   spill [sp, #0] -&gt; R8	# spill size = 64
a68 +   spill [sp, #28] -&gt; R7	# spill size = 32
a6c +   li R11, #-187	# int, #@loadConI
a70     spill R20 -&gt; [sp, #0]	# spill size = 32
a74 +   spill R19 -&gt; [sp, #16]	# spill size = 64
a78 +   spill R7 -&gt; [sp, #4]	# spill size = 32
a7c +   spill R9 -&gt; [sp, #32]	# spill size = 64
a80 +   spill R29 -&gt; [sp, #40]	# spill size = 64
a84 +   spill R12 -&gt; [sp, #48]	# spill size = 64
a88 +   spill R31 -&gt; [sp, #56]	# spill size = 64
a8c +   spill R30 -&gt; [sp, #28]	# spill size = 32
a90 +   spill R28 -&gt; [sp, #64]	# spill size = 32
a94     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #48 L[1]=_ L[2]=sp + #56 STK[0]=sp + #28 STK[1]=sp + #64
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=2712/0xa98}
a98     #@ShouldNotReachHere

aa4     B107: #	out( N1360 ) &lt;- in( B20 )  Freq: 7.22436e-08
aa4 +   spill [sp, #0] -&gt; R8	# spill size = 64
aa8 +   spill [sp, #28] -&gt; R29	# spill size = 32
aac +   li R11, #-187	# int, #@loadConI
ab0     spill R20 -&gt; [sp, #0]	# spill size = 32
ab4 +   spill R19 -&gt; [sp, #16]	# spill size = 64
ab8 +   spill R29 -&gt; [sp, #4]	# spill size = 32
abc +   spill R9 -&gt; [sp, #32]	# spill size = 64
ac0 +   spill R22 -&gt; [sp, #40]	# spill size = 64
ac4 +   spill R28 -&gt; [sp, #48]	# spill size = 64
ac8 +   spill R21 -&gt; [sp, #28]	# spill size = 32
acc +   spill R10 -&gt; [sp, #64]	# spill size = 64
ad0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:193 (line 645) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=sp + #64 L[12]=sp + #28 STK[0]=sp + #64 STK[1]=sp + #48
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [64]=Oop off=2772/0xad4}
ad4     #@ShouldNotReachHere

ae0     B108: #	out( N1360 ) &lt;- in( B26 )  Freq: 7.08426e-08
ae0 +   spill [sp, #28] -&gt; R28	# spill size = 32
ae4 +   li R11, #-187	# int, #@loadConI
ae8     spill R20 -&gt; [sp, #8]	# spill size = 32
aec +   spill R19 -&gt; [sp, #16]	# spill size = 64
af0 +   spill R28 -&gt; [sp, #12]	# spill size = 32
af4 +   spill R9 -&gt; [sp, #32]	# spill size = 64
af8 +   spill R22 -&gt; [sp, #40]	# spill size = 64
afc +   spill R21 -&gt; [sp, #28]	# spill size = 32
b00 +   spill R12 -&gt; [sp, #56]	# spill size = 64
b04 +   spill R10 -&gt; [sp, #64]	# spill size = 64
b08 +   spill R30 -&gt; [sp, #72]	# spill size = 32
b0c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #56 L[1]=_ L[2]=sp + #64 STK[0]=sp + #72 STK[1]=R8
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #56 L[3]=sp + #16 L[4]=sp + #12 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=_ L[12]=sp + #28
        # OopMap {[0]=Oop [16]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=2832/0xb10}
b10     #@ShouldNotReachHere

b1c     B109: #	out( B12 ) &lt;- in( B80 )  Freq: 6.02859e-08
b1c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
b1c     spill R23 -&gt; R11	# spill size = 64
b20 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
b50 +   j  B12	#@branch

b54     B110: #	out( N1360 ) &lt;- in( B25 )  Freq: 1e-35
b54 +   spill [sp, #0] -&gt; R8	# spill size = 64
b58 +   spill [sp, #28] -&gt; R7	# spill size = 32
b5c +   spill [sp, #24] -&gt; R28	# spill size = 32
b60 +   li R11, #-34	# int, #@loadConI
b64     spill R20 -&gt; [sp, #0]	# spill size = 32
b68 +   spill R19 -&gt; [sp, #8]	# spill size = 64
b6c +   spill R7 -&gt; [sp, #4]	# spill size = 32
b70 +   spill R28 -&gt; [sp, #16]	# spill size = 32
b74 +   spill R9 -&gt; [sp, #24]	# spill size = 64
b78 +   spill R22 -&gt; [sp, #32]	# spill size = 64
b7c +   spill R21 -&gt; [sp, #20]	# spill size = 32
b80 +   spill R12 -&gt; [sp, #48]	# spill size = 64
b84 +   spill R10 -&gt; [sp, #64]	# spill size = 64
b88     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=sp + #64 L[2]=_ STK[0]=sp + #64
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #8 L[4]=sp + #4 L[5]=sp + #16 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #32 L[11]=_ L[12]=sp + #20
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [64]=Oop off=2956/0xb8c}
b8c     #@ShouldNotReachHere

b98     B111: #	out( N1360 ) &lt;- in( B46 )  Freq: 1e-35
b98 +   spill [sp, #0] -&gt; R8	# spill size = 64
b9c +   li R11, #-34	# int, #@loadConI
ba0     spill R20 -&gt; [sp, #0]	# spill size = 32
ba4 +   spill R19 -&gt; [sp, #16]	# spill size = 64
ba8 +   spill R9 -&gt; [sp, #32]	# spill size = 64
bac +   spill R29 -&gt; [sp, #40]	# spill size = 64
bb0 +   spill R12 -&gt; [sp, #48]	# spill size = 64
bb4 +   spill R31 -&gt; [sp, #64]	# spill size = 64
bb8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=sp + #64 L[2]=_ STK[0]=sp + #64
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #28 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [64]=Oop off=3004/0xbbc}
bbc     #@ShouldNotReachHere

bc8     B112: #	out( N1360 ) &lt;- in( B45 )  Freq: 2.05483e-07
bc8 +   spill [sp, #0] -&gt; R8	# spill size = 64
bcc +   li R11, #-12	# int, #@loadConI
bd0     spill R20 -&gt; [sp, #0]	# spill size = 32
bd4 +   spill R19 -&gt; [sp, #16]	# spill size = 64
bd8 +   spill R9 -&gt; [sp, #32]	# spill size = 64
bdc +   spill R29 -&gt; [sp, #40]	# spill size = 64
be0 +   spill R12 -&gt; [sp, #48]	# spill size = 64
be4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #28 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop off=3048/0xbe8}
be8     #@ShouldNotReachHere

bf4     B113: #	out( N1360 ) &lt;- in( B61 )  Freq: 1.77014e-07
bf4 +   li R11, #-10	# int, #@loadConI
bf8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:26 (line 627) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#NULL
        # OopMap {off=3068/0xbfc}
bfc     #@ShouldNotReachHere

c08     B114: #	out( N1360 ) &lt;- in( B24 )  Freq: 1.43567e-07
c08 +   spill [sp, #0] -&gt; R8	# spill size = 64
c0c +   spill [sp, #28] -&gt; R28	# spill size = 32
c10 +   spill [sp, #24] -&gt; R7	# spill size = 32
c14 +   li R11, #-12	# int, #@loadConI
c18     spill R20 -&gt; [sp, #0]	# spill size = 32
c1c +   spill R19 -&gt; [sp, #8]	# spill size = 64
c20 +   spill R28 -&gt; [sp, #4]	# spill size = 32
c24 +   spill R7 -&gt; [sp, #16]	# spill size = 32
c28 +   spill R9 -&gt; [sp, #24]	# spill size = 64
c2c +   spill R22 -&gt; [sp, #32]	# spill size = 64
c30 +   spill R21 -&gt; [sp, #20]	# spill size = 32
c34 +   spill R12 -&gt; [sp, #48]	# spill size = 64
c38     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #8 L[4]=sp + #4 L[5]=sp + #16 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #32 L[11]=_ L[12]=sp + #20
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop off=3132/0xc3c}
c3c     #@ShouldNotReachHere

c48     B115: #	out( N1360 ) &lt;- in( B42 )  Freq: 1.034e-07
c48 +   spill [sp, #0] -&gt; R8	# spill size = 64
c4c +   li R11, #-187	# int, #@loadConI
c50     spill R20 -&gt; [sp, #0]	# spill size = 32
c54 +   spill R19 -&gt; [sp, #16]	# spill size = 64
c58 +   spill R9 -&gt; [sp, #32]	# spill size = 64
c5c +   spill R29 -&gt; [sp, #40]	# spill size = 64
c60 +   spill R31 -&gt; [sp, #48]	# spill size = 64
c64 +   spill R28 -&gt; [sp, #56]	# spill size = 64
c68     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:85 (line 632) L[0]=R8 L[1]=sp + #0 L[2]=sp + #56 L[3]=sp + #16 L[4]=sp + #28 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=sp + #48 L[12]=_ STK[0]=sp + #56
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=3180/0xc6c}
c6c     #@ShouldNotReachHere

c78     B116: #	out( N1360 ) &lt;- in( B21 )  Freq: 7.22436e-08
c78 +   spill [sp, #0] -&gt; R8	# spill size = 64
c7c +   spill [sp, #28] -&gt; R7	# spill size = 32
c80 +   li R11, #-187	# int, #@loadConI
c84     spill R20 -&gt; [sp, #0]	# spill size = 32
c88 +   spill R19 -&gt; [sp, #16]	# spill size = 64
c8c +   spill R7 -&gt; [sp, #4]	# spill size = 32
c90 +   spill R9 -&gt; [sp, #32]	# spill size = 64
c94 +   spill R22 -&gt; [sp, #40]	# spill size = 64
c98 +   spill R28 -&gt; [sp, #48]	# spill size = 64
c9c +   spill R10 -&gt; [sp, #56]	# spill size = 64
ca0 +   spill R21 -&gt; [sp, #28]	# spill size = 32
ca4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:197 (line 645) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=sp + #56 L[12]=sp + #28 STK[0]=sp + #48
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=3240/0xca8}
ca8     #@ShouldNotReachHere

cb4     B117: #	out( B121 ) &lt;- in( B88 )  Freq: 1.20595e-10
cb4      -- 	// exception oop; no code emitted, #@CreateException
cb4 +   spill R10 -&gt; R11	# spill size = 64
cb8 +   j  B121	#@branch

cbc     B118: #	out( B121 ) &lt;- in( B86 )  Freq: 5.11152e-10
cbc      -- 	// exception oop; no code emitted, #@CreateException
cbc +   spill R10 -&gt; R11	# spill size = 64
cc0 +   j  B121	#@branch

cc4     B119: #	out( B121 ) &lt;- in( B63 )  Freq: 2.51242e-07
cc4      -- 	// exception oop; no code emitted, #@CreateException
cc4 +   spill R10 -&gt; R11	# spill size = 64
cc8 +   j  B121	#@branch

ccc     B120: #	out( B121 ) &lt;- in( B60 )  Freq: 1.74698e-06
ccc      -- 	// exception oop; no code emitted, #@CreateException
ccc +   spill R10 -&gt; R11	# spill size = 64

cd0     B121: #	out( N1360 ) &lt;- in( B120 B118 B117 B119 )  Freq: 1.99885e-06
cd0     # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
cdc +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='473'>
----------------------- MetaData before Compile_id = 473 ------------------------
{method}
 - this oop:          0x00000040961a1ad8
 - method holder:     &apos;java/util/HashMap&apos;
 - constants:         0x000000409619f4e0 constant pool [610] {0x000000409619f4e0} for &apos;java/util/HashMap&apos; cache=0x00000040961a4fd8
 - access:            0x81000001  public 
 - name:              &apos;put&apos;
 - signature:         &apos;(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;&apos;
 - max stack:         7
 - max locals:        3
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      7
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x00000040083172b0: 0xbbb i2c: 0x0000004013944dc0 c2i: 0x0000004013944e0c c2iUV: 0x0000004013944dd8
 - compiled entry     0x000000400c506840
 - code size:         13
 - code start:        0x00000040961a1a98
 - code end (excl):   0x00000040961a1aa5
 - method data:       0x0000004096487118
 - checked ex length: 0
 - linenumber start:  0x00000040961a1aa5
 - localvar length:   3
 - localvar start:    0x00000040961a1ab0
 - compiled code: nmethod  20131  176       3       java.util.HashMap::put (13 bytes)

------------------------ OptoAssembly for Compile_id = 473 -----------------------
#
#  java/lang/Object * ( java/util/HashMap:NotNull *, java/lang/Object *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/HashMap:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
#r016 c_rarg3:c_rarg3   : parm 2: java/lang/Object *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N121: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B9 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     spill R11 -&gt; [sp, #8]	# spill size = 64
040 +   spill R13 -&gt; [sp, #0]	# spill size = 64
044 +   spill R12 -&gt; R8	# spill size = 64
048     lwu  R28, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
04c     NullCheck R12

04c     B2: #	out( B7 B3 ) &lt;- in( B1 )  Freq: 1
04c +   decode_klass_not_null  R28, R28	#@decodeKlass_not_null
058 +   ld  R28, [R28, #504]	# ptr, #@loadP
05c +   mv  R7, metadataptr:Constant0x00000040d820b280	# ptr, #@loadConP
074 +   bne  R28, R7, B7	#@cmpP_branch  P=0.001000 C=-1.000000

078     B3: #	out( B7 B4 ) &lt;- in( B2 )  Freq: 0.999
078 +   ld  R7, [R12]	# int, #@loadL
07c +   li R29, #1	# long, #@loadConL
080 +   andi  R28, R7, #7	#@andL_reg_imm
084 +   bne  R28, R29, B7	#@cmpL_branch  P=0.001000 C=-1.000000

088     B4: #	out( B7 B5 ) &lt;- in( B3 )  Freq: 0.998001
088 +   srli  R7, R7, (#8 &amp; 0x3f)	#@urShiftL_reg_imm
08c +   li R29, #2147483647	# int, #@loadConI
094 +   addw  R7, R7, zr	#@convL2I_reg
098 +   andr  R10, R7, R29	#@andI_reg_reg
09c +   beq  R10, zr, B7	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0a0     B5: #	out( B11 B6 ) &lt;- in( B8 B4 )  Freq: 0.999999
0a0 +   srliw  R7, R10, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
0a4 +   xorr  R12, R7, R10	#@xorI_reg_reg
0a8 +   li R15, #0	# int, #@loadConI
0ac +   li R16, #1	# int, #@loadConI
0b0     spill [sp, #8] -&gt; R11	# spill size = 64
0b4 +   spill R8 -&gt; R13	# spill size = 64
0b8 +   spill [sp, #0] -&gt; R14	# spill size = 64
0bc     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::putVal
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {off=192/0xc0}

0c0     B6: #	out( N121 ) &lt;- in( B5 )  Freq: 0.999979
        # Block is sole successor of call
0c0     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0d8 +   ret	// return register, #@Ret

0dc     B7: #	out( B10 B8 ) &lt;- in( B2 B3 B4 )  Freq: 0.00299699
0dc +   spill R12 -&gt; R11	# spill size = 64
0e0     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=R8 L[2]=sp + #0 STK[0]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=252/0xfc}

0fc     B8: #	out( B5 ) &lt;- in( B7 )  Freq: 0.00299693
        # Block is sole successor of call
0fc +   j  B5	#@branch

100     B9: #	out( N121 ) &lt;- in( B1 )  Freq: 4.76837e-07
100 +   li R11, #-187	# int, #@loadConI
104     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::hash @ bci:1 (line 338) L[0]=R8 L[1]=_ STK[0]=R8
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=R8 L[2]=sp + #0 STK[0]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=264/0x108}
108     #@ShouldNotReachHere

114     B10: #	out( B12 ) &lt;- in( B7 )  Freq: 2.99699e-08
114      -- 	// exception oop; no code emitted, #@CreateException
114 +   spill R10 -&gt; R11	# spill size = 64
118 +   j  B12	#@branch

11c     B11: #	out( B12 ) &lt;- in( B5 )  Freq: 9.99999e-06
11c      -- 	// exception oop; no code emitted, #@CreateException
11c +   spill R10 -&gt; R11	# spill size = 64

120     B12: #	out( N121 ) &lt;- in( B10 B11 )  Freq: 1.003e-05
120     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
12c +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='476'>
----------------------- MetaData before Compile_id = 476 ------------------------
{method}
 - this oop:          0x0000004096291480
 - method holder:     &apos;java/util/HashSet&apos;
 - constants:         0x00000040962901e0 constant pool [285] {0x00000040962901e0} for &apos;java/util/HashSet&apos; cache=0x0000004096291e18
 - access:            0x81000001  public 
 - name:              &apos;add&apos;
 - signature:         &apos;(Ljava/lang/Object;)Z&apos;
 - max stack:         4
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      5
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824bb30: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c5186c0
 - code size:         20
 - code start:        0x0000004096291448
 - code end (excl):   0x000000409629145c
 - method data:       0x000000409648dd90
 - checked ex length: 0
 - linenumber start:  0x000000409629145c
 - localvar length:   2
 - localvar start:    0x0000004096291464
 - compiled code: nmethod  20212  212       3       java.util.HashSet::add (20 bytes)

------------------------ OptoAssembly for Compile_id = 476 -----------------------
#
#  bool ( java/util/HashSet:NotNull *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/HashSet:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N144: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B10 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lwu  R7, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashSet.map
040 +   decode_heap_oop  R7, R7	#@decodeHeapOop
044     spill R7 -&gt; [sp, #0]	# spill size = 64
048 +   beq   R7, zr, B10	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

04c     B2: #	out( B11 B3 ) &lt;- in( B1 )  Freq: 0.999999
04c +   spill R12 -&gt; R8	# spill size = 64
050     lwu  R28, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
054     NullCheck R12

054     B3: #	out( B8 B4 ) &lt;- in( B2 )  Freq: 0.999999
054 +   decode_klass_not_null  R28, R28	#@decodeKlass_not_null
060 +   ld  R28, [R28, #504]	# ptr, #@loadP
064 +   mv  R7, metadataptr:Constant0x00000040d061f880	# ptr, #@loadConP
07c +   bne  R28, R7, B8	#@cmpP_branch  P=0.001000 C=-1.000000

080     B4: #	out( B8 B5 ) &lt;- in( B3 )  Freq: 0.998999
080 +   ld  R7, [R12]	# int, #@loadL
084 +   li R29, #1	# long, #@loadConL
088 +   andi  R28, R7, #7	#@andL_reg_imm
08c +   bne  R28, R29, B8	#@cmpL_branch  P=0.001000 C=-1.000000

090     B5: #	out( B8 B6 ) &lt;- in( B4 )  Freq: 0.998
090 +   srli  R7, R7, (#8 &amp; 0x3f)	#@urShiftL_reg_imm
094 +   li R29, #2147483647	# int, #@loadConI
09c +   addw  R7, R7, zr	#@convL2I_reg
0a0 +   andr  R10, R7, R29	#@andI_reg_reg
0a4 +   beq  R10, zr, B8	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0a8     B6: #	out( B13 B7 ) &lt;- in( B9 B5 )  Freq: 0.999998
0a8 +   srliw  R7, R10, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
0ac +   xorr  R12, R7, R10	#@xorI_reg_reg
0b0 +   mv  R14, java/lang/Object:exact *	# ptr, #@loadConP
0c8 +   li R15, #0	# int, #@loadConI
0cc +   li R16, #1	# int, #@loadConI
0d0     spill [sp, #0] -&gt; R11	# spill size = 64
0d4 +   spill R8 -&gt; R13	# spill size = 64
0d8     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::putVal
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {off=220/0xdc}

0dc     B7: #	out( N144 ) &lt;- in( B6 )  Freq: 0.999978
        # Block is sole successor of call
0dc +   snez  R7, R10	#@convP2Bool
0e0 +   xori  R10, R7, #1	#@xorI_reg_imm
0e4     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0fc +   ret	// return register, #@Ret

100     B8: #	out( B12 B9 ) &lt;- in( B3 B4 B5 )  Freq: 0.00299698
100 +   spill R12 -&gt; R11	# spill size = 64
104     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=R8 L[2]=#Ptr0x00000040d820ae30 STK[0]=sp + #0
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=288/0x120}

120     B9: #	out( B6 ) &lt;- in( B8 )  Freq: 0.00299692
        # Block is sole successor of call
120 +   j  B6	#@branch

124     B10: #	out( N144 ) &lt;- in( B1 )  Freq: 1.01328e-06
124 +   li R11, #-10	# int, #@loadConI
128     spill R12 -&gt; R8	# spill size = 64
12c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8 STK[2]=#Ptr0x00000040d820ae30
        # OopMap {fp=Oop off=304/0x130}
130     #@ShouldNotReachHere

13c     B11: #	out( N144 ) &lt;- in( B2 )  Freq: 4.76837e-07
13c +   li R11, #-187	# int, #@loadConI
140     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::hash @ bci:1 (line 338) L[0]=R8 L[1]=_ STK[0]=R8
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=R8 L[2]=#Ptr0x00000040d820ae30 STK[0]=sp + #0
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=324/0x144}
144     #@ShouldNotReachHere

150     B12: #	out( B14 ) &lt;- in( B8 )  Freq: 2.99698e-08
150      -- 	// exception oop; no code emitted, #@CreateException
150 +   spill R10 -&gt; R11	# spill size = 64
154 +   j  B14	#@branch

158     B13: #	out( B14 ) &lt;- in( B6 )  Freq: 9.99998e-06
158      -- 	// exception oop; no code emitted, #@CreateException
158 +   spill R10 -&gt; R11	# spill size = 64

15c     B14: #	out( N144 ) &lt;- in( B12 B13 )  Freq: 1.003e-05
15c     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
168 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='478'>
----------------------- MetaData before Compile_id = 478 ------------------------
{method}
 - this oop:          0x000000409600fdc8
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000008  static 
 - name:              &apos;checkIndex&apos;
 - signature:         &apos;(II)V&apos;
 - max stack:         5
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400831b1d0: 0xaa i2c: 0x0000004013945f40 c2i: 0x0000004013945f88 c2iUV: 0x0000004013945f54
 - compiled entry     0x000000400c56cb00
 - code size:         48
 - code start:        0x000000409600fd70
 - code end (excl):   0x000000409600fda0
 - method data:       0x000000409658b428
 - checked ex length: 0
 - linenumber start:  0x000000409600fda0
 - localvar length:   2
 - localvar start:    0x000000409600fdae
 - compiled code: nmethod  20262  293       3       java.lang.String::checkIndex (48 bytes)

------------------------ OptoAssembly for Compile_id = 478 -----------------------
#
#  void ( int, int )
#
#r012 c_rarg1   : parm 0: int
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B4 B5 B3 )  Freq: 1

000     B1: #	out( B4 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     blt  R11, zr, B4	#@cmpI_reg_imm0_branch  P=0.000000 C=5139.000000

020     B2: #	out( B5 B3 ) &lt;- in( B1 )  Freq: 1
020 +   bge  R11, R12, B5	#@cmpI_branch  P=0.000000 C=5139.000000

024     B3: #	out( N1 ) &lt;- in( B2 )  Freq: 0.999999
024     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
03c +   ret	// return register, #@Ret

040     B4: #	out( N1 ) &lt;- in( B1 )  Freq: 5e-07
040 +   spill R11 -&gt; [sp, #4]	# spill size = 32
044 +   spill R12 -&gt; [sp, #0]	# spill size = 32
048 +   li R11, #-187	# int, #@loadConI
04c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkIndex @ bci:1 (line 4557) L[0]=sp + #4 L[1]=sp + #0 STK[0]=sp + #4
        # OopMap {off=80/0x50}
050     #@ShouldNotReachHere

05c     B5: #	out( N1 ) &lt;- in( B2 )  Freq: 4.76837e-07
05c +   spill R11 -&gt; [sp, #4]	# spill size = 32
060 +   spill R12 -&gt; [sp, #8]	# spill size = 32
064 +   li R11, #-187	# int, #@loadConI
068     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkIndex @ bci:6 (line 4557) L[0]=sp + #4 L[1]=sp + #8 STK[0]=sp + #4 STK[1]=sp + #8
        # OopMap {off=108/0x6c}
06c +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='479'>
----------------------- MetaData before Compile_id = 479 ------------------------
{method}
 - this oop:          0x00000040960b7f20
 - method holder:     &apos;java/lang/AbstractStringBuilder&apos;
 - constants:         0x00000040960b5e28 constant pool [547]/operands[14] {0x00000040960b5e28} for &apos;java/lang/AbstractStringBuilder&apos; cache=0x0000004096285bb8
 - access:            0x81000002  private 
 - name:              &apos;ensureCapacityInternal&apos;
 - signature:         &apos;(I)V&apos;
 - max stack:         5
 - max locals:        3
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b960: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c4b4e40
 - code size:         39
 - code start:        0x00000040960b7ec0
 - code end (excl):   0x00000040960b7ee7
 - method data:       0x00000040963f4810
 - checked ex length: 0
 - linenumber start:  0x00000040960b7ee7
 - localvar length:   3
 - localvar start:    0x00000040960b7efa
 - compiled code: nmethod  20324   33       3       java.lang.AbstractStringBuilder::ensureCapacityInternal (39 bytes)

------------------------ OptoAssembly for Compile_id = 479 -----------------------
#
#  void ( java/lang/AbstractStringBuilder:NotNull *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/AbstractStringBuilder:NotNull *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N411: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B34 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/AbstractStringBuilder.value
040 +   lb  R29, [R11, #16]	# byte, #@loadB ! Field: java/lang/AbstractStringBuilder.coder
044     spill R11 -&gt; [sp, #0]	# spill size = 64
048 +   decode_heap_oop  R31, R7	#@decodeHeapOop
04c     lwu  R8, [R31, #12]	# range, #@loadRange
050     NullCheck R31

050     B2: #	out( B4 B3 ) &lt;- in( B1 )  Freq: 0.999999
050 +   sraw  R7, R8, R29	#@rShiftI_reg_reg
054 +   subw  R28, R12, R7	#@subI_reg_reg
058 +   bgt  R28, zr, B4	#@cmpI_reg_imm0_branch  P=0.055256 C=5375.000000

05c     B3: #	out( N411 ) &lt;- in( B22 B23 B20 B19 B18 B2 )  Freq: 0.999998
05c     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
074 +   ret	// return register, #@Ret

078     B4: #	out( B7 B5 ) &lt;- in( B2 )  Freq: 0.0552558
078 +   li R7, #2	# int, #@loadConI
07c +   sllw  R30, R12, R29	#@lShiftI_reg_reg
080 +   sllw  R28, R7, R29	#@lShiftI_reg_reg
084 +   subw  R12, R30, R8	#@subI_reg_reg
088 +   addw  R28, R28, R8	#@addI_reg_reg
08c     spill R12 -&gt; R7	# spill size = 32
090 +   CMove R7, (R12 lt R28), R7, R28	#@cmovI_cmpI
	
098 +   addw  R10, R7, R8	#@addI_reg_reg
09c +   li R7, #2147483639	# int, #@loadConI
0a4 +   addiw  R28, R10, #-1	#@addI_reg_imm
0a8 +   bltu  R28, R7, B7	#@cmpU_branch  P=0.500000 C=-1.000000

0ac     B5: #	out( B36 B6 ) &lt;- in( B4 )  Freq: 0.0276279
0ac +   spill R31 -&gt; [sp, #24]	# spill size = 64
0b0 +   spill R8 -&gt; R11	# spill size = 32
0b4     CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect jdk.internal.util.ArraysSupport::hugeLength
        # jdk.internal.util.ArraysSupport::newLength @ bci:23 (line 642) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.lang.AbstractStringBuilder::newCapacity @ bci:29 (line 257) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # java.lang.AbstractStringBuilder::ensureCapacityInternal @ bci:24 (line 229) L[0]=sp + #0 L[1]=_ L[2]=_ STK[0]=sp + #0 STK[1]=sp + #24
        # OopMap {[0]=Oop [24]=Oop off=184/0xb8}

0b8     B6: #	out( B7 ) &lt;- in( B5 )  Freq: 0.0276273
        # Block is sole successor of call
0b8 +   spill [sp, #24] -&gt; R31	# spill size = 64

0bc     B7: #	out( B30 B8 ) &lt;- in( B4 B6 )  Freq: 0.0552552
0bc +   spill [sp, #0] -&gt; R7	# spill size = 64
0c0 +   lb  R28, [R7, #16]	# byte, #@loadB ! Field: java/lang/AbstractStringBuilder.coder
0c4 +   sraw  R7, R10, R28	#@rShiftI_reg_reg
0c8 +   sllw  R7, R7, R28	#@lShiftI_reg_reg
0cc +   li R29, #2147483647	# int, #@loadConI
0d4     spill R7 -&gt; R28	# spill size = 32
0d8 +   li R30, #1048576	# int, #@loadConI
0dc +   CMove R28, (R8 lt R7), R28, R8	#@cmovI_cmpI
	
0e4     beq  R10, R29, B30	#@cmpI_branch  P=0.000001 C=-1.000000

0e8     B8: #	out( B9 B9 ) &lt;- in( B7 )  Freq: 0.0552552
0e8 +   addw  R29, R7, zr	#@convI2L_reg_reg
0ec +   bleu  R7, R30, B9	#@cmpU_branch  P=0.999999 C=-1.000000

0f0     B9: #	out( B32 B10 ) &lt;- in( B8 B8 )  Freq: 0.0552552
0f0 +   addi  R10, R29, #23	#@addL_reg_imm
0f4 +   bltu  R8, R28, B32	#@cmpU_branch  P=0.000001 C=-1.000000

0f8     B10: #	out( B32 B11 ) &lt;- in( B9 )  Freq: 0.0552551
0f8 +   bltu  R7, R28, B32	#@cmpU_branch  P=0.000001 C=-1.000000

0fc     B11: #	out( B28 B12 ) &lt;- in( B10 )  Freq: 0.0552551
0fc +   andi  R8, R10, #-8	#@andL_reg_imm
100 +   bgtu  R7, R30, B28	#@cmpU_branch  P=0.000001 C=-1.000000

104     B12: #	out( B28 B13 ) &lt;- in( B11 )  Freq: 0.055255
104 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
104     ld  R9, [R23, #288]	# ptr, #@loadP
108 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
108     ld  R30, [R23, #304]	# ptr, #@loadP
10c +   add R29, R9, R8	# ptr, #@addP_reg_reg
110 +   bgeu  R29, R30, B28	#@cmpP_branch  P=0.000100 C=-1.000000

114     B13: #	out( B14 ) &lt;- in( B12 )  Freq: 0.0552495
114 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
114     sd  R29, [R23, #288]	# ptr, #@storeP
118 +   li R29, #1	# long, #@loadConL
11c +   mv  R30, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
12c +   sd  R29, [R9]	# long, #@storeL
130 +   sw  R30, [R9, #8]	# compressed klass ptr, #@storeNKlass
134 +   sw  R7, [R9, #12]	# int, #@storeI

138     B14: #	out( B31 B15 ) &lt;- in( B29 B13 )  Freq: 0.0552551
138     
138 +   srli  R29, R10, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
13c +   # checkcastPP of R9, #@checkCastPP
13c     addi  R11, R9, #16	# ptr, #@addP_reg_imm
140 +   encode_heap_oop  R18, R9	#@encodeHeapOop
144 +   beq  R28, zr, B31	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

148     B15: #	out( B24 B16 ) &lt;- in( B14 )  Freq: 0.055255
148 +   addi  R10, R31, #16	# ptr, #@addP_reg_imm
14c +   blt  R28, R7, B24	#@cmpI_branch  P=0.001000 C=-1.000000

150     B16: #	out( B17 ) &lt;- in( B15 )  Freq: 0.0551997
150 +   addi  R7, R8, #-16	#@addL_reg_imm
154 +   srli  R12, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
158 +   CALL, runtime leaf nofp 0x000000401396d840	#@CallLeafNoFPDirect jlong_disjoint_arraycopy
        No JVM State Info
        # 

15c     B17: #	out( B25 B18 ) &lt;- in( B24 B16 B31 )  Freq: 0.0552551
15c     MEMBAR-store-store	#@membar_storestore
160 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
160     lb  R7, [R23, #56]	# byte, #@loadB
164 +   bne  R7, zr, B25	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

168     B18: #	out( B3 B19 ) &lt;- in( B33 B27 B25 B17 )  Freq: 0.0552551
168 +   spill [sp, #0] -&gt; R7	# spill size = 64
16c +   mv  R7, R7	# ptr -&gt; long, #@castP2X
16c +   mv  R28, R9	# ptr -&gt; long, #@castP2X
170 +   xorr  R28, R28, R7	#@xorL_reg_reg
174 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
178     spill [sp, #0] -&gt; R29	# spill size = 64
17c +   sw  R18, [R29, #20]	# compressed ptr, #@storeN ! Field: java/lang/AbstractStringBuilder.value
180 +   beq  R28, zr, B3	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

184     B19: #	out( B3 B20 ) &lt;- in( B18 )  Freq: 0.0551998
184 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
188 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
194 +   add R10, R28, R7	# ptr, #@addP_reg_reg
198 +   lb  R28, [R10]	# byte, #@loadB
19c +   li R7, #4	# int, #@loadConI
1a0 +   beq  R28, R7, B3	#@cmpI_branch  P=0.999000 C=-1.000000

1a4     B20: #	out( B3 B21 ) &lt;- in( B19 )  Freq: 5.51998e-05
1a4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a4     ld  R7, [R23, #64]	# int, #@loadL
1a8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1a8     ld  R28, [R23, #80]	# ptr, #@loadP
1ac +   #@membar_volatile
	fence iorw iorw
1b0 +   lb  R30, [R10]	# byte, #@loadB
1b4 +   beq  R30, zr, B3	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1b8     B21: #	out( B23 B22 ) &lt;- in( B20 )  Freq: 2.75999e-05
1b8 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1bc +   bne  R7, zr, B23	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1c0     B22: #	out( B3 ) &lt;- in( B21 )  Freq: 1.38e-05
1c0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1c0     spill R23 -&gt; R11	# spill size = 64
1c4 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
1f4 +   j  B3	#@branch

1f8     B23: #	out( B3 ) &lt;- in( B21 )  Freq: 1.38e-05
1f8 +   add R28, R28, R7	# ptr, #@addP_reg_reg
1fc +   addi  R7, R7, #-8	#@addL_reg_imm
200 +   sd  R10, [R28, #-8]	# ptr, #@storeP
204 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
204     sd  R7, [R23, #64]	# long, #@storeL
208 +   j  B3	#@branch

20c     B24: #	out( B17 ) &lt;- in( B15 )  Freq: 5.5255e-05
20c +   addw  R12, R28, zr	#@convI2L_reg_reg
210 +   addi  R7, R12, #16	#@addL_reg_imm
214 +   srli  R30, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
218 +   andi  R7, R7, #-8	#@andL_reg_imm
21c +   add R28, R9, R7	# ptr, #@addP_reg_reg
220 +   sub  R29, R29, R30	#@subL_reg_reg
224     ClearArray R29, R28	#@clearArray_reg_reg
27c +   CALL, runtime leaf nofp 0x000000401396cf00	#@CallLeafNoFPDirect arrayof_jbyte_disjoint_arraycopy
        No JVM State Info
        # 
280 +   j  B17	#@branch

284     B25: #	out( B18 B26 ) &lt;- in( B17 )  Freq: 5.52543e-05
284 +   spill [sp, #0] -&gt; R7	# spill size = 64
288 +   lwu  R28, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/AbstractStringBuilder.value
28c +   decode_heap_oop  R10, R28	#@decodeHeapOop
290 +   beq   R10, zr, B18	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

294     B26: #	out( B33 B27 ) &lt;- in( B25 )  Freq: 2.76272e-05
294 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
294     ld  R7, [R23, #32]	# int, #@loadL
298 +   beq  R7, zr, B33	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

29c     B27: #	out( B18 ) &lt;- in( B26 )  Freq: 2.75995e-05
29c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
29c     ld  R28, [R23, #48]	# ptr, #@loadP
2a0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
2a4 +   addi  R7, R7, #-8	#@addL_reg_imm
2a8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
2ac +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2ac     sd  R7, [R23, #32]	# long, #@storeL
2b0 +   j  B18	#@branch

2b4     B28: #	out( B35 B29 ) &lt;- in( B11 B12 )  Freq: 5.58241e-06
2b4 +   spill R10 -&gt; [sp, #24]	# spill size = 64
2b8 +   spill R28 -&gt; [sp, #12]	# spill size = 32
2bc +   spill R31 -&gt; [sp, #16]	# spill size = 64
2c0 +   spill R7 -&gt; [sp, #8]	# spill size = 32
2c4 +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
2dc     spill R7 -&gt; R12	# spill size = 32
2e0     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # java.util.Arrays::copyOf @ bci:1 (line 3537) L[0]=sp + #16 L[1]=sp + #8 L[2]=_
        # java.lang.AbstractStringBuilder::ensureCapacityInternal @ bci:32 (line 228) L[0]=_ L[1]=_ L[2]=_ STK[0]=sp + #0
        # OopMap {[0]=Oop [16]=Oop off=740/0x2e4}

2e4     B29: #	out( B14 ) &lt;- in( B28 )  Freq: 5.58229e-06
        # Block is sole successor of call
2e4 +   spill R10 -&gt; R9	# spill size = 64
2e8 +   spill [sp, #8] -&gt; R7	# spill size = 32
2ec +   spill [sp, #16] -&gt; R31	# spill size = 64
2f0 +   spill [sp, #12] -&gt; R28	# spill size = 32
2f4 +   spill [sp, #24] -&gt; R10	# spill size = 64
2f8 +   j  B14	#@branch

2fc     B30: #	out( N411 ) &lt;- in( B7 )  Freq: 5.5989e-08
2fc +   li R11, #117	# int, #@loadConI
300     spill [sp, #0] -&gt; R8	# spill size = 64
304 +   spill R31 -&gt; [sp, #8]	# spill size = 64
308     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unloaded&apos; action=&apos;reinterpret&apos; index=&apos;117&apos;)
        # java.lang.AbstractStringBuilder::newCapacity @ bci:41 (line 259) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_
        # java.lang.AbstractStringBuilder::ensureCapacityInternal @ bci:24 (line 229) L[0]=R8 L[1]=_ L[2]=_ STK[0]=R8 STK[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=780/0x30c}
30c     #@ShouldNotReachHere

318     B31: #	out( B17 ) &lt;- in( B14 )  Freq: 5.59888e-08
318 +   spill R11 -&gt; R28	# spill size = 64
31c +   addi  R29, R29, #-2	#@addL_reg_imm
320     ClearArray R29, R28	#@clearArray_reg_reg
378     
378 +   j  B17	#@branch

37c     B32: #	out( N411 ) &lt;- in( B9 B10 )  Freq: 1.1051e-07
37c +   spill [sp, #0] -&gt; R8	# spill size = 64
380 +   li R11, #-52	# int, #@loadConI
384     spill R31 -&gt; [sp, #0]	# spill size = 64
388 +   spill R7 -&gt; [sp, #12]	# spill size = 32
38c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # java.util.Arrays::copyOf @ bci:1 (line 3537) L[0]=sp + #0 L[1]=sp + #12 L[2]=_ STK[0]=sp + #12
        # java.lang.AbstractStringBuilder::ensureCapacityInternal @ bci:32 (line 228) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8
        # OopMap {fp=Oop [0]=Oop off=912/0x390}
390     #@ShouldNotReachHere

39c     B33: #	out( B18 ) &lt;- in( B26 )  Freq: 2.76268e-08
39c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
39c     spill R23 -&gt; R11	# spill size = 64
3a0 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
3d0 +   j  B18	#@branch

3d4     B34: #	out( N411 ) &lt;- in( B1 )  Freq: 1.01328e-06
3d4 +   li R11, #-10	# int, #@loadConI
3d8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.AbstractStringBuilder::ensureCapacityInternal @ bci:4 (line 226) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # OopMap {off=988/0x3dc}
3dc     #@ShouldNotReachHere

3e8     B35: #	out( B37 ) &lt;- in( B28 )  Freq: 5.58241e-11
3e8      -- 	// exception oop; no code emitted, #@CreateException
3e8 +   spill R10 -&gt; R11	# spill size = 64
3ec +   j  B37	#@branch

3f0     B36: #	out( B37 ) &lt;- in( B5 )  Freq: 2.76279e-07
3f0      -- 	// exception oop; no code emitted, #@CreateException
3f0 +   spill R10 -&gt; R11	# spill size = 64

3f4     B37: #	out( N411 ) &lt;- in( B36 B35 )  Freq: 2.76335e-07
3f4     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
400 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='480'>
----------------------- MetaData before Compile_id = 480 ------------------------
{method}
 - this oop:          0x000000409600b7b0
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;indexOf&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         4
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b960: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c504d40
 - code size:         7
 - code start:        0x000000409600b788
 - code end (excl):   0x000000409600b78f
 - method data:       0x00000040964867d8
 - checked ex length: 0
 - linenumber start:  0x000000409600b78f
 - localvar length:   2
 - localvar start:    0x000000409600b796
 - compiled code: nmethod  20403  173       3       java.lang.String::indexOf (7 bytes)

------------------------ OptoAssembly for Compile_id = 480 -----------------------
#
#  int ( java/lang/String:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N96: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B6 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
040 +   lb  R29, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
044 +   decode_heap_oop  R7, R7	#@decodeHeapOop
048 +   srliw  R28, R12, (#8 &amp; 0x1f)	#@urShiftI_reg_imm
04c     spill R12 -&gt; R13	# spill size = 32
050 +   bne  R29, zr, B6	#@cmpI_reg_imm0_branch  P=0.000000 C=102022.000000

054     B2: #	out( B7 B3 ) &lt;- in( B1 )  Freq: 1
054 +   bne  R28, zr, B7	#@cmpI_reg_imm0_branch  P=0.000000 C=12924.000000

058     B3: #	out( B9 B4 ) &lt;- in( B2 )  Freq: 0.999999
058     lwu  R12, [R7, #12]	# range, #@loadRange
05c     NullCheck R7

05c     B4: #	out( B8 B5 ) &lt;- in( B3 )  Freq: 0.999998
05c +   bleu  R12, zr, B8	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=5375.000000

060     B5: #	out( N96 ) &lt;- in( B4 )  Freq: 0.999998
060 +   addi  R11, R7, #16	# ptr, #@addP_reg_imm
064 +   StringUTF16 IndexOf char[] R11,R12,R13 -&gt; R10
314 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
32c +   ret	// return register, #@Ret

330     B6: #	out( N96 ) &lt;- in( B1 )  Freq: 5e-07
330 +   spill R11 -&gt; R8	# spill size = 64
334 +   spill R12 -&gt; [sp, #0]	# spill size = 32
338 +   spill R29 -&gt; [sp, #4]	# spill size = 32
33c +   li R11, #-187	# int, #@loadConI
340     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #4
        # java.lang.String::indexOf @ bci:1 (line 2416) L[0]=R8 L[1]=sp + #0 L[2]=#0
        # java.lang.String::indexOf @ bci:3 (line 2373) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=836/0x344}
344     #@ShouldNotReachHere

350     B7: #	out( N96 ) &lt;- in( B2 )  Freq: 5e-07
350 +   li R11, #-187	# int, #@loadConI
354     spill R7 -&gt; R8	# spill size = 64
358 +   spill R12 -&gt; [sp, #0]	# spill size = 32
35c +   spill R28 -&gt; [sp, #4]	# spill size = 32
360     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::canEncode @ bci:4 (line 54) L[0]=_ STK[0]=sp + #4
        # java.lang.StringLatin1::indexOf @ bci:1 (line 203) L[0]=R8 L[1]=sp + #0 L[2]=#0 L[3]=_
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # java.lang.String::indexOf @ bci:3 (line 2373) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=868/0x364}
364     #@ShouldNotReachHere

370     B8: #	out( N96 ) &lt;- in( B4 )  Freq: 4.76836e-07
370 +   li R11, #-187	# int, #@loadConI
374     spill R7 -&gt; R8	# spill size = 64
378 +   spill R13 -&gt; [sp, #0]	# spill size = 32
37c +   spill R12 -&gt; [sp, #8]	# spill size = 32
380     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::indexOf @ bci:23 (line 209) L[0]=R8 L[1]=sp + #0 L[2]=#0 L[3]=sp + #8 STK[0]=#0 STK[1]=sp + #8
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # java.lang.String::indexOf @ bci:3 (line 2373) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=900/0x384}
384     #@ShouldNotReachHere

390     B9: #	out( N96 ) &lt;- in( B3 )  Freq: 1.01328e-06
390 +   li R11, #-10	# int, #@loadConI
394     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::indexOf @ bci:10 (line 206) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # java.lang.String::indexOf @ bci:13 (line 2416) L[0]=_ L[1]=_ L[2]=_
        # java.lang.String::indexOf @ bci:3 (line 2373) L[0]=_ L[1]=_
        # OopMap {off=920/0x398}
398 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='484'>
----------------------- MetaData before Compile_id = 484 ------------------------
{method}
 - this oop:          0x00000040960be5d0
 - method holder:     &apos;java/lang/StringBuilder&apos;
 - constants:         0x00000040960bca60 constant pool [409] {0x00000040960bca60} for &apos;java/lang/StringBuilder&apos; cache=0x00000040962869e0
 - access:            0x81000001  public 
 - name:              &apos;append&apos;
 - signature:         &apos;(C)Ljava/lang/StringBuilder;&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    2
 - method size:       13
 - intrinsic id:      324 _StringBuilder_append_char
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b960: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c4e0b00
 - code size:         8
 - code start:        0x00000040960be5a0
 - code end (excl):   0x00000040960be5a8
 - method data:       0x000000409658bd48
 - checked ex length: 0
 - linenumber start:  0x00000040960be5a8
 - localvar length:   2
 - localvar start:    0x00000040960be5ae
 - compiled code: nmethod  20493   93       3       java.lang.StringBuilder::append (8 bytes)

------------------------ OptoAssembly for Compile_id = 484 -----------------------
#
#  java/lang/StringBuilder:exact * ( java/lang/StringBuilder:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/StringBuilder:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N134: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B10 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lw  R7, [R11, #12]	# int, #@loadI ! Field: java/lang/AbstractStringBuilder.count
040 +   spill R12 -&gt; [sp, #8]	# spill size = 32
044 +   addiw  R12, R7, #1	#@addI_reg_imm
048     spill [sp, #8] -&gt; R7	# spill size = 32
04c +   srliw  R7, R7, (#8 &amp; 0x1f)	#@urShiftI_reg_imm
050     spill [sp, #8] -&gt; R28	# spill size = 32
054 +   spill R11 -&gt; [sp, #0]	# spill size = 64
058 +   spill R7 -&gt; [sp, #12]	# spill size = 32
05c +   slliw  R8, R28, (#24 &amp; 0x1f)	#@lShiftI_reg_imm
060     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.AbstractStringBuilder::ensureCapacityInternal
        # java.lang.AbstractStringBuilder::append @ bci:7 (line 802) L[0]=sp + #0 L[1]=sp + #8
        # java.lang.StringBuilder::append @ bci:2 (line 246) L[0]=sp + #0 L[1]=_
        # OopMap {[0]=Oop off=100/0x64}

064     B2: #	out( B8 B3 ) &lt;- in( B1 )  Freq: 0.99998
        # Block is sole successor of call
064 +   spill [sp, #0] -&gt; R7	# spill size = 64
068 +   lwu  R28, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/AbstractStringBuilder.value
06c +   lw  R29, [R7, #12]	# int, #@loadI ! Field: java/lang/AbstractStringBuilder.count
070 +   lb  R7, [R7, #16]	# byte, #@loadB ! Field: java/lang/AbstractStringBuilder.coder
074 +   decode_heap_oop  R30, R28	#@decodeHeapOop
078 +   bne  R7, zr, B8	#@cmpI_reg_imm0_branch  P=0.000000 C=5759.000000

07c     B3: #	out( B9 B4 ) &lt;- in( B2 )  Freq: 0.999979
07c +   spill [sp, #12] -&gt; R7	# spill size = 32
080 +   bne  R7, zr, B9	#@cmpI_reg_imm0_branch  P=0.000000 C=13237.000000

084     B4: #	out( B11 B5 ) &lt;- in( B3 )  Freq: 0.999979
084 +   addiw  R7, R29, #1	#@addI_reg_imm
088 +   sraiw  R8, R8, (#24 &amp; 0x1f)	#@rShiftI_reg_imm
08c     spill [sp, #0] -&gt; R28	# spill size = 64
090 +   sw  R7, [R28, #12]	# int, #@storeI ! Field: java/lang/AbstractStringBuilder.count
094     lwu  R28, [R30, #12]	# range, #@loadRange
098     NullCheck R30

098     B5: #	out( B7 B6 ) &lt;- in( B4 )  Freq: 0.999978
098 +   bgeu  R29, R28, B7	#@cmpU_branch  P=0.000001 C=-1.000000

09c     B6: #	out( N134 ) &lt;- in( B5 )  Freq: 0.999977
09c +   addw  R7, R29, zr	#@convI2L_reg_reg
0a0 +   add R7, R30, R7	# ptr, #@addP_reg_reg
0a4     spill [sp, #8] -&gt; R29	# spill size = 32
0a8 +   sb  R29, [R7, #16]	# byte, #@storeB
0ac     spill [sp, #0] -&gt; R10	# spill size = 64
0b0 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0c8 +   ret	// return register, #@Ret

0cc     B7: #	out( N134 ) &lt;- in( B5 )  Freq: 1.01326e-06
0cc +   li R11, #-28	# int, #@loadConI
0d0     spill R30 -&gt; [sp, #16]	# spill size = 64
0d4 +   spill R29 -&gt; [sp, #24]	# spill size = 32
0d8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.AbstractStringBuilder::append @ bci:41 (line 804) L[0]=sp + #0 L[1]=_ STK[0]=sp + #16 STK[1]=sp + #24 STK[2]=R8
        # java.lang.StringBuilder::append @ bci:2 (line 246) L[0]=sp + #0 L[1]=_
        # OopMap {[0]=Oop [16]=Oop off=220/0xdc}
0dc     #@ShouldNotReachHere

0e8     B8: #	out( N134 ) &lt;- in( B2 )  Freq: 4.9999e-07
0e8 +   li R11, #-187	# int, #@loadConI
0ec     spill [sp, #0] -&gt; R8	# spill size = 64
0f0 +   spill R7 -&gt; [sp, #12]	# spill size = 32
0f4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.AbstractStringBuilder::isLatin1 @ bci:10 (line 1677) L[0]=_ STK[0]=sp + #12
        # java.lang.AbstractStringBuilder::append @ bci:11 (line 803) L[0]=R8 L[1]=sp + #8
        # java.lang.StringBuilder::append @ bci:2 (line 246) L[0]=R8 L[1]=_
        # OopMap {fp=Oop off=248/0xf8}
0f8     #@ShouldNotReachHere

104     B9: #	out( N134 ) &lt;- in( B3 )  Freq: 4.9999e-07
104 +   li R11, #-187	# int, #@loadConI
108     spill [sp, #0] -&gt; R8	# spill size = 64
10c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::canEncode @ bci:4 (line 54) L[0]=_ STK[0]=sp + #12
        # java.lang.AbstractStringBuilder::append @ bci:18 (line 803) L[0]=R8 L[1]=sp + #8
        # java.lang.StringBuilder::append @ bci:2 (line 246) L[0]=R8 L[1]=_
        # OopMap {fp=Oop off=272/0x110}
110     #@ShouldNotReachHere

11c     B10: #	out( N134 ) &lt;- in( B1 )  Freq: 1e-05
11c      -- 	// exception oop; no code emitted, #@CreateException
11c +   spill R10 -&gt; R11	# spill size = 64
120 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
12c +   j rethrow_stub	#@RethrowException

134     B11: #	out( N134 ) &lt;- in( B4 )  Freq: 1.01326e-06
134 +   li R11, #-10	# int, #@loadConI
138     spill R29 -&gt; [sp, #0]	# spill size = 32
13c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.AbstractStringBuilder::append @ bci:41 (line 804) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=sp + #0 STK[2]=R8
        # java.lang.StringBuilder::append @ bci:2 (line 246) L[0]=_ L[1]=_
        # OopMap {off=320/0x140}
140 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='485'>
----------------------- MetaData before Compile_id = 485 ------------------------
{method}
 - this oop:          0x00000040960b9540
 - method holder:     &apos;java/lang/AbstractStringBuilder&apos;
 - constants:         0x00000040960b5e28 constant pool [547]/operands[14] {0x00000040960b5e28} for &apos;java/lang/AbstractStringBuilder&apos; cache=0x0000004096285bb8
 - access:            0x81000001  public 
 - name:              &apos;append&apos;
 - signature:         &apos;(C)Ljava/lang/AbstractStringBuilder;&apos;
 - max stack:         6
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      17
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b960: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c4e1040
 - code size:         77
 - code start:        0x00000040960b94c8
 - code end (excl):   0x00000040960b9515
 - method data:       0x000000409658beb8
 - checked ex length: 0
 - linenumber start:  0x00000040960b9515
 - localvar length:   2
 - localvar start:    0x00000040960b9526
 - compiled code: nmethod  20520   94       3       java.lang.AbstractStringBuilder::append (77 bytes)

------------------------ OptoAssembly for Compile_id = 485 -----------------------
#
#  java/lang/AbstractStringBuilder * ( java/lang/AbstractStringBuilder:NotNull *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/AbstractStringBuilder:NotNull *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N130: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B10 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lw  R7, [R11, #12]	# int, #@loadI ! Field: java/lang/AbstractStringBuilder.count
040 +   spill R12 -&gt; [sp, #0]	# spill size = 32
044 +   addiw  R12, R7, #1	#@addI_reg_imm
048     spill [sp, #0] -&gt; R7	# spill size = 32
04c +   srliw  R7, R7, (#8 &amp; 0x1f)	#@urShiftI_reg_imm
050     spill [sp, #0] -&gt; R28	# spill size = 32
054 +   spill R11 -&gt; [sp, #8]	# spill size = 64
058 +   spill R7 -&gt; [sp, #4]	# spill size = 32
05c +   slliw  R8, R28, (#24 &amp; 0x1f)	#@lShiftI_reg_imm
060     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.lang.AbstractStringBuilder::ensureCapacityInternal
        # java.lang.AbstractStringBuilder::append @ bci:7 (line 802) L[0]=sp + #8 L[1]=sp + #0
        # OopMap {[8]=Oop off=100/0x64}

064     B2: #	out( B8 B3 ) &lt;- in( B1 )  Freq: 0.99998
        # Block is sole successor of call
064 +   spill [sp, #8] -&gt; R7	# spill size = 64
068 +   lwu  R28, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/AbstractStringBuilder.value
06c +   lw  R29, [R7, #12]	# int, #@loadI ! Field: java/lang/AbstractStringBuilder.count
070 +   lb  R7, [R7, #16]	# byte, #@loadB ! Field: java/lang/AbstractStringBuilder.coder
074 +   decode_heap_oop  R30, R28	#@decodeHeapOop
078 +   bne  R7, zr, B8	#@cmpI_reg_imm0_branch  P=0.000000 C=5759.000000

07c     B3: #	out( B9 B4 ) &lt;- in( B2 )  Freq: 0.999979
07c +   spill [sp, #4] -&gt; R7	# spill size = 32
080 +   bne  R7, zr, B9	#@cmpI_reg_imm0_branch  P=0.000000 C=13237.000000

084     B4: #	out( B11 B5 ) &lt;- in( B3 )  Freq: 0.999979
084 +   addiw  R7, R29, #1	#@addI_reg_imm
088 +   sraiw  R8, R8, (#24 &amp; 0x1f)	#@rShiftI_reg_imm
08c     spill [sp, #8] -&gt; R28	# spill size = 64
090 +   sw  R7, [R28, #12]	# int, #@storeI ! Field: java/lang/AbstractStringBuilder.count
094     lwu  R28, [R30, #12]	# range, #@loadRange
098     NullCheck R30

098     B5: #	out( B7 B6 ) &lt;- in( B4 )  Freq: 0.999978
098 +   bgeu  R29, R28, B7	#@cmpU_branch  P=0.000001 C=-1.000000

09c     B6: #	out( N130 ) &lt;- in( B5 )  Freq: 0.999977
09c +   addw  R7, R29, zr	#@convI2L_reg_reg
0a0 +   add R7, R30, R7	# ptr, #@addP_reg_reg
0a4     spill [sp, #0] -&gt; R29	# spill size = 32
0a8 +   sb  R29, [R7, #16]	# byte, #@storeB
0ac     spill [sp, #8] -&gt; R10	# spill size = 64
0b0 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0c8 +   ret	// return register, #@Ret

0cc     B7: #	out( N130 ) &lt;- in( B5 )  Freq: 1.01326e-06
0cc +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
0d4 +   li R11, #-28	# int, #@loadConI
0d8     spill R30 -&gt; [sp, #8]	# spill size = 64
0dc +   spill R29 -&gt; [sp, #16]	# spill size = 32
0e0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.AbstractStringBuilder::append @ bci:41 (line 804) L[0]=sp + #0 L[1]=_ STK[0]=sp + #8 STK[1]=sp + #16 STK[2]=R8
        # OopMap {[0]=Oop [8]=Oop off=228/0xe4}
0e4     #@ShouldNotReachHere

0f0     B8: #	out( N130 ) &lt;- in( B2 )  Freq: 4.9999e-07
0f0 +   li R11, #-187	# int, #@loadConI
0f4     spill [sp, #8] -&gt; R8	# spill size = 64
0f8 +   spill R7 -&gt; [sp, #4]	# spill size = 32
0fc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.AbstractStringBuilder::isLatin1 @ bci:10 (line 1677) L[0]=_ STK[0]=sp + #4
        # java.lang.AbstractStringBuilder::append @ bci:11 (line 803) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop off=256/0x100}
100     #@ShouldNotReachHere

10c     B9: #	out( N130 ) &lt;- in( B3 )  Freq: 4.9999e-07
10c +   li R11, #-187	# int, #@loadConI
110     spill [sp, #8] -&gt; R8	# spill size = 64
114     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringLatin1::canEncode @ bci:4 (line 54) L[0]=_ STK[0]=sp + #4
        # java.lang.AbstractStringBuilder::append @ bci:18 (line 803) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop off=280/0x118}
118     #@ShouldNotReachHere

124     B10: #	out( N130 ) &lt;- in( B1 )  Freq: 1e-05
124      -- 	// exception oop; no code emitted, #@CreateException
124 +   spill R10 -&gt; R11	# spill size = 64
128 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
134 +   j rethrow_stub	#@RethrowException

13c     B11: #	out( N130 ) &lt;- in( B4 )  Freq: 1.01326e-06
13c +   li R11, #-10	# int, #@loadConI
140     spill R29 -&gt; [sp, #0]	# spill size = 32
144     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.AbstractStringBuilder::append @ bci:41 (line 804) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=sp + #0 STK[2]=R8
        # OopMap {off=328/0x148}
148 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='486'>
----------------------- MetaData before Compile_id = 486 ------------------------
{method}
 - this oop:          0x0000004096009fe8
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;codePointAt&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         4
 - max locals:        3
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b960: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c56be80
 - code size:         50
 - code start:        0x0000004096009f80
 - code end (excl):   0x0000004096009fb2
 - method data:       0x00000040964a2ff0
 - checked ex length: 0
 - linenumber start:  0x0000004096009fb2
 - localvar length:   3
 - localvar start:    0x0000004096009fc2
 - compiled code: nmethod  20542  292       3       java.lang.String::codePointAt (50 bytes)

------------------------ OptoAssembly for Compile_id = 486 -----------------------
#
#  int ( java/lang/String:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N66: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B5 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lwu  R28, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
040 +   lb  R7, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
044 +   decode_heap_oop  R28, R28	#@decodeHeapOop
048 +   bne  R7, zr, B5	#@cmpI_reg_imm0_branch  P=0.000000 C=103238.000000

04c     B2: #	out( B7 B3 ) &lt;- in( B1 )  Freq: 1
04c     lwu  R8, [R28, #12]	# range, #@loadRange
050     NullCheck R28

050     B3: #	out( B6 B4 ) &lt;- in( B2 )  Freq: 0.999999
050 +   bgeu  R12, R8, B6	#@cmpU_branch  P=0.000000 C=5140.000000

054     B4: #	out( N66 ) &lt;- in( B3 )  Freq: 0.999998
054 +   addw  R7, R12, zr	#@convI2L_reg_reg
058 +   add R7, R28, R7	# ptr, #@addP_reg_reg
05c +   lbu  R10, [R7, #16]	# byte, #@loadUB
060     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
078 +   ret	// return register, #@Ret

07c     B5: #	out( N66 ) &lt;- in( B1 )  Freq: 5e-07
07c +   spill R11 -&gt; R8	# spill size = 64
080 +   spill R12 -&gt; [sp, #0]	# spill size = 32
084 +   spill R7 -&gt; [sp, #4]	# spill size = 32
088 +   li R11, #-187	# int, #@loadConI
08c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #4
        # java.lang.String::codePointAt @ bci:1 (line 1539) L[0]=R8 L[1]=sp + #0 L[2]=_
        # OopMap {fp=Oop off=144/0x90}
090     #@ShouldNotReachHere

09c     B6: #	out( N66 ) &lt;- in( B3 )  Freq: 4.76836e-07
09c +   spill R11 -&gt; [sp, #0]	# spill size = 64
0a0 +   spill R12 -&gt; [sp, #12]	# spill size = 32
0a4 +   spill R12 -&gt; [sp, #16]	# spill size = 32
0a8 +   li R11, #-27	# int, #@loadConI
0ac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::checkIndex @ bci:1 (line 4557) L[0]=sp + #16 L[1]=R8 STK[0]=sp + #12
        # java.lang.String::codePointAt @ bci:13 (line 1540) L[0]=sp + #0 L[1]=sp + #12 L[2]=_
        # OopMap {[0]=Oop off=176/0xb0}
0b0     #@ShouldNotReachHere

0bc     B7: #	out( N66 ) &lt;- in( B2 )  Freq: 1.01328e-06
0bc +   li R11, #-10	# int, #@loadConI
0c0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::codePointAt @ bci:12 (line 1540) L[0]=_ L[1]=_ L[2]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=196/0xc4}
0c4 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='491'>
----------------------- MetaData before Compile_id = 491 ------------------------
{method}
 - this oop:          0x0000004096508178
 - method holder:     &apos;java/util/concurrent/locks/AbstractQueuedSynchronizer&apos;
 - constants:         0x0000004096505498 constant pool [349] {0x0000004096505498} for &apos;java/util/concurrent/locks/AbstractQueuedSynchronizer&apos; cache=0x0000004096508bb8
 - access:            0x81000011  public final 
 - name:              &apos;hasQueuedPredecessors&apos;
 - signature:         &apos;()Z&apos;
 - max stack:         3
 - max locals:        4
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c5096c0
 - code size:         58
 - code start:        0x0000004096508100
 - code end (excl):   0x000000409650813a
 - method data:       0x0000004096487dc8
 - checked ex length: 0
 - linenumber start:  0x000000409650813a
 - localvar length:   4
 - localvar start:    0x0000004096508146
 - compiled code: nmethod  20596  184       3       java.util.concurrent.locks.AbstractQueuedSynchronizer::hasQueuedPredecessors (58 bytes)

------------------------ OptoAssembly for Compile_id = 491 -----------------------
#
#  bool ( java/util/concurrent/locks/ReentrantReadWriteLock$FairSync:NotNull:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/concurrent/locks/ReentrantReadWriteLock$FairSync:NotNull:exact *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N36: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B3 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: volatile java/util/concurrent/locks/AbstractQueuedSynchronizer.head
040 +   #@membar_acquire
	fence ir iorw
044 +   decode_heap_oop  R7, R7	#@decodeHeapOop
048 +   bne   R7, zr, B3	#@cmpP_imm0_branch  P=0.000000 C=5375.000000

04c     B2: #	out( N36 ) &lt;- in( B1 )  Freq: 1
04c +   li R10, #0	# int, #@loadConI
050     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
068 +   ret	// return register, #@Ret

06c     B3: #	out( N36 ) &lt;- in( B1 )  Freq: 4.76837e-07
06c +   spill R11 -&gt; R8	# spill size = 64
070 +   spill R7 -&gt; [sp, #8]	# spill size = 64
074 +   li R11, #-187	# int, #@loadConI
078     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.concurrent.locks.AbstractQueuedSynchronizer::hasQueuedPredecessors @ bci:8 (line 1234) L[0]=R8 L[1]=#NULL L[2]=sp + #8 L[3]=_ STK[0]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=124/0x7c}
07c +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='493'>
----------------------- MetaData before Compile_id = 493 ------------------------
{method}
 - this oop:          0x000000409629d2e0
 - method holder:     &apos;java/net/URI&apos;
 - constants:         0x0000004096296c30 constant pool [731] {0x0000004096296c30} for &apos;java/net/URI&apos; cache=0x000000409629e0a8
 - access:            0x8100000a  private static 
 - name:              &apos;match&apos;
 - signature:         &apos;(CJJ)Z&apos;
 - max stack:         5
 - max locals:        5
 - size of params:    5
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x00000040083b33f0: 0xabebe i2c: 0x00000040139140c0 c2i: 0x000000401391410c c2iUV: 0x00000040139140d8
 - compiled entry     0x000000400c519380
 - code size:         56
 - code start:        0x000000409629d270
 - code end (excl):   0x000000409629d2a8
 - method data:       0x000000409648e1e8
 - checked ex length: 0
 - linenumber start:  0x000000409629d2a8
 - localvar length:   3
 - localvar start:    0x000000409629d2ba
 - compiled code: nmethod  20616  214       3       java.net.URI::match (56 bytes)

------------------------ OptoAssembly for Compile_id = 493 -----------------------
#
#  bool ( int, long, half, long, half )
#
#r012 c_rarg1   : parm 0: int
#r014 c_rarg2:c_rarg2   : parm 1: long
#r016 c_rarg3:c_rarg3   : parm 3: long
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B8 B7 B9 B10 B5 )  Freq: 1

000     B1: #	out( B8 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
01c     li R7, #1	# long, #@loadConL
020 +   li R28, #0	# long, #@loadConL
024 +   li R30, #64	# int, #@loadConI
028 +   beq  R11, zr, B8	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

02c     B2: #	out( B6 B3 ) &lt;- in( B1 )  Freq: 1
02c +   blt  R11, R30, B6	#@cmpI_branch  P=0.186977 C=5375.000000

030     B3: #	out( B9 B4 ) &lt;- in( B2 )  Freq: 0.813023
030 +   addiw  R29, R11, #-64	#@addI_reg_imm
034 +   sll  R7, R7, R29	#@lShiftL_reg_reg
038 +   li R30, #128	# int, #@loadConI
03c +   andr  R7, R7, R13	#@andL_reg_reg
040 +   bge  R11, R30, B9	#@cmpI_branch  P=0.000000 C=4370.000000

044     B4: #	out( B10 B5 ) &lt;- in( B3 )  Freq: 0.813022
044 +   beq  R7, zr, B10	#@cmpL_reg_imm0_branch  P=0.000000 C=4370.000000

048     B5: #	out( N1 ) &lt;- in( B6 B4 )  Freq: 0.999999
048 +   li R10, #1	# int, #@loadConI
04c     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

068     B6: #	out( B5 B7 ) &lt;- in( B2 )  Freq: 0.186977
068 +   sll  R7, R7, R11	#@lShiftL_reg_reg
06c +   andr  R7, R7, R12	#@andL_reg_reg
070 +   bne  R7, zr, B5	#@cmpL_reg_imm0_branch  P=1.000000 C=1005.000000

074     B7: #	out( N1 ) &lt;- in( B6 )  Freq: 8.91574e-08
074 +   slt   R8, R28, R7	#@cmpL3_reg_reg
	bnez  R8, done
	slt  R8, R7, R28
	neg   R8, R8	#@cmpL3_reg_reg
088     li R11, #-187	# int, #@loadConI
08c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.net.URI::match @ bci:19 (line 2642) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # OopMap {off=144/0x90}
090     #@ShouldNotReachHere

09c     B8: #	out( N1 ) &lt;- in( B1 )  Freq: 4.76837e-07
09c +   spill R11 -&gt; [sp, #16]	# spill size = 32
0a0 +   spill R12 -&gt; [sp, #0]	# spill size = 64
0a4 +   spill R13 -&gt; [sp, #8]	# spill size = 64
0a8 +   li R11, #-187	# int, #@loadConI
0ac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.net.URI::match @ bci:1 (line 2639) L[0]=sp + #16 L[1]=sp + #0 L[2]=_ L[3]=sp + #8 L[4]=_ STK[0]=sp + #16
        # OopMap {off=176/0xb0}
0b0     #@ShouldNotReachHere

0bc     B9: #	out( N1 ) &lt;- in( B3 )  Freq: 3.8768e-07
0bc +   spill R11 -&gt; [sp, #8]	# spill size = 32
0c0 +   spill R13 -&gt; [sp, #0]	# spill size = 64
0c4 +   li R11, #-187	# int, #@loadConI
0c8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.net.URI::match @ bci:32 (line 2643) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=_ STK[0]=sp + #8 STK[1]=#128
        # OopMap {off=204/0xcc}
0cc     #@ShouldNotReachHere

0d8     B10: #	out( N1 ) &lt;- in( B4 )  Freq: 3.87679e-07
0d8 +   slt   R8, R28, R7	#@cmpL3_reg_reg
	bnez  R8, done
	slt  R8, R7, R28
	neg   R8, R8	#@cmpL3_reg_reg
0ec     li R11, #-187	# int, #@loadConI
0f0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.net.URI::match @ bci:45 (line 2644) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # OopMap {off=244/0xf4}
0f4     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='495'>
----------------------- MetaData before Compile_id = 495 ------------------------
{method}
 - this oop:          0x00000040965f5868
 - method holder:     &apos;sun/nio/fs/UnixUriUtils&apos;
 - constants:         0x00000040965f4218 constant pool [305] {0x00000040965f4218} for &apos;sun/nio/fs/UnixUriUtils&apos; cache=0x00000040965f5b18
 - access:            0x8100000a  private static 
 - name:              &apos;match&apos;
 - signature:         &apos;(CJJ)Z&apos;
 - max stack:         5
 - max locals:        5
 - size of params:    5
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x00000040083b33f0: 0xabebe i2c: 0x00000040139140c0 c2i: 0x000000401391410c c2iUV: 0x00000040139140d8
 - compiled entry     0x000000400c518c80
 - code size:         50
 - code start:        0x00000040965f5800
 - code end (excl):   0x00000040965f5832
 - method data:       0x000000409648dfc0
 - checked ex length: 0
 - linenumber start:  0x00000040965f5832
 - localvar length:   3
 - localvar start:    0x00000040965f5842
 - compiled code: nmethod  20761  213       3       sun.nio.fs.UnixUriUtils::match (50 bytes)

------------------------ OptoAssembly for Compile_id = 495 -----------------------
#
#  bool ( int, long, half, long, half )
#
#r012 c_rarg1   : parm 0: int
#r014 c_rarg2:c_rarg2   : parm 1: long
#r016 c_rarg3:c_rarg3   : parm 3: long
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B6 B7 B8 B4 )  Freq: 1

000     B1: #	out( B5 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     li R29, #64	# int, #@loadConI
020 +   li R7, #1	# long, #@loadConL
024 +   li R28, #0	# long, #@loadConL
028 +   blt  R11, R29, B5	#@cmpI_branch  P=0.177860 C=5375.000000

02c     B2: #	out( B7 B3 ) &lt;- in( B1 )  Freq: 0.82214
02c +   addiw  R30, R11, #-64	#@addI_reg_imm
030 +   sll  R7, R7, R30	#@lShiftL_reg_reg
034 +   li R29, #128	# int, #@loadConI
038 +   andr  R7, R7, R13	#@andL_reg_reg
03c +   bge  R11, R29, B7	#@cmpI_branch  P=0.000000 C=4419.000000

040     B3: #	out( B8 B4 ) &lt;- in( B2 )  Freq: 0.822139
040 +   beq  R7, zr, B8	#@cmpL_reg_imm0_branch  P=0.000000 C=4419.000000

044     B4: #	out( N1 ) &lt;- in( B5 B3 )  Freq: 0.999999
044 +   li R10, #1	# int, #@loadConI
048     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
060 +   ret	// return register, #@Ret

064     B5: #	out( B4 B6 ) &lt;- in( B1 )  Freq: 0.17786
064 +   sll  R7, R7, R11	#@lShiftL_reg_reg
068 +   andr  R7, R12, R7	#@andL_reg_reg
06c +   bne  R7, zr, B4	#@cmpL_reg_imm0_branch  P=1.000000 C=956.000000

070     B6: #	out( N1 ) &lt;- in( B5 )  Freq: 8.48105e-08
070 +   slt   R8, R28, R7	#@cmpL3_reg_reg
	bnez  R8, done
	slt  R8, R7, R28
	neg   R8, R8	#@cmpL3_reg_reg
084     li R11, #-187	# int, #@loadConI
088     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixUriUtils::match @ bci:13 (line 185) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # OopMap {off=140/0x8c}
08c     #@ShouldNotReachHere

098     B7: #	out( N1 ) &lt;- in( B2 )  Freq: 3.92027e-07
098 +   spill R11 -&gt; [sp, #8]	# spill size = 32
09c +   spill R13 -&gt; [sp, #0]	# spill size = 64
0a0 +   li R11, #-187	# int, #@loadConI
0a4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixUriUtils::match @ bci:26 (line 186) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=_ STK[0]=sp + #8 STK[1]=#128
        # OopMap {off=168/0xa8}
0a8     #@ShouldNotReachHere

0b4     B8: #	out( N1 ) &lt;- in( B3 )  Freq: 3.92027e-07
0b4 +   slt   R8, R28, R7	#@cmpL3_reg_reg
	bnez  R8, done
	slt  R8, R7, R28
	neg   R8, R8	#@cmpL3_reg_reg
0c8     li R11, #-187	# int, #@loadConI
0cc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixUriUtils::match @ bci:39 (line 187) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=R8
        # OopMap {off=208/0xd0}
0d0     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='498'>
----------------------- MetaData before Compile_id = 498 ------------------------
{method}
 - this oop:          0x00000040963eb040
 - method holder:     &apos;java/lang/StringUTF16&apos;
 - constants:         0x00000040963e8a18 constant pool [598] {0x00000040963e8a18} for &apos;java/lang/StringUTF16&apos; cache=0x00000040963f0d90
 - access:            0xc1000009  public static 
 - name:              &apos;compress&apos;
 - signature:         &apos;([CI[BII)I&apos;
 - max stack:         4
 - max locals:        7
 - size of params:    5
 - method size:       13
 - intrinsic id:      89 _compressStringC
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x0000004008317520: 0xbabaa i2c: 0x0000004013945840 c2i: 0x0000004013945894 c2iUV: 0x0000004013945860
 - compiled entry     0x000000400c564bc0
 - code size:         50
 - code start:        0x00000040963eaf98
 - code end (excl):   0x00000040963eafca
 - method data:       0x00000040964a1db8
 - checked ex length: 0
 - linenumber start:  0x00000040963eafca
 - localvar length:   7
 - localvar start:    0x00000040963eafe2
 - compiled code: nmethod  21163  285       3       java.lang.StringUTF16::compress (50 bytes)

------------------------ OptoAssembly for Compile_id = 498 -----------------------
#
#  int ( char[int:&gt;=0]:exact *, int, byte[int:&gt;=0]:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: char[int:&gt;=0]:exact *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3:c_rarg3   : parm 2: byte[int:&gt;=0]:exact *
#r018 c_rarg4   : parm 3: int
#r020 c_rarg5   : parm 4: int
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B51 B60 B61 B41 B43 B50 B52 B58 B53 B57 B62 B63 B59 B54 B55 B56 )  Freq: 1

000     B1: #	out( B41 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
01c     spill R15 -&gt; R19	# spill size = 32
020 +   ble  R15, zr, B41	#@cmpI_reg_imm0_branch  P=0.047239 C=21656.000000

024     B2: #	out( B51 B3 ) &lt;- in( B1 )  Freq: 0.952761
024 +   addiw  R28, R12, #1	#@addI_reg_imm
028 +   addw  R31, R28, zr	#@convI2L_reg_reg
02c +   sub  R7, x0, R31	# long, #@negL_reg
030 +   li R28, #2147483647	# long, #@loadConL
038     spill R7 -&gt; R29	# spill size = 64
03c +   CMove R29, (R7 gt R28), R29, R28	#@cmovL_cmpL
	
044 +   addw  R10, R29, zr	#@convL2I_reg
048 +   addiw  R30, R15, #-1	#@addI_reg_imm
04c +   li R29, #1	# int, #@loadConI
050 +   li R15, #1	# long, #@loadConL
054     CMove R10, (R7 le R15), R10, R29	#@cmovI_cmpL
	
05c +   addiw  R29, R12, #2	#@addI_reg_imm
060 +   addw  R15, R29, zr	#@convI2L_reg_reg
064 +   sub  R29, x0, R15	# long, #@negL_reg
068     spill R29 -&gt; R16	# spill size = 64
06c +   CMove R16, (R29 gt R28), R16, R28	#@cmovL_cmpL
	
074 +   ble R10, R19, skip	#@minI_reg_reg
	mv  R10, R19
	skip:
07c +   li R18, #-2147483648	# int, #@loadConI
080 +   addw  R28, R16, zr	#@convL2I_reg
084 +   addw  R7, R10, zr	#@convI2L_reg_reg
088 +   CMove R30, (R19 lt R30), R30, R18	#@cmovI_cmpI
	
090     CMove R10, (R7 lt R29), R10, R28	#@cmovI_cmpL
	
098     lwu  R17, [R11, #12]	# range, #@loadRange
09c     NullCheck R11

09c     B3: #	out( B51 B4 ) &lt;- in( B2 )  Freq: 0.95276
09c     lwu  R28, [R13, #12]	# range, #@loadRange
0a0     NullCheck R13

0a0     B4: #	out( B51 B5 ) &lt;- in( B3 )  Freq: 0.952759
0a0 +   addw  R9, R14, zr	#@convI2L_reg_reg
0a4 +   addw  R7, R19, zr	#@convI2L_reg_reg
0a8 +   add  R7, R7, R9	#@addL_reg_reg
0ac +   addw  R25, R28, zr	#@convI2L_reg_reg
0b0 +   addi  R7, R7, #-1	#@addL_reg_imm
0b4 +   bgeu  R14, R28, B51	#@cmpU_branch  P=0.000001 C=-1.000000

0b8     B5: #	out( B51 B6 ) &lt;- in( B4 )  Freq: 0.952758
0b8 +   bgeu  R7, R25, B51	#@cmpUL_branch  P=0.000001 C=-1.000000

0bc     B6: #	out( B7 ) &lt;- in( B5 )  Freq: 0.952757
0bc +   li R16, #255	# int, #@loadConI
0c0 +   li R7, #0	# int, #@loadConI
0c4 +   li R29, #0	# int, #@loadConI
0c8 +   ble R10, R19, skip	#@minI_reg_reg
	mv  R10, R19
	skip:

0d0     B7: #	out( B43 B8 ) &lt;- in( B6 B10 ) Loop( B7-B10 inner pre of N217) Freq: 1.90551
0d0     addw  R28, R7, R12	#@addI_reg_reg
0d4 +   addw  R7, R28, zr	#@convI2L_reg_reg
0d8 +   slli  R7, R7, (#1 &amp; 0x3f)	#@lShiftL_reg_imm
0dc +   add R7, R11, R7	# ptr, #@addP_reg_reg
0e0 +   addw  R21, R29, R14	#@addI_reg_reg
0e4 +   bgeu  R28, R17, B43	#@cmpU_branch  P=0.000001 C=-1.000000

0e8     B8: #	out( B50 B9 ) &lt;- in( B7 )  Freq: 1.90551
0e8 +   lhu  R20, [R7, #16]	# short, #@loadUS
0ec +   bgt  R20, R16, B50	#@cmpI_branch  P=0.000000 C=20633.000000

0f0     B9: #	out( B11 B10 ) &lt;- in( B8 )  Freq: 1.90551
0f0 +   addw  R21, R29, zr	#@convI2L_reg_reg
0f4 +   add  R22, R9, R21	#@addL_reg_reg
0f8 +   add R7, R13, R22	# ptr, #@addP_reg_reg
0fc +   sb  R20, [R7, #16]	# byte, #@storeB
100 +   addiw  R7, R29, #1	#@addI_reg_imm
104 +   bge  R7, R10, B11	#@cmpI_loop  P=0.500000 C=20633.000000

108     B10: #	out( B7 ) &lt;- in( B9 )  Freq: 0.952755
108 +   spill R7 -&gt; R29	# spill size = 32
10c +   j  B7	#@branch

110     B11: #	out( B34 B12 ) &lt;- in( B9 )  Freq: 0.952755
110 +   addw  R20, R17, zr	#@convI2L_reg_reg
114 +   sub  R28, R20, R31	#@subL_reg_reg
118 +   addw  R10, R28, zr	#@convL2I_reg
11c +   addw  R29, R30, zr	#@convI2L_reg_reg
120     CMove R30, (R29 gt R28), R30, R10	#@cmovI_cmpL
	
128 +   addiw  R29, R30, #-2	#@addI_reg_imm
12c     CMove R29, (R30 lt R29), R29, R18	#@cmovI_cmpI
	
134 +   sub  R30, R20, R15	#@subL_reg_reg
138 +   addw  R28, R30, zr	#@convL2I_reg
13c +   addw  R10, R29, zr	#@convI2L_reg_reg
140     CMove R29, (R10 gt R30), R29, R28	#@cmovI_cmpL
	
148 +   bge  R7, R29, B34	#@cmpI_branch  P=0.000001 C=-1.000000

14c     B12: #	out( B52 B13 ) &lt;- in( B11 )  Freq: 0.952754
14c +   spill R29 -&gt; [sp, #4]	# spill size = 32
150 +   spill R7 -&gt; R29	# spill size = 32
154 +   # castII of R29, #@castII
154     addiw  R30, R29, #2	#@addI_reg_imm
158 +   addiw  R18, R30, #-2	#@addI_reg_imm
15c     spill R25 -&gt; [sp, #8]	# spill size = 64
160 +   addiw  R28, R29, #4	#@addI_reg_imm
164 +   # castII of R18, #@castII
164     addw  R25, R18, zr	#@convI2L_reg_reg
168 +   addiw  R30, R28, #-4	#@addI_reg_imm
16c     spill R19 -&gt; [sp, #0]	# spill size = 32
170 +   add  R19, R31, R21	#@addL_reg_reg
174 +   addw  R24, R29, zr	#@convI2L_reg_reg
178 +   # castII of R30, #@castII
178     addw  R18, R30, zr	#@convI2L_reg_reg
17c +   add  R21, R24, R15	#@addL_reg_reg
180     spill R29 -&gt; R30	# spill size = 32
184 +   add  R15, R18, R15	#@addL_reg_reg
188 +   # castII of R30, #@castII
188     addw  R28, R30, zr	#@convI2L_reg_reg
18c +   addw  R26, R7, zr	#@convI2L_reg_reg
190 +   addi  R18, R19, #3	#@addL_reg_imm
194 +   add  R8, R31, R24	#@addL_reg_reg
198 +   add  R30, R26, R31	#@addL_reg_reg
19c +   addi  R19, R22, #4	#@addL_reg_imm
1a0 +   add  R28, R28, R9	#@addL_reg_reg
1a4 +   addw  R10, R12, zr	#@convI2L_reg_reg
1a8 +   add  R24, R9, R24	#@addL_reg_reg
1ac +   add  R26, R9, R26	#@addL_reg_reg
1b0 +   add  R31, R25, R31	#@addL_reg_reg
1b4     spill [sp, #8] -&gt; R22	# spill size = 64
1b8 +   bgeu  R28, R22, B52	#@cmpUL_branch  P=0.000001 C=-1.000000

1bc     B13: #	out( B53 B14 ) &lt;- in( B12 )  Freq: 0.952753
1bc +   spill R22 -&gt; R25	# spill size = 64
1c0 +   bgeu  R24, R25, B53	#@cmpUL_branch  P=0.000001 C=-1.000000

1c4     B14: #	out( B54 B15 ) &lt;- in( B13 )  Freq: 0.952752
1c4 +   bgeu  R8, R20, B54	#@cmpUL_branch  P=0.000001 C=-1.000000

1c8     B15: #	out( B55 B16 ) &lt;- in( B14 )  Freq: 0.952751
1c8 +   bgeu  R31, R20, B55	#@cmpUL_branch  P=0.000001 C=-1.000000

1cc     B16: #	out( B56 B17 ) &lt;- in( B15 )  Freq: 0.95275
1cc +   bgeu  R18, R20, B56	#@cmpUL_branch  P=0.000001 C=-1.000000

1d0     B17: #	out( B57 B18 ) &lt;- in( B16 )  Freq: 0.952749
1d0 +   bgeu  R30, R20, B57	#@cmpUL_branch  P=0.000001 C=-1.000000

1d4     B18: #	out( B58 B19 ) &lt;- in( B17 )  Freq: 0.952748
1d4 +   bgeu  R26, R25, B58	#@cmpUL_branch  P=0.000001 C=-1.000000

1d8     B19: #	out( B59 B20 ) &lt;- in( B18 )  Freq: 0.952747
1d8 +   bgeu  R19, R25, B59	#@cmpUL_branch  P=0.000001 C=-1.000000

1dc     B20: #	out( B60 B21 ) &lt;- in( B19 )  Freq: 0.952746
1dc +   bgeu  R21, R20, B60	#@cmpUL_branch  P=0.000001 C=-1.000000

1e0     B21: #	out( B61 B22 ) &lt;- in( B20 )  Freq: 0.952745
1e0 +   bgeu  R15, R20, B61	#@cmpUL_branch  P=0.000001 C=-1.000000

1e4     B22: #	out( B32 ) &lt;- in( B21 )  Freq: 0.952744
1e4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1e4     j  B32	#@branch
        nop 	# 4 bytes pad for loops and calls

1f0     B23: #	out( B24 ) &lt;- in( B29 ) top-of-loop Freq: 406.254
1f0 +   spill R7 -&gt; R29	# spill size = 32

1f4     B24: #	out( B42 B25 ) &lt;- in( B32 B23 ) Loop( B24-B23 inner main of N186 strip mined) Freq: 426.397
1f4 +   addw  R28, R7, R12	#@addI_reg_reg
1f8 +   addw  R7, R28, zr	#@convI2L_reg_reg
1fc +   addw  R18, R29, zr	#@convI2L_reg_reg
200 +   slli  R7, R7, (#1 &amp; 0x3f)	#@lShiftL_reg_imm
204 +   add  R30, R10, R18	#@addL_reg_reg
208 +   addw  R31, R29, R12	#@addI_reg_reg
20c +   add R7, R11, R7	# ptr, #@addP_reg_reg
210 +   slli  R30, R30, (#1 &amp; 0x3f)	#@lShiftL_reg_imm
214 +   addw  R20, R31, zr	#@convI2L_reg_reg
218 +   addw  R21, R29, R14	#@addI_reg_reg
21c +   bgeu  R28, R17, B42	#@cmpU_branch  P=0.000001 C=-1.000000

220     B25: #	out( B44 B26 ) &lt;- in( B24 )  Freq: 426.397
220 +   slli  R20, R20, (#1 &amp; 0x3f)	#@lShiftL_reg_imm
224 +   add  R18, R9, R18	#@addL_reg_reg
228 +   add R30, R11, R30	# ptr, #@addP_reg_reg
22c +   add R22, R11, R20	# ptr, #@addP_reg_reg
230 +   lhu  R7, [R7, #16]	# short, #@loadUS
234 +   add R24, R13, R18	# ptr, #@addP_reg_reg
238 +   lhu  R30, [R30, #18]	# short, #@loadUS
23c +   lhu  R20, [R22, #22]	# short, #@loadUS
240 +   lhu  R18, [R22, #20]	# short, #@loadUS
244 +   bgt  R7, R16, B44	#@cmpI_branch  P=0.000000 C=20633.000000

248     B26: #	out( B47 B27 ) &lt;- in( B25 )  Freq: 426.397
248 +   sb  R7, [R24, #16]	# byte, #@storeB
24c +   addw  R7, R21, zr	#@convI2L_reg_reg
250 +   bgt  R30, R16, B47	#@cmpI_branch  P=0.000000 C=20633.000000

254     B27: #	out( B45 B28 ) &lt;- in( B26 )  Freq: 426.397
254 +   add R7, R13, R7	# ptr, #@addP_reg_reg
258 +   sb  R30, [R24, #17]	# byte, #@storeB
25c +   bgt  R18, R16, B45	#@cmpI_branch  P=0.000000 C=20633.000000

260     B28: #	out( B48 B29 ) &lt;- in( B27 )  Freq: 426.396
260 +   sb  R18, [R7, #18]	# byte, #@storeB
264 +   bgt  R20, R16, B48	#@cmpI_branch  P=0.000000 C=20633.000000

268     B29: #	out( B23 B30 ) &lt;- in( B28 )  Freq: 426.396
268 +   sb  R20, [R7, #19]	# byte, #@storeB
26c +   addiw  R7, R29, #4	#@addI_reg_imm
270 +   blt  R7, R19, B23	#@cmpI_loop  P=0.952761 C=20633.000000

274     B30: #	out( B33 B31 ) &lt;- in( B29 )  Freq: 20.1424
274 +   addiw  R29, R31, #4	#@addI_reg_imm
278 +   addiw  R31, R21, #4	#@addI_reg_imm
27c +   ld  R28, [R23, #920]	# ptr, #@loadP
280 +   lwu zr, [R28]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringUTF16::compress @ bci:44 (line 179) L[0]=R11 L[1]=R29 L[2]=R13 L[3]=R31 L[4]=sp + #0 L[5]=R7 L[6]=_
        # OopMap {c_rarg1=Oop c_rarg3=Oop off=640/0x280}
284 +   bge  R7, R15, B33	#@cmpI_branch  P=0.047239 C=20633.000000

288     B31: #	out( B32 ) &lt;- in( B30 )  Freq: 19.1909
288 +   spill R7 -&gt; R29	# spill size = 32
28c +   spill R15 -&gt; [sp, #4]	# spill size = 32

290     B32: #	out( B24 ) &lt;- in( B22 B31 ) Loop( B32-B31 ) Freq: 20.1436
290 +   spill [sp, #4] -&gt; R15	# spill size = 32
294 +   li R31, #0	# int, #@loadConI
298 +   subw  R30, R15, R29	#@subI_reg_reg
29c     CMove R30, (R15 lt R29), R30, R31	#@cmovI_cmpI
	
2a4 +   li R18, #4000	# int, #@loadConI
2ac +   li R28, #4000	# int, #@loadConI
2b4     CMove R30, (R30 gtu R28), R30, R18	#@cmovI_cmpU
	
2bc +   addw  R19, R30, R29	#@addI_reg_reg
2c0 +   j  B24	#@branch

2c4     B33: #	out( B34 ) &lt;- in( B30 )  Freq: 0.951499
2c4 +   spill [sp, #0] -&gt; R19	# spill size = 32

2c8     B34: #	out( B41 B35 ) &lt;- in( B11 B33 )  Freq: 0.9515
2c8 +   bge  R7, R19, B41	#@cmpI_branch  P=0.500000 C=-1.000000

2cc     B35: #	out( B62 B36 ) &lt;- in( B34 )  Freq: 0.47575
2cc +   spill R7 -&gt; R29	# spill size = 32
2d0 +   # castII of R29, #@castII
2d0     spill R29 -&gt; R30	# spill size = 32
2d4 +   addw  R28, R29, zr	#@convI2L_reg_reg
2d8 +   # castII of R30, #@castII
2d8     addw  R30, R30, zr	#@convI2L_reg_reg
2dc +   add  R28, R28, R9	#@addL_reg_reg
2e0 +   add  R30, R30, R9	#@addL_reg_reg
2e4 +   bgeu  R28, R25, B62	#@cmpUL_branch  P=0.000001 C=-1.000000

2e8     B36: #	out( B63 B37 ) &lt;- in( B35 )  Freq: 0.475749
2e8 +   bgeu  R30, R25, B63	#@cmpUL_branch  P=0.000001 C=-1.000000

2ec     B37: #	out( B43 B38 ) &lt;- in( B36 B40 ) Loop( B37-B40 inner post of N217) Freq: 0.951496
2ec +   addw  R28, R7, R12	#@addI_reg_reg
2f0 +   addw  R7, R28, zr	#@convI2L_reg_reg
2f4 +   slli  R7, R7, (#1 &amp; 0x3f)	#@lShiftL_reg_imm
2f8 +   add R7, R11, R7	# ptr, #@addP_reg_reg
2fc +   addw  R21, R29, R14	#@addI_reg_reg
300 +   bgeu  R28, R17, B43	#@cmpU_branch  P=0.000001 C=-1.000000

304     B38: #	out( B50 B39 ) &lt;- in( B37 )  Freq: 0.951495
304 +   lhu  R20, [R7, #16]	# short, #@loadUS
308 +   addw  R7, R29, zr	#@convI2L_reg_reg
30c +   add  R7, R7, R9	#@addL_reg_reg
310 +   add R7, R13, R7	# ptr, #@addP_reg_reg
314 +   bgt  R20, R16, B50	#@cmpI_branch  P=0.000000 C=20633.000000

318     B39: #	out( B41 B40 ) &lt;- in( B38 )  Freq: 0.951495
318 +   sb  R20, [R7, #16]	# byte, #@storeB
31c +   addiw  R7, R29, #1	#@addI_reg_imm
320 +   bge  R7, R19, B41	#@cmpI_loop  P=0.500000 C=20633.000000

324     B40: #	out( B37 ) &lt;- in( B39 )  Freq: 0.475747
324 +   spill R7 -&gt; R29	# spill size = 32
328 +   j  B37	#@branch

32c     B41: #	out( N1 ) &lt;- in( B1 B39 B34 )  Freq: 0.998736
32c +   spill R19 -&gt; R10	# spill size = 32
330 +   # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
348 +   ret	// return register, #@Ret

34c     B42: #	out( B43 ) &lt;- in( B24 )  Freq: 0.00043206
34c +   spill [sp, #0] -&gt; R19	# spill size = 32

350     B43: #	out( N1 ) &lt;- in( B37 B7 B42 )  Freq: 0.000434954
350 +   spill R11 -&gt; [sp, #24]	# spill size = 64
354 +   spill R13 -&gt; [sp, #8]	# spill size = 64
358 +   spill R21 -&gt; [sp, #4]	# spill size = 32
35c +   spill R19 -&gt; [sp, #16]	# spill size = 32
360 +   spill R29 -&gt; [sp, #20]	# spill size = 32
364 +   spill R28 -&gt; [sp, #32]	# spill size = 32
368 +   li R11, #-28	# int, #@loadConI
36c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.StringUTF16::compress @ bci:12 (line 180) L[0]=sp + #24 L[1]=sp + #32 L[2]=sp + #8 L[3]=sp + #4 L[4]=sp + #16 L[5]=sp + #20 L[6]=_ STK[0]=sp + #24 STK[1]=sp + #32
        # OopMap {[8]=Oop [24]=Oop off=880/0x370}
370     #@ShouldNotReachHere

37c     B44: #	out( B46 ) &lt;- in( B25 )  Freq: 0.000203322
37c +   spill R7 -&gt; R18	# spill size = 32
380 +   j  B46	#@branch

384     B45: #	out( B46 ) &lt;- in( B27 )  Freq: 0.000203322
384 +   addiw  R28, R31, #2	#@addI_reg_imm
388 +   # castII of R29, #@castII
388     addiw  R29, R29, #2	#@addI_reg_imm
38c +   addiw  R21, R21, #2	#@addI_reg_imm

390     B46: #	out( B49 ) &lt;- in( B44 B45 )  Freq: 0.000406644
390     spill R18 -&gt; R20	# spill size = 32
394 +   j  B49	#@branch

398     B47: #	out( B49 ) &lt;- in( B26 )  Freq: 0.000203322
398 +   addiw  R29, R29, #1	#@addI_reg_imm
39c +   addiw  R28, R31, #1	#@addI_reg_imm
3a0 +   addiw  R21, R21, #1	#@addI_reg_imm
3a4     spill R30 -&gt; R20	# spill size = 32
3a8 +   j  B49	#@branch

3ac     B48: #	out( B49 ) &lt;- in( B28 )  Freq: 0.000203322
3ac +   addiw  R29, R29, #3	#@addI_reg_imm
3b0 +   addiw  R28, R31, #3	#@addI_reg_imm
3b4 +   addiw  R21, R21, #3	#@addI_reg_imm

3b8     B49: #	out( B50 ) &lt;- in( B46 B47 B48 )  Freq: 0.000813287
3b8     spill [sp, #0] -&gt; R19	# spill size = 32

3bc     B50: #	out( N1 ) &lt;- in( B38 B8 B49 )  Freq: 0.000814649
3bc +   spill R11 -&gt; R8	# spill size = 64
3c0 +   spill R28 -&gt; [sp, #0]	# spill size = 32
3c4 +   spill R13 -&gt; [sp, #8]	# spill size = 64
3c8 +   spill R21 -&gt; [sp, #4]	# spill size = 32
3cc +   spill R19 -&gt; [sp, #16]	# spill size = 32
3d0 +   spill R29 -&gt; [sp, #20]	# spill size = 32
3d4 +   spill R20 -&gt; [sp, #28]	# spill size = 32
3d8 +   li R11, #-187	# int, #@loadConI
3dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringUTF16::compress @ bci:20 (line 181) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #4 L[4]=sp + #16 L[5]=sp + #20 L[6]=sp + #28 STK[0]=sp + #28 STK[1]=#255
        # OopMap {fp=Oop [8]=Oop off=992/0x3e0}
3e0     #@ShouldNotReachHere

3ec     B51: #	out( N1 ) &lt;- in( B5 B2 B3 B4 )  Freq: 3.86165e-06
3ec +   spill R11 -&gt; R8	# spill size = 64
3f0 +   spill R12 -&gt; [sp, #0]	# spill size = 32
3f4 +   spill R13 -&gt; [sp, #8]	# spill size = 64
3f8 +   spill R14 -&gt; [sp, #4]	# spill size = 32
3fc +   spill R19 -&gt; [sp, #20]	# spill size = 32
400 +   li R11, #-138	# int, #@loadConI
404     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringUTF16::compress @ bci:7 (line 179) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #4 L[4]=sp + #20 L[5]=#0 L[6]=_ STK[0]=#0 STK[1]=sp + #20
        # OopMap {fp=Oop [8]=Oop off=1032/0x408}
408     #@ShouldNotReachHere

414     B52: #	out( N1 ) &lt;- in( B12 )  Freq: 9.65405e-07
414     #@ShouldNotReachHere

420     B53: #	out( N1 ) &lt;- in( B13 )  Freq: 9.65404e-07
420     #@ShouldNotReachHere

42c     B54: #	out( N1 ) &lt;- in( B14 )  Freq: 9.65403e-07
42c     #@ShouldNotReachHere

438     B55: #	out( N1 ) &lt;- in( B15 )  Freq: 9.65402e-07
438     #@ShouldNotReachHere

444     B56: #	out( N1 ) &lt;- in( B16 )  Freq: 9.65401e-07
444     #@ShouldNotReachHere

450     B57: #	out( N1 ) &lt;- in( B17 )  Freq: 9.654e-07
450     #@ShouldNotReachHere

45c     B58: #	out( N1 ) &lt;- in( B18 )  Freq: 9.65399e-07
45c     #@ShouldNotReachHere

468     B59: #	out( N1 ) &lt;- in( B19 )  Freq: 9.65398e-07
468     #@ShouldNotReachHere

474     B60: #	out( N1 ) &lt;- in( B20 )  Freq: 9.65397e-07
474     #@ShouldNotReachHere

480     B61: #	out( N1 ) &lt;- in( B21 )  Freq: 9.65396e-07
480     #@ShouldNotReachHere

48c     B62: #	out( N1 ) &lt;- in( B35 )  Freq: 4.82067e-07
48c     #@ShouldNotReachHere

498     B63: #	out( N1 ) &lt;- in( B36 )  Freq: 4.82067e-07
498     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='499'>
----------------------- MetaData before Compile_id = 499 ------------------------
{method}
 - this oop:          0x0000004096534930
 - method holder:     &apos;jdk/internal/module/ModuleInfo$CountingDataInput&apos;
 - constants:         0x0000004096533c18 constant pool [122] {0x0000004096533c18} for &apos;jdk/internal/module/ModuleInfo$CountingDataInput&apos; cache=0x0000004096534f58
 - access:            0x81000001  public 
 - name:              &apos;readUnsignedShort&apos;
 - signature:         &apos;()I&apos;
 - max stack:         6
 - max locals:        2
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      11
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c563d00
 - code size:         24
 - code start:        0x00000040965348f0
 - code end (excl):   0x0000004096534908
 - method data:       0x00000040964a19f8
 - checked ex length: 1
 - checked ex start:  0x000000409653492c
 - linenumber start:  0x0000004096534908
 - localvar length:   2
 - localvar start:    0x0000004096534912
 - compiled code: nmethod  21210  283       3       jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort (24 bytes)

------------------------ OptoAssembly for Compile_id = 499 -----------------------
#
#  int ( jdk/internal/module/ModuleInfo$CountingDataInput:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: jdk/internal/module/ModuleInfo$CountingDataInput:NotNull *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N185: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B18 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R28, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/module/ModuleInfo$CountingDataInput.delegate
040 +   spill R11 -&gt; [sp, #0]	# spill size = 64
044 +   decode_heap_oop  R8, R28	#@decodeHeapOop
048     lwu  R7, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
04c     NullCheck R8

04c     B2: #	out( B11 B3 ) &lt;- in( B1 )  Freq: 0.999999
04c +   mv  R29, narrowklass: precise klass java/io/DataInputStream: 0x00000040d0994950:Constant:exact *	# compressed klass ptr, #@loadConNKlass
05c +   bne  R7, R29, B11	#@cmpN_branch  P=0.000001 C=-1.000000

060     B3: #	out( B19 B4 ) &lt;- in( B2 )  Freq: 0.999998
060 +   # checkcastPP of R8, #@checkCastPP
060     lwu  R7, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: volatile java/io/FilterInputStream.in
064 +   #@membar_acquire
	fence ir iorw
068 +   decode_heap_oop  R29, R7	#@decodeHeapOop
06c     lwu  R28, [R29, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
070     NullCheck R29

070     B4: #	out( B12 B5 ) &lt;- in( B3 )  Freq: 0.999997
070 +   mv  R7, narrowklass: precise klass java/io/BufferedInputStream: 0x00000040d09986e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
080 +   bne  R28, R7, B12	#@cmpN_branch  P=0.000001 C=-1.000000

084     B5: #	out( B15 B6 ) &lt;- in( B4 )  Freq: 0.999996
084 +   # checkcastPP of R29, #@checkCastPP
084     spill R29 -&gt; R11	# spill size = 64
088     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.io.BufferedInputStream::read
        # java.io.DataInputStream::readUnsignedShort @ bci:4 (line 343) L[0]=R8 L[1]=_ L[2]=_
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=sp + #0 L[1]=_
        # OopMap {fp=Oop [0]=Oop off=140/0x8c}

08c     B6: #	out( B20 B7 ) &lt;- in( B5 )  Freq: 0.999976
        # Block is sole successor of call
08c +   lwu  R28, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: volatile java/io/FilterInputStream.in
090 +   #@membar_acquire
	fence ir iorw
094     spill R10 -&gt; [sp, #8]	# spill size = 32
098 +   decode_heap_oop  R28, R28	#@decodeHeapOop
09c     lwu  R7, [R28, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0a0     NullCheck R28

0a0     B7: #	out( B13 B8 ) &lt;- in( B6 )  Freq: 0.999975
0a0 +   mv  R29, narrowklass: precise klass java/io/BufferedInputStream: 0x00000040d09986e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0b0 +   bne  R7, R29, B13	#@cmpN_branch  P=0.000001 C=-1.000000

0b4     B8: #	out( B16 B9 ) &lt;- in( B7 )  Freq: 0.999974
0b4 +   # checkcastPP of R28, #@checkCastPP
0b4     spill R28 -&gt; R11	# spill size = 64
0b8     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.io.BufferedInputStream::read
        # java.io.DataInputStream::readUnsignedShort @ bci:12 (line 344) L[0]=_ L[1]=sp + #8 L[2]=_
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=sp + #0 L[1]=_
        # OopMap {[0]=Oop off=188/0xbc}

0bc     B9: #	out( B14 B10 ) &lt;- in( B8 )  Freq: 0.999954
        # Block is sole successor of call
0bc +   spill [sp, #8] -&gt; R29	# spill size = 32
0c0 +   orr  R8, R29, R10	#@orI_reg_reg
0c4 +   blt  R8, zr, B14	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

0c8     B10: #	out( N185 ) &lt;- in( B9 )  Freq: 0.999953
0c8 +   spill [sp, #0] -&gt; R7	# spill size = 64
0cc +   ld  R7, [R7, #16]	# int, #@loadL ! Field: jdk/internal/module/ModuleInfo$CountingDataInput.count
0d0 +   slliw  R28, R29, (#8 &amp; 0x1f)	#@lShiftI_reg_imm
0d4 +   addw  R10, R28, R10	#@addI_reg_reg
0d8 +   addi  R7, R7, #2	#@addL_reg_imm
0dc     spill [sp, #0] -&gt; R28	# spill size = 64
0e0 +   sd  R7, [R28, #16]	# long, #@storeL ! Field: jdk/internal/module/ModuleInfo$CountingDataInput.count
0e4     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0fc +   ret	// return register, #@Ret

100     B11: #	out( N185 ) &lt;- in( B2 )  Freq: 9.99999e-07
100 +   li R11, #-34	# int, #@loadConI
104     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=sp + #0 L[1]=_ STK[0]=R8
        # OopMap {fp=Oop [0]=Oop off=264/0x108}
108     #@ShouldNotReachHere

114     B12: #	out( N185 ) &lt;- in( B4 )  Freq: 9.99997e-07
114 +   li R11, #-34	# int, #@loadConI
118     spill R29 -&gt; [sp, #8]	# spill size = 64
11c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:4 (line 343) L[0]=R8 L[1]=_ L[2]=_ STK[0]=sp + #8
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=sp + #0 L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=288/0x120}
120     #@ShouldNotReachHere

12c     B13: #	out( N185 ) &lt;- in( B7 )  Freq: 9.99975e-07
12c +   spill [sp, #0] -&gt; R8	# spill size = 64
130 +   li R11, #-34	# int, #@loadConI
134     spill R28 -&gt; [sp, #0]	# spill size = 64
138     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:12 (line 344) L[0]=_ L[1]=sp + #8 L[2]=_ STK[0]=sp + #0
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=R8 L[1]=_
        # OopMap {fp=Oop [0]=Oop off=316/0x13c}
13c     #@ShouldNotReachHere

148     B14: #	out( N185 ) &lt;- in( B9 )  Freq: 4.76815e-07
148 +   li R11, #-187	# int, #@loadConI
14c     spill R10 -&gt; [sp, #12]	# spill size = 32
150     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:19 (line 345) L[0]=_ L[1]=sp + #8 L[2]=sp + #12 STK[0]=R8
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=sp + #0 L[1]=_
        # OopMap {[0]=Oop off=340/0x154}
154     #@ShouldNotReachHere

160     B15: #	out( B17 ) &lt;- in( B5 )  Freq: 9.99996e-06
160      -- 	// exception oop; no code emitted, #@CreateException
160 +   spill R10 -&gt; R11	# spill size = 64
164 +   j  B17	#@branch

168     B16: #	out( B17 ) &lt;- in( B8 )  Freq: 9.99974e-06
168      -- 	// exception oop; no code emitted, #@CreateException
168 +   spill R10 -&gt; R11	# spill size = 64

16c     B17: #	out( N185 ) &lt;- in( B15 B16 )  Freq: 1.99997e-05
16c     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
178 +   j rethrow_stub	#@RethrowException

180     B18: #	out( N185 ) &lt;- in( B1 )  Freq: 1.01328e-06
180 +   li R11, #-10	# int, #@loadConI
184     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=_ L[1]=_ STK[0]=#NULL
        # OopMap {off=392/0x188}
188     #@ShouldNotReachHere

194     B19: #	out( N185 ) &lt;- in( B3 )  Freq: 1.01328e-06
194 +   li R11, #-10	# int, #@loadConI
198     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:4 (line 343) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=_ L[1]=_
        # OopMap {off=412/0x19c}
19c     #@ShouldNotReachHere

1a8     B20: #	out( N185 ) &lt;- in( B6 )  Freq: 1.01325e-06
1a8 +   li R11, #-10	# int, #@loadConI
1ac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:12 (line 344) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=_ L[1]=_
        # OopMap {off=432/0x1b0}
1b0 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='500'>
----------------------- MetaData before Compile_id = 500 ------------------------
{method}
 - this oop:          0x0000004096532bc8
 - method holder:     &apos;java/io/DataInputStream&apos;
 - constants:         0x0000004096530ee8 constant pool [187] {0x0000004096530ee8} for &apos;java/io/DataInputStream&apos; cache=0x0000004096533738
 - access:            0x81000011  public final 
 - name:              &apos;readUnsignedShort&apos;
 - signature:         &apos;()I&apos;
 - max stack:         4
 - max locals:        3
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c564340
 - code size:         39
 - code start:        0x0000004096532b68
 - code end (excl):   0x0000004096532b8f
 - method data:       0x00000040964a1ba8
 - checked ex length: 1
 - checked ex start:  0x0000004096532bc4
 - linenumber start:  0x0000004096532b8f
 - localvar length:   3
 - localvar start:    0x0000004096532b9e
 - compiled code: nmethod  21236  284       3       java.io.DataInputStream::readUnsignedShort (39 bytes)

------------------------ OptoAssembly for Compile_id = 500 -----------------------
#
#  int ( java/io/DataInputStream:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/io/DataInputStream:NotNull *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N143: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B15 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R7, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: volatile java/io/FilterInputStream.in
040 +   #@membar_acquire
	fence ir iorw
044     spill R11 -&gt; R8	# spill size = 64
048 +   decode_heap_oop  R11, R7	#@decodeHeapOop
04c     lwu  R28, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
050     NullCheck R11

050     B2: #	out( B9 B3 ) &lt;- in( B1 )  Freq: 0.999999
050 +   mv  R7, narrowklass: precise klass java/io/BufferedInputStream: 0x00000040d07d23f0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
060 +   bne  R28, R7, B9	#@cmpN_branch  P=0.000001 C=-1.000000

064     B3: #	out( B12 B4 ) &lt;- in( B2 )  Freq: 0.999998
064 +   # checkcastPP of R11, #@checkCastPP
064     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.io.BufferedInputStream::read
        # java.io.DataInputStream::readUnsignedShort @ bci:4 (line 343) L[0]=R8 L[1]=_ L[2]=_
        # OopMap {fp=Oop off=104/0x68}

068     B4: #	out( B16 B5 ) &lt;- in( B3 )  Freq: 0.999978
        # Block is sole successor of call
068 +   lwu  R28, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: volatile java/io/FilterInputStream.in
06c +   #@membar_acquire
	fence ir iorw
070     spill R10 -&gt; [sp, #0]	# spill size = 32
074 +   decode_heap_oop  R28, R28	#@decodeHeapOop
078     lwu  R7, [R28, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
07c     NullCheck R28

07c     B5: #	out( B10 B6 ) &lt;- in( B4 )  Freq: 0.999977
07c +   mv  R29, narrowklass: precise klass java/io/BufferedInputStream: 0x00000040d07d23f0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
08c +   bne  R7, R29, B10	#@cmpN_branch  P=0.000001 C=-1.000000

090     B6: #	out( B13 B7 ) &lt;- in( B5 )  Freq: 0.999976
090 +   # checkcastPP of R28, #@checkCastPP
090     spill R28 -&gt; R11	# spill size = 64
094     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.io.BufferedInputStream::read
        # java.io.DataInputStream::readUnsignedShort @ bci:12 (line 344) L[0]=_ L[1]=sp + #0 L[2]=_
        # OopMap {off=152/0x98}

098     B7: #	out( B11 B8 ) &lt;- in( B6 )  Freq: 0.999956
        # Block is sole successor of call
098 +   spill [sp, #0] -&gt; R28	# spill size = 32
09c +   orr  R8, R28, R10	#@orI_reg_reg
0a0 +   blt  R8, zr, B11	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

0a4     B8: #	out( N143 ) &lt;- in( B7 )  Freq: 0.999955
0a4 +   slliw  R7, R28, (#8 &amp; 0x1f)	#@lShiftI_reg_imm
0a8 +   addw  R10, R7, R10	#@addI_reg_reg
0ac     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0c4 +   ret	// return register, #@Ret

0c8     B9: #	out( N143 ) &lt;- in( B2 )  Freq: 9.99999e-07
0c8 +   spill R11 -&gt; [sp, #0]	# spill size = 64
0cc +   li R11, #-34	# int, #@loadConI
0d0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:4 (line 343) L[0]=R8 L[1]=_ L[2]=_ STK[0]=sp + #0
        # OopMap {fp=Oop [0]=Oop off=212/0xd4}
0d4     #@ShouldNotReachHere

0e0     B10: #	out( N143 ) &lt;- in( B5 )  Freq: 9.99977e-07
0e0 +   li R11, #-34	# int, #@loadConI
0e4     spill R28 -&gt; R8	# spill size = 64
0e8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:12 (line 344) L[0]=_ L[1]=sp + #0 L[2]=_ STK[0]=R8
        # OopMap {fp=Oop off=236/0xec}
0ec     #@ShouldNotReachHere

0f8     B11: #	out( N143 ) &lt;- in( B7 )  Freq: 4.76816e-07
0f8 +   li R11, #-187	# int, #@loadConI
0fc     spill R10 -&gt; [sp, #4]	# spill size = 32
100     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:19 (line 345) L[0]=_ L[1]=sp + #0 L[2]=sp + #4 STK[0]=R8
        # OopMap {off=260/0x104}
104     #@ShouldNotReachHere

110     B12: #	out( B14 ) &lt;- in( B3 )  Freq: 9.99998e-06
110      -- 	// exception oop; no code emitted, #@CreateException
110 +   spill R10 -&gt; R11	# spill size = 64
114 +   j  B14	#@branch

118     B13: #	out( B14 ) &lt;- in( B6 )  Freq: 9.99976e-06
118      -- 	// exception oop; no code emitted, #@CreateException
118 +   spill R10 -&gt; R11	# spill size = 64

11c     B14: #	out( N143 ) &lt;- in( B12 B13 )  Freq: 1.99997e-05
11c     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
128 +   j rethrow_stub	#@RethrowException

130     B15: #	out( N143 ) &lt;- in( B1 )  Freq: 1.01328e-06
130 +   li R11, #-10	# int, #@loadConI
134     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:4 (line 343) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # OopMap {off=312/0x138}
138     #@ShouldNotReachHere

144     B16: #	out( N143 ) &lt;- in( B4 )  Freq: 1.01326e-06
144 +   li R11, #-10	# int, #@loadConI
148     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:12 (line 344) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # OopMap {off=332/0x14c}
14c +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='501'>
----------------------- MetaData before Compile_id = 501 ------------------------
{method}
 - this oop:          0x0000004096533688
 - method holder:     &apos;java/io/DataInputStream&apos;
 - constants:         0x0000004096530ee8 constant pool [187] {0x0000004096530ee8} for &apos;java/io/DataInputStream&apos; cache=0x0000004096533738
 - access:            0xc1000019  public static final 
 - name:              &apos;readUTF&apos;
 - signature:         &apos;(Ljava/io/DataInput;)Ljava/lang/String;&apos;
 - max stack:         6
 - max locals:        9
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c5656c0
 - code size:         501
 - code start:        0x00000040965333c8
 - code end (excl):   0x00000040965335bd
 - method data:       0x00000040964a1fa0
 - checked ex length: 1
 - checked ex start:  0x0000004096533684
 - linenumber start:  0x00000040965335bd
 - localvar length:   12
 - localvar start:    0x00000040965335f2
 - compiled code: nmethod  21465  286       3       java.io.DataInputStream::readUTF (501 bytes)

------------------------ OptoAssembly for Compile_id = 501 -----------------------
#
#  java/lang/String:exact * ( java/io/DataInput * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/io/DataInput *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B103 B89 B104 B90 B105 B91 B106 B92 B97 B118 B98 B54 B93 B95 B96 B100 B73 B94 )  Freq: 1

000     B1: #	out( B103 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
01c     spill R11 -&gt; R29	# spill size = 64
020     lwu  R28, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
024     NullCheck R11

024     B2: #	out( B89 B3 ) &lt;- in( B1 )  Freq: 0.999999
024 +   mv  R7, narrowklass: precise klass jdk/internal/module/ModuleInfo$CountingDataInput: 0x00000040d0729950:Constant:exact *	# compressed klass ptr, #@loadConNKlass
034 +   bne  R28, R7, B89	#@cmpN_branch  P=0.000001 C=-1.000000

038     B3: #	out( B104 B4 ) &lt;- in( B2 )  Freq: 0.999998
038 +   # checkcastPP of R29, #@checkCastPP
038     lwu  R28, [R29, #12]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/module/ModuleInfo$CountingDataInput.delegate
03c +   spill R29 -&gt; [sp, #0]	# spill size = 64
040 +   decode_heap_oop  R8, R28	#@decodeHeapOop
044     lwu  R7, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
048     NullCheck R8

048     B4: #	out( B90 B5 ) &lt;- in( B3 )  Freq: 0.999997
048 +   mv  R29, narrowklass: precise klass java/io/DataInputStream: 0x00000040d07286e0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
058 +   bne  R7, R29, B90	#@cmpN_branch  P=0.000001 C=-1.000000

05c     B5: #	out( B105 B6 ) &lt;- in( B4 )  Freq: 0.999996
05c +   # checkcastPP of R8, #@checkCastPP
05c     lwu  R7, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: volatile java/io/FilterInputStream.in
060 +   #@membar_acquire
	fence ir iorw
064 +   decode_heap_oop  R29, R7	#@decodeHeapOop
068     lwu  R28, [R29, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
06c     NullCheck R29

06c     B6: #	out( B91 B7 ) &lt;- in( B5 )  Freq: 0.999995
06c +   mv  R7, narrowklass: precise klass java/io/BufferedInputStream: 0x00000040d05891d0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
07c +   bne  R28, R7, B91	#@cmpN_branch  P=0.000001 C=-1.000000

080     B7: #	out( B113 B8 ) &lt;- in( B6 )  Freq: 0.999994
080 +   # checkcastPP of R29, #@checkCastPP
080     spill R29 -&gt; R11	# spill size = 64
084     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.io.BufferedInputStream::read
        # java.io.DataInputStream::readUnsignedShort @ bci:4 (line 343) L[0]=R8 L[1]=_ L[2]=_
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=sp + #0 L[1]=_
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {fp=Oop [0]=Oop off=136/0x88}

088     B8: #	out( B106 B9 ) &lt;- in( B7 )  Freq: 0.999974
        # Block is sole successor of call
088 +   lwu  R28, [R8, #12]	# loadN, compressed ptr, #@loadN ! Field: volatile java/io/FilterInputStream.in
08c +   #@membar_acquire
	fence ir iorw
090     spill R10 -&gt; [sp, #8]	# spill size = 32
094 +   decode_heap_oop  R28, R28	#@decodeHeapOop
098     lwu  R7, [R28, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
09c     NullCheck R28

09c     B9: #	out( B92 B10 ) &lt;- in( B8 )  Freq: 0.999973
09c +   mv  R29, narrowklass: precise klass java/io/BufferedInputStream: 0x00000040d05891d0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0ac +   bne  R7, R29, B92	#@cmpN_branch  P=0.000001 C=-1.000000

0b0     B10: #	out( B114 B11 ) &lt;- in( B9 )  Freq: 0.999972
0b0 +   slliw  R29, R10, (#8 &amp; 0x1f)	#@lShiftI_reg_imm
0b4     # checkcastPP of R28, #@checkCastPP
0b4     spill R29 -&gt; [sp, #12]	# spill size = 32
0b8 +   spill R28 -&gt; R11	# spill size = 64
0bc +   spill [sp, #0] -&gt; R8	# spill size = 64
0c0     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.io.BufferedInputStream::read
        # java.io.DataInputStream::readUnsignedShort @ bci:12 (line 344) L[0]=_ L[1]=sp + #8 L[2]=_
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=R8 L[1]=_
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {fp=Oop [0]=Oop off=196/0xc4}

0c4     B11: #	out( B97 B12 ) &lt;- in( B10 )  Freq: 0.999952
        # Block is sole successor of call
0c4 +   ld  R7, [R8, #16]	# int, #@loadL ! Field: jdk/internal/module/ModuleInfo$CountingDataInput.count
0c8     spill [sp, #8] -&gt; R28	# spill size = 32
0cc +   orr  R8, R28, R10	#@orI_reg_reg
0d0     spill [sp, #12] -&gt; R29	# spill size = 32
0d4 +   addw  R30, R29, R10	#@addI_reg_reg
0d8 +   addi  R7, R7, #2	#@addL_reg_imm
0dc +   blt  R8, zr, B97	#@cmpI_reg_imm0_branch  P=0.000000 C=5376.000000

0e0     B12: #	out( B13 B13 ) &lt;- in( B11 )  Freq: 0.999951
0e0 +   li R31, #1048576	# int, #@loadConI
0e4 +   addw  R28, R30, zr	#@convI2L_reg_reg
0e8 +   bleu  R30, R31, B13	#@cmpU_branch  P=0.999999 C=-1.000000

0ec     B13: #	out( B74 B14 ) &lt;- in( B12 B12 )  Freq: 0.999951
0ec +   spill [sp, #0] -&gt; R29	# spill size = 64
0f0 +   sd  R7, [R29, #16]	# long, #@storeL ! Field: jdk/internal/module/ModuleInfo$CountingDataInput.count
0f4 +   li R7, #1048576	# int, #@loadConI
0f8 +   bgtu  R30, R7, B74	#@cmpU_branch  P=0.000001 C=-1.000000

0fc     B14: #	out( B74 B15 ) &lt;- in( B13 )  Freq: 0.99995
0fc +   addi  R7, R28, #23	#@addL_reg_imm
100 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
100     ld  R10, [R23, #288]	# ptr, #@loadP
104 +   andi  R28, R7, #-8	#@andL_reg_imm
108 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
108     ld  R29, [R23, #304]	# ptr, #@loadP
10c +   add R28, R10, R28	# ptr, #@addP_reg_reg
110 +   bgeu  R28, R29, B74	#@cmpP_branch  P=0.000100 C=-1.000000

114     B15: #	out( B16 ) &lt;- in( B14 )  Freq: 0.99985
114 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
114     sd  R28, [R23, #288]	# ptr, #@storeP
118 +   li R28, #1	# long, #@loadConL
11c +   sd  R28, [R10]	# long, #@storeL
120 +   mv  R28, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
130 +   sw  R28, [R10, #8]	# compressed klass ptr, #@storeNKlass
134 +   srli  R7, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
138 +   addi  R28, R10, #16	# ptr, #@addP_reg_imm
13c +   addi  R29, R7, #-2	#@addL_reg_imm
140 +   sw  R30, [R10, #12]	# int, #@storeI
144 +   ClearArray R29, R28	#@clearArray_reg_reg

19c     B16: #	out( B76 B17 ) &lt;- in( B75 B15 )  Freq: 0.999951
19c     
19c     MEMBAR-store-store	#@membar_storestore
1a0 +   spill R30 -&gt; R7	# spill size = 32
1a4 +   # castII of R7, #@castII
1a4     li R28, #524288	# int, #@loadConI
1a8     spill R10 -&gt; R31	# spill size = 64
1ac +   addw  R8, R7, zr	#@convI2L_reg_reg
1b0 +   # checkcastPP of R31, #@checkCastPP
1b0     bgtu  R7, R28, B76	#@cmpU_branch  P=0.000001 C=-1.000000

1b4     B17: #	out( B76 B18 ) &lt;- in( B16 )  Freq: 0.99995
1b4 +   slli  R28, R8, (#1 &amp; 0x3f)	#@lShiftL_reg_imm
1b8 +   addi  R28, R28, #23	#@addL_reg_imm
1bc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1bc     ld  R10, [R23, #288]	# ptr, #@loadP
1c0 +   andi  R29, R28, #-8	#@andL_reg_imm
1c4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1c4     ld  R30, [R23, #304]	# ptr, #@loadP
1c8 +   add R29, R10, R29	# ptr, #@addP_reg_reg
1cc +   bgeu  R29, R30, B76	#@cmpP_branch  P=0.000100 C=-1.000000

1d0     B18: #	out( B19 ) &lt;- in( B17 )  Freq: 0.99985
1d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1d0     sd  R29, [R23, #288]	# ptr, #@storeP
1d4 +   li R29, #1	# long, #@loadConL
1d8 +   sd  R29, [R10]	# long, #@storeL
1dc +   mv  R30, narrowklass: precise klass [C: 0x00000040d001b5f0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1ec +   srli  R29, R28, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
1f0 +   sw  R30, [R10, #8]	# compressed klass ptr, #@storeNKlass
1f4 +   addi  R28, R10, #16	# ptr, #@addP_reg_imm
1f8 +   addi  R29, R29, #-2	#@addL_reg_imm
1fc +   sw  R7, [R10, #12]	# int, #@storeI
200     ClearArray R29, R28	#@clearArray_reg_reg
258     spill R31 -&gt; [sp, #8]	# spill size = 64
25c +   spill R7 -&gt; [sp, #16]	# spill size = 32

260     B19: #	out( B116 B20 ) &lt;- in( B77 B18 )  Freq: 0.999951
260     
260 +   MEMBAR-store-store	#@membar_storestore
264 +   spill [sp, #0] -&gt; R7	# spill size = 64
268 +   lwu  R7, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/module/ModuleInfo$CountingDataInput.delegate
26c +   # checkcastPP of R10, #@checkCastPP
26c     spill R10 -&gt; [sp, #24]	# spill size = 64
270 +   decode_heap_oop  R11, R7	#@decodeHeapOop
274     spill [sp, #8] -&gt; R12	# spill size = 64
278 +   li R13, #0	# int, #@loadConI
27c     spill [sp, #16] -&gt; R14	# spill size = 32
280     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.io.DataInput::readFully
        # jdk.internal.module.ModuleInfo$CountingDataInput::readFully @ bci:7 (line 1115) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=sp + #16
        # java.io.DataInputStream::readUTF @ bci:87 (line 614) L[0]=_ L[1]=sp + #16 L[2]=sp + #8 L[3]=sp + #24 L[4]=_ L[5]=_ L[6]=_ L[7]=#0 L[8]=#0
        # OopMap {[0]=Oop [8]=Oop [24]=Oop off=668/0x29c}

29c     B20: #	out( B60 B21 ) &lt;- in( B19 )  Freq: 0.999931
        # Block is sole successor of call
29c +   spill [sp, #0] -&gt; R28	# spill size = 64
2a0 +   ld  R7, [R28, #16]	# int, #@loadL ! Field: jdk/internal/module/ModuleInfo$CountingDataInput.count
2a4 +   add  R7, R7, R8	#@addL_reg_reg
2a8 +   sd  R7, [R28, #16]	# long, #@storeL ! Field: jdk/internal/module/ModuleInfo$CountingDataInput.count
2ac     spill [sp, #16] -&gt; R29	# spill size = 32
2b0 +   ble  R29, zr, B60	#@cmpI_reg_imm0_branch  P=0.048037 C=21296.000000

2b4     B21: #	out( B93 B22 ) &lt;- in( B20 )  Freq: 0.951897
2b4 +   addiw  R7, R29, #-1	#@addI_reg_imm
2b8 +   beq  R29, zr, B93	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

2bc     B22: #	out( B93 B23 ) &lt;- in( B21 )  Freq: 0.951896
2bc +   bgeu  R7, R29, B93	#@cmpU_branch  P=0.000001 C=-1.000000

2c0     B23: #	out( B99 B24 ) &lt;- in( B22 )  Freq: 0.951896
2c0 +   spill [sp, #8] -&gt; R16	# spill size = 64
2c4 +   lbu  R28, [R16, #16]	# byte, #@loadUB
2c8 +   li R11, #127	# int, #@loadConI
2cc +   bgt  R28, R11, B99	#@cmpI_branch  P=0.000000 C=20273.000000

2d0     B24: #	out( B34 B25 ) &lt;- in( B23 )  Freq: 0.951895
2d0 +   li R31, #-2147483648	# int, #@loadConI
2d4 +   addiw  R15, R29, #-3	#@addI_reg_imm
2d8     CMove R15, (R7 lt R15), R15, R31	#@cmovI_cmpI
	
2e0 +   li R12, #1	# int, #@loadConI
2e4 +   li R13, #4000	# int, #@loadConI
2ec     spill [sp, #24] -&gt; R14	# spill size = 64
2f0 +   sh  R28, [R14, #16]	# short, #@storeC
2f4 +   ble  R15, R12, B34	#@cmpI_branch  P=0.000001 C=-1.000000

2f8     B25: #	out( B94 B26 ) &lt;- in( B24 )  Freq: 0.951894
2f8 +   bleu  R29, R12, B94	#@cmpU_branch  P=0.000001 C=-1.000000

2fc     B26: #	out( B95 B27 ) &lt;- in( B25 )  Freq: 0.951893
2fc +   li R28, #4	# int, #@loadConI
300 +   bleu  R29, R28, B95	#@cmpU_branch  P=0.000001 C=-1.000000

304     B27: #	out( B28 ) &lt;- in( B26 B33 ) Loop( B27-B33 ) Freq: 19.8002
304 +   li R30, #0	# int, #@loadConI
308 +   subw  R7, R15, R12	#@subI_reg_reg
30c     CMove R7, (R15 lt R12), R7, R30	#@cmovI_cmpI
	
314 +   CMove R7, (R7 gtu R13), R7, R13	#@cmovI_cmpU
	
31c +   addw  R30, R7, R12	#@addI_reg_reg

320     B28: #	out( B68 B29 ) &lt;- in( B27 B32 ) Loop( B28-B32 inner main of N311 strip mined) Freq: 412.169
320 +   addw  R7, R12, zr	#@convI2L_reg_reg
324 +   add R28, R16, R7	# ptr, #@addP_reg_reg
328 +   slli  R7, R7, (#1 &amp; 0x3f)	#@lShiftL_reg_imm
32c +   lbu  R31, [R28, #16]	# byte, #@loadUB
330 +   lbu  R10, [R28, #17]	# byte, #@loadUB
334 +   lbu  R17, [R28, #18]	# byte, #@loadUB
338 +   add R7, R14, R7	# ptr, #@addP_reg_reg
33c +   lbu  R28, [R28, #19]	# byte, #@loadUB
340 +   bgt  R31, R11, B68	#@cmpI_branch  P=0.000000 C=20273.000000

344     B29: #	out( B71 B30 ) &lt;- in( B28 )  Freq: 412.168
344 +   sh  R31, [R7, #16]	# short, #@storeC
348 +   bgt  R10, R11, B71	#@cmpI_branch  P=0.000000 C=20273.000000

34c     B30: #	out( B69 B31 ) &lt;- in( B29 )  Freq: 412.168
34c +   sh  R10, [R7, #18]	# short, #@storeC
350 +   bgt  R17, R11, B69	#@cmpI_branch  P=0.000000 C=20273.000000

354     B31: #	out( B72 B32 ) &lt;- in( B30 )  Freq: 412.168
354 +   sh  R17, [R7, #20]	# short, #@storeC
358 +   bgt  R28, R11, B72	#@cmpI_branch  P=0.000000 C=20273.000000

35c     B32: #	out( B28 B33 ) &lt;- in( B31 )  Freq: 412.168
35c +   addiw  R12, R12, #4	#@addI_reg_imm
360 +   sh  R28, [R7, #22]	# short, #@storeC
364 +   blt  R12, R30, B28	#@cmpI_loop  P=0.951963 C=20273.000000

368     B33: #	out( B27 B34 ) &lt;- in( B32 )  Freq: 19.7994
368 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
368     ld  R30, [R23, #920]	# ptr, #@loadP
36c +   lwu zr, [R30]	# Safepoint: poll for GC, #@safePoint        # java.io.DataInputStream::readUTF @ bci:131 (line 620) L[0]=_ L[1]=R29 L[2]=R16 L[3]=R14 L[4]=_ L[5]=_ L[6]=_ L[7]=R12 L[8]=R12
        # OopMap {c_rarg4=Oop c_rarg6=Oop off=876/0x36c}
370 +   blt  R12, R15, B27	#@cmpI_branch  P=0.951963 C=20273.000000

374     B34: #	out( B38 B35 ) &lt;- in( B24 B33 )  Freq: 0.951107
374 +   bge  R12, R29, B38	#@cmpI_branch  P=0.500000 C=-1.000000

378     B35: #	out( B96 B36 ) &lt;- in( B34 )  Freq: 0.475553
378 +   # castII of R12, #@castII
378     bgeu  R12, R29, B96	#@cmpU_branch  P=0.000001 C=-1.000000

37c     B36: #	out( B73 B37 ) &lt;- in( B35 B37 ) Loop( B36-B37 inner post of N1224) Freq: 0.951106
37c +   addw  R7, R12, zr	#@convI2L_reg_reg
380 +   add R28, R16, R7	# ptr, #@addP_reg_reg
384 +   lbu  R28, [R28, #16]	# byte, #@loadUB
388 +   slli  R7, R7, (#1 &amp; 0x3f)	#@lShiftL_reg_imm
38c +   add R7, R14, R7	# ptr, #@addP_reg_reg
390 +   bgt  R28, R11, B73	#@cmpI_branch  P=0.000000 C=20273.000000

394     B37: #	out( B36 B38 ) &lt;- in( B36 )  Freq: 0.951105
394 +   addiw  R12, R12, #1	#@addI_reg_imm
398 +   sh  R28, [R7, #16]	# short, #@storeC
39c +   blt  R12, R29, B36	#@cmpI_loop  P=0.500000 C=20273.000000

3a0     B38: #	out( B39 ) &lt;- in( B37 B34 )  Freq: 0.951106
3a0 +   spill R12 -&gt; R7	# spill size = 32

3a4     B39: #	out( B98 B40 ) &lt;- in( B60 B38 )  Freq: 0.99914
3a4 +   blt  R7, R29, B98	#@cmpI_branch  P=0.000000 C=1023.000000

3a8     B40: #	out( B78 B41 ) &lt;- in( B39 )  Freq: 0.999139
3a8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3a8     ld  R10, [R23, #288]	# ptr, #@loadP
3ac +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3ac     ld  R28, [R23, #304]	# ptr, #@loadP
3b0 +   addi  R30, R10, #24	# ptr, #@addP_reg_imm
3b4 +   bgeu  R30, R28, B78	#@cmpP_branch  P=0.000100 C=-1.000000

3b8     B41: #	out( B42 ) &lt;- in( B40 )  Freq: 0.99904
3b8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3b8     sd  R30, [R23, #288]	# ptr, #@storeP
3bc +   li R28, #1	# long, #@loadConL
3c0 +   mv  R30, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
3d0 +   sd  R28, [R10]	# long, #@storeL
3d4 +   sw  R30, [R10, #8]	# compressed klass ptr, #@storeNKlass
3d8 +   sw  zr, [R10, #12]	# int, #@storeimmI0
3dc +   sd  zr, [R10, #16]	# long, #@storeimmL0
3e0     spill R29 -&gt; R8	# spill size = 32
3e4 +   spill R14 -&gt; [sp, #0]	# spill size = 64
3e8 +   spill R7 -&gt; [sp, #8]	# spill size = 32

3ec     B42: #	out( B117 B43 ) &lt;- in( B79 B41 )  Freq: 0.999139
3ec     
3ec +   # checkcastPP of R10, #@checkCastPP
3ec     spill R10 -&gt; [sp, #16]	# spill size = 64
3f0 +   li R11, #0	# int, #@loadConI
3f4     spill [sp, #8] -&gt; R12	# spill size = 32
3f8 +   spill R8 -&gt; R13	# spill size = 32
3fc     CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.String::checkBoundsOffCount
        # java.lang.String::rangeCheck @ bci:4 (line 304) L[0]=_ L[1]=_ L[2]=_
        # java.lang.String::&lt;init&gt; @ bci:7 (line 300) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #16 STK[1]=sp + #0 STK[2]=#0 STK[3]=sp + #8
        # java.io.DataInputStream::readUTF @ bci:497 (line 666) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ STK[0]=sp + #16
        # OopMap {[0]=Oop [16]=Oop off=1024/0x400}

400     B43: #	out( B55 B44 ) &lt;- in( B42 )  Freq: 0.999119
        # Block is sole successor of call
400 +   spill [sp, #8] -&gt; R7	# spill size = 32
404 +   beq  R7, zr, B55	#@cmpI_reg_imm0_branch  P=0.100000 C=-1.000000

408     B44: #	out( B87 B45 ) &lt;- in( B43 )  Freq: 0.899207
408 +   li R28, #1048576	# int, #@loadConI
40c +   bgtu  R7, R28, B87	#@cmpU_branch  P=0.000001 C=-1.000000

410     B45: #	out( B87 B46 ) &lt;- in( B44 )  Freq: 0.899207
410 +   addw  R7, R7, zr	#@convI2L_reg_reg
414 +   addi  R7, R7, #23	#@addL_reg_imm
418 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
418     ld  R10, [R23, #288]	# ptr, #@loadP
41c +   andi  R28, R7, #-8	#@andL_reg_imm
420 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
420     ld  R29, [R23, #304]	# ptr, #@loadP
424 +   add R28, R10, R28	# ptr, #@addP_reg_reg
428 +   bgeu  R28, R29, B87	#@cmpP_branch  P=0.000100 C=-1.000000

42c     B46: #	out( B47 ) &lt;- in( B45 )  Freq: 0.899117
42c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
42c     sd  R28, [R23, #288]	# ptr, #@storeP
430 +   li R28, #1	# long, #@loadConL
434 +   mv  R29, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
444 +   sd  R28, [R10]	# long, #@storeL
448 +   sw  R29, [R10, #8]	# compressed klass ptr, #@storeNKlass
44c     spill [sp, #8] -&gt; R28	# spill size = 32
450 +   sw  R28, [R10, #12]	# int, #@storeI
454 +   srli  R7, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
458 +   addi  R28, R10, #16	# ptr, #@addP_reg_imm
45c +   addi  R29, R7, #-2	#@addL_reg_imm
460 +   ClearArray R29, R28	#@clearArray_reg_reg

4b8     B47: #	out( B111 B48 ) &lt;- in( B88 B46 )  Freq: 0.899207
4b8     
4b8     MEMBAR-store-store	#@membar_storestore
4bc +   spill R10 -&gt; R8	# spill size = 64
4c0 +   # checkcastPP of R8, #@checkCastPP
4c0     spill [sp, #0] -&gt; R11	# spill size = 64
4c4 +   li R12, #0	# int, #@loadConI
4c8     spill R8 -&gt; R13	# spill size = 64
4cc +   li R14, #0	# int, #@loadConI
4d0     spill [sp, #8] -&gt; R15	# spill size = 32
4d4     CALL,static 0x00000040139d2fc0	#@CallStaticJavaDirect java.lang.StringUTF16::compress
        # java.lang.StringUTF16::compress @ bci:9 (line 162) L[0]=_ L[1]=_ L[2]=sp + #8 L[3]=R8
        # java.lang.String::&lt;init&gt; @ bci:36 (line 4494) L[0]=sp + #16 L[1]=sp + #0 L[2]=#0 L[3]=sp + #8 L[4]=_ L[5]=_
        # java.lang.String::&lt;init&gt; @ bci:10 (line 300) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.io.DataInputStream::readUTF @ bci:497 (line 666) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ STK[0]=sp + #16
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=1240/0x4d8}

4d8     B48: #	out( B100 B49 ) &lt;- in( B47 )  Freq: 0.899189
        # Block is sole successor of call
4d8 +   spill [sp, #8] -&gt; R7	# spill size = 32
4dc +   bne  R10, R7, B100	#@cmpI_branch  P=0.000000 C=1166.000000

4e0     B49: #	out( B61 B50 ) &lt;- in( B48 )  Freq: 0.899189
4e0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
4e0     lb  R7, [R23, #56]	# byte, #@loadB
4e4 +   bne  R7, zr, B61	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

4e8     B50: #	out( B51 ) &lt;- in( B49 )  Freq: 0.89829
4e8 +   spill [sp, #16] -&gt; R9	# spill size = 64

4ec     B51: #	out( B53 B52 ) &lt;- in( B101 B63 B61 B50 )  Freq: 0.899189
4ec +   mv  R7, R9	# ptr -&gt; long, #@castP2X
4f0 +   mv  R28, R8	# ptr -&gt; long, #@castP2X
4f4 +   xorr  R28, R28, R7	#@xorL_reg_reg
4f8 +   encode_heap_oop  R30, R8	#@encodeHeapOop
4fc +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
500 +   sw  R30, [R9, #20]	# compressed ptr, #@storeN ! Field: java/lang/String.value (constant)
504 +   beq  R28, zr, B53	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

508     B52: #	out( B64 B53 ) &lt;- in( B51 )  Freq: 0.89829
508 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
50c +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
518 +   add R10, R28, R7	# ptr, #@addP_reg_reg
51c +   lb  R7, [R10]	# byte, #@loadB
520 +   li R29, #4	# int, #@loadConI
524 +   bne  R7, R29, B64	#@cmpI_branch  P=0.001000 C=-1.000000

528     B53: #	out( B54 ) &lt;- in( B66 B67 B64 B52 B51 )  Freq: 0.899189
528 +   sb zr, [R9, #16]	# byte, #@storeimmB0 ! Field: java/lang/String.coder (constant)

52c     B54: #	out( N1 ) &lt;- in( B59 B53 )  Freq: 0.999101
52c +   #@membar_release
	fence iorw ow
530 +   #@membar_release
	fence iorw ow
530 +   spill R9 -&gt; R10	# spill size = 64
534 +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
54c +   ret	// return register, #@Ret

550     B55: #	out( B80 B56 ) &lt;- in( B43 )  Freq: 0.099912
550 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
550     lb  R7, [R23, #56]	# byte, #@loadB
554 +   bne  R7, zr, B80	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

558     B56: #	out( B57 ) &lt;- in( B55 )  Freq: 0.0998121
558 +   spill [sp, #16] -&gt; R9	# spill size = 64

55c     B57: #	out( B59 B58 ) &lt;- in( B102 B82 B80 B56 )  Freq: 0.099912
55c +   mv  R7, stable:byte[int:0]&lt;ciTypeArray length=0 type=&lt;ciTypeArrayKlass name=[B loaded=true ident=1142 address=0x00000040d001b710&gt; ident=1186 address=0x00000040d08855a0&gt; *	# ptr, #@loadConP
574 +   mv  R28, R9	# ptr -&gt; long, #@castP2X
578 +   mv  R7, R7	# ptr -&gt; long, #@castP2X
578 +   xorr  R7, R7, R28	#@xorL_reg_reg
57c +   mv  R30, narrowoop: stable:byte[int:0]&lt;ciTypeArray length=0 type=&lt;ciTypeArrayKlass name=[B loaded=true ident=1142 address=0x00000040d001b710&gt; ident=1186 address=0x00000040d08855a0&gt; *	# compressed ptr, #@loadConN
58c +   srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
590 +   sw  R30, [R9, #20]	# compressed ptr, #@storeN ! Field: java/lang/String.value (constant)
594 +   beq  R7, zr, B59	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

598     B58: #	out( B83 B59 ) &lt;- in( B57 )  Freq: 0.0998121
598 +   srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
59c +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
5a8 +   add R10, R28, R7	# ptr, #@addP_reg_reg
5ac +   lb  R7, [R10]	# byte, #@loadB
5b0 +   li R28, #4	# int, #@loadConI
5b4 +   bne  R7, R28, B83	#@cmpI_branch  P=0.001000 C=-1.000000

5b8     B59: #	out( B54 ) &lt;- in( B85 B86 B83 B58 B57 )  Freq: 0.099912
5b8 +   sb zr, [R9, #16]	# byte, #@storeimmB0 ! Field: java/lang/String.coder (constant)
5bc +   j  B54	#@branch

5c0     B60: #	out( B39 ) &lt;- in( B20 )  Freq: 0.0480339
5c0 +   li R7, #0	# int, #@loadConI
5c4     spill [sp, #8] -&gt; R16	# spill size = 64
5c8 +   spill [sp, #24] -&gt; R14	# spill size = 64
5cc +   j  B39	#@branch

5d0     B61: #	out( B51 B62 ) &lt;- in( B49 )  Freq: 0.000899177
5d0 +   spill [sp, #16] -&gt; R9	# spill size = 64
5d4 +   lwu  R28, [R9, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
5d8 +   decode_heap_oop  R10, R28	#@decodeHeapOop
5dc +   beq   R10, zr, B51	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

5e0     B62: #	out( B101 B63 ) &lt;- in( B61 )  Freq: 0.000449589
5e0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5e0     ld  R7, [R23, #32]	# int, #@loadL
5e4 +   beq  R7, zr, B101	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

5e8     B63: #	out( B51 ) &lt;- in( B62 )  Freq: 0.000449139
5e8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5e8     ld  R28, [R23, #48]	# ptr, #@loadP
5ec +   add R28, R28, R7	# ptr, #@addP_reg_reg
5f0 +   addi  R7, R7, #-8	#@addL_reg_imm
5f4 +   sd  R10, [R28, #-8]	# ptr, #@storeP
5f8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5f8     sd  R7, [R23, #32]	# long, #@storeL
5fc +   j  B51	#@branch

600     B64: #	out( B53 B65 ) &lt;- in( B52 )  Freq: 0.00089829
600 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
600     ld  R7, [R23, #64]	# int, #@loadL
604 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
604     ld  R28, [R23, #80]	# ptr, #@loadP
608 +   #@membar_volatile
	fence iorw iorw
60c +   lb  R30, [R10]	# byte, #@loadB
610 +   beq  R30, zr, B53	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

614     B65: #	out( B67 B66 ) &lt;- in( B64 )  Freq: 0.000449145
614 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
618 +   bne  R7, zr, B67	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

61c     B66: #	out( B53 ) &lt;- in( B65 )  Freq: 0.000224572
61c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
61c     spill R23 -&gt; R11	# spill size = 64
620 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
650 +   j  B53	#@branch

654     B67: #	out( B53 ) &lt;- in( B65 )  Freq: 0.000224572
654 +   add R28, R28, R7	# ptr, #@addP_reg_reg
658 +   addi  R7, R7, #-8	#@addL_reg_imm
65c +   sd  R10, [R28, #-8]	# ptr, #@storeP
660 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
660     sd  R7, [R23, #64]	# long, #@storeL
664 +   j  B53	#@branch

668     B68: #	out( B70 ) &lt;- in( B28 )  Freq: 0.000196537
668 +   spill R31 -&gt; R17	# spill size = 32
66c +   j  B70	#@branch

670     B69: #	out( B70 ) &lt;- in( B30 )  Freq: 0.000196537
670 +   addiw  R12, R12, #2	#@addI_reg_imm

674     B70: #	out( B73 ) &lt;- in( B68 B69 )  Freq: 0.000393074
674     spill R17 -&gt; R28	# spill size = 32
678 +   j  B73	#@branch

67c     B71: #	out( B73 ) &lt;- in( B29 )  Freq: 0.000196537
67c +   addiw  R12, R12, #1	#@addI_reg_imm
680     spill R10 -&gt; R28	# spill size = 32
684 +   j  B73	#@branch

688     B72: #	out( B73 ) &lt;- in( B31 )  Freq: 0.000196537
688 +   addiw  R12, R12, #3	#@addI_reg_imm

68c     B73: #	out( N1 ) &lt;- in( B36 B99 B70 B71 B72 )  Freq: 0.000787056
68c +   li R11, #-187	# int, #@loadConI
690     spill R16 -&gt; R8	# spill size = 64
694 +   spill R14 -&gt; [sp, #0]	# spill size = 64
698 +   spill R12 -&gt; [sp, #16]	# spill size = 32
69c +   spill R28 -&gt; [sp, #20]	# spill size = 32
6a0 +   spill R29 -&gt; [sp, #24]	# spill size = 32
6a4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.io.DataInputStream::readUTF @ bci:112 (line 618) L[0]=_ L[1]=sp + #24 L[2]=R8 L[3]=sp + #0 L[4]=sp + #20 L[5]=_ L[6]=_ L[7]=sp + #16 L[8]=sp + #16 STK[0]=sp + #20 STK[1]=#127
        # OopMap {fp=Oop [0]=Oop off=1704/0x6a8}
6a8     #@ShouldNotReachHere

6b4     B74: #	out( B109 B75 ) &lt;- in( B13 B14 )  Freq: 0.000101025
6b4 +   spill R30 -&gt; [sp, #8]	# spill size = 32
6b8 +   spill [sp, #0] -&gt; R8	# spill size = 64
6bc +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
6d4     spill R30 -&gt; R12	# spill size = 32
6d8     CALL,static 0x000000401390d640	#@CallStaticJavaDirect wrapper for: _new_array_Java
        # java.io.DataInputStream::readUTF @ bci:70 (line 606) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {fp=Oop [0]=Oop off=1756/0x6dc}

6dc     B75: #	out( B16 ) &lt;- in( B74 )  Freq: 0.000101023
        # Block is sole successor of call
6dc +   spill [sp, #8] -&gt; R30	# spill size = 32
6e0 +   j  B16	#@branch

6e4     B76: #	out( B110 B77 ) &lt;- in( B16 B17 )  Freq: 0.000101025
6e4 +   spill R7 -&gt; [sp, #16]	# spill size = 32
6e8 +   spill R31 -&gt; [sp, #8]	# spill size = 64
6ec +   mv  R11, precise klass [C: 0x00000040d001b5f0:Constant:exact *	# ptr, #@loadConP
704     spill R7 -&gt; R12	# spill size = 32
708     CALL,static 0x000000401390d640	#@CallStaticJavaDirect wrapper for: _new_array_Java
        # java.io.DataInputStream::readUTF @ bci:74 (line 607) L[0]=sp + #0 L[1]=sp + #16 L[2]=sp + #8 L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {[0]=Oop [8]=Oop off=1804/0x70c}

70c     B77: #	out( B19 ) &lt;- in( B76 )  Freq: 0.000101023
        # Block is sole successor of call
70c +   j  B19	#@branch

710     B78: #	out( B108 B79 ) &lt;- in( B40 )  Freq: 9.99305e-05
710 +   spill R7 -&gt; [sp, #8]	# spill size = 32
714 +   spill R14 -&gt; [sp, #0]	# spill size = 64
718 +   spill R29 -&gt; R8	# spill size = 32
71c +   mv  R11, precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# ptr, #@loadConP
734     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.io.DataInputStream::readUTF @ bci:489 (line 666) L[0]=_ L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=sp + #8
        # OopMap {[0]=Oop off=1848/0x738}

738     B79: #	out( B42 ) &lt;- in( B78 )  Freq: 9.99285e-05
        # Block is sole successor of call
738 +   j  B42	#@branch

73c     B80: #	out( B57 B81 ) &lt;- in( B55 )  Freq: 9.99107e-05
73c +   spill [sp, #16] -&gt; R9	# spill size = 64
740 +   lwu  R28, [R9, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
744 +   decode_heap_oop  R10, R28	#@decodeHeapOop
748 +   beq   R10, zr, B57	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

74c     B81: #	out( B102 B82 ) &lt;- in( B80 )  Freq: 4.99553e-05
74c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
74c     ld  R7, [R23, #32]	# int, #@loadL
750 +   beq  R7, zr, B102	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

754     B82: #	out( B57 ) &lt;- in( B81 )  Freq: 4.99054e-05
754 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
754     ld  R28, [R23, #48]	# ptr, #@loadP
758 +   add R28, R28, R7	# ptr, #@addP_reg_reg
75c +   addi  R7, R7, #-8	#@addL_reg_imm
760 +   sd  R10, [R28, #-8]	# ptr, #@storeP
764 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
764     sd  R7, [R23, #32]	# long, #@storeL
768 +   j  B57	#@branch

76c     B83: #	out( B59 B84 ) &lt;- in( B58 )  Freq: 9.98121e-05
76c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
76c     ld  R7, [R23, #64]	# int, #@loadL
770 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
770     ld  R28, [R23, #80]	# ptr, #@loadP
774 +   #@membar_volatile
	fence iorw iorw
778 +   lb  R30, [R10]	# byte, #@loadB
77c +   beq  R30, zr, B59	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

780     B84: #	out( B86 B85 ) &lt;- in( B83 )  Freq: 4.9906e-05
780 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
784 +   bne  R7, zr, B86	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

788     B85: #	out( B59 ) &lt;- in( B84 )  Freq: 2.4953e-05
788 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
788     spill R23 -&gt; R11	# spill size = 64
78c +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
7bc +   j  B59	#@branch

7c0     B86: #	out( B59 ) &lt;- in( B84 )  Freq: 2.4953e-05
7c0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
7c4 +   addi  R7, R7, #-8	#@addL_reg_imm
7c8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
7cc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7cc     sd  R7, [R23, #64]	# long, #@storeL
7d0 +   j  B59	#@branch

7d4     B87: #	out( B107 B88 ) &lt;- in( B44 B45 )  Freq: 9.08467e-05
7d4 +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
7ec     spill [sp, #8] -&gt; R12	# spill size = 32
7f0     CALL,static 0x000000401390d640	#@CallStaticJavaDirect wrapper for: _new_array_Java
        # java.lang.StringUTF16::compress @ bci:1 (line 161) L[0]=sp + #0 L[1]=#0 L[2]=sp + #8 L[3]=_
        # java.lang.String::&lt;init&gt; @ bci:36 (line 4494) L[0]=sp + #16 L[1]=sp + #0 L[2]=#0 L[3]=sp + #8 L[4]=_ L[5]=_
        # java.lang.String::&lt;init&gt; @ bci:10 (line 300) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.io.DataInputStream::readUTF @ bci:497 (line 666) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ STK[0]=sp + #16
        # OopMap {[0]=Oop [16]=Oop off=2036/0x7f4}

7f4     B88: #	out( B47 ) &lt;- in( B87 )  Freq: 9.08449e-05
        # Block is sole successor of call
7f4 +   j  B47	#@branch

7f8     B89: #	out( N1 ) &lt;- in( B2 )  Freq: 9.99999e-07
7f8 +   li R11, #-34	# int, #@loadConI
7fc     spill R29 -&gt; [sp, #0]	# spill size = 64
800     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ STK[0]=sp + #0
        # OopMap {[0]=Oop off=2052/0x804}
804     #@ShouldNotReachHere

810     B90: #	out( N1 ) &lt;- in( B4 )  Freq: 9.99997e-07
810 +   li R11, #-34	# int, #@loadConI
814     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=sp + #0 L[1]=_ STK[0]=R8
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {fp=Oop [0]=Oop off=2072/0x818}
818     #@ShouldNotReachHere

824     B91: #	out( N1 ) &lt;- in( B6 )  Freq: 9.99995e-07
824 +   li R11, #-34	# int, #@loadConI
828     spill R29 -&gt; [sp, #16]	# spill size = 64
82c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:4 (line 343) L[0]=R8 L[1]=_ L[2]=_ STK[0]=sp + #16
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=sp + #0 L[1]=_
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=2096/0x830}
830     #@ShouldNotReachHere

83c     B92: #	out( N1 ) &lt;- in( B9 )  Freq: 9.99973e-07
83c +   li R11, #-34	# int, #@loadConI
840     spill [sp, #0] -&gt; R8	# spill size = 64
844 +   spill R28 -&gt; [sp, #16]	# spill size = 64
848     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:12 (line 344) L[0]=_ L[1]=sp + #8 L[2]=_ STK[0]=sp + #16
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=R8 L[1]=_
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {fp=Oop [16]=Oop off=2124/0x84c}
84c     #@ShouldNotReachHere

858     B93: #	out( N1 ) &lt;- in( B22 B21 )  Freq: 1.92907e-06
858 +   li R11, #-138	# int, #@loadConI
85c     spill [sp, #8] -&gt; R8	# spill size = 64
860     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUTF @ bci:95 (line 616) L[0]=_ L[1]=sp + #16 L[2]=R8 L[3]=sp + #24 L[4]=_ L[5]=_ L[6]=_ L[7]=#0 L[8]=#0 STK[0]=#0 STK[1]=sp + #16
        # OopMap {fp=Oop [24]=Oop off=2148/0x864}
864     #@ShouldNotReachHere

870     B94: #	out( N1 ) &lt;- in( B25 )  Freq: 9.51894e-07
870     #@ShouldNotReachHere

87c     B95: #	out( N1 ) &lt;- in( B26 )  Freq: 9.51893e-07
87c     #@ShouldNotReachHere

888     B96: #	out( N1 ) &lt;- in( B35 )  Freq: 4.81868e-07
888     #@ShouldNotReachHere

894     B97: #	out( N1 ) &lt;- in( B11 )  Freq: 4.76814e-07
894 +   li R11, #-187	# int, #@loadConI
898     spill R10 -&gt; [sp, #12]	# spill size = 32
89c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:19 (line 345) L[0]=_ L[1]=sp + #8 L[2]=sp + #12 STK[0]=R8
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=sp + #0 L[1]=_
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {[0]=Oop off=2208/0x8a0}
8a0     #@ShouldNotReachHere

8ac     B98: #	out( N1 ) &lt;- in( B39 )  Freq: 4.76427e-07
8ac +   li R11, #-187	# int, #@loadConI
8b0     spill R16 -&gt; R8	# spill size = 64
8b4 +   spill R14 -&gt; [sp, #0]	# spill size = 64
8b8 +   spill R7 -&gt; [sp, #16]	# spill size = 32
8bc +   spill R7 -&gt; [sp, #20]	# spill size = 32
8c0 +   spill R29 -&gt; [sp, #24]	# spill size = 32
8c4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.io.DataInputStream::readUTF @ bci:137 (line 623) L[0]=_ L[1]=sp + #24 L[2]=R8 L[3]=sp + #0 L[4]=_ L[5]=_ L[6]=_ L[7]=sp + #16 L[8]=sp + #20 STK[0]=sp + #16 STK[1]=sp + #24
        # OopMap {fp=Oop [0]=Oop off=2248/0x8c8}
8c8     #@ShouldNotReachHere

8d4     B99: #	out( B73 ) &lt;- in( B23 )  Freq: 4.53899e-07
8d4 +   li R12, #0	# int, #@loadConI
8d8     spill [sp, #24] -&gt; R14	# spill size = 64
8dc +   j  B73	#@branch

8e0     B100: #	out( N1 ) &lt;- in( B48 )  Freq: 4.49595e-07
8e0 +   li R11, #-187	# int, #@loadConI
8e4     spill R10 -&gt; [sp, #12]	# spill size = 32
8e8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.StringUTF16::compress @ bci:13 (line 162) L[0]=_ L[1]=_ L[2]=_ L[3]=R8 STK[0]=sp + #12 STK[1]=sp + #8
        # java.lang.String::&lt;init&gt; @ bci:36 (line 4494) L[0]=sp + #16 L[1]=sp + #0 L[2]=#0 L[3]=sp + #8 L[4]=_ L[5]=_
        # java.lang.String::&lt;init&gt; @ bci:10 (line 300) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.io.DataInputStream::readUTF @ bci:497 (line 666) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ STK[0]=sp + #16
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=2284/0x8ec}
8ec     #@ShouldNotReachHere

8f8     B101: #	out( B51 ) &lt;- in( B62 )  Freq: 4.49583e-07
8f8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8f8     spill R23 -&gt; R11	# spill size = 64
8fc +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
92c +   j  B51	#@branch

930     B102: #	out( B57 ) &lt;- in( B81 )  Freq: 4.99547e-08
930 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
930     spill R23 -&gt; R11	# spill size = 64
934 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
964 +   j  B57	#@branch

968     B103: #	out( N1 ) &lt;- in( B1 )  Freq: 1.01328e-06
968 +   li R11, #-10	# int, #@loadConI
96c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ STK[0]=#NULL
        # OopMap {off=2416/0x970}
970     #@ShouldNotReachHere

97c     B104: #	out( N1 ) &lt;- in( B3 )  Freq: 1.01328e-06
97c +   li R11, #-10	# int, #@loadConI
980     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=_ L[1]=_ STK[0]=#NULL
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {off=2436/0x984}
984     #@ShouldNotReachHere

990     B105: #	out( N1 ) &lt;- in( B5 )  Freq: 1.01327e-06
990 +   li R11, #-10	# int, #@loadConI
994     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:4 (line 343) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=_ L[1]=_
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {off=2456/0x998}
998     #@ShouldNotReachHere

9a4     B106: #	out( N1 ) &lt;- in( B8 )  Freq: 1.01325e-06
9a4 +   li R11, #-10	# int, #@loadConI
9a8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.io.DataInputStream::readUnsignedShort @ bci:12 (line 344) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # jdk.internal.module.ModuleInfo$CountingDataInput::readUnsignedShort @ bci:4 (line 1156) L[0]=_ L[1]=_
        # java.io.DataInputStream::readUTF @ bci:1 (line 595) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_
        # OopMap {off=2476/0x9ac}
9ac     #@ShouldNotReachHere

9b8     B107: #	out( B112 ) &lt;- in( B87 )  Freq: 9.08467e-10
9b8      -- 	// exception oop; no code emitted, #@CreateException
9b8 +   j  B112	#@branch

9bc     B108: #	out( B118 ) &lt;- in( B78 )  Freq: 9.99305e-10
9bc      -- 	// exception oop; no code emitted, #@CreateException
9bc +   spill R10 -&gt; R11	# spill size = 64
9c0 +   j  B118	#@branch

9c4     B109: #	out( B118 ) &lt;- in( B74 )  Freq: 1.01025e-09
9c4      -- 	// exception oop; no code emitted, #@CreateException
9c4 +   spill R10 -&gt; R11	# spill size = 64
9c8 +   j  B118	#@branch

9cc     B110: #	out( B118 ) &lt;- in( B76 )  Freq: 1.01025e-09
9cc      -- 	// exception oop; no code emitted, #@CreateException
9cc +   spill R10 -&gt; R11	# spill size = 64
9d0 +   j  B118	#@branch

9d4     B111: #	out( B112 ) &lt;- in( B47 )  Freq: 8.99207e-06
9d4      -- 	// exception oop; no code emitted, #@CreateException

9d4     B112: #	out( B118 ) &lt;- in( B107 B111 )  Freq: 8.99298e-06
9d4 +   spill R10 -&gt; R11	# spill size = 64
9d8 +   j  B118	#@branch

9dc     B113: #	out( B115 ) &lt;- in( B7 )  Freq: 9.99994e-06
9dc      -- 	// exception oop; no code emitted, #@CreateException
9dc +   j  B115	#@branch

9e0     B114: #	out( B115 ) &lt;- in( B10 )  Freq: 9.99972e-06
9e0      -- 	// exception oop; no code emitted, #@CreateException

9e0     B115: #	out( B118 ) &lt;- in( B113 B114 )  Freq: 1.99997e-05
9e0 +   spill R10 -&gt; R11	# spill size = 64
9e4 +   j  B118	#@branch

9e8     B116: #	out( B118 ) &lt;- in( B19 )  Freq: 9.99951e-06
9e8      -- 	// exception oop; no code emitted, #@CreateException
9e8 +   spill R10 -&gt; R11	# spill size = 64
9ec +   j  B118	#@branch

9f0     B117: #	out( B118 ) &lt;- in( B42 )  Freq: 9.99139e-06
9f0      -- 	// exception oop; no code emitted, #@CreateException
9f0 +   spill R10 -&gt; R11	# spill size = 64

9f4     B118: #	out( N1 ) &lt;- in( B115 B109 B110 B116 B108 B117 B112 )  Freq: 4.89866e-05
9f4     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
a00 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='512'>
----------------------- MetaData before Compile_id = 512 ------------------------
{method}
 - this oop:          0x00000040961efd58
 - method holder:     &apos;java/util/HashMap$HashIterator&apos;
 - constants:         0x00000040961ef810 constant pool [90] {0x00000040961ef810} for &apos;java/util/HashMap$HashIterator&apos; cache=0x00000040961f0040
 - access:            0x81000011  public final 
 - name:              &apos;hasNext&apos;
 - signature:         &apos;()Z&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c56b100
 - code size:         13
 - code start:        0x00000040961efd38
 - code end (excl):   0x00000040961efd45
 - method data:       0x00000040964a2db8
 - checked ex length: 0
 - linenumber start:  0x00000040961efd45
 - localvar length:   1
 - localvar start:    0x00000040961efd4a
 - compiled code: nmethod  21605  290       3       java.util.HashMap$HashIterator::hasNext (13 bytes)

------------------------ OptoAssembly for Compile_id = 512 -----------------------
#
#  bool ( java/util/HashMap$HashIterator:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/HashMap$HashIterator:NotNull *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N17: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N17 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     lwu  R28, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$HashIterator.next
040 +   decode_heap_oop  R7, R28	#@decodeHeapOop
044 +   snez  R10, R7	#@convP2Bool
048     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
060 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='516'>
----------------------- MetaData before Compile_id = 516 ------------------------
{method}
 - this oop:          0x0000004096041f28
 - method holder:     &apos;java/lang/ref/Reference&apos;
 - constants:         0x00000040960410d0 constant pool [195] {0x00000040960410d0} for &apos;java/lang/ref/Reference&apos; cache=0x000000409613f5d0
 - access:            0x81000011  public final 
 - name:              &apos;refersTo&apos;
 - signature:         &apos;(Ljava/lang/Object;)Z&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824bb30: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c4fa380
 - code size:         6
 - code start:        0x0000004096041f00
 - code end (excl):   0x0000004096041f06
 - method data:       0x0000004096481ba8
 - checked ex length: 0
 - linenumber start:  0x0000004096041f06
 - localvar length:   2
 - localvar start:    0x0000004096041f0c
 - compiled code: nmethod  21802  148       3       java.lang.ref.Reference::refersTo (6 bytes)

------------------------ OptoAssembly for Compile_id = 516 -----------------------
#
#  bool ( java/lang/ref/Reference:NotNull *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/ref/Reference:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N76: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B5 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
03c     lwu  R28, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
040 +   mv  R7, narrowklass: precise klass java/lang/ThreadLocal$ThreadLocalMap$Entry: 0x00000040d089d540:Constant:exact *	# compressed klass ptr, #@loadConNKlass
050 +   li R10, #1	# int, #@loadConI
054 +   bne  R28, R7, B5	#@cmpN_branch  P=0.000391 C=-1.000000

058     B2: #	out( B4 B3 ) &lt;- in( B1 )  Freq: 0.999609
058 +   # checkcastPP of R11, #@checkCastPP
058     lwu  R28, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
05c +   decode_heap_oop  R7, R28	#@decodeHeapOop
060     
060 +   beq  R7, R12, B4	#@cmpP_branch  P=0.500000 C=-1.000000

064     B3: #	out( B4 ) &lt;- in( B2 )  Freq: 0.499805
064 +   li R10, #0	# int, #@loadConI

068     B4: #	out( N76 ) &lt;- in( B2 B3 B6 B7 )  Freq: 1
068     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
080 +   ret	// return register, #@Ret

084     B5: #	out( B8 B6 ) &lt;- in( B1 )  Freq: 0.000390708
084 +   mv  R7, narrowklass: precise klass java/util/WeakHashMap$Entry: 0x00000040d089de10:Constant:exact *	# compressed klass ptr, #@loadConNKlass
094 +   bne  R28, R7, B8	#@cmpN_branch  P=0.000001 C=-1.000000

098     B6: #	out( B4 B7 ) &lt;- in( B5 )  Freq: 0.000390708
098 +   # checkcastPP of R11, #@checkCastPP
098     lwu  R28, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
09c +   decode_heap_oop  R7, R28	#@decodeHeapOop
0a0     
0a0 +   beq  R7, R12, B4	#@cmpP_branch  P=0.500000 C=-1.000000

0a4     B7: #	out( B4 ) &lt;- in( B6 )  Freq: 0.000195354
0a4 +   li R10, #0	# int, #@loadConI
0a8 +   j  B4	#@branch

0ac     B8: #	out( N76 ) &lt;- in( B5 )  Freq: 3.90708e-10
0ac +   spill R11 -&gt; R8	# spill size = 64
0b0 +   spill R12 -&gt; [sp, #0]	# spill size = 64
0b4 +   li R11, #-58	# int, #@loadConI
0b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;bimorphic&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.ref.Reference::refersTo @ bci:2 (line 366) L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop off=188/0xbc}
0bc     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='517'>
----------------------- MetaData before Compile_id = 517 ------------------------
{method}
 - this oop:          0x0000004096041fe8
 - method holder:     &apos;java/lang/ref/Reference&apos;
 - constants:         0x00000040960410d0 constant pool [195] {0x00000040960410d0} for &apos;java/lang/ref/Reference&apos; cache=0x000000409613f5d0
 - access:            0x81000000  
 - name:              &apos;refersToImpl&apos;
 - signature:         &apos;(Ljava/lang/Object;)Z&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      8
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824bb30: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c4fa880
 - code size:         6
 - code start:        0x0000004096041fc0
 - code end (excl):   0x0000004096041fc6
 - method data:       0x0000004096481d60
 - checked ex length: 0
 - linenumber start:  0x0000004096041fc6
 - localvar length:   2
 - localvar start:    0x0000004096041fcc
 - compiled code: nmethod  21811  149       3       java.lang.ref.Reference::refersToImpl (6 bytes)

------------------------ OptoAssembly for Compile_id = 517 -----------------------
#
#  bool ( java/lang/ref/Reference:NotNull *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/ref/Reference:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N31: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B4 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     lwu  R28, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/ref/Reference.referent
040 +   decode_heap_oop  R7, R28	#@decodeHeapOop
044     
044 +   bne  R7, R12, B4	#@cmpP_branch  P=0.500000 C=-1.000000

048     B2: #	out( B3 ) &lt;- in( B1 )  Freq: 0.5
048 +   li R10, #1	# int, #@loadConI

04c     B3: #	out( N31 ) &lt;- in( B2 B4 )  Freq: 1
04c     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

068     B4: #	out( B3 ) &lt;- in( B1 )  Freq: 0.5
068 +   li R10, #0	# int, #@loadConI
06c +   j  B3	#@branch

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='518'>
----------------------- MetaData before Compile_id = 518 ------------------------
{method}
 - this oop:          0x000000409602bb68
 - method holder:     &apos;java/lang/System&apos;
 - constants:         0x0000004096028fd8 constant pool [803]/operands[14] {0x0000004096028fd8} for &apos;java/lang/System&apos; cache=0x000000409614bb90
 - access:            0x81000009  public static 
 - name:              &apos;getSecurityManager&apos;
 - signature:         &apos;()Ljava/lang/SecurityManager;&apos;
 - max stack:         2
 - max locals:        0
 - size of params:    0
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b3f0: 0x i2c: 0x00000040139d1a40 c2i: 0x00000040139d1a80 c2iUV: 0x00000040139d1a4c
 - compiled entry     0x000000400c4f2100
 - code size:         12
 - code start:        0x000000409602bb48
 - code end (excl):   0x000000409602bb54
 - method data:       0x000000409658e908
 - checked ex length: 0
 - linenumber start:  0x000000409602bb54
 - localvar length:   0
 - compiled code: nmethod  21828  124       3       java.lang.System::getSecurityManager (12 bytes)

------------------------ OptoAssembly for Compile_id = 518 -----------------------
#
#  java/lang/SecurityManager * (  )
#
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N1: #	out( B1 ) &lt;- in( B3 B2 )  Freq: 1

000     B1: #	out( B3 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
01c     mv  R7, java/lang/Class:exact *	# ptr, #@loadConP
034 +   lw  R29, [R7, #156]	# int, #@loadI ! Field: java/lang/System.allowSecurityManager (constant)
038 +   li R28, #1	# int, #@loadConI
03c +   beq  R29, R28, B3	#@cmpI_branch  P=0.000000 C=10396.000000

040     B2: #	out( N1 ) &lt;- in( B1 )  Freq: 1
040 +   lwu  R28, [R7, #124]	# loadN, compressed ptr, #@loadN ! Field: volatile java/lang/System.security
044 +   #@membar_acquire
	fence ir iorw
048 +   decode_heap_oop  R10, R28	#@decodeHeapOop
04c     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

068     B3: #	out( N1 ) &lt;- in( B1 )  Freq: 4.76837e-07
068 +   li R11, #-187	# int, #@loadConI
06c     spill R29 -&gt; R8	# spill size = 32
070     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.System::allowSecurityManager @ bci:4 (line 193) STK[0]=R8 STK[1]=#1
        # java.lang.System::getSecurityManager @ bci:0 (line 483)
        # OopMap {off=116/0x74}
074 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>
<writer thread='3869227'/>
<dependency_failed type='unique_concrete_method_4' ctxk='java/util/function/Predicate' x='java.nio.file.Files$$Lambda$6/0x00000008000180e8 test (Ljava/lang/Object;)Z' x2='java/util/function/Predicate' x3='java.util.function.Predicate test (Ljava/lang/Object;)Z' witness='java/util/function/Predicate' stamp='22.209'/>
<dependency_failed type='unique_implementor' ctxk='java/util/function/Predicate' x='java/nio/file/Files$$Lambda$6+0x00000008000180e8' witness='java/util/function/Predicate' stamp='22.209'/>
<writer thread='3869246'/>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='555'>
----------------------- MetaData before Compile_id = 555 ------------------------
{method}
 - this oop:          0x00000040965e6108
 - method holder:     &apos;java/util/stream/ReferencePipeline$2$1&apos;
 - constants:         0x00000040965e5c18 constant pool [69] {0x00000040965e5c18} for &apos;java/util/stream/ReferencePipeline$2$1&apos; cache=0x00000040965e61d8
 - access:            0x81000001  public 
 - name:              &apos;accept&apos;
 - signature:         &apos;(Ljava/lang/Object;)V&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     4
 - vtable index:      7
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824bb30: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x00000040139d7c88
 - code size:         27
 - code start:        0x00000040965e60c8
 - code end (excl):   0x00000040965e60e3
 - method data:       0x0000004096492570
 - checked ex length: 0
 - linenumber start:  0x00000040965e60e3
 - localvar length:   2
 - localvar start:    0x00000040965e60ec

------------------------ OptoAssembly for Compile_id = 555 -----------------------
#
#  void ( java/util/stream/ReferencePipeline$2$1:NotNull *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/stream/ReferencePipeline$2$1:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 96 --
#r263 sp+92: in_preserve
#r262 sp+88: return address
#r261 sp+84: in_preserve
#r260 sp+80: saved fp register
#r259 sp+76: pad2, stack alignment
#r258 sp+72: pad2, stack alignment
#r257 sp+68: Fixed slot 1
#r256 sp+64: Fixed slot 0
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N832: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B66 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=96
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #96
	
03c     lwu  R7, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$2$1.this$1
040 +   spill R12 -&gt; [sp, #8]	# spill size = 64
044 +   spill R11 -&gt; [sp, #0]	# spill size = 64
048 +   decode_heap_oop  R7, R7	#@decodeHeapOop
04c     lwu  R28, [R7, #52]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$2.val$predicate
050     NullCheck R7

050     B2: #	out( B67 B3 ) &lt;- in( B1 )  Freq: 0.999999
050 +   decode_heap_oop  R11, R28	#@decodeHeapOop
054     lwu  R7, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
058     NullCheck R11

058     B3: #	out( B45 B4 ) &lt;- in( B2 )  Freq: 0.999998
058 +   mv  R29, narrowklass: precise klass java/nio/file/Files$$Lambda$6+0x00000008000180e8: 0x00000040d09bca40:Constant:exact *	# compressed klass ptr, #@loadConNKlass
068 +   bne  R7, R29, B45	#@cmpN_branch  P=0.024948 C=-1.000000

06c     B4: #	out( B68 B5 ) &lt;- in( B3 )  Freq: 0.97505
06c +   # checkcastPP of R11, #@checkCastPP
06c     lwu  R7, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/Files$$Lambda$6+0x00000008000180e8.arg$1 (constant)
070 +   decode_heap_oop  R30, R7	#@decodeHeapOop
074     lwu  R28, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
078     NullCheck R12

078     B5: #	out( B63 B6 ) &lt;- in( B4 )  Freq: 0.975049
078 +   mv  R7, narrowklass: precise klass java/nio/file/FileTreeWalker$Event: 0x00000040d09c1cd0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
088 +   bne  R28, R7, B63	#@cmpN_branch  P=0.000000 C=-1.000000

08c     B6: #	out( B69 B7 ) &lt;- in( B5 )  Freq: 0.975049
08c +   spill R12 -&gt; R7	# spill size = 64
090 +   # checkcastPP of R7, #@checkCastPP
090     lwu  R29, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.file
094 +   lwu  R7, [R7, #20]	# loadN, compressed ptr, #@loadN ! Field: java/nio/file/FileTreeWalker$Event.attrs
098 +   decode_heap_oop  R31, R29	#@decodeHeapOop
09c +   decode_heap_oop  R29, R7	#@decodeHeapOop
0a0     lwu  R28, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0a4     NullCheck R30

0a4     B7: #	out( B52 B8 ) &lt;- in( B6 )  Freq: 0.975048
0a4 +   mv  R7, narrowklass: precise klass jdk/internal/module/ModulePath$$Lambda$4+0x000000080003fd28: 0x00000040d095e9d0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0b4 +   bne  R28, R7, B52	#@cmpN_branch  P=0.000001 C=-1.000000

0b8     B8: #	out( B70 B9 ) &lt;- in( B7 )  Freq: 0.975047
0b8 +   # checkcastPP of R30, #@checkCastPP
0b8     lwu  R28, [R30, #12]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/module/ModulePath$$Lambda$4+0x000000080003fd28.arg$1 (constant)
0bc +   decode_heap_oop  R28, R28	#@decodeHeapOop
0c0     lwu  R7, [R31, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0c4     NullCheck R31

0c4     B9: #	out( B64 B10 ) &lt;- in( B8 )  Freq: 0.975046
0c4 +   mv  R30, narrowklass: precise klass sun/nio/fs/UnixPath: 0x00000040d0962730:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0d4 +   bne  R7, R30, B64	#@cmpN_branch  P=0.000000 C=-1.000000

0d8     B10: #	out( B71 B11 ) &lt;- in( B9 )  Freq: 0.975046
0d8 +   # checkcastPP of R31, #@checkCastPP
0d8     spill R31 -&gt; [sp, #16]	# spill size = 64
0dc     lwu  R7, [R29, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0e0     NullCheck R29

0e0     B11: #	out( B65 B12 ) &lt;- in( B10 )  Freq: 0.975045
0e0 +   mv  R30, narrowklass: precise klass sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes: 0x00000040d0962800:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0f0 +   bne  R7, R30, B65	#@cmpN_branch  P=0.000000 C=-1.000000

0f4     B12: #	out( B51 B13 ) &lt;- in( B11 )  Freq: 0.975045
0f4 +   # checkcastPP of R29, #@checkCastPP
0f4     lwu  R7, [R29, #12]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileAttributes$UnixAsBasicFileAttributes.attrs
0f8 +   decode_heap_oop  R7, R7	#@decodeHeapOop
0fc +   beq   R28, zr, B51	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

100     B13: #	out( B72 B14 ) &lt;- in( B12 )  Freq: 0.975044
100     lw  R28, [R7, #12]	# int, #@loadI ! Field: sun/nio/fs/UnixFileAttributes.st_mode
104     NullCheck R7

104     B14: #	out( B44 B15 ) &lt;- in( B13 )  Freq: 0.975043
104 +   li R7, #61440	# int, #@loadConI
108 +   andr  R28, R28, R7	#@andI_reg_reg
10c +   li R7, #32768	# int, #@loadConI
110 +   bne  R28, R7, B44	#@cmpI_branch  P=0.030134 C=5376.000000

114     B15: #	out( B75 B16 ) &lt;- in( B14 )  Freq: 0.945662
114 +   lwu  R28, [R31, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
118 +   mv  R7, java/lang/Class:exact *	# ptr, #@loadConP
130 +   lw  R8, [R7, #156]	# int, #@loadI ! Field: java/lang/System.allowSecurityManager (constant)
134 +   decode_heap_oop  R28, R28	#@decodeHeapOop
138     lwu  R28, [R28, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixFileSystem.provider
13c     NullCheck R28

13c     B16: #	out( B53 B17 ) &lt;- in( B15 )  Freq: 0.945661
13c +   beq   R28, zr, B53	#@cmpP_narrowOop_imm0_branch  P=0.000001 C=-1.000000

140     B17: #	out( B57 B18 ) &lt;- in( B16 )  Freq: 0.94566
140 +   li R29, #1	# int, #@loadConI
144 +   beq  R8, R29, B57	#@cmpI_branch  P=0.000000 C=10397.000000

148     B18: #	out( B58 B19 ) &lt;- in( B17 )  Freq: 0.945659
148 +   lwu  R28, [R7, #124]	# loadN, compressed ptr, #@loadN ! Field: volatile java/lang/System.security
14c +   #@membar_acquire
	fence ir iorw
150 +   decode_heap_oop  R8, R28	#@decodeHeapOop
154 +   bne   R8, zr, B58	#@cmpP_imm0_branch  P=0.000000 C=10136.000000

158     B19: #	out( B82 B20 ) &lt;- in( B18 )  Freq: 0.945659
158 +   spill R31 -&gt; R11	# spill size = 64
15c     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect sun.nio.fs.UnixPath::initOffsets
        # sun.nio.fs.UnixPath::getFileName @ bci:1 (line 255) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=352/0x160}

160     B20: #	out( B76 B21 ) &lt;- in( B19 )  Freq: 0.94564
        # Block is sole successor of call
160 +   spill [sp, #16] -&gt; R7	# spill size = 64
164 +   lwu  R7, [R7, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
168 +   #@membar_acquire
	fence ir iorw
16c +   decode_heap_oop  R7, R7	#@decodeHeapOop
170     lwu  R7, [R7, #12]	# range, #@loadRange
174     NullCheck R7

174     B21: #	out( B59 B22 ) &lt;- in( B20 )  Freq: 0.945639
174 +   bleu  R7, zr, B59	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=5193.000000

178     B22: #	out( B60 B23 ) &lt;- in( B21 )  Freq: 0.945638
178 +   li R28, #1	# int, #@loadConI
17c +   beq  R7, R28, B60	#@cmpI_branch  P=0.000000 C=5193.000000

180     B23: #	out( B77 B24 ) &lt;- in( B22 )  Freq: 0.945638
180 +   spill [sp, #16] -&gt; R28	# spill size = 64
184 +   lwu  R29, [R28, #28]	# loadN, compressed ptr, #@loadN ! Field: volatile sun/nio/fs/UnixPath.offsets
188 +   #@membar_acquire
	fence ir iorw
18c +   decode_heap_oop  R31, R29	#@decodeHeapOop
190 +   addw  R30, R7, zr	#@convI2L_reg_reg
194 +   lwu  R28, [R28, #20]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.path
198 +   slli  R29, R30, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
19c +   addiw  R8, R7, #-1	#@addI_reg_imm
1a0     lwu  R30, [R31, #12]	# range, #@loadRange
1a4     NullCheck R31

1a4     B24: #	out( B54 B25 ) &lt;- in( B23 )  Freq: 0.945637
1a4 +   add R7, R31, R29	# ptr, #@addP_reg_reg
1a8 +   decode_heap_oop  R29, R28	#@decodeHeapOop
1ac +   bgeu  R8, R30, B54	#@cmpU_branch  P=0.000001 C=-1.000000

1b0     B25: #	out( B78 B26 ) &lt;- in( B24 )  Freq: 0.945636
1b0     lwu  R19, [R29, #12]	# range, #@loadRange
1b4     NullCheck R29

1b4     B26: #	out( B55 B27 ) &lt;- in( B25 )  Freq: 0.945635
1b4 +   lw  R8, [R7, #12]	# int, #@loadI
1b8 +   subw  R9, R19, R8	#@subI_reg_reg
1bc +   li R7, #1048576	# int, #@loadConI
1c0 +   addw  R30, R8, zr	#@convI2L_reg_reg
1c4 +   addw  R12, R9, zr	#@convI2L_reg_reg
1c8 +   bgtu  R9, R7, B55	#@cmpU_branch  P=0.000001 C=-1.000000

1cc     B27: #	out( B28 ) &lt;- in( B26 )  Freq: 0.945634
1cc +   addw  R28, R19, zr	#@convI2L_reg_reg
1d0 +   sub  R28, R28, R30	#@subL_reg_reg

1d4     B28: #	out( B56 B29 ) &lt;- in( B27 B55 )  Freq: 0.945635
1d4 +   blt  R8, zr, B56	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

1d8     B29: #	out( B49 B30 ) &lt;- in( B28 )  Freq: 0.945634
1d8 +   bgtu  R9, R7, B49	#@cmpU_branch  P=0.000001 C=-1.000000

1dc     B30: #	out( B49 B31 ) &lt;- in( B29 )  Freq: 0.945633
1dc +   addi  R7, R28, #23	#@addL_reg_imm
1e0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1e0     ld  R18, [R23, #288]	# ptr, #@loadP
1e4 +   andi  R7, R7, #-8	#@andL_reg_imm
1e8 +   ld  R28, [R23, #304]	# ptr, #@loadP
1ec +   add R7, R18, R7	# ptr, #@addP_reg_reg
1f0 +   bgeu  R7, R28, B49	#@cmpP_branch  P=0.000100 C=-1.000000

1f4     B31: #	out( B32 ) &lt;- in( B30 )  Freq: 0.945539
1f4 +   sd  R7, [R23, #288]	# ptr, #@storeP
1f8 +   li R7, #1	# long, #@loadConL
1fc +   sd  R7, [R18]	# long, #@storeL
200 +   mv  R7, narrowklass: precise klass [B: 0x00000040d001b710:Constant:exact *	# compressed klass ptr, #@loadConNKlass
210 +   sw  R7, [R18, #8]	# compressed klass ptr, #@storeNKlass
214 +   sw  R9, [R18, #12]	# int, #@storeI

218     B32: #	out( B34 B33 ) &lt;- in( B50 B31 )  Freq: 0.945634
218     
218 +   # checkcastPP of R18, #@checkCastPP
218     addi  R20, R18, #16	# ptr, #@addP_reg_imm
21c +   beq  R19, R8, B34	#@cmpI_branch  P=0.000001 C=-1.000000

220     B33: #	out( B34 ) &lt;- in( B32 )  Freq: 0.945633
220 +   add R7, R29, R30	# ptr, #@addP_reg_reg
224     spill R20 -&gt; R11	# spill size = 64
228 +   addi  R10, R7, #16	# ptr, #@addP_reg_imm
22c +   CALL, runtime leaf nofp 0x000000401396cdf0	#@CallLeafNoFPDirect jbyte_arraycopy
        No JVM State Info
        # 

230     B34: #	out( B61 B35 ) &lt;- in( B33 B32 )  Freq: 0.945634
230     
230     beq  R19, R8, B61	#@cmpI_branch  P=0.000000 C=14917.000000

234     B35: #	out( B62 B36 ) &lt;- in( B34 )  Freq: 0.945634
234 +   lb  R8, [R20]	# byte, #@loadB
238 +   li R7, #46	# int, #@loadConI
23c +   beq  R8, R7, B62	#@cmpI_branch  P=0.000000 C=5193.000000

240     B36: #	out( B37 ) &lt;- in( B35 B83 )  Freq: 0.945642
240 +   li R28, #1	# int, #@loadConI

244     B37: #	out( B43 B38 ) &lt;- in( B44 B36 B46 )  Freq: 0.999971
244 +   beq  R28, zr, B43	#@cmpI_reg_imm0_branch  P=0.038685 C=5506.000000

248     B38: #	out( B73 B39 ) &lt;- in( B37 )  Freq: 0.961287
248 +   spill [sp, #0] -&gt; R7	# spill size = 64
24c +   lwu  R7, [R7, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/Sink$ChainedReference.downstream
250 +   decode_heap_oop  R11, R7	#@decodeHeapOop
254     lwu  R28, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
258     NullCheck R11

258     B39: #	out( B47 B40 ) &lt;- in( B38 )  Freq: 0.961286
258 +   mv  R7, narrowklass: precise klass java/util/stream/ReferencePipeline$3$1: 0x00000040d09bcbe0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
268 +   bne  R28, R7, B47	#@cmpN_branch  P=0.004161 C=-1.000000

26c     B40: #	out( B74 B41 ) &lt;- in( B39 )  Freq: 0.957286
26c +   # checkcastPP of R11, #@checkCastPP
26c     lwu  R28, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$3$1.this$1
270 +   decode_heap_oop  R7, R28	#@decodeHeapOop
274     lwu  R7, [R7, #52]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/ReferencePipeline$3.val$mapper
278     NullCheck R7

278     B41: #	out( B85 B42 ) &lt;- in( B40 )  Freq: 0.957285
278 +   lwu  R29, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/stream/Sink$ChainedReference.downstream
27c +   decode_heap_oop  R11, R7	#@decodeHeapOop
280 +   decode_heap_oop  R8, R29	#@decodeHeapOop
284     spill [sp, #8] -&gt; R12	# spill size = 64
288     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.function.Function::apply
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:12 (line 197) L[0]=_ L[1]=_ STK[0]=R8
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:21 (line 179) L[0]=_ L[1]=_
        # OopMap {fp=Oop off=676/0x2a4}

2a4     B42: #	out( B86 B43 ) &lt;- in( B41 )  Freq: 0.957266
        # Block is sole successor of call
2a4 +   spill R8 -&gt; R11	# spill size = 64
2a8 +   spill R10 -&gt; R12	# spill size = 64
2ac     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.stream.Sink::accept
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:17 (line 197) L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:21 (line 179) L[0]=_ L[1]=_
        # OopMap {off=712/0x2c8}

2c8     B43: #	out( N832 ) &lt;- in( B42 B48 B37 )  Freq: 0.99993
2c8     # pop frame 96
	add  sp, sp, #96
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
2e0 +   ret	// return register, #@Ret

2e4     B44: #	out( B37 ) &lt;- in( B14 )  Freq: 0.0293819
2e4 +   li R28, #0	# int, #@loadConI
2e8 +   j  B37	#@branch

2ec     B45: #	out( B81 B46 ) &lt;- in( B3 )  Freq: 0.0249476
2ec     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.function.Predicate::test
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop off=776/0x308}

308     B46: #	out( B37 ) &lt;- in( B45 )  Freq: 0.0249471
        # Block is sole successor of call
308 +   spill R10 -&gt; R28	# spill size = 32
30c +   j  B37	#@branch

310     B47: #	out( B80 B48 ) &lt;- in( B39 )  Freq: 0.0039998
310 +   spill [sp, #8] -&gt; R12	# spill size = 64
314     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.stream.Sink::accept
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:21 (line 179) L[0]=_ L[1]=_
        # OopMap {off=816/0x330}

330     B48: #	out( B43 ) &lt;- in( B47 )  Freq: 0.00399972
        # Block is sole successor of call
330 +   j  B43	#@branch

334     B49: #	out( B79 B50 ) &lt;- in( B29 B30 )  Freq: 9.55372e-05
334 +   spill R12 -&gt; [sp, #32]	# spill size = 64
338 +   spill R30 -&gt; [sp, #48]	# spill size = 64
33c +   spill R29 -&gt; [sp, #40]	# spill size = 64
340 +   spill R9 -&gt; [sp, #28]	# spill size = 32
344 +   spill R19 -&gt; [sp, #24]	# spill size = 32
348 +   mv  R11, precise klass [B: 0x00000040d001b710:Constant:exact *	# ptr, #@loadConP
360     spill R9 -&gt; R12	# spill size = 32
364     CALL,static 0x000000401390d340	#@CallStaticJavaDirect wrapper for: _new_array_nozero_Java
        # sun.nio.fs.UnixPath::getFileName @ bci:60 (line 269) L[0]=sp + #16 L[1]=_ L[2]=R8 L[3]=sp + #28 L[4]=_
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [40]=Oop off=872/0x368}

368     B50: #	out( B32 ) &lt;- in( B49 )  Freq: 9.55353e-05
        # Block is sole successor of call
368 +   spill [sp, #24] -&gt; R19	# spill size = 32
36c +   spill [sp, #28] -&gt; R9	# spill size = 32
370 +   spill [sp, #32] -&gt; R12	# spill size = 64
374 +   spill R10 -&gt; R18	# spill size = 64
378 +   spill [sp, #40] -&gt; R29	# spill size = 64
37c +   spill [sp, #48] -&gt; R30	# spill size = 64
380 +   j  B32	#@branch

384     B51: #	out( N832 ) &lt;- in( B12 )  Freq: 9.87993e-07
384 +   li R11, #-10	# int, #@loadConI
388     spill R31 -&gt; R8	# spill size = 64
38c +   spill R29 -&gt; [sp, #0]	# spill size = 64
390     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL STK[1]=R8 STK[2]=sp + #0
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=916/0x394}
394     #@ShouldNotReachHere

3a0     B52: #	out( N832 ) &lt;- in( B7 )  Freq: 9.75048e-07
3a0 +   spill [sp, #0] -&gt; R8	# spill size = 64
3a4 +   li R11, #-34	# int, #@loadConI
3a8     spill R12 -&gt; [sp, #0]	# spill size = 64
3ac +   spill R30 -&gt; [sp, #8]	# spill size = 64
3b0 +   spill R31 -&gt; [sp, #16]	# spill size = 64
3b4 +   spill R29 -&gt; [sp, #24]	# spill size = 64
3b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_ STK[0]=sp + #8 STK[1]=sp + #16 STK[2]=sp + #24
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=956/0x3bc}
3bc     #@ShouldNotReachHere

3c8     B53: #	out( N832 ) &lt;- in( B16 )  Freq: 9.58218e-07
3c8 +   spill [sp, #0] -&gt; R8	# spill size = 64
3cc +   li R11, #-10	# int, #@loadConI
3d0     spill R12 -&gt; [sp, #0]	# spill size = 64
3d4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_ STK[0]=#NULL STK[1]=sp + #16
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=984/0x3d8}
3d8     #@ShouldNotReachHere

3e4     B54: #	out( N832 ) &lt;- in( B24 )  Freq: 9.58194e-07
3e4 +   li R11, #-28	# int, #@loadConI
3e8     spill R31 -&gt; [sp, #24]	# spill size = 64
3ec     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:49 (line 267) L[0]=sp + #16 L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #24 STK[1]=R8
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop off=1008/0x3f0}
3f0     #@ShouldNotReachHere

3fc     B55: #	out( B28 ) &lt;- in( B26 )  Freq: 9.58192e-07
3fc +   spill R12 -&gt; R28	# spill size = 64
400 +   j  B28	#@branch

404     B56: #	out( N832 ) &lt;- in( B28 )  Freq: 9.45635e-07
404 +   li R11, #-52	# int, #@loadConI
408     spill R9 -&gt; [sp, #28]	# spill size = 32
40c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;intrinsic&apos; action=&apos;make_not_entrant&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:60 (line 269) L[0]=sp + #16 L[1]=_ L[2]=R8 L[3]=sp + #28 L[4]=_ STK[0]=sp + #28
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=1040/0x410}
410     #@ShouldNotReachHere

41c     B57: #	out( N832 ) &lt;- in( B17 )  Freq: 4.50926e-07
41c +   li R11, #-187	# int, #@loadConI
420     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.System::allowSecurityManager @ bci:4 (line 193) STK[0]=R8 STK[1]=#1
        # java.lang.System::getSecurityManager @ bci:0 (line 483)
        # sun.nio.fs.UnixPath::checkRead @ bci:0 (line 778) L[0]=sp + #16 L[1]=_
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:6 (line 352) L[0]=_ L[1]=_ L[2]=sp + #16 L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=1060/0x424}
424     #@ShouldNotReachHere

430     B58: #	out( N832 ) &lt;- in( B18 )  Freq: 4.50925e-07
430 +   li R11, #-187	# int, #@loadConI
434     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::checkRead @ bci:5 (line 779) L[0]=sp + #16 L[1]=R8 STK[0]=R8
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:6 (line 352) L[0]=_ L[1]=_ L[2]=sp + #16 L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=1080/0x438}
438     #@ShouldNotReachHere

444     B59: #	out( N832 ) &lt;- in( B21 )  Freq: 4.50916e-07
444 +   spill [sp, #0] -&gt; R8	# spill size = 64
448 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
450 +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
458 +   li R11, #-187	# int, #@loadConI
45c     spill R7 -&gt; [sp, #20]	# spill size = 32
460     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:11 (line 260) L[0]=sp + #8 L[1]=sp + #20 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #20
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=1124/0x464}
464     #@ShouldNotReachHere

470     B60: #	out( N832 ) &lt;- in( B22 )  Freq: 4.50916e-07
470 +   spill [sp, #0] -&gt; R8	# spill size = 64
474 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
47c +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
484 +   li R11, #-187	# int, #@loadConI
488     spill R7 -&gt; [sp, #20]	# spill size = 32
48c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:18 (line 264) L[0]=sp + #8 L[1]=sp + #20 L[2]=_ L[3]=_ L[4]=_ STK[0]=sp + #20 STK[1]=#1
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=1168/0x490}
490     #@ShouldNotReachHere

49c     B61: #	out( N832 ) &lt;- in( B34 )  Freq: 4.50913e-07
49c +   spill [sp, #16] -&gt; R7	# spill size = 64
4a0 +   lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: sun/nio/fs/UnixPath.fs
4a4 +   decode_heap_oop  R8, R7	#@decodeHeapOop
4a8 +   li R11, #-187	# int, #@loadConI
4ac     spill R9 -&gt; [sp, #16]	# spill size = 32
4b0 +   spill R18 -&gt; [sp, #24]	# spill size = 64
4b4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixPath::isEmpty @ bci:5 (line 216) L[0]=_ STK[0]=sp + #16
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:21 (line 358) L[0]=_ L[1]=_ L[2]=_ L[3]=#ScObj0 L[4]=_
        # ScObj0 sun/nio/fs/UnixPath={ [hash :0]=#0, [fs :1]=R8, [path :2]=sp + #24, [stringValue :3]=#NULL, [offsets :4]=#NULL }
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop off=1208/0x4b8}
4b8     #@ShouldNotReachHere

4c4     B62: #	out( N832 ) &lt;- in( B35 )  Freq: 4.50913e-07
4c4 +   li R11, #-187	# int, #@loadConI
4c8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:51 (line 363) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=R8 STK[1]=#46
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop off=1228/0x4cc}
4cc     #@ShouldNotReachHere

4d8     B63: #	out( N832 ) &lt;- in( B5 )  Freq: 1e-35
4d8 +   li R11, #-34	# int, #@loadConI
4dc     spill [sp, #0] -&gt; R8	# spill size = 64
4e0 +   spill R30 -&gt; [sp, #16]	# spill size = 64
4e4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:5 L[0]=_ L[1]=_ STK[0]=sp + #16 STK[1]=sp + #8
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=1256/0x4e8}
4e8     #@ShouldNotReachHere

4f4     B64: #	out( N832 ) &lt;- in( B9 )  Freq: 1e-35
4f4 +   spill [sp, #0] -&gt; R8	# spill size = 64
4f8 +   li R11, #-34	# int, #@loadConI
4fc     spill R12 -&gt; [sp, #0]	# spill size = 64
500 +   spill R29 -&gt; [sp, #8]	# spill size = 64
504 +   spill R28 -&gt; [sp, #16]	# spill size = 64
508 +   spill R31 -&gt; [sp, #24]	# spill size = 64
50c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:5 L[0]=_ L[1]=_ L[2]=sp + #8 STK[0]=sp + #16 STK[1]=sp + #24
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=1296/0x510}
510     #@ShouldNotReachHere

51c     B65: #	out( N832 ) &lt;- in( B11 )  Freq: 1e-35
51c +   spill [sp, #0] -&gt; R8	# spill size = 64
520 +   li R11, #-34	# int, #@loadConI
524     spill R12 -&gt; [sp, #0]	# spill size = 64
528 +   spill R28 -&gt; [sp, #8]	# spill size = 64
52c +   spill R29 -&gt; [sp, #24]	# spill size = 64
530     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:9 L[0]=_ L[1]=_ L[2]=_ STK[0]=sp + #8 STK[1]=sp + #16 STK[2]=sp + #24
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [24]=Oop off=1332/0x534}
534     #@ShouldNotReachHere

540     B66: #	out( N832 ) &lt;- in( B1 )  Freq: 1.01328e-06
540 +   li R11, #-10	# int, #@loadConI
544     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:4 (line 178) L[0]=_ L[1]=_ STK[0]=#NULL
        # OopMap {off=1352/0x548}
548     #@ShouldNotReachHere

554     B67: #	out( N832 ) &lt;- in( B2 )  Freq: 1.01328e-06
554 +   li R11, #-10	# int, #@loadConI
558     spill R12 -&gt; R8	# spill size = 64
55c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8
        # OopMap {fp=Oop off=1376/0x560}
560     #@ShouldNotReachHere

56c     B68: #	out( N832 ) &lt;- in( B4 )  Freq: 9.87998e-07
56c +   spill [sp, #0] -&gt; R8	# spill size = 64
570 +   li R11, #-12	# int, #@loadConI
574     spill R12 -&gt; [sp, #0]	# spill size = 64
578 +   spill R30 -&gt; [sp, #8]	# spill size = 64
57c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:5 L[0]=_ L[1]=_ STK[0]=sp + #8 STK[1]=#NULL
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=1408/0x580}
580     #@ShouldNotReachHere

58c     B69: #	out( N832 ) &lt;- in( B6 )  Freq: 9.87997e-07
58c +   li R11, #-10	# int, #@loadConI
590     spill R31 -&gt; R8	# spill size = 64
594 +   spill R29 -&gt; [sp, #0]	# spill size = 64
598     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8 STK[2]=sp + #0
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=1436/0x59c}
59c     #@ShouldNotReachHere

5a8     B70: #	out( N832 ) &lt;- in( B8 )  Freq: 9.87995e-07
5a8 +   spill [sp, #0] -&gt; R8	# spill size = 64
5ac +   li R11, #-12	# int, #@loadConI
5b0     spill R12 -&gt; [sp, #0]	# spill size = 64
5b4 +   spill R29 -&gt; [sp, #8]	# spill size = 64
5b8 +   spill R28 -&gt; [sp, #16]	# spill size = 64
5bc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:5 L[0]=_ L[1]=_ L[2]=sp + #8 STK[0]=sp + #16 STK[1]=#NULL
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=1472/0x5c0}
5c0     #@ShouldNotReachHere

5cc     B71: #	out( N832 ) &lt;- in( B10 )  Freq: 9.87994e-07
5cc +   spill [sp, #0] -&gt; R8	# spill size = 64
5d0 +   li R11, #-12	# int, #@loadConI
5d4     spill R12 -&gt; [sp, #0]	# spill size = 64
5d8 +   spill R28 -&gt; [sp, #8]	# spill size = 64
5dc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:9 L[0]=_ L[1]=_ L[2]=_ STK[0]=sp + #8 STK[1]=sp + #16 STK[2]=#NULL
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #0
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=1504/0x5e0}
5e0     #@ShouldNotReachHere

5ec     B72: #	out( N832 ) &lt;- in( B13 )  Freq: 9.87992e-07
5ec +   li R11, #-10	# int, #@loadConI
5f0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes::isRegularFile @ bci:4 (line 295) L[0]=_ STK[0]=#NULL
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:1 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=_ L[1]=_
        # OopMap {off=1524/0x5f4}
5f4     #@ShouldNotReachHere

600     B73: #	out( N832 ) &lt;- in( B38 )  Freq: 9.74052e-07
600 +   li R11, #-10	# int, #@loadConI
604     spill [sp, #8] -&gt; R8	# spill size = 64
608     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:21 (line 179) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8
        # OopMap {fp=Oop off=1548/0x60c}
60c     #@ShouldNotReachHere

618     B74: #	out( N832 ) &lt;- in( B40 )  Freq: 9.69998e-07
618 +   li R11, #-10	# int, #@loadConI
61c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.stream.ReferencePipeline$3$1::accept @ bci:8 (line 197) L[0]=_ L[1]=_ STK[0]=_ STK[1]=#NULL
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:21 (line 179) L[0]=_ L[1]=_
        # OopMap {off=1568/0x620}
620     #@ShouldNotReachHere

62c     B75: #	out( N832 ) &lt;- in( B15 )  Freq: 9.58219e-07
62c +   li R11, #-10	# int, #@loadConI
630     spill [sp, #0] -&gt; R8	# spill size = 64
634     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.nio.file.Files::provider @ bci:6 (line 105) L[0]=_ STK[0]=#NULL
        # java.nio.file.Files::isHidden @ bci:1 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=1592/0x638}
638     #@ShouldNotReachHere

644     B76: #	out( N832 ) &lt;- in( B20 )  Freq: 9.58197e-07
644 +   li R11, #-10	# int, #@loadConI
648     spill [sp, #0] -&gt; R8	# spill size = 64
64c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:8 (line 257) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=1616/0x650}
650     #@ShouldNotReachHere

65c     B77: #	out( N832 ) &lt;- in( B23 )  Freq: 9.58195e-07
65c +   li R11, #-10	# int, #@loadConI
660     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:49 (line 267) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL STK[1]=R8
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=sp + #0 L[1]=sp + #8
        # OopMap {[0]=Oop [8]=Oop off=1636/0x664}
664     #@ShouldNotReachHere

670     B78: #	out( N832 ) &lt;- in( B25 )  Freq: 9.58193e-07
670 +   li R11, #-10	# int, #@loadConI
674     spill [sp, #0] -&gt; R8	# spill size = 64
678     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # sun.nio.fs.UnixPath::getFileName @ bci:55 (line 268) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ STK[0]=#NULL
        # sun.nio.fs.UnixFileSystemProvider::isHidden @ bci:10 (line 353) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_
        # java.nio.file.Files::isHidden @ bci:5 (line 1643) L[0]=_
        # jdk.internal.module.ModulePath::isHidden @ bci:1 (line 770) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath::lambda$explodedPackages$7 @ bci:11 (line 669) L[0]=_ L[1]=_ L[2]=_
        # jdk.internal.module.ModulePath$$Lambda$4/0x000000080003fd28::test @ bci:12 L[0]=_ L[1]=_ L[2]=_
        # java.nio.file.Files::lambda$find$2 @ bci:9 (line 4042) L[0]=_ L[1]=_
        # java.nio.file.Files$$Lambda$6/0x00000008000180e8::test @ bci:8 L[0]=_ L[1]=_
        # java.util.stream.ReferencePipeline$2$1::accept @ bci:8 (line 178) L[0]=R8 L[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=1660/0x67c}
67c     #@ShouldNotReachHere

688     B79: #	out( B83 ) &lt;- in( B49 )  Freq: 9.55372e-10
688      -- 	// exception oop; no code emitted, #@CreateException
688 +   lwu  R7, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
68c +   j  B83	#@branch

690     B80: #	out( B88 ) &lt;- in( B47 )  Freq: 3.9998e-08
690      -- 	// exception oop; no code emitted, #@CreateException
690 +   spill R10 -&gt; R11	# spill size = 64
694 +   j  B88	#@branch

698     B81: #	out( B88 ) &lt;- in( B45 )  Freq: 2.49476e-07
698      -- 	// exception oop; no code emitted, #@CreateException
698 +   spill R10 -&gt; R11	# spill size = 64
69c +   j  B88	#@branch

6a0     B82: #	out( B83 ) &lt;- in( B19 )  Freq: 9.45659e-06
6a0      -- 	// exception oop; no code emitted, #@CreateException
6a0 +   lwu  R7, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass

6a4     B83: #	out( B36 B84 ) &lt;- in( B82 B79 )  Freq: 9.45754e-06
6a4 +   mv  R29, narrowklass: precise klass java/io/IOException: 0x00000040d06fe250:Constant:exact *	# compressed klass ptr, #@loadConNKlass
6b4 +   beq  R7, R29, B36	#@cmpN_branch  P=0.900000 C=-1.000000

6b8     B84: #	out( B88 ) &lt;- in( B83 )  Freq: 9.45755e-07
6b8 +   spill R10 -&gt; R11	# spill size = 64
6bc +   j  B88	#@branch

6c0     B85: #	out( B87 ) &lt;- in( B41 )  Freq: 9.57285e-06
6c0      -- 	// exception oop; no code emitted, #@CreateException
6c0 +   j  B87	#@branch

6c4     B86: #	out( B87 ) &lt;- in( B42 )  Freq: 9.57266e-06
6c4      -- 	// exception oop; no code emitted, #@CreateException

6c4     B87: #	out( B88 ) &lt;- in( B85 B86 )  Freq: 1.91455e-05
6c4 +   spill R10 -&gt; R11	# spill size = 64

6c8     B88: #	out( N832 ) &lt;- in( B81 B84 B80 B87 )  Freq: 2.03807e-05
6c8     # pop frame 96
	add  sp, sp, #96
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
6d4 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>
<writer thread='3869227'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashSet' witness='java/util/LinkedHashSet' stamp='22.842'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashSet' witness='java/util/LinkedHashSet' stamp='22.842'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashSet' witness='java/util/LinkedHashSet' stamp='22.842'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashSet' witness='java/util/LinkedHashSet' stamp='22.842'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashSet' witness='java/util/LinkedHashSet' stamp='22.842'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashSet' witness='java/util/LinkedHashSet' stamp='22.842'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.853'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.853'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.853'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.853'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.853'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.853'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.853'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.853'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.854'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.854'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.854'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.854'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.854'/>
<dependency_failed type='leaf_type' ctxk='java/util/HashMap' witness='java/util/LinkedHashMap' stamp='22.854'/>
<writer thread='3869246'/>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='572'>
----------------------- MetaData before Compile_id = 572 ------------------------
{method}
 - this oop:          0x0000004096291480
 - method holder:     &apos;java/util/HashSet&apos;
 - constants:         0x00000040962901e0 constant pool [285] {0x00000040962901e0} for &apos;java/util/HashSet&apos; cache=0x0000004096291e18
 - access:            0x81000001  public 
 - name:              &apos;add&apos;
 - signature:         &apos;(Ljava/lang/Object;)Z&apos;
 - max stack:         4
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     4
 - vtable index:      5
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824bb30: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x00000040139d7c88
 - code size:         20
 - code start:        0x0000004096291448
 - code end (excl):   0x000000409629145c
 - method data:       0x000000409648dd90
 - checked ex length: 0
 - linenumber start:  0x000000409629145c
 - localvar length:   2
 - localvar start:    0x0000004096291464

------------------------ OptoAssembly for Compile_id = 572 -----------------------
#
#  bool ( java/util/HashSet:NotNull *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/HashSet:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 96 --
#r263 sp+92: in_preserve
#r262 sp+88: return address
#r261 sp+84: in_preserve
#r260 sp+80: saved fp register
#r259 sp+76: pad2, stack alignment
#r258 sp+72: pad2, stack alignment
#r257 sp+68: Fixed slot 1
#r256 sp+64: Fixed slot 0
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1592: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B127 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=96
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #96
	
03c     lwu  R28, [R11, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashSet.map
040 +   decode_heap_oop  R7, R28	#@decodeHeapOop
044     spill R7 -&gt; [sp, #0]	# spill size = 64
048     lwu  R28, [R7, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
04c     NullCheck R7

04c     B2: #	out( B128 B3 ) &lt;- in( B1 )  Freq: 0.999999
04c +   spill R28 -&gt; [sp, #8]	# spill size = 32
050     lwu  R29, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
054     NullCheck R12

054     B3: #	out( B77 B4 ) &lt;- in( B2 )  Freq: 0.999999
054 +   decode_klass_not_null  R28, R29	#@decodeKlass_not_null
060 +   ld  R28, [R28, #504]	# ptr, #@loadP
064 +   mv  R7, metadataptr:Constant0x00000040d0923b40	# ptr, #@loadConP
07c +   bne  R28, R7, B77	#@cmpP_branch  P=0.001000 C=-1.000000

080     B4: #	out( B77 B5 ) &lt;- in( B3 )  Freq: 0.998999
080 +   ld  R7, [R12]	# int, #@loadL
084 +   li R30, #1	# long, #@loadConL
088 +   andi  R28, R7, #7	#@andL_reg_imm
08c +   bne  R28, R30, B77	#@cmpL_branch  P=0.001000 C=-1.000000

090     B5: #	out( B77 B6 ) &lt;- in( B4 )  Freq: 0.998
090 +   srli  R7, R7, (#8 &amp; 0x3f)	#@urShiftL_reg_imm
094 +   li R30, #2147483647	# int, #@loadConI
09c +   addw  R7, R7, zr	#@convL2I_reg
0a0 +   andr  R10, R7, R30	#@andI_reg_reg
0a4 +   beq  R10, zr, B77	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0a8     B6: #	out( B68 B7 ) &lt;- in( B78 B5 )  Freq: 0.999998
0a8 +   spill [sp, #0] -&gt; R7	# spill size = 64
0ac +   lwu  R28, [R7, #36]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap.table
0b0 +   srliw  R7, R10, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
0b4 +   decode_heap_oop  R18, R28	#@decodeHeapOop
0b8 +   xorr  R19, R7, R10	#@xorI_reg_reg
0bc +   beq   R18, zr, B68	#@cmpP_imm0_branch  P=0.172414 C=5452.000000

0c0     B7: #	out( B108 B8 ) &lt;- in( B6 )  Freq: 0.827585
0c0 +   lwu  R7, [R18, #12]	# range, #@loadRange
0c4 +   bleu  R7, zr, B108	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=4512.000000

0c8     B8: #	out( B106 B9 ) &lt;- in( B70 B7 )  Freq: 0.999994
0c8 +   addiw  R30, R7, #-1	#@addI_reg_imm
0cc +   andr  R28, R30, R19	#@andI_reg_reg
0d0 +   addw  R30, R28, zr	#@convI2L_reg_reg
0d4 +   slli  R30, R30, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0d8 +   add R30, R18, R30	# ptr, #@addP_reg_reg
0dc +   addi  R9, R30, #16	# ptr, #@addP_reg_imm
0e0 +   ble  R7, zr, B106	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0e4     B9: #	out( B39 B10 ) &lt;- in( B8 )  Freq: 0.999993
0e4 +   lwu  R7, [R9]	# loadN, compressed ptr, #@loadN
0e8 +   decode_heap_oop  R7, R7	#@decodeHeapOop
0ec +   encode_heap_oop  R31, R12	#@encodeHeapOop
0f0 +   mv  R15, NULL	# NULL ptr, #@loadConP0
0f4 +   mv  R30, narrowklass: precise klass java/util/HashMap$Node: 0x00000040d0926d20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
104 +   beq   R7, zr, B39	#@cmpP_imm0_branch  P=0.514857 C=5452.000000

108     B10: #	out( B51 B11 ) &lt;- in( B9 )  Freq: 0.48514
108 +   lw  R13, [R7, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
10c +   mv  R11, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
11c +   li R10, #0	# int, #@loadConI
120 +   beq  R13, R19, B51	#@cmpI_branch  P=0.440832 C=2645.000000

124     B11: #	out( B110 B12 ) &lt;- in( B10 )  Freq: 0.271275
124 +   lwu  R28, [R7, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
128 +   lwu  R14, [R7, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
12c +   decode_heap_oop  R21, R28	#@decodeHeapOop
130 +   mv  R28, narrowklass: precise klass java/util/HashMap$TreeNode: 0x00000040d0928630:Constant:exact *	# compressed klass ptr, #@loadConNKlass
140 +   beq  R14, R28, B110	#@cmpN_branch  P=0.000001 C=-1.000000

144     B12: #	out( B24 B13 ) &lt;- in( B11 )  Freq: 0.271275
144 +   bne   R21, zr, B24	#@cmpP_imm0_branch  P=0.615385 C=1729.000000

148     B13: #	out( B14 ) &lt;- in( B12 )  Freq: 0.104336
148 +   li R20, #0	# int, #@loadConI
14c     spill R7 -&gt; R21	# spill size = 64

150     B14: #	out( B79 B15 ) &lt;- in( B26 B13 )  Freq: 0.121973
150 +   mv  R28, narrowklass: precise klass java/util/HashMap: 0x00000040d05281b0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
160     spill [sp, #8] -&gt; R7	# spill size = 32
164 +   bne  R7, R28, B79	#@cmpN_branch  P=0.004732 C=-1.000000

168     B15: #	out( B104 B16 ) &lt;- in( B14 )  Freq: 0.121395
168 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
168     ld  R22, [R23, #288]	# ptr, #@loadP
16c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
16c     ld  R7, [R23, #304]	# ptr, #@loadP
170 +   addi  R28, R22, #32	# ptr, #@addP_reg_imm
174 +   bgeu  R28, R7, B104	#@cmpP_branch  P=0.000100 C=-1.000000

178     B16: #	out( B17 ) &lt;- in( B15 )  Freq: 0.121383
178 +   li R7, #1	# long, #@loadConL
17c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
17c     sd  R28, [R23, #288]	# ptr, #@storeP
180 +   sd  R7, [R22]	# long, #@storeL
184 +   sw  R30, [R22, #8]	# compressed klass ptr, #@storeNKlass
188 +   sw  zr, [R22, #12]	# int, #@storeimmI0
18c +   sw  zr, [R22, #16]	# int, #@storeimmI0
190 +   sd  zr, [R22, #24]	# long, #@storeimmL0

194     B17: #	out( B18 ) &lt;- in( B105 B16 )  Freq: 0.121395
194 +   mv  R7, narrowoop: java/lang/Object:exact *	# compressed ptr, #@loadConN
1a4 +   sw  R7, [R22, #20]	# compressed ptr, #@storeN
1a8     
1a8 +   # checkcastPP of R22, #@checkCastPP
1a8     sw  R31, [R22, #16]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.key
1ac +   sw  R19, [R22, #12]	# int, #@storeI ! Field: java/util/HashMap$Node.hash
1b0 +   #@membar_release
	fence iorw ow

1b4     B18: #	out( B95 B19 ) &lt;- in( B17 B80 )  Freq: 0.121973
1b4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b4     lb  R28, [R23, #56]	# byte, #@loadB
1b8 +   bne  R28, zr, B95	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1bc     B19: #	out( B22 B20 ) &lt;- in( B124 B97 B95 B18 )  Freq: 0.121973
1bc +   mv  R28, R21	# ptr -&gt; long, #@castP2X
1c0 +   mv  R7, R22	# ptr -&gt; long, #@castP2X
1c4 +   xorr  R7, R7, R28	#@xorL_reg_reg
1c8 +   encode_heap_oop  R29, R22	#@encodeHeapOop
1cc +   srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
1d0 +   li R9, #7	# int, #@loadConI
1d4 +   sw  R29, [R21, #24]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.next
1d8 +   beq  R7, zr, B22	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1dc     B20: #	out( B22 B21 ) &lt;- in( B19 )  Freq: 0.121851
1dc +   beq   R22, zr, B22	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

1e0     B21: #	out( B98 B22 ) &lt;- in( B20 )  Freq: 0.121729
1e0 +   srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1e4 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1f0 +   add R10, R28, R7	# ptr, #@addP_reg_reg
1f4 +   lb  R28, [R10]	# byte, #@loadB
1f8 +   li R7, #4	# int, #@loadConI
1fc +   bne  R28, R7, B98	#@cmpI_branch  P=0.001000 C=-1.000000

200     B22: #	out( B48 B23 ) &lt;- in( B100 B101 B98 B21 B20 B19 )  Freq: 0.121973
200 +   blt  R20, R9, B48	#@cmpI_branch  P=1.000000 C=665.000000

204     B23: #	out( N1592 ) &lt;- in( B22 )  Freq: 5.81611e-08
204 +   spill [sp, #0] -&gt; R8	# spill size = 64
208 +   li R11, #-187	# int, #@loadConI
20c     spill R19 -&gt; [sp, #0]	# spill size = 32
210 +   spill R18 -&gt; [sp, #8]	# spill size = 64
214 +   spill R20 -&gt; [sp, #4]	# spill size = 32
218     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:162 (line 641) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=#Ptr0x00000040d052a9f0 L[4]=#0 L[5]=#1 L[6]=sp + #8 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=_ STK[0]=sp + #4 STK[1]=#7
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop off=540/0x21c}
21c     #@ShouldNotReachHere

228     B24: #	out( B25 ) &lt;- in( B12 )  Freq: 0.166938
228 +   li R20, #0	# int, #@loadConI

22c     B25: #	out( B28 B26 ) &lt;- in( B24 B27 ) Loop( B25-B27 inner ) Freq: 0.195156
22c +   lw  R28, [R21, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
230 +   beq  R28, R19, B28	#@cmpI_branch  P=0.765038 C=1064.000000

234     B26: #	out( B14 B27 ) &lt;- in( B25 )  Freq: 0.0458544
234 +   addiw  R20, R20, #1	#@addI_reg_imm
238 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
238     ld  R7, [R23, #920]	# ptr, #@loadP
23c +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.util.HashMap::putVal @ bci:219 (line 638) L[0]=sp + #0 L[1]=R19 L[2]=R12 L[3]=#Ptr0x00000040d052a9f0 L[4]=#0 L[5]=#1 L[6]=R18 L[7]=R21 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=R20
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {xmethod=NarrowOop c_rarg2=Oop x18=Oop xdispatch=Oop [0]=Oop off=572/0x23c}
240 +   lwu  R28, [R21, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
244 +   decode_heap_oop  R7, R28	#@decodeHeapOop
248 +   beq   R7, zr, B14	#@cmpP_imm0_branch  P=0.384615 C=250.000000

24c     B27: #	out( B25 ) &lt;- in( B26 )  Freq: 0.0282181
24c +   spill R7 -&gt; R21	# spill size = 64
250 +   j  B25	#@branch

254     B28: #	out( B122 B29 ) &lt;- in( B25 )  Freq: 0.149302
254 +   lwu  R7, [R21, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
258 +   decode_heap_oop  R31, R7	#@decodeHeapOop
25c +   beq  R31, R12, B122	#@cmpP_branch  P=0.000000 C=814.000000

260     B29: #	out( B117 B30 ) &lt;- in( B28 )  Freq: 0.149302
260 +   bne  R29, R11, B117	#@cmpN_branch  P=0.000001 C=-1.000000

264     B30: #	out( B62 B31 ) &lt;- in( B29 )  Freq: 0.149302
264 +   # checkcastPP of R12, #@checkCastPP
264     beq  R12, R31, B62	#@cmpP_branch  P=0.064818 C=5338.000000

268     B31: #	out( B131 B32 ) &lt;- in( B30 )  Freq: 0.139624
268     lwu  R28, [R31, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
26c     NullCheck R31

26c     B32: #	out( B125 B33 ) &lt;- in( B31 )  Freq: 0.139624
26c +   mv  R30, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
27c +   lwu  R7, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
280 +   lb  R29, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
284 +   bne  R28, R30, B125	#@cmpN_branch  P=0.000000 C=-1.000000

288     B33: #	out( B123 B34 ) &lt;- in( B32 )  Freq: 0.139624
288 +   # checkcastPP of R31, #@checkCastPP
288     lb  R8, [R31, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
28c +   lwu  R28, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
290 +   decode_heap_oop  R7, R7	#@decodeHeapOop
294 +   bne  R29, R8, B123	#@cmpI_branch  P=0.000000 C=4992.000000

298     B34: #	out( B118 B35 ) &lt;- in( B33 )  Freq: 0.139624
298 +   beq   R7, zr, B118	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

29c     B35: #	out( B119 B36 ) &lt;- in( B34 )  Freq: 0.139624
29c +   decode_heap_oop  R28, R28	#@decodeHeapOop
2a0 +   lwu  R14, [R7, #12]	# range, #@loadRange
2a4 +   beq   R28, zr, B119	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

2a8     B36: #	out( B38 B37 ) &lt;- in( B35 )  Freq: 0.139624
2a8 +   lwu  R29, [R28, #12]	# range, #@loadRange
2ac +   bne  R14, R29, B38	#@cmpI_branch  P=0.000001 C=-1.000000

2b0     B37: #	out( B62 B38 ) &lt;- in( B36 )  Freq: 0.139624
2b0 +   addi  R13, R28, #16	# ptr, #@addP_reg_imm
2b4 +   addi  R11, R7, #16	# ptr, #@addP_reg_imm
2b8     String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
348 +   bne  R10, zr, B62	#@cmpI_reg_imm0_branch  P=1.000000 C=814.000000

34c     B38: #	out( N1592 ) &lt;- in( B37 B36 )  Freq: 2.06201e-07
34c +   spill [sp, #0] -&gt; R8	# spill size = 64
350 +   li R11, #-187	# int, #@loadConI
354     spill R19 -&gt; [sp, #0]	# spill size = 32
358 +   spill R18 -&gt; [sp, #8]	# spill size = 64
35c +   spill R21 -&gt; [sp, #16]	# spill size = 64
360 +   spill R20 -&gt; [sp, #4]	# spill size = 32
364 +   spill R10 -&gt; [sp, #24]	# spill size = 32
368 +   spill R12 -&gt; [sp, #32]	# spill size = 64
36c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:206 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #32 L[3]=#Ptr0x00000040d052a9f0 L[4]=#0 L[5]=#1 L[6]=sp + #8 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #16 L[11]=_ L[12]=sp + #4 STK[0]=sp + #24
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop off=880/0x370}
370     #@ShouldNotReachHere

37c     B39: #	out( B75 B40 ) &lt;- in( B9 )  Freq: 0.514854
37c +   mv  R29, narrowklass: precise klass java/util/HashMap: 0x00000040d05281b0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
38c     spill [sp, #8] -&gt; R10	# spill size = 32
390 +   bne  R10, R29, B75	#@cmpN_branch  P=0.013084 C=-1.000000

394     B40: #	out( B102 B41 ) &lt;- in( B39 )  Freq: 0.508117
394 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
394     ld  R20, [R23, #288]	# ptr, #@loadP
398 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
398     ld  R7, [R23, #304]	# ptr, #@loadP
39c +   addi  R29, R20, #32	# ptr, #@addP_reg_imm
3a0 +   bgeu  R29, R7, B102	#@cmpP_branch  P=0.000100 C=-1.000000

3a4     B41: #	out( B42 ) &lt;- in( B40 )  Freq: 0.508066
3a4 +   li R7, #1	# long, #@loadConL
3a8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3a8     sd  R29, [R23, #288]	# ptr, #@storeP
3ac +   sd  R7, [R20]	# long, #@storeL
3b0 +   sw  R30, [R20, #8]	# compressed klass ptr, #@storeNKlass
3b4 +   sw  zr, [R20, #12]	# int, #@storeimmI0
3b8 +   sw  zr, [R20, #16]	# int, #@storeimmI0
3bc +   sd  zr, [R20, #24]	# long, #@storeimmL0

3c0     B42: #	out( B43 ) &lt;- in( B103 B41 )  Freq: 0.508117
3c0 +   mv  R7, narrowoop: java/lang/Object:exact *	# compressed ptr, #@loadConN
3d0 +   sw  R7, [R20, #20]	# compressed ptr, #@storeN
3d4     
3d4 +   # checkcastPP of R20, #@checkCastPP
3d4     sw  R31, [R20, #16]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.key
3d8 +   sw  R19, [R20, #12]	# int, #@storeI ! Field: java/util/HashMap$Node.hash
3dc +   #@membar_release
	fence iorw ow

3e0     B43: #	out( B107 B44 ) &lt;- in( B42 B76 )  Freq: 0.514853
3e0 +   lwu  R7, [R18, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
3e4 +   mv  R30, narrowklass: precise klass [Ljava/util/HashMap$Node;: 0x00000040d0926df0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
3f4 +   bne  R7, R30, B107	#@cmpN_branch  P=0.000001 C=-1.000000

3f8     B44: #	out( B81 B45 ) &lt;- in( B43 )  Freq: 0.514853
3f8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3f8     lb  R7, [R23, #56]	# byte, #@loadB
3fc +   bne  R7, zr, B81	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

400     B45: #	out( B48 B46 ) &lt;- in( B111 B83 B81 B44 )  Freq: 0.514853
400 +   mv  R28, R9	# ptr -&gt; long, #@castP2X
404 +   mv  R7, R20	# ptr -&gt; long, #@castP2X
408 +   xorr  R7, R7, R28	#@xorL_reg_reg
40c +   encode_heap_oop  R30, R20	#@encodeHeapOop
410 +   srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
414 +   sw  R30, [R9]	# compressed ptr, #@storeN
418 +   beq  R7, zr, B48	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

41c     B46: #	out( B48 B47 ) &lt;- in( B45 )  Freq: 0.514338
41c +   beq   R20, zr, B48	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

420     B47: #	out( B84 B48 ) &lt;- in( B46 )  Freq: 0.513824
420 +   srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
424 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
430 +   add R10, R28, R7	# ptr, #@addP_reg_reg
434 +   lb  R7, [R10]	# byte, #@loadB
438 +   li R28, #4	# int, #@loadConI
43c +   bne  R7, R28, B84	#@cmpI_branch  P=0.001000 C=-1.000000

440     B48: #	out( B71 B49 ) &lt;- in( B22 B86 B87 B84 B47 B46 B45 )  Freq: 0.636825
440 +   spill [sp, #0] -&gt; R28	# spill size = 64
444 +   lw  R29, [R28, #24]	# int, #@loadI ! Field: java/util/HashMap.modCount
448     spill [sp, #0] -&gt; R7	# spill size = 64
44c +   lw  R7, [R7, #20]	# int, #@loadI ! Field: java/util/HashMap.size
450 +   addiw  R30, R29, #1	#@addI_reg_imm
454 +   addiw  R7, R7, #1	#@addI_reg_imm
458 +   lw  R28, [R28, #28]	# int, #@loadI ! Field: java/util/HashMap.threshold
45c     spill [sp, #0] -&gt; R29	# spill size = 64
460 +   sw  R30, [R29, #24]	# int, #@storeI ! Field: java/util/HashMap.modCount
464 +   sw  R7, [R29, #20]	# int, #@storeI ! Field: java/util/HashMap.size
468 +   bgt  R7, R28, B71	#@cmpI_branch  P=0.039459 C=3472.000000

46c     B49: #	out( B73 B50 ) &lt;- in( B72 B48 )  Freq: 0.636825
46c +   mv  R7, narrowklass: precise klass java/util/HashMap: 0x00000040d05281b0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
47c +   li R12, #1	# int, #@loadConI
480     spill [sp, #8] -&gt; R29	# spill size = 32
484 +   bne  R29, R7, B73	#@cmpN_branch  P=0.011484 C=-1.000000

488     B50: #	out( B67 ) &lt;- in( B49 B74 )  Freq: 0.636825
488 +   li R10, #1	# int, #@loadConI
48c +   j  B67	#@branch

490     B51: #	out( B120 B52 ) &lt;- in( B10 )  Freq: 0.213865
490 +   lwu  R30, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
494 +   decode_heap_oop  R30, R30	#@decodeHeapOop
498 +   beq  R30, R12, B120	#@cmpP_branch  P=0.000000 C=1166.000000

49c     B52: #	out( B112 B53 ) &lt;- in( B51 )  Freq: 0.213865
49c +   bne  R29, R11, B112	#@cmpN_branch  P=0.000001 C=-1.000000

4a0     B53: #	out( B61 B54 ) &lt;- in( B52 )  Freq: 0.213865
4a0 +   spill R12 -&gt; R28	# spill size = 64
4a4 +   # checkcastPP of R28, #@checkCastPP
4a4     beq  R28, R30, B61	#@cmpP_branch  P=0.064818 C=5338.000000

4a8     B54: #	out( B129 B55 ) &lt;- in( B53 )  Freq: 0.200002
4a8     lwu  R29, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
4ac     NullCheck R30

4ac     B55: #	out( B126 B56 ) &lt;- in( B54 )  Freq: 0.200002
4ac +   lwu  R12, [R28, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
4b0 +   lb  R31, [R28, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
4b4 +   bne  R29, R11, B126	#@cmpN_branch  P=0.000000 C=-1.000000

4b8     B56: #	out( B121 B57 ) &lt;- in( B55 )  Freq: 0.200002
4b8 +   # checkcastPP of R30, #@checkCastPP
4b8     lb  R29, [R30, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
4bc +   lwu  R13, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
4c0 +   decode_heap_oop  R11, R12	#@decodeHeapOop
4c4 +   bne  R31, R29, B121	#@cmpI_branch  P=0.000000 C=4992.000000

4c8     B57: #	out( B113 B58 ) &lt;- in( B56 )  Freq: 0.200002
4c8 +   beq   R11, zr, B113	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

4cc     B58: #	out( B114 B59 ) &lt;- in( B57 )  Freq: 0.200002
4cc +   decode_heap_oop  R29, R13	#@decodeHeapOop
4d0 +   lwu  R14, [R11, #12]	# range, #@loadRange
4d4 +   beq   R29, zr, B114	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

4d8     B59: #	out( B115 B60 ) &lt;- in( B58 )  Freq: 0.200002
4d8 +   lwu  R31, [R29, #12]	# range, #@loadRange
4dc +   bne  R14, R31, B115	#@cmpI_branch  P=0.000001 C=-1.000000

4e0     B60: #	out( B115 B61 ) &lt;- in( B59 )  Freq: 0.200002
4e0 +   addi  R13, R29, #16	# ptr, #@addP_reg_imm
4e4 +   addi  R11, R11, #16	# ptr, #@addP_reg_imm
4e8     String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
578 +   beq  R10, zr, B115	#@cmpI_reg_imm0_branch  P=0.000000 C=1166.000000

57c     B61: #	out( B62 ) &lt;- in( B53 B60 )  Freq: 0.213864
57c +   spill R7 -&gt; R21	# spill size = 64

580     B62: #	out( B88 B63 ) &lt;- in( B61 B30 B37 )  Freq: 0.363165
580 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
580     lb  R7, [R23, #56]	# byte, #@loadB
584 +   bne  R7, zr, B88	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

588     B63: #	out( B65 B64 ) &lt;- in( B116 B90 B88 B62 )  Freq: 0.363165
588 +   mv  R29, java/lang/Object:exact *	# ptr, #@loadConP
5a0 +   mv  R7, R21	# ptr -&gt; long, #@castP2X
5a4 +   mv  R29, R29	# ptr -&gt; long, #@castP2X
5a4 +   lwu  R28, [R21, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.value
5a8 +   xorr  R29, R29, R7	#@xorL_reg_reg
5ac +   mv  R30, narrowoop: java/lang/Object:exact *	# compressed ptr, #@loadConN
5bc +   srli  R29, R29, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
5c0 +   decode_heap_oop  R9, R28	#@decodeHeapOop
5c4 +   sw  R30, [R21, #20]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.value
5c8 +   beq  R29, zr, B65	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

5cc     B64: #	out( B91 B65 ) &lt;- in( B63 )  Freq: 0.362802
5cc +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
5d0 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
5dc +   add R10, R28, R7	# ptr, #@addP_reg_reg
5e0 +   lb  R7, [R10]	# byte, #@loadB
5e4 +   li R28, #4	# int, #@loadConI
5e8 +   bne  R7, R28, B91	#@cmpI_branch  P=0.001000 C=-1.000000

5ec     B65: #	out( B109 B66 ) &lt;- in( B93 B94 B91 B64 B63 )  Freq: 0.363165
5ec +   mv  R28, narrowklass: precise klass java/util/HashMap: 0x00000040d05281b0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
5fc     spill [sp, #8] -&gt; R7	# spill size = 32
600 +   bne  R7, R28, B109	#@cmpN_branch  P=0.000001 C=-1.000000

604     B66: #	out( B67 ) &lt;- in( B65 )  Freq: 0.363164
604 +   snez  R28, R9	#@convP2Bool
608 +   xori  R10, R28, #1	#@xorI_reg_imm

60c     B67: #	out( N1592 ) &lt;- in( B66 B50 )  Freq: 0.999989
60c     # pop frame 96
	add  sp, sp, #96
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
624 +   ret	// return register, #@Ret

628     B68: #	out( B139 B69 ) &lt;- in( B6 )  Freq: 0.172414
628 +   spill R19 -&gt; [sp, #16]	# spill size = 32
62c +   spill R29 -&gt; [sp, #12]	# spill size = 32
630 +   spill R12 -&gt; R8	# spill size = 64
634 +   spill [sp, #0] -&gt; R11	# spill size = 64
638     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:20 (line 627) L[0]=sp + #0 L[1]=sp + #16 L[2]=R8 L[3]=#Ptr0x00000040d052a9f0 L[4]=#0 L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=1596/0x63c}

63c     B69: #	out( B130 B70 ) &lt;- in( B68 )  Freq: 0.17241
        # Block is sole successor of call
63c     lwu  R7, [R10, #12]	# range, #@loadRange
640     NullCheck R10

640     B70: #	out( B8 ) &lt;- in( B69 )  Freq: 0.17241
640 +   spill R8 -&gt; R12	# spill size = 64
644 +   spill [sp, #12] -&gt; R29	# spill size = 32
648 +   spill R10 -&gt; R18	# spill size = 64
64c +   spill [sp, #16] -&gt; R19	# spill size = 32
650 +   j  B8	#@branch

654     B71: #	out( B138 B72 ) &lt;- in( B48 )  Freq: 0.0251282
654 +   spill [sp, #0] -&gt; R11	# spill size = 64
658     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:288 (line 661) L[0]=sp + #0 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {[0]=Oop off=1628/0x65c}

65c     B72: #	out( B49 ) &lt;- in( B71 )  Freq: 0.0251277
        # Block is sole successor of call
65c +   j  B49	#@branch

660     B73: #	out( B137 B74 ) &lt;- in( B49 )  Freq: 0.0073132
660 +   spill [sp, #0] -&gt; R11	# spill size = 64
664     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.HashMap::afterNodeInsertion
        # java.util.HashMap::putVal @ bci:295 (line 662) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {off=1664/0x680}

680     B74: #	out( B50 ) &lt;- in( B73 )  Freq: 0.00731305
        # Block is sole successor of call
680 +   j  B50	#@branch

684     B75: #	out( B136 B76 ) &lt;- in( B39 )  Freq: 0.0067364
684 +   spill [sp, #0] -&gt; R8	# spill size = 64
688 +   spill R12 -&gt; R7	# spill size = 64
68c +   spill R9 -&gt; [sp, #24]	# spill size = 64
690 +   spill R28 -&gt; [sp, #12]	# spill size = 32
694 +   spill R18 -&gt; [sp, #16]	# spill size = 64
698 +   spill R8 -&gt; R11	# spill size = 64
69c +   spill R19 -&gt; R12	# spill size = 32
6a0 +   spill R7 -&gt; R13	# spill size = 64
6a4 +   mv  R14, java/lang/Object:exact *	# ptr, #@loadConP
6bc     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.HashMap::newNode
        # java.util.HashMap::putVal @ bci:56 (line 629) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #16 STK[1]=sp + #12
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Derived_oop_[16] off=1752/0x6d8}

6d8     B76: #	out( B43 ) &lt;- in( B75 )  Freq: 0.00673627
        # Block is sole successor of call
6d8 +   spill [sp, #16] -&gt; R18	# spill size = 64
6dc +   spill [sp, #12] -&gt; R28	# spill size = 32
6e0 +   spill [sp, #24] -&gt; R9	# spill size = 64
6e4 +   spill R10 -&gt; R20	# spill size = 64
6e8 +   j  B43	#@branch

6ec     B77: #	out( B135 B78 ) &lt;- in( B3 B4 B5 )  Freq: 0.00299698
6ec +   spill R29 -&gt; [sp, #12]	# spill size = 32
6f0 +   spill R12 -&gt; R8	# spill size = 64
6f4 +   spill R12 -&gt; R11	# spill size = 64
6f8     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=R8 L[2]=#Ptr0x00000040d052a9f0 STK[0]=sp + #0
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop off=1812/0x714}

714     B78: #	out( B6 ) &lt;- in( B77 )  Freq: 0.00299692
        # Block is sole successor of call
714 +   spill R8 -&gt; R12	# spill size = 64
718 +   spill [sp, #12] -&gt; R29	# spill size = 32
71c +   j  B6	#@branch

720     B79: #	out( B134 B80 ) &lt;- in( B14 )  Freq: 0.000577154
720 +   spill [sp, #0] -&gt; R8	# spill size = 64
724 +   spill R12 -&gt; R7	# spill size = 64
728 +   spill R20 -&gt; [sp, #32]	# spill size = 32
72c +   spill R21 -&gt; [sp, #24]	# spill size = 64
730 +   spill R19 -&gt; [sp, #12]	# spill size = 32
734 +   spill R18 -&gt; [sp, #16]	# spill size = 64
738 +   spill R8 -&gt; R11	# spill size = 64
73c +   spill R19 -&gt; R12	# spill size = 32
740 +   spill R7 -&gt; R13	# spill size = 64
744 +   mv  R14, java/lang/Object:exact *	# ptr, #@loadConP
75c     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.HashMap::newNode
        # java.util.HashMap::putVal @ bci:152 (line 640) L[0]=R8 L[1]=sp + #12 L[2]=_ L[3]=#Ptr0x00000040d052a9f0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=sp + #32 STK[0]=sp + #24
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop [24]=Oop off=1912/0x778}

778     B80: #	out( B18 ) &lt;- in( B79 )  Freq: 0.000577143
        # Block is sole successor of call
778 +   spill [sp, #16] -&gt; R18	# spill size = 64
77c +   spill [sp, #12] -&gt; R19	# spill size = 32
780 +   spill [sp, #24] -&gt; R21	# spill size = 64
784 +   spill [sp, #32] -&gt; R20	# spill size = 32
788 +   spill R10 -&gt; R22	# spill size = 64
78c +   j  B18	#@branch

790     B81: #	out( B45 B82 ) &lt;- in( B44 )  Freq: 0.000514846
790 +   lwu  R28, [R9]	# loadN, compressed ptr, #@loadN
794 +   decode_heap_oop  R10, R28	#@decodeHeapOop
798 +   beq   R10, zr, B45	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

79c     B82: #	out( B111 B83 ) &lt;- in( B81 )  Freq: 0.000257423
79c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
79c     ld  R7, [R23, #32]	# int, #@loadL
7a0 +   beq  R7, zr, B111	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

7a4     B83: #	out( B45 ) &lt;- in( B82 )  Freq: 0.000257166
7a4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7a4     ld  R28, [R23, #48]	# ptr, #@loadP
7a8 +   add R28, R28, R7	# ptr, #@addP_reg_reg
7ac +   addi  R7, R7, #-8	#@addL_reg_imm
7b0 +   sd  R10, [R28, #-8]	# ptr, #@storeP
7b4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7b4     sd  R7, [R23, #32]	# long, #@storeL
7b8 +   j  B45	#@branch

7bc     B84: #	out( B48 B85 ) &lt;- in( B47 )  Freq: 0.000513824
7bc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7bc     ld  R7, [R23, #64]	# int, #@loadL
7c0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7c0     ld  R28, [R23, #80]	# ptr, #@loadP
7c4 +   #@membar_volatile
	fence iorw iorw
7c8 +   lb  R30, [R10]	# byte, #@loadB
7cc +   beq  R30, zr, B48	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

7d0     B85: #	out( B87 B86 ) &lt;- in( B84 )  Freq: 0.000256912
7d0 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
7d4 +   bne  R7, zr, B87	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

7d8     B86: #	out( B48 ) &lt;- in( B85 )  Freq: 0.000128456
7d8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7d8     spill R23 -&gt; R11	# spill size = 64
7dc +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
80c +   j  B48	#@branch

810     B87: #	out( B48 ) &lt;- in( B85 )  Freq: 0.000128456
810 +   add R28, R28, R7	# ptr, #@addP_reg_reg
814 +   addi  R7, R7, #-8	#@addL_reg_imm
818 +   sd  R10, [R28, #-8]	# ptr, #@storeP
81c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
81c     sd  R7, [R23, #64]	# long, #@storeL
820 +   j  B48	#@branch

824     B88: #	out( B63 B89 ) &lt;- in( B62 )  Freq: 0.00036316
824 +   lwu  R28, [R21, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.value
828 +   decode_heap_oop  R10, R28	#@decodeHeapOop
82c +   beq   R10, zr, B63	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

830     B89: #	out( B116 B90 ) &lt;- in( B88 )  Freq: 0.00018158
830 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
830     ld  R7, [R23, #32]	# int, #@loadL
834 +   beq  R7, zr, B116	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

838     B90: #	out( B63 ) &lt;- in( B89 )  Freq: 0.000181398
838 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
838     ld  R28, [R23, #48]	# ptr, #@loadP
83c +   add R28, R28, R7	# ptr, #@addP_reg_reg
840 +   addi  R7, R7, #-8	#@addL_reg_imm
844 +   sd  R10, [R28, #-8]	# ptr, #@storeP
848 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
848     sd  R7, [R23, #32]	# long, #@storeL
84c +   j  B63	#@branch

850     B91: #	out( B65 B92 ) &lt;- in( B64 )  Freq: 0.000362802
850 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
850     ld  R7, [R23, #64]	# int, #@loadL
854 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
854     ld  R28, [R23, #80]	# ptr, #@loadP
858 +   #@membar_volatile
	fence iorw iorw
85c +   lb  R30, [R10]	# byte, #@loadB
860 +   beq  R30, zr, B65	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

864     B92: #	out( B94 B93 ) &lt;- in( B91 )  Freq: 0.000181401
864 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
868 +   bne  R7, zr, B94	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

86c     B93: #	out( B65 ) &lt;- in( B92 )  Freq: 9.07004e-05
86c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
86c     spill R23 -&gt; R11	# spill size = 64
870 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
8a0 +   j  B65	#@branch

8a4     B94: #	out( B65 ) &lt;- in( B92 )  Freq: 9.07004e-05
8a4 +   add R28, R28, R7	# ptr, #@addP_reg_reg
8a8 +   addi  R7, R7, #-8	#@addL_reg_imm
8ac +   sd  R10, [R28, #-8]	# ptr, #@storeP
8b0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8b0     sd  R7, [R23, #64]	# long, #@storeL
8b4 +   j  B65	#@branch

8b8     B95: #	out( B19 B96 ) &lt;- in( B18 )  Freq: 0.000121971
8b8 +   lwu  R7, [R21, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
8bc +   decode_heap_oop  R10, R7	#@decodeHeapOop
8c0 +   beq   R10, zr, B19	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

8c4     B96: #	out( B124 B97 ) &lt;- in( B95 )  Freq: 6.09855e-05
8c4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8c4     ld  R7, [R23, #32]	# int, #@loadL
8c8 +   beq  R7, zr, B124	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

8cc     B97: #	out( B19 ) &lt;- in( B96 )  Freq: 6.09246e-05
8cc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8cc     ld  R28, [R23, #48]	# ptr, #@loadP
8d0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
8d4 +   addi  R7, R7, #-8	#@addL_reg_imm
8d8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
8dc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8dc     sd  R7, [R23, #32]	# long, #@storeL
8e0 +   j  B19	#@branch

8e4     B98: #	out( B22 B99 ) &lt;- in( B21 )  Freq: 0.000121729
8e4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8e4     ld  R7, [R23, #64]	# int, #@loadL
8e8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8e8     ld  R28, [R23, #80]	# ptr, #@loadP
8ec +   #@membar_volatile
	fence iorw iorw
8f0 +   lb  R29, [R10]	# byte, #@loadB
8f4 +   beq  R29, zr, B22	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

8f8     B99: #	out( B101 B100 ) &lt;- in( B98 )  Freq: 6.08644e-05
8f8 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
8fc +   bne  R7, zr, B101	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

900     B100: #	out( B22 ) &lt;- in( B99 )  Freq: 3.04322e-05
900 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
900     spill R23 -&gt; R11	# spill size = 64
904 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
934 +   j  B22	#@branch

938     B101: #	out( B22 ) &lt;- in( B99 )  Freq: 3.04322e-05
938 +   add R28, R28, R7	# ptr, #@addP_reg_reg
93c +   addi  R7, R7, #-8	#@addL_reg_imm
940 +   sd  R10, [R28, #-8]	# ptr, #@storeP
944 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
944     sd  R7, [R23, #64]	# long, #@storeL
948 +   j  B22	#@branch

94c     B102: #	out( B133 B103 ) &lt;- in( B40 )  Freq: 5.08201e-05
94c +   spill [sp, #0] -&gt; R8	# spill size = 64
950 +   spill R8 -&gt; [sp, #8]	# spill size = 64
954 +   spill R31 -&gt; [sp, #36]	# spill size = 32
958 +   spill R9 -&gt; [sp, #40]	# spill size = 64
95c +   spill R28 -&gt; [sp, #32]	# spill size = 32
960 +   spill R19 -&gt; [sp, #20]	# spill size = 32
964 +   spill R18 -&gt; [sp, #24]	# spill size = 64
968 +   spill R10 -&gt; [sp, #16]	# spill size = 32
96c +   # checkcastPP of R8, #@checkCastPP
96c     mv  R11, precise klass java/util/HashMap$Node: 0x00000040d0926d20:Constant:exact *	# ptr, #@loadConP
984     spill R12 -&gt; [sp, #0]	# spill size = 64
988     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #20 L[2]=sp + #0 L[3]=#Ptr0x00000040d052a9f0 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:56 (line 629) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #24 STK[1]=sp + #32
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [36]=NarrowOop [40]=Derived_oop_[24] off=2444/0x98c}

98c     B103: #	out( B42 ) &lt;- in( B102 )  Freq: 5.08191e-05
        # Block is sole successor of call
98c +   spill [sp, #8] -&gt; R29	# spill size = 64
990 +   spill [sp, #16] -&gt; R30	# spill size = 32
994 +   spill R30 -&gt; [sp, #8]	# spill size = 32
998 +   spill [sp, #24] -&gt; R18	# spill size = 64
99c +   spill [sp, #20] -&gt; R19	# spill size = 32
9a0 +   spill [sp, #32] -&gt; R28	# spill size = 32
9a4 +   spill [sp, #40] -&gt; R9	# spill size = 64
9a8 +   spill [sp, #36] -&gt; R31	# spill size = 32
9ac +   spill R10 -&gt; R20	# spill size = 64
9b0 +   spill R29 -&gt; [sp, #0]	# spill size = 64
9b4 +   j  B42	#@branch

9b8     B104: #	out( B132 B105 ) &lt;- in( B15 )  Freq: 1.21416e-05
9b8 +   spill [sp, #8] -&gt; R7	# spill size = 32
9bc +   spill [sp, #0] -&gt; R8	# spill size = 64
9c0 +   spill R8 -&gt; [sp, #8]	# spill size = 64
9c4 +   spill R20 -&gt; [sp, #36]	# spill size = 32
9c8 +   spill R21 -&gt; [sp, #40]	# spill size = 64
9cc +   spill R31 -&gt; [sp, #32]	# spill size = 32
9d0 +   spill R19 -&gt; [sp, #20]	# spill size = 32
9d4 +   spill R18 -&gt; [sp, #24]	# spill size = 64
9d8 +   spill R7 -&gt; [sp, #16]	# spill size = 32
9dc +   # checkcastPP of R8, #@checkCastPP
9dc     mv  R11, precise klass java/util/HashMap$Node: 0x00000040d0926d20:Constant:exact *	# ptr, #@loadConP
9f4     spill R12 -&gt; [sp, #0]	# spill size = 64
9f8     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #20 L[2]=sp + #0 L[3]=#Ptr0x00000040d052a9f0 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:152 (line 640) L[0]=R8 L[1]=sp + #20 L[2]=_ L[3]=#Ptr0x00000040d052a9f0 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=sp + #36 STK[0]=sp + #40
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Oop [32]=NarrowOop [40]=Oop off=2556/0x9fc}

9fc     B105: #	out( B17 ) &lt;- in( B104 )  Freq: 1.21413e-05
        # Block is sole successor of call
9fc +   spill [sp, #8] -&gt; R28	# spill size = 64
a00 +   spill [sp, #16] -&gt; R30	# spill size = 32
a04 +   spill R30 -&gt; [sp, #8]	# spill size = 32
a08 +   spill [sp, #24] -&gt; R18	# spill size = 64
a0c +   spill [sp, #20] -&gt; R19	# spill size = 32
a10 +   spill [sp, #32] -&gt; R31	# spill size = 32
a14 +   spill [sp, #40] -&gt; R21	# spill size = 64
a18 +   spill [sp, #36] -&gt; R20	# spill size = 32
a1c +   spill R10 -&gt; R22	# spill size = 64
a20 +   spill R28 -&gt; [sp, #0]	# spill size = 64
a24 +   j  B17	#@branch

a28     B106: #	out( N1592 ) &lt;- in( B8 )  Freq: 9.99994e-07
a28 +   spill [sp, #0] -&gt; R8	# spill size = 64
a2c +   li R11, #-28	# int, #@loadConI
a30     spill R19 -&gt; [sp, #0]	# spill size = 32
a34 +   spill R12 -&gt; [sp, #8]	# spill size = 64
a38 +   spill R18 -&gt; [sp, #24]	# spill size = 64
a3c +   spill R28 -&gt; [sp, #32]	# spill size = 32
a40     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.HashMap::putVal @ bci:40 (line 628) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=#Ptr0x00000040d052a9f0 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=sp + #32 L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #24 STK[1]=sp + #32
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop off=2628/0xa44}
a44     #@ShouldNotReachHere

a50     B107: #	out( N1592 ) &lt;- in( B43 )  Freq: 5.14853e-07
a50 +   spill [sp, #0] -&gt; R8	# spill size = 64
a54 +   li R11, #-42	# int, #@loadConI
a58     spill R18 -&gt; [sp, #0]	# spill size = 64
a5c +   spill R28 -&gt; [sp, #8]	# spill size = 32
a60 +   spill R20 -&gt; [sp, #16]	# spill size = 64
a64     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;array_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:59 (line 629) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #0 STK[1]=sp + #8 STK[2]=sp + #16
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=2664/0xa68}
a68     #@ShouldNotReachHere

a74     B108: #	out( N1592 ) &lt;- in( B7 )  Freq: 3.94623e-07
a74 +   spill [sp, #0] -&gt; R8	# spill size = 64
a78 +   li R11, #-187	# int, #@loadConI
a7c     spill R19 -&gt; [sp, #0]	# spill size = 32
a80 +   spill R12 -&gt; [sp, #8]	# spill size = 64
a84 +   spill R18 -&gt; [sp, #16]	# spill size = 64
a88 +   spill R7 -&gt; [sp, #24]	# spill size = 32
a8c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:16 (line 626) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=#Ptr0x00000040d052a9f0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=_ L[8]=sp + #24 L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #24
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=2704/0xa90}
a90     #@ShouldNotReachHere

a9c     B109: #	out( N1592 ) &lt;- in( B65 )  Freq: 3.63165e-07
a9c +   li R11, #-34	# int, #@loadConI
aa0     spill R9 -&gt; R8	# spill size = 64
aa4 +   spill R21 -&gt; [sp, #8]	# spill size = 64
aa8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:253 (line 655) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=R8 STK[0]=sp + #0 STK[1]=sp + #8
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=2732/0xaac}
aac     #@ShouldNotReachHere

ab8     B110: #	out( N1592 ) &lt;- in( B11 )  Freq: 2.74877e-07
ab8 +   spill [sp, #0] -&gt; R8	# spill size = 64
abc +   li R11, #-187	# int, #@loadConI
ac0     spill R19 -&gt; [sp, #0]	# spill size = 32
ac4 +   spill R12 -&gt; [sp, #8]	# spill size = 64
ac8 +   spill R18 -&gt; [sp, #16]	# spill size = 64
acc +   spill R7 -&gt; [sp, #24]	# spill size = 64
ad0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:109 (line 635) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=#Ptr0x00000040d052a9f0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=sp + #24 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#1
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop off=2772/0xad4}
ad4     #@ShouldNotReachHere

ae0     B111: #	out( B45 ) &lt;- in( B82 )  Freq: 2.5742e-07
ae0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
ae0     spill R23 -&gt; R11	# spill size = 64
ae4 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
b14 +   j  B45	#@branch

b18     B112: #	out( N1592 ) &lt;- in( B52 )  Freq: 2.13865e-07
b18 +   spill [sp, #0] -&gt; R8	# spill size = 64
b1c +   li R11, #-34	# int, #@loadConI
b20     spill R19 -&gt; [sp, #0]	# spill size = 32
b24 +   spill R18 -&gt; [sp, #16]	# spill size = 64
b28 +   spill R7 -&gt; [sp, #24]	# spill size = 64
b2c +   spill R12 -&gt; [sp, #32]	# spill size = 64
b30 +   spill R30 -&gt; [sp, #40]	# spill size = 64
b34     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #32 L[3]=#Ptr0x00000040d052a9f0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=sp + #24 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #32 STK[1]=sp + #40
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=2872/0xb38}
b38     #@ShouldNotReachHere

b44     B113: #	out( N1592 ) &lt;- in( B57 )  Freq: 2.02658e-07
b44     #@ShouldNotReachHere

b50     B114: #	out( N1592 ) &lt;- in( B58 )  Freq: 2.02658e-07
b50     #@ShouldNotReachHere

b5c     B115: #	out( N1592 ) &lt;- in( B60 B59 )  Freq: 2.9537e-07
b5c +   spill [sp, #0] -&gt; R8	# spill size = 64
b60 +   li R11, #-187	# int, #@loadConI
b64     spill R19 -&gt; [sp, #0]	# spill size = 32
b68 +   spill R28 -&gt; [sp, #8]	# spill size = 64
b6c +   spill R18 -&gt; [sp, #16]	# spill size = 64
b70 +   spill R7 -&gt; [sp, #24]	# spill size = 64
b74 +   spill R10 -&gt; [sp, #4]	# spill size = 32
b78     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:94 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=#Ptr0x00000040d052a9f0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=sp + #24 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #4
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop off=2940/0xb7c}
b7c     #@ShouldNotReachHere

b88     B116: #	out( B63 ) &lt;- in( B89 )  Freq: 1.81578e-07
b88 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
b88     spill R23 -&gt; R11	# spill size = 64
b8c +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
bbc +   j  B63	#@branch

bc0     B117: #	out( N1592 ) &lt;- in( B29 )  Freq: 1.49302e-07
bc0 +   spill [sp, #0] -&gt; R8	# spill size = 64
bc4 +   li R11, #-34	# int, #@loadConI
bc8     spill R19 -&gt; [sp, #0]	# spill size = 32
bcc +   spill R18 -&gt; [sp, #16]	# spill size = 64
bd0 +   spill R21 -&gt; [sp, #24]	# spill size = 64
bd4 +   spill R20 -&gt; [sp, #4]	# spill size = 32
bd8 +   spill R12 -&gt; [sp, #32]	# spill size = 64
bdc +   spill R31 -&gt; [sp, #40]	# spill size = 64
be0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #32 L[3]=#Ptr0x00000040d052a9f0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #24 L[11]=_ L[12]=sp + #4 STK[0]=sp + #32 STK[1]=sp + #40
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=3044/0xbe4}
be4     #@ShouldNotReachHere

bf0     B118: #	out( N1592 ) &lt;- in( B34 )  Freq: 1.41478e-07
bf0     #@ShouldNotReachHere

bfc     B119: #	out( N1592 ) &lt;- in( B35 )  Freq: 1.41478e-07
bfc     #@ShouldNotReachHere

c08     B120: #	out( N1592 ) &lt;- in( B51 )  Freq: 1.01979e-07
c08 +   spill [sp, #0] -&gt; R8	# spill size = 64
c0c +   li R11, #-187	# int, #@loadConI
c10     spill R19 -&gt; [sp, #0]	# spill size = 32
c14 +   spill R18 -&gt; [sp, #16]	# spill size = 64
c18 +   spill R7 -&gt; [sp, #24]	# spill size = 64
c1c +   spill R30 -&gt; [sp, #40]	# spill size = 64
c20 +   spill R12 -&gt; [sp, #48]	# spill size = 64
c24     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:81 (line 632) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=#Ptr0x00000040d052a9f0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=sp + #24 L[8]=_ L[9]=_ L[10]=_ L[11]=sp + #40 L[12]=_ STK[0]=sp + #40 STK[1]=sp + #48
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop off=3112/0xc28}
c28     #@ShouldNotReachHere

c34     B121: #	out( N1592 ) &lt;- in( B56 )  Freq: 1.00001e-07
c34 +   spill [sp, #0] -&gt; R8	# spill size = 64
c38 +   li R11, #-187	# int, #@loadConI
c3c     spill R19 -&gt; [sp, #0]	# spill size = 32
c40 +   spill R18 -&gt; [sp, #16]	# spill size = 64
c44 +   spill R7 -&gt; [sp, #24]	# spill size = 64
c48 +   spill R28 -&gt; [sp, #32]	# spill size = 64
c4c +   spill R30 -&gt; [sp, #40]	# spill size = 64
c50 +   spill R31 -&gt; [sp, #4]	# spill size = 32
c54 +   spill R29 -&gt; [sp, #48]	# spill size = 32
c58     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #32 L[1]=_ L[2]=sp + #40 STK[0]=sp + #4 STK[1]=sp + #48
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #32 L[3]=#Ptr0x00000040d052a9f0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=sp + #24 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=3164/0xc5c}
c5c     #@ShouldNotReachHere

c68     B122: #	out( N1592 ) &lt;- in( B28 )  Freq: 7.11927e-08
c68 +   spill [sp, #0] -&gt; R8	# spill size = 64
c6c +   li R11, #-187	# int, #@loadConI
c70     spill R19 -&gt; [sp, #0]	# spill size = 32
c74 +   spill R18 -&gt; [sp, #16]	# spill size = 64
c78 +   spill R21 -&gt; [sp, #24]	# spill size = 64
c7c +   spill R20 -&gt; [sp, #4]	# spill size = 32
c80 +   spill R12 -&gt; [sp, #32]	# spill size = 64
c84 +   spill R31 -&gt; [sp, #48]	# spill size = 64
c88     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:193 (line 645) L[0]=R8 L[1]=sp + #0 L[2]=sp + #32 L[3]=#Ptr0x00000040d052a9f0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #24 L[11]=sp + #48 L[12]=sp + #4 STK[0]=sp + #48 STK[1]=sp + #32
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [48]=Oop off=3212/0xc8c}
c8c     #@ShouldNotReachHere

c98     B123: #	out( N1592 ) &lt;- in( B33 )  Freq: 6.9812e-08
c98 +   li R11, #-187	# int, #@loadConI
c9c     spill R19 -&gt; [sp, #8]	# spill size = 32
ca0 +   spill R18 -&gt; [sp, #16]	# spill size = 64
ca4 +   spill R21 -&gt; [sp, #24]	# spill size = 64
ca8 +   spill R20 -&gt; [sp, #12]	# spill size = 32
cac +   spill R12 -&gt; [sp, #40]	# spill size = 64
cb0 +   spill R31 -&gt; [sp, #48]	# spill size = 64
cb4 +   spill R29 -&gt; [sp, #56]	# spill size = 32
cb8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #40 L[1]=_ L[2]=sp + #48 STK[0]=sp + #56 STK[1]=R8
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #40 L[3]=#Ptr0x00000040d052a9f0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #24 L[11]=_ L[12]=sp + #12
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [40]=Oop [48]=Oop off=3260/0xcbc}
cbc     #@ShouldNotReachHere

cc8     B124: #	out( B19 ) &lt;- in( B96 )  Freq: 6.09847e-08
cc8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
cc8     spill R23 -&gt; R11	# spill size = 64
ccc +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
cfc +   j  B19	#@branch

d00     B125: #	out( N1592 ) &lt;- in( B32 )  Freq: 1e-35
d00 +   spill [sp, #0] -&gt; R8	# spill size = 64
d04 +   li R11, #-34	# int, #@loadConI
d08     spill R19 -&gt; [sp, #0]	# spill size = 32
d0c +   spill R18 -&gt; [sp, #8]	# spill size = 64
d10 +   spill R21 -&gt; [sp, #16]	# spill size = 64
d14 +   spill R20 -&gt; [sp, #4]	# spill size = 32
d18 +   spill R12 -&gt; [sp, #32]	# spill size = 64
d1c +   spill R31 -&gt; [sp, #48]	# spill size = 64
d20     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #32 L[1]=sp + #48 L[2]=_ STK[0]=sp + #48
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #32 L[3]=#Ptr0x00000040d052a9f0 L[4]=#0 L[5]=#1 L[6]=sp + #8 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #16 L[11]=_ L[12]=sp + #4
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop [48]=Oop off=3364/0xd24}
d24     #@ShouldNotReachHere

d30     B126: #	out( N1592 ) &lt;- in( B55 )  Freq: 1e-35
d30 +   spill [sp, #0] -&gt; R8	# spill size = 64
d34 +   li R11, #-34	# int, #@loadConI
d38     spill R19 -&gt; [sp, #0]	# spill size = 32
d3c +   spill R18 -&gt; [sp, #16]	# spill size = 64
d40 +   spill R7 -&gt; [sp, #24]	# spill size = 64
d44 +   spill R28 -&gt; [sp, #32]	# spill size = 64
d48 +   spill R30 -&gt; [sp, #48]	# spill size = 64
d4c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #32 L[1]=sp + #48 L[2]=_ STK[0]=sp + #48
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #32 L[3]=#Ptr0x00000040d052a9f0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=sp + #24 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [48]=Oop off=3408/0xd50}
d50     #@ShouldNotReachHere

d5c     B127: #	out( N1592 ) &lt;- in( B1 )  Freq: 1.01328e-06
d5c +   li R11, #-10	# int, #@loadConI
d60     spill R12 -&gt; R8	# spill size = 64
d64     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8 STK[2]=#Ptr0x00000040d052a9f0
        # OopMap {fp=Oop off=3432/0xd68}
d68     #@ShouldNotReachHere

d74     B128: #	out( N1592 ) &lt;- in( B2 )  Freq: 4.76837e-07
d74 +   li R11, #-187	# int, #@loadConI
d78     spill R12 -&gt; [sp, #8]	# spill size = 64
d7c +   spill R12 -&gt; [sp, #16]	# spill size = 64
d80     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::hash @ bci:1 (line 338) L[0]=sp + #16 L[1]=_ STK[0]=sp + #8
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #8 L[2]=#Ptr0x00000040d052a9f0 STK[0]=sp + #0
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=3460/0xd84}
d84     #@ShouldNotReachHere

d90     B129: #	out( N1592 ) &lt;- in( B54 )  Freq: 2.02658e-07
d90 +   spill [sp, #0] -&gt; R8	# spill size = 64
d94 +   li R11, #-12	# int, #@loadConI
d98     spill R19 -&gt; [sp, #0]	# spill size = 32
d9c +   spill R18 -&gt; [sp, #16]	# spill size = 64
da0 +   spill R7 -&gt; [sp, #24]	# spill size = 64
da4 +   spill R28 -&gt; [sp, #32]	# spill size = 64
da8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #32 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #32 L[3]=#Ptr0x00000040d052a9f0 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=sp + #24 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop off=3500/0xdac}
dac     #@ShouldNotReachHere

db8     B130: #	out( N1592 ) &lt;- in( B69 )  Freq: 1.747e-07
db8 +   li R11, #-10	# int, #@loadConI
dbc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:26 (line 627) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#NULL
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {off=3520/0xdc0}
dc0     #@ShouldNotReachHere

dcc     B131: #	out( N1592 ) &lt;- in( B31 )  Freq: 1.41478e-07
dcc +   spill [sp, #0] -&gt; R8	# spill size = 64
dd0 +   li R11, #-12	# int, #@loadConI
dd4     spill R19 -&gt; [sp, #0]	# spill size = 32
dd8 +   spill R18 -&gt; [sp, #8]	# spill size = 64
ddc +   spill R21 -&gt; [sp, #16]	# spill size = 64
de0 +   spill R20 -&gt; [sp, #4]	# spill size = 32
de4 +   spill R12 -&gt; [sp, #32]	# spill size = 64
de8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #32 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #32 L[3]=#Ptr0x00000040d052a9f0 L[4]=#0 L[5]=#1 L[6]=sp + #8 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #16 L[11]=_ L[12]=sp + #4
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # java.util.HashSet::add @ bci:8 (line 221) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop off=3564/0xdec}
dec     #@ShouldNotReachHere

df8     B132: #	out( B140 ) &lt;- in( B104 )  Freq: 1.21416e-10
df8      -- 	// exception oop; no code emitted, #@CreateException
df8 +   j  B140	#@branch

dfc     B133: #	out( B140 ) &lt;- in( B102 )  Freq: 5.08201e-10
dfc      -- 	// exception oop; no code emitted, #@CreateException
dfc +   j  B140	#@branch

e00     B134: #	out( B140 ) &lt;- in( B79 )  Freq: 5.77154e-09
e00      -- 	// exception oop; no code emitted, #@CreateException
e00 +   j  B140	#@branch

e04     B135: #	out( B141 ) &lt;- in( B77 )  Freq: 2.99698e-08
e04      -- 	// exception oop; no code emitted, #@CreateException
e04 +   spill R10 -&gt; R11	# spill size = 64
e08 +   j  B141	#@branch

e0c     B136: #	out( B140 ) &lt;- in( B75 )  Freq: 6.7364e-08
e0c      -- 	// exception oop; no code emitted, #@CreateException
e0c +   j  B140	#@branch

e10     B137: #	out( B140 ) &lt;- in( B73 )  Freq: 7.3132e-08
e10      -- 	// exception oop; no code emitted, #@CreateException
e10 +   j  B140	#@branch

e14     B138: #	out( B140 ) &lt;- in( B71 )  Freq: 2.51282e-07
e14      -- 	// exception oop; no code emitted, #@CreateException
e14 +   j  B140	#@branch

e18     B139: #	out( B140 ) &lt;- in( B68 )  Freq: 1.72414e-06
e18      -- 	// exception oop; no code emitted, #@CreateException

e18     B140: #	out( B141 ) &lt;- in( B139 B136 B133 B134 B132 B138 B137 )  Freq: 2.12231e-06
e18 +   spill R10 -&gt; R11	# spill size = 64

e1c     B141: #	out( N1592 ) &lt;- in( B135 B140 )  Freq: 2.15228e-06
e1c     # pop frame 96
	add  sp, sp, #96
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
e28 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='573'>
----------------------- MetaData before Compile_id = 573 ------------------------
{method}
 - this oop:          0x00000040961a0cd8
 - method holder:     &apos;java/util/HashMap&apos;
 - constants:         0x000000409619f4e0 constant pool [610] {0x000000409619f4e0} for &apos;java/util/HashMap&apos; cache=0x00000040961a4fd8
 - access:            0x81000018  static final 
 - name:              &apos;hash&apos;
 - signature:         &apos;(Ljava/lang/Object;)I&apos;
 - max stack:         4
 - max locals:        2
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4f9040
 - code size:         20
 - code start:        0x00000040961a0ca0
 - code end (excl):   0x00000040961a0cb4
 - method data:       0x00000040964810c0
 - checked ex length: 0
 - linenumber start:  0x00000040961a0cb4
 - localvar length:   2
 - localvar start:    0x00000040961a0cbe
 - compiled code: nmethod  23209  145       3       java.util.HashMap::hash (20 bytes)

------------------------ OptoAssembly for Compile_id = 573 -----------------------
#
#  int ( java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/Object *
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B8 B5 B9 )  Freq: 1

000     B1: #	out( B8 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     lwu  R28, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
020     NullCheck R11

020     B2: #	out( B6 B3 ) &lt;- in( B1 )  Freq: 1
020 +   decode_klass_not_null  R28, R28	#@decodeKlass_not_null
02c +   ld  R28, [R28, #504]	# ptr, #@loadP
030 +   mv  R7, metadataptr:Constant0x00000040d0a1e730	# ptr, #@loadConP
048 +   bne  R28, R7, B6	#@cmpP_branch  P=0.001000 C=-1.000000

04c     B3: #	out( B6 B4 ) &lt;- in( B2 )  Freq: 0.999
04c +   ld  R7, [R11]	# int, #@loadL
050 +   li R29, #1	# long, #@loadConL
054 +   andi  R28, R7, #7	#@andL_reg_imm
058 +   bne  R28, R29, B6	#@cmpL_branch  P=0.001000 C=-1.000000

05c     B4: #	out( B6 B5 ) &lt;- in( B3 )  Freq: 0.998001
05c +   srli  R7, R7, (#8 &amp; 0x3f)	#@urShiftL_reg_imm
060 +   li R29, #2147483647	# int, #@loadConI
068 +   addw  R7, R7, zr	#@convL2I_reg
06c +   andr  R10, R7, R29	#@andI_reg_reg
070 +   beq  R10, zr, B6	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

074     B5: #	out( N1 ) &lt;- in( B7 B4 )  Freq: 0.999999
074 +   srliw  R7, R10, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
078 +   xorr  R10, R7, R10	#@xorI_reg_reg
07c     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
094 +   ret	// return register, #@Ret

098     B6: #	out( B9 B7 ) &lt;- in( B2 B3 B4 )  Freq: 0.00299699
098     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # OopMap {off=180/0xb4}

0b4     B7: #	out( B5 ) &lt;- in( B6 )  Freq: 0.00299693
        # Block is sole successor of call
0b4 +   j  B5	#@branch

0b8     B8: #	out( N1 ) &lt;- in( B1 )  Freq: 4.76837e-07
0b8 +   spill R11 -&gt; [sp, #0]	# spill size = 64
0bc +   li R11, #-187	# int, #@loadConI
0c0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::hash @ bci:1 (line 338) L[0]=sp + #0 L[1]=_ STK[0]=sp + #0
        # OopMap {[0]=Oop off=196/0xc4}
0c4     #@ShouldNotReachHere

0d0     B9: #	out( N1 ) &lt;- in( B6 )  Freq: 2.99699e-08
0d0      -- 	// exception oop; no code emitted, #@CreateException
0d0 +   spill R10 -&gt; R11	# spill size = 64
0d4 +   # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
0e0 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='579'>
----------------------- MetaData before Compile_id = 579 ------------------------
{method}
 - this oop:          0x00000040961a1ad8
 - method holder:     &apos;java/util/HashMap&apos;
 - constants:         0x000000409619f4e0 constant pool [610] {0x000000409619f4e0} for &apos;java/util/HashMap&apos; cache=0x00000040961a4fd8
 - access:            0x81000001  public 
 - name:              &apos;put&apos;
 - signature:         &apos;(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;&apos;
 - max stack:         7
 - max locals:        3
 - size of params:    3
 - method size:       13
 - highest level:     4
 - vtable index:      7
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x00000040083172b0: 0xbbb i2c: 0x0000004013944dc0 c2i: 0x0000004013944e0c c2iUV: 0x0000004013944dd8
 - compiled entry     0x0000004013944e0c
 - code size:         13
 - code start:        0x00000040961a1a98
 - code end (excl):   0x00000040961a1aa5
 - method data:       0x0000004096487118
 - checked ex length: 0
 - linenumber start:  0x00000040961a1aa5
 - localvar length:   3
 - localvar start:    0x00000040961a1ab0

------------------------ OptoAssembly for Compile_id = 579 -----------------------
#
#  java/lang/Object * ( java/util/HashMap:NotNull *, java/lang/Object *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/HashMap:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
#r016 c_rarg3:c_rarg3   : parm 2: java/lang/Object *
# -- Old sp -- Framesize: 112 --
#r263 sp+108: in_preserve
#r262 sp+104: return address
#r261 sp+100: in_preserve
#r260 sp+96: saved fp register
#r259 sp+92: pad2, stack alignment
#r258 sp+88: pad2, stack alignment
#r257 sp+84: Fixed slot 1
#r256 sp+80: Fixed slot 0
#r283 sp+76: spill
#r282 sp+72: spill
#r281 sp+68: spill
#r280 sp+64: spill
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1560: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B126 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=112
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #112
	
03c     spill R11 -&gt; [sp, #8]	# spill size = 64
040 +   spill R13 -&gt; [sp, #16]	# spill size = 64
044 +   spill R12 -&gt; [sp, #56]	# spill size = 64
048     lwu  R8, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
04c     NullCheck R12

04c     B2: #	out( B77 B3 ) &lt;- in( B1 )  Freq: 1
04c +   decode_klass_not_null  R28, R8	#@decodeKlass_not_null
058 +   ld  R28, [R28, #504]	# ptr, #@loadP
05c +   mv  R7, metadataptr:Constant0x00000040d09b75a0	# ptr, #@loadConP
074 +   bne  R28, R7, B77	#@cmpP_branch  P=0.001000 C=-1.000000

078     B3: #	out( B77 B4 ) &lt;- in( B2 )  Freq: 0.999
078 +   ld  R7, [R12]	# int, #@loadL
07c +   li R29, #1	# long, #@loadConL
080 +   andi  R28, R7, #7	#@andL_reg_imm
084 +   bne  R28, R29, B77	#@cmpL_branch  P=0.001000 C=-1.000000

088     B4: #	out( B77 B5 ) &lt;- in( B3 )  Freq: 0.998001
088 +   srli  R7, R7, (#8 &amp; 0x3f)	#@urShiftL_reg_imm
08c +   addw  R28, R7, zr	#@convL2I_reg
090 +   li R7, #2147483647	# int, #@loadConI
098 +   andr  R10, R28, R7	#@andI_reg_reg
09c +   beq  R10, zr, B77	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0a0     B5: #	out( B68 B6 ) &lt;- in( B78 B4 )  Freq: 0.999999
0a0 +   spill [sp, #8] -&gt; R7	# spill size = 64
0a4 +   lwu  R7, [R7, #36]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap.table
0a8 +   srliw  R29, R10, (#16 &amp; 0x1f)	#@urShiftI_reg_imm
0ac +   decode_heap_oop  R18, R7	#@decodeHeapOop
0b0 +   xorr  R19, R29, R10	#@xorI_reg_reg
0b4 +   beq   R18, zr, B68	#@cmpP_imm0_branch  P=0.171361 C=5503.000000

0b8     B6: #	out( B108 B7 ) &lt;- in( B5 )  Freq: 0.828638
0b8 +   lwu  R7, [R18, #12]	# range, #@loadRange
0bc +   bleu  R7, zr, B108	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=4560.000000

0c0     B7: #	out( B106 B8 ) &lt;- in( B70 B6 )  Freq: 0.999995
0c0 +   addiw  R28, R7, #-1	#@addI_reg_imm
0c4 +   andr  R28, R28, R19	#@andI_reg_reg
0c8 +   addw  R29, R28, zr	#@convI2L_reg_reg
0cc +   slli  R29, R29, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
0d0 +   add R29, R18, R29	# ptr, #@addP_reg_reg
0d4 +   addi  R20, R29, #16	# ptr, #@addP_reg_imm
0d8 +   ble  R7, zr, B106	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0dc     B8: #	out( B55 B9 ) &lt;- in( B7 )  Freq: 0.999994
0dc +   lwu  R29, [R20]	# loadN, compressed ptr, #@loadN
0e0     spill [sp, #8] -&gt; R7	# spill size = 64
0e4 +   lwu  R31, [R7, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0e8     spill [sp, #56] -&gt; R7	# spill size = 64
0ec +   encode_heap_oop  R30, R7	#@encodeHeapOop
0f0 +   decode_heap_oop  R29, R29	#@decodeHeapOop
0f4     spill [sp, #16] -&gt; R21	# spill size = 64
0f8 +   encode_heap_oop  R9, R21	#@encodeHeapOop
0fc +   mv  R15, NULL	# NULL ptr, #@loadConP0
100 +   mv  R7, narrowklass: precise klass java/util/HashMap$Node: 0x00000040d09ba780:Constant:exact *	# compressed klass ptr, #@loadConNKlass
110 +   mv  R12, narrowklass: precise klass java/util/HashMap: 0x00000040d09b3e40:Constant:exact *	# compressed klass ptr, #@loadConNKlass
120 +   beq   R29, zr, B55	#@cmpP_imm0_branch  P=0.519171 C=5503.000000

124     B9: #	out( B27 B10 ) &lt;- in( B8 )  Freq: 0.480826
124 +   lw  R11, [R29, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
128 +   mv  R28, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
138 +   li R10, #0	# int, #@loadConI
13c +   bne  R11, R19, B27	#@cmpI_branch  P=0.559713 C=2646.000000

140     B10: #	out( B119 B11 ) &lt;- in( B9 )  Freq: 0.211702
140 +   lwu  R30, [R29, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
144 +   decode_heap_oop  R30, R30	#@decodeHeapOop
148     spill [sp, #56] -&gt; R7	# spill size = 64
14c +   beq  R30, R7, B119	#@cmpP_branch  P=0.000000 C=1165.000000

150     B11: #	out( B111 B12 ) &lt;- in( B10 )  Freq: 0.211701
150 +   bne  R8, R28, B111	#@cmpN_branch  P=0.000001 C=-1.000000

154     B12: #	out( B20 B13 ) &lt;- in( B11 )  Freq: 0.211701
154 +   spill R7 -&gt; R31	# spill size = 64
158 +   # checkcastPP of R31, #@checkCastPP
158     beq  R31, R30, B20	#@cmpP_branch  P=0.064818 C=5338.000000

15c     B13: #	out( B127 B14 ) &lt;- in( B12 )  Freq: 0.197979
15c     lwu  R28, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
160     NullCheck R30

160     B14: #	out( B125 B15 ) &lt;- in( B13 )  Freq: 0.197979
160 +   mv  R11, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
170 +   lwu  R12, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
174 +   lb  R7, [R31, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
178 +   bne  R28, R11, B125	#@cmpN_branch  P=0.000000 C=-1.000000

17c     B15: #	out( B120 B16 ) &lt;- in( B14 )  Freq: 0.197979
17c +   # checkcastPP of R30, #@checkCastPP
17c     lb  R28, [R30, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
180 +   lwu  R13, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
184 +   decode_heap_oop  R11, R12	#@decodeHeapOop
188 +   bne  R7, R28, B120	#@cmpI_branch  P=0.000000 C=4992.000000

18c     B16: #	out( B112 B17 ) &lt;- in( B15 )  Freq: 0.197979
18c +   beq   R11, zr, B112	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

190     B17: #	out( B113 B18 ) &lt;- in( B16 )  Freq: 0.197979
190 +   decode_heap_oop  R7, R13	#@decodeHeapOop
194 +   lwu  R14, [R11, #12]	# range, #@loadRange
198 +   beq   R7, zr, B113	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

19c     B18: #	out( B114 B19 ) &lt;- in( B17 )  Freq: 0.197978
19c +   lwu  R30, [R7, #12]	# range, #@loadRange
1a0 +   bne  R14, R30, B114	#@cmpI_branch  P=0.000001 C=-1.000000

1a4     B19: #	out( B114 B20 ) &lt;- in( B18 )  Freq: 0.197978
1a4 +   addi  R13, R7, #16	# ptr, #@addP_reg_imm
1a8 +   addi  R11, R11, #16	# ptr, #@addP_reg_imm
1ac     String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
23c +   beq  R10, zr, B114	#@cmpI_reg_imm0_branch  P=0.000000 C=1165.000000

240     B20: #	out( B21 ) &lt;- in( B12 B19 )  Freq: 0.2117
240 +   spill R29 -&gt; R22	# spill size = 64

244     B21: #	out( B88 B22 ) &lt;- in( B20 B46 B53 )  Freq: 0.359555
244 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
244     lb  R7, [R23, #56]	# byte, #@loadB
248 +   bne  R7, zr, B88	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

24c     B22: #	out( B25 B23 ) &lt;- in( B115 B90 B88 B21 )  Freq: 0.359555
24c +   mv  R7, R22	# ptr -&gt; long, #@castP2X
250 +   mv  R29, R21	# ptr -&gt; long, #@castP2X
254 +   xorr  R29, R29, R7	#@xorL_reg_reg
258 +   lwu  R28, [R22, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.value
25c +   srli  R29, R29, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
260     spill [sp, #8] -&gt; R30	# spill size = 64
264 +   lwu  R18, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
268 +   decode_heap_oop  R20, R28	#@decodeHeapOop
26c +   mv  R19, narrowklass: precise klass java/util/HashMap: 0x00000040d09b3e40:Constant:exact *	# compressed klass ptr, #@loadConNKlass
27c +   sw  R9, [R22, #20]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.value
280 +   beq  R29, zr, B25	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

284     B23: #	out( B25 B24 ) &lt;- in( B22 )  Freq: 0.359195
284 +   beq   R21, zr, B25	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

288     B24: #	out( B91 B25 ) &lt;- in( B23 )  Freq: 0.358836
288 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
28c +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
298 +   add R10, R28, R7	# ptr, #@addP_reg_reg
29c +   lb  R28, [R10]	# byte, #@loadB
2a0 +   li R7, #4	# int, #@loadConI
2a4 +   bne  R28, R7, B91	#@cmpI_branch  P=0.001000 C=-1.000000

2a8     B25: #	out( B67 B26 ) &lt;- in( B93 B94 B91 B24 B23 B22 )  Freq: 0.359555
2a8 +   beq  R18, R19, B67	#@cmpN_branch  P=0.999999 C=-1.000000

2ac     B26: #	out( N1560 ) &lt;- in( B25 )  Freq: 3.59555e-07
2ac +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
2b4 +   li R11, #-34	# int, #@loadConI
2b8     spill R20 -&gt; R8	# spill size = 64
2bc +   spill R22 -&gt; [sp, #8]	# spill size = 64
2c0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:253 (line 655) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=R8 STK[0]=sp + #0 STK[1]=sp + #8
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=708/0x2c4}
2c4     #@ShouldNotReachHere

2d0     B27: #	out( B109 B28 ) &lt;- in( B9 )  Freq: 0.269124
2d0 +   lwu  R13, [R29, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
2d4 +   lwu  R11, [R29, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
2d8 +   mv  R14, narrowklass: precise klass java/util/HashMap$TreeNode: 0x00000040d01d5690:Constant:exact *	# compressed klass ptr, #@loadConNKlass
2e8 +   decode_heap_oop  R22, R13	#@decodeHeapOop
2ec +   beq  R11, R14, B109	#@cmpN_branch  P=0.000001 C=-1.000000

2f0     B28: #	out( B40 B29 ) &lt;- in( B27 )  Freq: 0.269124
2f0 +   bne   R22, zr, B40	#@cmpP_imm0_branch  P=0.614451 C=1730.000000

2f4     B29: #	out( B30 ) &lt;- in( B28 )  Freq: 0.103761
2f4 +   li R20, #0	# int, #@loadConI
2f8     spill R29 -&gt; R22	# spill size = 64

2fc     B30: #	out( B79 B31 ) &lt;- in( B42 B29 )  Freq: 0.121268
2fc +   bne  R31, R12, B79	#@cmpN_branch  P=0.004717 C=-1.000000

300     B31: #	out( B104 B32 ) &lt;- in( B30 )  Freq: 0.120696
300 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
300     ld  R24, [R23, #288]	# ptr, #@loadP
304 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
304     ld  R28, [R23, #304]	# ptr, #@loadP
308 +   addi  R29, R24, #32	# ptr, #@addP_reg_imm
30c +   bgeu  R29, R28, B104	#@cmpP_branch  P=0.000100 C=-1.000000

310     B32: #	out( B33 ) &lt;- in( B31 )  Freq: 0.120684
310 +   li R28, #1	# long, #@loadConL
314 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
314     sd  R29, [R23, #288]	# ptr, #@storeP
318 +   sd  R28, [R24]	# long, #@storeL
31c +   sw  R7, [R24, #8]	# compressed klass ptr, #@storeNKlass
320 +   sw  zr, [R24, #12]	# int, #@storeimmI0
324 +   sw  zr, [R24, #16]	# int, #@storeimmI0
328 +   sd  zr, [R24, #24]	# long, #@storeimmL0

32c     B33: #	out( B34 ) &lt;- in( B105 B32 )  Freq: 0.120696
32c +   sw  R9, [R24, #20]	# compressed ptr, #@storeN
330     
330 +   # checkcastPP of R24, #@checkCastPP
330     sw  R30, [R24, #16]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.key
334 +   sw  R19, [R24, #12]	# int, #@storeI ! Field: java/util/HashMap$Node.hash
338 +   #@membar_release
	fence iorw ow

33c     B34: #	out( B95 B35 ) &lt;- in( B33 B80 )  Freq: 0.121268
33c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
33c     lb  R7, [R23, #56]	# byte, #@loadB
340 +   bne  R7, zr, B95	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

344     B35: #	out( B38 B36 ) &lt;- in( B123 B97 B95 B34 )  Freq: 0.121268
344 +   mv  R28, R22	# ptr -&gt; long, #@castP2X
348 +   mv  R7, R24	# ptr -&gt; long, #@castP2X
34c +   xorr  R7, R7, R28	#@xorL_reg_reg
350 +   encode_heap_oop  R30, R24	#@encodeHeapOop
354 +   srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
358 +   li R9, #7	# int, #@loadConI
35c +   sw  R30, [R22, #24]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.next
360 +   beq  R7, zr, B38	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

364     B36: #	out( B38 B37 ) &lt;- in( B35 )  Freq: 0.121147
364 +   beq   R24, zr, B38	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

368     B37: #	out( B98 B38 ) &lt;- in( B36 )  Freq: 0.121026
368 +   srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
36c +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
378 +   add R10, R28, R7	# ptr, #@addP_reg_reg
37c +   lb  R7, [R10]	# byte, #@loadB
380 +   li R29, #4	# int, #@loadConI
384 +   bne  R7, R29, B98	#@cmpI_branch  P=0.001000 C=-1.000000

388     B38: #	out( B64 B39 ) &lt;- in( B100 B101 B98 B37 B36 B35 )  Freq: 0.121268
388 +   blt  R20, R9, B64	#@cmpI_branch  P=1.000000 C=667.000000

38c     B39: #	out( N1560 ) &lt;- in( B38 )  Freq: 5.78253e-08
38c +   spill [sp, #8] -&gt; R8	# spill size = 64
390 +   li R11, #-187	# int, #@loadConI
394     spill R19 -&gt; [sp, #0]	# spill size = 32
398 +   spill R21 -&gt; [sp, #8]	# spill size = 64
39c +   spill R18 -&gt; [sp, #16]	# spill size = 64
3a0 +   spill R20 -&gt; [sp, #4]	# spill size = 32
3a4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:162 (line 641) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=sp + #8 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=_ STK[0]=sp + #4 STK[1]=#7
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=936/0x3a8}
3a8     #@ShouldNotReachHere

3b4     B40: #	out( B41 ) &lt;- in( B28 )  Freq: 0.165364
3b4 +   li R20, #0	# int, #@loadConI

3b8     B41: #	out( B44 B42 ) &lt;- in( B40 B43 ) Loop( B41-B43 inner ) Freq: 0.193266
3b8 +   lw  R29, [R22, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
3bc +   beq  R29, R19, B44	#@cmpI_branch  P=0.765038 C=1064.000000

3c0     B42: #	out( B30 B43 ) &lt;- in( B41 )  Freq: 0.0454102
3c0 +   addiw  R20, R20, #1	#@addI_reg_imm
3c4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3c4     ld  R29, [R23, #920]	# ptr, #@loadP
3c8 +   lwu zr, [R29]	# Safepoint: poll for GC, #@safePoint        # java.util.HashMap::putVal @ bci:219 (line 638) L[0]=sp + #8 L[1]=R19 L[2]=sp + #56 L[3]=R21 L[4]=#0 L[5]=#1 L[6]=R18 L[7]=R22 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=R20
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {x30=NarrowOop x9=NarrowOop x18=Oop xdispatch=Oop xbcp=Oop [8]=Oop [56]=Oop off=968/0x3c8}
3cc +   lwu  R29, [R22, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
3d0 +   decode_heap_oop  R29, R29	#@decodeHeapOop
3d4 +   beq   R29, zr, B30	#@cmpP_imm0_branch  P=0.385549 C=250.000000

3d8     B43: #	out( B41 ) &lt;- in( B42 )  Freq: 0.0279024
3d8 +   spill R29 -&gt; R22	# spill size = 64
3dc +   j  B41	#@branch

3e0     B44: #	out( B121 B45 ) &lt;- in( B41 )  Freq: 0.147856
3e0 +   lwu  R29, [R22, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
3e4 +   decode_heap_oop  R30, R29	#@decodeHeapOop
3e8     spill [sp, #56] -&gt; R7	# spill size = 64
3ec +   beq  R30, R7, B121	#@cmpP_branch  P=0.000000 C=814.000000

3f0     B45: #	out( B116 B46 ) &lt;- in( B44 )  Freq: 0.147856
3f0 +   bne  R8, R28, B116	#@cmpN_branch  P=0.000001 C=-1.000000

3f4     B46: #	out( B21 B47 ) &lt;- in( B45 )  Freq: 0.147855
3f4 +   spill R7 -&gt; R31	# spill size = 64
3f8 +   # checkcastPP of R31, #@checkCastPP
3f8     beq  R31, R30, B21	#@cmpP_branch  P=0.064818 C=5338.000000

3fc     B47: #	out( B129 B48 ) &lt;- in( B46 )  Freq: 0.138272
3fc     lwu  R7, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
400     NullCheck R30

400     B48: #	out( B124 B49 ) &lt;- in( B47 )  Freq: 0.138272
400 +   lwu  R29, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
404 +   lb  R13, [R31, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
408 +   bne  R7, R28, B124	#@cmpN_branch  P=0.000000 C=-1.000000

40c     B49: #	out( B122 B50 ) &lt;- in( B48 )  Freq: 0.138272
40c +   # checkcastPP of R30, #@checkCastPP
40c     lb  R8, [R30, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
410 +   lwu  R28, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
414 +   decode_heap_oop  R7, R29	#@decodeHeapOop
418 +   bne  R13, R8, B122	#@cmpI_branch  P=0.000000 C=4992.000000

41c     B50: #	out( B117 B51 ) &lt;- in( B49 )  Freq: 0.138272
41c +   beq   R7, zr, B117	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

420     B51: #	out( B118 B52 ) &lt;- in( B50 )  Freq: 0.138271
420 +   decode_heap_oop  R28, R28	#@decodeHeapOop
424 +   lwu  R14, [R7, #12]	# range, #@loadRange
428 +   beq   R28, zr, B118	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

42c     B52: #	out( B54 B53 ) &lt;- in( B51 )  Freq: 0.138271
42c +   lwu  R30, [R28, #12]	# range, #@loadRange
430 +   bne  R14, R30, B54	#@cmpI_branch  P=0.000001 C=-1.000000

434     B53: #	out( B21 B54 ) &lt;- in( B52 )  Freq: 0.138271
434 +   addi  R13, R28, #16	# ptr, #@addP_reg_imm
438 +   addi  R11, R7, #16	# ptr, #@addP_reg_imm
43c     String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
4cc +   bne  R10, zr, B21	#@cmpI_reg_imm0_branch  P=1.000000 C=814.000000

4d0     B54: #	out( N1560 ) &lt;- in( B53 B52 )  Freq: 2.04204e-07
4d0 +   spill [sp, #8] -&gt; R8	# spill size = 64
4d4 +   li R11, #-187	# int, #@loadConI
4d8     spill R19 -&gt; [sp, #0]	# spill size = 32
4dc +   spill R21 -&gt; [sp, #8]	# spill size = 64
4e0 +   spill R18 -&gt; [sp, #16]	# spill size = 64
4e4 +   spill R22 -&gt; [sp, #24]	# spill size = 64
4e8 +   spill R20 -&gt; [sp, #4]	# spill size = 32
4ec +   spill R10 -&gt; [sp, #32]	# spill size = 32
4f0 +   spill R31 -&gt; [sp, #40]	# spill size = 64
4f4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:206 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #40 L[3]=sp + #8 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #24 L[11]=_ L[12]=sp + #4 STK[0]=sp + #32
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop off=1272/0x4f8}
4f8     #@ShouldNotReachHere

504     B55: #	out( B75 B56 ) &lt;- in( B8 )  Freq: 0.519168
504 +   bne  R31, R12, B75	#@cmpN_branch  P=0.013216 C=-1.000000

508     B56: #	out( B102 B57 ) &lt;- in( B55 )  Freq: 0.512307
508 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
508     ld  R22, [R23, #288]	# ptr, #@loadP
50c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
50c     ld  R29, [R23, #304]	# ptr, #@loadP
510 +   addi  R31, R22, #32	# ptr, #@addP_reg_imm
514 +   bgeu  R31, R29, B102	#@cmpP_branch  P=0.000100 C=-1.000000

518     B57: #	out( B58 ) &lt;- in( B56 )  Freq: 0.512256
518 +   li R29, #1	# long, #@loadConL
51c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
51c     sd  R31, [R23, #288]	# ptr, #@storeP
520 +   sd  R29, [R22]	# long, #@storeL
524 +   sw  R7, [R22, #8]	# compressed klass ptr, #@storeNKlass
528 +   sw  zr, [R22, #12]	# int, #@storeimmI0
52c +   sw  zr, [R22, #16]	# int, #@storeimmI0
530 +   sd  zr, [R22, #24]	# long, #@storeimmL0

534     B58: #	out( B59 ) &lt;- in( B103 B57 )  Freq: 0.512307
534 +   sw  R9, [R22, #20]	# compressed ptr, #@storeN
538     
538 +   # checkcastPP of R22, #@checkCastPP
538     sw  R30, [R22, #16]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.key
53c +   sw  R19, [R22, #12]	# int, #@storeI ! Field: java/util/HashMap$Node.hash
540 +   #@membar_release
	fence iorw ow

544     B59: #	out( B107 B60 ) &lt;- in( B58 B76 )  Freq: 0.519168
544 +   lwu  R29, [R18, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
548 +   mv  R7, narrowklass: precise klass [Ljava/util/HashMap$Node;: 0x00000040d09ba850:Constant:exact *	# compressed klass ptr, #@loadConNKlass
558 +   bne  R29, R7, B107	#@cmpN_branch  P=0.000001 C=-1.000000

55c     B60: #	out( B81 B61 ) &lt;- in( B59 )  Freq: 0.519168
55c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
55c     lb  R28, [R23, #56]	# byte, #@loadB
560 +   bne  R28, zr, B81	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

564     B61: #	out( B64 B62 ) &lt;- in( B110 B83 B81 B60 )  Freq: 0.519168
564 +   mv  R7, R20	# ptr -&gt; long, #@castP2X
568 +   mv  R28, R22	# ptr -&gt; long, #@castP2X
56c +   xorr  R28, R28, R7	#@xorL_reg_reg
570 +   encode_heap_oop  R29, R22	#@encodeHeapOop
574 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
578 +   sw  R29, [R20]	# compressed ptr, #@storeN
57c +   beq  R28, zr, B64	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

580     B62: #	out( B64 B63 ) &lt;- in( B61 )  Freq: 0.518649
580 +   beq   R22, zr, B64	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

584     B63: #	out( B84 B64 ) &lt;- in( B62 )  Freq: 0.51813
584 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
588 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
594 +   add R10, R28, R7	# ptr, #@addP_reg_reg
598 +   lb  R28, [R10]	# byte, #@loadB
59c +   li R29, #4	# int, #@loadConI
5a0 +   bne  R28, R29, B84	#@cmpI_branch  P=0.001000 C=-1.000000

5a4     B64: #	out( B71 B65 ) &lt;- in( B38 B86 B87 B84 B63 B62 B61 )  Freq: 0.640436
5a4 +   spill [sp, #8] -&gt; R7	# spill size = 64
5a8 +   lw  R28, [R7, #24]	# int, #@loadI ! Field: java/util/HashMap.modCount
5ac +   lw  R7, [R7, #20]	# int, #@loadI ! Field: java/util/HashMap.size
5b0 +   spill [sp, #8] -&gt; R29	# spill size = 64
5b4 +   lw  R30, [R29, #28]	# int, #@loadI ! Field: java/util/HashMap.threshold
5b8 +   addiw  R29, R7, #1	#@addI_reg_imm
5bc +   addiw  R28, R28, #1	#@addI_reg_imm
5c0     spill [sp, #8] -&gt; R7	# spill size = 64
5c4 +   sw  R28, [R7, #24]	# int, #@storeI ! Field: java/util/HashMap.modCount
5c8 +   sw  R29, [R7, #20]	# int, #@storeI ! Field: java/util/HashMap.size
5cc +   bgt  R29, R30, B71	#@cmpI_branch  P=0.038876 C=3524.000000

5d0     B65: #	out( B73 B66 ) &lt;- in( B72 B64 )  Freq: 0.640436
5d0 +   spill [sp, #8] -&gt; R7	# spill size = 64
5d4 +   lwu  R7, [R7, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
5d8 +   mv  R29, narrowklass: precise klass java/util/HashMap: 0x00000040d09b3e40:Constant:exact *	# compressed klass ptr, #@loadConNKlass
5e8 +   bne  R7, R29, B73	#@cmpN_branch  P=0.011607 C=-1.000000

5ec     B66: #	out( B67 ) &lt;- in( B65 B74 )  Freq: 0.640436
5ec +   mv  R20, NULL	# NULL ptr, #@loadConP0

5f0     B67: #	out( N1560 ) &lt;- in( B25 B66 )  Freq: 0.99999
5f0     spill R20 -&gt; R10	# spill size = 64
5f4 +   # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
60c +   ret	// return register, #@Ret

610     B68: #	out( B137 B69 ) &lt;- in( B5 )  Freq: 0.171361
610 +   spill [sp, #8] -&gt; R11	# spill size = 64
614 +   spill R19 -&gt; [sp, #4]	# spill size = 32
618     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:20 (line 627) L[0]=sp + #8 L[1]=sp + #4 L[2]=sp + #56 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {[8]=Oop [16]=Oop [56]=Oop off=1564/0x61c}

61c     B69: #	out( B128 B70 ) &lt;- in( B68 )  Freq: 0.171358
        # Block is sole successor of call
61c     lwu  R7, [R10, #12]	# range, #@loadRange
620     NullCheck R10

620     B70: #	out( B7 ) &lt;- in( B69 )  Freq: 0.171357
620 +   spill R10 -&gt; R18	# spill size = 64
624 +   spill [sp, #4] -&gt; R19	# spill size = 32
628 +   j  B7	#@branch

62c     B71: #	out( B136 B72 ) &lt;- in( B64 )  Freq: 0.0248978
62c +   spill [sp, #8] -&gt; R11	# spill size = 64
630     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:288 (line 661) L[0]=sp + #8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {[8]=Oop off=1588/0x634}

634     B72: #	out( B65 ) &lt;- in( B71 )  Freq: 0.0248973
        # Block is sole successor of call
634 +   j  B65	#@branch

638     B73: #	out( B135 B74 ) &lt;- in( B65 )  Freq: 0.00743365
638 +   li R12, #1	# int, #@loadConI
63c     spill [sp, #8] -&gt; R11	# spill size = 64
640     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.HashMap::afterNodeInsertion
        # java.util.HashMap::putVal @ bci:295 (line 662) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {off=1628/0x65c}

65c     B74: #	out( B66 ) &lt;- in( B73 )  Freq: 0.0074335
        # Block is sole successor of call
65c +   j  B66	#@branch

660     B75: #	out( B134 B76 ) &lt;- in( B55 )  Freq: 0.00686125
660 +   spill [sp, #8] -&gt; R8	# spill size = 64
664 +   spill [sp, #56] -&gt; R7	# spill size = 64
668 +   spill R20 -&gt; [sp, #24]	# spill size = 64
66c +   spill R28 -&gt; [sp, #16]	# spill size = 32
670 +   spill R18 -&gt; [sp, #0]	# spill size = 64
674 +   spill R8 -&gt; R11	# spill size = 64
678 +   spill R19 -&gt; R12	# spill size = 32
67c +   spill R7 -&gt; R13	# spill size = 64
680 +   spill R21 -&gt; R14	# spill size = 64
684     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.HashMap::newNode
        # java.util.HashMap::putVal @ bci:56 (line 629) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #0 STK[1]=sp + #16
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [24]=Derived_oop_[0] off=1696/0x6a0}

6a0     B76: #	out( B59 ) &lt;- in( B75 )  Freq: 0.00686111
        # Block is sole successor of call
6a0 +   spill [sp, #0] -&gt; R18	# spill size = 64
6a4 +   spill [sp, #16] -&gt; R28	# spill size = 32
6a8 +   spill [sp, #24] -&gt; R20	# spill size = 64
6ac +   spill R10 -&gt; R22	# spill size = 64
6b0 +   j  B59	#@branch

6b4     B77: #	out( B133 B78 ) &lt;- in( B2 B3 B4 )  Freq: 0.00299699
6b4 +   spill R12 -&gt; R11	# spill size = 64
6b8     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.HashMap::hash @ bci:9 (line 338) L[0]=_ L[1]=_
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #56 L[2]=sp + #16 STK[0]=sp + #8
        # OopMap {[8]=Oop [16]=Oop [56]=Oop off=1748/0x6d4}

6d4     B78: #	out( B5 ) &lt;- in( B77 )  Freq: 0.00299693
        # Block is sole successor of call
6d4 +   j  B5	#@branch

6d8     B79: #	out( B132 B80 ) &lt;- in( B30 )  Freq: 0.000572022
6d8 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
6e0 +   spill [sp, #56] -&gt; R7	# spill size = 64
6e4 +   spill R20 -&gt; [sp, #28]	# spill size = 32
6e8 +   spill R22 -&gt; [sp, #32]	# spill size = 64
6ec +   spill R19 -&gt; [sp, #24]	# spill size = 32
6f0 +   spill R18 -&gt; [sp, #16]	# spill size = 64
6f4 +   spill R21 -&gt; R8	# spill size = 64
6f8 +   spill [sp, #0] -&gt; R11	# spill size = 64
6fc +   spill R19 -&gt; R12	# spill size = 32
700 +   spill R7 -&gt; R13	# spill size = 64
704 +   spill R21 -&gt; R14	# spill size = 64
708     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.HashMap::newNode
        # java.util.HashMap::putVal @ bci:152 (line 640) L[0]=sp + #0 L[1]=sp + #24 L[2]=_ L[3]=R8 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=sp + #28 STK[0]=sp + #32
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop [32]=Oop off=1828/0x724}

724     B80: #	out( B34 ) &lt;- in( B79 )  Freq: 0.000572011
        # Block is sole successor of call
724 +   spill [sp, #24] -&gt; R28	# spill size = 32
728 +   spill R8 -&gt; R21	# spill size = 64
72c +   spill [sp, #16] -&gt; R18	# spill size = 64
730 +   spill [sp, #32] -&gt; R22	# spill size = 64
734 +   spill [sp, #28] -&gt; R20	# spill size = 32
738 +   spill R10 -&gt; R24	# spill size = 64
73c +   spill R28 -&gt; R19	# spill size = 32
740 +   j  B34	#@branch

744     B81: #	out( B61 B82 ) &lt;- in( B60 )  Freq: 0.000519161
744 +   lwu  R7, [R20]	# loadN, compressed ptr, #@loadN
748 +   decode_heap_oop  R10, R7	#@decodeHeapOop
74c +   beq   R10, zr, B61	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

750     B82: #	out( B110 B83 ) &lt;- in( B81 )  Freq: 0.000259581
750 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
750     ld  R7, [R23, #32]	# int, #@loadL
754 +   beq  R7, zr, B110	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

758     B83: #	out( B61 ) &lt;- in( B82 )  Freq: 0.000259321
758 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
758     ld  R28, [R23, #48]	# ptr, #@loadP
75c +   add R28, R28, R7	# ptr, #@addP_reg_reg
760 +   addi  R7, R7, #-8	#@addL_reg_imm
764 +   sd  R10, [R28, #-8]	# ptr, #@storeP
768 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
768     sd  R7, [R23, #32]	# long, #@storeL
76c +   j  B61	#@branch

770     B84: #	out( B64 B85 ) &lt;- in( B63 )  Freq: 0.00051813
770 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
770     ld  R7, [R23, #64]	# int, #@loadL
774 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
774     ld  R28, [R23, #80]	# ptr, #@loadP
778 +   #@membar_volatile
	fence iorw iorw
77c +   lb  R29, [R10]	# byte, #@loadB
780 +   beq  R29, zr, B64	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

784     B85: #	out( B87 B86 ) &lt;- in( B84 )  Freq: 0.000259065
784 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
788 +   bne  R7, zr, B87	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

78c     B86: #	out( B64 ) &lt;- in( B85 )  Freq: 0.000129533
78c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
78c     spill R23 -&gt; R11	# spill size = 64
790 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
7c0 +   j  B64	#@branch

7c4     B87: #	out( B64 ) &lt;- in( B85 )  Freq: 0.000129533
7c4 +   add R28, R28, R7	# ptr, #@addP_reg_reg
7c8 +   addi  R7, R7, #-8	#@addL_reg_imm
7cc +   sd  R10, [R28, #-8]	# ptr, #@storeP
7d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7d0     sd  R7, [R23, #64]	# long, #@storeL
7d4 +   j  B64	#@branch

7d8     B88: #	out( B22 B89 ) &lt;- in( B21 )  Freq: 0.00035955
7d8 +   lwu  R28, [R22, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.value
7dc +   decode_heap_oop  R10, R28	#@decodeHeapOop
7e0 +   beq   R10, zr, B22	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

7e4     B89: #	out( B115 B90 ) &lt;- in( B88 )  Freq: 0.000179775
7e4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7e4     ld  R7, [R23, #32]	# int, #@loadL
7e8 +   beq  R7, zr, B115	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

7ec     B90: #	out( B22 ) &lt;- in( B89 )  Freq: 0.000179595
7ec +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7ec     ld  R28, [R23, #48]	# ptr, #@loadP
7f0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
7f4 +   addi  R7, R7, #-8	#@addL_reg_imm
7f8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
7fc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7fc     sd  R7, [R23, #32]	# long, #@storeL
800 +   j  B22	#@branch

804     B91: #	out( B25 B92 ) &lt;- in( B24 )  Freq: 0.000358836
804 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
804     ld  R7, [R23, #64]	# int, #@loadL
808 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
808     ld  R28, [R23, #80]	# ptr, #@loadP
80c +   #@membar_volatile
	fence iorw iorw
810 +   lb  R29, [R10]	# byte, #@loadB
814 +   beq  R29, zr, B25	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

818     B92: #	out( B94 B93 ) &lt;- in( B91 )  Freq: 0.000179418
818 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
81c +   bne  R7, zr, B94	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

820     B93: #	out( B25 ) &lt;- in( B92 )  Freq: 8.97091e-05
820 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
820     spill R23 -&gt; R11	# spill size = 64
824 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
854 +   j  B25	#@branch

858     B94: #	out( B25 ) &lt;- in( B92 )  Freq: 8.97091e-05
858 +   add R28, R28, R7	# ptr, #@addP_reg_reg
85c +   addi  R7, R7, #-8	#@addL_reg_imm
860 +   sd  R10, [R28, #-8]	# ptr, #@storeP
864 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
864     sd  R7, [R23, #64]	# long, #@storeL
868 +   j  B25	#@branch

86c     B95: #	out( B35 B96 ) &lt;- in( B34 )  Freq: 0.000121267
86c +   lwu  R28, [R22, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
870 +   decode_heap_oop  R10, R28	#@decodeHeapOop
874 +   beq   R10, zr, B35	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

878     B96: #	out( B123 B97 ) &lt;- in( B95 )  Freq: 6.06334e-05
878 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
878     ld  R7, [R23, #32]	# int, #@loadL
87c +   beq  R7, zr, B123	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

880     B97: #	out( B35 ) &lt;- in( B96 )  Freq: 6.05728e-05
880 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
880     ld  R28, [R23, #48]	# ptr, #@loadP
884 +   add R28, R28, R7	# ptr, #@addP_reg_reg
888 +   addi  R7, R7, #-8	#@addL_reg_imm
88c +   sd  R10, [R28, #-8]	# ptr, #@storeP
890 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
890     sd  R7, [R23, #32]	# long, #@storeL
894 +   j  B35	#@branch

898     B98: #	out( B38 B99 ) &lt;- in( B37 )  Freq: 0.000121026
898 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
898     ld  R7, [R23, #64]	# int, #@loadL
89c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
89c     ld  R28, [R23, #80]	# ptr, #@loadP
8a0 +   #@membar_volatile
	fence iorw iorw
8a4 +   lb  R30, [R10]	# byte, #@loadB
8a8 +   beq  R30, zr, B38	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

8ac     B99: #	out( B101 B100 ) &lt;- in( B98 )  Freq: 6.0513e-05
8ac +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
8b0 +   bne  R7, zr, B101	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

8b4     B100: #	out( B38 ) &lt;- in( B99 )  Freq: 3.02565e-05
8b4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8b4     spill R23 -&gt; R11	# spill size = 64
8b8 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
8e8 +   j  B38	#@branch

8ec     B101: #	out( B38 ) &lt;- in( B99 )  Freq: 3.02565e-05
8ec +   add R28, R28, R7	# ptr, #@addP_reg_reg
8f0 +   addi  R7, R7, #-8	#@addL_reg_imm
8f4 +   sd  R10, [R28, #-8]	# ptr, #@storeP
8f8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8f8     sd  R7, [R23, #64]	# long, #@storeL
8fc +   j  B38	#@branch

900     B102: #	out( B131 B103 ) &lt;- in( B56 )  Freq: 5.12392e-05
900 +   spill [sp, #8] -&gt; R8	# spill size = 64
904 +   spill [sp, #8] -&gt; [sp, #16]	# spill size = 64
90c +   spill R9 -&gt; [sp, #52]	# spill size = 32
910 +   spill R30 -&gt; [sp, #48]	# spill size = 32
914 +   spill R20 -&gt; [sp, #40]	# spill size = 64
918 +   spill R28 -&gt; [sp, #36]	# spill size = 32
91c +   spill R19 -&gt; [sp, #32]	# spill size = 32
920 +   spill R18 -&gt; [sp, #24]	# spill size = 64
924 +   # checkcastPP of R8, #@checkCastPP
924     mv  R11, precise klass java/util/HashMap$Node: 0x00000040d09ba780:Constant:exact *	# ptr, #@loadConP
93c     spill R21 -&gt; [sp, #8]	# spill size = 64
940     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #32 L[2]=sp + #56 L[3]=sp + #8 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:56 (line 629) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #24 STK[1]=sp + #36
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Derived_oop_[24] [48]=NarrowOop [52]=NarrowOop [56]=Oop off=2372/0x944}

944     B103: #	out( B58 ) &lt;- in( B102 )  Freq: 5.12382e-05
        # Block is sole successor of call
944 +   spill [sp, #32] -&gt; R29	# spill size = 32
948 +   spill [sp, #16] -&gt; [sp, #8]	# spill size = 64
950 +   spill [sp, #24] -&gt; R18	# spill size = 64
954 +   spill [sp, #36] -&gt; R28	# spill size = 32
958 +   spill [sp, #40] -&gt; R20	# spill size = 64
95c +   spill [sp, #48] -&gt; R30	# spill size = 32
960 +   spill [sp, #52] -&gt; R9	# spill size = 32
964 +   spill R10 -&gt; R22	# spill size = 64
968 +   spill R29 -&gt; R19	# spill size = 32
96c +   j  B58	#@branch

970     B104: #	out( B130 B105 ) &lt;- in( B31 )  Freq: 1.20716e-05
970 +   spill [sp, #8] -&gt; R8	# spill size = 64
974 +   spill R20 -&gt; [sp, #44]	# spill size = 32
978 +   spill R22 -&gt; [sp, #48]	# spill size = 64
97c +   spill R9 -&gt; [sp, #40]	# spill size = 32
980 +   spill R30 -&gt; [sp, #36]	# spill size = 32
984 +   spill R19 -&gt; [sp, #32]	# spill size = 32
988 +   spill R18 -&gt; [sp, #24]	# spill size = 64
98c +   spill R21 -&gt; [sp, #16]	# spill size = 64
990 +   # checkcastPP of R8, #@checkCastPP
990     mv  R11, precise klass java/util/HashMap$Node: 0x00000040d09ba780:Constant:exact *	# ptr, #@loadConP
9a8     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #32 L[2]=sp + #56 L[3]=sp + #16 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:152 (line 640) L[0]=R8 L[1]=sp + #32 L[2]=_ L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=sp + #44 STK[0]=sp + #48
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [36]=NarrowOop [40]=NarrowOop [48]=Oop [56]=Oop off=2476/0x9ac}

9ac     B105: #	out( B33 ) &lt;- in( B104 )  Freq: 1.20714e-05
        # Block is sole successor of call
9ac +   spill [sp, #32] -&gt; R29	# spill size = 32
9b0 +   spill [sp, #16] -&gt; R21	# spill size = 64
9b4 +   spill [sp, #24] -&gt; R18	# spill size = 64
9b8 +   spill [sp, #36] -&gt; R30	# spill size = 32
9bc +   spill [sp, #40] -&gt; R9	# spill size = 32
9c0 +   spill [sp, #48] -&gt; R22	# spill size = 64
9c4 +   spill [sp, #44] -&gt; R20	# spill size = 32
9c8 +   spill R10 -&gt; R24	# spill size = 64
9cc +   spill R29 -&gt; R19	# spill size = 32
9d0 +   j  B33	#@branch

9d4     B106: #	out( N1560 ) &lt;- in( B7 )  Freq: 9.99995e-07
9d4 +   li R11, #-28	# int, #@loadConI
9d8     spill [sp, #8] -&gt; R8	# spill size = 64
9dc +   spill R19 -&gt; [sp, #0]	# spill size = 32
9e0 +   spill R18 -&gt; [sp, #32]	# spill size = 64
9e4 +   spill R28 -&gt; [sp, #40]	# spill size = 32
9e8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.HashMap::putVal @ bci:40 (line 628) L[0]=R8 L[1]=sp + #0 L[2]=sp + #56 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=sp + #40 L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #32 STK[1]=sp + #40
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [32]=Oop [56]=Oop off=2540/0x9ec}
9ec     #@ShouldNotReachHere

9f8     B107: #	out( N1560 ) &lt;- in( B59 )  Freq: 5.19168e-07
9f8 +   spill [sp, #8] -&gt; R8	# spill size = 64
9fc +   li R11, #-42	# int, #@loadConI
a00     spill R18 -&gt; [sp, #0]	# spill size = 64
a04 +   spill R28 -&gt; [sp, #8]	# spill size = 32
a08 +   spill R22 -&gt; [sp, #16]	# spill size = 64
a0c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;array_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:59 (line 629) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=#1 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #0 STK[1]=sp + #8 STK[2]=sp + #16
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=2576/0xa10}
a10     #@ShouldNotReachHere

a1c     B108: #	out( N1560 ) &lt;- in( B6 )  Freq: 3.95126e-07
a1c +   li R11, #-187	# int, #@loadConI
a20     spill [sp, #8] -&gt; R8	# spill size = 64
a24 +   spill R19 -&gt; [sp, #0]	# spill size = 32
a28 +   spill R18 -&gt; [sp, #24]	# spill size = 64
a2c +   spill R7 -&gt; [sp, #32]	# spill size = 32
a30     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:16 (line 626) L[0]=R8 L[1]=sp + #0 L[2]=sp + #56 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=_ L[8]=sp + #32 L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #32
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [56]=Oop off=2612/0xa34}
a34     #@ShouldNotReachHere

a40     B109: #	out( N1560 ) &lt;- in( B27 )  Freq: 2.72698e-07
a40 +   li R11, #-187	# int, #@loadConI
a44     spill [sp, #8] -&gt; R8	# spill size = 64
a48 +   spill R19 -&gt; [sp, #0]	# spill size = 32
a4c +   spill R18 -&gt; [sp, #24]	# spill size = 64
a50 +   spill R29 -&gt; [sp, #32]	# spill size = 64
a54     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:109 (line 635) L[0]=R8 L[1]=sp + #0 L[2]=sp + #56 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=sp + #32 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#1
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [56]=Oop off=2648/0xa58}
a58     #@ShouldNotReachHere

a64     B110: #	out( B61 ) &lt;- in( B82 )  Freq: 2.59577e-07
a64 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
a64     spill R23 -&gt; R11	# spill size = 64
a68 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
a98 +   j  B61	#@branch

a9c     B111: #	out( N1560 ) &lt;- in( B11 )  Freq: 2.11701e-07
a9c +   li R11, #-34	# int, #@loadConI
aa0     spill [sp, #8] -&gt; R8	# spill size = 64
aa4 +   spill R19 -&gt; [sp, #0]	# spill size = 32
aa8 +   spill R18 -&gt; [sp, #24]	# spill size = 64
aac +   spill R29 -&gt; [sp, #32]	# spill size = 64
ab0 +   spill R7 -&gt; [sp, #40]	# spill size = 64
ab4 +   spill R30 -&gt; [sp, #48]	# spill size = 64
ab8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #40 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=sp + #32 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #56 STK[1]=sp + #48
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=2748/0xabc}
abc     #@ShouldNotReachHere

ac8     B112: #	out( N1560 ) &lt;- in( B16 )  Freq: 2.00608e-07
ac8     #@ShouldNotReachHere

ad4     B113: #	out( N1560 ) &lt;- in( B17 )  Freq: 2.00608e-07
ad4     #@ShouldNotReachHere

ae0     B114: #	out( N1560 ) &lt;- in( B19 B18 )  Freq: 2.92382e-07
ae0 +   spill [sp, #8] -&gt; R8	# spill size = 64
ae4 +   li R11, #-187	# int, #@loadConI
ae8     spill R19 -&gt; [sp, #0]	# spill size = 32
aec +   spill R31 -&gt; [sp, #8]	# spill size = 64
af0 +   spill R18 -&gt; [sp, #24]	# spill size = 64
af4 +   spill R29 -&gt; [sp, #32]	# spill size = 64
af8 +   spill R10 -&gt; [sp, #4]	# spill size = 32
afc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:94 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=sp + #32 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #4
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [32]=Oop off=2816/0xb00}
b00     #@ShouldNotReachHere

b0c     B115: #	out( B22 ) &lt;- in( B89 )  Freq: 1.79773e-07
b0c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
b0c     spill R23 -&gt; R11	# spill size = 64
b10 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
b40 +   j  B22	#@branch

b44     B116: #	out( N1560 ) &lt;- in( B45 )  Freq: 1.47856e-07
b44 +   li R11, #-34	# int, #@loadConI
b48     spill [sp, #8] -&gt; R8	# spill size = 64
b4c +   spill R19 -&gt; [sp, #0]	# spill size = 32
b50 +   spill R21 -&gt; [sp, #16]	# spill size = 64
b54 +   spill R18 -&gt; [sp, #24]	# spill size = 64
b58 +   spill R22 -&gt; [sp, #32]	# spill size = 64
b5c +   spill R20 -&gt; [sp, #4]	# spill size = 32
b60 +   spill R7 -&gt; [sp, #40]	# spill size = 64
b64 +   spill R30 -&gt; [sp, #48]	# spill size = 64
b68     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #40 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #32 L[11]=_ L[12]=sp + #4 STK[0]=sp + #56 STK[1]=sp + #48
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=2924/0xb6c}
b6c     #@ShouldNotReachHere

b78     B117: #	out( N1560 ) &lt;- in( B50 )  Freq: 1.40108e-07
b78     #@ShouldNotReachHere

b84     B118: #	out( N1560 ) &lt;- in( B51 )  Freq: 1.40108e-07
b84     #@ShouldNotReachHere

b90     B119: #	out( N1560 ) &lt;- in( B10 )  Freq: 1.00947e-07
b90 +   li R11, #-187	# int, #@loadConI
b94     spill [sp, #8] -&gt; R8	# spill size = 64
b98 +   spill R19 -&gt; [sp, #0]	# spill size = 32
b9c +   spill R18 -&gt; [sp, #24]	# spill size = 64
ba0 +   spill R29 -&gt; [sp, #32]	# spill size = 64
ba4 +   spill R30 -&gt; [sp, #48]	# spill size = 64
ba8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:81 (line 632) L[0]=R8 L[1]=sp + #0 L[2]=sp + #56 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=sp + #32 L[8]=_ L[9]=_ L[10]=_ L[11]=sp + #48 L[12]=_ STK[0]=sp + #48 STK[1]=sp + #56
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop off=2988/0xbac}
bac     #@ShouldNotReachHere

bb8     B120: #	out( N1560 ) &lt;- in( B15 )  Freq: 9.89895e-08
bb8 +   li R11, #-187	# int, #@loadConI
bbc     spill [sp, #8] -&gt; R8	# spill size = 64
bc0 +   spill R19 -&gt; [sp, #0]	# spill size = 32
bc4 +   spill R18 -&gt; [sp, #24]	# spill size = 64
bc8 +   spill R29 -&gt; [sp, #32]	# spill size = 64
bcc +   spill R31 -&gt; [sp, #40]	# spill size = 64
bd0 +   spill R30 -&gt; [sp, #48]	# spill size = 64
bd4 +   spill R7 -&gt; [sp, #4]	# spill size = 32
bd8 +   spill R28 -&gt; [sp, #56]	# spill size = 32
bdc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #40 L[1]=_ L[2]=sp + #48 STK[0]=sp + #4 STK[1]=sp + #56
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #40 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=sp + #32 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [48]=Oop off=3040/0xbe0}
be0     #@ShouldNotReachHere

bec     B121: #	out( N1560 ) &lt;- in( B44 )  Freq: 7.05031e-08
bec +   li R11, #-187	# int, #@loadConI
bf0     spill [sp, #8] -&gt; R8	# spill size = 64
bf4 +   spill R19 -&gt; [sp, #0]	# spill size = 32
bf8 +   spill R21 -&gt; [sp, #16]	# spill size = 64
bfc +   spill R18 -&gt; [sp, #24]	# spill size = 64
c00 +   spill R22 -&gt; [sp, #32]	# spill size = 64
c04 +   spill R20 -&gt; [sp, #4]	# spill size = 32
c08 +   spill R7 -&gt; [sp, #40]	# spill size = 64
c0c +   spill R30 -&gt; [sp, #56]	# spill size = 64
c10     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:193 (line 645) L[0]=R8 L[1]=sp + #0 L[2]=sp + #40 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #32 L[11]=sp + #56 L[12]=sp + #4 STK[0]=sp + #56 STK[1]=sp + #40
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop off=3092/0xc14}
c14     #@ShouldNotReachHere

c20     B122: #	out( N1560 ) &lt;- in( B49 )  Freq: 6.91358e-08
c20 +   spill [sp, #8] -&gt; [sp, #0]	# spill size = 64
c28 +   li R11, #-187	# int, #@loadConI
c2c     spill R19 -&gt; [sp, #8]	# spill size = 32
c30 +   spill R21 -&gt; [sp, #16]	# spill size = 64
c34 +   spill R18 -&gt; [sp, #24]	# spill size = 64
c38 +   spill R22 -&gt; [sp, #32]	# spill size = 64
c3c +   spill R20 -&gt; [sp, #12]	# spill size = 32
c40 +   spill R31 -&gt; [sp, #48]	# spill size = 64
c44 +   spill R30 -&gt; [sp, #56]	# spill size = 64
c48 +   spill R13 -&gt; [sp, #64]	# spill size = 32
c4c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #48 L[1]=_ L[2]=sp + #56 STK[0]=sp + #64 STK[1]=R8
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #48 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #32 L[11]=_ L[12]=sp + #12
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [32]=Oop [48]=Oop [56]=Oop off=3152/0xc50}
c50     #@ShouldNotReachHere

c5c     B123: #	out( B35 ) &lt;- in( B96 )  Freq: 6.06327e-08
c5c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
c5c     spill R23 -&gt; R11	# spill size = 64
c60 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
c90 +   j  B35	#@branch

c94     B124: #	out( N1560 ) &lt;- in( B48 )  Freq: 1e-35
c94 +   spill [sp, #8] -&gt; R8	# spill size = 64
c98 +   li R11, #-34	# int, #@loadConI
c9c     spill R19 -&gt; [sp, #0]	# spill size = 32
ca0 +   spill R21 -&gt; [sp, #8]	# spill size = 64
ca4 +   spill R18 -&gt; [sp, #16]	# spill size = 64
ca8 +   spill R22 -&gt; [sp, #24]	# spill size = 64
cac +   spill R20 -&gt; [sp, #4]	# spill size = 32
cb0 +   spill R31 -&gt; [sp, #40]	# spill size = 64
cb4 +   spill R30 -&gt; [sp, #56]	# spill size = 64
cb8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #40 L[1]=sp + #56 L[2]=_ STK[0]=sp + #56
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #40 L[3]=sp + #8 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #24 L[11]=_ L[12]=sp + #4
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop [56]=Oop off=3260/0xcbc}
cbc     #@ShouldNotReachHere

cc8     B125: #	out( N1560 ) &lt;- in( B14 )  Freq: 1e-35
cc8 +   li R11, #-34	# int, #@loadConI
ccc     spill [sp, #8] -&gt; R8	# spill size = 64
cd0 +   spill R19 -&gt; [sp, #0]	# spill size = 32
cd4 +   spill R18 -&gt; [sp, #24]	# spill size = 64
cd8 +   spill R29 -&gt; [sp, #32]	# spill size = 64
cdc +   spill R31 -&gt; [sp, #40]	# spill size = 64
ce0 +   spill R30 -&gt; [sp, #56]	# spill size = 64
ce4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #40 L[1]=sp + #56 L[2]=_ STK[0]=sp + #56
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #40 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=sp + #32 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop [56]=Oop off=3304/0xce8}
ce8     #@ShouldNotReachHere

cf4     B126: #	out( N1560 ) &lt;- in( B1 )  Freq: 4.76837e-07
cf4 +   li R11, #-187	# int, #@loadConI
cf8     spill R13 -&gt; [sp, #0]	# spill size = 64
cfc +   spill R12 -&gt; [sp, #16]	# spill size = 64
d00 +   spill R12 -&gt; [sp, #24]	# spill size = 64
d04     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::hash @ bci:1 (line 338) L[0]=sp + #24 L[1]=_ STK[0]=sp + #16
        # java.util.HashMap::put @ bci:2 (line 610) L[0]=_ L[1]=sp + #16 L[2]=sp + #0 STK[0]=sp + #8
        # OopMap {[0]=Oop [8]=Oop [16]=Oop [24]=Oop off=3336/0xd08}
d08     #@ShouldNotReachHere

d14     B127: #	out( N1560 ) &lt;- in( B13 )  Freq: 2.00608e-07
d14 +   li R11, #-12	# int, #@loadConI
d18     spill [sp, #8] -&gt; R8	# spill size = 64
d1c +   spill R19 -&gt; [sp, #0]	# spill size = 32
d20 +   spill R18 -&gt; [sp, #24]	# spill size = 64
d24 +   spill R29 -&gt; [sp, #32]	# spill size = 64
d28 +   spill R31 -&gt; [sp, #40]	# spill size = 64
d2c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #40 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #40 L[3]=sp + #16 L[4]=#0 L[5]=#1 L[6]=sp + #24 L[7]=sp + #32 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [16]=Oop [24]=Oop [32]=Oop [40]=Oop off=3376/0xd30}
d30     #@ShouldNotReachHere

d3c     B128: #	out( N1560 ) &lt;- in( B69 )  Freq: 1.73633e-07
d3c +   li R11, #-10	# int, #@loadConI
d40     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:26 (line 627) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#NULL
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {off=3396/0xd44}
d44     #@ShouldNotReachHere

d50     B129: #	out( N1560 ) &lt;- in( B47 )  Freq: 1.40108e-07
d50 +   spill [sp, #8] -&gt; R8	# spill size = 64
d54 +   li R11, #-12	# int, #@loadConI
d58     spill R19 -&gt; [sp, #0]	# spill size = 32
d5c +   spill R21 -&gt; [sp, #8]	# spill size = 64
d60 +   spill R18 -&gt; [sp, #16]	# spill size = 64
d64 +   spill R22 -&gt; [sp, #24]	# spill size = 64
d68 +   spill R20 -&gt; [sp, #4]	# spill size = 32
d6c +   spill R31 -&gt; [sp, #40]	# spill size = 64
d70     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #40 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #40 L[3]=sp + #8 L[4]=#0 L[5]=#1 L[6]=sp + #16 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #24 L[11]=_ L[12]=sp + #4
        # java.util.HashMap::put @ bci:9 (line 610) L[0]=_ L[1]=_ L[2]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop [24]=Oop [40]=Oop off=3444/0xd74}
d74     #@ShouldNotReachHere

d80     B130: #	out( B138 ) &lt;- in( B104 )  Freq: 1.20716e-10
d80      -- 	// exception oop; no code emitted, #@CreateException
d80 +   j  B138	#@branch

d84     B131: #	out( B138 ) &lt;- in( B102 )  Freq: 5.12392e-10
d84      -- 	// exception oop; no code emitted, #@CreateException
d84 +   j  B138	#@branch

d88     B132: #	out( B138 ) &lt;- in( B79 )  Freq: 5.72022e-09
d88      -- 	// exception oop; no code emitted, #@CreateException
d88 +   j  B138	#@branch

d8c     B133: #	out( B139 ) &lt;- in( B77 )  Freq: 2.99699e-08
d8c      -- 	// exception oop; no code emitted, #@CreateException
d8c +   spill R10 -&gt; R11	# spill size = 64
d90 +   j  B139	#@branch

d94     B134: #	out( B138 ) &lt;- in( B75 )  Freq: 6.86125e-08
d94      -- 	// exception oop; no code emitted, #@CreateException
d94 +   j  B138	#@branch

d98     B135: #	out( B138 ) &lt;- in( B73 )  Freq: 7.43365e-08
d98      -- 	// exception oop; no code emitted, #@CreateException
d98 +   j  B138	#@branch

d9c     B136: #	out( B138 ) &lt;- in( B71 )  Freq: 2.48978e-07
d9c      -- 	// exception oop; no code emitted, #@CreateException
d9c +   j  B138	#@branch

da0     B137: #	out( B138 ) &lt;- in( B68 )  Freq: 1.71361e-06
da0      -- 	// exception oop; no code emitted, #@CreateException

da0     B138: #	out( B139 ) &lt;- in( B137 B134 B131 B132 B130 B136 B135 )  Freq: 2.11189e-06
da0 +   spill R10 -&gt; R11	# spill size = 64

da4     B139: #	out( N1560 ) &lt;- in( B133 B138 )  Freq: 2.14186e-06
da4     # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
db0 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='580'>
----------------------- MetaData before Compile_id = 580 ------------------------
{method}
 - this oop:          0x00000040961a1da0
 - method holder:     &apos;java/util/HashMap&apos;
 - constants:         0x000000409619f4e0 constant pool [610] {0x000000409619f4e0} for &apos;java/util/HashMap&apos; cache=0x00000040961a4fd8
 - access:            0xc1000010  final 
 - name:              &apos;putVal&apos;
 - signature:         &apos;(ILjava/lang/Object;Ljava/lang/Object;ZZ)Ljava/lang/Object;&apos;
 - max stack:         8
 - max locals:        13
 - size of params:    6
 - method size:       13
 - highest level:     4
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400832ee20: 0xbabbaa i2c: 0x0000004013930340 c2i: 0x0000004013930398 c2iUV: 0x0000004013930364
 - compiled entry     0x0000004013930398
 - code size:         300
 - code start:        0x00000040961a1b70
 - code end (excl):   0x00000040961a1c9c
 - method data:       0x0000004096485328
 - checked ex length: 0
 - linenumber start:  0x00000040961a1c9c
 - localvar length:   18
 - localvar start:    0x00000040961a1cc4

------------------------ OptoAssembly for Compile_id = 580 -----------------------
#
#  java/lang/Object * ( java/util/HashMap:NotNull *, int, java/lang/Object *, java/lang/Object *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/HashMap:NotNull *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3:c_rarg3   : parm 2: java/lang/Object *
#r018 c_rarg4:c_rarg4   : parm 3: java/lang/Object *
#r020 c_rarg5   : parm 4: int
#r022 c_rarg6   : parm 5: int
# -- Old sp -- Framesize: 112 --
#r263 sp+108: in_preserve
#r262 sp+104: return address
#r261 sp+100: in_preserve
#r260 sp+96: saved fp register
#r259 sp+92: pad2, stack alignment
#r258 sp+88: pad2, stack alignment
#r257 sp+84: Fixed slot 1
#r256 sp+80: Fixed slot 0
#r283 sp+76: spill
#r282 sp+72: spill
#r281 sp+68: spill
#r280 sp+64: spill
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1567: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B68 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=112
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #112
	
03c     lwu  R28, [R11, #36]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap.table
040 +   decode_heap_oop  R18, R28	#@decodeHeapOop
044     spill R16 -&gt; [sp, #28]	# spill size = 32
048 +   spill R15 -&gt; [sp, #24]	# spill size = 32
04c +   spill R14 -&gt; [sp, #16]	# spill size = 64
050 +   spill R13 -&gt; [sp, #8]	# spill size = 64
054 +   spill R12 -&gt; [sp, #0]	# spill size = 32
058 +   spill R11 -&gt; [sp, #32]	# spill size = 64
05c +   beq   R18, zr, B68	#@cmpP_imm0_branch  P=0.171361 C=5503.000000

060     B2: #	out( B106 B3 ) &lt;- in( B1 )  Freq: 0.828639
060 +   lwu  R7, [R18, #12]	# range, #@loadRange
064 +   bleu  R7, zr, B106	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000000 C=4560.000000

068     B3: #	out( B104 B4 ) &lt;- in( B70 B2 )  Freq: 0.999996
068 +   addiw  R28, R7, #-1	#@addI_reg_imm
06c     spill [sp, #0] -&gt; R9	# spill size = 32
070 +   andr  R10, R28, R9	#@andI_reg_reg
074 +   addw  R28, R10, zr	#@convI2L_reg_reg
078 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
07c +   add R28, R18, R28	# ptr, #@addP_reg_reg
080 +   addi  R21, R28, #16	# ptr, #@addP_reg_imm
084 +   ble  R7, zr, B104	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

088     B4: #	out( B55 B5 ) &lt;- in( B3 )  Freq: 0.999995
088 +   lwu  R28, [R21]	# loadN, compressed ptr, #@loadN
08c +   decode_heap_oop  R16, R28	#@decodeHeapOop
090     spill [sp, #32] -&gt; R7	# spill size = 64
094 +   lwu  R11, [R7, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
098     spill [sp, #8] -&gt; R30	# spill size = 64
09c +   encode_heap_oop  R31, R30	#@encodeHeapOop
0a0     spill [sp, #16] -&gt; R20	# spill size = 64
0a4 +   encode_heap_oop  R19, R20	#@encodeHeapOop
0a8 +   mv  R15, NULL	# NULL ptr, #@loadConP0
0ac +   mv  R14, narrowklass: precise klass java/util/HashMap: 0x00000040d014cf90:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0bc +   li R13, #1	# long, #@loadConL
0c0 +   mv  R28, narrowklass: precise klass java/util/HashMap$Node: 0x00000040d014e150:Constant:exact *	# compressed klass ptr, #@loadConNKlass
0d0 +   beq   R16, zr, B55	#@cmpP_imm0_branch  P=0.519171 C=5503.000000

0d4     B5: #	out( B25 B6 ) &lt;- in( B4 )  Freq: 0.480826
0d4 +   lw  R7, [R16, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
0d8 +   li R12, #0	# int, #@loadConI
0dc +   bne  R7, R9, B25	#@cmpI_branch  P=0.559713 C=2646.000000

0e0     B6: #	out( B119 B7 ) &lt;- in( B5 )  Freq: 0.211702
0e0 +   lwu  R28, [R16, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
0e4 +   decode_heap_oop  R29, R28	#@decodeHeapOop
0e8 +   beq  R29, R30, B119	#@cmpP_branch  P=0.000000 C=1165.000000

0ec     B7: #	out( B129 B8 ) &lt;- in( B6 )  Freq: 0.211702
0ec     lwu  R7, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
0f0     NullCheck R30

0f0     B8: #	out( B109 B9 ) &lt;- in( B7 )  Freq: 0.211701
0f0 +   mv  R31, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
100 +   bne  R7, R31, B109	#@cmpN_branch  P=0.000001 C=-1.000000

104     B9: #	out( B17 B10 ) &lt;- in( B8 )  Freq: 0.211701
104 +   # checkcastPP of R30, #@checkCastPP
104     beq  R30, R29, B17	#@cmpP_branch  P=0.064818 C=5338.000000

108     B10: #	out( B126 B11 ) &lt;- in( B9 )  Freq: 0.197979
108     lwu  R7, [R29, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
10c     NullCheck R29

10c     B11: #	out( B125 B12 ) &lt;- in( B10 )  Freq: 0.197979
10c +   lwu  R10, [R30, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
110 +   lb  R28, [R30, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
114 +   bne  R7, R31, B125	#@cmpN_branch  P=0.000000 C=-1.000000

118     B12: #	out( B120 B13 ) &lt;- in( B11 )  Freq: 0.197979
118 +   # checkcastPP of R29, #@checkCastPP
118     lb  R7, [R29, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
11c +   lwu  R11, [R29, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
120 +   decode_heap_oop  R31, R10	#@decodeHeapOop
124 +   bne  R28, R7, B120	#@cmpI_branch  P=0.000000 C=4992.000000

128     B13: #	out( B110 B14 ) &lt;- in( B12 )  Freq: 0.197979
128 +   beq   R31, zr, B110	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

12c     B14: #	out( B111 B15 ) &lt;- in( B13 )  Freq: 0.197979
12c +   decode_heap_oop  R7, R11	#@decodeHeapOop
130 +   lwu  R14, [R31, #12]	# range, #@loadRange
134 +   beq   R7, zr, B111	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

138     B15: #	out( B113 B16 ) &lt;- in( B14 )  Freq: 0.197978
138 +   lwu  R29, [R7, #12]	# range, #@loadRange
13c +   bne  R14, R29, B113	#@cmpI_branch  P=0.000001 C=-1.000000

140     B16: #	out( B112 B17 ) &lt;- in( B15 )  Freq: 0.197978
140 +   addi  R13, R7, #16	# ptr, #@addP_reg_imm
144 +   addi  R11, R31, #16	# ptr, #@addP_reg_imm
148     String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
1d8 +   beq  R10, zr, B112	#@cmpI_reg_imm0_branch  P=0.000000 C=1165.000000

1dc     B17: #	out( B18 ) &lt;- in( B9 B16 )  Freq: 0.2117
1dc +   spill R16 -&gt; R22	# spill size = 64

1e0     B18: #	out( B115 B19 ) &lt;- in( B17 B45 B52 )  Freq: 0.359555
1e0 +   lwu  R28, [R22, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.value
1e4 +   decode_heap_oop  R18, R28	#@decodeHeapOop
1e8     spill [sp, #24] -&gt; R7	# spill size = 32
1ec +   bne  R7, zr, B115	#@cmpI_reg_imm0_branch  P=0.000000 C=1979.000000

1f0     B19: #	out( B86 B20 ) &lt;- in( B18 )  Freq: 0.359555
1f0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1f0     lb  R7, [R23, #56]	# byte, #@loadB
1f4 +   bne  R7, zr, B86	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1f8     B20: #	out( B23 B21 ) &lt;- in( B114 B88 B86 B19 )  Freq: 0.359555
1f8 +   mv  R7, R22	# ptr -&gt; long, #@castP2X
1fc +   mv  R28, R20	# ptr -&gt; long, #@castP2X
200 +   xorr  R28, R28, R7	#@xorL_reg_reg
204 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
208     spill [sp, #32] -&gt; R29	# spill size = 64
20c +   lwu  R9, [R29, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
210 +   mv  R21, narrowklass: precise klass java/util/HashMap: 0x00000040d014cf90:Constant:exact *	# compressed klass ptr, #@loadConNKlass
220 +   sw  R19, [R22, #20]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.value
224 +   beq  R28, zr, B23	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

228     B21: #	out( B23 B22 ) &lt;- in( B20 )  Freq: 0.359195
228 +   beq   R20, zr, B23	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

22c     B22: #	out( B89 B23 ) &lt;- in( B21 )  Freq: 0.358836
22c +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
230 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
23c +   add R10, R28, R7	# ptr, #@addP_reg_reg
240 +   lb  R28, [R10]	# byte, #@loadB
244 +   li R29, #4	# int, #@loadConI
248 +   bne  R28, R29, B89	#@cmpI_branch  P=0.001000 C=-1.000000

24c     B23: #	out( B67 B24 ) &lt;- in( B91 B92 B89 B22 B21 B20 )  Freq: 0.359555
24c +   beq  R9, R21, B67	#@cmpN_branch  P=0.999999 C=-1.000000

250     B24: #	out( N1567 ) &lt;- in( B23 )  Freq: 3.59555e-07
250 +   li R11, #-34	# int, #@loadConI
254     spill R18 -&gt; R8	# spill size = 64
258 +   spill R22 -&gt; [sp, #8]	# spill size = 64
25c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:253 (line 655) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=R8 STK[0]=sp + #32 STK[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop [32]=Oop off=608/0x260}
260     #@ShouldNotReachHere

26c     B25: #	out( B107 B26 ) &lt;- in( B5 )  Freq: 0.269125
26c +   lwu  R10, [R16, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
270 +   lwu  R7, [R16, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
274 +   mv  R29, narrowklass: precise klass java/util/HashMap$TreeNode: 0x00000040d0152830:Constant:exact *	# compressed klass ptr, #@loadConNKlass
284 +   decode_heap_oop  R22, R10	#@decodeHeapOop
288 +   beq  R7, R29, B107	#@cmpN_branch  P=0.000001 C=-1.000000

28c     B26: #	out( B38 B27 ) &lt;- in( B25 )  Freq: 0.269124
28c +   bne   R22, zr, B38	#@cmpP_imm0_branch  P=0.614451 C=1730.000000

290     B27: #	out( B28 ) &lt;- in( B26 )  Freq: 0.103761
290 +   li R21, #0	# int, #@loadConI
294     spill R16 -&gt; R22	# spill size = 64

298     B28: #	out( B77 B29 ) &lt;- in( B40 B27 )  Freq: 0.121269
298 +   bne  R11, R14, B77	#@cmpN_branch  P=0.004717 C=-1.000000

29c     B29: #	out( B102 B30 ) &lt;- in( B28 )  Freq: 0.120697
29c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
29c     ld  R25, [R23, #288]	# ptr, #@loadP
2a0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2a0     ld  R7, [R23, #304]	# ptr, #@loadP
2a4 +   addi  R29, R25, #32	# ptr, #@addP_reg_imm
2a8 +   bgeu  R29, R7, B102	#@cmpP_branch  P=0.000100 C=-1.000000

2ac     B30: #	out( B31 ) &lt;- in( B29 )  Freq: 0.120684
2ac +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2ac     sd  R29, [R23, #288]	# ptr, #@storeP
2b0 +   sd  R13, [R25]	# long, #@storeL
2b4 +   sw  R28, [R25, #8]	# compressed klass ptr, #@storeNKlass
2b8 +   sd  zr, [R25, #24]	# long, #@storeimmL0

2bc     B31: #	out( B32 ) &lt;- in( B103 B30 )  Freq: 0.120697
2bc +   sw  R9, [R25, #12]	# int, #@storeI
2c0 +   sw  R31, [R25, #16]	# compressed ptr, #@storeN
2c4 +   sw  R19, [R25, #20]	# compressed ptr, #@storeN
2c8     
2c8 +   # checkcastPP of R25, #@checkCastPP
2c8     #@membar_release
	fence iorw ow

2cc     B32: #	out( B93 B33 ) &lt;- in( B31 B78 )  Freq: 0.121269
2cc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2cc     lb  R7, [R23, #56]	# byte, #@loadB
2d0 +   bne  R7, zr, B93	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

2d4     B33: #	out( B36 B34 ) &lt;- in( B123 B95 B93 B32 )  Freq: 0.121269
2d4 +   mv  R28, R22	# ptr -&gt; long, #@castP2X
2d8 +   mv  R7, R25	# ptr -&gt; long, #@castP2X
2dc +   xorr  R7, R7, R28	#@xorL_reg_reg
2e0 +   encode_heap_oop  R30, R25	#@encodeHeapOop
2e4 +   srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
2e8 +   li R24, #7	# int, #@loadConI
2ec +   sw  R30, [R22, #24]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.next
2f0 +   beq  R7, zr, B36	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

2f4     B34: #	out( B36 B35 ) &lt;- in( B33 )  Freq: 0.121147
2f4 +   beq   R25, zr, B36	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

2f8     B35: #	out( B96 B36 ) &lt;- in( B34 )  Freq: 0.121026
2f8 +   srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
2fc +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
308 +   add R10, R28, R7	# ptr, #@addP_reg_reg
30c +   lb  R7, [R10]	# byte, #@loadB
310 +   li R29, #4	# int, #@loadConI
314 +   bne  R7, R29, B96	#@cmpI_branch  P=0.001000 C=-1.000000

318     B36: #	out( B64 B37 ) &lt;- in( B98 B99 B96 B35 B34 B33 )  Freq: 0.121269
318 +   blt  R21, R24, B64	#@cmpI_branch  P=1.000000 C=667.000000

31c     B37: #	out( N1567 ) &lt;- in( B36 )  Freq: 5.78253e-08
31c +   spill [sp, #24] -&gt; R7	# spill size = 32
320 +   spill [sp, #28] -&gt; R28	# spill size = 32
324 +   li R11, #-187	# int, #@loadConI
328     spill [sp, #32] -&gt; R8	# spill size = 64
32c +   spill R9 -&gt; [sp, #0]	# spill size = 32
330 +   spill R20 -&gt; [sp, #8]	# spill size = 64
334 +   spill R7 -&gt; [sp, #4]	# spill size = 32
338 +   spill R28 -&gt; [sp, #16]	# spill size = 32
33c +   spill R18 -&gt; [sp, #24]	# spill size = 64
340 +   spill R21 -&gt; [sp, #20]	# spill size = 32
344     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:162 (line 641) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=sp + #8 L[4]=sp + #4 L[5]=sp + #16 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=_ STK[0]=sp + #20 STK[1]=#7
        # OopMap {fp=Oop [8]=Oop [24]=Oop off=840/0x348}
348     #@ShouldNotReachHere

354     B38: #	out( B39 ) &lt;- in( B26 )  Freq: 0.165364
354 +   li R21, #0	# int, #@loadConI

358     B39: #	out( B42 B40 ) &lt;- in( B38 B41 ) Loop( B39-B41 inner ) Freq: 0.193266
358 +   lw  R7, [R22, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
35c +   beq  R7, R9, B42	#@cmpI_branch  P=0.765038 C=1064.000000

360     B40: #	out( B28 B41 ) &lt;- in( B39 )  Freq: 0.0454103
360 +   addiw  R21, R21, #1	#@addI_reg_imm
364 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
364     ld  R7, [R23, #920]	# ptr, #@loadP
368 +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.util.HashMap::putVal @ bci:219 (line 638) L[0]=sp + #32 L[1]=R9 L[2]=R30 L[3]=R20 L[4]=sp + #24 L[5]=sp + #28 L[6]=R18 L[7]=R22 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=R21
        # OopMap {x30=Oop xmethod=NarrowOop x18=Oop x19=NarrowOop esp=Oop xbcp=Oop [32]=Oop off=872/0x368}
36c +   lwu  R7, [R22, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
370 +   decode_heap_oop  R7, R7	#@decodeHeapOop
374 +   beq   R7, zr, B28	#@cmpP_imm0_branch  P=0.385549 C=250.000000

378     B41: #	out( B39 ) &lt;- in( B40 )  Freq: 0.0279024
378 +   spill R7 -&gt; R22	# spill size = 64
37c +   j  B39	#@branch

380     B42: #	out( B121 B43 ) &lt;- in( B39 )  Freq: 0.147856
380 +   lwu  R28, [R22, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.key
384 +   decode_heap_oop  R31, R28	#@decodeHeapOop
388 +   beq  R31, R30, B121	#@cmpP_branch  P=0.000000 C=814.000000

38c     B43: #	out( B130 B44 ) &lt;- in( B42 )  Freq: 0.147856
38c     lwu  R7, [R30, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
390     NullCheck R30

390     B44: #	out( B116 B45 ) &lt;- in( B43 )  Freq: 0.147856
390 +   mv  R29, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
3a0 +   bne  R7, R29, B116	#@cmpN_branch  P=0.000001 C=-1.000000

3a4     B45: #	out( B18 B46 ) &lt;- in( B44 )  Freq: 0.147855
3a4 +   spill R30 -&gt; R15	# spill size = 64
3a8 +   # checkcastPP of R15, #@checkCastPP
3a8     beq  R15, R31, B18	#@cmpP_branch  P=0.064818 C=5338.000000

3ac     B46: #	out( B128 B47 ) &lt;- in( B45 )  Freq: 0.138272
3ac     lwu  R7, [R31, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
3b0     NullCheck R31

3b0     B47: #	out( B124 B48 ) &lt;- in( B46 )  Freq: 0.138272
3b0 +   lwu  R30, [R15, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
3b4 +   lb  R28, [R15, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
3b8 +   bne  R7, R29, B124	#@cmpN_branch  P=0.000000 C=-1.000000

3bc     B48: #	out( B122 B49 ) &lt;- in( B47 )  Freq: 0.138272
3bc +   # checkcastPP of R31, #@checkCastPP
3bc     lb  R8, [R31, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
3c0 +   lwu  R29, [R31, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
3c4 +   decode_heap_oop  R7, R30	#@decodeHeapOop
3c8 +   bne  R28, R8, B122	#@cmpI_branch  P=0.000000 C=4992.000000

3cc     B49: #	out( B117 B50 ) &lt;- in( B48 )  Freq: 0.138272
3cc +   beq   R7, zr, B117	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

3d0     B50: #	out( B118 B51 ) &lt;- in( B49 )  Freq: 0.138271
3d0 +   decode_heap_oop  R28, R29	#@decodeHeapOop
3d4 +   lwu  R14, [R7, #12]	# range, #@loadRange
3d8 +   beq   R28, zr, B118	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

3dc     B51: #	out( B54 B52 ) &lt;- in( B50 )  Freq: 0.138271
3dc +   lwu  R29, [R28, #12]	# range, #@loadRange
3e0 +   bne  R14, R29, B54	#@cmpI_branch  P=0.000001 C=-1.000000

3e4     B52: #	out( B18 B53 ) &lt;- in( B51 )  Freq: 0.138271
3e4 +   addi  R13, R28, #16	# ptr, #@addP_reg_imm
3e8 +   addi  R11, R7, #16	# ptr, #@addP_reg_imm
3ec     String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
47c +   bne  R10, zr, B18	#@cmpI_reg_imm0_branch  P=1.000000 C=814.000000

480     B53: #	out( B54 ) &lt;- in( B52 )  Freq: 6.59328e-08
480 +   spill R10 -&gt; R12	# spill size = 32

484     B54: #	out( N1567 ) &lt;- in( B53 B51 )  Freq: 2.04204e-07
484 +   spill [sp, #24] -&gt; R7	# spill size = 32
488 +   spill [sp, #28] -&gt; R28	# spill size = 32
48c +   spill [sp, #32] -&gt; R8	# spill size = 64
490 +   li R11, #-187	# int, #@loadConI
494     spill R9 -&gt; [sp, #0]	# spill size = 32
498 +   spill R20 -&gt; [sp, #8]	# spill size = 64
49c +   spill R7 -&gt; [sp, #4]	# spill size = 32
4a0 +   spill R28 -&gt; [sp, #16]	# spill size = 32
4a4 +   spill R18 -&gt; [sp, #24]	# spill size = 64
4a8 +   spill R22 -&gt; [sp, #32]	# spill size = 64
4ac +   spill R21 -&gt; [sp, #20]	# spill size = 32
4b0 +   spill R12 -&gt; [sp, #40]	# spill size = 32
4b4 +   spill R15 -&gt; [sp, #48]	# spill size = 64
4b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:206 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #8 L[4]=sp + #4 L[5]=sp + #16 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #32 L[11]=_ L[12]=sp + #20 STK[0]=sp + #40
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop off=1212/0x4bc}
4bc     #@ShouldNotReachHere

4c8     B55: #	out( B75 B56 ) &lt;- in( B4 )  Freq: 0.519169
4c8 +   bne  R11, R14, B75	#@cmpN_branch  P=0.013216 C=-1.000000

4cc     B56: #	out( B100 B57 ) &lt;- in( B55 )  Freq: 0.512308
4cc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
4cc     ld  R22, [R23, #288]	# ptr, #@loadP
4d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
4d0     ld  R7, [R23, #304]	# ptr, #@loadP
4d4 +   addi  R29, R22, #32	# ptr, #@addP_reg_imm
4d8 +   bgeu  R29, R7, B100	#@cmpP_branch  P=0.000100 C=-1.000000

4dc     B57: #	out( B58 ) &lt;- in( B56 )  Freq: 0.512256
4dc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
4dc     sd  R29, [R23, #288]	# ptr, #@storeP
4e0 +   sd  R13, [R22]	# long, #@storeL
4e4 +   sw  R28, [R22, #8]	# compressed klass ptr, #@storeNKlass
4e8 +   sd  zr, [R22, #24]	# long, #@storeimmL0

4ec     B58: #	out( B59 ) &lt;- in( B101 B57 )  Freq: 0.512308
4ec +   sw  R9, [R22, #12]	# int, #@storeI
4f0 +   sw  R31, [R22, #16]	# compressed ptr, #@storeN
4f4 +   sw  R19, [R22, #20]	# compressed ptr, #@storeN
4f8     
4f8 +   #@membar_release
	fence iorw ow
4fc +   # checkcastPP of R22, #@checkCastPP

4fc     B59: #	out( B105 B60 ) &lt;- in( B58 B76 )  Freq: 0.519169
4fc     lwu  R28, [R18, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
500 +   mv  R7, narrowklass: precise klass [Ljava/util/HashMap$Node;: 0x00000040d0150ff0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
510 +   bne  R28, R7, B105	#@cmpN_branch  P=0.000001 C=-1.000000

514     B60: #	out( B79 B61 ) &lt;- in( B59 )  Freq: 0.519168
514 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
514     lb  R28, [R23, #56]	# byte, #@loadB
518 +   bne  R28, zr, B79	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

51c     B61: #	out( B64 B62 ) &lt;- in( B108 B81 B79 B60 )  Freq: 0.519168
51c +   mv  R7, R21	# ptr -&gt; long, #@castP2X
520 +   mv  R28, R22	# ptr -&gt; long, #@castP2X
524 +   xorr  R28, R28, R7	#@xorL_reg_reg
528 +   encode_heap_oop  R29, R22	#@encodeHeapOop
52c +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
530 +   sw  R29, [R21]	# compressed ptr, #@storeN
534 +   beq  R28, zr, B64	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

538     B62: #	out( B64 B63 ) &lt;- in( B61 )  Freq: 0.518649
538 +   beq   R22, zr, B64	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

53c     B63: #	out( B82 B64 ) &lt;- in( B62 )  Freq: 0.51813
53c +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
540 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
54c +   add R10, R28, R7	# ptr, #@addP_reg_reg
550 +   lb  R28, [R10]	# byte, #@loadB
554 +   li R29, #4	# int, #@loadConI
558 +   bne  R28, R29, B82	#@cmpI_branch  P=0.001000 C=-1.000000

55c     B64: #	out( B71 B65 ) &lt;- in( B36 B84 B85 B82 B63 B62 B61 )  Freq: 0.640437
55c +   spill [sp, #32] -&gt; R7	# spill size = 64
560 +   lw  R28, [R7, #24]	# int, #@loadI ! Field: java/util/HashMap.modCount
564 +   lw  R7, [R7, #20]	# int, #@loadI ! Field: java/util/HashMap.size
568 +   spill [sp, #32] -&gt; R29	# spill size = 64
56c +   lw  R30, [R29, #28]	# int, #@loadI ! Field: java/util/HashMap.threshold
570 +   addiw  R29, R7, #1	#@addI_reg_imm
574 +   addiw  R28, R28, #1	#@addI_reg_imm
578     spill [sp, #32] -&gt; R7	# spill size = 64
57c +   sw  R28, [R7, #24]	# int, #@storeI ! Field: java/util/HashMap.modCount
580 +   sw  R29, [R7, #20]	# int, #@storeI ! Field: java/util/HashMap.size
584 +   bgt  R29, R30, B71	#@cmpI_branch  P=0.038876 C=3524.000000

588     B65: #	out( B73 B66 ) &lt;- in( B72 B64 )  Freq: 0.640436
588 +   spill [sp, #32] -&gt; R7	# spill size = 64
58c +   lwu  R7, [R7, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
590 +   mv  R29, narrowklass: precise klass java/util/HashMap: 0x00000040d014cf90:Constant:exact *	# compressed klass ptr, #@loadConNKlass
5a0 +   bne  R7, R29, B73	#@cmpN_branch  P=0.011607 C=-1.000000

5a4     B66: #	out( B67 ) &lt;- in( B65 B74 )  Freq: 0.640436
5a4 +   mv  R18, NULL	# NULL ptr, #@loadConP0

5a8     B67: #	out( N1567 ) &lt;- in( B23 B66 )  Freq: 0.99999
5a8     spill R18 -&gt; R10	# spill size = 64
5ac +   # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
5c4 +   ret	// return register, #@Ret

5c8     B68: #	out( B137 B69 ) &lt;- in( B1 )  Freq: 0.171361
5c8     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:20 (line 627) L[0]=sp + #32 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #24 L[5]=sp + #28 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {[8]=Oop [16]=Oop [32]=Oop off=1484/0x5cc}

5cc     B69: #	out( B127 B70 ) &lt;- in( B68 )  Freq: 0.171358
        # Block is sole successor of call
5cc     lwu  R7, [R10, #12]	# range, #@loadRange
5d0     NullCheck R10

5d0     B70: #	out( B3 ) &lt;- in( B69 )  Freq: 0.171357
5d0 +   spill R10 -&gt; R18	# spill size = 64
5d4 +   j  B3	#@branch

5d8     B71: #	out( B136 B72 ) &lt;- in( B64 )  Freq: 0.0248978
5d8 +   spill R7 -&gt; R11	# spill size = 64
5dc     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect java.util.HashMap::resize
        # java.util.HashMap::putVal @ bci:288 (line 661) L[0]=sp + #32 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=sp + #28 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {[32]=Oop off=1504/0x5e0}

5e0     B72: #	out( B65 ) &lt;- in( B71 )  Freq: 0.0248973
        # Block is sole successor of call
5e0 +   j  B65	#@branch

5e4     B73: #	out( B135 B74 ) &lt;- in( B65 )  Freq: 0.00743365
5e4 +   spill [sp, #32] -&gt; R11	# spill size = 64
5e8 +   spill [sp, #28] -&gt; R12	# spill size = 32
5ec     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.HashMap::afterNodeInsertion
        # java.util.HashMap::putVal @ bci:295 (line 662) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {off=1544/0x608}

608     B74: #	out( B66 ) &lt;- in( B73 )  Freq: 0.0074335
        # Block is sole successor of call
608 +   j  B66	#@branch

60c     B75: #	out( B134 B76 ) &lt;- in( B55 )  Freq: 0.00686125
60c +   spill [sp, #32] -&gt; R8	# spill size = 64
610 +   spill R21 -&gt; [sp, #16]	# spill size = 64
614 +   spill R10 -&gt; [sp, #8]	# spill size = 32
618 +   spill R18 -&gt; [sp, #0]	# spill size = 64
61c +   spill R8 -&gt; R11	# spill size = 64
620 +   spill R9 -&gt; R12	# spill size = 32
624 +   spill R30 -&gt; R13	# spill size = 64
628 +   spill R20 -&gt; R14	# spill size = 64
62c     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.HashMap::newNode
        # java.util.HashMap::putVal @ bci:56 (line 629) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=sp + #28 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #0 STK[1]=sp + #8
        # OopMap {fp=Oop [0]=Oop [16]=Derived_oop_[0] [32]=Oop off=1608/0x648}

648     B76: #	out( B59 ) &lt;- in( B75 )  Freq: 0.00686111
        # Block is sole successor of call
648 +   spill R10 -&gt; R7	# spill size = 64
64c +   spill [sp, #0] -&gt; R18	# spill size = 64
650 +   spill [sp, #8] -&gt; R10	# spill size = 32
654 +   spill [sp, #16] -&gt; R21	# spill size = 64
658 +   spill R7 -&gt; R22	# spill size = 64
65c +   j  B59	#@branch

660     B77: #	out( B133 B78 ) &lt;- in( B28 )  Freq: 0.000572023
660 +   spill [sp, #32] -&gt; R8	# spill size = 64
664 +   spill R21 -&gt; [sp, #4]	# spill size = 32
668 +   spill R22 -&gt; [sp, #40]	# spill size = 64
66c +   spill R18 -&gt; [sp, #16]	# spill size = 64
670 +   spill R20 -&gt; [sp, #8]	# spill size = 64
674 +   spill R9 -&gt; [sp, #0]	# spill size = 32
678 +   spill R8 -&gt; R11	# spill size = 64
67c +   spill R9 -&gt; R12	# spill size = 32
680 +   spill R30 -&gt; R13	# spill size = 64
684 +   spill R20 -&gt; R14	# spill size = 64
688     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.util.HashMap::newNode
        # java.util.HashMap::putVal @ bci:152 (line 640) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=sp + #8 L[4]=sp + #24 L[5]=sp + #28 L[6]=sp + #16 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=sp + #4 STK[0]=sp + #40
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop off=1700/0x6a4}

6a4     B78: #	out( B32 ) &lt;- in( B77 )  Freq: 0.000572011
        # Block is sole successor of call
6a4 +   spill [sp, #0] -&gt; R9	# spill size = 32
6a8 +   spill [sp, #8] -&gt; R20	# spill size = 64
6ac +   spill [sp, #16] -&gt; R18	# spill size = 64
6b0 +   spill [sp, #40] -&gt; R22	# spill size = 64
6b4 +   spill [sp, #4] -&gt; R21	# spill size = 32
6b8 +   spill R10 -&gt; R25	# spill size = 64
6bc +   j  B32	#@branch

6c0     B79: #	out( B61 B80 ) &lt;- in( B60 )  Freq: 0.000519161
6c0 +   lwu  R7, [R21]	# loadN, compressed ptr, #@loadN
6c4 +   decode_heap_oop  R10, R7	#@decodeHeapOop
6c8 +   beq   R10, zr, B61	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

6cc     B80: #	out( B108 B81 ) &lt;- in( B79 )  Freq: 0.000259581
6cc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6cc     ld  R7, [R23, #32]	# int, #@loadL
6d0 +   beq  R7, zr, B108	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

6d4     B81: #	out( B61 ) &lt;- in( B80 )  Freq: 0.000259321
6d4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6d4     ld  R28, [R23, #48]	# ptr, #@loadP
6d8 +   add R28, R28, R7	# ptr, #@addP_reg_reg
6dc +   addi  R7, R7, #-8	#@addL_reg_imm
6e0 +   sd  R10, [R28, #-8]	# ptr, #@storeP
6e4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6e4     sd  R7, [R23, #32]	# long, #@storeL
6e8 +   j  B61	#@branch

6ec     B82: #	out( B64 B83 ) &lt;- in( B63 )  Freq: 0.00051813
6ec +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6ec     ld  R7, [R23, #64]	# int, #@loadL
6f0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6f0     ld  R28, [R23, #80]	# ptr, #@loadP
6f4 +   #@membar_volatile
	fence iorw iorw
6f8 +   lb  R29, [R10]	# byte, #@loadB
6fc +   beq  R29, zr, B64	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

700     B83: #	out( B85 B84 ) &lt;- in( B82 )  Freq: 0.000259065
700 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
704 +   bne  R7, zr, B85	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

708     B84: #	out( B64 ) &lt;- in( B83 )  Freq: 0.000129533
708 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
708     spill R23 -&gt; R11	# spill size = 64
70c +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
73c +   j  B64	#@branch

740     B85: #	out( B64 ) &lt;- in( B83 )  Freq: 0.000129533
740 +   add R28, R28, R7	# ptr, #@addP_reg_reg
744 +   addi  R7, R7, #-8	#@addL_reg_imm
748 +   sd  R10, [R28, #-8]	# ptr, #@storeP
74c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
74c     sd  R7, [R23, #64]	# long, #@storeL
750 +   j  B64	#@branch

754     B86: #	out( B20 B87 ) &lt;- in( B19 )  Freq: 0.00035955
754 +   lwu  R28, [R22, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.value
758 +   decode_heap_oop  R10, R28	#@decodeHeapOop
75c +   beq   R10, zr, B20	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

760     B87: #	out( B114 B88 ) &lt;- in( B86 )  Freq: 0.000179775
760 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
760     ld  R7, [R23, #32]	# int, #@loadL
764 +   beq  R7, zr, B114	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

768     B88: #	out( B20 ) &lt;- in( B87 )  Freq: 0.000179595
768 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
768     ld  R28, [R23, #48]	# ptr, #@loadP
76c +   add R28, R28, R7	# ptr, #@addP_reg_reg
770 +   addi  R7, R7, #-8	#@addL_reg_imm
774 +   sd  R10, [R28, #-8]	# ptr, #@storeP
778 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
778     sd  R7, [R23, #32]	# long, #@storeL
77c +   j  B20	#@branch

780     B89: #	out( B23 B90 ) &lt;- in( B22 )  Freq: 0.000358836
780 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
780     ld  R7, [R23, #64]	# int, #@loadL
784 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
784     ld  R28, [R23, #80]	# ptr, #@loadP
788 +   #@membar_volatile
	fence iorw iorw
78c +   lb  R29, [R10]	# byte, #@loadB
790 +   beq  R29, zr, B23	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

794     B90: #	out( B92 B91 ) &lt;- in( B89 )  Freq: 0.000179418
794 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
798 +   bne  R7, zr, B92	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

79c     B91: #	out( B23 ) &lt;- in( B90 )  Freq: 8.9709e-05
79c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
79c     spill R23 -&gt; R11	# spill size = 64
7a0 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
7d0 +   j  B23	#@branch

7d4     B92: #	out( B23 ) &lt;- in( B90 )  Freq: 8.9709e-05
7d4 +   add R28, R28, R7	# ptr, #@addP_reg_reg
7d8 +   addi  R7, R7, #-8	#@addL_reg_imm
7dc +   sd  R10, [R28, #-8]	# ptr, #@storeP
7e0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7e0     sd  R7, [R23, #64]	# long, #@storeL
7e4 +   j  B23	#@branch

7e8     B93: #	out( B33 B94 ) &lt;- in( B32 )  Freq: 0.000121267
7e8 +   lwu  R28, [R22, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
7ec +   decode_heap_oop  R10, R28	#@decodeHeapOop
7f0 +   beq   R10, zr, B33	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

7f4     B94: #	out( B123 B95 ) &lt;- in( B93 )  Freq: 6.06335e-05
7f4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7f4     ld  R7, [R23, #32]	# int, #@loadL
7f8 +   beq  R7, zr, B123	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

7fc     B95: #	out( B33 ) &lt;- in( B94 )  Freq: 6.05728e-05
7fc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7fc     ld  R28, [R23, #48]	# ptr, #@loadP
800 +   add R28, R28, R7	# ptr, #@addP_reg_reg
804 +   addi  R7, R7, #-8	#@addL_reg_imm
808 +   sd  R10, [R28, #-8]	# ptr, #@storeP
80c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
80c     sd  R7, [R23, #32]	# long, #@storeL
810 +   j  B33	#@branch

814     B96: #	out( B36 B97 ) &lt;- in( B35 )  Freq: 0.000121026
814 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
814     ld  R7, [R23, #64]	# int, #@loadL
818 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
818     ld  R28, [R23, #80]	# ptr, #@loadP
81c +   #@membar_volatile
	fence iorw iorw
820 +   lb  R30, [R10]	# byte, #@loadB
824 +   beq  R30, zr, B36	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

828     B97: #	out( B99 B98 ) &lt;- in( B96 )  Freq: 6.05131e-05
828 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
82c +   bne  R7, zr, B99	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

830     B98: #	out( B36 ) &lt;- in( B97 )  Freq: 3.02565e-05
830 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
830     spill R23 -&gt; R11	# spill size = 64
834 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
864 +   j  B36	#@branch

868     B99: #	out( B36 ) &lt;- in( B97 )  Freq: 3.02565e-05
868 +   add R28, R28, R7	# ptr, #@addP_reg_reg
86c +   addi  R7, R7, #-8	#@addL_reg_imm
870 +   sd  R10, [R28, #-8]	# ptr, #@storeP
874 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
874     sd  R7, [R23, #64]	# long, #@storeL
878 +   j  B36	#@branch

87c     B100: #	out( B132 B101 ) &lt;- in( B56 )  Freq: 5.12393e-05
87c +   spill [sp, #32] -&gt; [sp, #16]	# spill size = 64
884 +   spill [sp, #16] -&gt; R8	# spill size = 64
888 +   spill R19 -&gt; [sp, #64]	# spill size = 32
88c +   spill R31 -&gt; [sp, #52]	# spill size = 32
890 +   spill R21 -&gt; [sp, #56]	# spill size = 64
894 +   spill R10 -&gt; [sp, #48]	# spill size = 32
898 +   spill R18 -&gt; [sp, #40]	# spill size = 64
89c +   spill R9 -&gt; [sp, #24]	# spill size = 32
8a0 +   # checkcastPP of R8, #@checkCastPP
8a0     mv  R11, precise klass java/util/HashMap$Node: 0x00000040d014e150:Constant:exact *	# ptr, #@loadConP
8b8     spill R30 -&gt; [sp, #0]	# spill size = 64
8bc +   spill R20 -&gt; [sp, #8]	# spill size = 64
8c0     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #24 L[2]=sp + #0 L[3]=sp + #8 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:56 (line 629) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=sp + #28 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #40 STK[1]=sp + #48
        # OopMap {fp=Oop [0]=Oop [8]=Oop [32]=Oop [40]=Oop [52]=NarrowOop [56]=Derived_oop_[40] [64]=NarrowOop off=2244/0x8c4}

8c4     B101: #	out( B58 ) &lt;- in( B100 )  Freq: 5.12382e-05
        # Block is sole successor of call
8c4 +   spill R10 -&gt; R7	# spill size = 64
8c8 +   spill [sp, #24] -&gt; R9	# spill size = 32
8cc +   spill [sp, #40] -&gt; R18	# spill size = 64
8d0 +   spill [sp, #48] -&gt; R10	# spill size = 32
8d4 +   spill [sp, #56] -&gt; R21	# spill size = 64
8d8 +   spill [sp, #52] -&gt; R31	# spill size = 32
8dc +   spill [sp, #64] -&gt; R19	# spill size = 32
8e0 +   spill R7 -&gt; R22	# spill size = 64
8e4 +   j  B58	#@branch

8e8     B102: #	out( B131 B103 ) &lt;- in( B29 )  Freq: 1.20717e-05
8e8 +   spill [sp, #32] -&gt; R8	# spill size = 64
8ec +   spill R21 -&gt; [sp, #60]	# spill size = 32
8f0 +   spill R22 -&gt; [sp, #64]	# spill size = 64
8f4 +   spill R19 -&gt; [sp, #56]	# spill size = 32
8f8 +   spill R31 -&gt; [sp, #20]	# spill size = 32
8fc +   spill R18 -&gt; [sp, #48]	# spill size = 64
900 +   spill R20 -&gt; [sp, #40]	# spill size = 64
904 +   spill R9 -&gt; [sp, #16]	# spill size = 32
908 +   # checkcastPP of R8, #@checkCastPP
908     mv  R11, precise klass java/util/HashMap$Node: 0x00000040d014e150:Constant:exact *	# ptr, #@loadConP
920     spill R30 -&gt; [sp, #0]	# spill size = 64
924     CALL,static 0x000000401390d940	#@CallStaticJavaDirect wrapper for: _new_instance_Java
        # java.util.HashMap::newNode @ bci:0 (line 1901) L[0]=_ L[1]=sp + #16 L[2]=sp + #0 L[3]=sp + #40 L[4]=#NULL
        # java.util.HashMap::putVal @ bci:152 (line 640) L[0]=R8 L[1]=sp + #16 L[2]=_ L[3]=sp + #40 L[4]=sp + #24 L[5]=sp + #28 L[6]=sp + #48 L[7]=_ L[8]=_ L[9]=_ L[10]=#NULL L[11]=_ L[12]=sp + #60 STK[0]=sp + #64
        # OopMap {fp=Oop [0]=Oop [20]=NarrowOop [32]=Oop [40]=Oop [48]=Oop [56]=NarrowOop [64]=Oop off=2344/0x928}

928     B103: #	out( B31 ) &lt;- in( B102 )  Freq: 1.20714e-05
        # Block is sole successor of call
928 +   spill [sp, #16] -&gt; R9	# spill size = 32
92c +   spill [sp, #40] -&gt; R20	# spill size = 64
930 +   spill [sp, #48] -&gt; R18	# spill size = 64
934 +   spill [sp, #20] -&gt; R31	# spill size = 32
938 +   spill [sp, #56] -&gt; R19	# spill size = 32
93c +   spill [sp, #64] -&gt; R22	# spill size = 64
940 +   spill [sp, #60] -&gt; R21	# spill size = 32
944 +   spill R10 -&gt; R25	# spill size = 64
948 +   j  B31	#@branch

94c     B104: #	out( N1567 ) &lt;- in( B3 )  Freq: 9.99996e-07
94c +   spill [sp, #24] -&gt; R28	# spill size = 32
950 +   spill [sp, #28] -&gt; R7	# spill size = 32
954 +   li R11, #-28	# int, #@loadConI
958     spill [sp, #32] -&gt; R8	# spill size = 64
95c +   spill R28 -&gt; [sp, #4]	# spill size = 32
960 +   spill R7 -&gt; [sp, #24]	# spill size = 32
964 +   spill R18 -&gt; [sp, #40]	# spill size = 64
968 +   spill R10 -&gt; [sp, #48]	# spill size = 32
96c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.HashMap::putVal @ bci:40 (line 628) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #40 L[7]=_ L[8]=_ L[9]=sp + #48 L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #40 STK[1]=sp + #48
        # OopMap {fp=Oop [8]=Oop [16]=Oop [40]=Oop off=2416/0x970}
970     #@ShouldNotReachHere

97c     B105: #	out( N1567 ) &lt;- in( B59 )  Freq: 5.19169e-07
97c +   li R11, #-42	# int, #@loadConI
980     spill [sp, #32] -&gt; R8	# spill size = 64
984 +   spill R18 -&gt; [sp, #8]	# spill size = 64
988 +   spill R10 -&gt; [sp, #4]	# spill size = 32
98c +   spill R22 -&gt; [sp, #16]	# spill size = 64
990     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;array_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:59 (line 629) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=sp + #28 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #8 STK[1]=sp + #4 STK[2]=sp + #16
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=2452/0x994}
994     #@ShouldNotReachHere

9a0     B106: #	out( N1567 ) &lt;- in( B2 )  Freq: 3.95126e-07
9a0 +   spill [sp, #32] -&gt; R8	# spill size = 64
9a4 +   li R11, #-187	# int, #@loadConI
9a8     spill R15 -&gt; [sp, #4]	# spill size = 32
9ac +   spill R16 -&gt; [sp, #24]	# spill size = 32
9b0 +   spill R18 -&gt; [sp, #32]	# spill size = 64
9b4 +   spill R7 -&gt; [sp, #40]	# spill size = 32
9b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:16 (line 626) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=sp + #40 L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #40
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop off=2492/0x9bc}
9bc     #@ShouldNotReachHere

9c8     B107: #	out( N1567 ) &lt;- in( B25 )  Freq: 2.72698e-07
9c8 +   spill [sp, #24] -&gt; R7	# spill size = 32
9cc +   spill [sp, #32] -&gt; R8	# spill size = 64
9d0 +   li R11, #-187	# int, #@loadConI
9d4     spill R7 -&gt; [sp, #4]	# spill size = 32
9d8 +   spill R18 -&gt; [sp, #32]	# spill size = 64
9dc +   spill R16 -&gt; [sp, #40]	# spill size = 64
9e0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:109 (line 635) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#1
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop off=2532/0x9e4}
9e4     #@ShouldNotReachHere

9f0     B108: #	out( B61 ) &lt;- in( B80 )  Freq: 2.59577e-07
9f0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
9f0     spill R23 -&gt; R11	# spill size = 64
9f4 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
a24 +   j  B61	#@branch

a28     B109: #	out( N1567 ) &lt;- in( B8 )  Freq: 2.11701e-07
a28 +   spill [sp, #24] -&gt; R28	# spill size = 32
a2c +   spill [sp, #32] -&gt; R8	# spill size = 64
a30 +   li R11, #-34	# int, #@loadConI
a34     spill R28 -&gt; [sp, #4]	# spill size = 32
a38 +   spill R18 -&gt; [sp, #32]	# spill size = 64
a3c +   spill R16 -&gt; [sp, #40]	# spill size = 64
a40 +   spill R29 -&gt; [sp, #56]	# spill size = 64
a44     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #8 STK[1]=sp + #56
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop [56]=Oop off=2632/0xa48}
a48     #@ShouldNotReachHere

a54     B110: #	out( N1567 ) &lt;- in( B13 )  Freq: 2.00608e-07
a54     #@ShouldNotReachHere

a60     B111: #	out( N1567 ) &lt;- in( B14 )  Freq: 2.00608e-07
a60     #@ShouldNotReachHere

a6c     B112: #	out( B113 ) &lt;- in( B16 )  Freq: 9.44034e-08
a6c +   spill R10 -&gt; R12	# spill size = 32

a70     B113: #	out( N1567 ) &lt;- in( B112 B15 )  Freq: 2.92382e-07
a70 +   spill [sp, #24] -&gt; R7	# spill size = 32
a74 +   spill [sp, #28] -&gt; R28	# spill size = 32
a78 +   spill [sp, #32] -&gt; R8	# spill size = 64
a7c +   li R11, #-187	# int, #@loadConI
a80     spill R30 -&gt; [sp, #8]	# spill size = 64
a84 +   spill R7 -&gt; [sp, #4]	# spill size = 32
a88 +   spill R28 -&gt; [sp, #24]	# spill size = 32
a8c +   spill R18 -&gt; [sp, #32]	# spill size = 64
a90 +   spill R16 -&gt; [sp, #40]	# spill size = 64
a94 +   spill R12 -&gt; [sp, #28]	# spill size = 32
a98     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:94 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=sp + #28
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop off=2716/0xa9c}
a9c     #@ShouldNotReachHere

aa8     B114: #	out( B20 ) &lt;- in( B87 )  Freq: 1.79773e-07
aa8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
aa8     spill R23 -&gt; R11	# spill size = 64
aac +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
adc +   j  B20	#@branch

ae0     B115: #	out( N1567 ) &lt;- in( B18 )  Freq: 1.71449e-07
ae0 +   li R11, #-187	# int, #@loadConI
ae4     spill [sp, #32] -&gt; R8	# spill size = 64
ae8 +   spill R20 -&gt; [sp, #0]	# spill size = 64
aec +   spill R22 -&gt; [sp, #8]	# spill size = 64
af0 +   spill R18 -&gt; [sp, #16]	# spill size = 64
af4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:236 (line 653) L[0]=R8 L[1]=_ L[2]=_ L[3]=sp + #0 L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #8 L[11]=_ L[12]=sp + #16 STK[0]=sp + #24
        # OopMap {fp=Oop [0]=Oop [8]=Oop [16]=Oop off=2808/0xaf8}
af8     #@ShouldNotReachHere

b04     B116: #	out( N1567 ) &lt;- in( B44 )  Freq: 1.47856e-07
b04 +   spill [sp, #24] -&gt; R28	# spill size = 32
b08 +   spill [sp, #28] -&gt; R7	# spill size = 32
b0c +   spill [sp, #32] -&gt; R8	# spill size = 64
b10 +   li R11, #-34	# int, #@loadConI
b14     spill R9 -&gt; [sp, #0]	# spill size = 32
b18 +   spill R20 -&gt; [sp, #16]	# spill size = 64
b1c +   spill R28 -&gt; [sp, #4]	# spill size = 32
b20 +   spill R7 -&gt; [sp, #24]	# spill size = 32
b24 +   spill R18 -&gt; [sp, #32]	# spill size = 64
b28 +   spill R22 -&gt; [sp, #40]	# spill size = 64
b2c +   spill R21 -&gt; [sp, #28]	# spill size = 32
b30 +   spill R30 -&gt; [sp, #48]	# spill size = 64
b34 +   spill R31 -&gt; [sp, #56]	# spill size = 64
b38     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=_ L[12]=sp + #28 STK[0]=sp + #48 STK[1]=sp + #56
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=2876/0xb3c}
b3c     #@ShouldNotReachHere

b48     B117: #	out( N1567 ) &lt;- in( B49 )  Freq: 1.40108e-07
b48     #@ShouldNotReachHere

b54     B118: #	out( N1567 ) &lt;- in( B50 )  Freq: 1.40108e-07
b54     #@ShouldNotReachHere

b60     B119: #	out( N1567 ) &lt;- in( B6 )  Freq: 1.00947e-07
b60 +   spill [sp, #24] -&gt; R28	# spill size = 32
b64 +   spill [sp, #32] -&gt; R8	# spill size = 64
b68 +   li R11, #-187	# int, #@loadConI
b6c     spill R28 -&gt; [sp, #4]	# spill size = 32
b70 +   spill R18 -&gt; [sp, #32]	# spill size = 64
b74 +   spill R16 -&gt; [sp, #40]	# spill size = 64
b78 +   spill R29 -&gt; [sp, #56]	# spill size = 64
b7c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:81 (line 632) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=sp + #56 L[12]=_ STK[0]=sp + #56 STK[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop [56]=Oop off=2944/0xb80}
b80     #@ShouldNotReachHere

b8c     B120: #	out( N1567 ) &lt;- in( B12 )  Freq: 9.89895e-08
b8c +   spill [sp, #24] -&gt; R31	# spill size = 32
b90 +   spill [sp, #28] -&gt; R10	# spill size = 32
b94 +   spill [sp, #32] -&gt; R8	# spill size = 64
b98 +   li R11, #-187	# int, #@loadConI
b9c     spill R31 -&gt; [sp, #4]	# spill size = 32
ba0 +   spill R10 -&gt; [sp, #24]	# spill size = 32
ba4 +   spill R18 -&gt; [sp, #32]	# spill size = 64
ba8 +   spill R16 -&gt; [sp, #40]	# spill size = 64
bac +   spill R30 -&gt; [sp, #48]	# spill size = 64
bb0 +   spill R29 -&gt; [sp, #56]	# spill size = 64
bb4 +   spill R28 -&gt; [sp, #28]	# spill size = 32
bb8 +   spill R7 -&gt; [sp, #64]	# spill size = 32
bbc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #48 L[1]=_ L[2]=sp + #56 STK[0]=sp + #28 STK[1]=sp + #64
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=3008/0xbc0}
bc0     #@ShouldNotReachHere

bcc     B121: #	out( N1567 ) &lt;- in( B42 )  Freq: 7.05031e-08
bcc +   spill [sp, #24] -&gt; R28	# spill size = 32
bd0 +   spill [sp, #28] -&gt; R7	# spill size = 32
bd4 +   spill [sp, #32] -&gt; R8	# spill size = 64
bd8 +   li R11, #-187	# int, #@loadConI
bdc     spill R9 -&gt; [sp, #0]	# spill size = 32
be0 +   spill R20 -&gt; [sp, #16]	# spill size = 64
be4 +   spill R28 -&gt; [sp, #4]	# spill size = 32
be8 +   spill R7 -&gt; [sp, #24]	# spill size = 32
bec +   spill R18 -&gt; [sp, #32]	# spill size = 64
bf0 +   spill R22 -&gt; [sp, #40]	# spill size = 64
bf4 +   spill R21 -&gt; [sp, #28]	# spill size = 32
bf8 +   spill R30 -&gt; [sp, #48]	# spill size = 64
bfc +   spill R31 -&gt; [sp, #64]	# spill size = 64
c00     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:193 (line 645) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=sp + #64 L[12]=sp + #28 STK[0]=sp + #64 STK[1]=sp + #48
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [64]=Oop off=3076/0xc04}
c04     #@ShouldNotReachHere

c10     B122: #	out( N1567 ) &lt;- in( B48 )  Freq: 6.91358e-08
c10 +   spill [sp, #24] -&gt; R7	# spill size = 32
c14 +   spill [sp, #28] -&gt; R29	# spill size = 32
c18 +   spill [sp, #32] -&gt; [sp, #0]	# spill size = 64
c20 +   li R11, #-187	# int, #@loadConI
c24     spill R9 -&gt; [sp, #8]	# spill size = 32
c28 +   spill R20 -&gt; [sp, #16]	# spill size = 64
c2c +   spill R7 -&gt; [sp, #12]	# spill size = 32
c30 +   spill R29 -&gt; [sp, #24]	# spill size = 32
c34 +   spill R18 -&gt; [sp, #32]	# spill size = 64
c38 +   spill R22 -&gt; [sp, #40]	# spill size = 64
c3c +   spill R21 -&gt; [sp, #28]	# spill size = 32
c40 +   spill R15 -&gt; [sp, #56]	# spill size = 64
c44 +   spill R31 -&gt; [sp, #64]	# spill size = 64
c48 +   spill R28 -&gt; [sp, #72]	# spill size = 32
c4c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #56 L[1]=_ L[2]=sp + #64 STK[0]=sp + #72 STK[1]=R8
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=sp + #0 L[1]=sp + #8 L[2]=sp + #56 L[3]=sp + #16 L[4]=sp + #12 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=_ L[12]=sp + #28
        # OopMap {[0]=Oop [16]=Oop [32]=Oop [40]=Oop [56]=Oop [64]=Oop off=3152/0xc50}
c50     #@ShouldNotReachHere

c5c     B123: #	out( B33 ) &lt;- in( B94 )  Freq: 6.06327e-08
c5c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
c5c     spill R23 -&gt; R11	# spill size = 64
c60 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
c90 +   j  B33	#@branch

c94     B124: #	out( N1567 ) &lt;- in( B47 )  Freq: 1e-35
c94 +   spill [sp, #24] -&gt; R7	# spill size = 32
c98 +   spill [sp, #28] -&gt; R28	# spill size = 32
c9c +   spill [sp, #32] -&gt; R8	# spill size = 64
ca0 +   li R11, #-34	# int, #@loadConI
ca4     spill R9 -&gt; [sp, #0]	# spill size = 32
ca8 +   spill R20 -&gt; [sp, #8]	# spill size = 64
cac +   spill R7 -&gt; [sp, #4]	# spill size = 32
cb0 +   spill R28 -&gt; [sp, #16]	# spill size = 32
cb4 +   spill R18 -&gt; [sp, #24]	# spill size = 64
cb8 +   spill R22 -&gt; [sp, #32]	# spill size = 64
cbc +   spill R21 -&gt; [sp, #20]	# spill size = 32
cc0 +   spill R15 -&gt; [sp, #48]	# spill size = 64
cc4 +   spill R31 -&gt; [sp, #64]	# spill size = 64
cc8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=sp + #64 L[2]=_ STK[0]=sp + #64
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #8 L[4]=sp + #4 L[5]=sp + #16 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #32 L[11]=_ L[12]=sp + #20
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop [64]=Oop off=3276/0xccc}
ccc     #@ShouldNotReachHere

cd8     B125: #	out( N1567 ) &lt;- in( B11 )  Freq: 1e-35
cd8 +   spill [sp, #24] -&gt; R7	# spill size = 32
cdc +   spill [sp, #32] -&gt; R8	# spill size = 64
ce0 +   li R11, #-34	# int, #@loadConI
ce4     spill R7 -&gt; [sp, #4]	# spill size = 32
ce8 +   spill R18 -&gt; [sp, #32]	# spill size = 64
cec +   spill R16 -&gt; [sp, #40]	# spill size = 64
cf0 +   spill R30 -&gt; [sp, #48]	# spill size = 64
cf4 +   spill R29 -&gt; [sp, #64]	# spill size = 64
cf8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=sp + #64 L[2]=_ STK[0]=sp + #64
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [64]=Oop off=3324/0xcfc}
cfc     #@ShouldNotReachHere

d08     B126: #	out( N1567 ) &lt;- in( B10 )  Freq: 2.00608e-07
d08 +   spill [sp, #24] -&gt; R28	# spill size = 32
d0c +   spill [sp, #32] -&gt; R8	# spill size = 64
d10 +   li R11, #-12	# int, #@loadConI
d14     spill R28 -&gt; [sp, #4]	# spill size = 32
d18 +   spill R18 -&gt; [sp, #32]	# spill size = 64
d1c +   spill R16 -&gt; [sp, #40]	# spill size = 64
d20 +   spill R30 -&gt; [sp, #48]	# spill size = 64
d24     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:91 (line 633) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop off=3368/0xd28}
d28     #@ShouldNotReachHere

d34     B127: #	out( N1567 ) &lt;- in( B69 )  Freq: 1.73633e-07
d34 +   li R11, #-10	# int, #@loadConI
d38     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::putVal @ bci:26 (line 627) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ STK[0]=#NULL
        # OopMap {off=3388/0xd3c}
d3c     #@ShouldNotReachHere

d48     B128: #	out( N1567 ) &lt;- in( B46 )  Freq: 1.40108e-07
d48 +   spill [sp, #24] -&gt; R28	# spill size = 32
d4c +   spill [sp, #28] -&gt; R7	# spill size = 32
d50 +   spill [sp, #32] -&gt; R8	# spill size = 64
d54 +   li R11, #-12	# int, #@loadConI
d58     spill R9 -&gt; [sp, #0]	# spill size = 32
d5c +   spill R20 -&gt; [sp, #8]	# spill size = 64
d60 +   spill R28 -&gt; [sp, #4]	# spill size = 32
d64 +   spill R7 -&gt; [sp, #16]	# spill size = 32
d68 +   spill R18 -&gt; [sp, #24]	# spill size = 64
d6c +   spill R22 -&gt; [sp, #32]	# spill size = 64
d70 +   spill R21 -&gt; [sp, #20]	# spill size = 32
d74 +   spill R15 -&gt; [sp, #48]	# spill size = 64
d78     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #48 L[1]=#NULL L[2]=_ STK[0]=#NULL
        # java.util.HashMap::putVal @ bci:203 (line 646) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #8 L[4]=sp + #4 L[5]=sp + #16 L[6]=sp + #24 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #32 L[11]=_ L[12]=sp + #20
        # OopMap {fp=Oop [8]=Oop [24]=Oop [32]=Oop [48]=Oop off=3452/0xd7c}
d7c     #@ShouldNotReachHere

d88     B129: #	out( N1567 ) &lt;- in( B7 )  Freq: 1.00947e-07
d88 +   spill [sp, #24] -&gt; R28	# spill size = 32
d8c +   spill [sp, #32] -&gt; R8	# spill size = 64
d90 +   li R11, #-187	# int, #@loadConI
d94     spill R28 -&gt; [sp, #4]	# spill size = 32
d98 +   spill R18 -&gt; [sp, #32]	# spill size = 64
d9c +   spill R16 -&gt; [sp, #40]	# spill size = 64
da0 +   spill R29 -&gt; [sp, #48]	# spill size = 64
da4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:85 (line 632) L[0]=R8 L[1]=sp + #0 L[2]=sp + #8 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #28 L[6]=sp + #32 L[7]=sp + #40 L[8]=_ L[9]=_ L[10]=_ L[11]=sp + #48 L[12]=_ STK[0]=sp + #8
        # OopMap {fp=Oop [8]=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop off=3496/0xda8}
da8     #@ShouldNotReachHere

db4     B130: #	out( N1567 ) &lt;- in( B43 )  Freq: 7.05031e-08
db4 +   spill [sp, #24] -&gt; R28	# spill size = 32
db8 +   spill [sp, #28] -&gt; R7	# spill size = 32
dbc +   spill [sp, #32] -&gt; R8	# spill size = 64
dc0 +   li R11, #-187	# int, #@loadConI
dc4     spill R9 -&gt; [sp, #0]	# spill size = 32
dc8 +   spill R20 -&gt; [sp, #16]	# spill size = 64
dcc +   spill R28 -&gt; [sp, #4]	# spill size = 32
dd0 +   spill R7 -&gt; [sp, #24]	# spill size = 32
dd4 +   spill R18 -&gt; [sp, #32]	# spill size = 64
dd8 +   spill R22 -&gt; [sp, #40]	# spill size = 64
ddc +   spill R21 -&gt; [sp, #28]	# spill size = 32
de0 +   spill R30 -&gt; [sp, #48]	# spill size = 64
de4 +   spill R31 -&gt; [sp, #56]	# spill size = 64
de8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::putVal @ bci:197 (line 645) L[0]=R8 L[1]=sp + #0 L[2]=sp + #48 L[3]=sp + #16 L[4]=sp + #4 L[5]=sp + #24 L[6]=sp + #32 L[7]=_ L[8]=_ L[9]=_ L[10]=sp + #40 L[11]=sp + #56 L[12]=sp + #28 STK[0]=sp + #48
        # OopMap {fp=Oop [16]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=3564/0xdec}
dec     #@ShouldNotReachHere

df8     B131: #	out( B138 ) &lt;- in( B102 )  Freq: 1.20717e-10
df8      -- 	// exception oop; no code emitted, #@CreateException
df8 +   spill R10 -&gt; R11	# spill size = 64
dfc +   j  B138	#@branch

e00     B132: #	out( B138 ) &lt;- in( B100 )  Freq: 5.12393e-10
e00      -- 	// exception oop; no code emitted, #@CreateException
e00 +   spill R10 -&gt; R11	# spill size = 64
e04 +   j  B138	#@branch

e08     B133: #	out( B138 ) &lt;- in( B77 )  Freq: 5.72023e-09
e08      -- 	// exception oop; no code emitted, #@CreateException
e08 +   spill R10 -&gt; R11	# spill size = 64
e0c +   j  B138	#@branch

e10     B134: #	out( B138 ) &lt;- in( B75 )  Freq: 6.86125e-08
e10      -- 	// exception oop; no code emitted, #@CreateException
e10 +   spill R10 -&gt; R11	# spill size = 64
e14 +   j  B138	#@branch

e18     B135: #	out( B138 ) &lt;- in( B73 )  Freq: 7.43365e-08
e18      -- 	// exception oop; no code emitted, #@CreateException
e18 +   spill R10 -&gt; R11	# spill size = 64
e1c +   j  B138	#@branch

e20     B136: #	out( B138 ) &lt;- in( B71 )  Freq: 2.48978e-07
e20      -- 	// exception oop; no code emitted, #@CreateException
e20 +   spill R10 -&gt; R11	# spill size = 64
e24 +   j  B138	#@branch

e28     B137: #	out( B138 ) &lt;- in( B68 )  Freq: 1.71361e-06
e28      -- 	// exception oop; no code emitted, #@CreateException
e28 +   spill R10 -&gt; R11	# spill size = 64

e2c     B138: #	out( N1567 ) &lt;- in( B137 B134 B132 B133 B131 B136 B135 )  Freq: 2.11189e-06
e2c     # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
e38 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='599'>
----------------------- MetaData before Compile_id = 599 ------------------------
{method}
 - this oop:          0x00000040963b8c98
 - method holder:     &apos;java/util/ImmutableCollections$SetN$SetNIterator&apos;
 - constants:         0x00000040963b8858 constant pool [70] {0x00000040963b8858} for &apos;java/util/ImmutableCollections$SetN$SetNIterator&apos; cache=0x00000040963b8e80
 - access:            0x81000001  public 
 - name:              &apos;hasNext&apos;
 - signature:         &apos;()Z&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c5e7300
 - code size:         13
 - code start:        0x00000040963b8c78
 - code end (excl):   0x00000040963b8c85
 - method data:       0x00000040964eea88
 - checked ex length: 0
 - linenumber start:  0x00000040963b8c85
 - localvar length:   1
 - localvar start:    0x00000040963b8c8a
 - compiled code: nmethod  23923  559       3       java.util.ImmutableCollections$SetN$SetNIterator::hasNext (13 bytes)

------------------------ OptoAssembly for Compile_id = 599 -----------------------
#
#  bool ( java/util/ImmutableCollections$SetN$SetNIterator:NotNull:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/ImmutableCollections$SetN$SetNIterator:NotNull:exact *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N26: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B4 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     lw  R28, [R11, #12]	# int, #@loadI ! Field: java/util/ImmutableCollections$SetN$SetNIterator.remaining
040 +   ble  R28, zr, B4	#@cmpI_reg_imm0_branch  P=0.038698 C=5375.000000

044     B2: #	out( B3 ) &lt;- in( B1 )  Freq: 0.961302
044 +   li R10, #1	# int, #@loadConI

048     B3: #	out( N26 ) &lt;- in( B4 B2 )  Freq: 1
048     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
060 +   ret	// return register, #@Ret

064     B4: #	out( B3 ) &lt;- in( B1 )  Freq: 0.0386977
064 +   li R10, #0	# int, #@loadConI
068 +   j  B3	#@branch

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='600'>
----------------------- MetaData before Compile_id = 600 ------------------------
{method}
 - this oop:          0x00000040963b8dd0
 - method holder:     &apos;java/util/ImmutableCollections$SetN$SetNIterator&apos;
 - constants:         0x00000040963b8858 constant pool [70] {0x00000040963b8858} for &apos;java/util/ImmutableCollections$SetN$SetNIterator&apos; cache=0x00000040963b8e80
 - access:            0xc1000001  public 
 - name:              &apos;next&apos;
 - signature:         &apos;()Ljava/lang/Object;&apos;
 - max stack:         4
 - max locals:        4
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c5d25c0
 - code size:         90
 - code start:        0x00000040963b8d30
 - code end (excl):   0x00000040963b8d8a
 - method data:       0x00000040964dd4e8
 - checked ex length: 0
 - linenumber start:  0x00000040963b8d8a
 - localvar length:   4
 - localvar start:    0x00000040963b8d9c
 - compiled code: nmethod  23952  525       3       java.util.ImmutableCollections$SetN$SetNIterator::next (90 bytes)

------------------------ OptoAssembly for Compile_id = 600 -----------------------
#
#  java/lang/Object * ( java/util/ImmutableCollections$SetN$SetNIterator:NotNull:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/ImmutableCollections$SetN$SetNIterator:NotNull:exact *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N112: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B11 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lwu  R28, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$SetN$SetNIterator.this$0
040 +   lw  R13, [R11, #12]	# int, #@loadI ! Field: java/util/ImmutableCollections$SetN$SetNIterator.remaining
044 +   decode_heap_oop  R7, R28	#@decodeHeapOop
048     spill R11 -&gt; R31	# spill size = 64
04c +   ble  R13, zr, B11	#@cmpI_reg_imm0_branch  P=0.000000 C=5375.000000

050     B2: #	out( B12 B3 ) &lt;- in( B1 )  Freq: 1
050     lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$SetN.elements (constant)
054     NullCheck R7

054     B3: #	out( B13 B4 ) &lt;- in( B2 )  Freq: 0.999999
054 +   decode_heap_oop  R8, R7	#@decodeHeapOop
058     lwu  R7, [R8, #12]	# range, #@loadRange
05c     NullCheck R8

05c     B4: #	out( B5 ) &lt;- in( B3 )  Freq: 0.999997
05c +   lw  R29, [R11, #16]	# int, #@loadI ! Field: java/util/ImmutableCollections$SetN$SetNIterator.idx
060 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP

060     B5: #	out( B9 B6 ) &lt;- in( B4 B7 ) Loop( B5-B7 inner ) Freq: 1.94437
060     addiw  R29, R29, #-1	#@addI_reg_imm
064 +   blt  R29, zr, B9	#@cmpI_reg_imm0_branch  P=0.009760 C=10451.000000

068     B6: #	out( B10 B7 ) &lt;- in( B5 B9 )  Freq: 1.94437
068 +   bgeu  R29, R7, B10	#@cmpU_branch  P=0.000001 C=-1.000000

06c     B7: #	out( B5 B8 ) &lt;- in( B6 )  Freq: 1.94436
06c +   addw  R28, R29, zr	#@convI2L_reg_reg
070 +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
074 +   add R28, R8, R28	# ptr, #@addP_reg_reg
078 +   lwu  R28, [R28, #16]	# loadN, compressed ptr, #@loadN
07c +   decode_heap_oop  R10, R28	#@decodeHeapOop
080 +   ld  R30, [R23, #920]	# ptr, #@loadP
084 +   lwu zr, [R30]	# Safepoint: poll for GC, #@safePoint        # java.util.ImmutableCollections$SetN$SetNIterator::next @ bci:62 (line 976) L[0]=R31 L[1]=R10 L[2]=R29 L[3]=R7 STK[0]=R10
        # OopMap {xmethod=Oop c_rarg0=Oop fp=Oop off=132/0x84}
088 +   beq   R10, zr, B5	#@cmpP_imm0_branch  P=0.485695 C=10451.000000

08c     B8: #	out( N112 ) &lt;- in( B7 )  Freq: 0.999996
08c +   addiw  R28, R13, #-1	#@addI_reg_imm
090 +   sw  R29, [R31, #16]	# int, #@storeI ! Field: java/util/ImmutableCollections$SetN$SetNIterator.idx
094 +   sw  R28, [R31, #12]	# int, #@storeI ! Field: java/util/ImmutableCollections$SetN$SetNIterator.remaining
098     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0b0 +   ret	// return register, #@Ret

0b4     B9: #	out( B6 ) &lt;- in( B5 )  Freq: 0.0189767
0b4 +   addiw  R29, R7, #-1	#@addI_reg_imm
0b8 +   j  B6	#@branch

0bc     B10: #	out( N112 ) &lt;- in( B6 )  Freq: 1.97018e-06
0bc +   li R11, #-28	# int, #@loadConI
0c0     spill R7 -&gt; [sp, #4]	# spill size = 32
0c4 +   spill R29 -&gt; [sp, #8]	# spill size = 32
0c8 +   spill R31 -&gt; [sp, #16]	# spill size = 64
0cc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ImmutableCollections$SetN$SetNIterator::next @ bci:59 (line 976) L[0]=sp + #16 L[1]=_ L[2]=sp + #8 L[3]=sp + #4 STK[0]=R8 STK[1]=sp + #8
        # OopMap {fp=Oop [16]=Oop off=208/0xd0}
0d0     #@ShouldNotReachHere

0dc     B11: #	out( N112 ) &lt;- in( B1 )  Freq: 5e-07
0dc +   li R11, #-187	# int, #@loadConI
0e0     spill R31 -&gt; R8	# spill size = 64
0e4 +   spill R13 -&gt; [sp, #0]	# spill size = 32
0e8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.ImmutableCollections$SetN$SetNIterator::next @ bci:4 (line 961) L[0]=R8 L[1]=_ L[2]=_ L[3]=_ STK[0]=sp + #0
        # OopMap {fp=Oop off=236/0xec}
0ec     #@ShouldNotReachHere

0f8     B12: #	out( N112 ) &lt;- in( B2 )  Freq: 1.01328e-06
0f8 +   li R11, #-10	# int, #@loadConI
0fc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN$SetNIterator::next @ bci:16 (line 964) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # OopMap {off=256/0x100}
100     #@ShouldNotReachHere

10c     B13: #	out( N112 ) &lt;- in( B3 )  Freq: 1.01328e-06
10c +   li R11, #-10	# int, #@loadConI
110     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN$SetNIterator::next @ bci:19 (line 964) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#NULL
        # OopMap {off=276/0x114}
114     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='602'>
----------------------- MetaData before Compile_id = 602 ------------------------
{method}
 - this oop:          0x0000004096547f08
 - method holder:     &apos;java/lang/module/ModuleDescriptor$Exports&apos;
 - constants:         0x00000040965476a8 constant pool [132] {0x00000040965476a8} for &apos;java/lang/module/ModuleDescriptor$Exports&apos; cache=0x00000040965485c0
 - access:            0x81000001  public 
 - name:              &apos;isQualified&apos;
 - signature:         &apos;()Z&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c5f1f00
 - code size:         18
 - code start:        0x0000004096547ee0
 - code end (excl):   0x0000004096547ef2
 - method data:       0x0000004096443fd8
 - checked ex length: 0
 - linenumber start:  0x0000004096547ef2
 - localvar length:   1
 - localvar start:    0x0000004096547efa
 - compiled code: nmethod  23976  588       3       java.lang.module.ModuleDescriptor$Exports::isQualified (18 bytes)

------------------------ OptoAssembly for Compile_id = 602 -----------------------
#
#  bool ( java/lang/module/ModuleDescriptor$Exports:NotNull:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/module/ModuleDescriptor$Exports:NotNull:exact *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N57: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B8 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     lwu  R28, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/module/ModuleDescriptor$Exports.targets
040 +   decode_heap_oop  R7, R28	#@decodeHeapOop
044     lwu  R29, [R7, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
048     NullCheck R7

048     B2: #	out( B5 B3 ) &lt;- in( B1 )  Freq: 0.999999
048 +   mv  R28, narrowklass: precise klass java/util/ImmutableCollections$SetN: 0x00000040d011b070:Constant:exact *	# compressed klass ptr, #@loadConNKlass
058 +   beq  R29, R28, B5	#@cmpN_branch  P=0.634108 C=-1.000000

05c     B3: #	out( B7 B4 ) &lt;- in( B2 )  Freq: 0.365891
05c +   mv  R30, narrowklass: precise klass java/util/ImmutableCollections$Set12: 0x00000040d011b140:Constant:exact *	# compressed klass ptr, #@loadConNKlass
06c +   bne  R29, R30, B7	#@cmpN_branch  P=0.000001 C=-1.000000

070     B4: #	out( B6 ) &lt;- in( B3 )  Freq: 0.365891
070 +   li R10, #1	# int, #@loadConI
074 +   j  B6	#@branch

078     B5: #	out( B6 ) &lt;- in( B2 )  Freq: 0.634108
078 +   # checkcastPP of R7, #@checkCastPP
078     lw  R28, [R7, #12]	# int, #@loadI ! Field: java/util/ImmutableCollections$SetN.size (constant)
07c +   snez  R10, R28	#@convI2Bool

080     B6: #	out( N57 ) &lt;- in( B5 B4 )  Freq: 0.999999
080     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
098 +   ret	// return register, #@Ret

09c     B7: #	out( N57 ) &lt;- in( B3 )  Freq: 3.65891e-07
09c +   li R11, #-58	# int, #@loadConI
0a0     spill R7 -&gt; R8	# spill size = 64
0a4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;bimorphic&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.module.ModuleDescriptor$Exports::isQualified @ bci:4 (line 426) L[0]=_ STK[0]=R8
        # OopMap {fp=Oop off=168/0xa8}
0a8     #@ShouldNotReachHere

0b4     B8: #	out( N57 ) &lt;- in( B1 )  Freq: 1.01328e-06
0b4 +   li R11, #-10	# int, #@loadConI
0b8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.module.ModuleDescriptor$Exports::isQualified @ bci:4 (line 426) L[0]=_ STK[0]=#NULL
        # OopMap {off=188/0xbc}
0bc +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='604'>
----------------------- MetaData before Compile_id = 604 ------------------------
{method}
 - this oop:          0x0000004096164410
 - method holder:     &apos;java/util/ImmutableCollections$SetN&apos;
 - constants:         0x00000040961639e8 constant pool [168] {0x00000040961639e8} for &apos;java/util/ImmutableCollections$SetN&apos; cache=0x0000004096164c20
 - access:            0x81000001  public 
 - name:              &apos;contains&apos;
 - signature:         &apos;(Ljava/lang/Object;)Z&apos;
 - max stack:         3
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      13
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824bb30: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c4fb4c0
 - code size:         26
 - code start:        0x00000040961643d0
 - code end (excl):   0x00000040961643ea
 - method data:       0x0000004096482100
 - checked ex length: 0
 - linenumber start:  0x00000040961643ea
 - localvar length:   2
 - localvar start:    0x00000040961643f6
 - compiled code: nmethod  24334  155       3       java.util.ImmutableCollections$SetN::contains (26 bytes)

------------------------ OptoAssembly for Compile_id = 604 -----------------------
#
#  bool ( java/util/ImmutableCollections$SetN:NotNull:exact *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/ImmutableCollections$SetN:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 96 --
#r263 sp+92: in_preserve
#r262 sp+88: return address
#r261 sp+84: in_preserve
#r260 sp+80: saved fp register
#r259 sp+76: pad2, stack alignment
#r258 sp+72: pad2, stack alignment
#r257 sp+68: Fixed slot 1
#r256 sp+64: Fixed slot 0
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1895: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B171 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=96
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #96
	
03c     spill R11 -&gt; [sp, #0]	# spill size = 64
040 +   spill R12 -&gt; [sp, #48]	# spill size = 64
044     lwu  R29, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
048     NullCheck R12

048     B2: #	out( B52 B3 ) &lt;- in( B1 )  Freq: 1
048 +   lw  R7, [R11, #12]	# int, #@loadI ! Field: java/util/ImmutableCollections$SetN.size (constant)
04c +   ble  R7, zr, B52	#@cmpI_reg_imm0_branch  P=0.009503 C=9471.000000

050     B3: #	out( B66 B4 ) &lt;- in( B2 )  Freq: 0.990497
050 +   mv  R28, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
060 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
060     bne  R29, R28, B66	#@cmpN_branch  P=0.000451 C=-1.000000

064     B4: #	out( B23 B5 ) &lt;- in( B3 )  Freq: 0.99005
064 +   spill R12 -&gt; R10	# spill size = 64
068 +   # checkcastPP of R10, #@checkCastPP
068     lw  R30, [R10, #12]	# int, #@loadI ! Field: java/lang/String.hash
06c +   bne  R30, zr, B23	#@cmpI_reg_imm0_branch  P=0.474144 C=5376.000000

070     B5: #	out( B60 B6 ) &lt;- in( B4 )  Freq: 0.520624
070 +   lbu  R28, [R10, #17]	# byte, #@loadUB ! Field: java/lang/String.hashIsZero
074 +   bne  R28, zr, B60	#@cmpI_reg_imm0_branch  P=0.001062 C=2826.000000

078     B6: #	out( B147 B7 ) &lt;- in( B5 )  Freq: 0.520071
078 +   lwu  R7, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
07c +   lb  R8, [R10, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
080 +   decode_heap_oop  R13, R7	#@decodeHeapOop
084 +   bne  R8, zr, B147	#@cmpI_reg_imm0_branch  P=0.000000 C=115940.000000

088     B7: #	out( B170 B8 ) &lt;- in( B6 )  Freq: 0.520071
088     lwu  R12, [R13, #12]	# range, #@loadRange
08c     NullCheck R13

08c     B8: #	out( B56 B9 ) &lt;- in( B7 )  Freq: 0.52007
08c +   bleu  R12, zr, B56	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.056079 C=18260.000000

090     B9: #	out( B142 B10 ) &lt;- in( B8 )  Freq: 0.490905
090 +   addiw  R28, R12, #-1	#@addI_reg_imm
094 +   bgeu  R28, R12, B142	#@cmpU_branch  P=0.000001 C=-1.000000

098     B10: #	out( B143 B11 ) &lt;- in( B9 )  Freq: 0.490905
098 +   li R7, #1	# int, #@loadConI
09c +   addiw  R14, R12, #-3	#@addI_reg_imm
0a0 +   lbu  R30, [R13, #16]	# byte, #@loadUB
0a4 +   ble  R14, R7, B143	#@cmpI_branch  P=0.000001 C=-1.000000

0a8     B11: #	out( B144 B12 ) &lt;- in( B10 )  Freq: 0.490904
0a8 +   slliw  R7, R30, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0ac +   li R28, #1	# int, #@loadConI
0b0 +   subw  R31, R7, R30	#@subI_reg_reg
0b4 +   bleu  R12, R28, B144	#@cmpU_branch  P=0.000001 C=-1.000000

0b8     B12: #	out( B145 B13 ) &lt;- in( B11 )  Freq: 0.490904
0b8 +   li R28, #4	# int, #@loadConI
0bc +   bleu  R12, R28, B145	#@cmpU_branch  P=0.000001 C=-1.000000

0c0     B13: #	out( B14 ) &lt;- in( B12 )  Freq: 0.490903
0c0 +   li R28, #1	# int, #@loadConI
0c4 +   li R16, #1	# int, #@loadConI
0c8     spill R28 -&gt; [sp, #12]	# spill size = 32

0cc     B14: #	out( B15 ) &lt;- in( B13 B16 ) Loop( B14-B16 ) Freq: 8.7538
0cc +   subw  R28, R12, R16	#@subI_reg_reg
0d0 +   addiw  R7, R28, #-3	#@addI_reg_imm
0d4 +   li R28, #0	# int, #@loadConI
0d8     CMove R7, (R14 lt R16), R7, R28	#@cmovI_cmpI
	
0e0 +   li R28, #4000	# int, #@loadConI
0e8 +   li R30, #4000	# int, #@loadConI
0f0     CMove R7, (R7 gtu R30), R7, R28	#@cmovI_cmpU
	
0f8 +   addw  R17, R7, R16	#@addI_reg_reg
        nop 	# 2 bytes pad for loops and calls

100     B15: #	out( B15 B16 ) &lt;- in( B14 B15 ) Loop( B15-B15 inner main of N157 strip mined) Freq: 156.098
100 +   addw  R7, R16, zr	#@convI2L_reg_reg
104 +   add R7, R13, R7	# ptr, #@addP_reg_reg
108 +   lbu  R30, [R7, #16]	# byte, #@loadUB
10c +   addw  R31, R31, R30	#@addI_reg_reg
110 +   lbu  R28, [R7, #17]	# byte, #@loadUB
114 +   slliw  R30, R31, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
118 +   subw  R31, R30, R31	#@subI_reg_reg
11c +   addw  R31, R31, R28	#@addI_reg_reg
120 +   lbu  R30, [R7, #18]	# byte, #@loadUB
124 +   slliw  R11, R31, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
128 +   subw  R28, R11, R31	#@subI_reg_reg
12c +   addw  R30, R28, R30	#@addI_reg_reg
130 +   lbu  R7, [R7, #19]	# byte, #@loadUB
134 +   slliw  R28, R30, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
138 +   subw  R30, R28, R30	#@subI_reg_reg
13c +   addw  R30, R30, R7	#@addI_reg_reg
140 +   slliw  R7, R30, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
144 +   addiw  R16, R16, #4	#@addI_reg_imm
148 +   subw  R31, R7, R30	#@subI_reg_reg
14c +   blt  R16, R17, B15	#@cmpI_loop  P=0.943921 C=17236.000000

150     B16: #	out( B14 B17 ) &lt;- in( B15 )  Freq: 8.7538
150 +   ld  R7, [R23, #920]	# ptr, #@loadP
154 +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::hashCode @ bci:37 (line 196) L[0]=_ L[1]=R30 L[2]=R13 L[3]=R12 L[4]=R16 L[5]=_
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=R10 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #0 L[1]=R10 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {c_rarg0=Oop c_rarg3=Oop [0]=Oop [48]=Oop off=340/0x154}
158 +   blt  R16, R14, B14	#@cmpI_branch  P=0.943921 C=17236.000000

15c     B17: #	out( B21 B18 ) &lt;- in( B143 B16 )  Freq: 0.490904
15c +   bge  R16, R12, B21	#@cmpI_branch  P=0.500000 C=-1.000000

160     B18: #	out( B149 B19 ) &lt;- in( B17 )  Freq: 0.245452
160 +   # castII of R16, #@castII
160     bgeu  R16, R12, B149	#@cmpU_branch  P=0.000001 C=-1.000000

164     B19: #	out( B150 B20 ) &lt;- in( B18 )  Freq: 0.245452
164 +   spill R16 -&gt; R28	# spill size = 32
168 +   # castII of R28, #@castII
168     bgeu  R28, R12, B150	#@cmpU_branch  P=0.000001 C=-1.000000

16c     B20: #	out( B20 B21 ) &lt;- in( B19 B20 ) Loop( B20-B20 inner post of N1959) Freq: 0.490903
16c +   addw  R7, R16, zr	#@convI2L_reg_reg
170 +   add R7, R13, R7	# ptr, #@addP_reg_reg
174 +   slliw  R31, R30, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
178 +   lbu  R7, [R7, #16]	# byte, #@loadUB
17c +   subw  R28, R31, R30	#@subI_reg_reg
180 +   addiw  R16, R16, #1	#@addI_reg_imm
184 +   addw  R30, R28, R7	#@addI_reg_reg
188 +   blt  R16, R12, B20	#@cmpI_loop  P=0.500000 C=17236.000000

18c     B21: #	out( B57 B22 ) &lt;- in( B20 B17 )  Freq: 0.490903
18c +   beq  R30, zr, B57	#@cmpI_reg_imm0_branch  P=0.000354 C=2823.000000

190     B22: #	out( B24 ) &lt;- in( B21 )  Freq: 0.490729
190 +   sw  R30, [R10, #12]	# int, #@storeI ! Field: java/lang/String.hash
194 +   j  B24	#@branch

198     B23: #	out( B24 ) &lt;- in( B4 )  Freq: 0.469427
198 +   li R28, #1	# int, #@loadConI
19c     spill R28 -&gt; [sp, #12]	# spill size = 32

1a0     B24: #	out( B169 B25 ) &lt;- in( B22 B57 B60 B23 B106 )  Freq: 0.990494
1a0 +   spill [sp, #0] -&gt; R7	# spill size = 64
1a4 +   lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$SetN.elements (constant)
1a8 +   decode_heap_oop  R31, R7	#@decodeHeapOop
1ac     lwu  R28, [R31, #12]	# range, #@loadRange
1b0     NullCheck R31

1b0     B25: #	out( B138 B26 ) &lt;- in( B24 )  Freq: 0.990493
1b0 +   bleu  R28, zr, B138	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

1b4     B26: #	out( B54 B27 ) &lt;- in( B25 )  Freq: 0.990492
1b4 +   remw  R7, R30, R28	#@modI
1b8 +   xorr  R30, R7, R28	#@xorI_reg_reg
1bc     spill R7 -&gt; [sp, #8]	# spill size = 32
1c0 +   blt  R30, zr, B54	#@cmpI_reg_imm0_branch  P=0.099851 C=11387.000000

1c4     B27: #	out( B137 B28 ) &lt;- in( B26 B55 )  Freq: 0.990492
1c4 +   spill [sp, #8] -&gt; R7	# spill size = 32
1c8 +   addw  R7, R7, zr	#@convI2L_reg_reg
1cc +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
1d0 +   add R7, R31, R7	# ptr, #@addP_reg_reg
1d4     spill [sp, #8] -&gt; R10	# spill size = 32
1d8 +   bgeu  R10, R28, B137	#@cmpU_branch  P=0.000001 C=-1.000000

1dc     B28: #	out( B50 B29 ) &lt;- in( B27 )  Freq: 0.990491
1dc +   lwu  R30, [R7, #16]	# loadN, compressed ptr, #@loadN
1e0 +   decode_heap_oop  R10, R30	#@decodeHeapOop
1e4 +   beq   R10, zr, B50	#@cmpP_imm0_branch  P=0.440489 C=24970.000000

1e8     B29: #	out( B127 B30 ) &lt;- in( B28 )  Freq: 0.554191
1e8 +   mv  R30, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
1f8 +   bne  R29, R30, B127	#@cmpN_branch  P=0.000143 C=-1.000000

1fc     B30: #	out( B51 B31 ) &lt;- in( B29 )  Freq: 0.554112
1fc +   spill [sp, #48] -&gt; R15	# spill size = 64
200 +   # checkcastPP of R15, #@checkCastPP
200     beq  R15, R10, B51	#@cmpP_branch  P=0.064818 C=5338.000000

204     B31: #	out( B168 B32 ) &lt;- in( B30 )  Freq: 0.518195
204 +   lwu  R7, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
208 +   lb  R12, [R15, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
20c +   bne  R7, R30, B168	#@cmpN_branch  P=0.000000 C=-1.000000

210     B32: #	out( B146 B33 ) &lt;- in( B31 )  Freq: 0.518195
210 +   # checkcastPP of R10, #@checkCastPP
210     lb  R8, [R10, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
214 +   bne  R12, R8, B146	#@cmpI_branch  P=0.000000 C=4992.000000

218     B33: #	out( B141 B34 ) &lt;- in( B32 )  Freq: 0.518195
218 +   lwu  R7, [R15, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
21c +   decode_heap_oop  R17, R7	#@decodeHeapOop
220 +   lwu  R30, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
224 +   beq   R17, zr, B141	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

228     B34: #	out( B139 B35 ) &lt;- in( B33 )  Freq: 0.518194
228 +   decode_heap_oop  R7, R30	#@decodeHeapOop
22c +   lwu  R16, [R17, #12]	# range, #@loadRange
230 +   beq   R7, zr, B139	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

234     B35: #	out( B37 B36 ) &lt;- in( B34 )  Freq: 0.518194
234 +   lwu  R29, [R7, #12]	# range, #@loadRange
238 +   addi  R9, R17, #16	# ptr, #@addP_reg_imm
23c +   bne  R16, R29, B37	#@cmpI_branch  P=0.001000 C=-1.000000

240     B36: #	out( B51 B37 ) &lt;- in( B35 )  Freq: 0.517676
240 +   spill R16 -&gt; R14	# spill size = 32
244 +   addi  R13, R7, #16	# ptr, #@addP_reg_imm
248     spill R9 -&gt; R11	# spill size = 64
24c +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
2dc +   bne  R10, zr, B51	#@cmpI_reg_imm0_branch  P=0.007014 C=13972.000000

2e0     B37: #	out( B59 B38 ) &lt;- in( B35 B36 )  Freq: 0.514563
2e0 +   spill [sp, #8] -&gt; R7	# spill size = 32
2e4 +   addiw  R29, R7, #1	#@addI_reg_imm
2e8     spill R29 -&gt; [sp, #8]	# spill size = 32
2ec +   beq  R29, R28, B59	#@cmpI_branch  P=0.008360 C=13875.000000

2f0     B38: #	out( B140 B39 ) &lt;- in( B59 B37 )  Freq: 0.514563
2f0 +   spill [sp, #8] -&gt; R7	# spill size = 32
2f4 +   addw  R7, R7, zr	#@convI2L_reg_reg
2f8 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
2fc +   add R7, R31, R7	# ptr, #@addP_reg_reg
300     spill [sp, #8] -&gt; R30	# spill size = 32
304 +   bgeu  R30, R28, B140	#@cmpU_branch  P=0.000001 C=-1.000000

308     B39: #	out( B50 B40 ) &lt;- in( B38 )  Freq: 0.514562
308 +   lwu  R29, [R7, #16]	# loadN, compressed ptr, #@loadN
30c +   decode_heap_oop  R10, R29	#@decodeHeapOop
310 +   beq   R10, zr, B50	#@cmpP_imm0_branch  P=0.440489 C=13875.000000

314     B40: #	out( B41 ) &lt;- in( B39 )  Freq: 0.287903
314 +   mv  R18, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
        nop 	# 6 bytes pad for loops and calls

330     B41: #	out( B51 B42 ) &lt;- in( B40 B49 ) Loop( B41-B49 inner ) Freq: 0.599271
330 +   beq  R15, R10, B51	#@cmpP_branch  P=0.064818 C=5338.000000

334     B42: #	out( B168 B43 ) &lt;- in( B41 )  Freq: 0.560427
334 +   lwu  R7, [R10, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
338 +   bne  R7, R18, B168	#@cmpN_branch  P=0.000000 C=-1.000000

33c     B43: #	out( B146 B44 ) &lt;- in( B42 )  Freq: 0.560427
33c +   # checkcastPP of R10, #@checkCastPP
33c     lwu  R7, [R10, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
340 +   lb  R8, [R10, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
344 +   decode_heap_oop  R7, R7	#@decodeHeapOop
348 +   bne  R12, R8, B146	#@cmpI_branch  P=0.000000 C=4992.000000

34c     B44: #	out( B139 B45 ) &lt;- in( B43 )  Freq: 0.560427
34c +   beq   R7, zr, B139	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

350     B45: #	out( B47 B46 ) &lt;- in( B44 )  Freq: 0.560426
350 +   lwu  R30, [R7, #12]	# range, #@loadRange
354 +   bne  R16, R30, B47	#@cmpI_branch  P=0.001000 C=-1.000000

358     B46: #	out( B51 B47 ) &lt;- in( B45 )  Freq: 0.559866
358 +   spill R16 -&gt; R14	# spill size = 32
35c +   addi  R13, R7, #16	# ptr, #@addP_reg_imm
360     spill R9 -&gt; R11	# spill size = 64
364 +   String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
3f4 +   bne  R10, zr, B51	#@cmpI_reg_imm0_branch  P=0.007014 C=13972.000000

3f8     B47: #	out( B58 B48 ) &lt;- in( B45 B46 )  Freq: 0.5565
3f8 +   spill [sp, #8] -&gt; R7	# spill size = 32
3fc +   addiw  R7, R7, #1	#@addI_reg_imm
400     spill R7 -&gt; [sp, #8]	# spill size = 32
404 +   beq  R7, R28, B58	#@cmpI_branch  P=0.008360 C=13875.000000

408     B48: #	out( B140 B49 ) &lt;- in( B58 B47 )  Freq: 0.5565
408 +   ld  R7, [R23, #920]	# ptr, #@loadP
40c +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.util.ImmutableCollections$SetN::probe @ bci:53 (line 1017) L[0]=sp + #0 L[1]=sp + #48 L[2]=sp + #8 L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {xmethod=Oop c_rarg5=Oop c_rarg7=Oop x9=Derived_oop_c_rarg7 [0]=Oop [48]=Oop off=1036/0x40c}
410 +   spill [sp, #8] -&gt; R7	# spill size = 32
414 +   addw  R7, R7, zr	#@convI2L_reg_reg
418 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
41c +   add R7, R31, R7	# ptr, #@addP_reg_reg
420     spill [sp, #8] -&gt; R30	# spill size = 32
424 +   bgeu  R30, R28, B140	#@cmpU_branch  P=0.000001 C=-1.000000

428     B49: #	out( B41 B50 ) &lt;- in( B48 )  Freq: 0.556499
428 +   lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN
42c +   decode_heap_oop  R10, R7	#@decodeHeapOop
430 +   bne   R10, zr, B41	#@cmpP_imm0_branch  P=0.559511 C=13875.000000

434     B50: #	out( B51 ) &lt;- in( B39 B49 B134 B28 )  Freq: 0.908168
434 +   li R7, #-1	# int, #@loadConI
438     spill [sp, #8] -&gt; R28	# spill size = 32
43c +   subw  R7, R7, R28	#@subI_reg_reg
440     spill R7 -&gt; [sp, #8]	# spill size = 32

444     B51: #	out( B53 B52 ) &lt;- in( B30 B41 B36 B46 B129 B50 )  Freq: 0.990488
444 +   spill [sp, #8] -&gt; R28	# spill size = 32
448 +   bge  R28, zr, B53	#@cmpI_reg_imm0_branch  P=0.010766 C=9381.000000

44c     B52: #	out( B53 ) &lt;- in( B51 B2 )  Freq: 0.989326
44c +   li R28, #0	# int, #@loadConI
450     spill R28 -&gt; [sp, #12]	# spill size = 32

454     B53: #	out( N1895 ) &lt;- in( B52 B51 )  Freq: 0.99999
454 +   spill [sp, #12] -&gt; R10	# spill size = 32
458 +   # pop frame 96
	add  sp, sp, #96
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
470 +   ret	// return register, #@Ret

474     B54: #	out( B155 B55 ) &lt;- in( B26 )  Freq: 0.0989013
474 +   addw  R7, R7, R28	#@addI_reg_reg
478     spill [sp, #8] -&gt; R10	# spill size = 32
47c +   beq  R10, zr, B155	#@cmpI_reg_imm0_branch  P=0.000000 C=1137.000000

480     B55: #	out( B27 ) &lt;- in( B54 )  Freq: 0.0989013
480 +   spill R7 -&gt; [sp, #8]	# spill size = 32
484 +   j  B27	#@branch

488     B56: #	out( B57 ) &lt;- in( B8 )  Freq: 0.0291649
488 +   li R28, #1	# int, #@loadConI
48c     spill R28 -&gt; [sp, #12]	# spill size = 32

490     B57: #	out( B24 ) &lt;- in( B21 B56 )  Freq: 0.0293388
490 +   spill [sp, #12] -&gt; R28	# spill size = 32
494 +   sb  R28, [R10, #17]	# byte, #@storeB ! Field: java/lang/String.hashIsZero
498 +   li R30, #0	# int, #@loadConI
49c +   j  B24	#@branch

4a0     B58: #	out( B48 ) &lt;- in( B47 )  Freq: 0.00465255
4a0 +   li R29, #0	# int, #@loadConI
4a4     spill R29 -&gt; [sp, #8]	# spill size = 32
4a8 +   j  B48	#@branch

4ac     B59: #	out( B38 ) &lt;- in( B37 )  Freq: 0.00430194
4ac +   li R7, #0	# int, #@loadConI
4b0     spill R7 -&gt; [sp, #8]	# spill size = 32
4b4 +   j  B38	#@branch

4b8     B60: #	out( B24 ) &lt;- in( B5 )  Freq: 0.000552679
4b8 +   li R7, #1	# int, #@loadConI
4bc +   li R30, #0	# int, #@loadConI
4c0     spill R7 -&gt; [sp, #12]	# spill size = 32
4c4 +   j  B24	#@branch

4c8     B61: #	out( B185 B62 ) &lt;- in( B114 B115 B116 ) top-of-loop Freq: 9.27684e-07
4c8 +   spill R14 -&gt; [sp, #40]	# spill size = 32
4cc +   spill R12 -&gt; [sp, #36]	# spill size = 32
4d0 +   spill R28 -&gt; [sp, #32]	# spill size = 32
4d4 +   spill R31 -&gt; [sp, #24]	# spill size = 64
4d8 +   spill R15 -&gt; [sp, #16]	# spill size = 64
4dc +   spill R29 -&gt; [sp, #8]	# spill size = 32
4e0     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.ImmutableCollections$SetN::hashCode @ bci:33 (line 996) L[0]=_ L[1]=_ L[2]=sp + #24 L[3]=sp + #32 L[4]=sp + #36 L[5]=_ STK[0]=sp + #40
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:4 (line 508) L[0]=sp + #16 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [48]=Oop off=1276/0x4fc}

4fc     B62: #	out( B63 ) &lt;- in( B61 )  Freq: 9.27665e-07
        # Block is sole successor of call
4fc +   spill [sp, #8] -&gt; R29	# spill size = 32
500 +   spill [sp, #16] -&gt; R15	# spill size = 64
504 +   spill [sp, #24] -&gt; R31	# spill size = 64
508 +   spill [sp, #32] -&gt; R28	# spill size = 32
50c +   spill [sp, #36] -&gt; R12	# spill size = 32
510 +   spill [sp, #40] -&gt; R14	# spill size = 32

514     B63: #	out( B64 ) &lt;- in( B62 B117 ) top-of-loop Freq: 0.000309539
514 +   addw  R14, R10, R14	#@addI_reg_reg
        nop 	# 4 bytes pad for loops and calls

520     B64: #	out( B113 B65 ) &lt;- in( B63 B113 ) top-of-loop Freq: 0.000619077
520 +   addiw  R12, R12, #1	#@addI_reg_imm
524 +   blt  R12, R28, B113	#@cmpI_loop  P=0.581041 C=3696.000000

528     B65: #	out( B72 ) &lt;- in( B64 )  Freq: 0.000259368
528 +   j  B72	#@branch

52c     B66: #	out( B156 B67 ) &lt;- in( B3 )  Freq: 0.000446388
52c +   mv  R7, narrowklass: precise klass java/lang/module/ModuleDescriptor$Exports: 0x00000040d0924560:Constant:exact *	# compressed klass ptr, #@loadConNKlass
53c +   bne  R29, R7, B156	#@cmpN_branch  P=0.000001 C=-1.000000

540     B67: #	out( B172 B68 ) &lt;- in( B66 )  Freq: 0.000446387
540 +   spill R12 -&gt; R15	# spill size = 64
544 +   # checkcastPP of R15, #@checkCastPP
544     lwu  R28, [R15, #12]	# loadN, compressed ptr, #@loadN ! Field: java/lang/module/ModuleDescriptor$Exports.mods
548 +   decode_heap_oop  R8, R28	#@decodeHeapOop
54c     lwu  R7, [R8, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
550     NullCheck R8

550     B68: #	out( B157 B69 ) &lt;- in( B67 )  Freq: 0.000446387
550 +   mv  R30, narrowklass: precise klass java/util/ImmutableCollections$SetN: 0x00000040d01dd400:Constant:exact *	# compressed klass ptr, #@loadConNKlass
560 +   bne  R7, R30, B157	#@cmpN_branch  P=0.000001 C=-1.000000

564     B69: #	out( B173 B70 ) &lt;- in( B68 )  Freq: 0.000446387
564 +   # checkcastPP of R8, #@checkCastPP
564     lwu  R7, [R8, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$SetN.elements (constant)
568 +   decode_heap_oop  R31, R7	#@decodeHeapOop
56c     lwu  R28, [R31, #12]	# range, #@loadRange
570     NullCheck R31

570     B70: #	out( B111 B71 ) &lt;- in( B69 )  Freq: 0.000446386
570 +   bgtu  R28, zr, B111	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.581041 C=6361.000000

574     B71: #	out( B72 ) &lt;- in( B70 )  Freq: 0.000187018
574 +   li R28, #1	# int, #@loadConI
578 +   li R14, #0	# int, #@loadConI
57c     spill R28 -&gt; [sp, #12]	# spill size = 32

580     B72: #	out( B174 B73 ) &lt;- in( B65 B71 )  Freq: 0.000446386
580 +   lwu  R7, [R15, #16]	# loadN, compressed ptr, #@loadN ! Field: java/lang/module/ModuleDescriptor$Exports.source
584 +   lwu  R30, [R15, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/module/ModuleDescriptor$Exports.targets
588 +   decode_heap_oop  R13, R7	#@decodeHeapOop
58c     lw  R9, [R13, #12]	# int, #@loadI ! Field: java/lang/String.hash
590     NullCheck R13

590     B73: #	out( B92 B74 ) &lt;- in( B72 )  Freq: 0.000446385
590 +   li R17, #43	# int, #@loadConI
594 +   decode_heap_oop  R18, R30	#@decodeHeapOop
598 +   mulw  R16, R14, R17	#@mulI
59c +   bne  R9, zr, B92	#@cmpI_reg_imm0_branch  P=0.474144 C=5376.000000

5a0     B74: #	out( B148 B75 ) &lt;- in( B73 )  Freq: 0.000234734
5a0 +   lbu  R7, [R13, #17]	# byte, #@loadUB ! Field: java/lang/String.hashIsZero
5a4 +   bne  R7, zr, B148	#@cmpI_reg_imm0_branch  P=0.001062 C=2826.000000

5a8     B75: #	out( B165 B76 ) &lt;- in( B74 )  Freq: 0.000234485
5a8 +   lwu  R7, [R13, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
5ac +   lb  R28, [R13, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
5b0 +   decode_heap_oop  R14, R7	#@decodeHeapOop
5b4 +   bne  R28, zr, B165	#@cmpI_reg_imm0_branch  P=0.000000 C=115940.000000

5b8     B76: #	out( B177 B77 ) &lt;- in( B75 )  Freq: 0.000234485
5b8     lwu  R8, [R14, #12]	# range, #@loadRange
5bc     NullCheck R14

5bc     B77: #	out( B135 B78 ) &lt;- in( B76 )  Freq: 0.000234485
5bc +   bleu  R8, zr, B135	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.056079 C=18260.000000

5c0     B78: #	out( B159 B79 ) &lt;- in( B77 )  Freq: 0.000221335
5c0 +   addiw  R28, R8, #-1	#@addI_reg_imm
5c4 +   bgeu  R28, R8, B159	#@cmpU_branch  P=0.000001 C=-1.000000

5c8     B79: #	out( B160 B80 ) &lt;- in( B78 )  Freq: 0.000221335
5c8 +   addiw  R7, R8, #-3	#@addI_reg_imm
5cc +   lbu  R9, [R14, #16]	# byte, #@loadUB
5d0     spill [sp, #12] -&gt; R28	# spill size = 32
5d4 +   ble  R7, R28, B160	#@cmpI_branch  P=0.000001 C=-1.000000

5d8     B80: #	out( B161 B81 ) &lt;- in( B79 )  Freq: 0.000221335
5d8 +   slliw  R28, R9, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
5dc +   subw  R28, R28, R9	#@subI_reg_reg
5e0     spill [sp, #12] -&gt; R31	# spill size = 32
5e4 +   bleu  R8, R31, B161	#@cmpU_branch  P=0.000001 C=-1.000000

5e8     B81: #	out( B162 B82 ) &lt;- in( B80 )  Freq: 0.000221334
5e8 +   li R30, #4	# int, #@loadConI
5ec +   bleu  R8, R30, B162	#@cmpU_branch  P=0.000001 C=-1.000000

5f0     B82: #	out( B83 ) &lt;- in( B81 )  Freq: 0.000221334
5f0 +   li R30, #1	# int, #@loadConI

5f4     B83: #	out( B84 ) &lt;- in( B82 B85 ) Loop( B83-B85 ) Freq: 0.00394684
5f4 +   subw  R10, R8, R30	#@subI_reg_reg
5f8 +   li R11, #0	# int, #@loadConI
5fc +   addiw  R31, R10, #-3	#@addI_reg_imm
600     CMove R31, (R7 lt R30), R31, R11	#@cmovI_cmpI
	
608 +   li R12, #4000	# int, #@loadConI
610 +   li R10, #4000	# int, #@loadConI
618     CMove R31, (R31 gtu R10), R31, R12	#@cmovI_cmpU
	
620 +   addw  R10, R31, R30	#@addI_reg_reg
        nop 	# 6 bytes pad for loops and calls

630     B84: #	out( B84 B85 ) &lt;- in( B83 B84 ) Loop( B84-B84 inner main of N359 strip mined) Freq: 0.0703802
630 +   addw  R31, R30, zr	#@convI2L_reg_reg
634 +   add R31, R14, R31	# ptr, #@addP_reg_reg
638 +   lbu  R11, [R31, #16]	# byte, #@loadUB
63c +   addw  R11, R28, R11	#@addI_reg_reg
640 +   lbu  R9, [R31, #17]	# byte, #@loadUB
644 +   slliw  R28, R11, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
648 +   subw  R28, R28, R11	#@subI_reg_reg
64c +   addw  R11, R28, R9	#@addI_reg_reg
650 +   lbu  R19, [R31, #18]	# byte, #@loadUB
654 +   slliw  R28, R11, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
658 +   subw  R28, R28, R11	#@subI_reg_reg
65c +   addw  R28, R28, R19	#@addI_reg_reg
660 +   lbu  R11, [R31, #19]	# byte, #@loadUB
664 +   slliw  R12, R28, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
668 +   subw  R28, R12, R28	#@subI_reg_reg
66c +   addw  R9, R28, R11	#@addI_reg_reg
670 +   slliw  R31, R9, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
674 +   addiw  R30, R30, #4	#@addI_reg_imm
678 +   subw  R28, R31, R9	#@subI_reg_reg
67c +   blt  R30, R10, B84	#@cmpI_loop  P=0.943921 C=17236.000000

680     B85: #	out( B83 B86 ) &lt;- in( B84 )  Freq: 0.00394684
680 +   ld  R19, [R23, #920]	# ptr, #@loadP
684 +   lwu zr, [R19]	# Safepoint: poll for GC, #@safePoint        # java.lang.StringLatin1::hashCode @ bci:37 (line 196) L[0]=_ L[1]=R9 L[2]=R14 L[3]=R8 L[4]=R30 L[5]=_
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=R13 L[1]=_
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:18 (line 509) L[0]=R15 L[1]=_ STK[0]=R16
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #0 L[1]=R15 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {c_rarg3=Oop c_rarg4=Oop c_rarg5=Oop x18=Oop [0]=Oop [48]=Oop off=1668/0x684}
688 +   blt  R30, R7, B83	#@cmpI_branch  P=0.943921 C=17236.000000

68c     B86: #	out( B90 B87 ) &lt;- in( B160 B85 )  Freq: 0.000221334
68c +   bge  R30, R8, B90	#@cmpI_branch  P=0.500000 C=-1.000000

690     B87: #	out( B166 B88 ) &lt;- in( B86 )  Freq: 0.000110667
690 +   # castII of R30, #@castII
690     bgeu  R30, R8, B166	#@cmpU_branch  P=0.000001 C=-1.000000

694     B88: #	out( B167 B89 ) &lt;- in( B87 )  Freq: 0.000110667
694 +   spill R30 -&gt; R7	# spill size = 32
698 +   # castII of R7, #@castII
698     bgeu  R7, R8, B167	#@cmpU_branch  P=0.000001 C=-1.000000

69c     B89: #	out( B89 B90 ) &lt;- in( B88 B89 ) Loop( B89-B89 inner post of N1943) Freq: 0.000221334
69c +   addw  R7, R30, zr	#@convI2L_reg_reg
6a0 +   add R7, R14, R7	# ptr, #@addP_reg_reg
6a4 +   lbu  R28, [R7, #16]	# byte, #@loadUB
6a8 +   slliw  R7, R9, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
6ac +   subw  R31, R7, R9	#@subI_reg_reg
6b0 +   addiw  R30, R30, #1	#@addI_reg_imm
6b4 +   addw  R9, R31, R28	#@addI_reg_reg
6b8 +   blt  R30, R8, B89	#@cmpI_loop  P=0.500000 C=17236.000000

6bc     B90: #	out( B135 B91 ) &lt;- in( B89 B86 )  Freq: 0.000221334
6bc +   beq  R9, zr, B135	#@cmpI_reg_imm0_branch  P=0.000354 C=2823.000000

6c0     B91: #	out( B92 ) &lt;- in( B90 )  Freq: 0.000221256
6c0 +   sw  R9, [R13, #12]	# int, #@storeI ! Field: java/lang/String.hash

6c4     B92: #	out( B175 B93 ) &lt;- in( B91 B135 B148 B73 )  Freq: 0.000446384
6c4     lwu  R28, [R18, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
6c8     NullCheck R18

6c8     B93: #	out( B107 B94 ) &lt;- in( B92 )  Freq: 0.000446384
6c8 +   addw  R7, R9, R16	#@addI_reg_reg
6cc +   mv  R10, narrowklass: precise klass java/util/ImmutableCollections$SetN: 0x00000040d01dd400:Constant:exact *	# compressed klass ptr, #@loadConNKlass
6dc +   mulw  R30, R7, R17	#@mulI
6e0 +   beq  R28, R10, B107	#@cmpN_branch  P=0.672696 C=-1.000000

6e4     B94: #	out( B164 B95 ) &lt;- in( B93 )  Freq: 0.000146103
6e4 +   mv  R31, narrowklass: precise klass java/util/ImmutableCollections$Set12: 0x00000040d0929b40:Constant:exact *	# compressed klass ptr, #@loadConNKlass
6f4 +   bne  R28, R31, B164	#@cmpN_branch  P=0.000001 C=-1.000000

6f8     B95: #	out( B179 B96 ) &lt;- in( B94 )  Freq: 0.000146103
6f8 +   # checkcastPP of R18, #@checkCastPP
6f8     lwu  R7, [R18, #12]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$Set12.e0 (constant)
6fc +   decode_heap_oop  R11, R7	#@decodeHeapOop
700     lwu  R28, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
704     NullCheck R11

704     B96: #	out( B151 B97 ) &lt;- in( B95 )  Freq: 0.000146103
704 +   decode_klass_not_null  R7, R28	#@decodeKlass_not_null
710 +   ld  R7, [R7, #504]	# ptr, #@loadP
714 +   mv  R28, metadataptr:Constant0x00000040d01e39f0	# ptr, #@loadConP
72c +   bne  R7, R28, B151	#@cmpP_branch  P=0.001000 C=-1.000000

730     B97: #	out( B151 B98 ) &lt;- in( B96 )  Freq: 0.000145957
730 +   ld  R7, [R11]	# int, #@loadL
734 +   li R31, #1	# long, #@loadConL
738 +   andi  R28, R7, #7	#@andL_reg_imm
73c +   bne  R28, R31, B151	#@cmpL_branch  P=0.001000 C=-1.000000

740     B98: #	out( B151 B99 ) &lt;- in( B97 )  Freq: 0.000145811
740 +   srli  R7, R7, (#8 &amp; 0x3f)	#@urShiftL_reg_imm
744 +   li R31, #2147483647	# int, #@loadConI
74c +   addw  R7, R7, zr	#@convL2I_reg
750 +   andr  R13, R7, R31	#@andI_reg_reg
754 +   beq  R13, zr, B151	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

758     B99: #	out( B106 B100 ) &lt;- in( B152 B98 )  Freq: 0.000146103
758 +   lwu  R28, [R18, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$Set12.e1 (constant)
75c +   mv  R7, narrowoop: java/lang/Object:exact *	# compressed ptr, #@loadConN
76c +   beq  R28, R7, B106	#@cmpN_branch  P=0.100000 C=-1.000000

770     B100: #	out( B180 B101 ) &lt;- in( B99 )  Freq: 0.000131493
770 +   decode_heap_oop  R11, R28	#@decodeHeapOop
774     lwu  R28, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
778     NullCheck R11

778     B101: #	out( B153 B102 ) &lt;- in( B100 )  Freq: 0.000131492
778 +   decode_klass_not_null  R7, R28	#@decodeKlass_not_null
784 +   ld  R7, [R7, #504]	# ptr, #@loadP
788 +   mv  R28, metadataptr:Constant0x00000040d01e39f0	# ptr, #@loadConP
7a0 +   bne  R7, R28, B153	#@cmpP_branch  P=0.001000 C=-1.000000

7a4     B102: #	out( B153 B103 ) &lt;- in( B101 )  Freq: 0.000131361
7a4 +   ld  R7, [R11]	# int, #@loadL
7a8 +   li R31, #1	# long, #@loadConL
7ac +   andi  R28, R7, #7	#@andL_reg_imm
7b0 +   bne  R28, R31, B153	#@cmpL_branch  P=0.001000 C=-1.000000

7b4     B103: #	out( B153 B104 ) &lt;- in( B102 )  Freq: 0.00013123
7b4 +   srli  R7, R7, (#8 &amp; 0x3f)	#@urShiftL_reg_imm
7b8 +   li R28, #2147483647	# int, #@loadConI
7c0 +   addw  R7, R7, zr	#@convL2I_reg
7c4 +   andr  R10, R7, R28	#@andI_reg_reg
7c8 +   beq  R10, zr, B153	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

7cc     B104: #	out( B106 ) &lt;- in( B154 B103 )  Freq: 0.000131492
7cc +   addw  R13, R10, R13	#@addI_reg_reg
7d0 +   j  B106	#@branch

7d4     B105: #	out( B106 ) &lt;- in( B108 )  Freq: 0.000125805
7d4 +   li R13, #0	# int, #@loadConI

7d8     B106: #	out( B24 ) &lt;- in( B121 B105 B104 B99 )  Freq: 0.000446383
7d8 +   addw  R30, R13, R30	#@addI_reg_reg
7dc +   j  B24	#@branch

7e0     B107: #	out( B176 B108 ) &lt;- in( B93 )  Freq: 0.00030028
7e0 +   # checkcastPP of R18, #@checkCastPP
7e0     lwu  R7, [R18, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$SetN.elements (constant)
7e4 +   decode_heap_oop  R12, R7	#@decodeHeapOop
7e8     lwu  R7, [R12, #12]	# range, #@loadRange
7ec     NullCheck R12

7ec     B108: #	out( B105 B109 ) &lt;- in( B107 )  Freq: 0.00030028
7ec +   bleu  R7, zr, B105	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.418959 C=6361.000000

7f0     B109: #	out( B163 B110 ) &lt;- in( B108 )  Freq: 0.000174475
7f0 +   addiw  R31, R7, #-1	#@addI_reg_imm
7f4 +   bgeu  R31, R7, B163	#@cmpU_branch  P=0.000001 C=-1.000000

7f8     B110: #	out( B122 ) &lt;- in( B109 )  Freq: 0.000174475
7f8 +   li R16, #0	# int, #@loadConI
7fc +   li R13, #0	# int, #@loadConI
800 +   j  B122	#@branch

804     B111: #	out( B158 B112 ) &lt;- in( B70 )  Freq: 0.000259369
804 +   addiw  R30, R28, #-1	#@addI_reg_imm
808 +   bgeu  R30, R28, B158	#@cmpU_branch  P=0.000001 C=-1.000000

80c     B112: #	out( B113 ) &lt;- in( B111 )  Freq: 0.000259368
80c +   li R7, #1	# int, #@loadConI
810 +   li R12, #0	# int, #@loadConI
814 +   li R14, #0	# int, #@loadConI
818     spill R7 -&gt; [sp, #12]	# spill size = 32

81c     B113: #	out( B64 B114 ) &lt;- in( B112 B64 ) Loop( B113-B64 inner ) Freq: 0.000619077
81c +   addw  R7, R12, zr	#@convI2L_reg_reg
820 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
824 +   add R7, R31, R7	# ptr, #@addP_reg_reg
828 +   lwu  R7, [R7, #16]	# loadN, compressed ptr, #@loadN
82c +   decode_heap_oop  R11, R7	#@decodeHeapOop
830 +   beq   R11, zr, B64	#@cmpP_imm0_branch  P=0.500000 C=3696.000000

834     B114: #	out( B61 B115 ) &lt;- in( B113 )  Freq: 0.000309539
834 +   lwu  R30, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
838 +   decode_klass_not_null  R7, R30	#@decodeKlass_not_null
844 +   ld  R7, [R7, #504]	# ptr, #@loadP
848 +   mv  R30, metadataptr:Constant0x00000040d01e39f0	# ptr, #@loadConP
860 +   bne  R7, R30, B61	#@cmpP_branch  P=0.001000 C=-1.000000

864     B115: #	out( B61 B116 ) &lt;- in( B114 )  Freq: 0.000309229
864 +   ld  R7, [R11]	# int, #@loadL
868 +   li R10, #1	# long, #@loadConL
86c +   andi  R30, R7, #7	#@andL_reg_imm
870 +   bne  R30, R10, B61	#@cmpL_branch  P=0.001000 C=-1.000000

874     B116: #	out( B61 B117 ) &lt;- in( B115 )  Freq: 0.00030892
874 +   srli  R7, R7, (#8 &amp; 0x3f)	#@urShiftL_reg_imm
878 +   li R10, #2147483647	# int, #@loadConI
880 +   addw  R7, R7, zr	#@convL2I_reg
884 +   andr  R10, R7, R10	#@andI_reg_reg
888 +   beq  R10, zr, B61	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

88c     B117: #	out( B63 ) &lt;- in( B116 )  Freq: 0.000308611
88c +   j  B63	#@branch

890     B118: #	out( B181 B119 ) &lt;- in( B123 B124 B125 ) top-of-loop Freq: 6.24045e-07
890 +   spill R13 -&gt; [sp, #44]	# spill size = 32
894 +   spill R16 -&gt; [sp, #40]	# spill size = 32
898 +   spill R7 -&gt; [sp, #28]	# spill size = 32
89c +   spill R12 -&gt; [sp, #32]	# spill size = 64
8a0 +   spill R30 -&gt; [sp, #24]	# spill size = 32
8a4 +   spill R15 -&gt; [sp, #16]	# spill size = 64
8a8 +   spill R29 -&gt; [sp, #8]	# spill size = 32
8ac     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.ImmutableCollections$SetN::hashCode @ bci:33 (line 996) L[0]=_ L[1]=_ L[2]=sp + #32 L[3]=sp + #28 L[4]=sp + #40 L[5]=_ STK[0]=sp + #44
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:31 (line 510) L[0]=_ L[1]=_ STK[0]=sp + #24
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [16]=Oop [32]=Oop [48]=Oop off=2248/0x8c8}

8c8     B119: #	out( B120 ) &lt;- in( B118 )  Freq: 6.24033e-07
        # Block is sole successor of call
8c8 +   spill [sp, #8] -&gt; R29	# spill size = 32
8cc +   spill [sp, #16] -&gt; R15	# spill size = 64
8d0 +   spill [sp, #24] -&gt; R30	# spill size = 32
8d4 +   spill [sp, #32] -&gt; R12	# spill size = 64
8d8 +   spill [sp, #28] -&gt; R7	# spill size = 32
8dc +   spill [sp, #40] -&gt; R16	# spill size = 32
8e0 +   spill [sp, #44] -&gt; R13	# spill size = 32

8e4     B120: #	out( B121 ) &lt;- in( B119 B126 ) top-of-loop Freq: 0.000208224
8e4 +   addw  R13, R10, R13	#@addI_reg_reg
        nop 	# 4 bytes pad for loops and calls

8f0     B121: #	out( B106 B122 ) &lt;- in( B120 B122 ) top-of-loop Freq: 0.000416448
8f0 +   addiw  R16, R16, #1	#@addI_reg_imm
8f4 +   bge  R16, R7, B106	#@cmpI_loop  P=0.418959 C=3696.000000

8f8     B122: #	out( B121 B123 ) &lt;- in( B110 B121 ) Loop( B122-B121 inner ) Freq: 0.000416448
8f8 +   addw  R28, R16, zr	#@convI2L_reg_reg
8fc +   slli  R28, R28, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
900 +   add R28, R12, R28	# ptr, #@addP_reg_reg
904 +   lwu  R28, [R28, #16]	# loadN, compressed ptr, #@loadN
908 +   decode_heap_oop  R11, R28	#@decodeHeapOop
90c +   beq   R11, zr, B121	#@cmpP_imm0_branch  P=0.500000 C=3696.000000

910     B123: #	out( B118 B124 ) &lt;- in( B122 )  Freq: 0.000208224
910 +   lwu  R31, [R11, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
914 +   decode_klass_not_null  R28, R31	#@decodeKlass_not_null
920 +   ld  R28, [R28, #504]	# ptr, #@loadP
924 +   mv  R31, metadataptr:Constant0x00000040d01e39f0	# ptr, #@loadConP
93c +   bne  R28, R31, B118	#@cmpP_branch  P=0.001000 C=-1.000000

940     B124: #	out( B118 B125 ) &lt;- in( B123 )  Freq: 0.000208016
940 +   ld  R28, [R11]	# int, #@loadL
944 +   li R10, #1	# long, #@loadConL
948 +   andi  R31, R28, #7	#@andL_reg_imm
94c +   bne  R31, R10, B118	#@cmpL_branch  P=0.001000 C=-1.000000

950     B125: #	out( B118 B126 ) &lt;- in( B124 )  Freq: 0.000207808
950 +   srli  R28, R28, (#8 &amp; 0x3f)	#@urShiftL_reg_imm
954 +   li R31, #2147483647	# int, #@loadConI
95c +   addw  R28, R28, zr	#@convL2I_reg
960 +   andr  R10, R28, R31	#@andI_reg_reg
964 +   beq  R10, zr, B118	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

968     B126: #	out( B120 ) &lt;- in( B125 )  Freq: 0.0002076
968 +   j  B120	#@branch

96c     B127: #	out( B128 ) &lt;- in( B29 )  Freq: 7.93437e-05
96c +   spill R10 -&gt; R12	# spill size = 64

970     B128: #	out( B186 B129 ) &lt;- in( B127 B133 ) Loop( B128-B133 inner ) Freq: 0.000178535
970 +   spill [sp, #48] -&gt; R11	# spill size = 64
974     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::equals
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=sp + #0 L[1]=sp + #48 L[2]=sp + #8 L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [48]=Oop off=2448/0x990}

990     B129: #	out( B51 B130 ) &lt;- in( B128 )  Freq: 0.000178532
        # Block is sole successor of call
990 +   bne  R10, zr, B51	#@cmpI_reg_imm0_branch  P=0.007014 C=13972.000000

994     B130: #	out( B178 B131 ) &lt;- in( B129 )  Freq: 0.000177279
994 +   spill [sp, #0] -&gt; R7	# spill size = 64
998 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN ! Field: java/util/ImmutableCollections$SetN.elements (constant)
99c +   decode_heap_oop  R31, R28	#@decodeHeapOop
9a0     lwu  R29, [R31, #12]	# range, #@loadRange
9a4     NullCheck R31

9a4     B131: #	out( B136 B132 ) &lt;- in( B130 )  Freq: 0.000177279
9a4 +   spill [sp, #8] -&gt; R7	# spill size = 32
9a8 +   addiw  R28, R7, #1	#@addI_reg_imm
9ac     spill R28 -&gt; [sp, #8]	# spill size = 32
9b0 +   beq  R28, R29, B136	#@cmpI_branch  P=0.008360 C=13875.000000

9b4     B132: #	out( B140 B133 ) &lt;- in( B136 B131 )  Freq: 0.000177279
9b4 +   ld  R10, [R23, #920]	# ptr, #@loadP
9b8 +   lwu zr, [R10]	# Safepoint: poll for GC, #@safePoint        # java.util.ImmutableCollections$SetN::probe @ bci:53 (line 1017) L[0]=sp + #0 L[1]=sp + #48 L[2]=sp + #8 L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {xmethod=Oop [0]=Oop [48]=Oop off=2488/0x9b8}
9bc +   spill [sp, #8] -&gt; R7	# spill size = 32
9c0 +   bgeu  R7, R29, B140	#@cmpU_branch  P=0.000001 C=-1.000000

9c4     B133: #	out( B128 B134 ) &lt;- in( B132 )  Freq: 0.000177279
9c4 +   addw  R7, R7, zr	#@convI2L_reg_reg
9c8 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
9cc +   add R7, R31, R7	# ptr, #@addP_reg_reg
9d0 +   lwu  R28, [R7, #16]	# loadN, compressed ptr, #@loadN
9d4 +   decode_heap_oop  R12, R28	#@decodeHeapOop
9d8 +   bne   R12, zr, B128	#@cmpP_imm0_branch  P=0.559511 C=13875.000000

9dc     B134: #	out( B50 ) &lt;- in( B133 )  Freq: 7.80894e-05
9dc +   j  B50	#@branch

9e0     B135: #	out( B92 ) &lt;- in( B90 B77 )  Freq: 1.3228e-05
9e0 +   spill [sp, #12] -&gt; R7	# spill size = 32
9e4 +   sb  R7, [R13, #17]	# byte, #@storeB ! Field: java/lang/String.hashIsZero
9e8 +   li R9, #0	# int, #@loadConI
9ec +   j  B92	#@branch

9f0     B136: #	out( B132 ) &lt;- in( B131 )  Freq: 1.48212e-06
9f0 +   li R7, #0	# int, #@loadConI
9f4     spill R7 -&gt; [sp, #8]	# spill size = 32
9f8 +   j  B132	#@branch

9fc     B137: #	out( N1895 ) &lt;- in( B27 )  Freq: 1.00364e-06
9fc +   li R11, #-28	# int, #@loadConI
a00     spill [sp, #0] -&gt; R8	# spill size = 64
a04 +   spill R31 -&gt; [sp, #16]	# spill size = 64
a08     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:18 (line 1009) L[0]=R8 L[1]=sp + #48 L[2]=sp + #8 L[3]=_ STK[0]=sp + #16 STK[1]=sp + #8
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [16]=Oop [48]=Oop off=2572/0xa0c}
a0c     #@ShouldNotReachHere

a18     B138: #	out( N1895 ) &lt;- in( B25 )  Freq: 9.90493e-07
a18 +   li R11, #-122	# int, #@loadConI
a1c     spill R30 -&gt; R8	# spill size = 32
a20     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;div0_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.Math::floorMod @ bci:2 (line 1342) L[0]=_ L[1]=_ L[2]=_ STK[0]=R8 STK[1]=#0
        # java.util.ImmutableCollections$SetN::probe @ bci:9 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=2596/0xa24}
a24     #@ShouldNotReachHere

a30     B139: #	out( N1895 ) &lt;- in( B34 B44 )  Freq: 1.09294e-06
a30     #@ShouldNotReachHere

a3c     B140: #	out( N1895 ) &lt;- in( B38 B48 B132 )  Freq: 1.08546e-06
a3c +   li R11, #-28	# int, #@loadConI
a40     spill [sp, #0] -&gt; R8	# spill size = 64
a44 +   spill R31 -&gt; [sp, #16]	# spill size = 64
a48     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:18 (line 1009) L[0]=R8 L[1]=sp + #48 L[2]=sp + #8 L[3]=_ STK[0]=sp + #16 STK[1]=sp + #8
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [16]=Oop [48]=Oop off=2636/0xa4c}
a4c     #@ShouldNotReachHere

a58     B141: #	out( N1895 ) &lt;- in( B33 )  Freq: 5.25076e-07
a58     #@ShouldNotReachHere

a64     B142: #	out( N1895 ) &lt;- in( B9 )  Freq: 4.97424e-07
a64 +   li R11, #-138	# int, #@loadConI
a68     spill [sp, #0] -&gt; R8	# spill size = 64
a6c +   spill R10 -&gt; [sp, #8]	# spill size = 64
a70 +   spill R13 -&gt; [sp, #16]	# spill size = 64
a74 +   spill R12 -&gt; [sp, #28]	# spill size = 32
a78     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:13 (line 196) L[0]=_ L[1]=#0 L[2]=sp + #16 L[3]=sp + #28 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=sp + #28
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=sp + #8 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=2684/0xa7c}
a7c     #@ShouldNotReachHere

a88     B143: #	out( B17 ) &lt;- in( B10 )  Freq: 4.97423e-07
a88 +   li R16, #1	# int, #@loadConI
a8c     spill R7 -&gt; [sp, #12]	# spill size = 32
a90 +   j  B17	#@branch

a94     B144: #	out( N1895 ) &lt;- in( B11 )  Freq: 4.90904e-07
a94     #@ShouldNotReachHere

aa0     B145: #	out( N1895 ) &lt;- in( B12 )  Freq: 4.90904e-07
aa0     #@ShouldNotReachHere

aac     B146: #	out( N1895 ) &lt;- in( B32 B43 )  Freq: 5.39311e-07
aac +   li R11, #-187	# int, #@loadConI
ab0     spill R15 -&gt; [sp, #24]	# spill size = 64
ab4 +   spill R10 -&gt; [sp, #32]	# spill size = 64
ab8 +   spill R12 -&gt; [sp, #12]	# spill size = 32
abc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #24 L[1]=_ L[2]=sp + #32 STK[0]=sp + #12 STK[1]=R8
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=sp + #0 L[1]=sp + #24 L[2]=sp + #8 L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [24]=Oop [32]=Oop off=2752/0xac0}
ac0     #@ShouldNotReachHere

acc     B147: #	out( N1895 ) &lt;- in( B6 )  Freq: 2.60035e-07
acc +   li R11, #-187	# int, #@loadConI
ad0     spill R10 -&gt; [sp, #16]	# spill size = 64
ad4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=R8
        # java.lang.String::hashCode @ bci:17 (line 2337) L[0]=sp + #16 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [16]=Oop off=2776/0xad8}
ad8     #@ShouldNotReachHere

ae4     B148: #	out( B92 ) &lt;- in( B74 )  Freq: 2.49187e-07
ae4 +   li R9, #0	# int, #@loadConI
ae8 +   j  B92	#@branch

aec     B149: #	out( N1895 ) &lt;- in( B18 )  Freq: 2.48711e-07
aec     #@ShouldNotReachHere

af8     B150: #	out( N1895 ) &lt;- in( B19 )  Freq: 2.48711e-07
af8     #@ShouldNotReachHere

b04     B151: #	out( B182 B152 ) &lt;- in( B96 B97 B98 )  Freq: 4.37869e-07
b04 +   spill R30 -&gt; [sp, #32]	# spill size = 32
b08 +   spill R18 -&gt; [sp, #24]	# spill size = 64
b0c +   spill R15 -&gt; [sp, #16]	# spill size = 64
b10 +   spill R29 -&gt; [sp, #8]	# spill size = 32
b14     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.ImmutableCollections$Set12::hashCode @ bci:4 (line 815) L[0]=sp + #24
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:31 (line 510) L[0]=_ L[1]=_ STK[0]=sp + #32
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [16]=Oop [24]=Oop [48]=Oop off=2864/0xb30}

b30     B152: #	out( B99 ) &lt;- in( B151 )  Freq: 4.3786e-07
        # Block is sole successor of call
b30 +   spill [sp, #8] -&gt; R29	# spill size = 32
b34 +   spill [sp, #16] -&gt; R15	# spill size = 64
b38 +   spill [sp, #24] -&gt; R18	# spill size = 64
b3c +   spill [sp, #32] -&gt; R30	# spill size = 32
b40 +   spill R10 -&gt; R13	# spill size = 32
b44 +   j  B99	#@branch

b48     B153: #	out( B183 B154 ) &lt;- in( B101 B102 B103 )  Freq: 3.94081e-07
b48 +   spill R13 -&gt; [sp, #28]	# spill size = 32
b4c +   spill R30 -&gt; [sp, #24]	# spill size = 32
b50 +   spill R15 -&gt; [sp, #16]	# spill size = 64
b54 +   spill R29 -&gt; [sp, #8]	# spill size = 32
b58     CALL,dynamic 0x00000040139d2b40	#@CallDynamicJavaDirect java.lang.Object::hashCode
        # java.util.ImmutableCollections$Set12::hashCode @ bci:25 (line 815) L[0]=_ STK[0]=sp + #28
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:31 (line 510) L[0]=_ L[1]=_ STK[0]=sp + #24
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [16]=Oop [48]=Oop off=2932/0xb74}

b74     B154: #	out( B104 ) &lt;- in( B153 )  Freq: 3.94074e-07
        # Block is sole successor of call
b74 +   spill [sp, #8] -&gt; R29	# spill size = 32
b78 +   spill [sp, #24] -&gt; R30	# spill size = 32
b7c +   spill [sp, #28] -&gt; R13	# spill size = 32
b80 +   j  B104	#@branch

b84     B155: #	out( N1895 ) &lt;- in( B54 )  Freq: 4.71598e-08
b84 +   li R11, #-187	# int, #@loadConI
b88     spill [sp, #0] -&gt; R8	# spill size = 64
b8c +   spill R28 -&gt; [sp, #12]	# spill size = 32
b90     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.Math::floorMod @ bci:11 (line 1344) L[0]=_ L[1]=sp + #12 L[2]=sp + #8 STK[0]=sp + #8
        # java.util.ImmutableCollections$SetN::probe @ bci:9 (line 1007) L[0]=R8 L[1]=sp + #48 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [48]=Oop off=2964/0xb94}
b94     #@ShouldNotReachHere

ba0     B156: #	out( N1895 ) &lt;- in( B66 )  Freq: 4.46388e-10
ba0 +   li R11, #-58	# int, #@loadConI
ba4     spill [sp, #0] -&gt; R8	# spill size = 64
ba8 +   spill R12 -&gt; [sp, #8]	# spill size = 64
bac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;bimorphic&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_ STK[0]=sp + #48
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [48]=Oop off=2992/0xbb0}
bb0     #@ShouldNotReachHere

bbc     B157: #	out( N1895 ) &lt;- in( B68 )  Freq: 4.46387e-10
bbc +   li R11, #-34	# int, #@loadConI
bc0     spill R15 -&gt; [sp, #16]	# spill size = 64
bc4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:4 (line 508) L[0]=sp + #16 L[1]=_ STK[0]=R8
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=3016/0xbc8}
bc8     #@ShouldNotReachHere

bd4     B158: #	out( N1895 ) &lt;- in( B111 )  Freq: 2.62813e-10
bd4 +   li R11, #-138	# int, #@loadConI
bd8     spill [sp, #0] -&gt; R8	# spill size = 64
bdc +   spill R15 -&gt; [sp, #8]	# spill size = 64
be0 +   spill R31 -&gt; [sp, #16]	# spill size = 64
be4 +   spill R28 -&gt; [sp, #28]	# spill size = 32
be8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::hashCode @ bci:16 (line 994) L[0]=_ L[1]=#0 L[2]=sp + #16 L[3]=sp + #28 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=sp + #28
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:4 (line 508) L[0]=sp + #8 L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=3052/0xbec}
bec     #@ShouldNotReachHere

bf8     B159: #	out( N1895 ) &lt;- in( B78 )  Freq: 2.24274e-10
bf8 +   li R11, #-138	# int, #@loadConI
bfc     spill R15 -&gt; [sp, #16]	# spill size = 64
c00 +   spill R16 -&gt; [sp, #24]	# spill size = 32
c04 +   spill R13 -&gt; [sp, #32]	# spill size = 64
c08 +   spill R14 -&gt; [sp, #40]	# spill size = 64
c0c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:13 (line 196) L[0]=_ L[1]=#0 L[2]=sp + #40 L[3]=R8 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=R8
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=sp + #32 L[1]=_
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:18 (line 509) L[0]=sp + #16 L[1]=_ STK[0]=sp + #24
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=sp + #0 L[1]=sp + #16 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {[0]=Oop [16]=Oop [32]=Oop [40]=Oop off=3088/0xc10}
c10     #@ShouldNotReachHere

c1c     B160: #	out( B86 ) &lt;- in( B79 )  Freq: 2.24274e-10
c1c +   li R30, #1	# int, #@loadConI
c20 +   j  B86	#@branch

c24     B161: #	out( N1895 ) &lt;- in( B80 )  Freq: 2.21335e-10
c24     #@ShouldNotReachHere

c30     B162: #	out( N1895 ) &lt;- in( B81 )  Freq: 2.21334e-10
c30     #@ShouldNotReachHere

c3c     B163: #	out( N1895 ) &lt;- in( B109 )  Freq: 1.76792e-10
c3c +   spill [sp, #0] -&gt; R8	# spill size = 64
c40 +   li R11, #-138	# int, #@loadConI
c44     spill R15 -&gt; [sp, #0]	# spill size = 64
c48 +   spill R30 -&gt; [sp, #8]	# spill size = 32
c4c +   spill R12 -&gt; [sp, #16]	# spill size = 64
c50 +   spill R7 -&gt; [sp, #24]	# spill size = 32
c54     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::hashCode @ bci:16 (line 994) L[0]=_ L[1]=#0 L[2]=sp + #16 L[3]=sp + #24 L[4]=#0 L[5]=_ STK[0]=#0 STK[1]=sp + #24
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:31 (line 510) L[0]=_ L[1]=_ STK[0]=sp + #8
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=3160/0xc58}
c58     #@ShouldNotReachHere

c64     B164: #	out( N1895 ) &lt;- in( B94 )  Freq: 1.46103e-10
c64 +   spill [sp, #0] -&gt; R8	# spill size = 64
c68 +   li R11, #-58	# int, #@loadConI
c6c     spill R15 -&gt; [sp, #0]	# spill size = 64
c70 +   spill R30 -&gt; [sp, #8]	# spill size = 32
c74 +   spill R18 -&gt; [sp, #16]	# spill size = 64
c78     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;bimorphic&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:31 (line 510) L[0]=_ L[1]=_ STK[0]=sp + #8 STK[1]=sp + #16
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=R8 L[1]=sp + #0 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [0]=Oop [16]=Oop off=3196/0xc7c}
c7c     #@ShouldNotReachHere

c88     B165: #	out( N1895 ) &lt;- in( B75 )  Freq: 1.17243e-10
c88 +   li R11, #-187	# int, #@loadConI
c8c     spill [sp, #0] -&gt; R8	# spill size = 64
c90 +   spill R15 -&gt; [sp, #8]	# spill size = 64
c94 +   spill R16 -&gt; [sp, #16]	# spill size = 32
c98 +   spill R13 -&gt; [sp, #24]	# spill size = 64
c9c +   spill R28 -&gt; [sp, #20]	# spill size = 32
ca0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::isLatin1 @ bci:10 (line 4546) L[0]=_ STK[0]=sp + #20
        # java.lang.String::hashCode @ bci:17 (line 2337) L[0]=sp + #24 L[1]=_
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:18 (line 509) L[0]=sp + #8 L[1]=_ STK[0]=sp + #16
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=R8 L[1]=sp + #8 L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [8]=Oop [24]=Oop off=3236/0xca4}
ca4     #@ShouldNotReachHere

cb0     B166: #	out( N1895 ) &lt;- in( B87 )  Freq: 1.12137e-10
cb0     #@ShouldNotReachHere

cbc     B167: #	out( N1895 ) &lt;- in( B88 )  Freq: 1.12137e-10
cbc     #@ShouldNotReachHere

cc8     B168: #	out( N1895 ) &lt;- in( B31 B42 )  Freq: 1e-35
cc8 +   li R11, #-34	# int, #@loadConI
ccc     spill [sp, #0] -&gt; R8	# spill size = 64
cd0 +   spill R15 -&gt; [sp, #16]	# spill size = 64
cd4 +   spill R10 -&gt; [sp, #32]	# spill size = 64
cd8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=sp + #16 L[1]=sp + #32 L[2]=_ STK[0]=sp + #32
        # java.util.ImmutableCollections$SetN::probe @ bci:31 (line 1012) L[0]=R8 L[1]=sp + #16 L[2]=sp + #8 L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {fp=Oop [16]=Oop [32]=Oop off=3292/0xcdc}
cdc     #@ShouldNotReachHere

ce8     B169: #	out( N1895 ) &lt;- in( B24 )  Freq: 1.00365e-06
ce8 +   li R11, #-10	# int, #@loadConI
cec     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:8 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3312/0xcf0}
cf0     #@ShouldNotReachHere

cfc     B170: #	out( N1895 ) &lt;- in( B7 )  Freq: 5.26977e-07
cfc +   li R11, #-10	# int, #@loadConI
d00     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:5 (line 196) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=_ L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3332/0xd04}
d04     #@ShouldNotReachHere

d10     B171: #	out( N1895 ) &lt;- in( B1 )  Freq: 4.76837e-07
d10 +   li R11, #-187	# int, #@loadConI
d14     spill [sp, #0] -&gt; R8	# spill size = 64
d18 +   spill R12 -&gt; [sp, #8]	# spill size = 64
d1c +   spill R12 -&gt; [sp, #16]	# spill size = 64
d20     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.Objects::requireNonNull @ bci:1 (line 208) L[0]=sp + #16 STK[0]=sp + #8
        # java.util.ImmutableCollections$SetN::contains @ bci:1 (line 937) L[0]=R8 L[1]=sp + #8
        # OopMap {fp=Oop [8]=Oop [16]=Oop off=3364/0xd24}
d24     #@ShouldNotReachHere

d30     B172: #	out( N1895 ) &lt;- in( B67 )  Freq: 4.52315e-10
d30 +   li R11, #-10	# int, #@loadConI
d34     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:4 (line 508) L[0]=_ L[1]=_ STK[0]=#NULL
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3384/0xd38}
d38     #@ShouldNotReachHere

d44     B173: #	out( N1895 ) &lt;- in( B69 )  Freq: 4.52314e-10
d44 +   li R11, #-10	# int, #@loadConI
d48     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::hashCode @ bci:8 (line 994) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:4 (line 508) L[0]=_ L[1]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3404/0xd4c}
d4c     #@ShouldNotReachHere

d58     B174: #	out( N1895 ) &lt;- in( B72 )  Freq: 4.52313e-10
d58 +   li R11, #-10	# int, #@loadConI
d5c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:18 (line 509) L[0]=_ L[1]=_ STK[0]=_ STK[1]=#NULL
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3424/0xd60}
d60     #@ShouldNotReachHere

d6c     B175: #	out( N1895 ) &lt;- in( B92 )  Freq: 4.52312e-10
d6c +   li R11, #-10	# int, #@loadConI
d70     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:31 (line 510) L[0]=_ L[1]=_ STK[0]=_ STK[1]=#NULL
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3444/0xd74}
d74     #@ShouldNotReachHere

d80     B176: #	out( N1895 ) &lt;- in( B107 )  Freq: 3.04268e-10
d80 +   li R11, #-10	# int, #@loadConI
d84     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::hashCode @ bci:8 (line 994) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:31 (line 510) L[0]=_ L[1]=_ STK[0]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3464/0xd88}
d88     #@ShouldNotReachHere

d94     B177: #	out( N1895 ) &lt;- in( B76 )  Freq: 2.37599e-10
d94 +   li R11, #-10	# int, #@loadConI
d98     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.StringLatin1::hashCode @ bci:5 (line 196) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ STK[0]=#NULL
        # java.lang.String::hashCode @ bci:27 (line 2337) L[0]=_ L[1]=_
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:18 (line 509) L[0]=_ L[1]=_ STK[0]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3484/0xd9c}
d9c     #@ShouldNotReachHere

da8     B178: #	out( N1895 ) &lt;- in( B130 )  Freq: 1.79633e-10
da8 +   li R11, #-10	# int, #@loadConI
dac     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$SetN::probe @ bci:47 (line 1014) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=_ STK[1]=#NULL
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3504/0xdb0}
db0     #@ShouldNotReachHere

dbc     B179: #	out( N1895 ) &lt;- in( B95 )  Freq: 1.48043e-10
dbc +   li R11, #-10	# int, #@loadConI
dc0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$Set12::hashCode @ bci:4 (line 815) L[0]=_ STK[0]=#NULL
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:31 (line 510) L[0]=_ L[1]=_ STK[0]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3524/0xdc4}
dc4     #@ShouldNotReachHere

dd0     B180: #	out( N1895 ) &lt;- in( B100 )  Freq: 1.33239e-10
dd0 +   li R11, #-10	# int, #@loadConI
dd4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.ImmutableCollections$Set12::hashCode @ bci:25 (line 815) L[0]=_ STK[0]=_ STK[1]=#NULL
        # java.lang.module.ModuleDescriptor$Exports::hashCode @ bci:31 (line 510) L[0]=_ L[1]=_ STK[0]=_
        # java.util.ImmutableCollections$SetN::probe @ bci:1 (line 1007) L[0]=_ L[1]=_ L[2]=_ L[3]=_
        # java.util.ImmutableCollections$SetN::contains @ bci:14 (line 938) L[0]=_ L[1]=_
        # OopMap {off=3544/0xdd8}
dd8     #@ShouldNotReachHere

de4     B181: #	out( B187 ) &lt;- in( B118 )  Freq: 6.24045e-12
de4      -- 	// exception oop; no code emitted, #@CreateException
de4 +   spill R10 -&gt; R11	# spill size = 64
de8 +   j  B187	#@branch

dec     B182: #	out( B184 ) &lt;- in( B151 )  Freq: 4.37869e-12
dec      -- 	// exception oop; no code emitted, #@CreateException
dec +   j  B184	#@branch

df0     B183: #	out( B184 ) &lt;- in( B153 )  Freq: 3.94081e-12
df0      -- 	// exception oop; no code emitted, #@CreateException

df0     B184: #	out( B187 ) &lt;- in( B182 B183 )  Freq: 8.3195e-12
df0 +   spill R10 -&gt; R11	# spill size = 64
df4 +   j  B187	#@branch

df8     B185: #	out( B187 ) &lt;- in( B61 )  Freq: 9.27684e-12
df8      -- 	// exception oop; no code emitted, #@CreateException
df8 +   spill R10 -&gt; R11	# spill size = 64
dfc +   j  B187	#@branch

e00     B186: #	out( B187 ) &lt;- in( B128 )  Freq: 1.78535e-09
e00      -- 	// exception oop; no code emitted, #@CreateException
e00 +   spill R10 -&gt; R11	# spill size = 64

e04     B187: #	out( N1895 ) &lt;- in( B185 B184 B181 B186 )  Freq: 1.80919e-09
e04     # pop frame 96
	add  sp, sp, #96
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
e10 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='605'>
----------------------- MetaData before Compile_id = 605 ------------------------
{method}
 - this oop:          0x00000040961a20a8
 - method holder:     &apos;java/util/HashMap&apos;
 - constants:         0x000000409619f4e0 constant pool [610] {0x000000409619f4e0} for &apos;java/util/HashMap&apos; cache=0x00000040961a4fd8
 - access:            0xc1000010  final 
 - name:              &apos;resize&apos;
 - signature:         &apos;()[Ljava/util/HashMap$Node;&apos;
 - max stack:         6
 - max locals:        14
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c58a900
 - code size:         356
 - code start:        0x00000040961a1e38
 - code end (excl):   0x00000040961a1f9c
 - method data:       0x0000004096485a10
 - checked ex length: 0
 - linenumber start:  0x00000040961a1f9c
 - localvar length:   17
 - localvar start:    0x00000040961a1fd8
 - compiled code: nmethod  24674  387       3       java.util.HashMap::resize (356 bytes)

------------------------ OptoAssembly for Compile_id = 605 -----------------------
#
#  narrowoop: java/util/HashMap$Node *[int:&gt;=0] * ( java/util/HashMap:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/HashMap:NotNull *
# -- Old sp -- Framesize: 112 --
#r263 sp+108: in_preserve
#r262 sp+104: return address
#r261 sp+100: in_preserve
#r260 sp+96: saved fp register
#r259 sp+92: pad2, stack alignment
#r258 sp+88: pad2, stack alignment
#r257 sp+84: Fixed slot 1
#r256 sp+80: Fixed slot 0
#r283 sp+76: spill
#r282 sp+72: spill
#r281 sp+68: spill
#r280 sp+64: spill
#r279 sp+60: spill
#r278 sp+56: spill
#r277 sp+52: spill
#r276 sp+48: spill
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N2056: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B24 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=112
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #112
	
03c     lwu  R7, [R11, #36]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap.table
040 +   decode_heap_oop  R7, R7	#@decodeHeapOop
044     spill R7 -&gt; [sp, #48]	# spill size = 64
048 +   lw  R7, [R11, #28]	# int, #@loadI ! Field: java/util/HashMap.threshold
04c     spill R7 -&gt; [sp, #24]	# spill size = 32
050 +   spill [sp, #48] -&gt; R7	# spill size = 64
054 +   li R28, #16	# int, #@loadConI
058     spill R11 -&gt; [sp, #40]	# spill size = 64
05c +   bne   R7, zr, B24	#@cmpP_imm0_branch  P=0.192477 C=2047.000000

060     B2: #	out( B3 ) &lt;- in( B1 )  Freq: 0.807523
060 +   mv  R7, NULL	# NULL ptr, #@loadConP0
064 +   li R29, #0	# int, #@loadConI
068     spill R7 -&gt; [sp, #48]	# spill size = 64
06c +   spill R29 -&gt; [sp, #56]	# spill size = 32

070     B3: #	out( B19 B4 ) &lt;- in( B24 B2 )  Freq: 1
070 +   li R31, #262144	# int, #@loadConI
074 +   li R7, #1073741824	# int, #@loadConI
078     spill [sp, #56] -&gt; R29	# spill size = 32
07c +   bgt  R29, zr, B19	#@cmpI_reg_imm0_branch  P=0.192477 C=2047.000000

080     B4: #	out( B6 B5 ) &lt;- in( B3 )  Freq: 0.807523
080 +   spill [sp, #24] -&gt; R29	# spill size = 32
084 +   ble  R29, zr, B6	#@cmpI_reg_imm0_branch  P=0.435572 C=1653.000000

088     B5: #	out( B7 ) &lt;- in( B4 )  Freq: 0.455789
088 +   li R29, #0	# int, #@loadConI
08c +   j  B7	#@branch

090     B6: #	out( B7 ) &lt;- in( B4 )  Freq: 0.351734
090 +   li R30, #16	# int, #@loadConI
094 +   li R29, #12	# int, #@loadConI
098     spill R30 -&gt; [sp, #24]	# spill size = 32

09c     B7: #	out( B10 B8 ) &lt;- in( B22 B6 B5 B23 )  Freq: 1
09c +   bne  R29, zr, B10	#@cmpI_reg_imm0_branch  P=0.484612 C=2047.000000

0a0     B8: #	out( B131 B9 ) &lt;- in( B7 )  Freq: 0.515388
0a0 +   spill [sp, #24] -&gt; R28	# spill size = 32
0a4 +   fcvt.s.w  F0, R28	#@convI2F_reg_reg
0a8 +   flw  F2, [R11, #32]	# float, #@loadF ! Field: java/util/HashMap.loadFactor
0ac +   fmul.s  F2, F0, F2	#@mulF_reg_reg
0b0 +   fcvt.w.s  R29, F2	#@convF2I_reg_reg
0d0     spill [sp, #24] -&gt; R30	# spill size = 32
0d4 +   bge  R30, R7, B131	#@cmpI_branch  P=0.000000 C=1055.000000

0d8     B9: #	out( B130 B10 ) &lt;- in( B8 )  Freq: 0.515388
0d8     -- 	// MachConstantBaseNode (empty encoding)
0d8 +   flw F0, [constant table base + #0]	# load from constant table: float=#1073741824.000000, #@loadConF
0e0     float_ble F0, F2, B130 	#@cmpF_branch  P=0.000000 C=1055.000000

0e8     B10: #	out( B11 B11 ) &lt;- in( B9 B7 )  Freq: 0.999999
0e8 +   spill [sp, #24] -&gt; R28	# spill size = 32
0ec +   addw  R7, R28, zr	#@convI2L_reg_reg
0f0 +   bleu  R28, R31, B11	#@cmpU_branch  P=0.999999 C=-1.000000

0f4     B11: #	out( B118 B12 ) &lt;- in( B10 B10 )  Freq: 0.999999
0f4 +   sw  R29, [R11, #28]	# int, #@storeI ! Field: java/util/HashMap.threshold
0f8     spill [sp, #24] -&gt; R29	# spill size = 32
0fc +   bgtu  R29, R31, B118	#@cmpU_branch  P=0.000001 C=-1.000000

100     B12: #	out( B118 B13 ) &lt;- in( B11 )  Freq: 0.999998
100 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
104 +   addi  R7, R7, #23	#@addL_reg_imm
108 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
108     ld  R22, [R23, #288]	# ptr, #@loadP
10c +   andi  R28, R7, #-8	#@andL_reg_imm
110 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
110     ld  R29, [R23, #304]	# ptr, #@loadP
114 +   add R28, R22, R28	# ptr, #@addP_reg_reg
118 +   bgeu  R28, R29, B118	#@cmpP_branch  P=0.000100 C=-1.000000

11c     B13: #	out( B14 ) &lt;- in( B12 )  Freq: 0.999898
11c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
11c     sd  R28, [R23, #288]	# ptr, #@storeP
120 +   li R28, #1	# long, #@loadConL
124 +   sd  R28, [R22]	# long, #@storeL
128 +   mv  R28, narrowklass: precise klass [Ljava/util/HashMap$Node;: 0x00000040d09f4300:Constant:exact *	# compressed klass ptr, #@loadConNKlass
138 +   sw  R28, [R22, #8]	# compressed klass ptr, #@storeNKlass
13c     spill [sp, #24] -&gt; R28	# spill size = 32
140 +   sw  R28, [R22, #12]	# int, #@storeI
144 +   srli  R7, R7, (#3 &amp; 0x3f)	#@urShiftL_reg_imm
148 +   addi  R28, R22, #16	# ptr, #@addP_reg_imm
14c +   addi  R29, R7, #-2	#@addL_reg_imm
150 +   ClearArray R29, R28	#@clearArray_reg_reg

1a8     B14: #	out( B85 B15 ) &lt;- in( B119 B13 )  Freq: 0.999999
1a8     
1a8     MEMBAR-store-store	#@membar_storestore
1ac +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ac     lb  R28, [R23, #56]	# byte, #@loadB
1b0 +   # checkcastPP of R22, #@checkCastPP
1b0     bne  R28, zr, B85	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

1b4     B15: #	out( B17 B16 ) &lt;- in( B125 B87 B85 B14 )  Freq: 0.999999
1b4 +   spill [sp, #40] -&gt; R28	# spill size = 64
1b8 +   mv  R28, R28	# ptr -&gt; long, #@castP2X
1b8 +   mv  R7, R22	# ptr -&gt; long, #@castP2X
1bc +   xorr  R7, R7, R28	#@xorL_reg_reg
1c0 +   encode_heap_oop  R29, R22	#@encodeHeapOop
1c4 +   srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
1c8     spill [sp, #40] -&gt; R30	# spill size = 64
1cc +   sw  R29, [R30, #36]	# compressed ptr, #@storeN ! Field: java/util/HashMap.table
1d0 +   beq  R7, zr, B17	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

1d4     B16: #	out( B88 B17 ) &lt;- in( B15 )  Freq: 0.998999
1d4 +   srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
1d8 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
1e4 +   add R10, R28, R7	# ptr, #@addP_reg_reg
1e8 +   lb  R28, [R10]	# byte, #@loadB
1ec +   li R29, #4	# int, #@loadConI
1f0 +   bne  R28, R29, B88	#@cmpI_branch  P=0.001000 C=-1.000000

1f4     B17: #	out( B25 B18 ) &lt;- in( B90 B91 B88 B16 B15 )  Freq: 0.999999
1f4 +   spill [sp, #48] -&gt; R7	# spill size = 64
1f8 +   bne   R7, zr, B25	#@cmpP_imm0_branch  P=0.192477 C=2047.000000

1fc     B18: #	out( N2056 ) &lt;- in( B55 B25 B17 )  Freq: 0.999996
1fc +   spill R22 -&gt; R10	# spill size = 64
200 +   # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
218 +   ret	// return register, #@Ret

21c     B19: #	out( B136 B20 ) &lt;- in( B3 )  Freq: 0.192477
21c +   slliw  R8, R29, (#1 &amp; 0x1f)	#@lShiftI_reg_imm
220 +   bge  R29, R7, B136	#@cmpI_branch  P=0.000000 C=394.000000

224     B20: #	out( B137 B21 ) &lt;- in( B19 )  Freq: 0.192477
224 +   bge  R8, R7, B137	#@cmpI_branch  P=0.000000 C=394.000000

228     B21: #	out( B23 B22 ) &lt;- in( B20 )  Freq: 0.192477
228 +   bge  R29, R28, B23	#@cmpI_branch  P=0.690355 C=394.000000

22c     B22: #	out( B7 ) &lt;- in( B21 )  Freq: 0.0595994
22c +   li R29, #0	# int, #@loadConI
230     spill R8 -&gt; [sp, #24]	# spill size = 32
234 +   j  B7	#@branch

238     B23: #	out( B7 ) &lt;- in( B21 )  Freq: 0.132877
238 +   spill [sp, #24] -&gt; R29	# spill size = 32
23c +   slliw  R29, R29, (#1 &amp; 0x1f)	#@lShiftI_reg_imm
240     spill R8 -&gt; [sp, #24]	# spill size = 32
244 +   j  B7	#@branch

248     B24: #	out( B3 ) &lt;- in( B1 )  Freq: 0.192477
248 +   lwu  R29, [R7, #12]	# range, #@loadRange
24c     spill R29 -&gt; [sp, #56]	# spill size = 32
250 +   j  B3	#@branch

254     B25: #	out( B18 B26 ) &lt;- in( B17 )  Freq: 0.192477
254 +   spill [sp, #56] -&gt; R7	# spill size = 32
258 +   ble  R7, zr, B18	#@cmpI_reg_imm0_branch  P=0.032540 C=12108.000000

25c     B26: #	out( B133 B27 ) &lt;- in( B25 )  Freq: 0.186213
25c +   spill [sp, #48] -&gt; R7	# spill size = 64
260 +   spill [sp, #24] -&gt; R28	# spill size = 32
264 +   spill [sp, #56] -&gt; R29	# spill size = 32
268 +   lwu  R7, [R7, #12]	# range, #@loadRange
26c +   # castII of R28, #@castII
26c     addiw  R29, R29, #-1	#@addI_reg_imm
270     spill R28 -&gt; [sp, #60]	# spill size = 32
274 +   bleu  R7, zr, B133	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

278     B27: #	out( B133 B28 ) &lt;- in( B26 )  Freq: 0.186213
278 +   bgeu  R29, R7, B133	#@cmpU_branch  P=0.000001 C=-1.000000

27c     B28: #	out( B134 B29 ) &lt;- in( B27 )  Freq: 0.186213
27c +   ble  R28, zr, B134	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

280     B29: #	out( B56 ) &lt;- in( B28 )  Freq: 0.186213
280 +   addiw  R28, R28, #-1	#@addI_reg_imm
284     spill R28 -&gt; [sp, #64]	# spill size = 32
288 +   spill [sp, #56] -&gt; R28	# spill size = 32
28c +   addw  R7, R28, zr	#@convI2L_reg_reg
290 +   li R21, #0	# int, #@loadConI
294     spill R7 -&gt; [sp, #72]	# spill size = 64
298 +   j  B56	#@branch

29c     B30: #	out( B38 B31 ) &lt;- in( B69 )  Freq: 1.14263
29c +   beq   R25, zr, B38	#@cmpP_imm0_branch  P=0.708850 C=2339.000000

2a0     B31: #	out( B115 B32 ) &lt;- in( B30 )  Freq: 0.332676
2a0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2a0     lb  R7, [R23, #56]	# byte, #@loadB
2a4 +   bne  R7, zr, B115	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

2a8     B32: #	out( B39 B33 ) &lt;- in( B135 B117 B115 B31 )  Freq: 0.332676
2a8 +   mv  R28, R25	# ptr -&gt; long, #@castP2X
2ac +   mv  R7, R19	# ptr -&gt; long, #@castP2X
2b0 +   xorr  R7, R7, R28	#@xorL_reg_reg
2b4 +   srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
2b8 +   sw  R24, [R25, #24]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.next
2bc +   beq  R7, zr, B39	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

2c0     B33: #	out( B39 B34 ) &lt;- in( B32 )  Freq: 0.332343
2c0 +   srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
2c4 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
2d0 +   add R10, R28, R7	# ptr, #@addP_reg_reg
2d4 +   lb  R7, [R10]	# byte, #@loadB
2d8 +   li R30, #4	# int, #@loadConI
2dc +   beq  R7, R30, B39	#@cmpI_branch  P=0.999000 C=-1.000000

2e0     B34: #	out( B39 B35 ) &lt;- in( B33 )  Freq: 0.000332343
2e0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2e0     ld  R28, [R23, #64]	# int, #@loadL
2e4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2e4     ld  R30, [R23, #80]	# ptr, #@loadP
2e8 +   #@membar_volatile
	fence iorw iorw
2ec +   lb  R7, [R10]	# byte, #@loadB
2f0 +   beq  R7, zr, B39	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

2f4     B35: #	out( B37 B36 ) &lt;- in( B34 )  Freq: 0.000166172
2f4 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
2f8 +   bne  R28, zr, B37	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

2fc     B36: #	out( B39 ) &lt;- in( B35 )  Freq: 8.30858e-05
2fc +   spill R29 -&gt; [sp, #8]	# spill size = 64
300     
300     
300 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
300     spill R23 -&gt; R11	# spill size = 64
304 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
334 +   spill R21 -&gt; R24	# spill size = 32
338 +   spill R22 -&gt; [sp, #0]	# spill size = 64
33c +   spill R26 -&gt; [sp, #16]	# spill size = 64
340 +   spill R24 -&gt; R21	# spill size = 32
344 +   spill [sp, #0] -&gt; R22	# spill size = 64
348 +   spill [sp, #8] -&gt; R29	# spill size = 64
34c +   spill [sp, #16] -&gt; R26	# spill size = 64
350 +   j  B39	#@branch

354     B37: #	out( B39 ) &lt;- in( B35 )  Freq: 8.30858e-05
354 +   add R7, R30, R28	# ptr, #@addP_reg_reg
358 +   sd  R10, [R7, #-8]	# ptr, #@storeP
35c +   addi  R7, R28, #-8	#@addL_reg_imm
360 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
360     sd  R7, [R23, #64]	# long, #@storeL
364 +   j  B39	#@branch

368     B38: #	out( B39 ) &lt;- in( B30 )  Freq: 0.809951
368 +   spill R19 -&gt; R26	# spill size = 64

36c     B39: #	out( B40 ) &lt;- in( B36 B37 B34 B33 B32 B38 )  Freq: 1.14263
36c +   spill R19 -&gt; R25	# spill size = 64
370 +   spill R20 -&gt; R19	# spill size = 64

374     B40: #	out( B68 B41 ) &lt;- in( B39 B76 B77 B74 B73 B72 B78 )  Freq: 2.35951
374 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
374     ld  R7, [R23, #920]	# ptr, #@loadP
378 +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.util.HashMap::resize @ bci:306 (line 733) L[0]=sp + #40 L[1]=sp + #48 L[2]=sp + #56 L[3]=_ L[4]=sp + #60 L[5]=_ L[6]=R22 L[7]=R21 L[8]=R8 L[9]=R29 L[10]=R19 L[11]=R26 L[12]=R25 L[13]=_ STK[0]=R8
        # OopMap {x29=Oop x19=Oop xbcp=Oop xmonitors=Oop xcpool=Oop fp=Oop [40]=Oop [48]=Oop off=888/0x378}
37c +   bne   R8, zr, B68	#@cmpP_imm0_branch  P=0.555072 C=4830.000000

380     B41: #	out( B48 B42 ) &lt;- in( B40 )  Freq: 1.04981
380 +   beq   R19, zr, B48	#@cmpP_imm0_branch  P=0.221498 C=2149.000000

384     B42: #	out( B92 B43 ) &lt;- in( B41 )  Freq: 0.817279
384 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
384     lb  R28, [R23, #56]	# byte, #@loadB
388 +   bne  R28, zr, B92	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

38c     B43: #	out( B123 B44 ) &lt;- in( B126 B94 B92 B42 )  Freq: 0.817279
38c +   add R7, R22, R18	# ptr, #@addP_reg_reg
390 +   sw  rheapbase, [R19, #24]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/util/HashMap$Node.next
394     spill [sp, #60] -&gt; R28	# spill size = 32
398 +   bgeu  R21, R28, B123	#@cmpU_branch  P=0.000001 C=-1.000000

39c     B44: #	out( B95 B45 ) &lt;- in( B43 )  Freq: 0.817278
39c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
39c     lb  R28, [R23, #56]	# byte, #@loadB
3a0 +   addi  R20, R7, #16	# ptr, #@addP_reg_imm
3a4 +   bne  R28, zr, B95	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

3a8     B45: #	out( B48 B46 ) &lt;- in( B127 B97 B95 B44 )  Freq: 0.817278
3a8 +   mv  R28, R20	# ptr -&gt; long, #@castP2X
3ac +   mv  R7, R29	# ptr -&gt; long, #@castP2X
3b0 +   xorr  R7, R7, R28	#@xorL_reg_reg
3b4 +   encode_heap_oop  R31, R29	#@encodeHeapOop
3b8 +   srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
3bc +   sw  R31, [R20]	# compressed ptr, #@storeN
3c0 +   beq  R7, zr, B48	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

3c4     B46: #	out( B48 B47 ) &lt;- in( B45 )  Freq: 0.816461
3c4 +   beq   R29, zr, B48	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

3c8     B47: #	out( B98 B48 ) &lt;- in( B46 )  Freq: 0.815644
3c8 +   srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
3cc +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
3d8 +   add R10, R28, R7	# ptr, #@addP_reg_reg
3dc +   lb  R7, [R10]	# byte, #@loadB
3e0 +   li R29, #4	# int, #@loadConI
3e4 +   bne  R7, R29, B98	#@cmpI_branch  P=0.001000 C=-1.000000

3e8     B48: #	out( B55 B49 ) &lt;- in( B100 B101 B98 B47 B46 B45 B41 )  Freq: 1.04981
3e8 +   beq   R25, zr, B55	#@cmpP_imm0_branch  P=0.228478 C=2149.000000

3ec     B49: #	out( B102 B50 ) &lt;- in( B48 )  Freq: 0.809951
3ec +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3ec     lb  R28, [R23, #56]	# byte, #@loadB
3f0 +   bne  R28, zr, B102	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

3f4     B50: #	out( B124 B51 ) &lt;- in( B128 B104 B102 B49 )  Freq: 0.809951
3f4 +   spill [sp, #72] -&gt; R7	# spill size = 64
3f8 +   add  R7, R7, R9	#@addL_reg_reg
3fc +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
400     spill [sp, #56] -&gt; R28	# spill size = 32
404 +   addw  R8, R21, R28	#@addI_reg_reg
408 +   add R7, R22, R7	# ptr, #@addP_reg_reg
40c +   sw  rheapbase, [R25, #24]	# compressed ptr (rheapbase==0), #@storeImmN0 ! Field: java/util/HashMap$Node.next
410     spill [sp, #60] -&gt; R29	# spill size = 32
414 +   bgeu  R8, R29, B124	#@cmpU_branch  P=0.000001 C=-1.000000

418     B51: #	out( B105 B52 ) &lt;- in( B50 )  Freq: 0.80995
418 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
418     lb  R28, [R23, #56]	# byte, #@loadB
41c +   addi  R19, R7, #16	# ptr, #@addP_reg_imm
420 +   bne  R28, zr, B105	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

424     B52: #	out( B55 B53 ) &lt;- in( B129 B107 B105 B51 )  Freq: 0.80995
424 +   mv  R28, R19	# ptr -&gt; long, #@castP2X
428 +   mv  R7, R26	# ptr -&gt; long, #@castP2X
42c +   xorr  R7, R7, R28	#@xorL_reg_reg
430 +   encode_heap_oop  R30, R26	#@encodeHeapOop
434 +   srli  R7, R7, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
438 +   sw  R30, [R19]	# compressed ptr, #@storeN
43c +   beq  R7, zr, B55	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

440     B53: #	out( B55 B54 ) &lt;- in( B52 )  Freq: 0.80914
440 +   beq   R26, zr, B55	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

444     B54: #	out( B108 B55 ) &lt;- in( B53 )  Freq: 0.808331
444 +   srli  R7, R28, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
448 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
454 +   add R10, R28, R7	# ptr, #@addP_reg_reg
458 +   lb  R7, [R10]	# byte, #@loadB
45c +   li R28, #4	# int, #@loadConI
460 +   bne  R7, R28, B108	#@cmpI_branch  P=0.001000 C=-1.000000

464     B55: #	out( B18 B56 ) &lt;- in( B56 B110 B111 B108 B54 B53 B52 B48 B66 B67 B64 B63 B62 ) top-of-loop Freq: 5.72242
464 +   addiw  R21, R21, #1	#@addI_reg_imm
468 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
468     ld  R7, [R23, #920]	# ptr, #@loadP
46c +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.util.HashMap::resize @ bci:350 (line 705) L[0]=sp + #40 L[1]=sp + #48 L[2]=sp + #56 L[3]=_ L[4]=sp + #60 L[5]=_ L[6]=R22 L[7]=R21 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_
        # OopMap {xbcp=Oop [40]=Oop [48]=Oop off=1132/0x46c}
470 +   spill [sp, #56] -&gt; R28	# spill size = 32
474 +   bge  R21, R28, B18	#@cmpI_loop  P=0.032540 C=11714.000000

478     B56: #	out( B55 B57 ) &lt;- in( B29 B55 ) Loop( B56-B55 ) Freq: 5.72242
478 +   addw  R9, R21, zr	#@convI2L_reg_reg
47c +   slli  R18, R9, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
480     spill [sp, #48] -&gt; R7	# spill size = 64
484 +   add R25, R7, R18	# ptr, #@addP_reg_reg
488 +   lwu  R24, [R25, #16]	# loadN, compressed ptr, #@loadN
48c +   decode_heap_oop  R19, R24	#@decodeHeapOop
490 +   beq   R19, zr, B55	#@cmpP_imm0_branch  P=0.452023 C=11714.000000

494     B57: #	out( B79 B58 ) &lt;- in( B56 )  Freq: 3.13576
494 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
494     lb  R7, [R23, #56]	# byte, #@loadB
498 +   bne  R7, zr, B79	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

49c     B58: #	out( B61 B59 ) &lt;- in( B120 B81 B79 B57 )  Freq: 3.13576
49c +   lwu  R7, [R19, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
4a0 +   lw  R28, [R19, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
4a4 +   sw  rheapbase, [R25, #16]	# compressed ptr (rheapbase==0), #@storeImmN0
4a8 +   beq   R7, zr, B61	#@cmpP_narrowOop_imm0_branch  P=0.665213 C=6419.000000

4ac     B59: #	out( B121 B60 ) &lt;- in( B58 )  Freq: 1.04981
4ac +   lwu  R29, [R19, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
4b0 +   mv  R31, narrowklass: precise klass java/util/HashMap$TreeNode: 0x00000040d07784d0:Constant:exact *	# compressed klass ptr, #@loadConNKlass
4c0 +   beq  R29, R31, B121	#@cmpN_branch  P=0.000001 C=-1.000000

4c4     B60: #	out( B69 ) &lt;- in( B59 )  Freq: 1.04981
4c4 +   mv  R20, NULL	# NULL ptr, #@loadConP0
4c8 +   mv  R25, NULL	# NULL ptr, #@loadConP0
4cc +   mv  R29, NULL	# NULL ptr, #@loadConP0
4d0 +   mv  R26, NULL	# NULL ptr, #@loadConP0
4d4 +   j  B69	#@branch

4d8     B61: #	out( B82 B62 ) &lt;- in( B58 )  Freq: 2.08594
4d8 +   spill [sp, #64] -&gt; R29	# spill size = 32
4dc +   andr  R28, R29, R28	#@andI_reg_reg
4e0 +   addw  R7, R28, zr	#@convI2L_reg_reg
4e4 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
4e8 +   add R7, R22, R7	# ptr, #@addP_reg_reg
4ec +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
4ec     lb  R28, [R23, #56]	# byte, #@loadB
4f0 +   addi  R20, R7, #16	# ptr, #@addP_reg_imm
4f4 +   bne  R28, zr, B82	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

4f8     B62: #	out( B55 B63 ) &lt;- in( B122 B84 B82 B61 )  Freq: 2.08594
4f8 +   mv  R7, R20	# ptr -&gt; long, #@castP2X
4fc +   mv  R28, R19	# ptr -&gt; long, #@castP2X
500 +   xorr  R28, R28, R7	#@xorL_reg_reg
504 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
508 +   sw  R24, [R20]	# compressed ptr, #@storeN
50c +   beq  R28, zr, B55	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

510     B63: #	out( B55 B64 ) &lt;- in( B62 )  Freq: 2.08386
510 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
514 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
520 +   add R10, R28, R7	# ptr, #@addP_reg_reg
524 +   lb  R28, [R10]	# byte, #@loadB
528 +   li R7, #4	# int, #@loadConI
52c +   beq  R28, R7, B55	#@cmpI_branch  P=0.999000 C=-1.000000

530     B64: #	out( B55 B65 ) &lt;- in( B63 )  Freq: 0.00208386
530 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
530     ld  R7, [R23, #64]	# int, #@loadL
534 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
534     ld  R28, [R23, #80]	# ptr, #@loadP
538 +   #@membar_volatile
	fence iorw iorw
53c +   lb  R29, [R10]	# byte, #@loadB
540 +   beq  R29, zr, B55	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

544     B65: #	out( B67 B66 ) &lt;- in( B64 )  Freq: 0.00104193
544 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
548 +   bne  R7, zr, B67	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

54c     B66: #	out( B55 ) &lt;- in( B65 )  Freq: 0.000520965
54c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
54c     spill R23 -&gt; R11	# spill size = 64
550 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
580 +   j  B55	#@branch

584     B67: #	out( B55 ) &lt;- in( B65 )  Freq: 0.000520965
584 +   add R28, R28, R7	# ptr, #@addP_reg_reg
588 +   addi  R7, R7, #-8	#@addL_reg_imm
58c +   sd  R10, [R28, #-8]	# ptr, #@storeP
590 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
590     sd  R7, [R23, #64]	# long, #@storeL
594 +   j  B55	#@branch

598     B68: #	out( B69 ) &lt;- in( B40 )  Freq: 1.3097
598 +   lw  R28, [R8, #12]	# int, #@loadI ! Field: java/util/HashMap$Node.hash
59c +   lwu  R7, [R8, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
5a0     spill R19 -&gt; R20	# spill size = 64
5a4 +   encode_heap_oop  R24, R8	#@encodeHeapOop
5a8     spill R8 -&gt; R19	# spill size = 64

5ac     B69: #	out( B30 B70 ) &lt;- in( B60 B68 ) Loop( B69-B68 inner ) Freq: 2.35951
5ac +   spill [sp, #56] -&gt; R31	# spill size = 32
5b0 +   andr  R30, R28, R31	#@andI_reg_reg
5b4 +   decode_heap_oop  R8, R7	#@decodeHeapOop
5b8 +   bne  R30, zr, B30	#@cmpI_reg_imm0_branch  P=0.484265 C=4830.000000

5bc     B70: #	out( B78 B71 ) &lt;- in( B69 )  Freq: 1.21688
5bc +   beq   R20, zr, B78	#@cmpP_imm0_branch  P=0.671618 C=2491.000000

5c0     B71: #	out( B112 B72 ) &lt;- in( B70 )  Freq: 0.399602
5c0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
5c0     lb  R28, [R23, #56]	# byte, #@loadB
5c4 +   bne  R28, zr, B112	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

5c8     B72: #	out( B40 B73 ) &lt;- in( B132 B114 B112 B71 )  Freq: 0.399602
5c8 +   mv  R7, R20	# ptr -&gt; long, #@castP2X
5cc +   mv  R28, R19	# ptr -&gt; long, #@castP2X
5d0 +   xorr  R28, R28, R7	#@xorL_reg_reg
5d4 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
5d8 +   sw  R24, [R20, #24]	# compressed ptr, #@storeN ! Field: java/util/HashMap$Node.next
5dc +   beq  R28, zr, B40	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

5e0     B73: #	out( B40 B74 ) &lt;- in( B72 )  Freq: 0.399202
5e0 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
5e4 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
5f0 +   add R10, R28, R7	# ptr, #@addP_reg_reg
5f4 +   lb  R28, [R10]	# byte, #@loadB
5f8 +   li R7, #4	# int, #@loadConI
5fc +   beq  R28, R7, B40	#@cmpI_branch  P=0.999000 C=-1.000000

600     B74: #	out( B40 B75 ) &lt;- in( B73 )  Freq: 0.000399203
600 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
600     ld  R7, [R23, #64]	# int, #@loadL
604 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
604     ld  R30, [R23, #80]	# ptr, #@loadP
608 +   #@membar_volatile
	fence iorw iorw
60c +   lb  R28, [R10]	# byte, #@loadB
610 +   beq  R28, zr, B40	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

614     B75: #	out( B77 B76 ) &lt;- in( B74 )  Freq: 0.000199601
614 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
618 +   bne  R7, zr, B77	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

61c     B76: #	out( B40 ) &lt;- in( B75 )  Freq: 9.98006e-05
61c +   spill R29 -&gt; [sp, #8]	# spill size = 64
620     
620     
620 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
620     spill R23 -&gt; R11	# spill size = 64
624 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
654 +   spill R25 -&gt; [sp, #0]	# spill size = 64
658 +   spill R22 -&gt; R25	# spill size = 64
65c +   spill R21 -&gt; R22	# spill size = 32
660 +   spill R22 -&gt; R21	# spill size = 32
664 +   spill R25 -&gt; R22	# spill size = 64
668 +   spill R26 -&gt; [sp, #16]	# spill size = 64
66c +   spill [sp, #0] -&gt; R25	# spill size = 64
670 +   spill [sp, #8] -&gt; R29	# spill size = 64
674 +   spill [sp, #16] -&gt; R26	# spill size = 64
678 +   j  B40	#@branch

67c     B77: #	out( B40 ) &lt;- in( B75 )  Freq: 9.98006e-05
67c +   add R28, R30, R7	# ptr, #@addP_reg_reg
680 +   addi  R7, R7, #-8	#@addL_reg_imm
684 +   sd  R10, [R28, #-8]	# ptr, #@storeP
688 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
688     sd  R7, [R23, #64]	# long, #@storeL
68c +   j  B40	#@branch

690     B78: #	out( B40 ) &lt;- in( B70 )  Freq: 0.817279
690 +   spill R19 -&gt; R29	# spill size = 64
694 +   j  B40	#@branch

698     B79: #	out( B58 B80 ) &lt;- in( B57 )  Freq: 0.00313572
698 +   lwu  R28, [R25, #16]	# loadN, compressed ptr, #@loadN
69c +   decode_heap_oop  R10, R28	#@decodeHeapOop
6a0 +   beq   R10, zr, B58	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

6a4     B80: #	out( B120 B81 ) &lt;- in( B79 )  Freq: 0.00156786
6a4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6a4     ld  R7, [R23, #32]	# int, #@loadL
6a8 +   beq  R7, zr, B120	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

6ac     B81: #	out( B58 ) &lt;- in( B80 )  Freq: 0.00156629
6ac +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6ac     ld  R28, [R23, #48]	# ptr, #@loadP
6b0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
6b4 +   addi  R7, R7, #-8	#@addL_reg_imm
6b8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
6bc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6bc     sd  R7, [R23, #32]	# long, #@storeL
6c0 +   j  B58	#@branch

6c4     B82: #	out( B62 B83 ) &lt;- in( B61 )  Freq: 0.00208592
6c4 +   lwu  R28, [R20]	# loadN, compressed ptr, #@loadN
6c8 +   decode_heap_oop  R10, R28	#@decodeHeapOop
6cc +   beq   R10, zr, B62	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

6d0     B83: #	out( B122 B84 ) &lt;- in( B82 )  Freq: 0.00104296
6d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6d0     ld  R7, [R23, #32]	# int, #@loadL
6d4 +   beq  R7, zr, B122	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

6d8     B84: #	out( B62 ) &lt;- in( B83 )  Freq: 0.00104192
6d8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6d8     ld  R28, [R23, #48]	# ptr, #@loadP
6dc +   add R28, R28, R7	# ptr, #@addP_reg_reg
6e0 +   addi  R7, R7, #-8	#@addL_reg_imm
6e4 +   sd  R10, [R28, #-8]	# ptr, #@storeP
6e8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
6e8     sd  R7, [R23, #32]	# long, #@storeL
6ec +   j  B62	#@branch

6f0     B85: #	out( B15 B86 ) &lt;- in( B14 )  Freq: 0.000999986
6f0 +   spill [sp, #40] -&gt; R7	# spill size = 64
6f4 +   lwu  R7, [R7, #36]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap.table
6f8 +   decode_heap_oop  R10, R7	#@decodeHeapOop
6fc +   beq   R10, zr, B15	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

700     B86: #	out( B125 B87 ) &lt;- in( B85 )  Freq: 0.000499993
700 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
700     ld  R7, [R23, #32]	# int, #@loadL
704 +   beq  R7, zr, B125	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

708     B87: #	out( B15 ) &lt;- in( B86 )  Freq: 0.000499493
708 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
708     ld  R28, [R23, #48]	# ptr, #@loadP
70c +   add R28, R28, R7	# ptr, #@addP_reg_reg
710 +   addi  R7, R7, #-8	#@addL_reg_imm
714 +   sd  R10, [R28, #-8]	# ptr, #@storeP
718 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
718     sd  R7, [R23, #32]	# long, #@storeL
71c +   j  B15	#@branch

720     B88: #	out( B17 B89 ) &lt;- in( B16 )  Freq: 0.000998999
720 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
720     ld  R7, [R23, #64]	# int, #@loadL
724 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
724     ld  R28, [R23, #80]	# ptr, #@loadP
728 +   #@membar_volatile
	fence iorw iorw
72c +   lb  R29, [R10]	# byte, #@loadB
730 +   beq  R29, zr, B17	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

734     B89: #	out( B91 B90 ) &lt;- in( B88 )  Freq: 0.0004995
734 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
738 +   bne  R7, zr, B91	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

73c     B90: #	out( B17 ) &lt;- in( B89 )  Freq: 0.00024975
73c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
73c     spill R23 -&gt; R11	# spill size = 64
740 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
770 +   j  B17	#@branch

774     B91: #	out( B17 ) &lt;- in( B89 )  Freq: 0.00024975
774 +   add R28, R28, R7	# ptr, #@addP_reg_reg
778 +   addi  R7, R7, #-8	#@addL_reg_imm
77c +   sd  R10, [R28, #-8]	# ptr, #@storeP
780 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
780     sd  R7, [R23, #64]	# long, #@storeL
784 +   j  B17	#@branch

788     B92: #	out( B43 B93 ) &lt;- in( B42 )  Freq: 0.000817269
788 +   lwu  R7, [R19, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
78c +   decode_heap_oop  R10, R7	#@decodeHeapOop
790 +   beq   R10, zr, B43	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

794     B93: #	out( B126 B94 ) &lt;- in( B92 )  Freq: 0.000408634
794 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
794     ld  R7, [R23, #32]	# int, #@loadL
798 +   beq  R7, zr, B126	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

79c     B94: #	out( B43 ) &lt;- in( B93 )  Freq: 0.000408226
79c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
79c     ld  R28, [R23, #48]	# ptr, #@loadP
7a0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
7a4 +   addi  R7, R7, #-8	#@addL_reg_imm
7a8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
7ac +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7ac     sd  R7, [R23, #32]	# long, #@storeL
7b0 +   j  B43	#@branch

7b4     B95: #	out( B45 B96 ) &lt;- in( B44 )  Freq: 0.000817268
7b4 +   lwu  R28, [R20]	# loadN, compressed ptr, #@loadN
7b8 +   decode_heap_oop  R10, R28	#@decodeHeapOop
7bc +   beq   R10, zr, B45	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

7c0     B96: #	out( B127 B97 ) &lt;- in( B95 )  Freq: 0.000408634
7c0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7c0     ld  R7, [R23, #32]	# int, #@loadL
7c4 +   beq  R7, zr, B127	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

7c8     B97: #	out( B45 ) &lt;- in( B96 )  Freq: 0.000408225
7c8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7c8     ld  R28, [R23, #48]	# ptr, #@loadP
7cc +   add R28, R28, R7	# ptr, #@addP_reg_reg
7d0 +   addi  R7, R7, #-8	#@addL_reg_imm
7d4 +   sd  R10, [R28, #-8]	# ptr, #@storeP
7d8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7d8     sd  R7, [R23, #32]	# long, #@storeL
7dc +   j  B45	#@branch

7e0     B98: #	out( B48 B99 ) &lt;- in( B47 )  Freq: 0.000815645
7e0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7e0     ld  R7, [R23, #64]	# int, #@loadL
7e4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7e4     ld  R28, [R23, #80]	# ptr, #@loadP
7e8 +   #@membar_volatile
	fence iorw iorw
7ec +   lb  R30, [R10]	# byte, #@loadB
7f0 +   beq  R30, zr, B48	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

7f4     B99: #	out( B101 B100 ) &lt;- in( B98 )  Freq: 0.000407822
7f4 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
7f8 +   bne  R7, zr, B101	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

7fc     B100: #	out( B48 ) &lt;- in( B99 )  Freq: 0.000203911
7fc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
7fc     spill R23 -&gt; R11	# spill size = 64
800 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
830 +   j  B48	#@branch

834     B101: #	out( B48 ) &lt;- in( B99 )  Freq: 0.000203911
834 +   add R28, R28, R7	# ptr, #@addP_reg_reg
838 +   addi  R7, R7, #-8	#@addL_reg_imm
83c +   sd  R10, [R28, #-8]	# ptr, #@storeP
840 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
840     sd  R7, [R23, #64]	# long, #@storeL
844 +   j  B48	#@branch

848     B102: #	out( B50 B103 ) &lt;- in( B49 )  Freq: 0.00080994
848 +   lwu  R7, [R25, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
84c +   decode_heap_oop  R10, R7	#@decodeHeapOop
850 +   beq   R10, zr, B50	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

854     B103: #	out( B128 B104 ) &lt;- in( B102 )  Freq: 0.00040497
854 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
854     ld  R7, [R23, #32]	# int, #@loadL
858 +   beq  R7, zr, B128	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

85c     B104: #	out( B50 ) &lt;- in( B103 )  Freq: 0.000404565
85c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
85c     ld  R28, [R23, #48]	# ptr, #@loadP
860 +   add R28, R28, R7	# ptr, #@addP_reg_reg
864 +   addi  R7, R7, #-8	#@addL_reg_imm
868 +   sd  R10, [R28, #-8]	# ptr, #@storeP
86c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
86c     sd  R7, [R23, #32]	# long, #@storeL
870 +   j  B50	#@branch

874     B105: #	out( B52 B106 ) &lt;- in( B51 )  Freq: 0.000809939
874 +   lwu  R28, [R19]	# loadN, compressed ptr, #@loadN
878 +   decode_heap_oop  R10, R28	#@decodeHeapOop
87c +   beq   R10, zr, B52	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

880     B106: #	out( B129 B107 ) &lt;- in( B105 )  Freq: 0.00040497
880 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
880     ld  R7, [R23, #32]	# int, #@loadL
884 +   beq  R7, zr, B129	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

888     B107: #	out( B52 ) &lt;- in( B106 )  Freq: 0.000404565
888 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
888     ld  R28, [R23, #48]	# ptr, #@loadP
88c +   add R28, R28, R7	# ptr, #@addP_reg_reg
890 +   addi  R7, R7, #-8	#@addL_reg_imm
894 +   sd  R10, [R28, #-8]	# ptr, #@storeP
898 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
898     sd  R7, [R23, #32]	# long, #@storeL
89c +   j  B52	#@branch

8a0     B108: #	out( B55 B109 ) &lt;- in( B54 )  Freq: 0.000808331
8a0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8a0     ld  R7, [R23, #64]	# int, #@loadL
8a4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8a4     ld  R28, [R23, #80]	# ptr, #@loadP
8a8 +   #@membar_volatile
	fence iorw iorw
8ac +   lb  R30, [R10]	# byte, #@loadB
8b0 +   beq  R30, zr, B55	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

8b4     B109: #	out( B111 B110 ) &lt;- in( B108 )  Freq: 0.000404165
8b4 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
8b8 +   bne  R7, zr, B111	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

8bc     B110: #	out( B55 ) &lt;- in( B109 )  Freq: 0.000202083
8bc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
8bc     spill R23 -&gt; R11	# spill size = 64
8c0 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
8f0 +   j  B55	#@branch

8f4     B111: #	out( B55 ) &lt;- in( B109 )  Freq: 0.000202083
8f4 +   add R28, R28, R7	# ptr, #@addP_reg_reg
8f8 +   addi  R7, R7, #-8	#@addL_reg_imm
8fc +   sd  R10, [R28, #-8]	# ptr, #@storeP
900 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
900     sd  R7, [R23, #64]	# long, #@storeL
904 +   j  B55	#@branch

908     B112: #	out( B72 B113 ) &lt;- in( B71 )  Freq: 0.000399597
908 +   lwu  R7, [R20, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
90c +   decode_heap_oop  R10, R7	#@decodeHeapOop
910 +   beq   R10, zr, B72	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

914     B113: #	out( B132 B114 ) &lt;- in( B112 )  Freq: 0.000199798
914 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
914     ld  R7, [R23, #32]	# int, #@loadL
918 +   beq  R7, zr, B132	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

91c     B114: #	out( B72 ) &lt;- in( B113 )  Freq: 0.000199599
91c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
91c     ld  R28, [R23, #48]	# ptr, #@loadP
920 +   add R28, R28, R7	# ptr, #@addP_reg_reg
924 +   addi  R7, R7, #-8	#@addL_reg_imm
928 +   sd  R10, [R28, #-8]	# ptr, #@storeP
92c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
92c     sd  R7, [R23, #32]	# long, #@storeL
930 +   j  B72	#@branch

934     B115: #	out( B32 B116 ) &lt;- in( B31 )  Freq: 0.000332672
934 +   lwu  R28, [R25, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
938 +   decode_heap_oop  R10, R28	#@decodeHeapOop
93c +   beq   R10, zr, B32	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

940     B116: #	out( B135 B117 ) &lt;- in( B115 )  Freq: 0.000166336
940 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
940     ld  R7, [R23, #32]	# int, #@loadL
944 +   beq  R7, zr, B135	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

948     B117: #	out( B32 ) &lt;- in( B116 )  Freq: 0.00016617
948 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
948     ld  R28, [R23, #48]	# ptr, #@loadP
94c +   add R28, R28, R7	# ptr, #@addP_reg_reg
950 +   addi  R7, R7, #-8	#@addL_reg_imm
954 +   sd  R10, [R28, #-8]	# ptr, #@storeP
958 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
958     sd  R7, [R23, #32]	# long, #@storeL
95c +   j  B32	#@branch

960     B118: #	out( B138 B119 ) &lt;- in( B11 B12 )  Freq: 0.00010103
960 +   mv  R11, precise klass [Ljava/util/HashMap$Node;: 0x00000040d09f4300:Constant:exact *	# ptr, #@loadConP
978     spill [sp, #24] -&gt; R12	# spill size = 32
97c +   spill [sp, #40] -&gt; R8	# spill size = 64
980     CALL,static 0x000000401390d640	#@CallStaticJavaDirect wrapper for: _new_array_Java
        # java.util.HashMap::resize @ bci:133 (line 702) L[0]=R8 L[1]=sp + #48 L[2]=sp + #56 L[3]=_ L[4]=sp + #24 L[5]=_ L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_
        # OopMap {fp=Oop [40]=Oop [48]=Oop off=2436/0x984}

984     B119: #	out( B14 ) &lt;- in( B118 )  Freq: 0.000101028
        # Block is sole successor of call
984 +   spill R10 -&gt; R22	# spill size = 64
988 +   j  B14	#@branch

98c     B120: #	out( B58 ) &lt;- in( B80 )  Freq: 1.56784e-06
98c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
98c     spill R23 -&gt; R11	# spill size = 64
990 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
9c0 +   spill R22 -&gt; [sp, #0]	# spill size = 64
9c4 +   spill R21 -&gt; R22	# spill size = 32
9c8 +   spill R22 -&gt; R21	# spill size = 32
9cc +   spill [sp, #0] -&gt; R22	# spill size = 64
9d0 +   j  B58	#@branch

9d4     B121: #	out( N2056 ) &lt;- in( B59 )  Freq: 1.06375e-06
9d4 +   li R11, #-187	# int, #@loadConI
9d8     spill R21 -&gt; [sp, #0]	# spill size = 32
9dc +   spill R19 -&gt; [sp, #8]	# spill size = 64
9e0 +   spill R22 -&gt; [sp, #32]	# spill size = 64
9e4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::resize @ bci:203 (line 711) L[0]=sp + #40 L[1]=sp + #48 L[2]=sp + #56 L[3]=_ L[4]=sp + #60 L[5]=_ L[6]=sp + #32 L[7]=sp + #0 L[8]=sp + #8 L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ STK[0]=#1
        # OopMap {[8]=Oop [32]=Oop [40]=Oop [48]=Oop off=2536/0x9e8}
9e8     #@ShouldNotReachHere

9f4     B122: #	out( B62 ) &lt;- in( B83 )  Freq: 1.04295e-06
9f4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
9f4     spill R23 -&gt; R11	# spill size = 64
9f8 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
a28 +   j  B62	#@branch

a2c     B123: #	out( N2056 ) &lt;- in( B43 )  Freq: 8.28132e-07
a2c +   spill [sp, #40] -&gt; R7	# spill size = 64
a30 +   spill R7 -&gt; [sp, #8]	# spill size = 64
a34 +   spill [sp, #56] -&gt; R28	# spill size = 32
a38 +   spill [sp, #60] -&gt; R7	# spill size = 32
a3c +   spill [sp, #48] -&gt; R8	# spill size = 64
a40 +   li R11, #-28	# int, #@loadConI
a44     spill R21 -&gt; [sp, #4]	# spill size = 32
a48 +   spill R28 -&gt; [sp, #16]	# spill size = 32
a4c +   spill R7 -&gt; [sp, #20]	# spill size = 32
a50 +   spill R26 -&gt; [sp, #32]	# spill size = 64
a54 +   spill R25 -&gt; [sp, #40]	# spill size = 64
a58 +   spill R22 -&gt; [sp, #48]	# spill size = 64
a5c +   spill R29 -&gt; [sp, #56]	# spill size = 64
a60     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.HashMap::resize @ bci:326 (line 736) L[0]=sp + #8 L[1]=R8 L[2]=sp + #16 L[3]=_ L[4]=sp + #20 L[5]=_ L[6]=sp + #48 L[7]=sp + #4 L[8]=_ L[9]=_ L[10]=_ L[11]=sp + #32 L[12]=sp + #40 L[13]=_ STK[0]=sp + #48 STK[1]=sp + #4 STK[2]=sp + #56
        # OopMap {fp=Oop [8]=Oop [32]=Oop [40]=Oop [48]=Oop [56]=Oop off=2660/0xa64}
a64     #@ShouldNotReachHere

a70     B124: #	out( N2056 ) &lt;- in( B50 )  Freq: 8.20706e-07
a70 +   spill [sp, #48] -&gt; R7	# spill size = 64
a74 +   spill R7 -&gt; [sp, #0]	# spill size = 64
a78 +   spill [sp, #40] -&gt; R7	# spill size = 64
a7c +   li R11, #-28	# int, #@loadConI
a80     spill R21 -&gt; [sp, #8]	# spill size = 32
a84 +   spill R7 -&gt; [sp, #16]	# spill size = 64
a88 +   spill R22 -&gt; [sp, #40]	# spill size = 64
a8c +   spill R26 -&gt; [sp, #48]	# spill size = 64
a90     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.HashMap::resize @ bci:346 (line 740) L[0]=sp + #16 L[1]=sp + #0 L[2]=sp + #56 L[3]=_ L[4]=sp + #60 L[5]=_ L[6]=sp + #40 L[7]=sp + #8 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ STK[0]=sp + #40 STK[1]=R8 STK[2]=sp + #48
        # OopMap {[0]=Oop [16]=Oop [40]=Oop [48]=Oop off=2708/0xa94}
a94     #@ShouldNotReachHere

aa0     B125: #	out( B15 ) &lt;- in( B86 )  Freq: 4.99987e-07
aa0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
aa0     spill R23 -&gt; R11	# spill size = 64
aa4 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
ad4 +   j  B15	#@branch

ad8     B126: #	out( B43 ) &lt;- in( B93 )  Freq: 4.08629e-07
ad8 +   spill R29 -&gt; [sp, #0]	# spill size = 64
adc     
adc     
adc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
adc     spill R23 -&gt; R11	# spill size = 64
ae0 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
b10 +   spill R25 -&gt; R8	# spill size = 64
b14 +   spill R22 -&gt; R25	# spill size = 64
b18 +   spill R21 -&gt; R22	# spill size = 32
b1c +   spill R22 -&gt; R21	# spill size = 32
b20 +   spill R25 -&gt; R22	# spill size = 64
b24 +   spill R26 -&gt; [sp, #8]	# spill size = 64
b28 +   spill R8 -&gt; R25	# spill size = 64
b2c +   spill [sp, #0] -&gt; R29	# spill size = 64
b30 +   spill [sp, #8] -&gt; R26	# spill size = 64
b34 +   j  B43	#@branch

b38     B127: #	out( B45 ) &lt;- in( B96 )  Freq: 4.08629e-07
b38 +   spill R29 -&gt; R8	# spill size = 64
b3c     
b3c     
b3c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
b3c     spill R23 -&gt; R11	# spill size = 64
b40 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
b70 +   spill R26 -&gt; [sp, #0]	# spill size = 64
b74 +   spill R25 -&gt; R26	# spill size = 64
b78 +   spill R22 -&gt; R25	# spill size = 64
b7c +   spill R25 -&gt; R22	# spill size = 64
b80 +   spill R21 -&gt; R24	# spill size = 32
b84 +   spill R26 -&gt; R25	# spill size = 64
b88 +   spill R24 -&gt; R21	# spill size = 32
b8c +   spill R8 -&gt; R29	# spill size = 64
b90 +   spill [sp, #0] -&gt; R26	# spill size = 64
b94 +   j  B45	#@branch

b98     B128: #	out( B50 ) &lt;- in( B103 )  Freq: 4.04965e-07
b98 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
b98     spill R23 -&gt; R11	# spill size = 64
b9c +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
bcc +   j  B50	#@branch

bd0     B129: #	out( B52 ) &lt;- in( B106 )  Freq: 4.04965e-07
bd0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
bd0     spill R23 -&gt; R11	# spill size = 64
bd4 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
c04 +   j  B52	#@branch

c08     B130: #	out( N2056 ) &lt;- in( B9 )  Freq: 2.57694e-07
c08 +   flt.s  R28, F2, F0	#@cmpF3_reg_reg
	bgtz   R28, done
	feq.s  R28, F0, F2
	addi   R28, R28, -1	#@cmpF3_reg_reg
c18 +   subw  R8, x0, R28	# int, #@negI_reg
c1c     spill F2 -&gt; [sp, #8]	# spill size = 32
c20 +   li R11, #-187	# int, #@loadConI
c24     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::resize @ bci:112 (line 697) L[0]=sp + #40 L[1]=sp + #48 L[2]=sp + #56 L[3]=_ L[4]=sp + #24 L[5]=_ L[6]=sp + #8 L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ STK[0]=R8
        # OopMap {[40]=Oop [48]=Oop off=3112/0xc28}
c28     #@ShouldNotReachHere

c34     B131: #	out( N2056 ) &lt;- in( B8 )  Freq: 2.45756e-07
c34 +   spill F2 -&gt; [sp, #0]	# spill size = 32
c38 +   li R11, #-187	# int, #@loadConI
c3c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::resize @ bci:104 (line 697) L[0]=sp + #40 L[1]=sp + #48 L[2]=sp + #56 L[3]=_ L[4]=sp + #24 L[5]=_ L[6]=sp + #0 L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ STK[0]=sp + #24 STK[1]=#1073741824
        # OopMap {[40]=Oop [48]=Oop off=3136/0xc40}
c40     #@ShouldNotReachHere

c4c     B132: #	out( B72 ) &lt;- in( B113 )  Freq: 1.99796e-07
c4c +   spill R29 -&gt; [sp, #24]	# spill size = 64
c50     
c50     
c50 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
c50     spill R23 -&gt; R11	# spill size = 64
c54 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
c84 +   spill R26 -&gt; [sp, #32]	# spill size = 64
c88 +   spill R21 -&gt; R26	# spill size = 32
c8c +   spill R22 -&gt; [sp, #8]	# spill size = 64
c90 +   spill R25 -&gt; [sp, #16]	# spill size = 64
c94 +   spill R26 -&gt; R21	# spill size = 32
c98 +   spill [sp, #8] -&gt; R22	# spill size = 64
c9c +   spill [sp, #16] -&gt; R25	# spill size = 64
ca0 +   spill [sp, #24] -&gt; R29	# spill size = 64
ca4 +   spill [sp, #32] -&gt; R26	# spill size = 64
ca8 +   j  B72	#@branch

cac     B133: #	out( N2056 ) &lt;- in( B27 B26 )  Freq: 3.74899e-07
cac +   li R11, #-138	# int, #@loadConI
cb0     spill R22 -&gt; [sp, #16]	# spill size = 64
cb4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::resize @ bci:154 (line 705) L[0]=sp + #40 L[1]=sp + #48 L[2]=sp + #56 L[3]=_ L[4]=sp + #60 L[5]=_ L[6]=sp + #16 L[7]=#0 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ STK[0]=#0 STK[1]=sp + #56
        # OopMap {[16]=Oop [40]=Oop [48]=Oop off=3256/0xcb8}
cb8     #@ShouldNotReachHere

cc4     B134: #	out( N2056 ) &lt;- in( B28 )  Freq: 1.86213e-07
cc4 +   li R11, #-66	# int, #@loadConI
cc8     spill R22 -&gt; [sp, #16]	# spill size = 64
ccc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;profile_predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap::resize @ bci:154 (line 705) L[0]=sp + #40 L[1]=sp + #48 L[2]=sp + #56 L[3]=_ L[4]=sp + #60 L[5]=_ L[6]=sp + #16 L[7]=#0 L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ STK[0]=#0 STK[1]=sp + #56
        # OopMap {[16]=Oop [40]=Oop [48]=Oop off=3280/0xcd0}
cd0     #@ShouldNotReachHere

cdc     B135: #	out( B32 ) &lt;- in( B116 )  Freq: 1.66334e-07
cdc +   spill R29 -&gt; [sp, #24]	# spill size = 64
ce0     
ce0     
ce0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
ce0     spill R23 -&gt; R11	# spill size = 64
ce4 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
d14 +   spill R26 -&gt; [sp, #32]	# spill size = 64
d18 +   spill R21 -&gt; R26	# spill size = 32
d1c +   spill R22 -&gt; [sp, #8]	# spill size = 64
d20 +   spill R25 -&gt; [sp, #16]	# spill size = 64
d24 +   spill R26 -&gt; R21	# spill size = 32
d28 +   spill [sp, #8] -&gt; R22	# spill size = 64
d2c +   spill [sp, #16] -&gt; R25	# spill size = 64
d30 +   spill [sp, #24] -&gt; R29	# spill size = 64
d34 +   spill [sp, #32] -&gt; R26	# spill size = 64
d38 +   j  B32	#@branch

d3c     B136: #	out( N2056 ) &lt;- in( B19 )  Freq: 9.17801e-08
d3c +   li R11, #-187	# int, #@loadConI
d40     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::resize @ bci:31 (line 681) L[0]=sp + #40 L[1]=sp + #48 L[2]=sp + #56 L[3]=sp + #24 L[4]=_ L[5]=#0 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ STK[0]=sp + #56 STK[1]=#1073741824
        # OopMap {[40]=Oop [48]=Oop off=3396/0xd44}
d44     #@ShouldNotReachHere

d50     B137: #	out( N2056 ) &lt;- in( B20 )  Freq: 9.178e-08
d50 +   li R11, #-187	# int, #@loadConI
d54     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap::resize @ bci:50 (line 685) L[0]=sp + #40 L[1]=sp + #48 L[2]=sp + #56 L[3]=sp + #24 L[4]=R8 L[5]=#0 L[6]=_ L[7]=_ L[8]=_ L[9]=_ L[10]=_ L[11]=_ L[12]=_ L[13]=_ STK[0]=R8 STK[1]=#1073741824
        # OopMap {[40]=Oop [48]=Oop off=3416/0xd58}
d58     #@ShouldNotReachHere

d64     B138: #	out( N2056 ) &lt;- in( B118 )  Freq: 1.0103e-09
d64      -- 	// exception oop; no code emitted, #@CreateException
d64 +   spill R10 -&gt; R11	# spill size = 64
d68 +   # pop frame 112
	add  sp, sp, #112
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
d74 +   j rethrow_stub	#@RethrowException

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='606'>
----------------------- MetaData before Compile_id = 606 ------------------------
{method}
 - this oop:          0x00000040961efe88
 - method holder:     &apos;java/util/HashMap$HashIterator&apos;
 - constants:         0x00000040961ef810 constant pool [90] {0x00000040961ef810} for &apos;java/util/HashMap$HashIterator&apos; cache=0x00000040961f0040
 - access:            0xc1000010  final 
 - name:              &apos;nextNode&apos;
 - signature:         &apos;()Ljava/util/HashMap$Node;&apos;
 - max stack:         7
 - max locals:        3
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c576780
 - code size:         100
 - code start:        0x00000040961efdf0
 - code end (excl):   0x00000040961efe54
 - method data:       0x00000040964a6460
 - checked ex length: 0
 - linenumber start:  0x00000040961efe54
 - localvar length:   3
 - localvar start:    0x00000040961efe60
 - compiled code: nmethod  24795  344       3       java.util.HashMap$HashIterator::nextNode (100 bytes)

------------------------ OptoAssembly for Compile_id = 606 -----------------------
#
#  java/util/HashMap$Node * ( java/util/HashMap$HashIterator:NotNull * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/HashMap$HashIterator:NotNull *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N565: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B50 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     lwu  R7, [R11, #28]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$HashIterator.this$0
040 +   lwu  R18, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$HashIterator.next
044     spill R11 -&gt; R21	# spill size = 64
048 +   decode_heap_oop  R7, R7	#@decodeHeapOop
04c     lw  R7, [R7, #24]	# int, #@loadI ! Field: java/util/HashMap.modCount
050     NullCheck R7

050     B2: #	out( B48 B3 ) &lt;- in( B1 )  Freq: 0.999999
050 +   lw  R8, [R11, #12]	# int, #@loadI ! Field: java/util/HashMap$HashIterator.expectedModCount
054 +   decode_heap_oop  R20, R18	#@decodeHeapOop
058 +   bne  R7, R8, B48	#@cmpI_branch  P=0.000000 C=5119.000000

05c     B3: #	out( B49 B4 ) &lt;- in( B2 )  Freq: 0.999999
05c +   beq   R20, zr, B49	#@cmpP_imm0_branch  P=0.000000 C=5119.000000

060     B4: #	out( B30 B5 ) &lt;- in( B3 )  Freq: 0.999998
060 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
060     lb  R28, [R23, #56]	# byte, #@loadB
064 +   bne  R28, zr, B30	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

068     B5: #	out( B7 B6 ) &lt;- in( B46 B32 B30 B4 )  Freq: 0.999998
068 +   mv  R7, R21	# ptr -&gt; long, #@castP2X
06c +   mv  R28, R20	# ptr -&gt; long, #@castP2X
070 +   xorr  R28, R28, R7	#@xorL_reg_reg
074 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
078 +   li R9, #4	# int, #@loadConI
07c +   mv  R22, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
088 +   sw  R18, [R21, #24]	# compressed ptr, #@storeN ! Field: java/util/HashMap$HashIterator.current
08c +   beq  R28, zr, B7	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

090     B6: #	out( B36 B7 ) &lt;- in( B5 )  Freq: 0.998998
090 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
094 +   add R10, R22, R7	# ptr, #@addP_reg_reg
098 +   lb  R7, [R10]	# byte, #@loadB
09c +   bne  R7, R9, B36	#@cmpI_branch  P=0.001000 C=-1.000000

0a0     B7: #	out( B33 B8 ) &lt;- in( B38 B39 B36 B6 B5 )  Freq: 0.999998
0a0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0a0     lb  R28, [R23, #56]	# byte, #@loadB
0a4 +   lwu  R19, [R20, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$Node.next
0a8 +   bne  R28, zr, B33	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

0ac     B8: #	out( B11 B9 ) &lt;- in( B47 B35 B33 B7 )  Freq: 0.999998
0ac +   decode_heap_oop  R18, R19	#@decodeHeapOop
0b0 +   mv  R7, R21	# ptr -&gt; long, #@castP2X
0b4 +   mv  R28, R18	# ptr -&gt; long, #@castP2X
0b8 +   xorr  R28, R28, R7	#@xorL_reg_reg
0bc +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
0c0 +   sw  R19, [R21, #20]	# compressed ptr, #@storeN ! Field: java/util/HashMap$HashIterator.next
0c4 +   beq  R28, zr, B11	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0c8     B9: #	out( B11 B10 ) &lt;- in( B8 )  Freq: 0.998998
0c8 +   beq   R18, zr, B11	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

0cc     B10: #	out( B40 B11 ) &lt;- in( B9 )  Freq: 0.997999
0cc +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
0d0 +   add R10, R22, R7	# ptr, #@addP_reg_reg
0d4 +   lb  R28, [R10]	# byte, #@loadB
0d8 +   bne  R28, R9, B40	#@cmpI_branch  P=0.001000 C=-1.000000

0dc     B11: #	out( B22 B12 ) &lt;- in( B42 B43 B40 B10 B9 B8 )  Freq: 0.999998
0dc +   bne   R18, zr, B22	#@cmpP_imm0_branch  P=0.153350 C=5119.000000

0e0     B12: #	out( B51 B13 ) &lt;- in( B11 )  Freq: 0.846648
0e0 +   lwu  R7, [R21, #28]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$HashIterator.this$0
0e4 +   decode_heap_oop  R7, R7	#@decodeHeapOop
0e8     lwu  R28, [R7, #36]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap.table
0ec     NullCheck R7

0ec     B13: #	out( B52 B14 ) &lt;- in( B12 )  Freq: 0.846647
0ec +   lw  R29, [R21, #16]	# int, #@loadI ! Field: java/util/HashMap$HashIterator.index
0f0 +   decode_heap_oop  R8, R28	#@decodeHeapOop
0f4     lwu  R19, [R8, #12]	# range, #@loadRange
0f8     NullCheck R8

0f8     B14: #	out( B22 B15 ) &lt;- in( B13 )  Freq: 0.846647
0f8 +   bge  R29, R19, B22	#@cmpI_branch  P=0.069047 C=16496.000000
        nop 	# 2 bytes pad for loops and calls

100     B15: #	out( B44 B16 ) &lt;- in( B14 B21 ) Loop( B15-B21 inner ) Freq: 2.99998
100 +   addw  R7, R29, zr	#@convI2L_reg_reg
104 +   addiw  R28, R29, #1	#@addI_reg_imm
108 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
10c +   sw  R28, [R21, #16]	# int, #@storeI ! Field: java/util/HashMap$HashIterator.index
110 +   bgeu  R29, R19, B44	#@cmpU_branch  P=0.000001 C=-1.000000

114     B16: #	out( B23 B17 ) &lt;- in( B15 )  Freq: 2.99998
114 +   add R7, R8, R7	# ptr, #@addP_reg_reg
118 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
118     lb  R29, [R23, #56]	# byte, #@loadB
11c +   lwu  R18, [R7, #16]	# loadN, compressed ptr, #@loadN
120 +   bne  R29, zr, B23	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

124     B17: #	out( B20 B18 ) &lt;- in( B45 B25 B23 B16 )  Freq: 2.99998
124 +   decode_heap_oop  R24, R18	#@decodeHeapOop
128 +   mv  R7, R21	# ptr -&gt; long, #@castP2X
12c +   mv  R28, R24	# ptr -&gt; long, #@castP2X
130 +   xorr  R28, R28, R7	#@xorL_reg_reg
134 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
138 +   sw  R18, [R21, #20]	# compressed ptr, #@storeN ! Field: java/util/HashMap$HashIterator.next
13c +   beq  R28, zr, B20	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

140     B18: #	out( B20 B19 ) &lt;- in( B17 )  Freq: 2.99698
140 +   beq   R24, zr, B20	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

144     B19: #	out( B26 B20 ) &lt;- in( B18 )  Freq: 2.99398
144 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
148 +   add R10, R22, R7	# ptr, #@addP_reg_reg
14c +   lb  R7, [R10]	# byte, #@loadB
150 +   bne  R7, R9, B26	#@cmpI_branch  P=0.001000 C=-1.000000

154     B20: #	out( B22 B21 ) &lt;- in( B28 B29 B26 B19 B18 B17 )  Freq: 2.99998
154 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
154     ld  R7, [R23, #920]	# ptr, #@loadP
158 +   lwu zr, [R7]	# Safepoint: poll for GC, #@safePoint        # java.util.HashMap$HashIterator::nextNode @ bci:95 (line 1601) L[0]=R21 L[1]=R8 L[2]=R20 STK[0]=R24
        # OopMap {esp=Oop xdispatch=Oop xlocals=Oop fp=Oop off=344/0x158}
15c +   bne   R24, zr, B22	#@cmpP_imm0_branch  P=0.208048 C=15357.000000

160     B21: #	out( B15 B22 ) &lt;- in( B20 )  Freq: 2.37584
160 +   lw  R29, [R21, #16]	# int, #@loadI ! Field: java/util/HashMap$HashIterator.index
164 +   blt  R29, R19, B15	#@cmpI_branch  P=0.930953 C=16496.000000

168     B22: #	out( N565 ) &lt;- in( B11 B21 B20 B14 )  Freq: 0.999994
168 +   spill R20 -&gt; R10	# spill size = 64
16c +   # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
184 +   ret	// return register, #@Ret

188     B23: #	out( B17 B24 ) &lt;- in( B16 )  Freq: 0.00299994
188 +   lwu  R7, [R21, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$HashIterator.next
18c +   decode_heap_oop  R10, R7	#@decodeHeapOop
190 +   beq   R10, zr, B17	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

194     B24: #	out( B45 B25 ) &lt;- in( B23 )  Freq: 0.00149997
194 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
194     ld  R7, [R23, #32]	# int, #@loadL
198 +   beq  R7, zr, B45	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

19c     B25: #	out( B17 ) &lt;- in( B24 )  Freq: 0.00149847
19c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
19c     ld  R28, [R23, #48]	# ptr, #@loadP
1a0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
1a4 +   addi  R7, R7, #-8	#@addL_reg_imm
1a8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
1ac +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1ac     sd  R7, [R23, #32]	# long, #@storeL
1b0 +   j  B17	#@branch

1b4     B26: #	out( B20 B27 ) &lt;- in( B19 )  Freq: 0.00299398
1b4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b4     ld  R7, [R23, #64]	# int, #@loadL
1b8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1b8     ld  R28, [R23, #80]	# ptr, #@loadP
1bc +   #@membar_volatile
	fence iorw iorw
1c0 +   lb  R30, [R10]	# byte, #@loadB
1c4 +   beq  R30, zr, B20	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

1c8     B27: #	out( B29 B28 ) &lt;- in( B26 )  Freq: 0.00149699
1c8 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
1cc +   bne  R7, zr, B29	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

1d0     B28: #	out( B20 ) &lt;- in( B27 )  Freq: 0.000748495
1d0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
1d0     spill R23 -&gt; R11	# spill size = 64
1d4 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
204 +   j  B20	#@branch

208     B29: #	out( B20 ) &lt;- in( B27 )  Freq: 0.000748495
208 +   add R28, R28, R7	# ptr, #@addP_reg_reg
20c +   addi  R7, R7, #-8	#@addL_reg_imm
210 +   sd  R10, [R28, #-8]	# ptr, #@storeP
214 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
214     sd  R7, [R23, #64]	# long, #@storeL
218 +   j  B20	#@branch

21c     B30: #	out( B5 B31 ) &lt;- in( B4 )  Freq: 0.000999985
21c +   lwu  R7, [R11, #24]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$HashIterator.current
220 +   decode_heap_oop  R10, R7	#@decodeHeapOop
224 +   beq   R10, zr, B5	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

228     B31: #	out( B46 B32 ) &lt;- in( B30 )  Freq: 0.000499993
228 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
228     ld  R7, [R23, #32]	# int, #@loadL
22c +   beq  R7, zr, B46	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

230     B32: #	out( B5 ) &lt;- in( B31 )  Freq: 0.000499493
230 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
230     ld  R28, [R23, #48]	# ptr, #@loadP
234 +   add R28, R28, R7	# ptr, #@addP_reg_reg
238 +   addi  R7, R7, #-8	#@addL_reg_imm
23c +   sd  R10, [R28, #-8]	# ptr, #@storeP
240 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
240     sd  R7, [R23, #32]	# long, #@storeL
244 +   j  B5	#@branch

248     B33: #	out( B8 B34 ) &lt;- in( B7 )  Freq: 0.000999985
248 +   lwu  R7, [R21, #20]	# loadN, compressed ptr, #@loadN ! Field: java/util/HashMap$HashIterator.next
24c +   decode_heap_oop  R10, R7	#@decodeHeapOop
250 +   beq   R10, zr, B8	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

254     B34: #	out( B47 B35 ) &lt;- in( B33 )  Freq: 0.000499993
254 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
254     ld  R7, [R23, #32]	# int, #@loadL
258 +   beq  R7, zr, B47	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

25c     B35: #	out( B8 ) &lt;- in( B34 )  Freq: 0.000499493
25c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
25c     ld  R28, [R23, #48]	# ptr, #@loadP
260 +   add R28, R28, R7	# ptr, #@addP_reg_reg
264 +   addi  R7, R7, #-8	#@addL_reg_imm
268 +   sd  R10, [R28, #-8]	# ptr, #@storeP
26c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
26c     sd  R7, [R23, #32]	# long, #@storeL
270 +   j  B8	#@branch

274     B36: #	out( B7 B37 ) &lt;- in( B6 )  Freq: 0.000998998
274 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
274     ld  R7, [R23, #64]	# int, #@loadL
278 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
278     ld  R28, [R23, #80]	# ptr, #@loadP
27c +   #@membar_volatile
	fence iorw iorw
280 +   lb  R30, [R10]	# byte, #@loadB
284 +   beq  R30, zr, B7	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

288     B37: #	out( B39 B38 ) &lt;- in( B36 )  Freq: 0.000499499
288 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
28c +   bne  R7, zr, B39	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

290     B38: #	out( B7 ) &lt;- in( B37 )  Freq: 0.00024975
290 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
290     spill R23 -&gt; R11	# spill size = 64
294 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
2c4 +   j  B7	#@branch

2c8     B39: #	out( B7 ) &lt;- in( B37 )  Freq: 0.00024975
2c8 +   add R28, R28, R7	# ptr, #@addP_reg_reg
2cc +   addi  R7, R7, #-8	#@addL_reg_imm
2d0 +   sd  R10, [R28, #-8]	# ptr, #@storeP
2d4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2d4     sd  R7, [R23, #64]	# long, #@storeL
2d8 +   j  B7	#@branch

2dc     B40: #	out( B11 B41 ) &lt;- in( B10 )  Freq: 0.000997999
2dc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2dc     ld  R7, [R23, #64]	# int, #@loadL
2e0 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2e0     ld  R28, [R23, #80]	# ptr, #@loadP
2e4 +   #@membar_volatile
	fence iorw iorw
2e8 +   lb  R29, [R10]	# byte, #@loadB
2ec +   beq  R29, zr, B11	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

2f0     B41: #	out( B43 B42 ) &lt;- in( B40 )  Freq: 0.000499
2f0 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
2f4 +   bne  R7, zr, B43	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

2f8     B42: #	out( B11 ) &lt;- in( B41 )  Freq: 0.0002495
2f8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
2f8     spill R23 -&gt; R11	# spill size = 64
2fc +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
32c +   j  B11	#@branch

330     B43: #	out( B11 ) &lt;- in( B41 )  Freq: 0.0002495
330 +   add R28, R28, R7	# ptr, #@addP_reg_reg
334 +   addi  R7, R7, #-8	#@addL_reg_imm
338 +   sd  R10, [R28, #-8]	# ptr, #@storeP
33c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
33c     sd  R7, [R23, #64]	# long, #@storeL
340 +   j  B11	#@branch

344     B44: #	out( N565 ) &lt;- in( B15 )  Freq: 3.03982e-06
344 +   li R11, #-28	# int, #@loadConI
348     spill R21 -&gt; [sp, #8]	# spill size = 64
34c +   spill R29 -&gt; [sp, #16]	# spill size = 32
350 +   spill R20 -&gt; [sp, #24]	# spill size = 64
354     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.HashMap$HashIterator::nextNode @ bci:90 (line 1601) L[0]=sp + #8 L[1]=R8 L[2]=sp + #24 STK[0]=sp + #8 STK[1]=R8 STK[2]=sp + #16
        # OopMap {fp=Oop [8]=Oop [24]=Oop off=856/0x358}
358     #@ShouldNotReachHere

364     B45: #	out( B17 ) &lt;- in( B24 )  Freq: 1.49995e-06
364 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
364     spill R23 -&gt; R11	# spill size = 64
368 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
398 +   j  B17	#@branch

39c     B46: #	out( B5 ) &lt;- in( B31 )  Freq: 4.99986e-07
39c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
39c     spill R23 -&gt; R11	# spill size = 64
3a0 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
3d0 +   j  B5	#@branch

3d4     B47: #	out( B8 ) &lt;- in( B34 )  Freq: 4.99986e-07
3d4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
3d4     spill R23 -&gt; R11	# spill size = 64
3d8 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
408 +   j  B8	#@branch

40c     B48: #	out( N565 ) &lt;- in( B2 )  Freq: 4.76837e-07
40c +   li R11, #-187	# int, #@loadConI
410     spill R21 -&gt; [sp, #0]	# spill size = 64
414 +   spill R20 -&gt; [sp, #8]	# spill size = 64
418 +   spill R7 -&gt; [sp, #16]	# spill size = 32
41c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap$HashIterator::nextNode @ bci:16 (line 1596) L[0]=sp + #0 L[1]=_ L[2]=sp + #8 STK[0]=sp + #16 STK[1]=R8
        # OopMap {[0]=Oop [8]=Oop off=1056/0x420}
420     #@ShouldNotReachHere

42c     B49: #	out( N565 ) &lt;- in( B3 )  Freq: 4.76836e-07
42c +   li R11, #-187	# int, #@loadConI
430     spill R21 -&gt; R8	# spill size = 64
434 +   spill R20 -&gt; [sp, #8]	# spill size = 64
438     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap$HashIterator::nextNode @ bci:28 (line 1598) L[0]=R8 L[1]=_ L[2]=sp + #8 STK[0]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=1084/0x43c}
43c     #@ShouldNotReachHere

448     B50: #	out( N565 ) &lt;- in( B1 )  Freq: 1.01328e-06
448 +   li R11, #-10	# int, #@loadConI
44c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap$HashIterator::nextNode @ bci:9 (line 1596) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # OopMap {off=1104/0x450}
450     #@ShouldNotReachHere

45c     B51: #	out( N565 ) &lt;- in( B12 )  Freq: 8.57891e-07
45c +   li R11, #-10	# int, #@loadConI
460     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.HashMap$HashIterator::nextNode @ bci:60 (line 1600) L[0]=_ L[1]=_ L[2]=_ STK[0]=#NULL
        # OopMap {off=1124/0x464}
464     #@ShouldNotReachHere

470     B52: #	out( N565 ) &lt;- in( B13 )  Freq: 4.03713e-07
470 +   li R11, #-187	# int, #@loadConI
474     spill R21 -&gt; [sp, #0]	# spill size = 64
478 +   spill R20 -&gt; [sp, #8]	# spill size = 64
47c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.HashMap$HashIterator::nextNode @ bci:65 (line 1600) L[0]=sp + #0 L[1]=R8 L[2]=sp + #8 STK[0]=R8
        # OopMap {fp=Oop [0]=Oop [8]=Oop off=1152/0x480}
480     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='629'>
----------------------- MetaData before Compile_id = 629 ------------------------
{method}
 - this oop:          0x00000040961a4ca8
 - method holder:     &apos;java/util/HashMap&apos;
 - constants:         0x000000409619f4e0 constant pool [610] {0x000000409619f4e0} for &apos;java/util/HashMap&apos; cache=0x00000040961a4fd8
 - access:            0x81000000  
 - name:              &apos;afterNodeInsertion&apos;
 - signature:         &apos;(Z)V&apos;
 - max stack:         1
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      30
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b960: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c5f8800
 - code size:         1
 - code start:        0x00000040961a4c88
 - code end (excl):   0x00000040961a4c89
 - method data:       0x0000004096486678
 - checked ex length: 0
 - linenumber start:  0x00000040961a4c89
 - localvar length:   2
 - localvar start:    0x00000040961a4c8e
 - compiled code: nmethod  25041  617       3       java.util.HashMap::afterNodeInsertion (1 bytes)

------------------------ OptoAssembly for Compile_id = 629 -----------------------
#
#  void ( java/util/HashMap:NotNull *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/HashMap:NotNull *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N13: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N13 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
054 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='640'>
----------------------- MetaData before Compile_id = 640 ------------------------
{method}
 - this oop:          0x0000004096432ce8
 - method holder:     &apos;java/util/zip/ZipUtils&apos;
 - constants:         0x0000004096431118 constant pool [325] {0x0000004096431118} for &apos;java/util/zip/ZipUtils&apos; cache=0x0000004096435158
 - access:            0x81000018  static final 
 - name:              &apos;SH&apos;
 - signature:         &apos;([BI)I&apos;
 - max stack:         5
 - max locals:        2
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400831ff40: 0xba i2c: 0x00000040139438c0 c2i: 0x0000004013943908 c2iUV: 0x00000040139438d4
 - compiled entry     0x000000400c606240
 - code size:         21
 - code start:        0x0000004096432cb0
 - code end (excl):   0x0000004096432cc5
 - method data:       0x0000004096435c10
 - checked ex length: 0
 - linenumber start:  0x0000004096432cc5
 - localvar length:   2
 - localvar start:    0x0000004096432cce
 - compiled code: nmethod  25554  637       3       java.util.zip.ZipUtils::SH (21 bytes)

------------------------ OptoAssembly for Compile_id = 640 -----------------------
#
#  int ( byte[int:&gt;=0]:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: byte[int:&gt;=0]:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 48 --
#r263 sp+44: in_preserve
#r262 sp+40: return address
#r261 sp+36: in_preserve
#r260 sp+32: saved fp register
#r259 sp+28: pad2, stack alignment
#r258 sp+24: pad2, stack alignment
#r257 sp+20: Fixed slot 1
#r256 sp+16: Fixed slot 0
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N1: #	out( B1 ) &lt;- in( B7 B5 B6 B4 )  Freq: 1

000     B1: #	out( B7 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=48
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #48
	
01c     addw  R7, R12, zr	#@convI2L_reg_reg
020     lwu  R29, [R11, #12]	# range, #@loadRange
024     NullCheck R11

024     B2: #	out( B5 B3 ) &lt;- in( B1 )  Freq: 0.999999
024 +   add R7, R11, R7	# ptr, #@addP_reg_reg
028 +   addiw  R28, R12, #1	#@addI_reg_imm
02c +   bgeu  R12, R29, B5	#@cmpU_branch  P=0.000001 C=-1.000000

030     B3: #	out( B6 B4 ) &lt;- in( B2 )  Freq: 0.999998
030 +   lbu  R8, [R7, #16]	# byte, #@loadUB
034 +   bgeu  R28, R29, B6	#@cmpU_branch  P=0.000001 C=-1.000000

038     B4: #	out( N1 ) &lt;- in( B3 )  Freq: 0.999997
038 +   lbu  R7, [R7, #17]	# byte, #@loadUB
03c +   slliw  R28, R7, (#8 &amp; 0x1f)	#@lShiftI_reg_imm
040 +   orr  R10, R28, R8	#@orI_reg_reg
044     # pop frame 48
	add  sp, sp, #48
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
05c +   ret	// return register, #@Ret

060     B5: #	out( N1 ) &lt;- in( B2 )  Freq: 1.01328e-06
060 +   spill R11 -&gt; [sp, #8]	# spill size = 64
064 +   spill R12 -&gt; [sp, #4]	# spill size = 32
068 +   li R11, #-28	# int, #@loadConI
06c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.zip.ZipUtils::SH @ bci:2 (line 203) L[0]=sp + #8 L[1]=sp + #4 STK[0]=sp + #8 STK[1]=sp + #4
        # OopMap {[8]=Oop off=112/0x70}
070     #@ShouldNotReachHere

07c     B6: #	out( N1 ) &lt;- in( B3 )  Freq: 1.01328e-06
07c +   spill R11 -&gt; [sp, #0]	# spill size = 64
080 +   spill R28 -&gt; [sp, #8]	# spill size = 32
084 +   li R11, #-28	# int, #@loadConI
088     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.zip.ZipUtils::SH @ bci:11 (line 203) L[0]=_ L[1]=_ STK[0]=R8 STK[1]=sp + #0 STK[2]=sp + #8
        # OopMap {[0]=Oop off=140/0x8c}
08c     #@ShouldNotReachHere

098     B7: #	out( N1 ) &lt;- in( B1 )  Freq: 1.01328e-06
098 +   li R11, #-10	# int, #@loadConI
09c     spill R12 -&gt; R8	# spill size = 32
0a0     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.zip.ZipUtils::SH @ bci:2 (line 203) L[0]=_ L[1]=_ STK[0]=#NULL STK[1]=R8
        # OopMap {off=164/0xa4}
0a4 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='646'>
----------------------- MetaData before Compile_id = 646 ------------------------
{method}
 - this oop:          0x0000004096423570
 - method holder:     &apos;java/util/zip/ZipCoder$UTF8ZipCoder&apos;
 - constants:         0x0000004096422ea0 constant pool [64] {0x0000004096422ea0} for &apos;java/util/zip/ZipCoder$UTF8ZipCoder&apos; cache=0x00000040964236c8
 - access:            0xc1000000  
 - name:              &apos;checkedHash&apos;
 - signature:         &apos;([BII)I&apos;
 - max stack:         5
 - max locals:        7
 - size of params:    4
 - method size:       13
 - highest level:     3
 - vtable index:      12
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400831abc0: 0xbbaa i2c: 0x0000004013944340 c2i: 0x0000004013944390 c2iUV: 0x000000401394435c
 - compiled entry     0x000000400c606780
 - code size:         91
 - code start:        0x00000040964234a8
 - code end (excl):   0x0000004096423503
 - method data:       0x0000004096435df0
 - checked ex length: 1
 - checked ex start:  0x000000409642356c
 - linenumber start:  0x0000004096423503
 - localvar length:   7
 - localvar start:    0x0000004096423516
 - compiled code: nmethod  25691  639       3       java.util.zip.ZipCoder$UTF8ZipCoder::checkedHash (91 bytes)

------------------------ OptoAssembly for Compile_id = 646 -----------------------
#
#  int ( java/util/zip/ZipCoder$UTF8ZipCoder:NotNull:exact *, byte[int:&gt;=0]:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/util/zip/ZipCoder$UTF8ZipCoder:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: byte[int:&gt;=0]:exact *
#r016 c_rarg3   : parm 2: int
#r018 c_rarg4   : parm 3: int
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N350: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B45 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     addw  R31, R13, R14	#@addI_reg_reg
040 +   beq  R14, zr, B45	#@cmpI_reg_imm0_branch  P=0.000000 C=1023.000000

044     B2: #	out( B30 B3 ) &lt;- in( B1 )  Freq: 1
044 +   addw  R11, R31, zr	#@convI2L_reg_reg
048 +   li R7, #0	# int, #@loadConI
04c +   bge  R13, R31, B30	#@cmpI_branch  P=0.020098 C=50901.000000

050     B3: #	out( B37 B4 ) &lt;- in( B2 )  Freq: 0.979902
050     lwu  R28, [R12, #12]	# range, #@loadRange
054     NullCheck R12

054     B4: #	out( B37 B5 ) &lt;- in( B3 )  Freq: 0.979901
054 +   addi  R29, R11, #-1	#@addL_reg_imm
058 +   addw  R30, R28, zr	#@convI2L_reg_reg
05c +   bgeu  R13, R28, B37	#@cmpU_branch  P=0.000001 C=-1.000000

060     B5: #	out( B37 B6 ) &lt;- in( B4 )  Freq: 0.9799
060 +   bgeu  R29, R30, B37	#@cmpUL_branch  P=0.000001 C=-1.000000

064     B6: #	out( B7 ) &lt;- in( B5 )  Freq: 0.979899
064 +   addiw  R29, R13, #1	#@addI_reg_imm
068 +   li R16, #0	# int, #@loadConI

06c     B7: #	out( B42 B8 ) &lt;- in( B6 B9 ) Loop( B7-B9 inner pre of N242) Freq: 1.9598
06c +   addw  R30, R13, zr	#@convI2L_reg_reg
070 +   add R30, R12, R30	# ptr, #@addP_reg_reg
074 +   lb  R9, [R30, #16]	# byte, #@loadB
078 +   blt  R9, zr, B42	#@cmpI_reg_imm0_branch  P=0.000000 C=49878.000000

07c     B8: #	out( B10 B9 ) &lt;- in( B7 )  Freq: 1.9598
07c +   slliw  R10, R16, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
080 +   subw  R30, R10, R16	#@subI_reg_reg
084 +   addiw  R10, R13, #1	#@addI_reg_imm
088 +   addw  R16, R30, R9	#@addI_reg_reg
08c +   bge  R10, R29, B10	#@cmpI_loop  P=0.500000 C=49878.000000

090     B9: #	out( B7 ) &lt;- in( B8 )  Freq: 0.979898
090 +   spill R10 -&gt; R13	# spill size = 32
094 +   j  B7	#@branch

098     B10: #	out( B38 B11 ) &lt;- in( B8 )  Freq: 0.979898
098 +   li R29, #-2147483648	# int, #@loadConI
09c +   addiw  R17, R31, #-3	#@addI_reg_imm
0a0     CMove R17, (R31 lt R17), R17, R29	#@cmovI_cmpI
	
0a8 +   bge  R10, R17, B38	#@cmpI_branch  P=0.000001 C=-1.000000

0ac     B11: #	out( B39 B12 ) &lt;- in( B10 )  Freq: 0.979897
0ac +   li R19, #4000	# int, #@loadConI
0b4     spill R10 -&gt; R15	# spill size = 32
0b8 +   addiw  R30, R13, #4	#@addI_reg_imm
0bc +   # castII of R15, #@castII
0bc     bgeu  R15, R28, B39	#@cmpU_branch  P=0.000001 C=-1.000000

0c0     B12: #	out( B40 B13 ) &lt;- in( B11 )  Freq: 0.979896
0c0 +   bgeu  R10, R28, B40	#@cmpU_branch  P=0.000001 C=-1.000000

0c4     B13: #	out( B41 B14 ) &lt;- in( B12 )  Freq: 0.979895
0c4 +   bgeu  R30, R28, B41	#@cmpU_branch  P=0.000001 C=-1.000000

0c8     B14: #	out( B15 ) &lt;- in( B13 )  Freq: 0.979894
0c8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP

0c8     B15: #	out( B16 ) &lt;- in( B14 B21 ) Loop( B15-B21 ) Freq: 48.5207
0c8 +   subw  R29, R17, R15	#@subI_reg_reg
0cc     CMove R29, (R17 lt R15), R29, R7	#@cmovI_cmpI
	
0d4 +   CMove R29, (R29 gtu R19), R29, R19	#@cmovI_cmpU
	
0dc +   addw  R18, R29, R15	#@addI_reg_reg

0e0     B16: #	out( B31 B17 ) &lt;- in( B15 B20 ) Loop( B16-B20 inner main of N89 strip mined) Freq: 2413.99
0e0 +   addw  R29, R15, zr	#@convI2L_reg_reg
0e4 +   add R29, R12, R29	# ptr, #@addP_reg_reg
0e8 +   lb  R13, [R29, #16]	# byte, #@loadB
0ec +   slliw  R30, R16, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
0f0 +   subw  R10, R30, R16	#@subI_reg_reg
0f4 +   addw  R22, R10, R13	#@addI_reg_reg
0f8 +   lb  R20, [R29, #17]	# byte, #@loadB
0fc +   slliw  R30, R22, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
100 +   subw  R10, R30, R22	#@subI_reg_reg
104 +   addw  R24, R10, R20	#@addI_reg_reg
108 +   lb  R21, [R29, #18]	# byte, #@loadB
10c +   slliw  R30, R24, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
110 +   subw  R30, R30, R24	#@subI_reg_reg
114 +   addw  R30, R30, R21	#@addI_reg_reg
118 +   lb  R9, [R29, #19]	# byte, #@loadB
11c +   slliw  R10, R30, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
120 +   subw  R29, R10, R30	#@subI_reg_reg
124 +   blt  R13, zr, B31	#@cmpI_reg_imm0_branch  P=0.000000 C=49878.000000

128     B17: #	out( B32 B18 ) &lt;- in( B16 )  Freq: 2413.99
128 +   blt  R20, zr, B32	#@cmpI_reg_imm0_branch  P=0.000000 C=49878.000000

12c     B18: #	out( B33 B19 ) &lt;- in( B17 )  Freq: 2413.99
12c +   blt  R21, zr, B33	#@cmpI_reg_imm0_branch  P=0.000000 C=49878.000000

130     B19: #	out( B34 B20 ) &lt;- in( B18 )  Freq: 2413.99
130 +   blt  R9, zr, B34	#@cmpI_reg_imm0_branch  P=0.000000 C=49878.000000

134     B20: #	out( B16 B21 ) &lt;- in( B19 )  Freq: 2413.99
134 +   addiw  R15, R15, #4	#@addI_reg_imm
138 +   addw  R16, R29, R9	#@addI_reg_reg
13c +   blt  R15, R18, B16	#@cmpI_loop  P=0.979902 C=49878.000000

140     B21: #	out( B15 B22 ) &lt;- in( B20 )  Freq: 48.5159
140 +   ld  R29, [R23, #920]	# ptr, #@loadP
144 +   lwu zr, [R29]	# Safepoint: poll for GC, #@safePoint        # java.util.zip.ZipCoder$UTF8ZipCoder::checkedHash @ bci:64 (line 229) L[0]=_ L[1]=R12 L[2]=R15 L[3]=R14 L[4]=R31 L[5]=R16 L[6]=_
        # OopMap {c_rarg2=Oop off=324/0x144}
148 +   blt  R15, R17, B15	#@cmpI_branch  P=0.979902 C=49878.000000

14c     B22: #	out( B26 B23 ) &lt;- in( B38 B21 )  Freq: 0.975067
14c +   bge  R15, R31, B26	#@cmpI_branch  P=0.500000 C=-1.000000

150     B23: #	out( B43 B24 ) &lt;- in( B22 )  Freq: 0.487533
150 +   # castII of R15, #@castII
150     bgeu  R15, R28, B43	#@cmpU_branch  P=0.000001 C=-1.000000

154     B24: #	out( B44 B25 ) &lt;- in( B23 B25 ) Loop( B24-B25 inner post of N242) Freq: 0.975065
154 +   addw  R7, R15, zr	#@convI2L_reg_reg
158 +   add R7, R12, R7	# ptr, #@addP_reg_reg
15c +   lb  R9, [R7, #16]	# byte, #@loadB
160 +   slliw  R28, R16, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
164 +   subw  R7, R28, R16	#@subI_reg_reg
168 +   blt  R9, zr, B44	#@cmpI_reg_imm0_branch  P=0.000000 C=49878.000000

16c     B25: #	out( B24 B26 ) &lt;- in( B24 )  Freq: 0.975065
16c +   addiw  R15, R15, #1	#@addI_reg_imm
170 +   addw  R16, R7, R9	#@addI_reg_reg
174 +   blt  R15, R31, B24	#@cmpI_loop  P=0.500000 C=49878.000000

178     B26: #	out( B47 B27 ) &lt;- in( B25 B22 B30 )  Freq: 0.995164
178 +   addiw  R8, R31, #-1	#@addI_reg_imm
17c     lwu  R28, [R12, #12]	# range, #@loadRange
180     NullCheck R12

180     B27: #	out( B36 B28 ) &lt;- in( B26 )  Freq: 0.995163
180 +   add R7, R12, R11	# ptr, #@addP_reg_reg
184 +   bgeu  R8, R28, B36	#@cmpU_branch  P=0.000001 C=-1.000000

188     B28: #	out( B46 B29 ) &lt;- in( B27 )  Freq: 0.995162
188 +   lb  R8, [R7, #15]	# byte, #@loadB
18c +   li R7, #47	# int, #@loadConI
190 +   beq  R8, R7, B46	#@cmpI_branch  P=0.000000 C=1023.000000

194     B29: #	out( N350 ) &lt;- in( B28 )  Freq: 0.995161
194 +   slliw  R28, R16, (#5 &amp; 0x1f)	#@lShiftI_reg_imm
198 +   subw  R7, R28, R16	#@subI_reg_reg
19c +   addiw  R10, R7, #47	#@addI_reg_imm
1a0     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
1b8 +   ret	// return register, #@Ret

1bc     B30: #	out( B26 ) &lt;- in( B2 )  Freq: 0.0200978
1bc +   li R16, #0	# int, #@loadConI
1c0 +   j  B26	#@branch

1c4     B31: #	out( B35 ) &lt;- in( B16 )  Freq: 0.00120699
1c4 +   spill R13 -&gt; R9	# spill size = 32
1c8 +   spill R16 -&gt; R30	# spill size = 32
1cc +   j  B35	#@branch

1d0     B32: #	out( B35 ) &lt;- in( B17 )  Freq: 0.00120699
1d0 +   addiw  R15, R15, #1	#@addI_reg_imm
1d4     spill R20 -&gt; R9	# spill size = 32
1d8 +   spill R22 -&gt; R30	# spill size = 32
1dc +   j  B35	#@branch

1e0     B33: #	out( B35 ) &lt;- in( B18 )  Freq: 0.00120699
1e0 +   addiw  R15, R15, #2	#@addI_reg_imm
1e4     spill R21 -&gt; R9	# spill size = 32
1e8 +   spill R24 -&gt; R30	# spill size = 32
1ec +   j  B35	#@branch

1f0     B34: #	out( B35 ) &lt;- in( B19 )  Freq: 0.00120699
1f0 +   addiw  R15, R15, #3	#@addI_reg_imm

1f4     B35: #	out( N350 ) &lt;- in( B44 B42 B31 B33 B32 B34 )  Freq: 0.00482944
1f4 +   li R11, #-187	# int, #@loadConI
1f8     spill R12 -&gt; R8	# spill size = 64
1fc +   spill R15 -&gt; [sp, #0]	# spill size = 32
200 +   spill R14 -&gt; [sp, #4]	# spill size = 32
204 +   spill R31 -&gt; [sp, #8]	# spill size = 32
208 +   spill R30 -&gt; [sp, #12]	# spill size = 32
20c +   spill R9 -&gt; [sp, #20]	# spill size = 32
210     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.zip.ZipCoder$UTF8ZipCoder::checkedHash @ bci:27 (line 217) L[0]=_ L[1]=R8 L[2]=sp + #0 L[3]=sp + #4 L[4]=sp + #8 L[5]=sp + #12 L[6]=sp + #20 STK[0]=sp + #20
        # OopMap {fp=Oop off=532/0x214}
214     #@ShouldNotReachHere

220     B36: #	out( N350 ) &lt;- in( B27 )  Freq: 1.00838e-06
220 +   li R11, #-28	# int, #@loadConI
224     spill R16 -&gt; [sp, #0]	# spill size = 32
228 +   spill R12 -&gt; [sp, #8]	# spill size = 64
22c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.util.zip.ZipCoder$UTF8ZipCoder::checkedHash @ bci:72 (line 231) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=sp + #0 L[6]=_ STK[0]=sp + #8 STK[1]=R8
        # OopMap {[8]=Oop off=560/0x230}
230     #@ShouldNotReachHere

23c     B37: #	out( N350 ) &lt;- in( B5 B3 B4 )  Freq: 2.97874e-06
23c +   li R11, #-138	# int, #@loadConI
240     spill R12 -&gt; R8	# spill size = 64
244 +   spill R14 -&gt; [sp, #0]	# spill size = 32
248 +   spill R31 -&gt; [sp, #8]	# spill size = 32
24c +   spill R13 -&gt; [sp, #16]	# spill size = 32
250     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # java.util.zip.ZipCoder$UTF8ZipCoder::checkedHash @ bci:17 (line 215) L[0]=_ L[1]=R8 L[2]=sp + #16 L[3]=sp + #0 L[4]=sp + #8 L[5]=#0 L[6]=_ STK[0]=sp + #16 STK[1]=sp + #8
        # OopMap {fp=Oop off=596/0x254}
254     #@ShouldNotReachHere

260     B38: #	out( B22 ) &lt;- in( B10 )  Freq: 9.9291e-07
260 +   spill R10 -&gt; R15	# spill size = 32
264 +   j  B22	#@branch

268     B39: #	out( N350 ) &lt;- in( B11 )  Freq: 9.92909e-07
268     #@ShouldNotReachHere

274     B40: #	out( N350 ) &lt;- in( B12 )  Freq: 9.92908e-07
274     #@ShouldNotReachHere

280     B41: #	out( N350 ) &lt;- in( B13 )  Freq: 9.92907e-07
280     #@ShouldNotReachHere

28c     B42: #	out( B35 ) &lt;- in( B7 )  Freq: 9.79898e-07
28c +   spill R16 -&gt; R30	# spill size = 32
290 +   spill R13 -&gt; R15	# spill size = 32
294 +   j  B35	#@branch

298     B43: #	out( N350 ) &lt;- in( B23 )  Freq: 4.94007e-07
298     #@ShouldNotReachHere

2a4     B44: #	out( B35 ) &lt;- in( B24 )  Freq: 4.87533e-07
2a4 +   spill R16 -&gt; R30	# spill size = 32
2a8 +   j  B35	#@branch

2ac     B45: #	out( N350 ) &lt;- in( B1 )  Freq: 4.76837e-07
2ac +   li R11, #-187	# int, #@loadConI
2b0     spill R12 -&gt; R8	# spill size = 64
2b4 +   spill R14 -&gt; [sp, #4]	# spill size = 32
2b8 +   spill R13 -&gt; [sp, #8]	# spill size = 32
2bc     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.zip.ZipCoder$UTF8ZipCoder::checkedHash @ bci:1 (line 209) L[0]=_ L[1]=R8 L[2]=sp + #8 L[3]=sp + #4 L[4]=_ L[5]=_ L[6]=_ STK[0]=sp + #4
        # OopMap {fp=Oop off=704/0x2c0}
2c0     #@ShouldNotReachHere

2cc     B46: #	out( N350 ) &lt;- in( B28 )  Freq: 4.7453e-07
2cc +   li R11, #-187	# int, #@loadConI
2d0     spill R16 -&gt; [sp, #0]	# spill size = 32
2d4     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.util.zip.ZipCoder$UTF8ZipCoder::checkedHash @ bci:75 (line 231) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=sp + #0 L[6]=_ STK[0]=R8 STK[1]=#47
        # OopMap {off=728/0x2d8}
2d8     #@ShouldNotReachHere

2e4     B47: #	out( N350 ) &lt;- in( B26 )  Freq: 1.00838e-06
2e4 +   li R11, #-10	# int, #@loadConI
2e8     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.util.zip.ZipCoder$UTF8ZipCoder::checkedHash @ bci:72 (line 231) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=#NULL STK[1]=R8
        # OopMap {off=748/0x2ec}
2ec     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='653'>
----------------------- MetaData before Compile_id = 653 ------------------------
{method}
 - this oop:          0x000000409600fb68
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000000  
 - name:              &apos;coder&apos;
 - signature:         &apos;()B&apos;
 - max stack:         2
 - max locals:        1
 - size of params:    1
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b5c0: 0xb i2c: 0x00000040139d16c0 c2i: 0x00000040139d1704 c2iUV: 0x00000040139d16d0
 - compiled entry     0x000000400c4ae100
 - code size:         15
 - code start:        0x000000409600fb40
 - code end (excl):   0x000000409600fb4f
 - method data:       0x000000409634cdf0
 - checked ex length: 0
 - linenumber start:  0x000000409600fb4f
 - localvar length:   1
 - localvar start:    0x000000409600fb5a
 - compiled code: nmethod  26283    5       3       java.lang.String::coder (15 bytes)

------------------------ OptoAssembly for Compile_id = 653 -----------------------
#
#  byte ( java/lang/String:NotNull:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N15: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N15 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     lb  R10, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
040     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
058 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='658'>
----------------------- MetaData before Compile_id = 658 ------------------------
{method}
 - this oop:          0x0000004096391948
 - method holder:     &apos;jdk/internal/org/objectweb/asm/ByteVector&apos;
 - constants:         0x00000040963907f0 constant pool [102] {0x00000040963907f0} for &apos;jdk/internal/org/objectweb/asm/ByteVector&apos; cache=0x0000004096391e78
 - access:            0xc1000001  public 
 - name:              &apos;putUTF8&apos;
 - signature:         &apos;(Ljava/lang/String;)Ljdk/internal/org/objectweb/asm/ByteVector;&apos;
 - max stack:         5
 - max locals:        7
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      10
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824bb30: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x000000400c4b1300
 - code size:         144
 - code start:        0x0000004096391848
 - code end (excl):   0x00000040963918d8
 - method data:       0x00000040963d7818
 - checked ex length: 0
 - linenumber start:  0x00000040963918d8
 - localvar length:   7
 - localvar start:    0x00000040963918f2
 - compiled code: nmethod  26532   25       3       jdk.internal.org.objectweb.asm.ByteVector::putUTF8 (144 bytes)

------------------------ OptoAssembly for Compile_id = 658 -----------------------
#
#  jdk/internal/org/objectweb/asm/ByteVector * ( jdk/internal/org/objectweb/asm/ByteVector:NotNull *, java/lang/String:exact * )
#
#r012 c_rarg1:c_rarg1   : parm 0: jdk/internal/org/objectweb/asm/ByteVector:NotNull *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/String:exact *
# -- Old sp -- Framesize: 80 --
#r263 sp+76: in_preserve
#r262 sp+72: return address
#r261 sp+68: in_preserve
#r260 sp+64: saved fp register
#r259 sp+60: pad2, stack alignment
#r258 sp+56: pad2, stack alignment
#r257 sp+52: Fixed slot 1
#r256 sp+48: Fixed slot 0
#r275 sp+44: spill
#r274 sp+40: spill
#r273 sp+36: spill
#r272 sp+32: spill
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N558: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B61 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=80
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #80
	
03c     spill R12 -&gt; R16	# spill size = 64
040     lwu  R7, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
044     NullCheck R12

044     B2: #	out( B62 B3 ) &lt;- in( B1 )  Freq: 0.999999
044 +   decode_heap_oop  R7, R7	#@decodeHeapOop
048     lwu  R28, [R7, #12]	# range, #@loadRange
04c     NullCheck R7

04c     B3: #	out( B57 B4 ) &lt;- in( B2 )  Freq: 0.999998
04c +   lb  R7, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
050     spill R11 -&gt; R17	# spill size = 64
054 +   lw  R8, [R17, #12]	# int, #@loadI ! Field: jdk/internal/org/objectweb/asm/ByteVector.length
058 +   lwu  R11, [R11, #16]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/org/objectweb/asm/ByteVector.data
05c +   sraw  R28, R28, R7	#@rShiftI_reg_reg
060 +   li R30, #65535	# int, #@loadConI
068 +   addw  R29, R28, R8	#@addI_reg_reg
06c +   decode_heap_oop  R7, R11	#@decodeHeapOop
070 +   bgt  R28, R30, B57	#@cmpI_branch  P=0.000000 C=1023.000000

074     B4: #	out( B63 B5 ) &lt;- in( B3 )  Freq: 0.999997
074     lwu  R30, [R7, #12]	# range, #@loadRange
078     NullCheck R7

078     B5: #	out( B38 B6 ) &lt;- in( B4 )  Freq: 0.999996
078 +   srliw  R10, R28, (#8 &amp; 0x1f)	#@urShiftI_reg_imm
07c +   slliw  R31, R10, (#24 &amp; 0x1f)	#@lShiftI_reg_imm
080 +   addiw  R7, R29, #2	#@addI_reg_imm
084 +   sraiw  R31, R31, (#24 &amp; 0x1f)	#@rShiftI_reg_imm
088 +   bgt  R7, R30, B38	#@cmpI_branch  P=0.139785 C=1023.000000

08c     B6: #	out( B46 B7 ) &lt;- in( B40 B5 )  Freq: 0.999994
08c +   decode_heap_oop  R9, R11	#@decodeHeapOop
090 +   lwu  R29, [R9, #12]	# range, #@loadRange
094 +   addiw  R7, R8, #1	#@addI_reg_imm
098 +   addw  R30, R8, zr	#@convI2L_reg_reg
09c +   bgeu  R8, R29, B46	#@cmpU_branch  P=0.000001 C=-1.000000

0a0     B7: #	out( B47 B8 ) &lt;- in( B6 )  Freq: 0.999993
0a0 +   add R19, R9, R30	# ptr, #@addP_reg_reg
0a4 +   addiw  R31, R8, #2	#@addI_reg_imm
0a8 +   sb  R10, [R19, #16]	# byte, #@storeB
0ac +   bgeu  R7, R29, B47	#@cmpU_branch  P=0.000001 C=-1.000000

0b0     B8: #	out( B37 B9 ) &lt;- in( B7 )  Freq: 0.999992
0b0 +   sb  R28, [R19, #17]	# byte, #@storeB
0b4 +   ble  R28, zr, B37	#@cmpI_reg_imm0_branch  P=0.042604 C=24012.000000

0b8     B9: #	out( B48 B10 ) &lt;- in( B8 )  Freq: 0.957388
0b8 +   lwu  R30, [R16, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0bc +   lb  R7, [R16, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
0c0 +   decode_heap_oop  R18, R30	#@decodeHeapOop
0c4 +   bne  R7, zr, B48	#@cmpI_reg_imm0_branch  P=0.000001 C=-1.000000

0c8     B10: #	out( B48 B11 ) &lt;- in( B9 )  Freq: 0.957387
0c8     lwu  R30, [R18, #12]	# range, #@loadRange
0cc     NullCheck R18

0cc     B11: #	out( B48 B12 ) &lt;- in( B10 )  Freq: 0.957386
0cc +   addw  R7, R28, zr	#@convI2L_reg_reg
0d0 +   addw  R10, R30, zr	#@convI2L_reg_reg
0d4 +   addi  R11, R7, #-1	#@addL_reg_imm
0d8 +   bleu  R30, zr, B48	#@cmpUEqNeLeGt_reg_imm0_branch  P=0.000001 C=-1.000000

0dc     B12: #	out( B48 B13 ) &lt;- in( B11 )  Freq: 0.957385
0dc +   bgeu  R11, R10, B48	#@cmpUL_branch  P=0.000001 C=-1.000000

0e0     B13: #	out( B48 B14 ) &lt;- in( B12 )  Freq: 0.957384
0e0 +   lb  R12, [R18, #16]	# byte, #@loadB
0e4 +   addw  R24, R31, zr	#@convI2L_reg_reg
0e8 +   add  R10, R7, R24	#@addL_reg_reg
0ec +   andi  R15, R12, #255	#@andI_reg_imm
0f0 +   addw  R22, R29, zr	#@convI2L_reg_reg
0f4 +   addiw  R7, R15, #-1	#@addI_reg_imm
0f8 +   addi  R10, R10, #-1	#@addL_reg_imm
0fc +   li R11, #127	# int, #@loadConI
100 +   bgeu  R31, R29, B48	#@cmpU_branch  P=0.000001 C=-1.000000

104     B14: #	out( B48 B15 ) &lt;- in( B13 )  Freq: 0.957383
104 +   bgeu  R10, R22, B48	#@cmpUL_branch  P=0.000001 C=-1.000000

108     B15: #	out( B58 B16 ) &lt;- in( B14 )  Freq: 0.957382
108 +   li R10, #0	# int, #@loadConI
10c +   bgeu  R7, R11, B58	#@cmpU_branch  P=0.000000 C=22989.000000

110     B16: #	out( B29 B17 ) &lt;- in( B15 )  Freq: 0.957382
110 +   li R29, #-2147483648	# int, #@loadConI
114 +   addiw  R13, R28, #-3	#@addI_reg_imm
118     CMove R13, (R28 lt R13), R13, R29	#@cmovI_cmpI
	
120 +   li R14, #1	# int, #@loadConI
124 +   sb  R12, [R19, #18]	# byte, #@storeB
128 +   ble  R13, R14, B29	#@cmpI_branch  P=0.000001 C=-1.000000

12c     B17: #	out( B49 B18 ) &lt;- in( B16 )  Freq: 0.957381
12c +   addi  R31, R24, #1	#@addL_reg_imm
130 +   addi  R7, R24, #4	#@addL_reg_imm
134 +   li R29, #4	# int, #@loadConI
138 +   bgeu  R31, R22, B49	#@cmpUL_branch  P=0.000001 C=-1.000000

13c     B18: #	out( B51 B19 ) &lt;- in( B17 )  Freq: 0.95738
13c +   bleu  R30, R14, B51	#@cmpU_branch  P=0.000001 C=-1.000000

140     B19: #	out( B52 B20 ) &lt;- in( B18 )  Freq: 0.957379
140 +   bleu  R30, R29, B52	#@cmpU_branch  P=0.000001 C=-1.000000

144     B20: #	out( B50 B21 ) &lt;- in( B19 )  Freq: 0.957378
144 +   bgeu  R7, R22, B50	#@cmpUL_branch  P=0.000001 C=-1.000000

148     B21: #	out( B22 ) &lt;- in( B20 )  Freq: 0.957377
148 +   li R12, #4000	# int, #@loadConI
150      -- 	// R23=Thread::current(), empty, #@tlsLoadP

150     B22: #	out( B23 ) &lt;- in( B21 B28 ) Loop( B22-B28 ) Freq: 22.4491
150 +   subw  R7, R13, R14	#@subI_reg_reg
154     CMove R7, (R13 lt R14), R7, R10	#@cmovI_cmpI
	
15c +   CMove R7, (R7 gtu R12), R7, R12	#@cmovI_cmpU
	
164 +   addw  R19, R7, R14	#@addI_reg_reg
        nop 	# 4 bytes pad for loops and calls

170     B23: #	out( B41 B24 ) &lt;- in( B22 B27 ) Loop( B23-B27 inner main of N198 strip mined) Freq: 526.907
170 +   addw  R7, R14, zr	#@convI2L_reg_reg
174 +   add R21, R18, R7	# ptr, #@addP_reg_reg
178 +   addw  R31, R14, R8	#@addI_reg_reg
17c +   lb  R7, [R21, #16]	# byte, #@loadB
180 +   addw  R29, R31, zr	#@convI2L_reg_reg
184 +   add R20, R9, R29	# ptr, #@addP_reg_reg
188 +   andi  R15, R7, #255	#@andI_reg_imm
18c +   addiw  R29, R15, #-1	#@addI_reg_imm
190 +   bgeu  R29, R11, B41	#@cmpU_branch  P=0.000000 C=22989.000000

194     B24: #	out( B42 B25 ) &lt;- in( B23 )  Freq: 526.906
194 +   sb  R7, [R20, #18]	# byte, #@storeB
198 +   lb  R7, [R21, #17]	# byte, #@loadB
19c +   andi  R15, R7, #255	#@andI_reg_imm
1a0 +   addiw  R29, R15, #-1	#@addI_reg_imm
1a4 +   bgeu  R29, R11, B42	#@cmpU_branch  P=0.000000 C=22989.000000

1a8     B25: #	out( B43 B26 ) &lt;- in( B24 )  Freq: 526.906
1a8 +   sb  R7, [R20, #19]	# byte, #@storeB
1ac +   lb  R7, [R21, #18]	# byte, #@loadB
1b0 +   andi  R15, R7, #255	#@andI_reg_imm
1b4 +   addiw  R29, R15, #-1	#@addI_reg_imm
1b8 +   bgeu  R29, R11, B43	#@cmpU_branch  P=0.000000 C=22989.000000

1bc     B26: #	out( B44 B27 ) &lt;- in( B25 )  Freq: 526.906
1bc +   sb  R7, [R20, #20]	# byte, #@storeB
1c0 +   lb  R7, [R21, #19]	# byte, #@loadB
1c4 +   andi  R15, R7, #255	#@andI_reg_imm
1c8 +   addiw  R29, R15, #-1	#@addI_reg_imm
1cc +   addiw  R31, R31, #5	#@addI_reg_imm
1d0 +   bgeu  R29, R11, B44	#@cmpU_branch  P=0.000000 C=22989.000000

1d4     B27: #	out( B23 B28 ) &lt;- in( B26 )  Freq: 526.906
1d4 +   addiw  R14, R14, #4	#@addI_reg_imm
1d8 +   sb  R7, [R20, #21]	# byte, #@storeB
1dc +   blt  R14, R19, B23	#@cmpI_loop  P=0.957396 C=22989.000000

1e0     B28: #	out( B22 B29 ) &lt;- in( B27 )  Freq: 22.4481
1e0 +   spill R31 -&gt; R7	# spill size = 32
1e4 +   # castII of R7, #@castII
1e4     addiw  R29, R7, #1	#@addI_reg_imm
1e8 +   ld  R15, [R23, #920]	# ptr, #@loadP
1ec +   lwu zr, [R15]	# Safepoint: poll for GC, #@safePoint        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:134 (line 290) L[0]=R17 L[1]=R16 L[2]=R28 L[3]=R29 L[4]=R9 L[5]=R14 L[6]=_
        # OopMap {c_rarg6=Oop c_rarg7=Oop x9=Oop x18=Oop off=492/0x1ec}
1f0 +   blt  R14, R13, B22	#@cmpI_branch  P=0.957396 C=22989.000000

1f4     B29: #	out( B36 B30 ) &lt;- in( B16 B28 )  Freq: 0.956373
1f4 +   bge  R14, R28, B36	#@cmpI_branch  P=0.500000 C=-1.000000

1f8     B30: #	out( B53 B31 ) &lt;- in( B29 )  Freq: 0.478187
1f8 +   # castII of R14, #@castII
1f8     spill R14 -&gt; R7	# spill size = 32
1fc +   addw  R29, R14, zr	#@convI2L_reg_reg
200 +   # castII of R7, #@castII
200     addw  R31, R7, zr	#@convI2L_reg_reg
204 +   add  R29, R29, R24	#@addL_reg_reg
208 +   add  R31, R31, R24	#@addL_reg_reg
20c +   bgeu  R14, R30, B53	#@cmpU_branch  P=0.000001 C=-1.000000

210     B31: #	out( B54 B32 ) &lt;- in( B30 )  Freq: 0.478186
210 +   bgeu  R7, R30, B54	#@cmpU_branch  P=0.000001 C=-1.000000

214     B32: #	out( B55 B33 ) &lt;- in( B31 )  Freq: 0.478186
214 +   bgeu  R29, R22, B55	#@cmpUL_branch  P=0.000001 C=-1.000000

218     B33: #	out( B56 B34 ) &lt;- in( B32 )  Freq: 0.478185
218 +   bgeu  R31, R22, B56	#@cmpUL_branch  P=0.000001 C=-1.000000

21c     B34: #	out( B45 B35 ) &lt;- in( B33 B35 ) Loop( B34-B35 inner post of N594) Freq: 0.956369
21c +   addw  R7, R14, zr	#@convI2L_reg_reg
220 +   add R7, R18, R7	# ptr, #@addP_reg_reg
224 +   lb  R29, [R7, #16]	# byte, #@loadB
228 +   addw  R7, R14, R8	#@addI_reg_reg
22c +   andi  R15, R29, #255	#@andI_reg_imm
230 +   addw  R30, R7, zr	#@convI2L_reg_reg
234 +   addiw  R12, R15, #-1	#@addI_reg_imm
238 +   add R30, R9, R30	# ptr, #@addP_reg_reg
23c +   addiw  R31, R7, #2	#@addI_reg_imm
240 +   bgeu  R12, R11, B45	#@cmpU_branch  P=0.000000 C=22989.000000

244     B35: #	out( B34 B36 ) &lt;- in( B34 )  Freq: 0.956368
244 +   addiw  R14, R14, #1	#@addI_reg_imm
248 +   sb  R29, [R30, #18]	# byte, #@storeB
24c +   blt  R14, R28, B34	#@cmpI_loop  P=0.500000 C=22989.000000

250     B36: #	out( B37 ) &lt;- in( B35 B29 )  Freq: 0.956371
250 +   # castII of R31, #@castII
250     addiw  R31, R31, #1	#@addI_reg_imm

254     B37: #	out( N558 ) &lt;- in( B36 B8 )  Freq: 0.998974
254 +   sw  R31, [R17, #12]	# int, #@storeI ! Field: jdk/internal/org/objectweb/asm/ByteVector.length
258     spill R17 -&gt; R10	# spill size = 64
25c +   # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
274 +   ret	// return register, #@Ret

278     B38: #	out( B60 B39 ) &lt;- in( B5 )  Freq: 0.139784
278 +   spill R8 -&gt; [sp, #8]	# spill size = 32
27c +   spill R12 -&gt; R8	# spill size = 64
280 +   spill R31 -&gt; [sp, #20]	# spill size = 32
284 +   spill R10 -&gt; [sp, #16]	# spill size = 32
288 +   spill R17 -&gt; [sp, #0]	# spill size = 64
28c +   addiw  R12, R28, #2	#@addI_reg_imm
290     spill R28 -&gt; [sp, #12]	# spill size = 32
294 +   spill R17 -&gt; R11	# spill size = 64
298     CALL,static 0x00000040139d26c0	#@CallStaticJavaDirect jdk.internal.org.objectweb.asm.ByteVector::enlarge
        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:43 (line 281) L[0]=sp + #0 L[1]=R8 L[2]=sp + #12 L[3]=sp + #8 L[4]=_ L[5]=_ L[6]=_
        # OopMap {fp=Oop [0]=Oop off=668/0x29c}

29c     B39: #	out( B59 B40 ) &lt;- in( B38 )  Freq: 0.139782
        # Block is sole successor of call
29c +   spill [sp, #0] -&gt; R17	# spill size = 64
2a0 +   lwu  R11, [R17, #16]	# loadN, compressed ptr, #@loadN ! Field: jdk/internal/org/objectweb/asm/ByteVector.data
2a4 +   beq   R11, zr, B59	#@cmpP_narrowOop_imm0_branch  P=0.000001 C=-1.000000

2a8     B40: #	out( B6 ) &lt;- in( B39 )  Freq: 0.139781
2a8 +   spill R8 -&gt; R16	# spill size = 64
2ac +   spill [sp, #8] -&gt; R8	# spill size = 32
2b0 +   spill [sp, #12] -&gt; R28	# spill size = 32
2b4 +   spill [sp, #16] -&gt; R10	# spill size = 32
2b8 +   spill [sp, #20] -&gt; R31	# spill size = 32
2bc +   j  B6	#@branch

2c0     B41: #	out( B45 ) &lt;- in( B23 )  Freq: 0.000251249
2c0 +   addiw  R31, R31, #2	#@addI_reg_imm
2c4 +   j  B45	#@branch

2c8     B42: #	out( B45 ) &lt;- in( B24 )  Freq: 0.000251249
2c8 +   addiw  R14, R14, #1	#@addI_reg_imm
2cc +   addiw  R31, R31, #3	#@addI_reg_imm
2d0 +   j  B45	#@branch

2d4     B43: #	out( B45 ) &lt;- in( B25 )  Freq: 0.000251248
2d4 +   addiw  R14, R14, #2	#@addI_reg_imm
2d8 +   addiw  R31, R31, #4	#@addI_reg_imm
2dc +   j  B45	#@branch

2e0     B44: #	out( B45 ) &lt;- in( B26 )  Freq: 0.000251248
2e0 +   addiw  R14, R14, #3	#@addI_reg_imm

2e4     B45: #	out( N558 ) &lt;- in( B34 B58 B41 B43 B42 B44 )  Freq: 0.00100591
2e4 +   li R11, #-195	# int, #@loadConI
2e8     spill R31 -&gt; R8	# spill size = 32
2ec +   spill R9 -&gt; [sp, #0]	# spill size = 64
2f0 +   spill R14 -&gt; [sp, #8]	# spill size = 32
2f4 +   spill R15 -&gt; [sp, #16]	# spill size = 32
2f8 +   spill R17 -&gt; [sp, #24]	# spill size = 64
2fc +   spill R16 -&gt; [sp, #32]	# spill size = 64
300 +   spill R28 -&gt; [sp, #20]	# spill size = 32
304     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_fused_if&apos; action=&apos;reinterpret&apos;)
        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:93 (line 292) L[0]=sp + #24 L[1]=sp + #32 L[2]=sp + #20 L[3]=R8 L[4]=sp + #0 L[5]=sp + #8 L[6]=sp + #16 STK[0]=sp + #16 STK[1]=#1
        # OopMap {[0]=Oop [24]=Oop [32]=Oop off=776/0x308}
308     #@ShouldNotReachHere

314     B46: #	out( N558 ) &lt;- in( B6 )  Freq: 1.01327e-06
314 +   li R11, #-28	# int, #@loadConI
318     spill R9 -&gt; [sp, #8]	# spill size = 64
31c +   spill R17 -&gt; [sp, #16]	# spill size = 64
320 +   spill R16 -&gt; [sp, #24]	# spill size = 64
324 +   spill R28 -&gt; [sp, #32]	# spill size = 32
328 +   spill R7 -&gt; [sp, #36]	# spill size = 32
32c +   spill R31 -&gt; [sp, #40]	# spill size = 32
330     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:63 (line 288) L[0]=sp + #16 L[1]=sp + #24 L[2]=sp + #32 L[3]=sp + #36 L[4]=sp + #8 L[5]=_ L[6]=_ STK[0]=sp + #8 STK[1]=R8 STK[2]=sp + #40
        # OopMap {[8]=Oop [16]=Oop [24]=Oop off=820/0x334}
334     #@ShouldNotReachHere

340     B47: #	out( N558 ) &lt;- in( B7 )  Freq: 1.01327e-06
340 +   slliw  R29, R28, (#24 &amp; 0x1f)	#@lShiftI_reg_imm
344 +   sraiw  R8, R29, (#24 &amp; 0x1f)	#@rShiftI_reg_imm
348 +   li R11, #-28	# int, #@loadConI
34c     spill R31 -&gt; [sp, #0]	# spill size = 32
350 +   spill R9 -&gt; [sp, #16]	# spill size = 64
354 +   spill R17 -&gt; [sp, #24]	# spill size = 64
358 +   spill R16 -&gt; [sp, #32]	# spill size = 64
35c +   spill R28 -&gt; [sp, #4]	# spill size = 32
360 +   spill R7 -&gt; [sp, #40]	# spill size = 32
364     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:72 (line 289) L[0]=sp + #24 L[1]=sp + #32 L[2]=sp + #4 L[3]=sp + #0 L[4]=sp + #16 L[5]=_ L[6]=_ STK[0]=sp + #16 STK[1]=sp + #40 STK[2]=R8
        # OopMap {[16]=Oop [24]=Oop [32]=Oop off=872/0x368}
368     #@ShouldNotReachHere

374     B48: #	out( N558 ) &lt;- in( B14 B9 B10 B11 B12 B13 )  Freq: 5.79517e-06
374 +   li R11, #-138	# int, #@loadConI
378     spill R31 -&gt; R8	# spill size = 32
37c +   spill R9 -&gt; [sp, #0]	# spill size = 64
380 +   spill R17 -&gt; [sp, #8]	# spill size = 64
384 +   spill R16 -&gt; [sp, #16]	# spill size = 64
388 +   spill R28 -&gt; [sp, #28]	# spill size = 32
38c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;predicate&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:79 (line 290) L[0]=sp + #8 L[1]=sp + #16 L[2]=sp + #28 L[3]=R8 L[4]=sp + #0 L[5]=#0 L[6]=_ STK[0]=#0 STK[1]=sp + #28
        # OopMap {[0]=Oop [8]=Oop [16]=Oop off=912/0x390}
390     #@ShouldNotReachHere

39c     B49: #	out( N558 ) &lt;- in( B17 )  Freq: 9.70094e-07
39c     #@ShouldNotReachHere

3a8     B50: #	out( N558 ) &lt;- in( B20 )  Freq: 9.70091e-07
3a8     #@ShouldNotReachHere

3b4     B51: #	out( N558 ) &lt;- in( B18 )  Freq: 9.5738e-07
3b4     #@ShouldNotReachHere

3c0     B52: #	out( N558 ) &lt;- in( B19 )  Freq: 9.57379e-07
3c0     #@ShouldNotReachHere

3cc     B53: #	out( N558 ) &lt;- in( B30 )  Freq: 4.84536e-07
3cc     #@ShouldNotReachHere

3d8     B54: #	out( N558 ) &lt;- in( B31 )  Freq: 4.84536e-07
3d8     #@ShouldNotReachHere

3e4     B55: #	out( N558 ) &lt;- in( B32 )  Freq: 4.84535e-07
3e4     #@ShouldNotReachHere

3f0     B56: #	out( N558 ) &lt;- in( B33 )  Freq: 4.84535e-07
3f0     #@ShouldNotReachHere

3fc     B57: #	out( N558 ) &lt;- in( B3 )  Freq: 4.76836e-07
3fc +   li R11, #-187	# int, #@loadConI
400     spill R17 -&gt; R8	# spill size = 64
404 +   spill R12 -&gt; [sp, #0]	# spill size = 64
408 +   spill R28 -&gt; [sp, #12]	# spill size = 32
40c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:8 (line 276) L[0]=R8 L[1]=sp + #0 L[2]=sp + #12 L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=sp + #12 STK[1]=#65535
        # OopMap {fp=Oop [0]=Oop off=1040/0x410}
410     #@ShouldNotReachHere

41c     B58: #	out( B45 ) &lt;- in( B15 )  Freq: 4.56515e-07
41c +   li R14, #0	# int, #@loadConI
420 +   j  B45	#@branch

424     B59: #	out( N558 ) &lt;- in( B39 )  Freq: 1.41638e-07
424 +   li R11, #-10	# int, #@loadConI
428     spill [sp, #8] -&gt; R8	# spill size = 32
42c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:63 (line 288) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=#NULL STK[1]=R8 STK[2]=sp + #20
        # OopMap {off=1072/0x430}
430     #@ShouldNotReachHere

43c     B60: #	out( N558 ) &lt;- in( B38 )  Freq: 1.39784e-06
43c      -- 	// exception oop; no code emitted, #@CreateException
43c +   spill R10 -&gt; R11	# spill size = 64
440 +   # pop frame 80
	add  sp, sp, #80
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	
44c +   j rethrow_stub	#@RethrowException

454     B61: #	out( N558 ) &lt;- in( B1 )  Freq: 1.01328e-06
454 +   li R11, #-10	# int, #@loadConI
458     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:1 (line 275) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=#NULL
        # OopMap {off=1116/0x45c}
45c     #@ShouldNotReachHere

468     B62: #	out( N558 ) &lt;- in( B2 )  Freq: 1.01328e-06
468 +   li R11, #-10	# int, #@loadConI
46c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::length @ bci:4 (line 1474) L[0]=_ STK[0]=#NULL
        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:1 (line 275) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_
        # OopMap {off=1136/0x470}
470     #@ShouldNotReachHere

47c     B63: #	out( N558 ) &lt;- in( B4 )  Freq: 1.01328e-06
47c +   li R11, #-10	# int, #@loadConI
480     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;null_check&apos; action=&apos;maybe_recompile&apos;)
        # jdk.internal.org.objectweb.asm.ByteVector::putUTF8 @ bci:35 (line 280) L[0]=_ L[1]=_ L[2]=_ L[3]=_ L[4]=_ L[5]=_ L[6]=_ STK[0]=_ STK[1]=#NULL
        # OopMap {off=1156/0x484}
484     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='660'>
----------------------- MetaData before Compile_id = 660 ------------------------
{method}
 - this oop:          0x000000409600a890
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000001  public 
 - name:              &apos;equals&apos;
 - signature:         &apos;(Ljava/lang/Object;)Z&apos;
 - max stack:         3
 - max locals:        3
 - size of params:    2
 - method size:       13
 - highest level:     4
 - vtable index:      1
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824bb30: 0xbb i2c: 0x00000040139d7c40 c2i: 0x00000040139d7c88 c2iUV: 0x00000040139d7c54
 - compiled entry     0x00000040139d7c88
 - code size:         56
 - code start:        0x000000409600a820
 - code end (excl):   0x000000409600a858
 - method data:       0x00000040963f5748
 - checked ex length: 0
 - linenumber start:  0x000000409600a858
 - localvar length:   3
 - localvar start:    0x000000409600a86a

------------------------ OptoAssembly for Compile_id = 660 -----------------------
#
#  bool ( java/lang/String:NotNull:exact *, java/lang/Object * )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: java/lang/Object *
# -- Old sp -- Framesize: 64 --
#r263 sp+60: in_preserve
#r262 sp+56: return address
#r261 sp+52: in_preserve
#r260 sp+48: saved fp register
#r259 sp+44: pad2, stack alignment
#r258 sp+40: pad2, stack alignment
#r257 sp+36: Fixed slot 1
#r256 sp+32: Fixed slot 0
#r271 sp+28: spill
#r270 sp+24: spill
#r269 sp+20: spill
#r268 sp+16: spill
#r267 sp+12: spill
#r266 sp+ 8: spill
#r265 sp+ 4: spill
#r264 sp+ 0: spill
#
000     N113: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B12 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=64
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #64
	
03c     beq  R11, R12, B12	#@cmpP_branch  P=0.065691 C=5465.000000

040     B2: #	out( B9 B3 ) &lt;- in( B1 )  Freq: 0.934309
040 +   beq   R12, zr, B9	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

044     B3: #	out( B16 B4 ) &lt;- in( B2 )  Freq: 0.933375
044 +   lwu  R7, [R12, #8]	# loadNKlass, compressed class ptr, #@loadNKlass
048 +   mv  R29, narrowklass: precise klass java/lang/String: 0x00000040d000df20:Constant:exact *	# compressed klass ptr, #@loadConNKlass
058 +   lb  R28, [R11, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
05c +   bne  R7, R29, B16	#@cmpN_branch  P=0.000000 C=-1.000000

060     B4: #	out( B15 B5 ) &lt;- in( B3 )  Freq: 0.933375
060 +   # checkcastPP of R12, #@checkCastPP
060     lb  R8, [R12, #16]	# byte, #@loadB ! Field: java/lang/String.coder (constant)
064 +   bne  R28, R8, B15	#@cmpI_branch  P=0.000000 C=5105.000000

068     B5: #	out( B13 B6 ) &lt;- in( B4 )  Freq: 0.933375
068 +   lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
06c +   decode_heap_oop  R7, R7	#@decodeHeapOop
070 +   lwu  R29, [R12, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
074 +   beq   R7, zr, B13	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

078     B6: #	out( B14 B7 ) &lt;- in( B5 )  Freq: 0.933374
078 +   decode_heap_oop  R28, R29	#@decodeHeapOop
07c +   lwu  R14, [R7, #12]	# range, #@loadRange
080 +   beq   R28, zr, B14	#@cmpP_imm0_branch  P=0.000001 C=-1.000000

084     B7: #	out( B9 B8 ) &lt;- in( B6 )  Freq: 0.933373
084 +   lwu  R30, [R28, #12]	# range, #@loadRange
088 +   bne  R14, R30, B9	#@cmpI_branch  P=0.001000 C=-1.000000

08c     B8: #	out( B11 B9 ) &lt;- in( B7 )  Freq: 0.932439
08c +   addi  R13, R28, #16	# ptr, #@addP_reg_imm
090 +   addi  R11, R7, #16	# ptr, #@addP_reg_imm
094     String Equals R11, R13, R14 -&gt; R10	#@string_equalsL
124 +   bne  R10, zr, B11	#@cmpI_reg_imm0_branch  P=0.195299 C=5105.000000

128     B9: #	out( B10 ) &lt;- in( B2 B8 B7 )  Freq: 0.752203
128 +   li R10, #0	# int, #@loadConI

12c     B10: #	out( N113 ) &lt;- in( B12 B9 B11 )  Freq: 0.999998
12c     # pop frame 64
	add  sp, sp, #64
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
144 +   ret	// return register, #@Ret

148     B11: #	out( B10 ) &lt;- in( B8 )  Freq: 0.182104
148 +   li R10, #1	# int, #@loadConI
14c +   j  B10	#@branch

150     B12: #	out( B10 ) &lt;- in( B1 )  Freq: 0.0656908
150 +   li R10, #1	# int, #@loadConI
154 +   j  B10	#@branch

158     B13: #	out( N113 ) &lt;- in( B5 )  Freq: 9.45769e-07
158     #@ShouldNotReachHere

164     B14: #	out( N113 ) &lt;- in( B6 )  Freq: 9.45768e-07
164     #@ShouldNotReachHere

170     B15: #	out( N113 ) &lt;- in( B4 )  Freq: 4.66687e-07
170 +   spill R11 -&gt; [sp, #0]	# spill size = 64
174 +   spill R12 -&gt; [sp, #8]	# spill size = 64
178 +   spill R28 -&gt; [sp, #16]	# spill size = 32
17c +   li R11, #-187	# int, #@loadConI
180     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;unstable_if&apos; action=&apos;reinterpret&apos;)
        # java.lang.String::equals @ bci:33 (line 1823) L[0]=sp + #0 L[1]=_ L[2]=sp + #8 STK[0]=sp + #16 STK[1]=R8
        # OopMap {[0]=Oop [8]=Oop off=388/0x184}
184     #@ShouldNotReachHere

190     B16: #	out( N113 ) &lt;- in( B3 )  Freq: 1e-35
190 +   spill R11 -&gt; R8	# spill size = 64
194 +   spill R12 -&gt; [sp, #8]	# spill size = 64
198 +   li R11, #-34	# int, #@loadConI
19c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;class_check&apos; action=&apos;maybe_recompile&apos;)
        # java.lang.String::equals @ bci:8 (line 1825) L[0]=R8 L[1]=sp + #8 L[2]=_ STK[0]=sp + #8
        # OopMap {fp=Oop [8]=Oop off=416/0x1a0}
1a0     #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='713'>
----------------------- MetaData before Compile_id = 713 ------------------------
{method}
 - this oop:          0x0000004096707800
 - method holder:     &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$44+0x00000008000c2c00&apos;
 - constants:         0x0000004096705dc8 constant pool [20] {0x0000004096705dc8} for &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$44+0x00000008000c2c00&apos; cache=0x0000004096707890
 - access:            0x81000001  public 
 - name:              &apos;applyAsInt&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         2
 - max locals:        2
 - size of params:    2
 - method size:       13
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b960: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x00000040139d7908
 - code size:         5
 - code start:        0x0000004096705fe8
 - code end (excl):   0x0000004096705fed
 - method data:       0x0000004096707e30
 - checked ex length: 0
 - localvar length:   0

------------------------ OptoAssembly for Compile_id = 713 -----------------------
#
#  int ( compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$44+0x00000008000c2c00:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$44+0x00000008000c2c00:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N17: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N17 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     li R7, #0	# int, #@loadConI
040     spill R12 -&gt; R10	# spill size = 32
044 +   CMove R10, (R12 ge R7), R10, R7	#@cmovI_cmpI
	
04c +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='717'>
----------------------- MetaData before Compile_id = 717 ------------------------
{method}
 - this oop:          0x000000409670cc40
 - method holder:     &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$50+0x00000008000c5a50&apos;
 - constants:         0x000000409670ca18 constant pool [20] {0x000000409670ca18} for &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$50+0x00000008000c5a50&apos; cache=0x000000409670ccd0
 - access:            0x81000001  public 
 - name:              &apos;applyAsInt&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         2
 - max locals:        2
 - size of params:    2
 - method size:       13
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b960: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x00000040139d7908
 - code size:         5
 - code start:        0x000000409670cc38
 - code end (excl):   0x000000409670cc3d
 - method data:       0x0000004096710000
 - checked ex length: 0
 - localvar length:   0

------------------------ OptoAssembly for Compile_id = 717 -----------------------
#
#  int ( compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$50+0x00000008000c5a50:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$50+0x00000008000c5a50:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N17: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N17 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     li R7, #1	# int, #@loadConI
040     spill R12 -&gt; R10	# spill size = 32
044 +   CMove R10, (R12 ge R7), R10, R7	#@cmovI_cmpI
	
04c +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='727'>
----------------------- MetaData before Compile_id = 727 ------------------------
{method}
 - this oop:          0x0000004096710760
 - method holder:     &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$52+0x00000008000c6000&apos;
 - constants:         0x0000004096710538 constant pool [20] {0x0000004096710538} for &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$52+0x00000008000c6000&apos; cache=0x00000040967107f0
 - access:            0x81000001  public 
 - name:              &apos;applyAsInt&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         2
 - max locals:        2
 - size of params:    2
 - method size:       13
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b960: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x00000040139d7908
 - code size:         5
 - code start:        0x0000004096710758
 - code end (excl):   0x000000409671075d
 - method data:       0x0000004096710998
 - checked ex length: 0
 - localvar length:   0

------------------------ OptoAssembly for Compile_id = 727 -----------------------
#
#  int ( compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$52+0x00000008000c6000:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$52+0x00000008000c6000:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N17: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N17 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     li R7, #-1	# int, #@loadConI
040     spill R12 -&gt; R10	# spill size = 32
044 +   CMove R10, (R12 ge R7), R10, R7	#@cmovI_cmpI
	
04c +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='730'>
----------------------- MetaData before Compile_id = 730 ------------------------
{method}
 - this oop:          0x00000040967110f8
 - method holder:     &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$54+0x00000008000c64a0&apos;
 - constants:         0x0000004096710ed0 constant pool [20] {0x0000004096710ed0} for &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$54+0x00000008000c64a0&apos; cache=0x0000004096711188
 - access:            0x81000001  public 
 - name:              &apos;applyAsInt&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         2
 - max locals:        2
 - size of params:    2
 - method size:       13
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b960: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x00000040139d7908
 - code size:         5
 - code start:        0x00000040967110f0
 - code end (excl):   0x00000040967110f5
 - method data:       0x0000004096711330
 - checked ex length: 0
 - localvar length:   0

------------------------ OptoAssembly for Compile_id = 730 -----------------------
#
#  int ( compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$54+0x00000008000c64a0:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$54+0x00000008000c64a0:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N17: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N17 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     li R7, #0	# int, #@loadConI
040     spill R12 -&gt; R10	# spill size = 32
044 +   CMove R10, (R12 le R7), R10, R7	#@cmovI_cmpI
	
04c +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='733'>
----------------------- MetaData before Compile_id = 733 ------------------------
{method}
 - this oop:          0x0000004096711a90
 - method holder:     &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$56+0x00000008000c6940&apos;
 - constants:         0x0000004096711868 constant pool [20] {0x0000004096711868} for &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$56+0x00000008000c6940&apos; cache=0x0000004096711b20
 - access:            0x81000001  public 
 - name:              &apos;applyAsInt&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         2
 - max locals:        2
 - size of params:    2
 - method size:       13
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b960: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x00000040139d7908
 - code size:         5
 - code start:        0x0000004096711a88
 - code end (excl):   0x0000004096711a8d
 - method data:       0x0000004096711cc8
 - checked ex length: 0
 - localvar length:   0

------------------------ OptoAssembly for Compile_id = 733 -----------------------
#
#  int ( compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$56+0x00000008000c6940:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$56+0x00000008000c6940:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N17: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N17 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     li R7, #1	# int, #@loadConI
040     spill R12 -&gt; R10	# spill size = 32
044 +   CMove R10, (R12 le R7), R10, R7	#@cmovI_cmpI
	
04c +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='737'>
----------------------- MetaData before Compile_id = 737 ------------------------
{method}
 - this oop:          0x0000004096712428
 - method holder:     &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$58+0x00000008000c6de0&apos;
 - constants:         0x0000004096712200 constant pool [20] {0x0000004096712200} for &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$58+0x00000008000c6de0&apos; cache=0x00000040967124b8
 - access:            0x81000001  public 
 - name:              &apos;applyAsInt&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         2
 - max locals:        2
 - size of params:    2
 - method size:       13
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b960: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x00000040139d7908
 - code size:         5
 - code start:        0x0000004096712420
 - code end (excl):   0x0000004096712425
 - method data:       0x0000004096712660
 - checked ex length: 0
 - localvar length:   0

------------------------ OptoAssembly for Compile_id = 737 -----------------------
#
#  int ( compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$58+0x00000008000c6de0:NotNull:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$58+0x00000008000c6de0:NotNull:exact *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N17: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N17 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     li R7, #-1	# int, #@loadConI
040     spill R12 -&gt; R10	# spill size = 32
044 +   CMove R10, (R12 le R7), R10, R7	#@cmovI_cmpI
	
04c +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
064 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='748'>
----------------------- MetaData before Compile_id = 748 ------------------------
{method}
 - this oop:          0x0000004096712d98
 - method holder:     &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$60+0x00000008000c7260&apos;
 - constants:         0x0000004096712b70 constant pool [20] {0x0000004096712b70} for &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$60+0x00000008000c7260&apos; cache=0x0000004096712e00
 - access:            0x81000001  public 
 - name:              &apos;applyAsInt&apos;
 - signature:         &apos;(II)I&apos;
 - max stack:         3
 - max locals:        3
 - size of params:    3
 - method size:       13
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x0000004008316ed0: 0xbaa i2c: 0x0000004013945bc0 c2i: 0x0000004013945c0c c2iUV: 0x0000004013945bd8
 - compiled entry     0x0000004013945c0c
 - code size:         6
 - code start:        0x0000004096712d90
 - code end (excl):   0x0000004096712d96
 - method data:       0x0000004096712fe8
 - checked ex length: 0
 - localvar length:   0

------------------------ OptoAssembly for Compile_id = 748 -----------------------
#
#  int ( compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$60+0x00000008000c7260:NotNull:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$60+0x00000008000c7260:NotNull:exact *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N17: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N17 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     spill R13 -&gt; R10	# spill size = 32
040 +   CMove R10, (R12 lt R13), R10, R12	#@cmovI_cmpI
	
048 +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
060 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='773'>
----------------------- MetaData before Compile_id = 773 ------------------------
{method}
 - this oop:          0x000000409600faa8
 - method holder:     &apos;java/lang/String&apos;
 - constants:         0x00000040960013b8 constant pool [1396]/operands[28] {0x00000040960013b8} for &apos;java/lang/String&apos; cache=0x00000040961445d8
 - access:            0x81000000  
 - name:              &apos;&lt;init&gt;&apos;
 - signature:         &apos;([BB)V&apos;
 - max stack:         3
 - max locals:        3
 - size of params:    3
 - method size:       13
 - highest level:     3
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x0000004008317380: 0xbba i2c: 0x0000004013945140 c2i: 0x000000401394518c c2iUV: 0x0000004013945158
 - compiled entry     0x000000400c4b5a80
 - code size:         15
 - code start:        0x000000409600fa68
 - code end (excl):   0x000000409600fa77
 - method data:       0x00000040963f4ef0
 - checked ex length: 0
 - linenumber start:  0x000000409600fa77
 - localvar length:   3
 - localvar start:    0x000000409600fa82
 - compiled code: nmethod  28341   35       3       java.lang.String::&lt;init&gt; (15 bytes)

------------------------ OptoAssembly for Compile_id = 773 -----------------------
#
#  void ( java/lang/String:NotNull:exact *, byte[int:&gt;=0]:exact *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/String:NotNull:exact *
#r014 c_rarg2:c_rarg2   : parm 1: byte[int:&gt;=0]:exact *
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N166: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B7 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c      -- 	// R23=Thread::current(), empty, #@tlsLoadP
03c     lb  R28, [R23, #56]	# byte, #@loadB
040     spill R13 -&gt; R18	# spill size = 32
044 +   spill R12 -&gt; R9	# spill size = 64
048 +   bne  R28, zr, B7	#@cmpI_reg_imm0_branch  P=0.001000 C=-1.000000

04c     B2: #	out( B3 ) &lt;- in( B1 )  Freq: 0.999
04c +   spill R11 -&gt; R19	# spill size = 64

050     B3: #	out( B6 B4 ) &lt;- in( B14 B9 B7 B2 )  Freq: 1
050 +   mv  R7, R19	# ptr -&gt; long, #@castP2X
054 +   mv  R28, R9	# ptr -&gt; long, #@castP2X
058 +   xorr  R28, R28, R7	#@xorL_reg_reg
05c +   encode_heap_oop  R29, R9	#@encodeHeapOop
060 +   srli  R28, R28, (#24 &amp; 0x3f)	#@urShiftL_reg_imm
064 +   sw  R29, [R19, #20]	# compressed ptr, #@storeN ! Field: java/lang/String.value (constant)
068 +   beq  R28, zr, B6	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

06c     B4: #	out( B6 B5 ) &lt;- in( B3 )  Freq: 0.999
06c +   beq   R9, zr, B6	#@cmpP_imm0_branch  P=0.001000 C=-1.000000

070     B5: #	out( B10 B6 ) &lt;- in( B4 )  Freq: 0.998001
070 +   srli  R7, R7, (#9 &amp; 0x3f)	#@urShiftL_reg_imm
074 +   mv  R28, 0x0000004021281000	# Byte Map Base, #@loadByteMapBase
080 +   add R10, R28, R7	# ptr, #@addP_reg_reg
084 +   lb  R28, [R10]	# byte, #@loadB
088 +   li R7, #4	# int, #@loadConI
08c +   bne  R28, R7, B10	#@cmpI_branch  P=0.001000 C=-1.000000

090     B6: #	out( N166 ) &lt;- in( B12 B13 B10 B5 B4 B3 )  Freq: 1
090 +   sb  R18, [R19, #16]	# byte, #@storeB ! Field: java/lang/String.coder (constant)
094 +   #@membar_release
	fence iorw ow
098 +   #@membar_release
	fence iorw ow
098 +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
0b0 +   ret	// return register, #@Ret

0b4     B7: #	out( B3 B8 ) &lt;- in( B1 )  Freq: 0.000999987
0b4 +   lwu  R7, [R11, #20]	# loadN, compressed ptr, #@loadN ! Field: java/lang/String.value (constant)
0b8 +   decode_heap_oop  R10, R7	#@decodeHeapOop
0bc     spill R11 -&gt; R19	# spill size = 64
0c0 +   beq   R10, zr, B3	#@cmpP_imm0_branch  P=0.500000 C=-1.000000

0c4     B8: #	out( B14 B9 ) &lt;- in( B7 )  Freq: 0.000499994
0c4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0c4     ld  R7, [R23, #32]	# int, #@loadL
0c8 +   beq  R7, zr, B14	#@cmpL_reg_imm0_branch  P=0.001000 C=-1.000000

0cc     B9: #	out( B3 ) &lt;- in( B8 )  Freq: 0.000499494
0cc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0cc     ld  R28, [R23, #48]	# ptr, #@loadP
0d0 +   add R28, R28, R7	# ptr, #@addP_reg_reg
0d4 +   addi  R7, R7, #-8	#@addL_reg_imm
0d8 +   sd  R10, [R28, #-8]	# ptr, #@storeP
0dc +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0dc     sd  R7, [R23, #32]	# long, #@storeL
0e0 +   j  B3	#@branch

0e4     B10: #	out( B6 B11 ) &lt;- in( B5 )  Freq: 0.000998001
0e4 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e4     ld  R7, [R23, #64]	# int, #@loadL
0e8 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
0e8     ld  R28, [R23, #80]	# ptr, #@loadP
0ec +   #@membar_volatile
	fence iorw iorw
0f0 +   lb  R30, [R10]	# byte, #@loadB
0f4 +   beq  R30, zr, B6	#@cmpI_reg_imm0_branch  P=0.500000 C=-1.000000

0f8     B11: #	out( B13 B12 ) &lt;- in( B10 )  Freq: 0.000499001
0f8 +   storestore (elided)
	sb zr, [R10]	# byte, #@storeimmCM0
0fc +   bne  R7, zr, B13	#@cmpL_reg_imm0_branch  P=0.500000 C=-1.000000

100     B12: #	out( B6 ) &lt;- in( B11 )  Freq: 0.0002495
100 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
100     spill R23 -&gt; R11	# spill size = 64
104 +   CALL, runtime leaf 0x000000400320808e	#@CallLeafDirect write_ref_field_post_entry
        No JVM State Info
        # 
134 +   j  B6	#@branch

138     B13: #	out( B6 ) &lt;- in( B11 )  Freq: 0.0002495
138 +   add R28, R28, R7	# ptr, #@addP_reg_reg
13c +   addi  R7, R7, #-8	#@addL_reg_imm
140 +   sd  R10, [R28, #-8]	# ptr, #@storeP
144 +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
144     sd  R7, [R23, #64]	# long, #@storeL
148 +   j  B6	#@branch

14c     B14: #	out( B3 ) &lt;- in( B8 )  Freq: 4.99987e-07
14c +    -- 	// R23=Thread::current(), empty, #@tlsLoadP
14c     spill R23 -&gt; R11	# spill size = 64
150 +   CALL, runtime leaf 0x0000004003207df4	#@CallLeafDirect write_ref_field_pre_entry
        No JVM State Info
        # 
180 +   j  B3	#@branch

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='774'>
----------------------- MetaData before Compile_id = 774 ------------------------
{method}
 - this oop:          0x0000004096713728
 - method holder:     &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$62+0x00000008000c76c0&apos;
 - constants:         0x0000004096713500 constant pool [20] {0x0000004096713500} for &apos;compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$62+0x00000008000c76c0&apos; cache=0x0000004096713790
 - access:            0x81000001  public 
 - name:              &apos;applyAsInt&apos;
 - signature:         &apos;(II)I&apos;
 - max stack:         3
 - max locals:        3
 - size of params:    3
 - method size:       13
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x0000004008316ed0: 0xbaa i2c: 0x0000004013945bc0 c2i: 0x0000004013945c0c c2iUV: 0x0000004013945bd8
 - compiled entry     0x0000004013945c0c
 - code size:         6
 - code start:        0x0000004096713720
 - code end (excl):   0x0000004096713726
 - method data:       0x0000004096713938
 - checked ex length: 0
 - localvar length:   0

------------------------ OptoAssembly for Compile_id = 774 -----------------------
#
#  int ( compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$62+0x00000008000c76c0:NotNull:exact *, int, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: compiler/intrinsics/math/TestMinMaxIntrinsics$$Lambda$62+0x00000008000c76c0:NotNull:exact *
#r014 c_rarg2   : parm 1: int
#r016 c_rarg3   : parm 2: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N17: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( N17 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     spill R12 -&gt; R10	# spill size = 32
040 +   CMove R10, (R12 lt R13), R10, R13	#@cmovI_cmpI
	
048 +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
060 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='786'>
----------------------- MetaData before Compile_id = 786 ------------------------
{method}
 - this oop:          0x0000004096704298
 - method holder:     &apos;compiler/intrinsics/math/TestMinMaxIntrinsics&apos;
 - constants:         0x0000004096703310 constant pool [240]/operands[112] {0x0000004096703310} for &apos;compiler/intrinsics/math/TestMinMaxIntrinsics&apos; cache=0x0000004096705228
 - access:            0x81000008  static 
 - name:              &apos;maxL2I&apos;
 - signature:         &apos;(JI)I&apos;
 - max stack:         3
 - max locals:        3
 - size of params:    3
 - method size:       13
 - vtable index:      -2
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x0000004008323910: 0xbea i2c: 0x0000004013937740 c2i: 0x0000004013937788 c2iUV: 0x0000004013937754
 - compiled entry     0x0000004013937788
 - code size:         7
 - code start:        0x0000004096704288
 - code end (excl):   0x000000409670428f
 - method data:       0x0000004096714018
 - checked ex length: 0
 - linenumber start:  0x000000409670428f
 - localvar length:   0

------------------------ OptoAssembly for Compile_id = 786 -----------------------
#
#  int ( long, half, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: long
#r014 c_rarg2   : parm 2: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N1: #	out( B1 ) &lt;- in( B1 )  Freq: 1

000     B1: #	out( N1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
01c     addw  R10, R11, zr	#@convL2I_reg
020     CMove R10, (R10 lt R12), R10, R12	#@cmovI_cmpI
	
028 +   # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
040 +   ret	// return register, #@Ret

--------------------------------------------------------------------------------
</opto_assembly>

============================= C2-compiled nmethod ==============================
<opto_assembly compile_id='791'>
----------------------- MetaData before Compile_id = 791 ------------------------
{method}
 - this oop:          0x00000040961e8fd0
 - method holder:     &apos;java/lang/CharacterDataLatin1&apos;
 - constants:         0x00000040961e89b8 constant pool [130] {0x00000040961e89b8} for &apos;java/lang/CharacterDataLatin1&apos; cache=0x00000040961eb818
 - access:            0x81000000  
 - name:              &apos;getProperties&apos;
 - signature:         &apos;(I)I&apos;
 - max stack:         3
 - max locals:        4
 - size of params:    2
 - method size:       13
 - highest level:     3
 - vtable index:      35
 - i2i entry:         0x00000040138ccac0
 - adapters:          AHE@0x000000400824b960: 0xba i2c: 0x00000040139d78c0 c2i: 0x00000040139d7908 c2iUV: 0x00000040139d78d4
 - compiled entry     0x000000400c4f0680
 - code size:         11
 - code start:        0x00000040961e8f88
 - code end (excl):   0x00000040961e8f93
 - method data:       0x00000040965ed348
 - checked ex length: 0
 - linenumber start:  0x00000040961e8f93
 - localvar length:   4
 - localvar start:    0x00000040961e8f9e
 - compiled code: nmethod  28670  117       3       java.lang.CharacterDataLatin1::getProperties (11 bytes)

------------------------ OptoAssembly for Compile_id = 791 -----------------------
#
#  int ( java/lang/CharacterDataLatin1:NotNull *, int )
#
#r012 c_rarg1:c_rarg1   : parm 0: java/lang/CharacterDataLatin1:NotNull *
#r014 c_rarg2   : parm 1: int
# -- Old sp -- Framesize: 32 --
#r263 sp+28: in_preserve
#r262 sp+24: return address
#r261 sp+20: in_preserve
#r260 sp+16: saved fp register
#r259 sp+12: pad2, stack alignment
#r258 sp+ 8: pad2, stack alignment
#r257 sp+ 4: Fixed slot 1
#r256 sp+ 0: Fixed slot 0
#
000     N35: #	out( B1 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
000     # MachUEPNode
	lwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]	# compressed klass
	beq t0, t1, ic_hit
	j, SharedRuntime::_ic_miss_stub	 # Inline cache check
	ic_hit:

        nop 	# 2 bytes pad for loops and calls

020     B1: #	out( B3 B2 ) &lt;- BLOCK HEAD IS JUNK  Freq: 1
020     # stack bang size=32
	sd  fp, [sp, #-16]
	sd  ra, [sp, #-8]
	sub sp, sp, #32
	
03c     li R28, #65535	# int, #@loadConI
044 +   li R7, #256	# int, #@loadConI
048 +   andr  R28, R12, R28	#@andI_reg_reg
04c +   bgeu  R28, R7, B3	#@cmpU_branch  P=0.000001 C=-1.000000

050     B2: #	out( N35 ) &lt;- in( B1 )  Freq: 0.999999
050 +   addw  R7, R28, zr	#@convI2L_reg_reg
054 +   slli  R7, R7, (#2 &amp; 0x3f)	#@lShiftL_reg_imm
058 +   mv  R28, int[int:256]&lt;ciTypeArray length=256 type=&lt;ciTypeArrayKlass name=[I loaded=true ident=1144 address=0x00000040d001b7c0&gt; ident=1154 address=0x00000040d09be180&gt; *	# ptr, #@loadConP
070 +   add R7, R28, R7	# ptr, #@addP_reg_reg
074 +   lw  R10, [R7, #16]	# int, #@loadI
078     # pop frame 32
	add  sp, sp, #32
	ld  ra, [sp,#-16]
	ld  fp, [sp,#-8]
	# test polling word
	ld t0, [xthread,#912]
	bgtu sp, t0, #slow_path
090 +   ret	// return register, #@Ret

094     B3: #	out( N35 ) &lt;- in( B1 )  Freq: 1.01328e-06
094 +   li R11, #-28	# int, #@loadConI
098     spill R28 -&gt; R8	# spill size = 32
09c     CALL,static 0x00000040139d9ac0	#@CallStaticJavaDirect wrapper for: uncommon_trap(reason=&apos;range_check&apos; action=&apos;make_not_entrant&apos;)
        # java.lang.CharacterDataLatin1::getProperties @ bci:7 (line 74) L[0]=_ L[1]=_ L[2]=_ L[3]=_ STK[0]=#Ptr0x00000040d09be180 STK[1]=R8
        # OopMap {off=160/0xa0}
0a0 +   #@ShouldNotReachHere

--------------------------------------------------------------------------------
</opto_assembly>
<writer thread='3869227'/>
C1 Runtime statistics:
 _resolve_invoke_virtual_cnt:     147
 _resolve_invoke_opt_virtual_cnt: 458
 _resolve_invoke_static_cnt:      164
 _handle_wrong_method_cnt:        122
 _ic_miss_cnt:                    60
 _generic_arraycopystub_cnt:      0
 _byte_arraycopy_cnt:             0
 _short_arraycopy_cnt:            0
 _int_arraycopy_cnt:              0
 _long_arraycopy_cnt:             0
 _oop_arraycopy_cnt:              0
 _arraycopy_slowcase_cnt:         0
 _arraycopy_checkcast_cnt:        0
 _arraycopy_checkcast_attempt_cnt:0
 _new_type_array_slowcase_cnt:    0
 _new_object_array_slowcase_cnt:  2
 _new_instance_slowcase_cnt:      3
 _new_multi_array_slowcase_cnt:   0
 _monitorenter_slowcase_cnt:      8
 _monitorexit_slowcase_cnt:       8
 _patch_code_slowcase_cnt:        0
 _throw_range_check_exception_count:            0:
 _throw_index_exception_count:                  0:
 _throw_div0_exception_count:                   0:
 _throw_null_pointer_exception_count:           0:
 _throw_class_cast_exception_count:             0:
 _throw_incompatible_class_change_error_count:  0:
 _throw_count:                                  0:

<statistics type='deoptimization'>
Deoptimization traps recorded:
    23 (100.0%) total
    null_check/make_not_entrant/instanceof: 1 (4.3%)
              range_check/reinterpret/ifge: 1 (4.3%)
       range_check/make_not_entrant/baload: 1 (4.3%)
  class_check/maybe_recompile/invokeinterface: 4 (17.4%)
  bimorphic/maybe_recompile/invokeinterface: 4 (17.4%)
              unstable_if/reinterpret/ifeq: 2 (8.7%)
         unstable_if/reinterpret/if_icmpne: 2 (8.7%)
              unstable_if/reinterpret/ifne: 2 (8.7%)
               unstable_if/reinterpret/nop: 6 (26.1%)
</statistics>
<statistics type='SharedRuntime'>
   11 new instance requires GC
   33 new array requires GC
   60 inline cache miss in compiled
  122 wrong method
  164 unresolved static call site
  147 unresolved virtual call site
  458 unresolved opt virtual call site
28909 slow partial subtype
28877 unsafe array copies
AdapterHandlerTable: empty 112 longest 4 total 263 average 1.453039
AdapterHandlerTable: lookups 4919 buckets 5562 equals 4246 hits 4246 compact 4246
</statistics>
<statistics type='opto'>
--- Compiler Statistics ---
Methods seen: 1070  Methods parsed: 1070  Nodes created: 188334
Blocks parsed: 3035  Blocks seen: 4015
3447 original NULL checks - 2934 elided (85%); optimizer leaves 671,
363 made implicit (54%)
1 implicit null exceptions at runtime
CCP: 113  constants found: 0
Total frameslots = 816, Max frameslots = 36
Inserted 0 spill loads, 0 spill stores, 0 mem-mem moves and 0 copies.
Total load cost=      0, store cost =      0, mem-mem cost =  0.00, copy cost =     0.
Adjusted spill cost =       0.
Conservatively coalesced 326 copies, 0 pairs, 2791 post alloc.
Average allocation trips 1.732283
High Pressure Blocks = 0, Low Pressure Blocks = 0
Nops added 0 bytes to total of 137392 bytes, for 0.00%
Peephole: peephole rules applied: 0
PhaseIdealLoop=446, sum _unique=479245, long loops=0/0/0
</statistics>
<statistics type='intrinsic'>
Compiler intrinsic usage:
     9 ( 7.9%) _hashCode (worked,virtual)
     2 ( 1.8%) _getClass (worked)
    12 (10.5%) _min (worked)
     6 ( 5.3%) _max (worked)
    20 (17.5%) _arraycopy (worked)
    13 (11.4%) _currentThread (worked)
     2 ( 1.8%) _isArray (worked)
     3 ( 2.6%) _isPrimitive (worked)
     0 ( 0.0%) _compressStringC (disabled)
     6 ( 5.3%) _indexOfL_char (worked)
    18 (15.8%) _equalsL (worked)
     0 ( 0.0%) _hasNegatives (disabled)
    11 ( 9.6%) _Reference_refersTo0 (worked)
     1 ( 0.9%) _allocateUninitializedArray (worked)
     2 ( 1.8%) _copyMemory (worked)
     2 ( 1.8%) _putByte (worked)
     7 ( 6.1%) _compareAndSetInt (worked)
   114 (100.0%) total (worked,disabled,virtual)
</statistics>
<tty_done stamp='36.723'/>
</tty>
<hotspot_log_done stamp='36.723'/>
</hotspot_log>
